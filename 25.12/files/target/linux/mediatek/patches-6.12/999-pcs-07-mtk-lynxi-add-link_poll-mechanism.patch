From 7dfffc16b71099fd37e218af7e62e3adb56b0e41 Mon Sep 17 00:00:00 2001
From: Bo-Cun Chen <bc-bocun.chen@mediatek.com>
Date: Fri, 2 Jan 2026 09:44:08 +0800
Subject: [PATCH] net: pcs: mtk-lynxi: add link_poll mechanism

Signed-off-by: Bo-Cun Chen <bc-bocun.chen@mediatek.com>
---
 drivers/net/pcs/pcs-mtk-lynxi.c   | 217 +++++++++++++++++++-----------
 include/linux/pcs/pcs-mtk-lynxi.h |  38 ++++++
 2 files changed, 174 insertions(+), 81 deletions(-)

diff --git a/drivers/net/pcs/pcs-mtk-lynxi.c b/drivers/net/pcs/pcs-mtk-lynxi.c
index 7a7014d..95c6187 100644
--- a/drivers/net/pcs/pcs-mtk-lynxi.c
+++ b/drivers/net/pcs/pcs-mtk-lynxi.c
@@ -26,6 +26,7 @@
 #define SGMSYS_PCS_CONTROL_1		0x0
 #define SGMII_BMCR			GENMASK(15, 0)
 #define SGMII_BMSR			GENMASK(31, 16)
+#define SGMII_LINK_STATUS		BIT(18)
 #define SGMII_REF_CK_SEL		BIT(24)
 
 #define SGMSYS_PCS_DEVICE_ID		0x4
@@ -78,38 +79,6 @@
 
 #define MTK_NETSYS_V3_AMA_RGC3		0x128
 
-/* struct mtk_pcs_lynxi -  This structure holds each sgmii regmap andassociated
- *                         data
- * @regmap:                The register map pointing at the range used to setup
- *                         SGMII modes
- * @dev:                   Pointer to device owning the PCS
- * @ana_rgc3:              The offset of register ANA_RGC3 relative to regmap
- * @interface:             Currently configured interface mode
- * @pcs:                   Phylink PCS structure
- * @flags:                 Flags indicating hardware properties
- * @rstc:                  Reset controller
- * @sgmii_sel:             SGMII Register Clock
- * @sgmii_rx:              SGMII RX Clock
- * @sgmii_tx:              SGMII TX Clock
- * @node:                  List node
- */
-struct mtk_pcs_lynxi {
-	struct regmap		*regmap;
-	struct device		*dev;
-	u32			ana_rgc3;
-	phy_interface_t		interface;
-	struct			phylink_pcs pcs;
-	u32			flags;
-	unsigned int		neg_mode;
-	__ETHTOOL_DECLARE_LINK_MODE_MASK(advertising);
-	struct reset_control	*rstc;
-	struct clk		*sgmii_sel;
-	struct clk		*sgmii_rx;
-	struct clk		*sgmii_tx;
-	struct phy		*xfi_tphy;
-	struct list_head	node;
-};
-
 static LIST_HEAD(mtk_pcs_lynxi_instances);
 static DEFINE_MUTEX(instance_mutex);
 
@@ -118,7 +87,7 @@ static int mtk_pcs_lynxi_config(struct phylink_pcs *pcs, unsigned int neg_mode,
 				const unsigned long *advertising,
 				bool permit_pause_to_mac);
 
-static struct mtk_pcs_lynxi *pcs_to_mtk_pcs_lynxi(struct phylink_pcs *pcs)
+struct mtk_pcs_lynxi *pcs_to_mtk_pcs_lynxi(struct phylink_pcs *pcs)
 {
 	return container_of(pcs, struct mtk_pcs_lynxi, pcs);
 }
@@ -138,12 +107,24 @@ static unsigned int mtk_pcs_lynxi_inband_caps(struct phylink_pcs *pcs,
 	}
 }
 
-static void mtk_pcs_lynxi_get_state(struct phylink_pcs *pcs,
-				    struct phylink_link_state *state)
+static int mtk_pcs_lynxi_link_status(struct mtk_pcs_lynxi *mpcs)
 {
-	struct mtk_pcs_lynxi *mpcs = pcs_to_mtk_pcs_lynxi(pcs);
+	unsigned int val;
+
+	mutex_lock(&mpcs->regmap_lock);
+	regmap_read(mpcs->regmap, SGMSYS_PCS_CONTROL_1, &val);
+	mutex_unlock(&mpcs->regmap_lock);
+
+	return FIELD_GET(SGMII_LINK_STATUS, val);
+}
+
+static void mtk_pcs_lynxi_update_state(struct mtk_pcs_lynxi *mpcs)
+{
+	struct phylink_link_state *state = &mpcs->state;
 	unsigned int bm, bmsr, adv, rgc3, sgm_mode;
 
+	mutex_lock(&mpcs->regmap_lock);
+
 	/* Read the BMSR and LPA */
 	regmap_read(mpcs->regmap, SGMSYS_PCS_CONTROL_1, &bm);
 	bmsr = FIELD_GET(SGMII_BMSR, bm);
@@ -177,13 +158,34 @@ static void mtk_pcs_lynxi_get_state(struct phylink_pcs *pcs,
 			state->duplex = DUPLEX_FULL;
 	}
 
-	/* Continuously repeat re-configuration sequence until link comes up */
-	if (!state->link) {
-		mtk_pcs_lynxi_config(pcs, mpcs->neg_mode,
-				     state->interface, mpcs->advertising, false);
+	state->interface = mpcs->interface;
+
+	mutex_unlock(&mpcs->regmap_lock);
 }
 
-static void mtk_sgmii_reset(struct mtk_pcs_lynxi *mpcs)
+static void mtk_pcs_lynxi_get_state(struct phylink_pcs *pcs,
+				    struct phylink_link_state *state)
+{
+	struct mtk_pcs_lynxi *mpcs = pcs_to_mtk_pcs_lynxi(pcs);
+
+	/* Passing the advertising and lp_advertising parameters to
+	 * phylink_mii_c22_pcs_decode_state()in mtk_pcs_lynxi_update_state().
+	 */
+	linkmode_copy(mpcs->state.advertising, state->advertising);
+	linkmode_copy(mpcs->state.lp_advertising, state->lp_advertising);
+
+	/* When the interface of the mpcs is not initialized,
+	 * we should not report the states.
+	 */
+	if (mpcs->state.interface != PHY_INTERFACE_MODE_NA)
+		state->interface = mpcs->state.interface;
+
+	state->speed = mpcs->state.speed;
+	state->duplex = mpcs->state.duplex;
+	state->link = mpcs->state.link;
+}
+
+static void mtk_pcs_lynxi_hw_reset(struct mtk_pcs_lynxi *mpcs)
 {
 	if (!mpcs->rstc)
 		return;
@@ -235,54 +237,60 @@ static int mtk_pcs_lynxi_config(struct phylink_pcs *pcs, unsigned int neg_mode,
 		trxbuf_thr = 0x2111;
 	}
 
-	if (mpcs->interface != interface || mpcs->neg_mode != neg_mode) {
-		link_timer = phylink_get_link_timer_ns(interface);
-		if (link_timer < 0)
-			return link_timer;
-
-		/* PHYA power down */
-		regmap_set_bits(mpcs->regmap, SGMSYS_QPHY_PWR_STATE_CTRL,
-				SGMII_PHYA_PWD);
-
-		/* Reset SGMII PCS state */
-		if (mpcs->xfi_tphy)
-			phy_reset(mpcs->xfi_tphy);
-
-		mtk_sgmii_reset(mpcs);
-		regmap_set_bits(mpcs->regmap, SGMSYS_RESERVED_0,
-				SGMII_SW_RESET);
-
-		/* Configure the interface polarity */
-		pnswap_tx = (mpcs->flags & MTK_SGMII_FLAG_PN_SWAP_TX) ?
-			    SGMII_PN_SWAP_TX : 0;
-		pnswap_rx = (mpcs->flags & MTK_SGMII_FLAG_PN_SWAP_RX) ?
-			    SGMII_PN_SWAP_RX : 0;
-		regmap_update_bits(mpcs->regmap, SGMSYS_QPHY_WRAP_CTRL,
-				   SGMII_PN_SWAP_MASK,
-				   pnswap_tx | pnswap_rx);
-
-		if (interface == PHY_INTERFACE_MODE_2500BASEX)
-			rgc3 = SGMII_PHY_SPEED_3_125G;
-		else
-			rgc3 = SGMII_PHY_SPEED_1_25G;
+	link_timer = phylink_get_link_timer_ns(interface);
+	if (link_timer < 0)
+		return link_timer;
 
-		/* Configure the underlying interface speed */
-		regmap_update_bits(mpcs->regmap, mpcs->ana_rgc3,
-				   SGMII_PHY_SPEED_MASK, rgc3);
-
-		/* Setup the link timer */
-		regmap_write(mpcs->regmap, SGMSYS_PCS_LINK_TIMER,
-			     SGMII_LINK_TIMER_VAL(link_timer));
+	mutex_lock(&mpcs->regmap_lock);
 
+	if (mpcs->interface != interface || mpcs->neg_mode != neg_mode) {
 		mpcs->interface = interface;
 		mpcs->neg_mode = neg_mode;
-		linkmode_copy(mpcs->advertising, advertising);
 		mode_changed = true;
 	}
 
+	/* PHYA power down */
+	regmap_set_bits(mpcs->regmap, SGMSYS_QPHY_PWR_STATE_CTRL,
+			SGMII_PHYA_PWD);
+
+	/* Reset SGMII PCS state */
+	if (mpcs->xfi_tphy)
+		phy_reset(mpcs->xfi_tphy);
+
+	mtk_pcs_lynxi_hw_reset(mpcs);
+	regmap_set_bits(mpcs->regmap, SGMSYS_RESERVED_0,
+			SGMII_SW_RESET);
+
+	/* Configure the interface polarity */
+	pnswap_tx = (mpcs->flags & MTK_SGMII_FLAG_PN_SWAP_TX) ?
+		    SGMII_PN_SWAP_TX : 0;
+	pnswap_rx = (mpcs->flags & MTK_SGMII_FLAG_PN_SWAP_RX) ?
+		    SGMII_PN_SWAP_RX : 0;
+	regmap_update_bits(mpcs->regmap, SGMSYS_QPHY_WRAP_CTRL,
+			   SGMII_PN_SWAP_MASK,
+			   pnswap_tx | pnswap_rx);
+
+	if (interface == PHY_INTERFACE_MODE_2500BASEX)
+		rgc3 = SGMII_PHY_SPEED_3_125G;
+	else
+		rgc3 = SGMII_PHY_SPEED_1_25G;
+
+	/* Configure the underlying interface speed */
+	regmap_update_bits(mpcs->regmap, mpcs->ana_rgc3,
+			   SGMII_PHY_SPEED_MASK, rgc3);
+
+	/* Setup the link timer */
+	regmap_write(mpcs->regmap, SGMSYS_PCS_LINK_TIMER,
+		     SGMII_LINK_TIMER_VAL(link_timer));
+
 	/* Update the advertisement, noting whether it has changed */
 	regmap_update_bits_check(mpcs->regmap, SGMSYS_PCS_ADVERTISE,
 				 SGMII_ADVERTISE, advertise, &changed);
+	/* Save the advertisement when the advertising pointer does not
+	 * come from link_poll.
+	 */
+	if (changed && advertising != mpcs->advertising)
+		linkmode_copy(mpcs->advertising, advertising);
 
 	/* Update the sgmsys mode register */
 	regmap_update_bits(mpcs->regmap, SGMSYS_SGMII_MODE,
@@ -308,8 +316,9 @@ static int mtk_pcs_lynxi_config(struct phylink_pcs *pcs, unsigned int neg_mode,
 	regmap_write(mpcs->regmap, SGMSYS_QPHY_PWR_STATE_CTRL, 0);
 
 	/* Setup PMA/PMD */
-	if (mode_changed)
-		phy_set_mode_ext(mpcs->xfi_tphy, PHY_MODE_ETHERNET, interface);
+	phy_set_mode_ext(mpcs->xfi_tphy, PHY_MODE_ETHERNET, interface);
+
+	mutex_unlock(&mpcs->regmap_lock);
 
 	return changed || mode_changed;
 }
@@ -318,7 +327,9 @@ static void mtk_pcs_lynxi_restart_an(struct phylink_pcs *pcs)
 {
 	struct mtk_pcs_lynxi *mpcs = pcs_to_mtk_pcs_lynxi(pcs);
 
+	mutex_lock(&mpcs->regmap_lock);
 	regmap_set_bits(mpcs->regmap, SGMSYS_PCS_CONTROL_1, BMCR_ANRESTART);
+	mutex_unlock(&mpcs->regmap_lock);
 }
 
 static void mtk_pcs_lynxi_link_up(struct phylink_pcs *pcs,
@@ -327,8 +338,20 @@ static void mtk_pcs_lynxi_link_up(struct phylink_pcs *pcs,
 				  int duplex)
 {
 	struct mtk_pcs_lynxi *mpcs = pcs_to_mtk_pcs_lynxi(pcs);
+	unsigned long t_start = jiffies;
 	unsigned int sgm_mode;
 
+	do {
+		msleep(100);
+
+		if (mtk_pcs_lynxi_link_status(mpcs))
+			goto setup_force;
+
+	} while (time_before(jiffies, t_start + msecs_to_jiffies(10000)));
+
+	dev_warn(mpcs->dev, "wait link up timeout!\n");
+
+setup_force:
 	if (neg_mode != PHYLINK_PCS_NEG_INBAND_ENABLED) {
 		/* Force the speed and duplex setting */
 		if (speed == SPEED_10)
@@ -341,12 +364,36 @@ static void mtk_pcs_lynxi_link_up(struct phylink_pcs *pcs,
 		if (duplex != DUPLEX_FULL)
 			sgm_mode |= SGMII_DUPLEX_HALF;
 
+		mutex_lock(&mpcs->regmap_lock);
 		regmap_update_bits(mpcs->regmap, SGMSYS_SGMII_MODE,
 				   SGMII_DUPLEX_HALF | SGMII_SPEED_MASK,
 				   sgm_mode);
+		mutex_unlock(&mpcs->regmap_lock);
 	}
 }
 
+static void mtk_pcs_lynxi_link_poll(struct work_struct *work)
+{
+	struct mtk_pcs_lynxi *mpcs = container_of(work, struct mtk_pcs_lynxi,
+						  link_poll.work);
+
+	if ((mpcs->interface != PHY_INTERFACE_MODE_SGMII &&
+	     mpcs->interface != PHY_INTERFACE_MODE_1000BASEX &&
+	     mpcs->interface != PHY_INTERFACE_MODE_2500BASEX) ||
+	    (mpcs->poll == false))
+		goto exit;
+
+	if (mtk_pcs_lynxi_link_status(mpcs))
+		mtk_pcs_lynxi_update_state(mpcs);
+	else
+		mtk_pcs_lynxi_config(&mpcs->pcs, mpcs->neg_mode, mpcs->interface,
+				     mpcs->advertising, false);
+
+exit:
+	if (!delayed_work_pending(&mpcs->link_poll))
+		schedule_delayed_work(&mpcs->link_poll, msecs_to_jiffies(1000));
+}
+
 static int mtk_pcs_lynxi_enable(struct phylink_pcs *pcs)
 {
 	struct mtk_pcs_lynxi *mpcs = pcs_to_mtk_pcs_lynxi(pcs);
@@ -359,6 +406,9 @@ static int mtk_pcs_lynxi_enable(struct phylink_pcs *pcs)
 	if (mpcs->xfi_tphy)
 		phy_power_on(mpcs->xfi_tphy);
 
+	if (!delayed_work_pending(&mpcs->link_poll))
+		schedule_delayed_work(&mpcs->link_poll, msecs_to_jiffies(1000));
+
 	return 0;
 }
 
@@ -366,6 +416,8 @@ static void mtk_pcs_lynxi_disable(struct phylink_pcs *pcs)
 {
 	struct mtk_pcs_lynxi *mpcs = pcs_to_mtk_pcs_lynxi(pcs);
 
+	cancel_delayed_work_sync(&mpcs->link_poll);
+
 	regmap_set_bits(mpcs->regmap, SGMSYS_QPHY_PWR_STATE_CTRL, SGMII_PHYA_PWD);
 
 	if (mpcs->sgmii_tx && mpcs->sgmii_rx) {
@@ -434,6 +486,9 @@ static struct phylink_pcs *mtk_pcs_lynxi_init(struct device *dev, struct regmap
 	mpcs->pcs.neg_mode = true;
 	mpcs->pcs.poll = true;
 	mpcs->interface = PHY_INTERFACE_MODE_NA;
+	mpcs->poll = true;
+	mutex_init(&mpcs->regmap_lock);
+	INIT_DELAYED_WORK(&mpcs->link_poll, mtk_pcs_lynxi_link_poll);
 
 	return &mpcs->pcs;
 };
diff --git a/include/linux/pcs/pcs-mtk-lynxi.h b/include/linux/pcs/pcs-mtk-lynxi.h
index 4ab8a32..50573d7 100644
--- a/include/linux/pcs/pcs-mtk-lynxi.h
+++ b/include/linux/pcs/pcs-mtk-lynxi.h
@@ -5,6 +5,44 @@
 #include <linux/phylink.h>
 #include <linux/regmap.h>
 
+/* struct mtk_pcs_lynxi -  This structure holds each sgmii regmap andassociated
+ *                         data
+ * @regmap:                The register map pointing at the range used to setup
+ *                         SGMII modes
+ * @dev:                   Pointer to device owning the PCS
+ * @ana_rgc3:              The offset of register ANA_RGC3 relative to regmap
+ * @interface:             Currently configured interface mode
+ * @pcs:                   Phylink PCS structure
+ * @flags:                 Flags indicating hardware properties
+ * @rstc:                  Reset controller
+ * @sgmii_sel:             SGMII Register Clock
+ * @sgmii_rx:              SGMII RX Clock
+ * @sgmii_tx:              SGMII TX Clock
+ * @node:                  List node
+ */
+struct mtk_pcs_lynxi {
+	struct regmap		*regmap;
+	struct device		*dev;
+	u32			ana_rgc3;
+	phy_interface_t		interface;
+	struct			phylink_pcs pcs;
+	u32			flags;
+	unsigned int		neg_mode;
+	__ETHTOOL_DECLARE_LINK_MODE_MASK(advertising);
+	struct reset_control	*rstc;
+	struct clk		*sgmii_sel;
+	struct clk		*sgmii_rx;
+	struct clk		*sgmii_tx;
+	struct phy		*xfi_tphy;
+	bool			poll;
+	struct delayed_work	link_poll;
+	struct phylink_link_state	state;
+	struct mutex		regmap_lock;
+	struct list_head	node;
+};
+
+struct mtk_pcs_lynxi *pcs_to_mtk_pcs_lynxi(struct phylink_pcs *pcs);
+
 #define MTK_SGMII_FLAG_PN_SWAP_TX BIT(0)
 #define MTK_SGMII_FLAG_PN_SWAP_RX BIT(1)
 #define MTK_SGMII_FLAG_PHYA_TRX_CK BIT(2)
-- 
2.45.2

