From b487917477958c0bab6d144cd19c0f3509383b54 Mon Sep 17 00:00:00 2001
From: Bo-Cun Chen <bc-bocun.chen@mediatek.com>
Date: Mon, 22 Sep 2025 11:12:10 +0800
Subject: [PATCH] net: ethernet: mtk_eth_soc: add ETH ports link down flow for
 NETSYSv3 SER

The NETSYSv3 introduces new hardware, XGMAC, which is used for
connecting to the external 10G PHY or internal 2.5G PHY.
Additionally, there is a new hardware component, built-in MT7531,
which connects to an internal BUS and is not a real MAC. Therefore,
we need to add both link down flows to the existing NETSYS SER flow.

Signed-off-by: Bo-Cun Chen <bc-bocun.chen@mediatek.com>
---
 drivers/net/ethernet/mediatek/mtk_eth_soc.c | 73 ++++++++++++++++++++-
 drivers/net/ethernet/mediatek/mtk_eth_soc.h |  5 ++
 2 files changed, 75 insertions(+), 3 deletions(-)

--- a/drivers/net/ethernet/mediatek/mtk_eth_soc.c
+++ b/drivers/net/ethernet/mediatek/mtk_eth_soc.c
@@ -5275,8 +5275,48 @@ static int mtk_do_ioctl(struct net_devic
 	return -EOPNOTSUPP;
 }
 
+static void mt7988_esw_iomap(struct mtk_eth *eth)
+{
+	struct device_node *np;
+	void __iomem *base;
+
+	np = of_find_compatible_node(NULL, NULL, "mediatek,mt7988-switch");
+	if (!np) {
+		/* check the GSW node if the DSA node does not exist */
+		of_find_compatible_node(NULL, NULL, "mediatek,mt7988-gsw-switch");
+	}
+
+	if (np) {
+		base = of_iomap(np, 0);
+		if (IS_ERR(base)) {
+			dev_err(eth->dev, "failed to map esw base address\n");
+			goto out;
+		}
+	}
+
+	eth->esw_base = base;
+out:
+	of_node_put(np);
+}
+
+static void mt7988_esw_force_link(struct mtk_eth *eth, bool link_up)
+{
+	u32 val;
+
+	if (!eth->esw_base)
+		return;
+
+	val = __raw_readl(eth->esw_base + MT753X_PMCR_P(6));
+	if (link_up)
+		val |= PMCR_FORCE_LNK;
+	else
+		val &= ~PMCR_FORCE_LNK;
+	__raw_writel(val, eth->esw_base + MT753X_PMCR_P(6));
+}
+
 static void mtk_prepare_for_reset(struct mtk_eth *eth)
 {
+	struct mtk_mac *mac;
 	u32 val;
 	int i;
 
@@ -5295,9 +5335,23 @@ static void mtk_prepare_for_reset(struct
 	mtk_w32(eth, 0, MTK_FE_INT_ENABLE);
 
 	/* force link down GMAC */
-	for (i = 0; i < 2; i++) {
-		val = mtk_r32(eth, MTK_MAC_MCR(i)) & ~MAC_MCR_FORCE_LINK;
-		mtk_w32(eth, val, MTK_MAC_MCR(i));
+	for (i = 0; i < MTK_MAX_DEVS; i++) {
+		mac = eth->mac[i];
+		if (!mac)
+			continue;
+
+		if (mtk_is_netsys_v3_or_greater(eth) &&
+		    mtk_interface_mode_is_xgmii(mac->interface)) {
+			if (mac->id == MTK_GMAC1_ID)
+				mt7988_esw_force_link(eth, false);
+			else {
+				mtk_m32(eth, XMAC_MCR_TRX_DISABLE, XMAC_MCR_TRX_DISABLE,
+					MTK_XMAC_MCR(mac->id));
+				mtk_m32(eth, MTK_XGMAC_FORCE_LINK(mac->id), 0,
+					MTK_XGMAC_STS(mac->id));
+			}
+		} else
+			mtk_m32(eth, MAC_MCR_FORCE_LINK, 0, MTK_MAC_MCR(i));
 	}
 }
 
@@ -5345,6 +5399,11 @@ static void mtk_pending_work(struct work
 				    "Driver up/down cycle failed\n");
 			dev_close(eth->netdev[i]);
 		}
+
+		if (mtk_is_netsys_v3_or_greater(eth) &&
+		    mtk_interface_mode_is_xgmii(eth->mac[i]->interface) &&
+		    eth->mac[i]->id == MTK_GMAC1_ID)
+			mt7988_esw_force_link(eth, true);
 	}
 
 	clear_bit(MTK_RESETTING, &eth->state);
@@ -6105,6 +6164,11 @@ static int mtk_add_mac(struct mtk_eth *e
 		}
 	}
 
+	if (mtk_is_netsys_v3_or_greater(mac->hw) &&
+	    MTK_HAS_CAPS(mac->hw->soc->caps, MTK_ESW) &&
+	    id == MTK_GMAC1_ID)
+		mt7988_esw_iomap(eth);
+
 	memset(mac->hwlro_ip, 0, sizeof(mac->hwlro_ip));
 	mac->hwlro_ip_cnt = 0;
 
@@ -6737,6 +6801,9 @@ static void mtk_remove(struct platform_d
 	struct mtk_mac *mac;
 	int i;
 
+	if (eth->esw_base)
+		iounmap(eth->esw_base);
+
 	/* stop all devices to make sure that dma is properly shut down */
 	for (i = 0; i < MTK_MAX_DEVS; i++) {
 		if (!eth->netdev[i])
--- a/drivers/net/ethernet/mediatek/mtk_eth_soc.h
+++ b/drivers/net/ethernet/mediatek/mtk_eth_soc.h
@@ -727,6 +727,10 @@
 #define MT7628_SDM_MAC_ADRL	(MT7628_SDM_OFFSET + 0x0c)
 #define MT7628_SDM_MAC_ADRH	(MT7628_SDM_OFFSET + 0x10)
 
+/* MT7988 internal switch register */
+#define MT753X_PMCR_P(x)	(0x3000 + ((x) * 0x100))
+#define  PMCR_FORCE_LNK		BIT(0)
+
 /* Counter / stat register */
 #define MT7628_SDM_TPCNT	(MT7628_SDM_OFFSET + 0x100)
 #define MT7628_SDM_TBCNT	(MT7628_SDM_OFFSET + 0x104)
@@ -1542,6 +1546,7 @@ struct mtk_eth {
 	struct device			*dev;
 	struct device			*dma_dev;
 	void __iomem			*base;
+	void __iomem			*esw_base;
 	void				*sram_base;
 	spinlock_t			page_lock;
 	spinlock_t			tx_irq_lock;
