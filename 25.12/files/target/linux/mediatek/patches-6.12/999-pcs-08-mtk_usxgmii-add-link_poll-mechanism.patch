From a62fc31865f3fd125ddd4ea8d470ca0dc140c16a Mon Sep 17 00:00:00 2001
From: Bo-Cun Chen <bc-bocun.chen@mediatek.com>
Date: Fri, 2 Jan 2026 09:45:29 +0800
Subject: [PATCH] net: pcs: mtk_usxgmii: add link_poll mechanism

Signed-off-by: Bo-Cun Chen <bc-bocun.chen@mediatek.com>
---
 drivers/net/pcs/pcs-mtk-usxgmii.c    | 168 +++++++++++++++++++--------
 include/linux/pcs/pcs-mtk-usxgmii.h  |  29 +++++
 include/linux/phy/phy-mtk-xfi-tphy.h |  23 ++++
 3 files changed, 169 insertions(+), 51 deletions(-)
 create mode 100644 include/linux/phy/phy-mtk-xfi-tphy.h

diff --git a/drivers/net/pcs/pcs-mtk-usxgmii.c b/drivers/net/pcs/pcs-mtk-usxgmii.c
index b7729fd..1e77896 100644
--- a/drivers/net/pcs/pcs-mtk-usxgmii.c
+++ b/drivers/net/pcs/pcs-mtk-usxgmii.c
@@ -15,6 +15,7 @@
 #include <linux/reset.h>
 #include <linux/pcs/pcs-mtk-usxgmii.h>
 #include <linux/phy/phy.h>
+#include <linux/phy/phy-mtk-xfi-tphy.h>
 #include <linux/platform_device.h>
 
 /* USXGMII subsystem config registers */
@@ -64,29 +65,6 @@
 #define RG_PCS_RX_STATUS_UPDATE			BIT(16)
 #define RG_PCS_RX_LINK_STATUS			BIT(2)
 
-/* struct mtk_usxgmii_pcs - This structure holds each usxgmii PCS
- * @pcs:		Phylink PCS structure
- * @dev:		Pointer to device structure
- * @base:		IO memory to access PCS hardware
- * @clk:		Pointer to USXGMII clk
- * @reset:		Pointer to USXGMII reset control
- * @interface:		Currently selected interface mode
- * @neg_mode:		Currently used phylink neg_mode
- * @node:		List node
- */
-struct mtk_usxgmii_pcs {
-	struct phylink_pcs		pcs;
-	struct device			*dev;
-	void __iomem			*base;
-	struct clk			*clk;
-	struct reset_control		*reset;
-	struct phy			*xfi_tphy;
-	phy_interface_t			interface;
-	unsigned int			polarity;
-	unsigned int			neg_mode;
-	struct list_head		node;
-};
-
 static LIST_HEAD(mtk_usxgmii_pcs_instances);
 static DEFINE_MUTEX(instance_mutex);
 
@@ -105,12 +83,54 @@ static void mtk_m32(struct mtk_usxgmii_pcs *mpcs, unsigned int reg, u32 mask, u3
 	iowrite32(val, mpcs->base + reg);
 }
 
-static struct mtk_usxgmii_pcs *pcs_to_mtk_usxgmii_pcs(struct phylink_pcs *pcs)
+struct mtk_usxgmii_pcs *pcs_to_mtk_usxgmii_pcs(struct phylink_pcs *pcs)
 {
 	return container_of(pcs, struct mtk_usxgmii_pcs, pcs);
 }
 
-static void mtk_usxgmii_reset(struct mtk_usxgmii_pcs *mpcs)
+static int mtk_usxgmii_pcs_link_status(struct mtk_usxgmii_pcs *mpcs)
+{
+	int status;
+
+	mutex_lock(&mpcs->regmap_lock);
+
+	/* Refresh USXGMII link status by toggling RG_PCS_RX_STATUS_UPDATE */
+	mtk_m32(mpcs, RG_PCS_RX_STATUS0, RG_PCS_RX_STATUS_UPDATE,
+		RG_PCS_RX_STATUS_UPDATE);
+	ndelay(1020);
+	mtk_m32(mpcs, RG_PCS_RX_STATUS0, RG_PCS_RX_STATUS_UPDATE, 0);
+	ndelay(1020);
+
+	/* Read USXGMII link status */
+	status = FIELD_GET(RG_PCS_RX_LINK_STATUS,
+			   mtk_r32(mpcs, RG_PCS_RX_STATUS0));
+
+	mutex_unlock(&mpcs->regmap_lock);
+
+	return status;
+}
+
+static bool mtk_usxgmii_pcs_is_valid_ctle(struct mtk_usxgmii_pcs *mpcs)
+{
+	struct mtk_xfi_tphy *xfi_tphy = phy_get_drvdata(mpcs->xfi_tphy);
+	unsigned int val, ctle;
+
+	mutex_lock(&mpcs->regmap_lock);
+
+	iowrite32(0x00000404, xfi_tphy->base + 0x00);
+	iowrite32(0x00d600d5, xfi_tphy->base + 0x10);
+	val = ioread32(xfi_tphy->base + 0xd0);
+
+	mutex_unlock(&mpcs->regmap_lock);
+
+	ctle = FIELD_GET(GENMASK(12, 8), val);
+	if (ctle > 10)
+		return false;
+
+	return true;
+}
+
+static void mtk_usxgmii_pcs_hw_reset(struct mtk_usxgmii_pcs *mpcs)
 {
 	reset_control_assert(mpcs->reset);
 	udelay(100);
@@ -157,13 +177,15 @@ static int mtk_usxgmii_pcs_config(struct phylink_pcs *pcs, unsigned int neg_mode
 
 	adapt_mode |= FIELD_PREP(USXGMII_RATE_ADAPT_MODE, USXGMII_RATE_ADAPT_MODE_X1);
 
+	mutex_lock(&mpcs->regmap_lock);
+
 	if (mpcs->interface != interface) {
 		mpcs->interface = interface;
 		mode_changed = true;
 	}
 
 	phy_reset(mpcs->xfi_tphy);
-	mtk_usxgmii_reset(mpcs);
+	mtk_usxgmii_pcs_hw_reset(mpcs);
 
 	/* Configure the interface polarity */
 	mtk_m32(mpcs, RG_PHY_TOP_CTRL0,
@@ -211,6 +233,11 @@ static int mtk_usxgmii_pcs_config(struct phylink_pcs *pcs, unsigned int neg_mode
 	if (an_ctrl & USXGMII_AN_ENABLE)
 		mtk_m32(mpcs, RG_PHY_TOP_SPEED_CTRL1, USXGMII_IF_FORCE_EN, 0);
 
+	/* Setup PMA/PMD */
+	phy_set_mode_ext(mpcs->xfi_tphy, PHY_MODE_ETHERNET, interface);
+
+	mutex_unlock(&mpcs->regmap_lock);
+
 	return mode_changed;
 }
 
@@ -281,41 +308,43 @@ static void mtk_usxgmii_pcs_get_an_state(struct mtk_usxgmii_pcs *mpcs,
 	phylink_decode_usxgmii_word(state, lpa);
 }
 
-static void mtk_usxgmii_pcs_get_state(struct phylink_pcs *pcs,
-				      struct phylink_link_state *state)
+static void mtk_usxgmii_pcs_update_state(struct mtk_usxgmii_pcs *mpcs)
 {
-	struct mtk_usxgmii_pcs *mpcs = pcs_to_mtk_usxgmii_pcs(pcs);
+	struct phylink_link_state *state = &mpcs->state;
 
-	/* Refresh USXGMII link status by toggling RG_PCS_AN_STATUS_UPDATE */
-	mtk_m32(mpcs, RG_PCS_RX_STATUS0, RG_PCS_RX_STATUS_UPDATE,
-		RG_PCS_RX_STATUS_UPDATE);
-	ndelay(1020);
-	mtk_m32(mpcs, RG_PCS_RX_STATUS0, RG_PCS_RX_STATUS_UPDATE, 0);
-	ndelay(1020);
+	state->link = mtk_usxgmii_pcs_link_status(mpcs);
+	state->interface = mpcs->interface;
 
-	/* Read USXGMII link status */
-	state->link = FIELD_GET(RG_PCS_RX_LINK_STATUS,
-				mtk_r32(mpcs, RG_PCS_RX_STATUS0));
-
-	/* Continuously repeat re-configuration sequence until link comes up */
-	if (!state->link) {
-		mtk_usxgmii_pcs_config(pcs, mpcs->neg_mode,
-				       state->interface, NULL, false);
-		phy_set_mode_ext(mpcs->xfi_tphy, PHY_MODE_ETHERNET, state->interface);
-		return;
-	}
+	mutex_lock(&mpcs->regmap_lock);
 
 	if (FIELD_GET(USXGMII_AN_ENABLE, mtk_r32(mpcs, RG_PCS_AN_CTRL0)))
 		mtk_usxgmii_pcs_get_an_state(mpcs, state);
 	else
 		mtk_usxgmii_pcs_get_fixed_speed(mpcs, state);
+
+	mutex_unlock(&mpcs->regmap_lock);
+}
+
+static void mtk_usxgmii_pcs_get_state(struct phylink_pcs *pcs,
+				      struct phylink_link_state *state)
+{
+	struct mtk_usxgmii_pcs *mpcs = pcs_to_mtk_usxgmii_pcs(pcs);
+
+	if (mpcs->state.interface != PHY_INTERFACE_MODE_NA)
+		state->interface = mpcs->state.interface;
+
+	state->speed = mpcs->state.speed;
+	state->duplex = mpcs->state.duplex;
+	state->link = mpcs->state.link;
 }
 
 static void mtk_usxgmii_pcs_restart_an(struct phylink_pcs *pcs)
 {
 	struct mtk_usxgmii_pcs *mpcs = pcs_to_mtk_usxgmii_pcs(pcs);
 
+	mutex_lock(&mpcs->regmap_lock);
 	mtk_m32(mpcs, RG_PCS_AN_CTRL0, USXGMII_AN_RESTART, USXGMII_AN_RESTART);
+	mutex_unlock(&mpcs->regmap_lock);
 }
 
 static void mtk_usxgmii_pcs_link_up(struct phylink_pcs *pcs, unsigned int neg_mode,
@@ -323,12 +352,41 @@ static void mtk_usxgmii_pcs_link_up(struct phylink_pcs *pcs, unsigned int neg_mo
 				    int speed, int duplex)
 {
 	struct mtk_usxgmii_pcs *mpcs = pcs_to_mtk_usxgmii_pcs(pcs);
+	unsigned long t_start = jiffies;
 
-	/* Reconfiguring USXGMII to ensure the quality of the RX signal
-	 * after the line side link up.
-	 */
-	mtk_usxgmii_pcs_config(pcs, neg_mode, interface, NULL, false);
-	phy_set_mode_ext(mpcs->xfi_tphy, PHY_MODE_ETHERNET, interface);
+	do {
+		msleep(100);
+
+		if (mtk_usxgmii_pcs_link_status(mpcs) &&
+		    mtk_usxgmii_pcs_is_valid_ctle(mpcs))
+			return;
+
+	} while (time_before(jiffies, t_start + msecs_to_jiffies(10000)));
+
+	dev_warn(mpcs->dev, "wait link up timeout!\n");
+}
+
+static void mtk_usxgmii_pcs_link_poll(struct work_struct *work)
+{
+	struct mtk_usxgmii_pcs *mpcs = container_of(work, struct mtk_usxgmii_pcs,
+						   link_poll.work);
+
+	if ((mpcs->interface != PHY_INTERFACE_MODE_5GBASER &&
+	     mpcs->interface != PHY_INTERFACE_MODE_10GBASER &&
+	     mpcs->interface != PHY_INTERFACE_MODE_10GKR &&
+	     mpcs->interface != PHY_INTERFACE_MODE_USXGMII) ||
+	    (mpcs->poll == false))
+		goto exit;
+
+	if (mtk_usxgmii_pcs_link_status(mpcs) && mtk_usxgmii_pcs_is_valid_ctle(mpcs))
+		mtk_usxgmii_pcs_update_state(mpcs);
+	else
+		mtk_usxgmii_pcs_config(&mpcs->pcs, mpcs->neg_mode,
+				       mpcs->interface, NULL, false);
+
+exit:
+	if (!delayed_work_pending(&mpcs->link_poll))
+		schedule_delayed_work(&mpcs->link_poll, msecs_to_jiffies(1000));
 }
 
 static int mtk_usxgmii_pcs_enable(struct phylink_pcs *pcs)
@@ -337,6 +395,9 @@ static int mtk_usxgmii_pcs_enable(struct phylink_pcs *pcs)
 
 	phy_power_on(mpcs->xfi_tphy);
 
+	if (!delayed_work_pending(&mpcs->link_poll))
+		schedule_delayed_work(&mpcs->link_poll, msecs_to_jiffies(1000));
+
 	return 0;
 }
 
@@ -344,6 +405,8 @@ static void mtk_usxgmii_pcs_disable(struct phylink_pcs *pcs)
 {
 	struct mtk_usxgmii_pcs *mpcs = pcs_to_mtk_usxgmii_pcs(pcs);
 
+	cancel_delayed_work_sync(&mpcs->link_poll);
+
 	mpcs->interface = PHY_INTERFACE_MODE_NA;
 	mpcs->neg_mode = -1;
 
@@ -386,6 +449,9 @@ static int mtk_usxgmii_probe(struct platform_device *pdev)
 	mpcs->pcs.neg_mode = true;
 	mpcs->interface = PHY_INTERFACE_MODE_NA;
 	mpcs->neg_mode = -1;
+	mpcs->poll = true;
+	mutex_init(&mpcs->regmap_lock);
+	INIT_DELAYED_WORK(&mpcs->link_poll, mtk_usxgmii_pcs_link_poll);
 
 	mpcs->clk = devm_clk_get_enabled(mpcs->dev, NULL);
 	if (IS_ERR(mpcs->clk))
diff --git a/include/linux/pcs/pcs-mtk-usxgmii.h b/include/linux/pcs/pcs-mtk-usxgmii.h
index ef936d9..8c18c1c 100644
--- a/include/linux/pcs/pcs-mtk-usxgmii.h
+++ b/include/linux/pcs/pcs-mtk-usxgmii.h
@@ -4,6 +4,35 @@
 
 #include <linux/phylink.h>
 
+/* struct mtk_usxgmii_pcs - This structure holds each usxgmii PCS
+ * @pcs:		Phylink PCS structure
+ * @dev:		Pointer to device structure
+ * @base:		IO memory to access PCS hardware
+ * @clk:		Pointer to USXGMII clk
+ * @reset:		Pointer to USXGMII reset control
+ * @interface:		Currently selected interface mode
+ * @neg_mode:		Currently used phylink neg_mode
+ * @node:		List node
+ */
+struct mtk_usxgmii_pcs {
+	struct phylink_pcs		pcs;
+	struct device			*dev;
+	void __iomem			*base;
+	struct clk			*clk;
+	struct reset_control		*reset;
+	struct phy			*xfi_tphy;
+	phy_interface_t			interface;
+	unsigned int			polarity;
+	unsigned int			neg_mode;
+	bool				poll;
+	struct delayed_work		link_poll;
+	struct phylink_link_state	state;
+	struct mutex			regmap_lock;
+	struct list_head		node;
+};
+
+struct mtk_usxgmii_pcs *pcs_to_mtk_usxgmii_pcs(struct phylink_pcs *pcs);
+
 /**
  * mtk_usxgmii_select_pcs() - Get MediaTek PCS instance
  * @np:		Pointer to device node indentifying a MediaTek USXGMII PCS
diff --git a/include/linux/phy/phy-mtk-xfi-tphy.h b/include/linux/phy/phy-mtk-xfi-tphy.h
new file mode 100644
index 0000000..0e0ac9d
--- /dev/null
+++ b/include/linux/phy/phy-mtk-xfi-tphy.h
@@ -0,0 +1,23 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#ifndef __LINUX_PHY_MTK_XFI_TPHY_H
+#define __LINUX_PHY_MTK_XFI_TPHY_H
+
+#define MTK_XFI_TPHY_NUM_CLOCKS		2
+
+/**
+ * struct mtk_xfi_tphy - run-time data of the XFI phy instance
+ * @base: IO memory area to access phy registers.
+ * @dev: Kernel device used to output prefixed debug info.
+ * @reset: Reset control corresponding to the phy instance.
+ * @clocks: All clocks required for the phy to operate.
+ * @da_war: Enables work-around for 10GBase-R mode.
+ */
+struct mtk_xfi_tphy {
+	void __iomem		*base;
+	struct device		*dev;
+	struct reset_control	*reset;
+	struct clk_bulk_data	clocks[MTK_XFI_TPHY_NUM_CLOCKS];
+	bool			da_war;
+};
+
+#endif /* __LINUX_PHY_MTK_XFI_TPHY_H */
-- 
2.45.2

