From 7e7db22a49d99ad111c2409627c90f193f12dc6a Mon Sep 17 00:00:00 2001
From: Bo-Cun Chen <bc-bocun.chen@mediatek.com>
Date: Fri, 26 Dec 2025 11:19:36 +0800
Subject: [PATCH] net: ethernet: mtk_eth_soc: add IEEE1588v2 support for 
 NETSYSv3.1

Users can use one of the following measurements to configure ptp4l in
Master and Slave mode on two directly connected DUTs.
 - Delay Request-Response Measurement
   ptp4l -2 -i ethX -m -H	# Master mode
   ptp4l -2 -i ethX -m -H -s	# Slave mode
 - Peer Delay Measurement
   ptp4l -2 -i ethX -P -m -H	# Master mode
   ptp4l -2 -i ethX -P -m -H -s	# Slave mode

Without this patch, the user is unable to use ptp4l to obtain the
hardware timestamp from GMAC.

Signed-off-by: Bo-Cun Chen <bc-bocun.chen@mediatek.com>
---
 drivers/net/ethernet/mediatek/Makefile      |   2 +-
 drivers/net/ethernet/mediatek/mtk_eth_ptp.c | 521 ++++++++++++++++++++
 drivers/net/ethernet/mediatek/mtk_eth_soc.c |  46 ++
 drivers/net/ethernet/mediatek/mtk_eth_soc.h |  79 ++-
 4 files changed, 646 insertions(+), 2 deletions(-)
 create mode 100644 drivers/net/ethernet/mediatek/mtk_eth_ptp.c

--- a/drivers/net/ethernet/mediatek/Makefile
+++ b/drivers/net/ethernet/mediatek/Makefile
@@ -4,7 +4,7 @@
 #
 
 obj-$(CONFIG_NET_MEDIATEK_SOC) += mtk_eth.o
-mtk_eth-y := mtk_eth_soc.o mtk_eth_path.o mtk_ppe.o mtk_ppe_debugfs.o mtk_ppe_offload.o
+mtk_eth-y := mtk_eth_soc.o mtk_eth_path.o mtk_eth_ptp.o mtk_ppe.o mtk_ppe_debugfs.o mtk_ppe_offload.o
 mtk_eth-$(CONFIG_NET_MEDIATEK_SOC_WED) += mtk_wed.o mtk_wed_mcu.o mtk_wed_wo.o
 ifdef CONFIG_DEBUG_FS
 mtk_eth-$(CONFIG_NET_MEDIATEK_SOC_WED) += mtk_wed_debugfs.o
--- /dev/null
+++ b/drivers/net/ethernet/mediatek/mtk_eth_ptp.c
@@ -0,0 +1,521 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * IEEE1588v2 PTP support for MediaTek ETH device.
+ *
+ * Copyright (c) 2024 MediaTek Inc.
+ * Authors: Bo-Cun Chen <bc-bocun.chen@mediatek.com>
+ */
+
+#include <linux/if_vlan.h>
+#include <linux/jiffies.h>
+#include <linux/net_tstamp.h>
+#include <linux/ptp_classify.h>
+
+#include "mtk_eth_soc.h"
+
+/* Values for the messageType field */
+#define SYNC			0x0
+#define DELAY_REQ		0x1
+#define PDELAY_REQ		0x2
+#define PDELAY_RESP		0x3
+#define FOLLOW_UP		0x8
+#define DELAY_RESP		0x9
+#define PDELAY_RESP_FOLLOW_UP	0xA
+#define ANNOUNCE		0xB
+
+static int mtk_ptp_hwtstamp_enable(struct net_device *dev, int hwtstamp)
+{
+	struct mtk_mac *mac = netdev_priv(dev);
+	struct mtk_eth *eth = mac->hw;
+
+	mtk_m32(eth, CSR_HW_TS_EN(mac->id),
+		hwtstamp ? CSR_HW_TS_EN(mac->id) : 0, MAC_TS_MAC_CFG);
+
+	return 0;
+}
+
+static int mtk_ptp_hwtstamp_get_t1(struct mtk_mac *mac, u16 seqid, struct timespec64 *ts)
+{
+	struct mtk_eth *eth = mac->hw;
+	u32 sid[2], dw[4];
+	int i;
+
+	sid[0] = mtk_r32(eth, MAC_TS_T1_SID1(mac->id));
+	for (i = 0; i < 4; i++)
+		dw[i] = mtk_r32(eth, MAC_TS_T1_DW(mac->id) + i * 4);
+	sid[1] = mtk_r32(eth, MAC_TS_T1_SID2(mac->id));
+
+	if (seqid != sid[0] || sid[0] != sid[1]) {
+		dev_warn(eth->dev, "invalid t1 hwtstamp(%d, %d, %d)!\n",
+			 seqid, sid[0], sid[1]);
+		return -EINVAL;
+	}
+
+	ts->tv_sec = dw[2] | ((u64)dw[3] << 32);
+	ts->tv_nsec = dw[1];
+
+	return 0;
+}
+
+static int mtk_ptp_hwtstamp_get_t2(struct mtk_mac *mac, u16 seqid, struct timespec64 *ts)
+{
+	struct mtk_eth *eth = mac->hw;
+	u32 sid[2], dw[4];
+	int i;
+
+	sid[0] = mtk_r32(eth, MAC_TS_T2_SID1(mac->id));
+	for (i = 0; i < 4; i++)
+		dw[i] = mtk_r32(eth, MAC_TS_T2_DW(mac->id) + i * 4);
+	sid[1] = mtk_r32(eth, MAC_TS_T2_SID2(mac->id));
+
+	if (seqid != sid[0] || sid[0] != sid[1]) {
+		dev_warn(eth->dev, "invalid t2 hwtstamp(%d, %d, %d)!\n",
+			 seqid, sid[0], sid[1]);
+		return -EINVAL;
+	}
+
+	ts->tv_sec = dw[2] | ((u64)dw[3] << 32);
+	ts->tv_nsec = dw[1];
+
+	return 0;
+}
+
+static int mtk_ptp_hwtstamp_get_t3(struct mtk_mac *mac, u16 seqid, struct timespec64 *ts)
+{
+	struct mtk_eth *eth = mac->hw;
+	u32 sid[2], dw[4];
+	int i;
+
+	sid[0] = mtk_r32(eth, MAC_TS_T3_SID1(mac->id));
+	for (i = 0; i < 4; i++)
+		dw[i] = mtk_r32(eth, MAC_TS_T3_DW(mac->id) + i * 4);
+	sid[1] = mtk_r32(eth, MAC_TS_T3_SID2(mac->id));
+
+	if (seqid != sid[0] || sid[0] != sid[1]) {
+		dev_warn(eth->dev, "invalid t3 hwtstamp(%d, %d, %d)!\n",
+			 seqid, sid[0], sid[1]);
+		return -EINVAL;
+	}
+
+	ts->tv_sec = dw[2] | ((u64)dw[3] << 32);
+	ts->tv_nsec = dw[1];
+
+	return 0;
+}
+
+static int mtk_ptp_hwtstamp_get_t4(struct mtk_mac *mac, u16 seqid, struct timespec64 *ts)
+{
+	struct mtk_eth *eth = mac->hw;
+	u32 sid[2], dw[4];
+	int i;
+
+	sid[0] = mtk_r32(eth, MAC_TS_T4_SID1(mac->id));
+	for (i = 0; i < 4; i++)
+		dw[i] = mtk_r32(eth, MAC_TS_T4_DW(mac->id) + i * 4);
+	sid[1] = mtk_r32(eth, MAC_TS_T4_SID2(mac->id));
+
+	if (seqid != sid[0] || sid[0] != sid[1]) {
+		dev_warn(eth->dev, "invalid t4 hwtstamp(%d, %d, %d)!\n",
+			 seqid, sid[0], sid[1]);
+		return -EINVAL;
+	}
+
+	ts->tv_sec = dw[2] | ((u64)dw[3] << 32);
+	ts->tv_nsec = dw[1];
+
+	return 0;
+}
+
+static void mtk_ptp_hwtstamp_tx_work(struct work_struct *work)
+{
+	struct mtk_mac *mac = container_of(work, struct mtk_mac, ptp_tx_work);
+	struct mtk_eth *eth = mac->hw;
+	struct sk_buff *skb = mac->ptp_tx_skb;
+	struct skb_shared_hwtstamps shhwtstamps;
+	struct timespec64 ts;
+	unsigned int ptp_class, offset = 0;
+	u8 *data, msgtype;
+	u16 seqid;
+	int ret;
+
+	if (!skb)
+		return;
+
+	ptp_class = mac->ptp_tx_class;
+	if (ptp_class & PTP_CLASS_VLAN)
+		offset += VLAN_HLEN;
+
+	if ((ptp_class & PTP_CLASS_PMASK) == PTP_CLASS_L2)
+		offset += ETH_HLEN;
+
+	data = skb_mac_header(skb);
+	seqid = get_unaligned_be16(data + offset + OFF_PTP_SEQUENCE_ID);
+	msgtype = data[offset] & 0x0f;
+	switch (msgtype) {
+	case SYNC:
+	case PDELAY_REQ:
+		ret = mtk_ptp_hwtstamp_get_t1(mac, seqid, &ts);
+		break;
+	case DELAY_REQ:
+	case PDELAY_RESP:
+		ret = mtk_ptp_hwtstamp_get_t3(mac, seqid, &ts);
+		break;
+	default:
+		dev_warn(eth->dev, "unrecognized hwtstamp msgtype (%d)!", msgtype);
+		goto out;
+	}
+
+	if (ret) {
+		if (time_is_before_jiffies(mac->ptp_tx_start +
+					   msecs_to_jiffies(500))) {
+			dev_warn(eth->dev, "detect %s hwtstamp timeout!",
+				 (msgtype == SYNC || msgtype == PDELAY_REQ) ? "t1" : "t3");
+			goto out;
+		} else {
+			schedule_work(&mac->ptp_tx_work);
+			return;
+		}
+	}
+
+	skb_shinfo(skb)->tx_flags |= SKBTX_IN_PROGRESS;
+
+	memset(&shhwtstamps, 0, sizeof(shhwtstamps));
+	shhwtstamps.hwtstamp = ktime_set(ts.tv_sec, ts.tv_nsec);
+	skb_tstamp_tx(skb, &shhwtstamps);
+
+out:
+	dev_kfree_skb_any(skb);
+	mac->ptp_tx_skb = NULL;
+	mac->ptp_tx_class = 0;
+	mac->ptp_tx_start = 0;
+}
+
+int mtk_ptp_hwtstamp_process_tx(struct net_device *dev, struct sk_buff *skb)
+{
+	struct mtk_mac *mac = netdev_priv(dev);
+	unsigned int ptp_class, offset = 0;
+
+	ptp_class = ptp_classify_raw(skb);
+	if (ptp_class == PTP_CLASS_NONE)
+		return 0;
+
+	if (ptp_class & PTP_CLASS_VLAN)
+		offset += VLAN_HLEN;
+
+	if ((ptp_class & PTP_CLASS_PMASK) == PTP_CLASS_L2)
+		offset += ETH_HLEN;
+	else
+		return 0;
+
+	mac->ptp_tx_skb = skb_get(skb);
+	mac->ptp_tx_class = ptp_class;
+	mac->ptp_tx_start = jiffies;
+	schedule_work(&mac->ptp_tx_work);
+
+	return 0;
+}
+
+int mtk_ptp_hwtstamp_process_rx(struct net_device *dev, struct sk_buff *skb)
+{
+	struct mtk_mac *mac = netdev_priv(dev);
+	struct mtk_eth *eth = mac->hw;
+	struct skb_shared_hwtstamps *shhwtstamps = skb_hwtstamps(skb);
+	struct timespec64 ts;
+	unsigned int ptp_class, offset = 0;
+	int ret;
+	u8 *data, msgtype;
+	u16 seqid;
+
+	ptp_class = ptp_classify_raw(skb);
+	if (ptp_class == PTP_CLASS_NONE)
+		return 0;
+
+	if (ptp_class & PTP_CLASS_VLAN)
+		offset += VLAN_HLEN;
+
+	if ((ptp_class & PTP_CLASS_PMASK) == PTP_CLASS_L2)
+		offset += ETH_HLEN;
+	else
+		return 0;
+
+	skb_reset_mac_header(skb);
+	data = skb_mac_header(skb);
+	seqid = get_unaligned_be16(data + offset + OFF_PTP_SEQUENCE_ID);
+	msgtype = data[offset] & 0x0f;
+	switch (msgtype) {
+	case SYNC:
+	case PDELAY_REQ:
+		ret = mtk_ptp_hwtstamp_get_t2(mac, seqid, &ts);
+		break;
+	case DELAY_REQ:
+	case PDELAY_RESP:
+		ret = mtk_ptp_hwtstamp_get_t4(mac, seqid, &ts);
+		break;
+	default:
+		dev_warn(eth->dev, "unrecognized hwtstamp msgtype (%d)!", msgtype);
+		return 0;
+	}
+
+	if (ret)
+		return ret;
+
+	memset(shhwtstamps, 0, sizeof(*shhwtstamps));
+	shhwtstamps->hwtstamp = ktime_set(ts.tv_sec, ts.tv_nsec);
+
+	return 0;
+}
+
+int mtk_ptp_hwtstamp_set_config(struct net_device *dev, struct ifreq *ifr)
+{
+	struct mtk_mac *mac = netdev_priv(dev);
+	struct mtk_eth *eth = mac->hw;
+	struct hwtstamp_config cfg;
+
+	if (!MTK_HAS_CAPS(eth->soc->caps, MTK_HWTSTAMP))
+		return -EOPNOTSUPP;
+
+	if (copy_from_user(&cfg, ifr->ifr_data, sizeof(cfg)))
+		return -EFAULT;
+
+	/* reserved for future extensions */
+	if (cfg.flags)
+		return -EINVAL;
+
+	if (cfg.tx_type != HWTSTAMP_TX_OFF && cfg.tx_type != HWTSTAMP_TX_ON &&
+	    cfg.tx_type != HWTSTAMP_TX_ONESTEP_SYNC)
+		return -ERANGE;
+
+	switch (cfg.rx_filter) {
+	case HWTSTAMP_FILTER_NONE:
+		eth->rx_ts_enabled = 0;
+		break;
+	case HWTSTAMP_FILTER_PTP_V2_L2_EVENT:
+	case HWTSTAMP_FILTER_PTP_V2_L2_SYNC:
+	case HWTSTAMP_FILTER_PTP_V2_L2_DELAY_REQ:
+		eth->rx_ts_enabled = HWTSTAMP_FILTER_PTP_V2_EVENT;
+		cfg.rx_filter = HWTSTAMP_FILTER_PTP_V2_EVENT;
+		break;
+	default:
+		return -ERANGE;
+	}
+
+	eth->tx_ts_enabled = cfg.tx_type;
+
+	mtk_ptp_hwtstamp_enable(dev, eth->tx_ts_enabled);
+
+	return copy_to_user(ifr->ifr_data, &cfg, sizeof(cfg)) ? -EFAULT : 0;
+}
+
+int mtk_ptp_hwtstamp_get_config(struct net_device *dev, struct ifreq *ifr)
+{
+	struct mtk_mac *mac = netdev_priv(dev);
+	struct mtk_eth *eth = mac->hw;
+	struct hwtstamp_config cfg;
+
+	if (!MTK_HAS_CAPS(eth->soc->caps, MTK_HWTSTAMP))
+		return -EOPNOTSUPP;
+
+	cfg.flags = 0;
+	cfg.tx_type = eth->tx_ts_enabled;
+	cfg.rx_filter = eth->rx_ts_enabled;
+
+	return copy_to_user(ifr->ifr_data, &cfg, sizeof(cfg)) ? -EFAULT : 0;
+}
+
+static void mtk_ptp_adjust_subsecond_width(struct mtk_eth *eth, long scaled_ppm)
+{
+	u64 base, adj;
+	u16 data16;
+	bool negative;
+
+	base = 0x4 << 16;
+	negative = diff_by_scaled_ppm(base, scaled_ppm, &adj);
+	data16 = (u16)adj;
+
+	mtk_w32(eth,
+		negative ? (base - data16) : (base + data16),
+		MAC_TS_TICK_SUBSECOND);
+
+	// update tick configuration
+	mtk_m32(eth, CSR_TICK_UPDATE, CSR_TICK_UPDATE, MAC_TS_TICK_CTRL);
+	mtk_m32(eth, CSR_TICK_UPDATE, 0, MAC_TS_TICK_CTRL);
+}
+
+static void mtk_ptp_adjust_second_width(struct mtk_eth *eth, long scaled_ppm)
+{
+	u64 base, adj;
+	bool negative;
+
+	base = 1000000000ULL;
+	negative = diff_by_scaled_ppm(base, scaled_ppm, &adj);
+
+	if (negative)
+		mtk_w32(eth, base + adj, MAC_TS_SECOND_VALUE);
+	else
+		mtk_w32(eth, base - adj, MAC_TS_SECOND_VALUE);
+}
+
+static int mtk_ptp_adjfine(struct ptp_clock_info *ptp, long scaled_ppm)
+{
+	struct mtk_eth *eth = container_of(ptp, struct mtk_eth, ptp_info);
+
+	if (scaled_ppm) {
+		switch (eth->ptp_mode) {
+		case 0:
+			mtk_ptp_adjust_subsecond_width(eth, scaled_ppm);
+			break;
+		case 1:
+			mtk_ptp_adjust_second_width(eth, scaled_ppm);
+			break;
+		default:
+			pr_warn("Adjust mode (%d) is not supported!", eth->ptp_mode);
+			break;
+		}
+	}
+
+	return 0;
+}
+
+static int mtk_ptp_adjtime(struct ptp_clock_info *ptp, s64 delta)
+{
+	struct mtk_eth *eth = container_of(ptp, struct mtk_eth, ptp_info);
+	struct timespec64 ts = ns_to_timespec64(delta);
+
+	mtk_w32(eth, (ts.tv_nsec >> 0) & 0xFFFFFFFF, MAC_TS_SUBSECOND_FIELD1);
+	mtk_w32(eth, (ts.tv_sec >>  0) & 0xFFFFFFFF, MAC_TS_SECOND_FIELD0);
+	mtk_w32(eth, (ts.tv_sec >> 32) & 0x0000FFFF, MAC_TS_SECOND_FIELD1);
+
+	// adjust timestamp
+	mtk_m32(eth, CSR_TS_ADJUST, CSR_TS_ADJUST, MAC_TS_TIMESTAMP_CTRL);
+	mtk_m32(eth, CSR_TS_ADJUST, 0, MAC_TS_TIMESTAMP_CTRL);
+
+	return 0;
+}
+
+static int mtk_ptp_gettime64(struct ptp_clock_info *ptp,
+			     struct timespec64 *ts)
+{
+	struct mtk_eth *eth = container_of(ptp, struct mtk_eth, ptp_info);
+	unsigned long t_start = jiffies;
+	u32 val[4];
+	int i;
+
+	mtk_w32(eth, CPU_TRIG, MAC_TS_CPU_TRIG);
+
+	while (1) {
+		if (!(mtk_r32(eth, MAC_TS_CPU_TRIG) & CPU_TS_VALID))
+			break;
+		if (time_after(jiffies, t_start + jiffies_to_msecs(1000))) {
+			pr_warn("cpu trigger timeout!");
+			return -ETIMEDOUT;
+		}
+		cond_resched();
+	}
+
+	for (i = 0; i < 4; i++)
+		val[i] = mtk_r32(eth, MAC_TS_CPU_TS_DW(i));
+
+	ts->tv_sec = val[2] | ((u64)val[3] << 32);
+	ts->tv_nsec = val[1];
+
+	return 0;
+}
+
+static int mtk_ptp_settime64(struct ptp_clock_info *ptp,
+			     const struct timespec64 *ts)
+{
+	struct mtk_eth *eth = container_of(ptp, struct mtk_eth, ptp_info);
+
+	mtk_w32(eth, (ts->tv_nsec >> 0) & 0xFFFFFFFF, MAC_TS_SUBSECOND_FIELD1);
+	mtk_w32(eth, (ts->tv_sec >>  0) & 0xFFFFFFFF, MAC_TS_SECOND_FIELD0);
+	mtk_w32(eth, (ts->tv_sec >> 32) & 0x0000FFFF, MAC_TS_SECOND_FIELD1);
+
+	// update timestamp
+	mtk_m32(eth, CSR_TS_UPDATE, CSR_TS_UPDATE, MAC_TS_TIMESTAMP_CTRL);
+	mtk_m32(eth, CSR_TS_UPDATE, 0, MAC_TS_TIMESTAMP_CTRL);
+
+	return 0;
+}
+
+static int mtk_ptp_enable(struct ptp_clock_info *ptp,
+			  struct ptp_clock_request *request, int on)
+{
+	struct mtk_eth *eth = container_of(ptp, struct mtk_eth, ptp_info);
+
+	// enable rx T1/T3 timestamp mask
+	mtk_w32(eth, 0x00000077, MAC_TS_RSV);
+	// update tick configuration
+	mtk_m32(eth, CSR_TICK_UPDATE, CSR_TICK_UPDATE, MAC_TS_TICK_CTRL);
+	mtk_m32(eth, CSR_TICK_UPDATE, 0, MAC_TS_TICK_CTRL);
+	// enable tick
+	mtk_m32(eth, CSR_TICK_RUN, on, MAC_TS_TICK_CTRL);
+
+	return 0;
+}
+
+static const struct ptp_clock_info mtk_ptp_caps = {
+	.owner		= THIS_MODULE,
+	.name		= "mtk_ptp",
+	.max_adj	= 24999999,
+	.n_alarm	= 0,
+	.n_ext_ts	= 0,
+	.n_per_out	= 1,
+	.n_pins		= 0,
+	.pps		= 0,
+	.adjfine	= mtk_ptp_adjfine,
+	.adjtime	= mtk_ptp_adjtime,
+	.gettime64	= mtk_ptp_gettime64,
+	.settime64	= mtk_ptp_settime64,
+	.enable		= mtk_ptp_enable,
+};
+
+int mtk_ptp_clock_init(struct mtk_eth *eth)
+{
+	struct mtk_mac *mac;
+	int i;
+
+	eth->ptp_mode = 1;	// 0 for adjusting subsecond width, 1 for adjusting second width.
+	eth->ptp_info = mtk_ptp_caps;
+	eth->ptp_clock = ptp_clock_register(&eth->ptp_info,
+					    eth->dev);
+	if (IS_ERR(eth->ptp_clock)) {
+		eth->ptp_clock = NULL;
+		return -EINVAL;
+	}
+
+	for (i = 0; i < MTK_MAX_DEVS; i++) {
+		mac = eth->mac[i];
+		if (!mac)
+			continue;
+
+		INIT_WORK(&mac->ptp_tx_work, mtk_ptp_hwtstamp_tx_work);
+	}
+
+	mtk_ptp_enable(&eth->ptp_info, NULL, 1);
+
+	return 0;
+}
+
+int mtk_ptp_clock_deinit(struct mtk_eth *eth)
+{
+	struct mtk_mac *mac;
+	int i;
+
+	for (i = 0; i < MTK_MAX_DEVS; i++) {
+		mac = eth->mac[i];
+		if (!mac)
+			continue;
+
+		cancel_work_sync(&mac->ptp_tx_work);
+		dev_kfree_skb_any(mac->ptp_tx_skb);
+		mac->ptp_tx_skb = NULL;
+		mac->ptp_tx_class = 0;
+		mac->ptp_tx_start = 0;
+	}
+
+	mtk_ptp_enable(&eth->ptp_info, NULL, 0);
+
+	ptp_clock_unregister(eth->ptp_clock);
+
+	return 0;
+}
--- a/drivers/net/ethernet/mediatek/mtk_eth_soc.c
+++ b/drivers/net/ethernet/mediatek/mtk_eth_soc.c
@@ -2761,6 +2761,9 @@ static int mtk_poll_rx(struct napi_struc
 		skb->dev = netdev;
 		bytes += skb->len;
 
+		if (MTK_HAS_CAPS(eth->soc->caps, MTK_HWTSTAMP) && eth->rx_ts_enabled)
+			mtk_ptp_hwtstamp_process_rx(eth->netdev[mac], skb);
+
 		if (mtk_is_netsys_v3_or_greater(eth)) {
 			reason = FIELD_GET(MTK_RXD5_PPE_CPU_REASON, trxd.rxd5);
 			hash = trxd.rxd5 & MTK_RXD5_FOE_ENTRY;
@@ -2909,6 +2912,11 @@ static int mtk_poll_tx_qdma(struct mtk_e
 		if (!tx_buf->data)
 			break;
 
+		if (unlikely(MTK_HAS_CAPS(eth->soc->caps, MTK_HWTSTAMP) &&
+			     tx_buf->data != (struct sk_buff *)MTK_DMA_DUMMY_DESC &&
+			     skb_shinfo(tx_buf->data)->tx_flags & SKBTX_HW_TSTAMP))
+			mtk_ptp_hwtstamp_process_tx(eth->netdev[tx_buf->mac_id], tx_buf->data);
+
 		if (tx_buf->data != (void *)MTK_DMA_DUMMY_DESC) {
 			if (tx_buf->type == MTK_TYPE_SKB)
 				mtk_poll_tx_done(eth, state, tx_buf->mac_id,
@@ -2949,6 +2957,11 @@ static int mtk_poll_tx_pdma(struct mtk_e
 		if (!tx_buf->data)
 			break;
 
+		if (unlikely(MTK_HAS_CAPS(eth->soc->caps, MTK_HWTSTAMP) &&
+			     tx_buf->data != (struct sk_buff *)MTK_DMA_DUMMY_DESC &&
+			     skb_shinfo(tx_buf->data)->tx_flags & SKBTX_HW_TSTAMP))
+			mtk_ptp_hwtstamp_process_tx(eth->netdev[tx_buf->mac_id], tx_buf->data);
+
 		if (tx_buf->data != (void *)MTK_DMA_DUMMY_DESC) {
 			if (tx_buf->type == MTK_TYPE_SKB)
 				mtk_poll_tx_done(eth, state, 0, tx_buf->data);
@@ -4473,6 +4486,9 @@ static int mtk_open(struct net_device *d
 			mtk_gdm_config(eth, target_mac->id, gdm_config);
 		}
 
+		if (MTK_HAS_CAPS(eth->soc->caps, MTK_HWTSTAMP))
+			mtk_ptp_clock_init(eth);
+
 		napi_enable(&eth->tx_napi);
 		napi_enable(&eth->rx_napi[0].napi);
 		mtk_tx_irq_enable(eth, MTK_TX_DONE_INT);
@@ -4623,6 +4639,9 @@ static int mtk_stop(struct net_device *d
 		mtk_stop_dma(eth, eth->soc->reg_map->qdma.glo_cfg);
 	mtk_stop_dma(eth, eth->soc->reg_map->pdma.glo_cfg);
 
+	if (MTK_HAS_CAPS(eth->soc->caps, MTK_HWTSTAMP))
+		mtk_ptp_clock_deinit(eth);
+
 	mtk_dma_free(eth);
 
 	for (i = 0; i < ARRAY_SIZE(eth->ppe); i++)
@@ -5519,6 +5538,10 @@ static int mtk_do_ioctl(struct net_devic
 	struct mtk_mac *mac = netdev_priv(dev);
 
 	switch (cmd) {
+	case SIOCSHWTSTAMP:
+		return mtk_ptp_hwtstamp_set_config(dev, ifr);
+	case SIOCGHWTSTAMP:
+		return mtk_ptp_hwtstamp_get_config(dev, ifr);
 	case SIOCGMIIPHY:
 	case SIOCGMIIREG:
 	case SIOCSMIIREG:
@@ -6015,6 +6038,28 @@ static int mtk_set_pauseparam(struct net
 	return phylink_ethtool_set_pauseparam(mac->phylink, pause);
 }
 
+static int mtk_get_ts_info(struct net_device *dev, struct kernel_ethtool_ts_info *info)
+{
+	struct mtk_mac *mac = netdev_priv(dev);
+	struct mtk_eth *eth = mac->hw;
+
+	if (!MTK_HAS_CAPS(eth->soc->caps, MTK_HWTSTAMP))
+		return -EOPNOTSUPP;
+
+	info->so_timestamping = SOF_TIMESTAMPING_TX_HARDWARE |
+				SOF_TIMESTAMPING_RX_HARDWARE |
+				SOF_TIMESTAMPING_RAW_HARDWARE;
+	info->phc_index = 0;
+	info->tx_types = (1 << HWTSTAMP_TX_OFF) |
+			 (1 << HWTSTAMP_TX_ON) |
+			 (1 << HWTSTAMP_TX_ONESTEP_SYNC);
+	info->rx_filters = (1 << HWTSTAMP_FILTER_NONE) |
+			   (1 << HWTSTAMP_FILTER_PTP_V2_L2_SYNC) |
+			   (1 << HWTSTAMP_FILTER_PTP_V2_L2_DELAY_REQ);
+
+	return 0;
+}
+
 static int mtk_get_eee(struct net_device *dev, struct ethtool_keee *eee)
 {
 	struct mtk_mac *mac = netdev_priv(dev);
@@ -6159,6 +6204,7 @@ static const struct ethtool_ops mtk_etht
 	.get_rxfh_indir_size	= mtk_get_rxfh_indir_size,
 	.get_rxfh		= mtk_get_rxfh,
 	.set_rxfh		= mtk_set_rxfh,
+	.get_ts_info		= mtk_get_ts_info,
 	.get_eee		= mtk_get_eee,
 	.set_eee		= mtk_set_eee,
 };
--- a/drivers/net/ethernet/mediatek/mtk_eth_soc.h
+++ b/drivers/net/ethernet/mediatek/mtk_eth_soc.h
@@ -15,6 +15,7 @@
 #include <linux/u64_stats_sync.h>
 #include <linux/refcount.h>
 #include <linux/phylink.h>
+#include <linux/ptp_clock_kernel.h>
 #include <linux/reset.h>
 #include <linux/rhashtable.h>
 #include <linux/dim.h>
@@ -690,6 +691,63 @@
 #define MTK_XMAC_CNT_CTRL(x)	(MTK_XMAC_BASE(x) + 0x100)
 #define XMAC_GLB_CNTCLR		BIT(0)
 
+/* MAC timestamp registers */
+#define MTK_MAC_TS_T1(x)	(0x13000 + ((x) * 0x80))
+#define MAC_TS_T1_SID1(x)	(MTK_MAC_TS_T1(x) + 0x0)
+#define MAC_TS_T1_DW(x)		(MTK_MAC_TS_T1(x) + 0x4)
+#define MAC_TS_T1_SID2(x)	(MTK_MAC_TS_T1(x) + 0x14)
+
+#define MTK_MAC_TS_T2(x)	(0x13020 + ((x) * 0x80))
+#define MAC_TS_T2_SID1(x)	(MTK_MAC_TS_T2(x) + 0x0)
+#define MAC_TS_T2_DW(x)		(MTK_MAC_TS_T2(x) + 0x4)
+#define MAC_TS_T2_SID2(x)	(MTK_MAC_TS_T2(x) + 0x14)
+
+#define MTK_MAC_TS_T3(x)	(0x13040 + ((x) * 0x80))
+#define MAC_TS_T3_SID1(x)	(MTK_MAC_TS_T3(x) + 0x0)
+#define MAC_TS_T3_DW(x)		(MTK_MAC_TS_T3(x) + 0x4)
+#define MAC_TS_T3_SID2(x)	(MTK_MAC_TS_T3(x) + 0x14)
+
+#define MTK_MAC_TS_T4(x)	(0x13060 + ((x) * 0x80))
+#define MAC_TS_T4_SID1(x)	(MTK_MAC_TS_T4(x) + 0x0)
+#define MAC_TS_T4_DW(x)		(MTK_MAC_TS_T4(x) + 0x4)
+#define MAC_TS_T4_SID2(x)	(MTK_MAC_TS_T4(x) + 0x14)
+
+#define MTK_MAC_TS_CTRL		(0x13800)
+#define MAC_TS_IRQ_EN		(MTK_MAC_TS_CTRL)
+#define MAC_TS_IRQ_STS		(MTK_MAC_TS_CTRL + 0x10)
+#define MAC_TS_IRQ_FRC		(MTK_MAC_TS_CTRL + 0x20)
+#define MAC_TS_MODE_CTRL	(MTK_MAC_TS_CTRL + 0x30)
+#define MAC_TS_CPU_TRIG		(MTK_MAC_TS_CTRL + 0x40)
+#define CPU_TS_VALID		BIT(1)
+#define CPU_TRIG		BIT(0)
+
+#define MAC_TS_CPU_TS_DW(x)	(MTK_MAC_TS_CTRL + 0x44 + ((x) * 4))
+#define MAC_TS_SUBSECOND_FIELD0	(MTK_MAC_TS_CTRL + 0x80)
+#define MAC_TS_SUBSECOND_FIELD1	(MTK_MAC_TS_CTRL + 0x84)
+#define MAC_TS_SECOND_FIELD0	(MTK_MAC_TS_CTRL + 0x88)
+#define MAC_TS_SECOND_FIELD1	(MTK_MAC_TS_CTRL + 0x8C)
+
+#define MAC_TS_TIMESTAMP_CTRL	(MTK_MAC_TS_CTRL + 0x90)
+#define CSR_TS_ADJUST		BIT(1)
+#define CSR_TS_UPDATE		BIT(0)
+
+#define MAC_TS_TICK_SUBSECOND	(MTK_MAC_TS_CTRL + 0xA0)
+#define CSR_TICK_NANOSECOND	GENMASK(31, 16)
+#define CSR_TICK_SUB_NANOSECOND	GENMASK(15, 0)
+
+#define MAC_TS_TICK_CTRL	(MTK_MAC_TS_CTRL + 0xA4)
+#define CSR_TICK_UPDATE		BIT(1)
+#define CSR_TICK_RUN		BIT(0)
+
+#define MAC_TS_MAC_CFG		(MTK_MAC_TS_CTRL + 0xA8)
+#define CSR_HW_TS_EN(x)		BIT(x)
+
+#define MAC_TS_SECOND_VALUE	(MTK_MAC_TS_CTRL + 0xB0)
+
+#define MAC_TS_RSV		(MTK_MAC_TS_CTRL + 0xB4)
+#define TS_T1_MASK		GENMASK(2, 0)
+#define TS_T3_MASK		GENMASK(6, 4)
+
 /* GPIO port control registers for GMAC 2*/
 #define GPIO_OD33_CTRL8		0x4c0
 #define GPIO_BIAS_CTRL		0xed0
@@ -1269,6 +1327,7 @@ enum mkt_eth_capabilities {
 	MTK_INFRA_BIT,
 	MTK_SHARED_SGMII_BIT,
 	MTK_GLO_MEM_ACCESS_BIT,
+	MTK_HWTSTAMP_BIT,
 	MTK_HWLRO_BIT,
 	MTK_RSS_BIT,
 	MTK_SHARED_INT_BIT,
@@ -1322,6 +1381,7 @@ enum mkt_eth_capabilities {
 #define MTK_INFRA		BIT_ULL(MTK_INFRA_BIT)
 #define MTK_SHARED_SGMII	BIT_ULL(MTK_SHARED_SGMII_BIT)
 #define MTK_GLO_MEM_ACCESS	BIT_ULL(MTK_GLO_MEM_ACCESS_BIT)
+#define MTK_HWTSTAMP		BIT_ULL(MTK_HWTSTAMP_BIT)
 #define MTK_HWLRO		BIT_ULL(MTK_HWLRO_BIT)
 #define MTK_RSS			BIT_ULL(MTK_RSS_BIT)
 #define MTK_SHARED_INT		BIT_ULL(MTK_SHARED_INT_BIT)
@@ -1450,7 +1510,7 @@ enum mkt_eth_capabilities {
 		      MTK_MUX_GMAC123_TO_GEPHY_SGMII | MTK_MUX_GMAC2_TO_2P5GPHY | \
 		      MTK_MUX_U3_GMAC23_TO_QPHY | MTK_U3_COPHY_V2 | MTK_SRAM | \
 		      MTK_QDMA | MTK_PDMA_INT | MTK_RSS | MTK_HWLRO | \
-		      MTK_GLO_MEM_ACCESS | MTK_RSTCTRL_PPE1)
+		      MTK_GLO_MEM_ACCESS | MTK_RSTCTRL_PPE1 | MTK_HWTSTAMP)
 
 #define MT7988_CAPS  (MTK_36BIT_DMA | MTK_GDM1_ESW | MTK_GMAC1_SGMII | \
 		      MTK_GMAC2_2P5GPHY | MTK_GMAC2_SGMII | MTK_GMAC2_USXGMII | \
@@ -1675,6 +1735,12 @@ struct mtk_eth {
 	struct work_struct		pending_work;
 	unsigned long			state;
 
+	struct ptp_clock_info		ptp_info;
+	struct ptp_clock		*ptp_clock;
+	int				ptp_mode;
+	int				tx_ts_enabled;
+	int				rx_ts_enabled;
+
 	const struct mtk_soc_data	*soc;
 
 	spinlock_t			dim_lock;
@@ -1750,6 +1816,10 @@ struct mtk_mac {
 	int				hwlro_ip_cnt;
 	unsigned int			syscfg0;
 	struct notifier_block		device_notifier;
+	struct work_struct		ptp_tx_work;
+	struct sk_buff			*ptp_tx_skb;
+	unsigned long			ptp_tx_start;
+	unsigned int			ptp_tx_class;
 };
 
 #define MTK_MUX_CHANNELS_MAX	2
@@ -1916,6 +1986,13 @@ int mtk_gmac_gephy_path_setup(struct mtk
 int mtk_gmac_rgmii_path_setup(struct mtk_eth *eth, int mac_id);
 int mtk_gmac_usxgmii_path_setup(struct mtk_eth *eth, int mac_id);
 
+int mtk_ptp_hwtstamp_process_tx(struct net_device *dev, struct sk_buff *skb);
+int mtk_ptp_hwtstamp_process_rx(struct net_device *dev, struct sk_buff *skb);
+int mtk_ptp_hwtstamp_set_config(struct net_device *dev, struct ifreq *ifr);
+int mtk_ptp_hwtstamp_get_config(struct net_device *dev, struct ifreq *ifr);
+int mtk_ptp_clock_init(struct mtk_eth *eth);
+int mtk_ptp_clock_deinit(struct mtk_eth *eth);
+
 int mtk_eth_offload_init(struct mtk_eth *eth, u8 id);
 int mtk_eth_setup_tc(struct net_device *dev, enum tc_setup_type type,
 		     void *type_data);
