From 743f5744388b88ba8bc0ae7912d4754438b29078 Mon Sep 17 00:00:00 2001
From: Bo-Cun Chen <bc-bocun.chen@mediatek.com>
Date: Wed, 28 Jan 2026 13:37:33 +0800
Subject: [PATCH] net: phy: as21xxx: update driver to v1.9.2

Changes from Firmware Version 1.9.1:
1. [firmware] 10G performance is optimized for non-standard RJ45 with
              Wi-Fi filter.
2. [firmware] 10G performance is optimized for non-standard CAT5E RJ45
              connector.
3. [firmware] anti-Wi-Fi interference capabilities are optimized.
4. [firmware] IOP performance is improved.
5. [firmweare/GUI] SerDes eye pattern is added.
6. [driver]: PHY log reading function is implemented in driver.
7. [firmware/driver]: 10G/non-10G LED feature is implemented.
                      (note: firmware 1.9.2 depends on driver 1.9.2)
8. [firmware] auto crossover issue of force 100M mode and parallel
              detection issue are fixed.

This patch also introduces an as21xx_bbu_api, which allows users to use
debugfs to get or set the PHY mode for debugging purposes.

Signed-off-by: Bo-Cun Chen <bc-bocun.chen@mediatek.com>
---
 drivers/net/phy/Makefile                      |    3 +-
 drivers/net/phy/as21xx_bbu_api/as21xx_api.c   | 1867 ++++++++
 drivers/net/phy/as21xx_bbu_api/as21xx_api.h   |  923 ++++
 .../net/phy/as21xx_bbu_api/as21xx_debugfs.c   | 3774 +++++++++++++++++
 .../net/phy/as21xx_bbu_api/as21xx_debugfs.h   |   45 +
 drivers/net/phy/as21xxx.c                     | 1585 +++++--
 drivers/net/phy/as21xxx.h                     |   65 +
 7 files changed, 7863 insertions(+), 399 deletions(-)
 create mode 100644 drivers/net/phy/as21xx_bbu_api/as21xx_api.c
 create mode 100644 drivers/net/phy/as21xx_bbu_api/as21xx_api.h
 create mode 100644 drivers/net/phy/as21xx_bbu_api/as21xx_debugfs.c
 create mode 100644 drivers/net/phy/as21xx_bbu_api/as21xx_debugfs.h
 create mode 100644 drivers/net/phy/as21xxx.h

diff --git a/drivers/net/phy/Makefile b/drivers/net/phy/Makefile
index a20b99d..68aa831 100644
--- a/drivers/net/phy/Makefile
+++ b/drivers/net/phy/Makefile
@@ -58,7 +58,8 @@ obj-$(CONFIG_AIR_EN8811H_PHY)   += air_en8811h.o
 obj-$(CONFIG_AMD_PHY)		+= amd.o
 obj-$(CONFIG_AMCC_QT2025_PHY)	+= qt2025.o
 obj-$(CONFIG_AQUANTIA_PHY)	+= aquantia/
-obj-$(CONFIG_AS21XXX_PHY)	+= as21xxx.o
+obj-$(CONFIG_AS21XXX_PHY)	+= aeon_as21xxx.o
+aeon_as21xxx-objs	:= as21xxx.o as21xx_bbu_api/as21xx_debugfs.o as21xx_bbu_api/as21xx_api.o
 ifdef CONFIG_AX88796B_RUST_PHY
   obj-$(CONFIG_AX88796B_PHY)	+= ax88796b_rust.o
 else
diff --git a/drivers/net/phy/as21xx_bbu_api/as21xx_api.c b/drivers/net/phy/as21xx_bbu_api/as21xx_api.c
new file mode 100644
index 0000000..91ee731
--- /dev/null
+++ b/drivers/net/phy/as21xx_bbu_api/as21xx_api.c
@@ -0,0 +1,1867 @@
+// SPDX-License-Identifier: GPL-2.0
+
+/******************************************************************************
+ *
+ * AEONSEMI CONFIDENTIAL
+ * _____________________
+ *
+ * Aeonsemi Inc., 2023
+ * All Rights Reserved.
+ *
+ * NOTICE:  All information contained herein is, and remains the property of
+ * Aeonsemi Inc. and its subsidiaries, if any. The intellectual and technical
+ * concepts contained herein are proprietary to Aeonsemi Inc. and its
+ * subsidiaries and may be covered by U.S. and Foreign Patents, patents in
+ * process, and are protected by trade secret or copyright law. Dissemination
+ * of this information or reproduction of this material is strictly forbidden
+ * unless prior written permission is obtained from Aeonsemi Inc.
+ *
+ *
+ *****************************************************************************/
+#include <linux/of_mdio.h>
+#include <linux/of_address.h>
+#include <linux/mii.h>
+#include <linux/phy.h>
+#include <linux/time.h>
+#include <linux/module.h>
+#include <../kernel/time/timekeeping.h>
+#include <linux/timekeeping.h>
+#include <linux/timex.h>
+#include <linux/delay.h>
+#include <linux/firmware.h>
+#include <linux/crc32.h>
+#include <linux/kernel.h>
+#include <linux/spinlock.h>
+#include <linux/interrupt.h>
+#include "../as21xxx.h"
+#include "as21xx_api.h"
+#include <linux/slab.h>
+#include <linux/string.h>
+
+MODULE_DESCRIPTION("Aeonsemi AS21XX PHY api drivers");
+MODULE_AUTHOR("Aeonsemi");
+MODULE_LICENSE("GPL");
+
+/******************************************************************************
+ * Low-Level MDIO Function Interface
+ *****************************************************************************/
+static unsigned short aeon_mdio_read_reg(struct phy_device *phydev,
+					 unsigned int reg_addr)
+{
+	unsigned short val = 0;
+	unsigned short dev_addr = (reg_addr >> 17) & 0x1F;
+	unsigned short phy_reg = (reg_addr >> 1) & 0xFFFF;
+
+	val = aeon_cl45_read(phydev, dev_addr, phy_reg);
+	return val;
+}
+
+static void aeon_mdio_write_reg(struct phy_device *phydev, unsigned int reg_addr,
+				unsigned short value)
+{
+	unsigned short dev_addr = (reg_addr >> 17) & 0x1F;
+	unsigned short phy_reg = (reg_addr >> 1) & 0xFFFF;
+
+	aeon_cl45_write(phydev, dev_addr, phy_reg, value);
+}
+
+static unsigned short aeon_mdio_read_reg_field(struct phy_device *phydev, unsigned int reg_addr,
+					       unsigned short field)
+{
+	unsigned short val = aeon_mdio_read_reg(phydev, reg_addr);
+	unsigned short width = (field & 0xFF);
+	unsigned short offset = ((field >> 8) & 0xFF);
+	unsigned short mask = ((1 << width) - 1);
+
+	return ((val >> offset) & mask);
+}
+
+static void aeon_mdio_write_reg_field(struct phy_device *phydev, unsigned int reg_addr,
+				      unsigned short field, unsigned short value)
+{
+	unsigned short val = aeon_mdio_read_reg(phydev, reg_addr);
+	unsigned short width = (field & 0xFF);
+	unsigned short offset = ((field >> 8) & 0xFF);
+	unsigned short mask = ((1 << width) - 1) << offset;
+
+	val = (val & ~mask) | ((value & ((1 << width) - 1)) << offset);
+	aeon_mdio_write_reg(phydev, reg_addr, val);
+}
+
+/******************************************************************************
+ * Mid-Level IPC Function Interface
+ *****************************************************************************/
+static void aeon_send_ipc_cmd(struct phy_device *phydev, unsigned short cmd)
+{
+	aeon_mdio_write_reg(phydev, IPC_CMD_BASEADDR, cmd);
+}
+
+static void aeon_set_ipc_data_reg(struct phy_device *phydev, unsigned int len,
+				  unsigned short *val)
+{
+	int ii;
+
+	if (len >= 8)
+		len = 8;
+	for (ii = 0; ii < len; ii++) {
+		aeon_mdio_write_reg(phydev, IPC_DATA0_BASEADDR + 2 * ii,
+				    *(val + ii));
+	}
+}
+
+static unsigned short aeon_get_ipc_status(struct phy_device *phydev)
+{
+	unsigned short val;
+
+	val = aeon_mdio_read_reg(phydev, IPC_STS_BASEADDR);
+
+	return val;
+}
+
+static void aeon_ipc_parse_sts(unsigned short sts, unsigned short *status,
+			       unsigned short *opcode, unsigned short *size,
+			       unsigned short *parity)
+{
+	/*
+	 * """Parse the 16-bit full status into components.
+	 * 16-bit status register is laid out as follows:
+	 * [1 parity][5 size][6 opcode][4 status]
+	 */
+	unsigned short status_mask = (1 << IPC_NB_STATUS) - 1;
+	unsigned short opcode_mask = (1 << IPC_NB_OPCODE) - 1;
+	unsigned short size_mask = (1 << IPC_PAYLOAD_NB) - 1;
+	// Clip off status bits
+	*status = sts & status_mask;
+	sts = (sts >> IPC_NB_STATUS);
+	// Clip off opcode
+	*opcode = (sts & opcode_mask);
+	sts = (sts >> IPC_NB_OPCODE);
+	// Clip off size
+	*size = (sts & size_mask);
+	sts = (sts >> IPC_PAYLOAD_NB);
+	// Get parity bit
+	*parity = sts & 1;
+}
+
+static void aeon_receive_ipc_data(struct phy_device *phydev, unsigned short len,
+				  unsigned short *data)
+{
+	int ii;
+
+	if (len > 8)
+		len = 8;
+	for (ii = 0; ii < len; ii++) {
+		*(data + ii) = aeon_mdio_read_reg(phydev, IPC_DATA0_BASEADDR +
+								  (ii << 1));
+	}
+}
+
+static unsigned int ipc_cmd_num;
+static unsigned int get_par(void)
+{
+	return ipc_cmd_num & 0x1;
+}
+
+static void aeon_ipc_build_cmd(unsigned short *cmd, short opcode, short size)
+{
+	/*
+	 * """Construct the full command word.
+	 * 16-bit register is laid out as follows:
+	 * [1 cmd par][4 reserved][5 size][6 opcode]
+	 */
+	unsigned short opcode_mask = (1 << IPC_NB_OPCODE) - 1;
+	unsigned short size_mask = (1 << IPC_PAYLOAD_NB) - 1;
+	unsigned short opcode_bits = opcode & opcode_mask;
+	unsigned short size_bits = size & size_mask;
+	unsigned short _cmd = 0;
+
+	_cmd = (size_bits << IPC_NB_OPCODE) + opcode_bits;
+
+	if (get_par() == 0)
+		_cmd &= ~IPC_CMD_PARITY;
+	else
+		_cmd |= IPC_CMD_PARITY;
+
+	*cmd = _cmd;
+	ipc_cmd_num++;
+}
+
+static void aeon_send_ipc_msg(struct phy_device *phydev, unsigned int len,
+			      unsigned short *val, short opcode, short size)
+{
+	unsigned short cmd;
+
+	aeon_set_ipc_data_reg(phydev, len, val);
+	aeon_ipc_build_cmd(&cmd, opcode, size);
+	aeon_send_ipc_cmd(phydev, cmd);
+}
+
+static unsigned short aeon_ipc_wait_cmd_done(struct phy_device *phydev,
+					     unsigned long *ns,
+					     unsigned short *ret_size)
+{
+	/*
+	 * """Wait until IPC status handshake returns DONE or READY.
+	 * timeout : seconds
+	 * Returns
+	 * -------
+	 *  status : int
+	 *  Return status:
+	 *  opcode : int
+	 *  serviced.
+	 *  ret_size : int
+	 *  Number of bytes in the return.
+	 */
+	struct timespec64 t1, t2;
+	unsigned long _to, _ns = 0;
+	unsigned short sts, opcode, ret_par;
+	unsigned short status = 0, par = 0;
+
+	if (ns)
+		_to = *ns;
+	else
+		_to = IPC_TIMEOUT;
+
+	ktime_get_real_ts64(&t1);
+	while ((par == 0) || ((status != IPC_STS_CMD_SUCCESS) &&
+			      (status != IPC_STS_CMD_ERROR))) {
+		mdelay(10);
+		sts = aeon_get_ipc_status(phydev);
+		aeon_ipc_parse_sts(sts, &status, &opcode, ret_size, &ret_par);
+		par = (get_par() != ret_par);
+
+		// Check return status
+		if (status == IPC_STS_CMD_ERROR)
+			break;
+
+		// Check timeout
+		ktime_get_real_ts64(&t2);
+		_ns = (t2.tv_sec - t1.tv_sec) * 1000000000 + t2.tv_nsec -
+		       t1.tv_nsec;
+		if (_ns > _to)
+			break;
+	}
+
+	return status;
+}
+
+#ifdef DUAL_FLASH
+static void aeon_ipc_send_bulk_write(unsigned int mem_addr, unsigned int size,
+				     struct phy_device *phydev)
+{
+	unsigned short status, ret_size;
+	unsigned short msg[4] = { mem_addr & 0xffff, mem_addr >> 16,
+				  size & 0xffff, size >> 16 };
+	struct device *dev = phydev_dev(phydev);
+
+	aeon_send_ipc_msg(phydev, 4, msg, IPC_CMD_BULK_WRITE, 8);
+
+	status = aeon_ipc_wait_cmd_done(phydev, NULL, &ret_size);
+	if (status != IPC_STS_CMD_SUCCESS) {
+		dev_err(dev, "IPC send bulk write command failed %x\n", status);
+		return;
+	}
+}
+
+static void aeon_ipc_send_bulk_data(unsigned short bw_type, unsigned short size,
+				    void *data, struct phy_device *phydev)
+{
+	unsigned short status, ret_size;
+	struct device *dev = phydev_dev(phydev);
+	// ipc data register is 16 bits, total 16 bytes per call.
+	switch (bw_type) {
+	case BW8:
+		size = (size + 1) / 2;
+		break;
+	case BW32:
+		size = size * 2;
+		break;
+	case BW16:
+	default:
+		break;
+	}
+
+	aeon_send_ipc_msg(phydev, size, (unsigned short *)data,
+			  IPC_CMD_BULK_DATA, size * 2);
+
+	status = aeon_ipc_wait_cmd_done(phydev, NULL, &ret_size);
+	if (status != IPC_STS_CMD_SUCCESS) {
+		dev_err(dev, "IPC Bulk data command failed: %x\n", status);
+		return;
+	}
+}
+#endif
+
+void aeon_ipc_cfg_param_direct(unsigned int data_len, unsigned short *data,
+			       struct phy_device *phydev)
+{
+	unsigned short _data = IPC_CMD_CFG_DIRECT;
+	unsigned short cmd, status, ret_size;
+	struct device *dev = phydev_dev(phydev);
+
+	aeon_set_ipc_data_reg(phydev, data_len + 1, data - 1);
+	aeon_set_ipc_data_reg(phydev, 1, &_data);
+
+	aeon_ipc_build_cmd(&cmd, IPC_CMD_CFG_PARAM, 2 * (data_len + 1));
+	aeon_send_ipc_cmd(phydev, cmd);
+
+	status = aeon_ipc_wait_cmd_done(phydev, NULL, &ret_size);
+	if (status != IPC_STS_CMD_SUCCESS) {
+		dev_err(dev, "IPC cfg param direct return status: %x\n",
+			status);
+		return;
+	}
+}
+
+static unsigned short aeon_ipc_dbg_cmd(struct phy_device *phydev, unsigned short dbg_sec,
+				       unsigned short dbg_cmd, unsigned short size)
+{
+	unsigned short data[8] = {0}, status, ret_size;
+
+	data[0] = (dbg_sec << 8) | dbg_cmd;
+	data[1] = size;
+	data[2] = 0;
+	aeon_send_ipc_msg(phydev, 3, data, IPC_OPCODE_DBGCMD, 6);
+	status = aeon_ipc_wait_cmd_done(phydev, NULL, &ret_size);
+	if (status != IPC_STS_CMD_SUCCESS)
+		return IPC_STS_CMD_ERROR;
+
+	return IPC_STS_CMD_SUCCESS;
+}
+
+static unsigned short aeon_ipc_wbuf(struct phy_device *phydev, void *write_data,
+				    unsigned short write_size, enum ipc_data_type_t write_type,
+				    unsigned short write_size_bytes,
+				    unsigned short write_size_words)
+{
+	unsigned short write_ipc_data_array[8] = {0};
+	unsigned short *write_ipc_data = (unsigned short *)write_ipc_data_array;
+	unsigned short ret_size, status;
+	unsigned char *src;
+	unsigned int *src_int;
+	unsigned short *src_short;
+	int i;
+
+	if (write_data && write_size > 0) {
+		if (write_type == IPC_DATA_UINT16) {
+			for (i = 0; i < write_size; i++) {
+				src_short = (unsigned short *)write_data;
+				write_ipc_data[i] = src_short[i];
+			}
+		} else {
+			if (write_type == IPC_DATA_UINT8) {
+				src = (unsigned char *)write_data;
+				for (i = 0; i < write_size; i += 2) {
+					write_ipc_data[i/2] = src[i];
+					if (i + 1 < write_size)
+						write_ipc_data[i/2] |= (src[i+1] << 8);
+				}
+			} else if (write_type == IPC_DATA_UINT32) {
+				src_int = (unsigned int *)write_data;
+				for (i = 0; i < write_size; i++) {
+					write_ipc_data[i*2] = src_int[i] & 0xFFFF;
+					write_ipc_data[i*2+1] = (src_int[i] >> 16) & 0xFFFF;
+				}
+			}
+		}
+
+		aeon_send_ipc_msg(phydev, write_size_words, write_ipc_data, IPC_OPCODE_WBUF,
+				  write_size_bytes);
+		status = aeon_ipc_wait_cmd_done(phydev, NULL, &ret_size);
+		if (status != IPC_STS_CMD_SUCCESS) {
+			phydev_err(phydev, "Write buffer command failed %x\n", status);
+			return IPC_STS_CMD_ERROR;
+		}
+	}
+
+	return IPC_STS_CMD_SUCCESS;
+}
+
+static unsigned short aeon_ipc_poll(struct phy_device *phydev)
+{
+	unsigned short done = 0, iter = 0, status = 0, ret_size = 0, cmd = 0;
+
+	while ((done == 0) && (iter < MAX_POLL)) {
+		aeon_ipc_build_cmd(&cmd, IPC_OPCODE_POLL, 0);
+		aeon_send_ipc_cmd(phydev, cmd);
+		status = aeon_ipc_wait_cmd_done(phydev, NULL, &ret_size);
+		if (status != IPC_STS_CMD_SUCCESS) {
+			phydev_err(phydev, "Read buffer command failed %x\n", status);
+			return IPC_STS_CMD_ERROR;
+		}
+		done = aeon_mdio_read_reg(phydev, IPC_DATA0_BASEADDR);
+
+		iter++;
+	}
+
+	return IPC_STS_CMD_SUCCESS;
+}
+
+static unsigned short aeon_ipc_recv(struct phy_device *phydev, void *recv_buf,
+				    unsigned short recv_size, enum ipc_data_type_t recv_type)
+{
+	unsigned char *temp_buf = NULL;
+	unsigned char *read_target, *p_data;
+	unsigned short ctr = 0, status, reg_val, cmd, ret_size;
+	unsigned short *dst;
+	unsigned int *dst_int;
+	int i;
+
+	if (recv_buf && recv_size > 0) {
+		if (recv_type != IPC_DATA_UINT8) {
+			temp_buf = kmalloc(recv_size, GFP_KERNEL);
+			if (!temp_buf)
+				return IPC_STS_CMD_ERROR;
+
+			read_target = temp_buf;
+		} else
+			read_target = (unsigned char *)recv_buf;
+
+		while (recv_size > ctr) {
+			p_data = read_target + ctr;
+			aeon_ipc_build_cmd(&cmd, IPC_OPCODE_RBUF, 0);
+			aeon_send_ipc_cmd(phydev, cmd);
+			status = aeon_ipc_wait_cmd_done(phydev, NULL, &ret_size);
+
+			if (status != IPC_STS_CMD_SUCCESS) {
+				phydev_err(phydev, "Read buffer command failed %x\n", status);
+				return IPC_STS_CMD_ERROR;
+			}
+
+			for (i = 0; i < IPC_PAYLOAD_WORDS; ++i) {
+				reg_val = aeon_mdio_read_reg(phydev, IPC_DATA0_BASEADDR + (i << 1));
+				p_data[i * 2] = reg_val & 0xFF;
+				p_data[i * 2 + 1] = (reg_val >> 8) & 0xFF;
+			}
+
+			ctr += IPC_PAYLOAD_SIZE;
+		}
+
+		if (recv_type != IPC_DATA_UINT8) {
+			if (recv_type == IPC_DATA_UINT16) {
+				dst = (unsigned short *)recv_buf;
+				for (i = 0; i < recv_size / 2; i++)
+					dst[i] = temp_buf[i*2] | (temp_buf[i*2+1] << 8);
+			} else if (recv_type == IPC_DATA_UINT32) {
+				dst_int = (unsigned int *)recv_buf;
+				for (i = 0; i < recv_size / 4; i++) {
+					dst_int[i] = temp_buf[i*4] |
+						     (temp_buf[i*4+1] << 8) |
+						     (temp_buf[i*4+2] << 16) |
+						     (temp_buf[i*4+3] << 24);
+				}
+			}
+			kfree(temp_buf);
+		}
+	}
+
+	return IPC_STS_CMD_SUCCESS;
+}
+
+static unsigned short aeon_ipc_operation(struct phy_device *phydev, unsigned short dbg_sec,
+					 unsigned short dbg_cmd, void *write_data,
+					 unsigned short write_size, enum ipc_data_type_t write_type,
+					 void *recv_buf, unsigned short recv_size,
+					 enum ipc_data_type_t recv_type)
+{
+	unsigned short ret;
+	unsigned short write_size_bytes = 0;
+	unsigned short write_size_words = 0;
+
+	if (write_data && write_size > 0) {
+		write_size_bytes = write_size * write_type;
+		write_size_words = (write_size_bytes + 1) / 2;
+	}
+
+	// Step 1
+	ret = aeon_ipc_dbg_cmd(phydev, dbg_sec, dbg_cmd, write_size_bytes);
+	if (ret != IPC_STS_CMD_SUCCESS) {
+		phydev_err(phydev, "AS21xx debug command failed %x\n", ret);
+		return IPC_STS_CMD_ERROR;
+	}
+	aeon_ipc_sync_parity(phydev);
+
+	// Step 2
+	ret = aeon_ipc_wbuf(phydev, write_data, write_size, write_type, write_size_bytes,
+			    write_size_words);
+	if (ret != IPC_STS_CMD_SUCCESS) {
+		phydev_err(phydev, "AS21xx write buffer command failed %x\n", ret);
+		return IPC_STS_CMD_ERROR;
+	}
+	aeon_ipc_sync_parity(phydev);
+	ret = aeon_ipc_poll(phydev);
+	if (ret != IPC_STS_CMD_SUCCESS) {
+		phydev_err(phydev, "AS21xx ipc poll command failed %x\n", ret);
+		return IPC_STS_CMD_ERROR;
+	}
+
+	// Step 3
+	ret = aeon_ipc_recv(phydev, recv_buf, recv_size, recv_type);
+	if (ret != IPC_STS_CMD_SUCCESS) {
+		phydev_err(phydev, "AS21xx ipc recv command failed %x\n", ret);
+		return IPC_STS_CMD_ERROR;
+	}
+	aeon_ipc_sync_parity(phydev);
+
+	return IPC_STS_CMD_SUCCESS;
+}
+
+/******************************************************************************
+ * Top-Level Public Function Interface
+ *****************************************************************************/
+#ifndef AEON_SEI2
+void aeon_pkt_chk_cfg(unsigned short enable, struct phy_device *phydev)
+{
+	unsigned short data[8], reg_num = 4;
+
+	data[0] = CFG_DPC_PKT_CHK;
+	data[1] = CFG_DPC_PKT_CHK;
+	data[2] = enable;
+	data[3] = 0;
+
+	aeon_ipc_cfg_param_direct(reg_num, data, phydev);
+}
+
+void aeon_auto_eee_cfg(unsigned short enable, unsigned int idle_th,
+		       struct phy_device *phydev)
+{
+	unsigned short data[8], reg_num = 5;
+
+	data[0] = CFG_AUTO_EEE;
+	data[1] = CFG_AUTO_EEE;
+	data[2] = enable;
+	data[3] = idle_th & 0xFFFF;
+	data[4] = (idle_th >> 16) & 0xFFFF;
+
+	aeon_ipc_cfg_param_direct(reg_num, data, phydev);
+}
+
+void aeon_sds_wait_eth_cfg(unsigned short sds_wait_eth_delay,
+			   struct phy_device *phydev)
+{
+	unsigned short data[8], reg_num = 5;
+
+	data[0] = CFG_DPC_SDS_WAIT_ETH;
+	data[1] = CFG_DPC_SDS_WAIT_ETH;
+	data[2] = sds_wait_eth_delay;
+	data[3] = 2;
+	data[4] = 1;
+
+	aeon_ipc_cfg_param_direct(reg_num, data, phydev);
+}
+
+void aeon_sds_restart_an(struct phy_device *phydev)
+{
+	unsigned short data[8], reg_num = 1;
+
+	data[0] = CFG_SDS_RESTART_AN;
+
+	aeon_ipc_cfg_param_direct(reg_num, data, phydev);
+}
+
+void aeon_ipc_set_tx_power_lvl(unsigned short gain, struct phy_device *phydev)
+{
+	unsigned short data[8], data_size;
+
+	data[0] = gain;
+	data_size = 1;
+
+	aeon_ipc_operation(phydev, IPC_DBGCMD_NGPHY, CFG_TM5_GAIN_IDX, data,
+			   data_size, IPC_DATA_UINT16, NULL, 0, IPC_DATA_UINT8);
+}
+
+void aeon_sds2nd_enable(unsigned short enable, struct phy_device *phydev)
+{
+	unsigned short data[8], reg_num = 3;
+	/* the order should match firmware cfg parameter sequence. */
+	data[0] = CFG_SDS2ND_EN;
+	data[1] = CFG_SDS2ND_EN;
+	data[2] = enable;
+
+	aeon_ipc_cfg_param_direct(reg_num, data, phydev);
+}
+
+void aeon_sds2nd_eq_cfg(unsigned short vga, unsigned short slc, unsigned short ctle,
+			unsigned short dfe, struct phy_device *phydev)
+{
+	unsigned short data[8], reg_num = 6;
+	/* the order should match firmware cfg parameter sequence. */
+	data[0] = CFG_SDS2ND_EQ;
+	data[1] = CFG_SDS2ND_EQ;
+	data[2] = vga;
+	data[3] = slc;
+	data[4] = ctle;
+	data[5] = dfe;
+
+	aeon_ipc_cfg_param_direct(reg_num, data, phydev);
+}
+
+void aeon_sds2nd_mode_cfg(unsigned short pcs_mode, unsigned short sds_spd, unsigned short op_mode,
+			  struct phy_device *phydev)
+{
+	unsigned short data[8], reg_num = 5;
+	/* the order should match firmware cfg parameter sequence. */
+	data[0] = CFG_SDS2ND_MODE;
+	data[1] = CFG_SDS2ND_MODE;
+	data[2] = pcs_mode;
+	data[3] = sds_spd;
+	data[4] = op_mode;
+
+	aeon_ipc_cfg_param_direct(reg_num, data, phydev);
+}
+
+void aeon_normal_retrain_cfg(unsigned short enable, struct phy_device *phydev)
+{
+	unsigned short data[8], data_size;
+
+	data[0] = enable;
+	data_size = 1;
+
+	aeon_ipc_operation(phydev, IPC_DBGCMD_NGPHY, CFG_NORMAL_RETRAIN_ABI, data,
+			   data_size, IPC_DATA_UINT16, NULL, 0, IPC_DATA_UINT8);
+}
+
+void aeon_ipc_auto_link_ena(unsigned char enable, struct phy_device *phydev)
+{
+	unsigned char data[8], data_size;
+
+	data[0] = enable;
+	data_size = 1;
+
+	aeon_ipc_operation(phydev, IPC_DBGCMD_AUTO_LINK, CFG_AUTO_LINK_ENA, data,
+			   data_size, IPC_DATA_UINT8, NULL, 0, IPC_DATA_UINT8);
+}
+
+void aeon_ipc_auto_link_cfg(unsigned char link_type, struct phy_device *phydev)
+{
+	unsigned char data[8], data_size;
+
+	data[0] = link_type;
+	data_size = 1;
+
+	aeon_ipc_operation(phydev, IPC_DBGCMD_AUTO_LINK, CFG_AUTO_LINK_CFG, data,
+			   data_size, IPC_DATA_UINT8, NULL, 0, IPC_DATA_UINT8);
+}
+
+void aeon_ipc_sds_txfir(unsigned char sds_id, unsigned char pre, unsigned char main,
+			unsigned char post, struct phy_device *phydev)
+{
+	unsigned char data[8], data_size;
+
+	data[0] = sds_id;
+	data[1] = pre;
+	data[2] = main;
+	data[3] = post;
+	data_size = 4;
+
+	aeon_ipc_operation(phydev, IPC_DBGCMD_SDS, CFG_SDS_TXFIR_SET, data,
+			   data_size, IPC_DATA_UINT8, NULL, 0, IPC_DATA_UINT8);
+}
+
+void aeon_sds_pcs_set_cfg(unsigned char pcs_sel, unsigned char sds_spd,
+			  unsigned char op_mode, struct phy_device *phydev)
+{
+	unsigned char data[8], data_size;
+
+	data[0] = pcs_sel;
+	data[1] = sds_spd;
+	data[2] = op_mode;
+	data_size = 3;
+
+	aeon_ipc_operation(phydev, IPC_DBGCMD_DPC, CFG_DPC_SET_CFG, data,
+			   data_size, IPC_DATA_UINT8, NULL, 0, IPC_DATA_UINT8);
+}
+
+void aeon_sds_pcs_get_cfg(unsigned char *pcs_sel, unsigned char *sds_spd,
+			  struct phy_device *phydev)
+{
+	unsigned char cfg[16] = {0};
+
+	aeon_ipc_operation(phydev, IPC_DBGCMD_DPC, CFG_DPC_GET_CFG, NULL,
+			   0, IPC_DATA_UINT8, cfg, 3, IPC_DATA_UINT8);
+
+	*pcs_sel = cfg[0];
+	*sds_spd = cfg[1];
+}
+
+void aeon_ra_mode_shift(unsigned char enable, struct phy_device *phydev)
+{
+	unsigned short data[8], data_size;
+
+	data[0] = enable;
+	data_size = 1;
+
+	aeon_ipc_operation(phydev, IPC_DBGCMD_DPC, IPC_CMD_RA_SET_CFG, data,
+			   data_size, IPC_DATA_UINT8, NULL, 0, IPC_DATA_UINT8);
+}
+
+void aeon_ra_mode_get(unsigned char *cfg, struct phy_device *phydev)
+{
+	aeon_ipc_operation(phydev, IPC_DBGCMD_DPC, IPC_CMD_RA_GET_CFG, NULL,
+			   0, IPC_DATA_UINT8, cfg, 1, IPC_DATA_UINT8);
+}
+
+void aeon_ipc_cnt_dump(unsigned int *revc_buf, struct phy_device *phydev)
+{
+	unsigned char iter = 0;
+
+	aeon_ipc_operation(phydev, IPC_DBGCMD_NGPHY, CFG_NGPHY_CNT_DUMP, NULL,
+			   0, IPC_DATA_UINT8, revc_buf,
+			   IPC_DATA_UINT32 * IPC_DUMP_NGPHY_NUM, IPC_DATA_UINT32);
+	iter = IPC_DUMP_NGPHY_NUM;
+	aeon_ipc_operation(phydev, IPC_DBGCMD_CU_AN, IPC_CMD_CU_AN_CNT_GET, NULL,
+			   0, IPC_DATA_UINT8, revc_buf + iter,
+			   IPC_DATA_UINT32 * IPC_DUMP_CU_AN_NUM, IPC_DATA_UINT32);
+	iter += IPC_DUMP_CU_AN_NUM;
+	aeon_ipc_operation(phydev, IPC_DBGCMD_DPC, CFG_DPC_CNT_DUMP, NULL,
+			   0, IPC_DATA_UINT8, revc_buf + iter,
+			   IPC_DATA_UINT32 * IPC_DUMP_DPC_NUM, IPC_DATA_UINT32);
+}
+void aeon_ipc_cnt_clr(struct phy_device *phydev)
+{
+	aeon_ipc_operation(phydev, IPC_DBGCMD_CU_AN, IPC_CMD_CU_AN_CNT_CLR, NULL,
+			   0, IPC_DATA_UINT8, NULL, 0, IPC_DATA_UINT8);
+	aeon_ipc_operation(phydev, IPC_DBGCMD_NGPHY, CFG_NGPHY_CNT_CLR, NULL,
+			   0, IPC_DATA_UINT8, NULL, 0, IPC_DATA_UINT8);
+	aeon_ipc_operation(phydev, IPC_DBGCMD_DPC, CFG_DPC_CNT_CLR, NULL,
+			   0, IPC_DATA_UINT8, NULL, 0, IPC_DATA_UINT8);
+}
+
+void aeon_ipc_enable_sds_loopback(struct phy_device *phydev)
+{
+	unsigned short value = 0;
+
+	value = aeon_cl45_read(phydev, 0x1e, 0x2);
+	value |= BIT(15);
+	aeon_cl45_write(phydev, 0x1e, 0x2, value);
+
+	value = aeon_cl45_read(phydev, 1, 0x808a);
+	value &= ~BIT(0);
+	value |= (BIT(1) | BIT(10) | BIT(11));
+	value &= ~BIT(12);
+	aeon_cl45_write(phydev, 1, 0x808a, value);
+
+	msleep(1000);
+
+	value = aeon_cl45_read(phydev, 3, 0x8829);
+	value |= BIT(7);
+	aeon_cl45_write(phydev, 3, 0x8829, value);
+
+	msleep(1000);
+
+	value = aeon_cl45_read(phydev, 3, 0x8829);
+	value |= BIT(1);
+	aeon_cl45_write(phydev, 3, 0x8829, value);
+
+	msleep(1000);
+}
+
+void aeon_sds_restart(unsigned char sds_id, struct phy_device *phydev)
+{
+	unsigned short data[8], data_size;
+
+	data[0] = sds_id;
+	data_size = 1;
+	aeon_ipc_operation(phydev, IPC_DBGCMD_SDS, CFG_SDS_RST, data,
+			   data_size, IPC_DATA_UINT8, NULL, 0, IPC_DATA_UINT8);
+}
+#else
+void aeon_sds_pcs_set_cfg(unsigned char pcs_sel, unsigned char sds_spd,
+			  unsigned char op_mode, struct phy_device *phydev)
+{
+	unsigned char data[8], data_size;
+
+	data[0] = pcs_sel;
+	data[1] = sds_spd;
+	data_size = 2;
+
+	aeon_ipc_operation(phydev, IPC_DBGCMD_DPC, CFG_DPC_SDS_SET_CFG, data,
+			   data_size, IPC_DATA_UINT8, NULL, 0, IPC_DATA_UINT8);
+}
+
+void aeon_sds_pcs_get_cfg(unsigned char *pcs_sel, unsigned char *sds_spd,
+			  struct phy_device *phydev)
+{
+	unsigned char cfg[16] = {0};
+
+	aeon_ipc_operation(phydev, IPC_DBGCMD_DPC, CFG_DPC_SDS_GET_CFG, NULL,
+			   0, IPC_DATA_UINT8, cfg, 2, IPC_DATA_UINT8);
+
+	*pcs_sel = cfg[0];
+	*sds_spd = cfg[1];
+}
+
+void aeon_dpc_fc_cfg(unsigned char enable, struct phy_device *phydev)
+{
+	unsigned char data[8] = {0};
+
+	data[0] = enable;
+	aeon_ipc_operation(phydev, IPC_DBGCMD_DPC, CFG_SUPPORT_FC_SET, data,
+			   1, IPC_DATA_UINT8, NULL, 0, IPC_DATA_UINT8);
+}
+
+void aeon_dpc_fc_cfg_get(unsigned char *enable, struct phy_device *phydev)
+{
+	aeon_ipc_operation(phydev, IPC_DBGCMD_DPC, CFG_SUPPORT_FC_GET, NULL,
+			   0, IPC_DATA_UINT8, enable, 1, IPC_DATA_UINT8);
+}
+
+void aeon_dpc_eee_mode(unsigned char eee_mode, struct phy_device *phydev)
+{
+	unsigned char data[8] = {0};
+
+	data[0] = eee_mode;
+	aeon_ipc_operation(phydev, IPC_DBGCMD_DPC, CFG_DPC_EEE_SET_CFG, data,
+			   1, IPC_DATA_UINT8, NULL, 0, IPC_DATA_UINT8);
+}
+
+void aeon_dpc_eee_mode_get(unsigned char *eee_mode, struct phy_device *phydev)
+{
+	aeon_ipc_operation(phydev, IPC_DBGCMD_DPC, CFG_DPC_EEE_GET_CFG, NULL,
+			   0, IPC_DATA_UINT8, eee_mode, 1, IPC_DATA_UINT8);
+}
+
+void aeon_dpc_buffer_mode(unsigned char buffer_mode, struct phy_device *phydev)
+{
+	unsigned char data[8] = {0};
+
+	data[0] = buffer_mode;
+	aeon_ipc_operation(phydev, IPC_DBGCMD_DPC, CFG_DPC_BUFFER_SET_CFG, data,
+			   1, IPC_DATA_UINT8, NULL, 0, IPC_DATA_UINT8);
+}
+
+void aeon_dpc_buffer_mode_get(unsigned char *buffer_mode, struct phy_device *phydev)
+{
+	aeon_ipc_operation(phydev, IPC_DBGCMD_DPC, CFG_DPC_BUFFER_GET_CFG, NULL,
+			   0, IPC_DATA_UINT8, buffer_mode, 1, IPC_DATA_UINT8);
+}
+
+void aeon_dpc_eee_clk_mode(unsigned char clk_mode, struct phy_device *phydev)
+{
+	unsigned char data[8] = {0};
+
+	data[0] = clk_mode;
+	aeon_ipc_operation(phydev, IPC_DBGCMD_DPC, CFG_EEE_CLK_STOP_CAP, data,
+			   1, IPC_DATA_UINT8, NULL, 0, IPC_DATA_UINT8);
+}
+
+void aeon_dpc_eq_cfg(unsigned char vga, unsigned char slc, unsigned char ctle,
+		     unsigned char dfe, unsigned char ffe, struct phy_device *phydev)
+{
+	unsigned char data[8] = {0};
+
+	data[0] = vga;
+	data[1] = slc;
+	data[2] = ctle;
+	data[3] = dfe;
+	data[4] = ffe;
+	aeon_ipc_operation(phydev, IPC_DBGCMD_SDS, CFG_PHY_SET_SDS_EQ, data,
+			   5, IPC_DATA_UINT8, NULL, 0, IPC_DATA_UINT8);
+}
+
+void aeon_dpc_eq_cfg_get(unsigned char *eq_cfg, struct phy_device *phydev)
+{
+	unsigned char cfg[16] = {0};
+
+	aeon_ipc_operation(phydev, IPC_DBGCMD_SDS, CFG_PHY_GET_SDS_EQ, NULL,
+			   0, IPC_DATA_UINT8, cfg, 5, IPC_DATA_UINT8);
+
+	eq_cfg[0] = cfg[0];
+	eq_cfg[1] = cfg[1];
+	eq_cfg[2] = cfg[2];
+	eq_cfg[3] = cfg[3];
+	eq_cfg[4] = cfg[4];
+}
+
+void aeon_pkt_fifo_full_th(unsigned short enable, unsigned short rx_th, unsigned short tx_th,
+			   struct phy_device *phydev)
+{
+	unsigned short data[8] = {0};
+
+	data[0] = enable;
+	data[1] = rx_th;
+	data[2] = tx_th;
+
+	aeon_ipc_operation(phydev, IPC_DBGCMD_DPC, CFG_PKT_FIFO_FULL_TH, data,
+			   3, IPC_DATA_UINT16, NULL, 0, IPC_DATA_UINT8);
+}
+
+void aeon_pkt_fifo_full_th_get(unsigned short *rx_th, unsigned short *tx_th,
+			       struct phy_device *phydev)
+{
+	unsigned short cfg[8] = {0};
+
+	aeon_ipc_operation(phydev, IPC_DBGCMD_DPC, CFG_PKT_FIFO_FULL_TH_GET, NULL,
+			   0, IPC_DATA_UINT8, cfg, 16, IPC_DATA_UINT16);
+
+	*rx_th = cfg[0];
+	*tx_th = cfg[1];
+}
+
+void aeon_ipc_cnt_dump(unsigned int *revc_buf, struct phy_device *phydev)
+{
+	aeon_ipc_operation(phydev, IPC_DBGCMD_DPC, CFG_DP_PKT_DUMP, NULL,
+			   0, IPC_DATA_UINT8, revc_buf,
+			   IPC_DATA_UINT32 * IPC_DP_DUMP_NUM, IPC_DATA_UINT32);
+}
+
+void aeon_ipc_cnt_clr(struct phy_device *phydev)
+{
+	aeon_ipc_operation(phydev, IPC_DBGCMD_DPC, CFG_DP_PKT_CLR, NULL,
+			   0, IPC_DATA_UINT8, NULL, 0, IPC_DATA_UINT8);
+}
+
+void aeon_ipc_testmode5_gain_idx(unsigned char gain_idx, struct phy_device *phydev)
+{
+	unsigned char data[8] = {0};
+
+	data[0] = gain_idx;
+
+	aeon_ipc_operation(phydev, IPC_DBGCMD_NGPHY, CFG_TM5_GAIN_IDX, data,
+			   1, IPC_DATA_UINT8, NULL, 0, IPC_DATA_UINT8);
+}
+#endif
+
+#ifdef DUAL_FLASH
+int aeon_ipc_sys_cpu_info(unsigned short sub_cmd, unsigned int flash_addr,
+			  unsigned int mem_addr, struct phy_device *phydev)
+{
+	unsigned short status, ret_size;
+	unsigned short cfg[5] = { 0 };
+	int val = 0;
+	struct device *dev = phydev_dev(phydev);
+
+	cfg[0] = sub_cmd;
+	if (sub_cmd == IPC_CMD_SYS_CPU_IMAGE_CHECK) {
+		cfg[1] = flash_addr & 0xFFFF;
+		cfg[2] = (flash_addr >> 16) & 0xFFFF;
+		cfg[3] = mem_addr & 0xFFFF;
+		cfg[4] = (mem_addr >> 16) & 0xFFFF;
+	}
+
+	aeon_send_ipc_msg(phydev, 5, cfg, IPC_CMD_SYS_CPU, 10);
+
+	status = aeon_ipc_wait_cmd_done(phydev, NULL, &ret_size);
+	if (status != IPC_STS_CMD_SUCCESS) {
+		dev_err(dev, "spu info command failed %x\n", status);
+		return 1;
+	}
+	if (sub_cmd == IPC_CMD_SYS_CPU_IMAGE_CHECK) {
+		aeon_receive_ipc_data(phydev, 1, cfg);
+		val = cfg[0];
+	} else if (sub_cmd == IPC_CMD_SYS_IMAGE_OFST) {
+		aeon_receive_ipc_data(phydev, 2, cfg);
+		val = cfg[0] + (cfg[1] << 16);
+	}
+	return val;
+}
+
+void aeon_ipc_set_fsm_mode(unsigned short fsm, unsigned short mode,
+			   struct phy_device *phydev)
+{
+	unsigned short data[8], reg_num = 4;
+
+	data[0] = CFG_NG_PHYCTRL;
+	data[1] = IPC_CMD_CFG_PHYCTRL_PAUSED;
+	data[2] = fsm;
+	data[3] = mode;
+
+	aeon_ipc_cfg_param_direct(reg_num, data, phydev);
+}
+
+void aeon_ipc_write_flash(unsigned int flash_addr, unsigned int mem_addr,
+			  unsigned short size, struct phy_device *phydev)
+{
+	unsigned short status, ret_size;
+	unsigned short cfg[5] = { 0 };
+	struct device *dev = phydev_dev(phydev);
+
+	cfg[0] = flash_addr & 0xFFFF;
+	cfg[1] = flash_addr >> 16;
+	cfg[2] = mem_addr & 0xFFFF;
+	cfg[3] = mem_addr >> 16;
+	cfg[4] = size;
+
+	aeon_send_ipc_msg(phydev, 5, cfg, IPC_CMD_FLASH_WRITE, 10);
+
+	status = aeon_ipc_wait_cmd_done(phydev, NULL, &ret_size);
+	if (status != IPC_STS_CMD_SUCCESS) {
+		dev_err(dev, "write flash command failed %x\n", status);
+		return;
+	}
+}
+
+void aeon_ipc_erase_flash(unsigned int flash_addr, unsigned int size,
+			  unsigned short mode, struct phy_device *phydev)
+{
+	unsigned short status, ret_size;
+	unsigned long ts = 6000000000;
+	unsigned long *_to = &ts;
+	unsigned short cfg[5] = { 0 };
+	struct device *dev = phydev_dev(phydev);
+
+	if ((flash_addr + size) >= FLASH_CHIP_SIZE)
+		size = FLASH_CHIP_SIZE - flash_addr - 1;
+
+	cfg[0] = flash_addr & 0xFFFF;
+	cfg[1] = flash_addr >> 16;
+	cfg[2] = size & 0xFFFF;
+	cfg[3] = size >> 16;
+	cfg[4] = mode;
+
+	aeon_send_ipc_msg(phydev, 5, cfg, IPC_CMD_FLASH_ERASE, 10);
+	status = aeon_ipc_wait_cmd_done(phydev, _to, &ret_size);
+	if (status != IPC_STS_CMD_SUCCESS) {
+		dev_err(dev, "erase flash command failed %x\n", status);
+		return;
+	}
+}
+
+void aeon_update_flash(const char *firmware, unsigned int flash_start,
+		       struct phy_device *phydev)
+{
+	int sector_ofst, total, ret, data_ofst;
+	unsigned char buf[FLASH_SECTOR_SIZE] = { 0 };
+	unsigned short *wdata = (unsigned short *)buf;
+	unsigned int temp_mem_addr = 0x33e000, flash_addr, image_size;
+	unsigned short crc, dlen;
+	const struct firmware *fw;
+	struct device *dev = phydev_dev(phydev);
+
+	aeon_ipc_set_fsm_mode(CFG_FSM_NGPHY, 0, phydev);
+	aeon_ipc_set_fsm_mode(CFG_FSM_GPHY, 0, phydev);
+	aeon_ipc_set_fsm_mode(CFG_FSM_CU_AN, 0, phydev);
+	aeon_ipc_set_fsm_mode(CFG_FSM_DPC, 0, phydev);
+	aeon_ipc_set_fsm_mode(CFG_FSM_SS, 0, phydev);
+
+	ret = request_firmware_direct(&fw, firmware, dev);
+	if (ret < 0) {
+		dev_err(dev, "failed to load flash bin %s, ret: %d\n", firmware,
+			ret);
+		return;
+	}
+	crc = ~crc32(~0, fw->data, fw->size);
+	dev_info(dev, "%s: crc32=0x%x\n", firmware, crc);
+	/* pad length so that fsm won't stuck at read back */
+	image_size = (fw->size + 3) & 0xFFFFFFFC;
+
+	/* erase first */
+	sector_ofst = 0;
+	aeon_ipc_erase_flash(flash_start, image_size, ERASE_MODE_BLOCK, phydev);
+
+	while ((sector_ofst << 12) < image_size) {
+		flash_addr = flash_start + FLASH_SECTOR_SIZE * sector_ofst;
+		dlen = 0;
+		total = (image_size - (sector_ofst << 12)) >> 1;
+		data_ofst = sector_ofst * FLASH_SECTOR_SIZE;
+		memcpy(buf, fw->data + data_ofst, FLASH_SECTOR_SIZE);
+
+		if (total > (FLASH_SECTOR_SIZE >> 1))
+			total = (FLASH_SECTOR_SIZE >> 1);
+
+		dev_info(dev, "sector_ofst : %u", sector_ofst);
+		dev_info(dev, "  data_ofst : 0x%x\n", data_ofst);
+		dev_info(dev, "flash_addr : 0x%x\n", flash_addr);
+
+		dev_info(dev, "Origin params : %u  %u  %u  %u  %u  %u  %u  %u\n",
+			 *(wdata), *(wdata + 1), *(wdata + 2), *(wdata + 3),
+			 *(wdata + 4), *(wdata + 5), *(wdata + 6), *(wdata + 7));
+
+		aeon_ipc_send_bulk_write(temp_mem_addr, FLASH_SECTOR_SIZE,
+					 phydev);
+		/* upload to system memory */
+		while (dlen < total) {
+			if ((total - dlen) > 8) {
+				aeon_ipc_send_bulk_data(BW16, 8, wdata + dlen,
+							phydev);
+				dlen += 8;
+			} else if ((total - dlen) > 0) {
+				aeon_ipc_send_bulk_data(BW16, total - dlen,
+							wdata + dlen, phydev);
+				dlen = total;
+			}
+		}
+		sector_ofst++;
+
+		/* write to flash */
+		aeon_ipc_write_flash(flash_addr, temp_mem_addr,
+				     FLASH_SECTOR_SIZE, phydev);
+	}
+	release_firmware(fw);
+}
+
+void aeon_burn_image(unsigned char include_bootloader,
+		     struct phy_device *phydev)
+{
+	unsigned int new_addr = 0, old_addr = 0;
+	struct device *dev = phydev_dev(phydev);
+	int ofst;
+	/* Disable WDT */
+	aeon_ipc_set_wdt(0, phydev);
+	if (include_bootloader == 0) {
+		ofst = aeon_ipc_sys_cpu_info(IPC_CMD_SYS_IMAGE_OFST, new_addr,
+					     old_addr, phydev);
+		if ((ofst == 0) || (ofst == IMAGE2_OFST)) {
+			new_addr = IMAGE1_HDR_OFST;
+			old_addr = IMAGE2_HDR_OFST;
+		} else if (ofst == IMAGE1_OFST) {
+			new_addr = IMAGE2_HDR_OFST;
+			old_addr = IMAGE1_HDR_OFST;
+		}
+		dev_info(dev, "new_addr: %u, old_addr : %u\n", new_addr, old_addr);
+		aeon_update_flash(FLASH_BIN, new_addr, phydev);
+		ofst = aeon_ipc_sys_cpu_info(IPC_CMD_SYS_CPU_IMAGE_CHECK,
+					     new_addr, 0x33d000, phydev);
+		if (ofst) {
+			aeon_update_flash(CLR_FLASH_IMAGE, old_addr, phydev);
+		} else {
+			dev_err(dev, "check image failed\n");
+			return;
+		}
+	} else {
+		aeon_update_flash(BOOT_LOADER_BIN, new_addr, phydev);
+	}
+	/* Enable WDT */
+	aeon_ipc_set_wdt(1, phydev);
+}
+#endif
+
+void aeon_ipc_sync_parity(struct phy_device *phydev)
+{
+	unsigned long noop_to = 20;
+	struct timespec64 t1, t2;
+	unsigned long _to = IPC_TIMEOUT, _ns = 0;
+	unsigned short cmd, par = 0;
+	unsigned short sts, status, opcode, size, ret_par;
+	struct device *dev = phydev_dev(phydev);
+
+	/* Send first noop, no need to wait reply */
+	aeon_ipc_build_cmd(&cmd, IPC_CMD_NOOP, 0);
+	aeon_send_ipc_cmd(phydev, cmd);
+	mdelay(noop_to);
+
+	/* Send second noop, expect the correct parity to return */
+	aeon_ipc_build_cmd(&cmd, IPC_CMD_NOOP, 0);
+	aeon_send_ipc_cmd(phydev, cmd);
+	par = 0;
+	ktime_get_real_ts64(&t1);
+	while (par == 0) {
+		mdelay(10);
+		sts = aeon_get_ipc_status(phydev);
+		aeon_ipc_parse_sts(sts, &status, &opcode, &size, &ret_par);
+		par = (get_par() != ret_par);
+
+		/* Check timeout */
+		ktime_get_real_ts64(&t2);
+		_ns = (t2.tv_sec - t1.tv_sec) * 1000000000 + t2.tv_nsec -
+		       t1.tv_nsec;
+		if (_ns > _to)
+			break;
+	}
+
+	if (par == 0) {
+		dev_err(dev, "IPC sync failure: NOOP 3, sts: %x\n",
+			aeon_get_ipc_status(phydev));
+	}
+}
+
+void aeon_ipc_get_fw_version(char *version, struct phy_device *phydev)
+{
+	unsigned short status, ret_size;
+	unsigned short data = IPC_CMD_INFO_VERSION;
+	struct device *dev = phydev_dev(phydev);
+
+	aeon_send_ipc_msg(phydev, 1, &data, IPC_CMD_INFO, 2);
+
+	status = aeon_ipc_wait_cmd_done(phydev, NULL, &ret_size);
+	if (status != IPC_STS_CMD_SUCCESS) {
+		dev_err(dev, "get FW version command failed %x\n", status);
+		return;
+	}
+	aeon_receive_ipc_data(phydev, 8, (unsigned short *)version);
+}
+
+void aeon_cu_an_set_top_spd(unsigned short top_spd, struct phy_device *phydev)
+{
+	unsigned short data[8], reg_num = 3;
+
+	data[0] = CFG_CU_AN;
+	data[1] = IPC_CMD_CU_AN_TOP_SPD;
+	data[2] = top_spd;
+
+	aeon_ipc_cfg_param_direct(reg_num, data, phydev);
+}
+
+void aeon_cu_an_restart(struct phy_device *phydev)
+{
+	unsigned short data[8], reg_num = 2;
+
+	data[0] = CFG_CU_AN;
+	data[1] = MDI_CFG_CU_AN_RESTART;
+
+	aeon_ipc_cfg_param_direct(reg_num, data, phydev);
+}
+
+void aeon_cu_an_set_eee_spd(unsigned short speed_mode,
+			    struct phy_device *phydev)
+{
+	unsigned short data[8], reg_num = 3;
+
+	data[0] = CFG_CU_AN;
+	data[1] = MDI_CFG_CU_AN_EEE_SPD;
+	data[2] = speed_mode;
+
+	aeon_ipc_cfg_param_direct(reg_num, data, phydev);
+}
+
+void aeon_cu_an_set_trd_swap(unsigned short en, unsigned short trd_swap,
+			     struct phy_device *phydev)
+{
+	unsigned short data[8], reg_num = 4;
+
+	data[0] = CFG_CU_AN;
+	data[1] = IPC_CMD_CU_AN_TRD_SWAP;
+	data[2] = en;
+	data[3] = trd_swap;
+
+	aeon_ipc_cfg_param_direct(reg_num, data, phydev);
+}
+
+void aeon_cu_an_set_ms_cfg(unsigned short port_type, unsigned short ms_man_en,
+			   unsigned short ms_man_val, struct phy_device *phydev)
+{
+	unsigned short data[8], reg_num = 5;
+
+	data[0] = CFG_CU_AN;
+	data[1] = IPC_CMD_CU_AN_MS_CFG;
+	data[2] = port_type;
+	data[3] = ms_man_en;
+	data[4] = ms_man_val;
+
+	aeon_ipc_cfg_param_direct(reg_num, data, phydev);
+}
+
+void aeon_cu_an_get_ms_cfg(unsigned short *ms_related_cfg,
+			struct phy_device *phydev)
+{
+	unsigned short data[8], reg_num = 2;
+
+	data[0] = CFG_CU_AN;
+	data[1] = IPC_CMD_CU_AN_GET_MS_CFG;
+
+	aeon_ipc_cfg_param_direct(reg_num, data, phydev);
+	aeon_receive_ipc_data(phydev, 3, (unsigned short *)ms_related_cfg);
+}
+
+void aeon_cu_an_set_cfr(unsigned short cfr, struct phy_device *phydev)
+{
+	unsigned short data[8], reg_num = 3;
+
+	data[0] = CFG_CU_AN;
+	data[1] = IPC_CMD_CU_AN_CFR;
+	data[2] = cfr;
+
+	aeon_ipc_cfg_param_direct(reg_num, data, phydev);
+}
+
+void aeon_cu_an_set_fast_retrain(unsigned short speed_mode,
+				 unsigned short thp_bypass,
+				 struct phy_device *phydev)
+{
+	unsigned short data[8], reg_num = 4;
+
+	data[0] = CFG_CU_AN;
+	data[1] = MDI_CFG_CU_AN_FR_SPD;
+	data[2] = speed_mode >> 4;
+	data[3] = thp_bypass;
+
+	aeon_ipc_cfg_param_direct(reg_num, data, phydev);
+}
+
+void aeon_cu_an_enable_downshift(unsigned short enable,
+				 unsigned short retry_limit,
+				 struct phy_device *phydev)
+{
+	unsigned short data[8], reg_num = 4;
+
+	data[0] = CFG_CU_AN;
+	data[1] = MDI_CFG_CU_AN_DS;
+	data[2] = enable;
+	data[3] = retry_limit;
+
+	aeon_ipc_cfg_param_direct(reg_num, data, phydev);
+}
+
+void aeon_sds_pma_set_cfg(unsigned short vga_adapt, unsigned short slc_adapt,
+			  unsigned short ctle_adapt, unsigned short dfe_adapt,
+			  struct phy_device *phydev)
+{
+	unsigned short data[8], reg_num = 6;
+	/* the order should match firmware cfg parameter sequence. */
+	data[0] = CFG_SDS_PMA;
+	data[1] = CFG_SDS_PMA;
+	data[2] = vga_adapt;
+	data[3] = slc_adapt;
+	data[4] = ctle_adapt;
+	data[5] = dfe_adapt;
+
+	aeon_ipc_cfg_param_direct(reg_num, data, phydev);
+}
+
+void aeon_cu_an_enable_aeon_oui(unsigned short nstd_pbo,
+				struct phy_device *phydev)
+{
+	unsigned short data[8], reg_num = 3;
+
+	data[0] = CFG_CU_AN;
+	data[1] = MDI_CFG_CU_AN_AEON_OUI;
+	data[2] = nstd_pbo;
+
+	aeon_ipc_cfg_param_direct(reg_num, data, phydev);
+}
+
+void aeon_ipc_eye_scan(unsigned char sds_id, unsigned char grp,
+		       unsigned short *revc_buf, struct phy_device *phydev)
+{
+	unsigned char data[8], data_size;
+
+	data[0] = sds_id;
+	data[1] = grp;
+	data_size = 2;
+
+	aeon_ipc_operation(phydev, IPC_DBGCMD_SDS, CFG_SDS_EYE_SCAN, data,
+		data_size, IPC_DATA_UINT8, revc_buf, EYE_STRIDE * 2, IPC_DATA_UINT16);
+}
+
+void aeon_ipc_log_size(unsigned short *msg_size, struct phy_device *phydev)
+{
+	unsigned short data[8], reg_num = 1;
+	unsigned short ret_size, status;
+
+	data[0] = CFG_LOG_SIZE;
+
+	aeon_send_ipc_msg(phydev, reg_num, data, IPC_CMD_LOG, reg_num * 2);
+	status = aeon_ipc_wait_cmd_done(phydev, NULL, &ret_size);
+	if (status != IPC_STS_CMD_SUCCESS) {
+		pr_info("get log size command failed %x\n", status);
+		return;
+	}
+
+	aeon_receive_ipc_data(phydev, 1, msg_size);
+}
+
+unsigned int aeon_ipc_read_log(unsigned short size, unsigned short pos, char *buf,
+			       struct phy_device *phydev)
+{
+	unsigned short data[8], reg_num = 2;
+	unsigned short ret_size, status;
+
+	data[0] = CFG_LOG_READ;
+	data[1] = size;
+
+	aeon_send_ipc_msg(phydev, reg_num, data, IPC_CMD_LOG, reg_num * 2);
+	status = aeon_ipc_wait_cmd_done(phydev, NULL, &ret_size);
+	if (status != IPC_STS_CMD_SUCCESS) {
+		pr_info("get log size command failed %x\n", status);
+		return -EFAULT;
+	}
+
+	aeon_receive_ipc_data(phydev, size, (unsigned short *)(buf + pos));
+
+	return 0;
+}
+
+void aeon_ipc_log_clean(struct phy_device *phydev)
+{
+	unsigned short data[8], reg_num = 1;
+	unsigned short ret_size, status;
+
+	data[0] = CFG_LOG_CLEAN;
+	aeon_send_ipc_msg(phydev, reg_num, data, IPC_CMD_LOG, reg_num * 2);
+	status = aeon_ipc_wait_cmd_done(phydev, NULL, &ret_size);
+	if (status != IPC_STS_CMD_SUCCESS)
+		pr_info("get log size command failed %x\n", status);
+}
+
+void aeon_ipc_temp_monitor(unsigned short sub_cmd, unsigned short params,
+			   unsigned short *temperature,
+			   struct phy_device *phydev)
+{
+	unsigned short data[8], reg_num = 3;
+
+	data[0] = CFG_TEMP_MON;
+	data[1] = sub_cmd;
+	data[2] = params;
+
+	aeon_ipc_cfg_param_direct(reg_num, data, phydev);
+	if (sub_cmd == 0x4)
+		aeon_receive_ipc_data(phydev, 3, (unsigned short *)temperature);
+}
+
+void aeon_ipc_set_led_cfg(unsigned short led0, unsigned short led1,
+			  unsigned short led2, unsigned short led3,
+			  unsigned short led4, unsigned short polarity,
+			  unsigned short blink, struct phy_device *phydev)
+{
+	unsigned short status, ret_size;
+	unsigned short cfg[7] = {
+		led0, led1, led2, led3, led4, polarity, blink
+	};
+	struct device *dev = phydev_dev(phydev);
+
+	aeon_send_ipc_msg(phydev, 7, cfg, IPC_CMD_SET_LED, 14);
+
+	status = aeon_ipc_wait_cmd_done(phydev, NULL, &ret_size);
+	if (status != IPC_STS_CMD_SUCCESS)
+		dev_err(dev, "set led command failed %x\n", status);
+}
+
+int aeon_read_status(struct phy_device *phydev)
+{
+	int ret = 0, reg = 0;
+	char hcd_status = 0;
+	struct device *dev = phydev_dev(phydev);
+
+	phydev->speed = SPEED_UNKNOWN;
+	phydev->duplex = DUPLEX_UNKNOWN;
+	phydev->pause = 1;
+	phydev->asym_pause = 1;
+
+	reg = aeon_mdio_read_reg(phydev, AN_REG_GIGA_STD_STATUS_BASEADDR);
+	if (reg < 0) {
+		dev_err(dev, "MII_BMSR reg %d!\n", reg);
+		return reg;
+	}
+	if (reg & BMSR_LSTATUS) {
+		phydev->link = 1;
+		hcd_status = aeon_mdio_read_reg_field(phydev, 0xF0010, 0x804);
+		switch (hcd_status) {
+		case 0xE:
+			phydev->speed = SPEED_10000;
+			phydev->duplex = DUPLEX_FULL;
+			break;
+		case 0xD:
+			phydev->speed = SPEED_5000;
+			phydev->duplex = DUPLEX_FULL;
+			break;
+		case 0xC:
+			phydev->speed = SPEED_2500;
+			phydev->duplex = DUPLEX_FULL;
+			break;
+		case 0xB:
+			phydev->speed = SPEED_1000;
+			phydev->duplex = DUPLEX_FULL;
+			break;
+		case 0xA:
+			phydev->speed = SPEED_100;
+			phydev->duplex = DUPLEX_FULL;
+			break;
+		case 0x3:
+			phydev->speed = SPEED_1000;
+			phydev->duplex = DUPLEX_HALF;
+			break;
+		case 0x2:
+			phydev->speed = SPEED_100;
+			phydev->duplex = DUPLEX_HALF;
+			break;
+		default:
+			break;
+		}
+	}
+
+	return ret;
+}
+
+void aeon_ipc_set_sys_reboot(struct phy_device *phydev)
+{
+	unsigned short data = IPC_CMD_SYS_REBOOT;
+
+	aeon_send_ipc_msg(phydev, 1, &data, IPC_CMD_SYS_CPU, 2);
+}
+
+void aeon_ipc_phy_enable_mode(unsigned short enable, struct phy_device *phydev)
+{
+	unsigned short status, ret_size;
+	unsigned short cfg[2] = { IPC_CMD_SYS_CPU_PHY_ENABLE, enable };
+	struct device *dev = phydev_dev(phydev);
+
+	aeon_send_ipc_msg(phydev, 2, cfg, IPC_CMD_SYS_CPU, 4);
+
+	status = aeon_ipc_wait_cmd_done(phydev, NULL, &ret_size);
+	if (status != IPC_STS_CMD_SUCCESS) {
+		dev_err(dev, "IPC set phy return status: %x\n", status);
+		return;
+	}
+}
+
+void aeon_ipc_ng_test_mode(unsigned short test_mode, unsigned short tone,
+			   struct phy_device *phydev)
+{
+	unsigned short data[8], reg_num = 4;
+
+	data[0] = CFG_NG_PHYCTRL;
+	data[1] = IPC_CMD_CFG_NG_TESTMODE;
+	data[2] = test_mode;
+	data[3] = tone;
+
+	aeon_ipc_cfg_param_direct(reg_num, data, phydev);
+}
+
+void aeon_cu_an_enable(unsigned char enable, struct phy_device *phydev)
+{
+	unsigned char data[8], data_size;
+
+	data[0] = enable;
+	data_size = 1;
+
+	aeon_ipc_operation(phydev, IPC_DBGCMD_CU_AN, IPC_CMD_CU_AN_ENABLE, data,
+			   data_size, IPC_DATA_UINT8, NULL, 0, 1);
+}
+
+void aeon_set_man_mdi(struct phy_device *phydev)
+{
+	unsigned short data[8], reg_num = 4;
+
+	data[0] = CFG_CU_AN;
+	data[1] = MDI_CFG_MAN_MDI;
+	data[2] = 1;
+	data[3] = MDI;
+
+	aeon_ipc_cfg_param_direct(reg_num, data, phydev);
+}
+
+void aeon_set_man_mdix(struct phy_device *phydev)
+{
+	unsigned short data[8], reg_num = 4;
+
+	data[0] = CFG_CU_AN;
+	data[1] = MDI_CFG_MAN_MDI;
+	data[2] = 1;
+	data[3] = MDIX;
+
+	aeon_ipc_cfg_param_direct(reg_num, data, phydev);
+}
+
+void aeon_set_man_duplex(unsigned short duplex, struct phy_device *phydev)
+{
+	unsigned short data[8], reg_num = 4;
+
+	data[0] = CFG_CU_AN;
+	data[1] = MDI_CFG_CU_AN_DUPLEX;
+	data[2] = 1;
+	data[3] = duplex;
+
+	aeon_ipc_cfg_param_direct(reg_num, data, phydev);
+}
+
+void aeon_ng_test_mode(unsigned short top_spd, unsigned short test_mode,
+		       unsigned short tone, struct phy_device *phydev)
+{
+	unsigned short ms = 1;
+
+	aeon_ipc_ng_test_mode(0, 0, phydev);
+	/* switch speed */
+	aeon_cu_an_set_top_spd(top_spd, phydev);
+	/* enable AN */
+	aeon_cu_an_enable(1, phydev);
+	/* restart AN */
+	aeon_cu_an_restart(phydev);
+	mdelay(500);
+	if (test_mode == 3)
+		ms = 0;
+	aeon_cu_an_set_ms_cfg(0, 1, ms, phydev);
+	aeon_set_man_mdi(phydev);
+	aeon_ipc_ng_test_mode(test_mode, tone, phydev);
+	mdelay(10);
+	/* disable AN */
+	aeon_cu_an_enable(0, phydev);
+	mdelay(10);
+	aeon_mdio_write_reg_field(phydev, 0xF014E, 0x4, 0);
+	aeon_mdio_write_reg_field(phydev, 0xF014C, 0xC01, 1);
+	mdelay(10);
+	aeon_mdio_write_reg_field(phydev, 0xF014C, 0xC01, 0);
+}
+
+void aeon_1g_test_mode(unsigned short test_mode, struct phy_device *phydev)
+{
+	unsigned short ms = 1;
+	/* enable AN */
+	aeon_cu_an_enable(1, phydev);
+	aeon_mdio_write_reg_field(phydev, 0xFFFD2, 0xD03, 0);
+	/* restart AN */
+	aeon_cu_an_restart(phydev);
+	mdelay(500);
+	if (test_mode == 3)
+		ms = 0;
+	aeon_cu_an_set_ms_cfg(0, 1, ms, phydev);
+	aeon_set_man_mdi(phydev);
+	/* switch speed */
+	aeon_cu_an_set_top_spd(MDI_CFG_SPD_T1G, phydev);
+	aeon_mdio_write_reg_field(phydev, 0xFFFD2, 0xD03, test_mode);
+	/* disable AN */
+	aeon_cu_an_enable(0, phydev);
+}
+
+void aeon_100m_test_mode(struct phy_device *phydev)
+{
+	/* enable AN */
+	aeon_cu_an_enable(1, phydev);
+	aeon_cu_an_set_ms_cfg(0, 1, 0, phydev);
+	aeon_set_man_mdi(phydev);
+	/* set half duplex */
+	aeon_set_man_duplex(0, phydev);
+	/* switch speed */
+	aeon_cu_an_set_top_spd(MDI_CFG_SPD_T100, phydev);
+	/* disable AN */
+	aeon_cu_an_enable(0, phydev);
+}
+
+void aeon_ipc_set_wol(unsigned short en, unsigned short *val,
+		      struct phy_device *phydev)
+{
+	unsigned short data[8], reg_num = 5;
+
+	data[0] = CFG_WOL;
+	data[1] = en;
+	data[2] = val[0];
+	data[3] = val[1];
+	data[4] = val[2];
+
+	aeon_ipc_cfg_param_direct(reg_num, data, phydev);
+}
+
+void aeon_ipc_smi_command(unsigned short *val, struct phy_device *phydev)
+{
+	unsigned short data[8], reg_num = 3;
+
+	data[0] = CFG_SMI_COMMAND;
+	data[1] = val[0];
+	data[2] = val[1];
+
+	aeon_ipc_cfg_param_direct(reg_num, data, phydev);
+}
+
+void aeon_ipc_irq_en(unsigned short *val, struct phy_device *phydev)
+{
+	struct device *dev = phydev_dev(phydev);
+	unsigned short status = 0;
+	unsigned short ret_size;
+	unsigned short data[8], reg_num = 5;
+
+	data[0] = IPC_CMD_IRQ_EN;
+	data[1] = val[0];
+	data[2] = val[1];
+	data[3] = val[2];
+	data[4] = val[3];
+
+	aeon_send_ipc_msg(phydev, reg_num, data, IPC_CMD_CFG_IRQ, reg_num * 2);
+	status = aeon_ipc_wait_cmd_done(phydev, NULL, &ret_size);
+	if (status != IPC_STS_CMD_SUCCESS) {
+		dev_err(dev, "set irq en command failed %x\n", status);
+		return;
+	}
+}
+
+void aeon_ipc_irq_clr(unsigned short val, struct phy_device *phydev)
+{
+	struct device *dev = phydev_dev(phydev);
+	unsigned short status = 0;
+	unsigned short ret_size;
+	unsigned short data[8], reg_num = 2;
+
+	data[0] = IPC_CMD_IRQ_CLR;
+	data[1] = val;
+
+	aeon_send_ipc_msg(phydev, reg_num, data, IPC_CMD_CFG_IRQ, reg_num * 2);
+	status = aeon_ipc_wait_cmd_done(phydev, NULL, &ret_size);
+	if (status != IPC_STS_CMD_SUCCESS) {
+		dev_err(dev, "set irq clr command failed %x\n", status);
+		return;
+	}
+}
+
+void aeon_ipc_irq_query(unsigned short *irq, struct phy_device *phydev)
+{
+	struct device *dev = phydev_dev(phydev);
+	unsigned short status = 0;
+	unsigned short ret_size;
+	unsigned short data[8], reg_num = 1;
+
+	data[0] = IPC_CMD_IRQ_QUERY;
+
+	aeon_send_ipc_msg(phydev, reg_num, data, IPC_CMD_CFG_IRQ, reg_num * 2);
+	status = aeon_ipc_wait_cmd_done(phydev, NULL, &ret_size);
+	if (status != IPC_STS_CMD_SUCCESS) {
+		dev_err(dev, "set irq query command failed %x\n", status);
+		return;
+	}
+	aeon_receive_ipc_data(phydev, 1, (unsigned short *)irq);
+}
+
+void aeon_ipc_set_tx_fullscale_delta(unsigned short speed,
+				     unsigned short *delta,
+				     struct phy_device *phydev)
+{
+	unsigned short data[8], reg_num = 5, i = 0;
+
+	data[0] = CFG_NG_PHYCTRL;
+	data[1] = IPC_CMD_CFG_TX_FULLSCALE;
+	data[2] = speed;
+	for (i = 0; i < 4; i++) {
+		data[3] = i;
+		data[4] = *(delta + i);
+
+		aeon_ipc_cfg_param_direct(reg_num, data, phydev);
+	}
+}
+
+void aeon_ipc_get_tx_fullscale_delta(unsigned short speed,
+				     unsigned short *delta,
+				     struct phy_device *phydev)
+{
+	unsigned short data[8], reg_num = 3;
+
+	data[0] = CFG_NG_PHYCTRL;
+	data[1] = IPC_CMD_GET_TX_FULLSCALE;
+	data[2] = speed;
+
+	aeon_ipc_cfg_param_direct(reg_num, data, phydev);
+	aeon_receive_ipc_data(phydev, 4, (unsigned short *)delta);
+}
+
+void aeon_ipc_set_wdt(unsigned short en, struct phy_device *phydev)
+{
+	unsigned short data[8], reg_num = 2;
+
+	data[0] = CFG_WDT;
+	data[1] = en;
+
+	aeon_ipc_cfg_param_direct(reg_num, data, phydev);
+}
+
+void aeon_ipc_read_mem(unsigned short addr1, unsigned short addr2,
+		       unsigned short num, unsigned short *params, struct phy_device *phydev)
+{
+	unsigned short status, ret_size;
+	unsigned short cfg[3] = {addr1, addr2, num};
+	struct device *dev = phydev_dev(phydev);
+
+	aeon_send_ipc_msg(phydev, 3, cfg, IPC_CMD_RMEM16, 6);
+
+	status = aeon_ipc_wait_cmd_done(phydev, NULL, &ret_size);
+	if (status != IPC_STS_CMD_SUCCESS) {
+		dev_err(dev, "read mem command failed %x\n", status);
+		return;
+	}
+	aeon_receive_ipc_data(phydev, num, (unsigned short *)params);
+}
+
+void aeon_ipc_set_mac_cnt(unsigned long long mac_tot_cnt, unsigned long long mac_crc_cnt,
+			  struct phy_device *phydev)
+{
+	unsigned short data[8], reg_num = 6;
+
+	data[0] = CFG_MAC_CNT;
+	data[1] = IPC_CMD_MAC_TOT;
+	data[2] = mac_tot_cnt & 0xFFFF;
+	data[3] = (mac_tot_cnt >> 16) & 0xFFFF;
+	data[4] = (mac_tot_cnt >> 32) & 0xFFFF;
+	data[5] = (mac_tot_cnt >> 48) & 0xFFFF;
+
+	aeon_ipc_cfg_param_direct(reg_num, data, phydev);
+	mdelay(2);
+
+	data[0] = CFG_MAC_CNT;
+	data[1] = IPC_CMD_MAC_CRC;
+	data[2] = mac_crc_cnt & 0xFFFF;
+	data[3] = (mac_crc_cnt >> 16) & 0xFFFF;
+	data[4] = (mac_crc_cnt >> 32) & 0xFFFF;
+	data[5] = (mac_crc_cnt >> 48) & 0xFFFF;
+
+	aeon_ipc_cfg_param_direct(reg_num, data, phydev);
+}
+
+void aeon_ipc_cable_diag(unsigned short sub_cmd, unsigned short *data_rcv, unsigned short mode,
+			 struct phy_device *phydev)
+{
+	unsigned short data[8], data_size = 0, data_num = 0;
+
+	data[0] = mode;
+
+	switch (sub_cmd) {
+	case IPC_CMD_CABLE_DIAG_CHAN_LEN:
+		data_num = 16;
+		break;
+	case IPC_CMD_CABLE_DIAG_PPM_OFST:
+		data_num = 16;
+		break;
+	case IPC_CMD_CABLE_DIAG_SNR_MARG:
+	case IPC_CMD_CABLE_DIAG_CHAN_SKW:
+		data_num = 16;
+		break;
+	case IPC_CMD_CABLE_DIAG_GET:
+		data_num = 16;
+		break;
+	case IPC_CMD_CABLE_DIAG_SET:
+		data_size = 1;
+		break;
+	}
+
+	aeon_ipc_operation(phydev, CFG_CABLE_DIAG, sub_cmd, data,
+			   data_size, IPC_DATA_UINT8, data_rcv, data_num, IPC_DATA_UINT16);
+}
+
+void aeon_synce_enable_cfg(unsigned char enable, struct phy_device *phydev)
+{
+	unsigned char data[8], data_size;
+
+	data[0] = enable;
+	data_size = 1;
+
+	aeon_ipc_operation(phydev, IPC_DBGCMD_SYNCE, IPC_SYNCE_ENABLE, data,
+			   data_size, IPC_DATA_UINT8, NULL, 0, IPC_DATA_UINT8);
+}
+
+void aeon_synce_mode_cfg(unsigned char ms, struct phy_device *phydev)
+{
+	unsigned char data[8], data_size;
+
+	data[0] = ms;
+	data_size = 1;
+
+	aeon_ipc_operation(phydev, IPC_DBGCMD_SYNCE, IPC_SYNCE_MODE, data,
+			   data_size, IPC_DATA_UINT8, NULL, 0, IPC_DATA_UINT8);
+}
+
+void aeon_synce_user_bw(unsigned char bw, struct phy_device *phydev)
+{
+	unsigned short data[8], data_size;
+
+	data[0] = bw;
+	data_size = 1;
+
+	aeon_ipc_operation(phydev, IPC_DBGCMD_SYNCE, IPC_SYNCE_USER_BW, data,
+			   data_size, IPC_DATA_UINT8, NULL, 0, IPC_DATA_UINT8);
+}
+
+void aeon_synce_slave_output_ctrl_cfg(unsigned char oc, struct phy_device *phydev)
+{
+	unsigned short data[8], data_size;
+
+	data[0] = oc;
+	data_size = 1;
+
+	aeon_ipc_operation(phydev, IPC_DBGCMD_SYNCE, IPC_SYNCE_SLAVE_CLK_OUTPUT_CTRL, data,
+			   data_size, IPC_DATA_UINT8, NULL, 0, IPC_DATA_UINT8);
+}
+
+void aeon_parallel_det(unsigned char enable, struct phy_device *phydev)
+{
+	unsigned char data[8], data_size;
+
+	data[0] = enable;
+	data_size = 1;
+
+	aeon_ipc_operation(phydev, IPC_DBGCMD_CU_AN, IPC_CMD_CU_AN_PARA_DET, data,
+			   data_size, IPC_DATA_UINT8, NULL, 0, IPC_DATA_UINT8);
+}
diff --git a/drivers/net/phy/as21xx_bbu_api/as21xx_api.h b/drivers/net/phy/as21xx_bbu_api/as21xx_api.h
new file mode 100644
index 0000000..d7d6aa0
--- /dev/null
+++ b/drivers/net/phy/as21xx_bbu_api/as21xx_api.h
@@ -0,0 +1,923 @@
+/******************************************************************************
+ *
+ * AEONSEMI CONFIDENTIAL
+ * _____________________
+ *
+ * Aeonsemi Inc., 2023
+ * All Rights Reserved.
+ *
+ * NOTICE:  All information contained herein is, and remains the property of
+ * Aeonsemi Inc. and its subsidiaries, if any. The intellectual and technical
+ * concepts contained herein are proprietary to Aeonsemi Inc. and its
+ * subsidiaries and may be covered by U.S. and Foreign Patents, patents in
+ * process, and are protected by trade secret or copyright law. Dissemination
+ * of this information or reproduction of this material is strictly forbidden
+ * unless prior written permission is obtained from Aeonsemi Inc.
+ *
+ *
+ *****************************************************************************/
+#ifndef _AS21XX_API_H
+#define _AS21XX_API_H
+
+#include <linux/mii.h>
+#include <linux/phy.h>
+#include <linux/version.h>
+
+/******************************************************************************
+ * MISC Macros
+ *****************************************************************************/
+enum bitwidth_type {
+	BW8 = 0,
+	BW16 = 1,
+	BW32 = 2,
+};
+
+#define MDI 1
+#define MDIX 0
+
+enum ipc_data_type_t {
+	IPC_DATA_UINT8 = 1,
+	IPC_DATA_UINT16 = 2,
+	IPC_DATA_UINT32 = 4,
+};
+
+#define MDI_CFG_SPD_T10 0x2
+#define MDI_CFG_SPD_T100 0x4
+#define MDI_CFG_SPD_T1G 0x8
+#define MDI_CFG_SPD_T2P5G 0x10
+#define MDI_CFG_SPD_T5G 0x20
+#define MDI_CFG_SPD_T10G 0x40
+
+#define AS21XX_PHY_NUM 2
+
+#if (KERNEL_VERSION(4, 5, 0) > LINUX_VERSION_CODE)
+#define phydev_mdio_bus(_dev) (_dev->bus)
+#define phydev_addr(_dev) (_dev->addr)
+#define phydev_dev(_dev) (&_dev->dev)
+#else
+#define phydev_mdio_bus(_dev) (_dev->mdio.bus)
+#define phydev_addr(_dev) (_dev->mdio.addr)
+#define phydev_dev(_dev) (&_dev->mdio.dev)
+#endif
+
+/**
+ * @brief Flash Image Burning
+ */
+#define CFG_FSM_NGPHY 0x81
+#define CFG_FSM_GPHY 0x8c
+#define CFG_FSM_CU_AN 0x8d
+#define CFG_FSM_DPC 0x8e
+#define CFG_FSM_SS 0x91
+#define FLASH_CHIP_SIZE 0x00200000
+#define IMAGE1_HDR_OFST 0x10000
+#define IMAGE1_OFST 0x10400
+#define IMAGE2_HDR_OFST 0x80000
+#define IMAGE2_OFST 0x80400
+#define MEM_WORD_SIZE 4
+#define BOOT_LOADER_BIN "bootloader_all.bin"
+#define FLASH_BIN "flash_burn.bin"
+#define CLR_FLASH_IMAGE "clr_flash_image.bin"
+#define ERASE_MODE_SECTOR 1
+#define ERASE_MODE_BLOCK 2
+#define FLASH_SECTOR_SIZE 4096
+
+/**
+ * @brief ipc related address
+ */
+#define AEON_REG_ADDR_OFFSET 0xEA000000
+#define AN_REG_GIGA_STD_STATUS_BASEADDR (AEON_REG_ADDR_OFFSET + 0xFFFC2)
+#define IPC_CMD_BASEADDR (AEON_REG_ADDR_OFFSET + 0x3CB002)
+#define IPC_STS_BASEADDR (AEON_REG_ADDR_OFFSET + 0x3CB004)
+#define IPC_DATA0_BASEADDR (AEON_REG_ADDR_OFFSET + 0x3CB010)
+
+/**
+ * @name Status
+ * @brief Introduction of IPC status
+ * 16-bit register IPC_STS_BASEADDR is laid out as follows:
+ * [1 bit parity][5 bits size][6 bits opcode][4 bits status]
+ * The following status indicates the last 4 bits above.
+ */
+#define IPC_STS_CMD_RCVD 0x1
+#define IPC_STS_CMD_PROCESS 0x2
+#define IPC_STS_CMD_SUCCESS 0x4
+#define IPC_STS_CMD_ERROR 0x8
+#define IPC_STS_SYS_BUSY 0xE
+#define IPC_STS_SYS_READY 0xF
+
+#define MAX_POLL 100
+#define IPC_PAYLOAD_SIZE 16
+#define IPC_PAYLOAD_WORDS (IPC_PAYLOAD_SIZE / 2)
+#define IPC_NB_OPCODE 0x6
+#define IPC_PAYLOAD_NB 0x5
+#define IPC_NB_STATUS 0x4
+#define IPC_CMD_PARITY 0x8000
+#define IPC_TIMEOUT 2000000000
+
+#define EYE_GRPS       31
+#define EYE_COLS_GRP    4
+#define EYE_YRES      254
+#define EYE_XRES      (EYE_GRPS * EYE_COLS_GRP)
+#define EYE_STRIDE    (EYE_COLS_GRP * EYE_YRES)
+#define EYE_TOTAL_BYTES (EYE_XRES * EYE_YRES)
+
+/**
+ * IPC Dump information
+ */
+#define IPC_DUMP_CU_AN_NUM 1
+#define IPC_DUMP_DPC_NUM 3
+#define IPC_DUMP_NGPHY_NUM 5
+#define IPC_DBG_DUMP_NUM 9
+#define IPC_DP_DUMP_NUM 34
+/******************************************************************************
+ * IPC Command Macros
+ *****************************************************************************/
+/**
+ * @name Opcode
+ * @brief Introduction of opcodes.
+ * @brief 16-bit register IPC_CMD_BASEADDR is laid out as follows:
+ * @brief [1 bit parity][4 bits reserved][5 bits size][6 bits opcode].
+ *
+ * The following opcodes indicate the last 6 bits above:
+ * @IPC_CMD_NOOP: Do nothing
+ * @IPC_CMD_INFO: Get Firmware Version
+ * @IPC_CMD_SYS_CPU: SYS_CPU
+ * @IPC_CMD_RMEM16: Read date from MEM
+ * @IPC_CMD_BULK_DATA: Pass bulk data in ipc registers
+ * @IPC_CMD_BULK_WRITE: Write bulk data to memory
+ * @IPC_CMD_FLASH_WRITE: Write memory data to flash
+ * @IPC_CMD_FLASH_ERASE: Erase flash
+ * @IPC_CMD_LOG: Read log
+ * @IPC_OPCODE_POLL
+ * @IPC_CMD_CFG_PARAM: Write config parameters to memory
+ * @IPC_CMD_CFG_IRQ: Cfg IRQ Output
+ * @IPC_CMD_SET_LED: Set led
+ * @IPC_OPCODE_DBGCMD
+ * @IPC_OPCODE_WBUF
+ * @IPC_OPCODE_RBUF
+ */
+enum ipc_top_level_cmd {
+	IPC_CMD_NOOP = 0,
+	IPC_CMD_INFO = 1,
+	IPC_CMD_SYS_CPU = 2,
+	IPC_CMD_RMEM16 = 3,
+	IPC_CMD_RMEM32 = 4,
+	IPC_CMD_WMEM16 = 7,
+	IPC_CMD_WMEM32 = 8,
+	IPC_CMD_BULK_DATA = 10,
+	IPC_CMD_BULK_READ = 11,
+	IPC_CMD_BULK_WRITE = 12,
+	IPC_CMD_FLASH_READ = 13,
+	IPC_CMD_FLASH_WRITE = 14,
+	IPC_CMD_FLASH_ERASE = 15,
+	IPC_CMD_MEM_CSUM = 16,
+	IPC_CMD_LOAD_TRIM = 17,
+	IPC_CMD_LOG = 19,
+	IPC_CMD_CFG_PRINTF = 20,
+	IPC_OPCODE_DBGCMD = 22,
+	IPC_OPCODE_POLL = 23,
+	IPC_OPCODE_WBUF = 24,
+	IPC_OPCODE_RBUF = 25,
+	IPC_CMD_CFG_PARAM = 26,
+	IPC_CMD_CFG_UART_PRINT = 33,
+	IPC_CMD_CFG_IRQ = 34,
+	IPC_CMD_SET_LED = 35,
+	IPC_CMD_CFG_INDIRECT = 36,
+};
+
+enum ipc_second_level_param_cmd {
+	IPC_CMD_CFG_DIRECT = 4,
+};
+
+enum ipc_second_level_log_cmd {
+	CFG_LOG_SIZE = 1,
+	CFG_LOG_READ = 2,
+	CFG_LOG_CLEAN = 3
+};
+
+enum ipc_second_level_irq_cmd {
+	IPC_CMD_IRQ_EN = 0,
+	IPC_CMD_IRQ_QUERY = 1,
+	IPC_CMD_IRQ_CLR = 2,
+};
+
+enum dbg_second_level_dbgcmd_cmd {
+	IPC_DBGCMD_NGPHY = 0x80,
+	IPC_DBGCMD_DPC = 0x8b,
+	IPC_DBGCMD_SDS = 0x96,
+	IPC_DBGCMD_CU_AN = 0xA0,
+	CFG_CABLE_DIAG  = 0xa4,
+	IPC_DBGCMD_AUTO_LINK = 0xA9,
+	IPC_DBGCMD_SYNCE = 0xAC,
+};
+
+enum ipc_second_level_info_cmd {
+	IPC_CMD_INFO_VERSION = 1,
+};
+
+enum ipc_second_level_cpu_cmd {
+	IPC_CMD_SYS_REBOOT = 3,
+	IPC_CMD_SYS_IMAGE_OFST = 4,
+	IPC_CMD_SYS_CPU_IMAGE_CHECK = 5,
+	IPC_CMD_SYS_CPU_PHY_ENABLE = 6,
+};
+
+enum ipc_third_level_dirct_cmd {
+	CFG_NG_PHYCTRL = 1,
+	CFG_CU_AN = 2,
+	CFG_SDS_PCS = 3,
+	CFG_AUTO_EEE = 4,
+	CFG_SDS_PMA = 5,
+	CFG_DPC_PKT_CHK = 7,
+	CFG_DPC_SDS_WAIT_ETH = 8,
+	CFG_WDT = 9,
+	CFG_SDS_RESTART_AN = 10,
+	CFG_TEMP_MON = 11,
+	CFG_WOL = 12,
+	CFG_SMI_COMMAND = 13,
+	CFG_EYE_DRAW = 15,
+	CFG_MAC_CNT = 16,
+	CFG_SDS2ND_EN = 17,
+	CFG_SDS2ND_MODE = 18,
+	CFG_SDS2ND_EQ = 19,
+};
+
+enum dbg_third_level_synce_cmd {
+	IPC_SYNCE_ENABLE = 0,
+	IPC_SYNCE_MODE = 1,
+	IPC_SYNCE_USER_BW = 2,
+	IPC_SYNCE_SLAVE_CLK_OUTPUT_CTRL = 3,
+};
+
+#ifdef AEON_SEI2
+enum dbg_third_level_dpc_cmd {
+	CFG_DPC_SET_CFG = 0,
+	CFG_DPC_GET_CFG = 1,
+	CFG_DPC_SDS_SET_CFG = 2,
+	CFG_DPC_SDS_GET_CFG = 3,
+	CFG_DPC_BUFFER_SET_CFG = 4,
+	CFG_DPC_BUFFER_GET_CFG = 5,
+	CFG_DPC_EEE_SET_CFG = 6,
+	CFG_DPC_EEE_GET_CFG = 7,
+	CFG_ETH_STS_HW_UPD_CFG = 8,
+	CFG_ETH_STS_CFG = 9,
+	CFG_BUFFER_EEE_CFG = 10,
+	CFG_ETH_STS_CFG_GET = 11,
+	CFG_EEE_CLK_STOP_CAP = 12,
+	CFG_SUPPORT_FC_SET = 13,
+	CFG_SUPPORT_FC_GET = 14,
+	CFG_DPC_RX_PKT_RATE = 15,
+	CFG_GET_TMR_BIAS = 16,
+	CFG_DP_STOCK_RESTART = 17,
+	CFG_DP_PKT_MON_SET = 18,
+	CFG_DP_PKT_DUMP = 19,
+	CFG_DP_PKT_CLR = 20,
+	CFG_PKT_FIFO_FULL_TH = 21,
+	CFG_PKT_FIFO_FULL_TH_GET = 22,
+};
+
+enum dbg_third_level_sds_cmd {
+	CFG_PHY_SET_SDS_EQ = 0,
+	CFG_SDS_EYE_SCAN = 1,
+	CFG_SDS_EYE_SCAN_CFG_GET = 2,
+	CFG_PHY_GET_SDS_EQ = 3,
+	DBG_TEST_SDS_VGA = 4,
+	DBG_TEST_SDS_EDGE = 5,
+	DBG_TEST_SDS_CTLE = 6,
+	DBG_TEST_SDS_DFE = 7,
+	DBG_TEST_SDS_LOAD = 8,
+	DBG_TEST_SDS_EEE = 9,
+	DBG_SDS_SET_SDS_HW_EQ = 10,
+	DBG_SDS_GET_SDS_HW_EQ = 11,
+	DBG_SDS_PHY_ENABLE = 12,
+	DBG_HWEQ_ITMAX = 13,
+	DBG_HWEQ_FSM_OVRD = 14,
+	DBG_HWEQ_SUBFSM_BRKP = 15,
+};
+
+enum dbg_third_level_ngphy_cmd {
+	CFG_NORMAL_RETRAIN_ABI = 13,
+	CFG_TM5_GAIN_IDX = 14,
+};
+#else
+enum dbg_third_level_ngphy_cmd {
+	CFG_NGPHY_CNT_DUMP = 4,
+	CFG_NGPHY_CNT_CLR = 5,
+	CFG_NORMAL_RETRAIN_ABI = 13,
+	CFG_TM5_GAIN_IDX = 14,
+};
+
+enum dbg_third_level_dpc_cmd {
+	CFG_DPC_SET_CFG = 0,
+	CFG_DPC_SDS_SET_CFG = 0,
+	CFG_DPC_GET_CFG = 1,
+	IPC_CMD_RA_SET_CFG = 2,
+	IPC_CMD_RA_GET_CFG  = 7,
+	CFG_DPC_CNT_DUMP = 13,
+	CFG_DPC_CNT_CLR = 14,
+};
+
+enum dbg_third_level_sds_cmd {
+	CFG_SDS_EYE_SCAN = 1,
+	CFG_SDS_RST = 13,
+	CFG_SDS_TXFIR_SET = 27,
+};
+
+enum dbg_third_level_autolink_cmd {
+	CFG_AUTO_LINK_ENA = 0,
+	CFG_AUTO_LINK_CFG = 1,
+};
+#endif
+
+enum dbg_third_level_diag_cmd {
+	IPC_CMD_CABLE_DIAG_CHAN_LEN = 0,
+	IPC_CMD_CABLE_DIAG_PPM_OFST = 1,
+	IPC_CMD_CABLE_DIAG_SNR_MARG = 2,
+	IPC_CMD_CABLE_DIAG_CHAN_SKW = 3,
+#ifndef AEON_SEI2
+	IPC_CMD_CABLE_DIAG_SET = 11,
+	IPC_CMD_CABLE_DIAG_GET = 12,
+#else
+	IPC_CMD_CABLE_DIAG_SET = 10,
+	IPC_CMD_CABLE_DIAG_GET = 11,
+#endif
+};
+
+enum dbg_third_level_an_cmd {
+	IPC_CMD_CU_AN_ENABLE = 0,
+	IPC_CMD_CU_AN_PARA_DET = 8,
+	IPC_CMD_CU_AN_CNT_GET = 10,
+	IPC_CMD_CU_AN_CNT_CLR = 11,
+};
+
+enum ipc_fourth_level_an_cmd {
+	MDI_CFG_MAN_MDI = 0,
+	MDI_CFG_CU_AN_ENABLE = 1,
+	MDI_CFG_CU_AN_DUPLEX = 2,
+	MDI_CFG_CU_AN_EEE_SPD = 3,
+	MDI_CFG_CU_AN_FR_SPD = 4,
+	MDI_CFG_CU_AN_DS = 6,
+	MDI_CFG_CU_AN_RESTART = 10,
+	MDI_CFG_CU_AN_AEON_OUI = 11,
+	IPC_CMD_CU_AN_TOP_SPD = 12,
+	IPC_CMD_CU_AN_MS_CFG = 13,
+	IPC_CMD_CU_AN_TRD_SWAP = 14,
+	IPC_CMD_CU_AN_GET_MS_CFG = 15,
+	IPC_CMD_CU_AN_CFR = 16,
+};
+
+enum ipc_fourth_level_phyctrl_cmd {
+	IPC_CMD_CFG_PHYCTRL_PAUSED = 2,
+	IPC_CMD_CFG_TX_FULLSCALE = 3,
+	IPC_CMD_CFG_NG_TESTMODE = 4,
+	IPC_CMD_GET_TX_FULLSCALE = 5,
+};
+
+enum ipc_fourth_level_cnt_cmd {
+	IPC_CMD_MAC_TOT = 0,
+	IPC_CMD_MAC_CRC = 1,
+};
+
+/******************************************************************************
+ * Function Definition Macros
+ *****************************************************************************/
+extern int aeon_cl45_read(struct phy_device *phydev, int dev_addr,
+			  unsigned int phy_reg);
+extern void aeon_cl45_write(struct phy_device *phydev, int dev_addr,
+			    unsigned int phy_reg, unsigned short phy_data);
+
+#ifndef AEON_SEI2
+/**
+ * @brief Send command to enable/disable packet checker.
+ * @param enable Enable/disable packet checker.
+ */
+void aeon_pkt_chk_cfg(unsigned short enable, struct phy_device *phydev);
+
+/**
+ * @brief Set auto-eee configuration.
+ * @param enable 1 : enable auto-eee, 0 : disable auto-eee.
+ * @param idle_th idle threshhold
+ */
+void aeon_auto_eee_cfg(unsigned short enable, unsigned int idle_th,
+		       struct phy_device *phydev);
+
+/**
+ * @brief Set sds_wait_eth configuration.
+ * @param sds_wait_eth_delay Delay.
+ */
+void aeon_sds_wait_eth_cfg(unsigned short sds_wait_eth_delay,
+			   struct phy_device *phydev);
+
+/**
+ * @brief Set ipc command for restarting serdes AN.
+ */
+void aeon_sds_restart_an(struct phy_device *phydev);
+
+/**
+ * @brief Set gain.
+ */
+void aeon_ipc_set_tx_power_lvl(unsigned short gain, struct phy_device *phydev);
+
+/**
+ * @brief Enable second Serdes
+ */
+void aeon_sds2nd_enable(unsigned short en, struct phy_device *phydev);
+
+/**
+ * @brief Set Seccond Serdes PCS, Datarate and Operation Mode.
+ */
+void aeon_sds2nd_mode_cfg(unsigned short pcs_mode, unsigned short sds_spd, unsigned short op_mode,
+			  struct phy_device *phydev);
+
+/**
+ * @brief Disable/enable normal retrain.
+ */
+void aeon_normal_retrain_cfg(unsigned short enable, struct phy_device *phydev);
+
+/**
+ * @brief Enable Auto Link Detection.
+ */
+void aeon_ipc_auto_link_ena(unsigned char enable, struct phy_device *phydev);
+
+/**
+ * @brief Enable Auto Link Type Configuration.
+ */
+void aeon_ipc_auto_link_cfg(unsigned char link_type, struct phy_device *phydev);
+
+/**
+ * @brief Set Serdes Tx Fir 3 cursors
+ */
+void aeon_ipc_sds_txfir(unsigned char sds_id, unsigned char pre, unsigned char main,
+			unsigned char post, struct phy_device *phydev);
+
+/**
+ * @brief get PCS mode and speed of serdes.
+ * @param pcs_mode 1 : 64/66B, 0 : 8B/10B.
+ * @param sds_spd 3 : 10G, 2 : 5G, 1 : 2.5G, 0 : 1G.
+ * @param op_mode Normal, Sds_Pkt_Gen, Eth_Pkt_Gen, Eth_Rmt_Lpbk
+ */
+void aeon_sds_pcs_get_cfg(unsigned char *pcs_sel, unsigned char *sds_spd,
+			  struct phy_device *phydev);
+
+/**
+ * @brief ra mode(xfi/usxgmii) shift.
+ * @param enable ra
+ * @param phydev phy device
+ */
+void aeon_ra_mode_shift(unsigned char enable, struct phy_device *phydev);
+
+/**
+ * @brief get ra mode.
+ * @param cfg ra mode
+ * @param phydev phy device
+ */
+void aeon_ra_mode_get(unsigned char *cfg, struct phy_device *phydev);
+
+/**
+ * @brief set sds loopback.
+ * @param phydev phy device
+ */
+void aeon_ipc_enable_sds_loopback(struct phy_device *phydev);
+
+/**
+ * @brief set sds restart.
+ * @param phydev phy device
+ * @param sds_id sds id
+ */
+void aeon_sds_restart(unsigned char sds_id, struct phy_device *phydev);
+#else
+/**
+ * @brief get Sds pcs cfg
+ */
+void aeon_sds_pcs_get_cfg(unsigned char *pcs_sel, unsigned char *sds_spd,
+			  struct phy_device *phydev);
+
+/**
+ * @brief set dpc fc cfg
+ */
+void aeon_dpc_fc_cfg(unsigned char enable, struct phy_device *phydev);
+
+/**
+ * @brief get dpc fc cfg
+ */
+void aeon_dpc_fc_cfg_get(unsigned char *enable, struct phy_device *phydev);
+
+/**
+ * @brief set dpc eee mode
+ */
+void aeon_dpc_eee_mode(unsigned char eee_mode, struct phy_device *phydev);
+
+/**
+ * @brief get dpc eee mode
+ */
+void aeon_dpc_eee_mode_get(unsigned char *eee_mode, struct phy_device *phydev);
+
+/**
+ * @brief set dpc buffer mode
+ */
+void aeon_dpc_buffer_mode(unsigned char buffer_mode, struct phy_device *phydev);
+
+/**
+ * @brief set dpc buffer mode get
+ */
+void aeon_dpc_buffer_mode_get(unsigned char *buffer_mode, struct phy_device *phydev);
+
+/**
+ * @brief set dpc eee clk mode
+ */
+void aeon_dpc_eee_clk_mode(unsigned char clk_mode, struct phy_device *phydev);
+
+/**
+ * @brief set dpc eq cfg
+ */
+void aeon_dpc_eq_cfg(unsigned char vga, unsigned char slc, unsigned char ctle,
+		     unsigned char dfe, unsigned char ffe, struct phy_device *phydev);
+
+/**
+ * @brief set dpc eq cfg
+ */
+void aeon_dpc_eq_cfg_get(unsigned char *eq_cfg, struct phy_device *phydev);
+
+/**
+ * @brief set fifo full tx value
+ */
+void aeon_pkt_fifo_full_th(unsigned short enable, unsigned short rx_th, unsigned short tx_th,
+			   struct phy_device *phydev);
+
+/**
+ * @brief get fifo full tx value
+ */
+void aeon_pkt_fifo_full_th_get(unsigned short *rx_th, unsigned short *tx_th,
+			       struct phy_device *phydev);
+
+/**
+ * @brief set testmode5 gain idx
+ */
+void aeon_ipc_testmode5_gain_idx(unsigned char gain_idx, struct phy_device *phydev);
+#endif
+
+/**
+ * @brief Configure PCS mode and speed of serdes.
+ * @param pcs_mode 1 : 64/66B, 0 : 8B/10B.
+ * @param sds_spd 3 : 10G, 2 : 5G, 1 : 2.5G, 0 : 1G.
+ * @param op_mode Normal, Sds_Pkt_Gen, Eth_Pkt_Gen, Eth_Rmt_Lpbk
+ */
+void aeon_sds_pcs_set_cfg(unsigned char pcs_sel, unsigned char sds_spd,
+			  unsigned char op_mode, struct phy_device *phydev);
+
+/**
+ * @brief Send IPC command to sync parity.
+ */
+void aeon_ipc_sync_parity(struct phy_device *phydev);
+
+/**
+ * @brief get as21xxx log size.
+ * @param msg_size log size.
+ * @param phydev phy device.
+ */
+void aeon_ipc_log_size(unsigned short *msg_size, struct phy_device *phydev);
+
+/**
+ * @brief get as21xxx log data.
+ * @param size log size.
+ * @param pos log size.
+ * @param buf storage log data
+ * @param phydev phy device
+ */
+unsigned int aeon_ipc_read_log(unsigned short size, unsigned short pos, char *buf,
+			       struct phy_device *phydev);
+
+/**
+ * @brief clean as21xxx log data.
+ * @param phydev phy device
+ */
+void aeon_ipc_log_clean(struct phy_device *phydev);
+
+/**
+ * @brief Send IPC command to get FW version.
+ */
+void aeon_ipc_get_fw_version(char *version, struct phy_device *phydev);
+
+/**
+ * @brief Set eee abilities.
+ * @param speed_mode 7 bits [10G eee] [5G eee] [2.5G eee] [1G eee] [100m eee] [0] [0].
+ */
+void aeon_cu_an_set_eee_spd(unsigned short speed_mode,
+			    struct phy_device *phydev);
+
+/**
+ * @brief Set fast retrain abilities.
+ * @param speed_mode 7 bits [10G fr] [5G fr] [2.5G fr] [0] [0] [0] [0].
+ * @param thp_bypass 2 bits [5G thp_bypass] [2.5G thp_bypass]
+ */
+void aeon_cu_an_set_fast_retrain(unsigned short speed_mode,
+				 unsigned short thp_bypass,
+				 struct phy_device *phydev);
+
+/**
+ * @brief Configure donwshift.
+ * @param enable Enable/disable downshift.
+ * @param retry_limit Limited failure times of training.
+ */
+void aeon_cu_an_enable_downshift(unsigned short enable,
+				 unsigned short retry_limit,
+				 struct phy_device *phydev);
+
+/**
+ * @brief Send command to restart AN.
+ */
+void aeon_cu_an_restart(struct phy_device *phydev);
+
+/**
+ * @brief Set non-standard PBO mode.
+ * @param nstd_pbo 2 bits [max_pbo] [min_pbo]
+ */
+void aeon_cu_an_enable_aeon_oui(unsigned short nstd_pbo,
+				struct phy_device *phydev);
+
+/**
+ * @brief Set ipc command to temperature monitor.
+ * @param sub_cmd 1 : start, 2 : stop, 3 : set configuration,
+ *  4 : get temperature, 5 : set threshhold
+ * @param params For sub_cmd = 3, 1 indicates continuous sampling, 0 indicates a single sample.
+ * For sub_cmd = 5, params indicates the temperature threshold to be set.
+ * @param temperature To save current temperature got from ipc command.
+ */
+void aeon_ipc_temp_monitor(unsigned short sub_cmd, unsigned short params,
+			   unsigned short *temperature,
+			   struct phy_device *phydev);
+
+/**
+ * @brief Set serdes adaptations.
+ * @param vga_adapt 1 : enable VGA adaptation, 0 : disable VGA adaptation.
+ * @param slc_adapt 1 : enable slicer adaptation, 0 : disable slicer adaptation.
+ * @param ctle_adapt 1 : enable CTLE adaptation, 0 : disable CTLE adaptation.
+ * @param dfe_adapt 1 : enable DFE adaptation, 0 : disable DFE adaptation.
+ */
+void aeon_sds_pma_set_cfg(unsigned short vga_adapt, unsigned short slc_adapt,
+			  unsigned short ctle_adapt, unsigned short dfe_adapt,
+			  struct phy_device *phydev);
+
+/**
+ * @brief Set led configuration.
+ */
+void aeon_ipc_set_led_cfg(unsigned short led0, unsigned short led1,
+			  unsigned short led2, unsigned short led3,
+			  unsigned short led4, unsigned short polarity,
+			  unsigned short blink, struct phy_device *phydev);
+
+/**
+ * @brief Send command to set top_speed.
+ * @param top_spd 7 bits [10G] [5G] [2.5G] [1G] [100m] [0] [0].
+ */
+void aeon_cu_an_set_top_spd(unsigned short top_spd, struct phy_device *phydev);
+
+/**
+ * @brief Send command to set trd_swap mode.
+ * @param en 1 : override, 0 : no overriding.
+ * @param trd_swap 1 : enable TRD swap, 0 : disable TRD swap.
+ */
+void aeon_cu_an_set_trd_swap(unsigned short en, unsigned short trd_swap,
+			     struct phy_device *phydev);
+
+/**
+ * @brief Send command to set manual master/slave.
+ * @param port_type 0: single port, 1: multi port.
+ * @param ms_man_en 0: disable manual m/s, 1: enable manual m/s.
+ * @param ms_man_val 0: slave, 1: master
+ */
+void aeon_cu_an_set_ms_cfg(unsigned short port_type, unsigned short ms_man_en,
+			   unsigned short ms_man_val,
+			   struct phy_device *phydev);
+
+/**
+ * @brief Send command to get m/s-related configuration.
+ */
+void aeon_cu_an_get_ms_cfg(unsigned short *ms_related_cfg,
+			   struct phy_device *phydev);
+
+/**
+ * @brief Send command to reboot phy.
+ */
+void aeon_ipc_set_sys_reboot(struct phy_device *phydev);
+
+/**
+ * @brief Enable/disable phy.
+ */
+void aeon_ipc_phy_enable_mode(unsigned short enable, struct phy_device *phydev);
+
+/**
+ * @brief Write data from memory to flash.
+ * @param flash_addr Flash address to write to.
+ * @param mem_addr Memory address of data to write.
+ * @param size Size of data.
+ */
+void aeon_ipc_write_flash(unsigned int flash_addr, unsigned int mem_addr,
+			  unsigned short size, struct phy_device *phydev);
+
+/**
+ * @brief Erase flash.
+ * @param flash_addr Flash address to erase.
+ * @param size Size of data.
+ * @param mode Mode of erasing. 1 : sector erase, 2 : block erase.
+ */
+void aeon_ipc_erase_flash(unsigned int flash_addr, unsigned int size,
+			  unsigned short mode, struct phy_device *phydev);
+
+/**
+ * @brief Set WDT.
+ * @param en Enable/disable WDT.
+ */
+void aeon_ipc_set_wdt(unsigned short en, struct phy_device *phydev);
+
+/**
+ * @brief Update image.
+ * @param include_bootloader 1/0.
+ * @note This a demo for dual flash programming feature.
+ */
+void aeon_burn_image(unsigned char include_bootloader,
+		     struct phy_device *phydev);
+
+/**
+ * @brief Send short config parameter list to firmware directly.
+ */
+void aeon_ipc_cfg_param_direct(unsigned int data_len, unsigned short *data,
+			       struct phy_device *phydev);
+
+/**
+ * @brief Set IPC commands related to CPU INFO.
+ */
+int aeon_ipc_sys_cpu_info(unsigned short sub_cmd, unsigned int flash_addr,
+			  unsigned int mem_addr, struct phy_device *phydev);
+
+/**
+ * @brief Set FW FSM running mode.
+ */
+void aeon_ipc_set_fsm_mode(unsigned short fsm, unsigned short mode,
+			   struct phy_device *phydev);
+
+/**
+ * @brief Update flash image.
+ */
+void aeon_update_flash(const char *firmware, unsigned int flash_start,
+		       struct phy_device *phydev);
+
+/**
+ * @brief Set ipc command for NG test mode.
+ */
+void aeon_ipc_ng_test_mode(unsigned short test_mode, unsigned short tone,
+			   struct phy_device *phydev);
+
+/**
+ * @brief Enable NG test mode for specific speed mode.
+ */
+void aeon_ng_test_mode(unsigned short top_spd, unsigned short test_mode, unsigned short tone,
+		       struct phy_device *phydev);
+
+/**
+ * @brief Enable 1G test mode.
+ */
+void aeon_1g_test_mode(unsigned short test_mode, struct phy_device *phydev);
+
+/**
+ * @brief Enable 100M test mode.
+ */
+void aeon_100m_test_mode(struct phy_device *phydev);
+
+/**
+ * @brief Set WOL.
+ * @param en Enable/disable WOL.
+ */
+void aeon_ipc_set_wol(unsigned short en, unsigned short *val,
+	struct phy_device *phydev);
+
+/**
+ * @brief Set SMI Command.
+ * @param val command value.
+ */
+void aeon_ipc_smi_command(unsigned short *val, struct phy_device *phydev);
+
+/**
+ * @brief Set irq enable.
+ * @param val irq index and en.
+ */
+void aeon_ipc_irq_en(unsigned short *val, struct phy_device *phydev);
+
+/**
+ * @brief Set irq clr.
+ * @param val irq index.
+ */
+void aeon_ipc_irq_clr(unsigned short val, struct phy_device *phydev);
+
+/**
+ * @brief get irq status.
+ * @param val irq status.
+ */
+void aeon_ipc_irq_query(unsigned short *irq, struct phy_device *phydev);
+
+/**
+ * @brief Set IPC commands related to cable diag lite.
+ */
+void aeon_ipc_cable_diag(unsigned short sub_cmd, unsigned short *data, unsigned short mode,
+			 struct phy_device *phydev);
+
+/**
+ * @brief Configure CISCO fast-retrain.
+ */
+void aeon_cu_an_set_cfr(unsigned short cfr, struct phy_device *phydev);
+
+/**
+ * @brief Set tx fullscale.
+ */
+void aeon_ipc_set_tx_fullscale_delta(unsigned short speed, unsigned short *delta,
+				     struct phy_device *phydev);
+
+/**
+ * @brief Get tx_full scale.
+ */
+void aeon_ipc_get_tx_fullscale_delta(unsigned short speed, unsigned short *delta,
+				     struct phy_device *phydev);
+
+/**
+ * @brief Get data from memory.
+ */
+void aeon_ipc_read_mem(unsigned short addr1, unsigned short addr2, unsigned short num,
+		       unsigned short *params, struct phy_device *phydev);
+
+/**
+ * @brief Set mac count.
+ */
+void aeon_ipc_set_mac_cnt(unsigned long long mac_tot_cnt, unsigned long long mac_crc_cnt,
+			  struct phy_device *phydev);
+
+/**
+ * @brief Set Seccond Serdes Equalization.
+ */
+void aeon_sds2nd_eq_cfg(unsigned short vga, unsigned short slc, unsigned short ctle,
+			unsigned short dfe, struct phy_device *phydev);
+
+/**
+ * @brief Set duplex mode.
+ */
+void aeon_set_man_duplex(unsigned short duplex, struct phy_device *phydev);
+
+/**
+ * @brief Enable/disable AN.
+ */
+void aeon_cu_an_enable(unsigned char enable, struct phy_device *phydev);
+
+/**
+ * @brief Serdes Eye Scan.
+ */
+void aeon_ipc_eye_scan(unsigned char sds_id, unsigned char grp, unsigned short *rev_buf,
+		       struct phy_device *phydev);
+
+/**
+ * @brief Force MDI mode.
+ */
+void aeon_set_man_mdi(struct phy_device *phydev);
+
+/**
+ * @brief Force MDIX mode.
+ */
+void aeon_set_man_mdix(struct phy_device *phydev);
+
+/**
+ * @brief Set synce enable.
+ */
+void aeon_synce_enable_cfg(unsigned char enable, struct phy_device *phydev);
+
+/**
+ * @brief Set synce master/slave.
+ */
+void aeon_synce_mode_cfg(unsigned char ms, struct phy_device *phydev);
+
+/**
+ * @brief Set synce user bw
+ */
+void aeon_synce_user_bw(unsigned char bw, struct phy_device *phydev);
+
+/**
+ * @brief Set synce slave output pin
+ */
+void aeon_synce_slave_output_ctrl_cfg(unsigned char oc, struct phy_device *phydev);
+/** @} */
+
+/**
+ * @brief Get phy link status.
+ */
+int aeon_read_status(struct phy_device *phydev);
+
+/**
+ * @brief Set parallel detection.
+ */
+void aeon_parallel_det(unsigned char enable, struct phy_device *phydev);
+
+/**
+ * @brief Dump PHY Count.
+ */
+void aeon_ipc_cnt_dump(unsigned int *revc_buf, struct phy_device *phydev);
+/**
+ * @brief Clear PHY Count.
+ */
+void aeon_ipc_cnt_clr(struct phy_device *phydev);
+#endif
diff --git a/drivers/net/phy/as21xx_bbu_api/as21xx_debugfs.c b/drivers/net/phy/as21xx_bbu_api/as21xx_debugfs.c
new file mode 100644
index 0000000..8b51cc7
--- /dev/null
+++ b/drivers/net/phy/as21xx_bbu_api/as21xx_debugfs.c
@@ -0,0 +1,3774 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/******************************************************************************
+ * AEONSEMI CONFIDENTIAL
+ * _____________________
+ *
+ * Aeonsemi Inc., 2023
+ * All Rights Reserved.
+ *
+ * NOTICE:  All information contained herein is, and remains the property of
+ * Aeonsemi Inc. and its subsidiaries, if any. The intellectual and technical
+ * concepts contained herein are proprietary to Aeonsemi Inc. and its
+ * subsidiaries and may be covered by U.S. and Foreign Patents, patents in
+ * process, and are protected by trade secret or copyright law. Dissemination
+ * of this information or reproduction of this material is strictly forbidden
+ * unless prior written permission is obtained from Aeonsemi Inc.
+ *
+ *
+ *****************************************************************************/
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/debugfs.h>
+#include <linux/printk.h>
+#include <linux/fs.h>
+#include <linux/proc_fs.h>
+#include <linux/phy.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include "../as21xxx.h"
+#include "as21xx_debugfs.h"
+#include "as21xx_api.h"
+#include <linux/timekeeping.h>
+#include <linux/timex.h>
+#include <linux/string.h>
+
+const char *IMP_TYPE_STR[CHAN_NUM] = {
+	"Null", "Open", "Short", "Load"
+};
+
+/******************************************************************************
+ * Static Function
+ *****************************************************************************/
+static int parse_cmd_args(const char *input, struct parsed_cmd *result, int max_args)
+{
+	char buffer[MAX_BUF];
+	char *token, *ptr;
+	int count = 0;
+	size_t len;
+
+	if (!input || !result || max_args > MAX_ARGS)
+		return -EINVAL;
+
+	strncpy(buffer, input, sizeof(buffer));
+	buffer[sizeof(buffer) - 1] = '\0';
+
+	// clear '\n'
+	len = strlen(buffer);
+	if (len > 0 && buffer[len - 1] == '\n')
+		buffer[len - 1] = '\0';
+
+	ptr = buffer;
+
+	token = strsep(&ptr, " ");
+	while (token && *token == '\0')
+		token = strsep(&ptr, " ");
+
+	if (!token)
+		return -EINVAL;
+
+	strncpy(result->cmd, token, sizeof(result->cmd) - 1);
+	result->cmd[sizeof(result->cmd) - 1] = '\0';
+
+	while ((token = strsep(&ptr, " ")) != NULL && count < max_args) {
+		if (*token == '\0')
+			continue;
+
+		if (kstrtol(token, 0, &result->args[count]) != 0)
+			return -EINVAL;
+
+		count++;
+	}
+
+	result->argc = count;
+	return 0;
+}
+
+#ifndef AEON_SEI2
+static inline void printk_pkt_chk_cfg_usage(void)
+{
+	pr_info("================Please input:===================\n");
+	pr_info("Set pkt chk: echo PktChk [mode] > /sys/kernel/debug/{MDIOBUS}/aeon_pkt_chk_cfg\n\n");
+}
+
+static inline void printk_mdc_timing_usage(void)
+{
+	pr_info("================Please input:===================\n");
+	pr_info("echo MdcTiming [mode] > /sys/kernel/debug/{MDIOBUS}/aeon_mdc_timing\n\n");
+}
+
+static inline void printk_auto_eee_cfg_usage(void)
+{
+	pr_info("================Please input:===================\n");
+	pr_info("Set auto-eee: echo AutoEEE [enable] [idle_th] > /sys/kernel/debug/{MDIOBUS}/aeon_auto_eee_cfg\n\n");
+}
+
+static inline void printk_sds_wait_eth_cfg_usage(void)
+{
+	pr_info("================Please input:===================\n");
+	pr_info("echo SdsWaitEth [sds_waith_eth] > /sys/kernel/debug/{MDIOBUS}/aeon_sds_wait_eth\n\n");
+}
+
+static inline void printk_sds_restart_an_usage(void)
+{
+	pr_info("================Please input:===================\n");
+	pr_info("echo sdsan > /sys/kernel/debug/{MDIOBUS}/aeon_sds_restart_an\n\n");
+}
+
+static inline void printk_tx_power_lvl_usage(void)
+{
+	pr_info("================Please input:===================\n");
+	pr_info("echo txgain [val] > /sys/kernel/debug/{MDIOBUS}/aeon_tx_power_lvl\n\n");
+}
+
+static inline void printk_sds2nd_cfg_usage(void)
+{
+	pr_info("================Please input:===================\n");
+	pr_info("Enable Second Serdes: echo Sds2ndEn [enable] > /sys/kernel/debug/{MDIOBUS}/aeon_sds2nd_enable\n");
+	pr_info("Config Second Serdes Equlization: echo Sds2ndEq [vga] [slc] [ctle] [dfe] > /sys/kernel/debug/{MDIOBUS}/aeon_sds2nd_eq_cfg\n");
+	pr_info("Config Second Serdes PCS Mode and Datarate: echo Sds2ndMode [pcsMode] [sdsSpd] > /sys/kernel/debug/{MDIOBUS}/aeon_sds2nd_mode_cfg\n");
+}
+
+static inline void printk_sds2nd_eye_diagram_usage(void)
+{
+	pr_info("================Please input:===================\n");
+	pr_info("echo eyescan > /sys/kernel/debug/{MDIOBUS}/aeon_sds2nd_eye_diagram_data\n");
+	pr_info("echo eyeshow > /sys/kernel/debug/{MDIOBUS}/aeon_sds2nd_eye_diagram_data\n");
+}
+
+static inline void printk_normal_retrain_usage(void)
+{
+	pr_info("================Please input:===================\n");
+	pr_info("echo nr [enable] > /sys/kernel/debug/{MDIOBUS}/aeon_normal_retrain\n\n");
+}
+
+static inline void printk_auto_link_usage(void)
+{
+	pr_info("================Please input:===================\n");
+	pr_info("echo AutoLinkEna [enable] > /sys/kernel/debug/{MDIOBUS}/aeon_auto_link\n");
+	pr_info("echo AutoLinkCfg [linktype] > /sys/kernel/debug/{MDIOBUS}/aeon_auto_link\n\n");
+}
+
+static inline void printk_sds_txfir_usage(void)
+{
+	pr_info("================Please input:===================\n");
+	pr_info("echo SdsTxFir [pre] [main] [post] > /sys/kernel/debug/{MDIOBUS}/aeon_sds_txfir\n\n");
+}
+
+static inline void printk_ra_mode_usage(void)
+{
+	pr_info("================Please input:===================\n");
+	pr_info("echo ra_mode [mode] > /sys/kernel/debug/{MDIOBUS}/aeon_ra_mode\n\n");
+	pr_info("echo ra_get > /sys/kernel/debug/{MDIOBUS}/aeon_ra_mode\n\n");
+}
+
+static inline void printk_dbg_dump_usage(void)
+{
+	pr_info("================Please input:===================\n");
+	pr_info("echo cnt > /sys/kernel/debug/{MDIOBUS}/aeon_dbg_dump\n\n");
+	pr_info("echo clr > /sys/kernel/debug/{MDIOBUS}/aeon_dbg_dump\n\n");
+	pr_info("echo mse > /sys/kernel/debug/{MDIOBUS}/aeon_dbg_dump\n\n");
+	pr_info("echo sds > /sys/kernel/debug/{MDIOBUS}/aeon_dbg_dump\n\n");
+}
+
+static inline void printk_traffic_loopback_usage(void)
+{
+	pr_info("================Please input:===================\n");
+	pr_info("echo sds > /sys/kernel/debug/{MDIOBUS}/aeon_traffic_loopback\n\n");
+	pr_info("echo eth > /sys/kernel/debug/{MDIOBUS}/aeon_traffic_loopback\n\n");
+}
+
+static inline void printk_sds_restart_usage(void)
+{
+	pr_info("================Please input:===================\n");
+	pr_info("echo sds [sds_id] > /sys/kernel/debug/{MDIOBUS}/aeon_sds_restart\n\n");
+}
+#else
+static inline void printk_dpc_fc_usage(void)
+{
+	pr_info("================Please input:===================\n");
+	pr_info("echo FcCfg > /sys/kernel/debug/{MDIOBUS}/aeon_dpc_fc\n");
+	pr_info("echo FcGet > /sys/kernel/debug/{MDIOBUS}/aeon_dpc_fc\n\n");
+}
+
+static inline void printk_dpc_eee_mode_usage(void)
+{
+	pr_info("================Please input:===================\n");
+	pr_info("echo eee_mode [mode] > /sys/kernel/debug/{MDIOBUS}/aeon_eee_mode\n");
+	pr_info("echo eee_mode_get > /sys/kernel/debug/{MDIOBUS}/aeon_eee_mode\n\n");
+}
+
+static inline void printk_buffer_mode_usage(void)
+{
+	pr_info("================Please input:===================\n");
+	pr_info("echo buffer_mode [mode] > /sys/kernel/debug/{MDIOBUS}/aeon_buffer_mode\n");
+	pr_info("echo buffer_mode_get > /sys/kernel/debug/{MDIOBUS}/aeon_buffer_mode\n\n");
+}
+
+static inline void printk_eee_clk_usage(void)
+{
+	pr_info("================Please input:===================\n");
+	pr_info("echo eee_clk [enable] > /sys/kernel/debug/{MDIOBUS}/aeon_eee_clk\n\n");
+}
+
+static inline void printk_sds_eq_usage(void)
+{
+	pr_info("================Please input:===================\n");
+	pr_info("echo sds_eq [vga] [slc] [ctle] [dfe] [ffe] > /sys/kernel/debug/{MDIOBUS}/aeon_sds_eq\n");
+	pr_info("echo sds_eq_get > /sys/kernel/debug/{MDIOBUS}/aeon_sds_eq\n\n");
+}
+
+static inline void printk_i2c_enable_usage(void)
+{
+	pr_info("================Please input:===================\n");
+	pr_info("echo IIC [enable] > /sys/kernel/debug/{MDIOBUS}/aeon_i2c_enable\n");
+}
+
+static inline void printk_fifofull_th_usage(void)
+{
+	pr_info("================Please input:===================\n");
+	pr_info("echo fifofull [enable] [rx_th] [tx_th] > /sys/kernel/debug/{MDIOBUS}/aeon_fifofull_th\n");
+	pr_info("echo fifofull_get > /sys/kernel/debug/{MDIOBUS}/aeon_fifofull_th\n");
+}
+
+static inline void printk_dbg_dump_usage(void)
+{
+	pr_info("================Please input:===================\n");
+	pr_info("echo cnt > /sys/kernel/debug/{MDIOBUS}/aeon_dbg_dump\n\n");
+	pr_info("echo clr > /sys/kernel/debug/{MDIOBUS}/aeon_dbg_dump\n\n");
+}
+
+static inline void printk_testmode5_gain_idx_usage(void)
+{
+	pr_info("================Please input:===================\n");
+	pr_info("echo gain [idx] > /sys/kernel/debug/{MDIOBUS}/aeon_tm5_gain\n\n");
+}
+#endif
+
+#ifdef DUAL_FLASH
+static inline void printk_sys_dual_flash(void)
+{
+	pr_info("================Please input:===================\n");
+	pr_info("echo flash [include_bootloader] > /sys/kernel/debug/{MDIOBUS}/aeon_burn_flash_image\n\n");
+}
+
+static inline void printk_erase_flash(void)
+{
+	pr_info("================Please input:===================\n");
+	pr_info("echo erase [flash_addr] [size] > /sys/kernel/debug/{MDIOBUS}/aeon_erase_flash\n\n");
+}
+#endif
+
+static inline void printk_force_speed_usage(void)
+{
+	pr_info("================Please input:===================\n");
+	pr_info("Set 10G FD: echo 10Gbps > /sys/kernel/debug/{MDIOBUS}/aeon_set_speed_mode\n");
+	pr_info("Set 5G FD: echo 5Gbps > /sys/kernel/debug/{MDIOBUS}/aeon_set_speed_mode\n");
+	pr_info("Set 2.5G FD: echo 2.5Gbps > /sys/kernel/debug/{MDIOBUS}/aeon_set_speed_mode\n");
+	pr_info("Set 1G FD: echo 1Gbps   > /sys/kernel/debug/{MDIOBUS}/aeon_set_speed_mode\n");
+	pr_info("Set 100M FD: echo 100Mbps > /sys/kernel/debug/{MDIOBUS}/aeon_set_speed_mode\n\n");
+}
+
+static inline void printk_restart_an_usage(void)
+{
+	pr_info("================Please input:===================\n");
+	pr_info("Restart AN: echo RestartAN > /sys/kernel/debug/{MDIOBUS}/aeon_restart_an\n");
+}
+
+static inline void printk_mdi_cfg_usage(void)
+{
+	pr_info("================Please input:===================\n");
+	pr_info("Set FastRetrain: echo FastRetrain [speed] [thp_bypass]> /sys/kernel/debug/{MDIOBUS}/aeon_set_mdi_cfg\n");
+	pr_info("Set EEE: echo EEE [speed] > /sys/kernel/debug/{MDIOBUS}/aeon_set_mdi_cfg\n");
+	pr_info("Set AeonOUI: echo AeonOUI [pbo_option]> /sys/kernel/debug/{MDIOBUS}/aeon_set_mdi_cfg\n");
+	pr_info("Set Manual M/S enable: echo ManualMS [value] > /sys/kernel/debug/{MDIOBUS}/aeon_set_mdi_cfg\n");
+	pr_info("Set M/S: echo SetMS [value] > /sys/kernel/debug/{MDIOBUS}/aeon_set_mdi_cfg\n");
+	pr_info("Set Port Type: echo PortType [value] > /sys/kernel/debug/{MDIOBUS}/aeon_set_mdi_cfg\n");
+	pr_info("Set SmartSpd: echo Smartspd [en] [retry_limit] > /sys/kernel/debug/{MDIOBUS}/aeon_set_mdi_cfg\n");
+	pr_info("Set Trd Swap: echo TrdSwap [en] [value] > /sys/kernel/debug/{MDIOBUS}/aeon_set_mdi_cfg\n");
+	pr_info("Set CFR: echo CFR [value] > /sys/kernel/debug/{MDIOBUS}/aeon_set_mdi_cfg\n\n");
+}
+
+static inline void printk_sds_pcs_cfg_usage(void)
+{
+	pr_info("================Please input:===================\n");
+	pr_info("Set sds pcs cfg: echo SdsPcs [pcsMode] [sdsSpd] > /sys/kernel/debug/{MDIOBUS}/aeon_set_sds_pcs_cfg\n");
+}
+
+static inline void printk_sds_pma_cfg_usage(void)
+{
+	pr_info("================Please input:===================\n");
+	pr_info("Set sds pma: echo SdsPma [vga_adapt] [ctle_adapt] [dfe_adapt] [slc_adapt]> /sys/kernel/debug/{MDIOBUS}/aeon_set_sds_pma_cfg\n\n");
+}
+
+static inline void printk_get_fw_version_usage(void)
+{
+	pr_info("================Please input:===================\n");
+	pr_info("Get fw version: echo ver > /sys/kernel/debug/{MDIOBUS}/aeon_fw_version\n\n");
+}
+
+static inline void printk_temp_monitor_usage(void)
+{
+	pr_info("================Please input:===================\n");
+	pr_info("Set temperature monitor: echo temp [subcommand] [param] > /sys/kernel/debug/{MDIOBUS}/aeon_temp_monitor\n\n");
+}
+
+static inline void printk_set_led_usage(void)
+{
+	pr_info("================Please input:===================\n");
+	pr_info("Set led: echo led [led0] [led1] [led2] [led3] [led4] [polarity] [blink] > /sys/kernel/debug/{MDIOBUS}/aeon_set_led\n\n");
+}
+
+static inline void printk_sys_reboot_usage(void)
+{
+	pr_info("================Please input:===================\n");
+	pr_info("Reboot: echo reboot > /sys/kernel/debug/{MDIOBUS}/aeon_set_sys_reboot\n\n");
+}
+
+static inline void printk_read_reg_usage(void)
+{
+	pr_info("================Please input:===================\n");
+	pr_info("echo ReadReg [dev_addr] [phy_reg] > /sys/kernel/debug/{MDIOBUS}/aeon_read_reg\n\n");
+}
+
+static inline void printk_write_reg_usage(void)
+{
+	pr_info("================Please input:===================\n");
+	pr_info("echo WriteReg [dev_addr] [phy_reg] [value] > /sys/kernel/debug/{MDIOBUS}/aeon_write_reg\n\n");
+}
+
+static inline void printk_eth_status_usage(void)
+{
+	pr_info("================Please input:===================\n");
+	pr_info("echo ethstatus > /sys/kernel/debug/{MDIOBUS}/aeon_get_eth_status\n\n");
+}
+
+static inline void printk_phy_enable_usage(void)
+{
+	pr_info("================Please input:===================\n");
+	pr_info("echo phyenable [enable] > /sys/kernel/debug/{MDIOBUS}/aeon_phy_enable\n\n");
+}
+
+static inline void printk_test_mode_usage(void)
+{
+	pr_info("================Please input:===================\n");
+	pr_info("Set NG testmode: echo ngtest [speed] [test_mode] [test_tone(if test_mode == 4)] > /sys/kernel/debug/{MDIOBUS}/aeon_test_mode\n");
+	pr_info("Set 1G testmode: echo 1gtest [test_mode] > /sys/kernel/debug/{MDIOBUS}/aeon_test_mode\n");
+	pr_info("Set 100M testmode: echo 100mtest > /sys/kernel/debug/{MDIOBUS}/aeon_test_mode\n\n");
+}
+
+static inline void printk_tx_fullscale_usage(void)
+{
+	pr_info("================Please input:===================\n");
+	pr_info("echo txfullscale [speed] [val0 val1 val2 val3] > /sys/kernel/debug/{MDIOBUS}/aeon_tx_fullscale\n");
+	pr_info("echo get [speed] > /sys/kernel/debug/{MDIOBUS}/aeon_tx_fullscale\n\n");
+}
+
+static inline void printk_wol_ctrl_usage(void)
+{
+	pr_info("================Please input:===================\n");
+	pr_info("echo wolctrl [value0] [value1] [value2] [value3]> /sys/kernel/debug/{MDIOBUS}/aeon_wol_ctrl\n\n");
+}
+
+static inline void printk_smi_ctrl_usage(void)
+{
+	pr_info("================Please input:===================\n");
+	pr_info("echo smicommand [value0] [value1]> /sys/kernel/debug/{MDIOBUS}/aeon_smi_command\n\n");
+}
+
+static inline void printk_set_irq_en_usage(void)
+{
+	pr_info("================Please input:===================\n");
+	pr_info("echo setirqen [value0] [value1] [value2] [value3] > /sys/kernel/debug/{MDIOBUS}/aeon_setirq_en\n\n");
+}
+
+static inline void printk_set_irq_clr_usage(void)
+{
+	pr_info("================Please input:===================\n");
+	pr_info("echo setirqclr [value0] > /sys/kernel/debug/{MDIOBUS}/aeon_setirq_clr\n\n");
+}
+
+static inline void printk_query_irq_status_usage(void)
+{
+	pr_info("================Please input:===================\n");
+	pr_info("echo queryirq > /sys/kernel/debug/{MDIOBUS}/aeon_query_irq\n\n");
+}
+
+static inline void printk_cable_diag_usage(void)
+{
+	pr_info("================Please input:===================\n");
+	pr_info("echo chanlen > /sys/kernel/debug/{MDIOBUS}/aeon_cable_diag\n");
+	pr_info("echo ppmofst > /sys/kernel/debug/{MDIOBUS}/aeon_cable_diag\n");
+	pr_info("echo snrmargin > /sys/kernel/debug/{MDIOBUS}/aeon_cable_diag\n");
+	pr_info("echo chanskew > /sys/kernel/debug/{MDIOBUS}/aeon_cable_diag\n");
+	pr_info("echo set [mode] > /sys/kernel/debug/{MDIOBUS}/aeon_cable_diag\n");
+	pr_info("echo get > /sys/kernel/debug/{MDIOBUS}/aeon_cable_diag\n\n");
+}
+
+static inline void printk_sds_eye_diagram_usage(void)
+{
+	pr_info("================Please input:===================\n");
+	pr_info("echo eyescan > /sys/kernel/debug/{MDIOBUS}/aeon_eye_diagram_data\n");
+	pr_info("echo eyeshow > /sys/kernel/debug/{MDIOBUS}/aeon_eye_diagram_data\n");
+}
+
+static inline void printk_force_mode_usage(void)
+{
+	pr_info("================Please input:===================\n");
+	pr_info("echo force100M [duplex] > /sys/kernel/debug/{MDIOBUS}/aeon_force_mode\n\n");
+}
+
+static inline void printk_parallel_det_usage(void)
+{
+	pr_info("================Please input:===================\n");
+	pr_info("echo paradet [enable] > /proc/tc3162/aeon_parallel_det\n\n");
+}
+
+static inline void printk_force_mdi_mode_usage(void)
+{
+	pr_info("================Please input:===================\n");
+	pr_info("echo mdi [val] > /sys/kernel/debug/{MDIOBUS}/aeon_force_mdi_mode\n\n");
+}
+
+static inline void printk_synce_master_mode_usage(void)
+{
+	pr_info("================Please input:===================\n");
+	pr_info("echo synce_master [enable] [bw] > /sys/kernel/debug/{MDIOBUS}/aeon_synce_master_mode\n\n");
+}
+
+static inline void printk_synce_slave_mode1_usage(void)
+{
+	pr_info("================Please input:===================\n");
+	pr_info("echo synce_slave_mode1 [enable] [oc] > /sys/kernel/debug/{MDIOBUS}/aeon_synce_slave_mode1\n\n");
+}
+
+static inline void printk_synce_slave_mode2_usage(void)
+{
+	pr_info("================Please input:===================\n");
+	pr_info("echo synce_slave_mode2 [enable] [bw] [oc] > /sys/kernel/debug/{MDIOBUS}/aeon_synce_slave_mode2\n\n");
+}
+
+static inline void printk_phylog_usage(void)
+{
+	pr_info("================Please input:===================\n");
+	pr_info("echo readlog > /sys/kernel/debug/{MDIOBUS}/aeon_read_log\n\n");
+	pr_info("echo cleanlog > /sys/kernel/debug/{MDIOBUS}/aeon_read_log\n\n");
+}
+
+static inline void printk_enable_an_usage(void)
+{
+	pr_info("================Please input:===================\n");
+	pr_info("echo enableAN [enable] > /sys/kernel/debug/{MDIOBUS}/aeon_enable_an\n\n");
+}
+
+/******************************************************************************
+ * Debugfs Function API
+ *****************************************************************************/
+#ifndef AEON_SEI2
+static ssize_t aeon_pkt_chk_cfg_read_proc(struct file *file, char __user *buf,
+					  size_t size, loff_t *ppos)
+{
+	printk_pkt_chk_cfg_usage();
+	return 0;
+}
+
+static ssize_t aeon_pkt_chk_cfg_write_proc(struct file *file,
+					   const char __user *buffer, size_t count,
+					   loff_t *pos)
+{
+	struct phy_device *phydev = file->private_data;
+	char val_string[MAX_BUF] = { 0 };
+	struct parsed_cmd cmdinfo = { 0 };
+
+	if (count >= sizeof(val_string))
+		return -EINVAL;
+
+	if (copy_from_user(val_string, buffer, count))
+		return -EFAULT;
+
+	val_string[count] = '\0';
+
+	if (parse_cmd_args(val_string, &cmdinfo, 1) != 0)
+		return -EINVAL;
+
+	if (!strcmp(cmdinfo.cmd, "PktChk")) {
+		if (cmdinfo.argc != 1)
+			return -EINVAL;
+
+		aeon_ipc_sync_parity(phydev);
+		aeon_pkt_chk_cfg(cmdinfo.args[0], phydev);
+		pr_info("Set Pkt Checker successfully!\n");
+	} else
+		printk_pkt_chk_cfg_usage();
+
+	return count;
+}
+
+static ssize_t aeon_mdc_timing_read_proc(struct file *file, char __user *buf,
+					 size_t size, loff_t *ppos)
+{
+	printk_mdc_timing_usage();
+	return 0;
+}
+
+static ssize_t aeon_mdc_timing_write_proc(struct file *file, const char __user *buffer,
+					  size_t count, loff_t *pos)
+{
+	struct phy_device *phydev = file->private_data;
+	char val_string[MAX_BUF] = { 0 };
+	struct parsed_cmd cmdinfo = { 0 };
+
+	if (count >= sizeof(val_string))
+		return -EINVAL;
+
+	if (copy_from_user(val_string, buffer, count))
+		return -EFAULT;
+
+	val_string[count] = '\0';
+
+	if (parse_cmd_args(val_string, &cmdinfo, 1) != 0)
+		return -EINVAL;
+
+	if (!strcmp(cmdinfo.cmd, "MdcTiming")) {
+		if (cmdinfo.argc != 1)
+			return -EINVAL;
+
+		if (cmdinfo.args[0] == 1) {
+			phy_write_mmd(phydev, 0x1E, 0x53, 0xFFFF);
+			phy_write_mmd(phydev, 0x1E, 0x54, 0xFFFF);
+			phy_write_mmd(phydev, 0x1E, 0x55, 0xFFFF);
+		} else {
+			phy_write_mmd(phydev, 0x1E, 0x53, 0x0);
+			phy_write_mmd(phydev, 0x1E, 0x54, 0x0);
+			phy_write_mmd(phydev, 0x1E, 0x55, 0x0);
+		}
+		pr_info("Set MDC timing successfully!\n");
+	} else
+		printk_mdc_timing_usage();
+
+	return count;
+}
+
+static ssize_t aeon_auto_eee_cfg_read_proc(struct file *file, char __user *buf,
+					   size_t size, loff_t *ppos)
+{
+	printk_auto_eee_cfg_usage();
+	return 0;
+}
+
+static ssize_t aeon_auto_eee_cfg_write_proc(struct file *file,
+					    const char __user *buffer, size_t count,
+					    loff_t *pos)
+{
+	struct phy_device *phydev = file->private_data;
+	char val_string[MAX_BUF] = { 0 };
+	struct parsed_cmd cmdinfo = { 0 };
+
+	if (count >= sizeof(val_string))
+		return -EINVAL;
+
+	if (copy_from_user(val_string, buffer, count))
+		return -EFAULT;
+
+	val_string[count] = '\0';
+
+	if (parse_cmd_args(val_string, &cmdinfo, 2) != 0)
+		return -EINVAL;
+
+	if (!strcmp(cmdinfo.cmd, "AutoEEE")) {
+		if (cmdinfo.argc != 2)
+			return -EINVAL;
+
+		aeon_ipc_sync_parity(phydev);
+		aeon_auto_eee_cfg(cmdinfo.args[0], cmdinfo.args[1], phydev);
+		pr_info("Set Auto EEE successfully!\n");
+	} else
+		printk_auto_eee_cfg_usage();
+
+	return count;
+}
+
+static ssize_t aeon_sds_wait_eth_cfg_read_proc(struct file *file, char __user *buf,
+					       size_t size, loff_t *ppos)
+{
+	printk_sds_wait_eth_cfg_usage();
+	return 0;
+}
+
+static ssize_t aeon_sds_wait_eth_cfg_write_proc(struct file *file,
+						const char __user *buffer,
+						size_t count, loff_t *pos)
+{
+	struct phy_device *phydev = file->private_data;
+	char val_string[MAX_BUF] = { 0 };
+	struct parsed_cmd cmdinfo = { 0 };
+
+	if (count >= sizeof(val_string))
+		return -EINVAL;
+
+	if (copy_from_user(val_string, buffer, count))
+		return -EFAULT;
+
+	val_string[count] = '\0';
+
+	if (parse_cmd_args(val_string, &cmdinfo, 1) != 0)
+		return -EINVAL;
+
+	if (!strcmp(cmdinfo.cmd, "SdsWaitEth")) {
+		if (cmdinfo.argc != 1)
+			return -EINVAL;
+
+		aeon_ipc_sync_parity(phydev);
+		aeon_sds_wait_eth_cfg(cmdinfo.args[0], phydev);
+		pr_info("Set Sds wait Eth cfg successfully!\n");
+	} else
+		printk_sds_wait_eth_cfg_usage();
+
+	return count;
+}
+
+static ssize_t aeon_sds_restart_an_read_proc(struct file *file, char __user *buf,
+					     size_t size, loff_t *ppos)
+{
+	printk_sds_restart_an_usage();
+
+	return 0;
+}
+
+static ssize_t aeon_sds_restart_an_write_proc(struct file *file,
+					      const char __user *buffer, size_t count,
+					      loff_t *pos)
+{
+	struct phy_device *phydev = file->private_data;
+	char val_string[MAX_BUF] = { 0 };
+	struct parsed_cmd cmdinfo = { 0 };
+
+	if (count >= sizeof(val_string))
+		return -EINVAL;
+
+	if (copy_from_user(val_string, buffer, count))
+		return -EFAULT;
+
+	val_string[count] = '\0';
+
+	if (parse_cmd_args(val_string, &cmdinfo, 0) != 0)
+		return -EINVAL;
+
+	if (!strcmp(cmdinfo.cmd, "sdsan")) {
+		if (cmdinfo.argc != 0)
+			return -EINVAL;
+
+		aeon_ipc_sync_parity(phydev);
+		aeon_sds_restart_an(phydev);
+		pr_info("Restart sds AN successfully!\n");
+	} else
+		printk_sds_restart_an_usage();
+
+	return count;
+}
+
+static ssize_t aeon_tx_power_lvl_read_proc(struct file *file, char __user *buffer,
+					   size_t count, loff_t *pos)
+{
+	printk_tx_power_lvl_usage();
+
+	return 0;
+}
+
+static ssize_t aeon_tx_power_lvl_write_proc(struct file *file, const char __user *buffer,
+					    size_t count, loff_t *pos)
+{
+	struct phy_device *phydev = file->private_data;
+	char val_string[MAX_BUF] = { 0 };
+	struct parsed_cmd cmdinfo = { 0 };
+
+	if (count >= sizeof(val_string))
+		return -EINVAL;
+
+	if (copy_from_user(val_string, buffer, count))
+		return -EFAULT;
+
+	val_string[count] = '\0';
+
+	if (parse_cmd_args(val_string, &cmdinfo, 1) != 0)
+		return -EINVAL;
+
+	if (!strcmp(cmdinfo.cmd, "txgain")) {
+		if (cmdinfo.argc != 1)
+			return -EINVAL;
+
+		aeon_ipc_sync_parity(phydev);
+		aeon_ipc_set_tx_power_lvl(cmdinfo.args[0], phydev);
+		pr_info("Set TX power level successfully!\n");
+	} else
+		printk_tx_power_lvl_usage();
+
+	return count;
+}
+
+static ssize_t aeon_sds2nd_enable_read_proc(struct file *file, char __user *buffer,
+					    size_t count, loff_t *pos)
+{
+	printk_sds2nd_cfg_usage();
+
+	return 0;
+}
+
+static ssize_t aeon_sds2nd_enable_write_proc(struct file *file, const char __user *buffer,
+					     size_t count, loff_t *pos)
+{
+	struct phy_device *phydev = file->private_data;
+	char val_string[MAX_BUF] = { 0 };
+	struct parsed_cmd cmdinfo = { 0 };
+
+	if (count >= sizeof(val_string))
+		return -EINVAL;
+
+	if (copy_from_user(val_string, buffer, count))
+		return -EFAULT;
+
+	val_string[count] = '\0';
+
+	if (parse_cmd_args(val_string, &cmdinfo, 1) != 0)
+		return -EINVAL;
+
+	if (!strcmp(cmdinfo.cmd, "Sds2ndEn")) {
+		if (cmdinfo.argc != 1)
+			return -EINVAL;
+
+		aeon_ipc_sync_parity(phydev);
+		aeon_sds2nd_enable(cmdinfo.args[0], phydev);
+	} else
+		printk_sds2nd_cfg_usage();
+
+	return count;
+}
+
+static ssize_t aeon_sds2nd_eq_read_proc(struct file *file, char __user *buffer,
+					size_t count, loff_t *pos)
+{
+	printk_sds2nd_cfg_usage();
+	return 0;
+}
+
+static ssize_t aeon_sds2nd_eq_write_proc(struct file *file, const char __user *buffer,
+					 size_t count, loff_t *pos)
+{
+	struct phy_device *phydev = file->private_data;
+	char val_string[MAX_BUF] = { 0 };
+	struct parsed_cmd cmdinfo = { 0 };
+
+	if (count >= sizeof(val_string))
+		return -EINVAL;
+
+	if (copy_from_user(val_string, buffer, count))
+		return -EFAULT;
+
+	val_string[count] = '\0';
+
+	if (parse_cmd_args(val_string, &cmdinfo, 4) != 0)
+		return -EINVAL;
+
+	if (!strcmp(cmdinfo.cmd, "Sds2ndEq")) {
+		if (cmdinfo.argc != 4)
+			return -EINVAL;
+
+		aeon_ipc_sync_parity(phydev);
+		aeon_sds2nd_eq_cfg(cmdinfo.args[0], cmdinfo.args[1], cmdinfo.args[2],
+				   cmdinfo.args[3], phydev);
+	} else
+		printk_sds2nd_cfg_usage();
+
+	return count;
+}
+
+static ssize_t aeon_sds2nd_mode_read_proc(struct file *file, char __user *buffer,
+					  size_t count, loff_t *pos)
+{
+	printk_sds2nd_cfg_usage();
+	return 0;
+}
+
+static ssize_t aeon_sds2nd_mode_write_proc(struct file *file, const char __user *buffer,
+					   size_t count, loff_t *pos)
+{
+	struct phy_device *phydev = file->private_data;
+	char val_string[MAX_BUF] = { 0 };
+	struct parsed_cmd cmdinfo = { 0 };
+
+	if (count >= sizeof(val_string))
+		return -EINVAL;
+
+	if (copy_from_user(val_string, buffer, count))
+		return -EFAULT;
+
+	val_string[count] = '\0';
+
+	if (parse_cmd_args(val_string, &cmdinfo, 2) != 0)
+		return -EINVAL;
+
+	if (!strcmp(cmdinfo.cmd, "Sds2ndMode")) {
+		if (cmdinfo.argc != 2)
+			return -EINVAL;
+
+		aeon_ipc_sync_parity(phydev);
+		aeon_sds2nd_mode_cfg(cmdinfo.args[0], cmdinfo.args[1], 0, phydev);
+	} else
+		printk_sds2nd_cfg_usage();
+
+	return count;
+}
+
+static ssize_t aeon_sds2nd_eye_diagram_read_proc(struct file *file, char __user *buffer,
+						 size_t count, loff_t *pos)
+{
+	printk_sds2nd_eye_diagram_usage();
+	return 0;
+}
+
+static ssize_t aeon_sds2nd_eye_diagram_write_proc(struct file *file, const char __user *buffer,
+						  size_t count, loff_t *pos)
+{
+	struct phy_device *phydev = file->private_data;
+	struct as21xxx_priv *priv = phydev->priv;
+	unsigned short *raw_eye_data = priv->raw_eye_data;
+	char val_string[MAX_BUF] = { 0 };
+	struct parsed_cmd cmdinfo = { 0 };
+	unsigned short ii, grp;
+
+	if (count >= sizeof(val_string))
+		return -EINVAL;
+
+	if (copy_from_user(val_string, buffer, count))
+		return -EFAULT;
+
+	val_string[count] = '\0';
+
+	if (parse_cmd_args(val_string, &cmdinfo, 1) != 0)
+		return -EINVAL;
+
+	if (!strcmp(cmdinfo.cmd, "eyescan"))
+		for (grp = 0; grp < EYE_GRPS ; ++grp) {
+			aeon_ipc_sync_parity(phydev);
+			aeon_ipc_eye_scan(1, grp, &raw_eye_data[grp * EYE_STRIDE], phydev);
+			msleep(1000);
+			aeon_ipc_sync_parity(phydev);
+			aeon_ipc_eye_scan(1, grp, &raw_eye_data[grp * EYE_STRIDE], phydev);
+		}
+	else if (!strcmp(cmdinfo.cmd, "eyeshow")) {
+		pr_info("RAW EYE data:\n");
+		for (ii = 0; ii < EYE_TOTAL_BYTES; ++ii) {
+			if ((ii % 16) == 0)
+				pr_info("\n");
+			pr_info("0x%04x ", raw_eye_data[ii]);
+		}
+		pr_info("\n");
+
+		memset(raw_eye_data, 0, EYE_TOTAL_BYTES * sizeof(unsigned short));
+	} else
+		printk_sds2nd_eye_diagram_usage();
+
+	return count;
+}
+
+static ssize_t aeon_normal_retrain_read_proc(struct file *file, char __user *buffer,
+					     size_t count, loff_t *pos)
+{
+	printk_normal_retrain_usage();
+	return 0;
+}
+
+static ssize_t aeon_normal_retrain_write_proc(struct file *file, const char __user *buffer,
+					      size_t count, loff_t *pos)
+{
+	struct phy_device *phydev = file->private_data;
+	char val_string[MAX_BUF] = { 0 };
+	struct parsed_cmd cmdinfo = { 0 };
+
+	if (count >= sizeof(val_string))
+		return -EINVAL;
+
+	if (copy_from_user(val_string, buffer, count))
+		return -EFAULT;
+
+	val_string[count] = '\0';
+
+	if (parse_cmd_args(val_string, &cmdinfo, 1) != 0)
+		return -EINVAL;
+
+	if (!strcmp(cmdinfo.cmd, "nr")) {
+		if (cmdinfo.argc != 1)
+			return -EINVAL;
+
+		aeon_ipc_sync_parity(phydev);
+		aeon_normal_retrain_cfg(cmdinfo.args[0], phydev);
+		pr_info("Set normal retrain successfully!\n");
+	} else
+		printk_normal_retrain_usage();
+
+	return count;
+}
+
+static ssize_t aeon_auto_link_read_proc(struct file *file, char __user *buffer,
+					size_t count, loff_t *pos)
+{
+	printk_auto_link_usage();
+	return 0;
+}
+
+static ssize_t aeon_auto_link_write_proc(struct file *file, const char __user *buffer,
+					 size_t count, loff_t *pos)
+{
+	struct phy_device *phydev = file->private_data;
+	char val_string[MAX_BUF] = { 0 };
+	struct parsed_cmd cmdinfo = { 0 };
+	unsigned char enable = 0;
+	unsigned char link_type = 0;
+
+	if (count >= sizeof(val_string))
+		return -EINVAL;
+
+	if (copy_from_user(val_string, buffer, count))
+		return -EFAULT;
+
+	val_string[count] = '\0';
+
+	if (parse_cmd_args(val_string, &cmdinfo, 1) != 0)
+		return -EINVAL;
+
+	if (!strcmp(cmdinfo.cmd, "AutoLinkEna")) {
+		if (cmdinfo.argc != 1)
+			return -EINVAL;
+		enable = cmdinfo.args[0];
+		aeon_ipc_sync_parity(phydev);
+		aeon_ipc_auto_link_ena(enable, phydev);
+	} else if (!strcmp(cmdinfo.cmd, "AutoLinkCfg")) {
+		if (cmdinfo.argc != 1)
+			return -EINVAL;
+		link_type = cmdinfo.args[0];
+		aeon_ipc_sync_parity(phydev);
+		aeon_ipc_auto_link_cfg(link_type, phydev);
+	} else
+		printk_auto_link_usage();
+
+	return count;
+}
+
+static ssize_t aeon_sds_txfir_read_proc(struct file *file, char __user *buffer,
+					size_t count, loff_t *pos)
+{
+	printk_sds_txfir_usage();
+	return 0;
+}
+
+static ssize_t aeon_sds_txfir_write_proc(struct file *file, const char __user *buffer,
+					 size_t count, loff_t *pos)
+{
+	struct phy_device *phydev = file->private_data;
+	char val_string[MAX_BUF] = { 0 };
+	struct parsed_cmd cmdinfo = { 0 };
+	unsigned short pre, main, post;
+
+	if (count >= sizeof(val_string))
+		return -EINVAL;
+
+	if (copy_from_user(val_string, buffer, count))
+		return -EFAULT;
+
+	val_string[count] = '\0';
+
+	if (parse_cmd_args(val_string, &cmdinfo, 3) != 0)
+		return -EINVAL;
+
+	if (!strcmp(cmdinfo.cmd, "SdsTxFir")) {
+		if (cmdinfo.argc != 3)
+			return -EINVAL;
+		pre = cmdinfo.args[0];
+		main = cmdinfo.args[1];
+		post = cmdinfo.args[2];
+		aeon_ipc_sync_parity(phydev);
+		aeon_ipc_sds_txfir(0, pre, main, post, phydev);
+	} else
+		printk_sds_txfir_usage();
+
+	return count;
+}
+
+static ssize_t aeon_ra_mode_read_proc(struct file *file, char __user *buffer,
+				      size_t count, loff_t *pos)
+{
+	printk_ra_mode_usage();
+
+	return 0;
+}
+
+static ssize_t aeon_ra_mode_write_proc(struct file *file, const char __user *buffer,
+				       size_t count, loff_t *pos)
+{
+	struct phy_device *phydev = file->private_data;
+	char ra_cfg[16] = {0};
+	char val_string[MAX_BUF] = {0};
+	struct parsed_cmd cmdinfo = {0};
+
+	if (count >= sizeof(val_string))
+		return -EINVAL;
+
+	if (copy_from_user(val_string, buffer, count))
+		return -EFAULT;
+
+	val_string[count] = '\0';
+
+	if (parse_cmd_args(val_string, &cmdinfo, 1) != 0)
+		return -EINVAL;
+
+	if (!strcmp(cmdinfo.cmd, "ra_mode")) {
+		if (cmdinfo.argc != 1)
+			return -EINVAL;
+
+		aeon_ra_mode_shift(cmdinfo.args[0], phydev);
+		pr_info("aeon set ra cfg successful\r\n");
+	} else if (!strcmp(cmdinfo.cmd, "ra_get")) {
+		aeon_ra_mode_get(ra_cfg, phydev);
+		pr_info("aeon get ra cfg %d\r\n", ra_cfg[0]);
+	} else
+		printk_ra_mode_usage();
+
+	return count;
+}
+
+static ssize_t aeon_dbg_dump_read_proc(struct file *file, char __user *buffer,
+				       size_t count, loff_t *pos)
+{
+	printk_dbg_dump_usage();
+
+	return 0;
+}
+
+static ssize_t aeon_dbg_dump_write_proc(struct file *file, const char __user *buffer,
+					size_t count, loff_t *pos)
+{
+	struct phy_device *phydev = file->private_data;
+	char val_string[MAX_BUF] = {0};
+	unsigned short val = 0;
+	unsigned char mse = 0;
+	unsigned char pwr = 0;
+	unsigned char speed = 0;
+	unsigned char link_status = 0;
+	unsigned int addr = 0;
+	unsigned char ch = 0;
+	unsigned short top = 0;
+	struct parsed_cmd cmdinfo = {0};
+	unsigned int recv_buf[IPC_DBG_DUMP_NUM] = {0};
+
+	if (count >= sizeof(val_string))
+		return -EINVAL;
+
+	if (copy_from_user(val_string, buffer, count))
+		return -EFAULT;
+
+	val_string[count] = '\0';
+
+	if (parse_cmd_args(val_string, &cmdinfo, 0) != 0)
+		return -EINVAL;
+
+	if (!strcmp(cmdinfo.cmd, "clr")) {
+		aeon_ipc_sync_parity(phydev);
+		aeon_ipc_cnt_clr(phydev);
+	} else if (!strcmp(cmdinfo.cmd, "cnt")) {
+		aeon_ipc_sync_parity(phydev);
+		aeon_ipc_cnt_dump(recv_buf, phydev);
+		pr_info("ERR_BLk     : %d\n", recv_buf[0]);
+		pr_info("BER_CNT     : %d\n", recv_buf[1]);
+		pr_info("HI_BER      : %d\n", recv_buf[2]);
+		pr_info("CFR_CNT     : %d\n", recv_buf[3]);
+		pr_info("CU_AN_CNT   : %d\n", recv_buf[4]);
+		pr_info("LDPC_ERR    : %d\n", recv_buf[5]);
+		pr_info("ETH_CRC_ERR : %d\n", recv_buf[6]);
+		pr_info("SDS_CRC_ERR : %d\n", recv_buf[7]);
+	} else if (!strcmp(cmdinfo.cmd, "mse")) {
+		val = aeon_cl45_read(phydev, 0x7, 0x8005);
+		link_status = ((val & 0xF000) >> 12) == 9;
+		if (link_status == 0)
+			pr_info("Link is down\n");
+		else {
+			val = aeon_cl45_read(phydev, 0x1E, 0x4002);
+			speed = val & 0xFF;
+			if (0x3 == speed || 0x5 == speed || 0x9 == speed) {
+				val = aeon_cl45_read(phydev, 0x1,  0xc2aa);
+				pr_info("CH_0 : MSE %d\n", val);
+				val = aeon_cl45_read(phydev, 0x1,  0xc2ab);
+				pr_info("CH_1 : MSE %d\n", val);
+				val = aeon_cl45_read(phydev, 0x1,  0xcaaa);
+				pr_info("CH_2 : MSE %d\n", val);
+				val = aeon_cl45_read(phydev, 0x1,  0xcaab);
+				pr_info("CH_3 : MSE %d\n", val);
+			} else if (speed == 0x10  || speed == 0x20) {
+				addr = 0x99ae;
+				for (ch = 0; ch < 4; ch++) {
+					val = aeon_cl45_read(phydev, 0x1, addr + ch);
+					mse = val & 0xff;
+					pwr = (val >> 8) & 0xff;
+					pr_info("CH_%d : PWR %d MSE %d\n", ch, pwr, mse);
+				}
+			}
+		}
+	} else if (!strcmp(cmdinfo.cmd, "sds")) {
+		pr_info("SerDes State:\n");
+		val = aeon_cl45_read(phydev, 0x1e, 0x0002);
+		top = val;
+		aeon_cl45_write(phydev, 0x1e, 0x0002, val | 0x8000);
+		val = aeon_cl45_read(phydev, 0x3, 0x0020);
+		pr_info("  PCS_STAT1    : 0x%04x\n", val);
+		val = aeon_cl45_read(phydev, 0x3, 0x0021);
+		pr_info("  PCS_STAT2    : 0x%04x\n", val);
+		aeon_cl45_write(phydev, 0x1, 0x80e3, 0xFFFF);
+		val = aeon_cl45_read(phydev, 0x1, 0x80e3);
+		pr_info("  PMA_INTR_FLAG: 0x%04x\n", val);
+		val = aeon_cl45_read(phydev, 0x1, 0x80e4);
+		pr_info("  PMA_INTR_RAW : 0x%04x\n", val);
+		val = aeon_cl45_read(phydev, 0x7, 0xFFE4);
+		pr_info("  USXGMII_MII4 : 0x%04x\n", val);
+		val = aeon_cl45_read(phydev, 0x7, 0xFFE5);
+		pr_info("  USXGMII_MII5 : 0x%04x\n", val);
+		val = aeon_cl45_read(phydev, 0x7, 0x8002);
+		pr_info("  USXGMII_STAT : 0x%04x\n", val);
+		aeon_cl45_write(phydev, 0x1e, 0x0002, top);
+	} else
+		printk_dbg_dump_usage();
+
+	return count;
+}
+
+static ssize_t aeon_traffic_loopback_read_proc(struct file *file, char __user *buffer,
+					       size_t count, loff_t *pos)
+{
+	printk_traffic_loopback_usage();
+	return 0;
+}
+
+static ssize_t aeon_traffic_loopback_write_proc(struct file *file, const char __user *buffer,
+						size_t count, loff_t *pos)
+{
+	struct phy_device *phydev = file->private_data;
+	char val_string[MAX_BUF] = { 0 };
+	struct parsed_cmd cmdinfo = { 0 };
+	unsigned char pcs_sel = 0, sds_spd = 0;
+
+	if (count >= sizeof(val_string))
+		return -EINVAL;
+
+	if (copy_from_user(val_string, buffer, count))
+		return -EFAULT;
+
+	val_string[count] = '\0';
+
+	if (parse_cmd_args(val_string, &cmdinfo, 1) != 0)
+		return -EINVAL;
+
+	if (!strcmp(cmdinfo.cmd, "sds")) {
+		aeon_ipc_enable_sds_loopback(phydev);
+		pr_info("  Set sds loopback successful\n");
+	} else if (!strcmp(cmdinfo.cmd, "eth")) {
+		aeon_ipc_sync_parity(phydev);
+		aeon_sds_pcs_get_cfg(&pcs_sel, &sds_spd, phydev);
+		aeon_ipc_sync_parity(phydev);
+		aeon_sds_pcs_set_cfg(pcs_sel, sds_spd, 3, phydev);
+		pr_info("  Set eth loopback successful\n");
+	} else
+		printk_traffic_loopback_usage();
+
+	return count;
+}
+
+static ssize_t aeon_sds_restart_read_proc(struct file *file, char __user *buffer,
+					  size_t count, loff_t *pos)
+{
+	printk_sds_restart_usage();
+
+	return 0;
+}
+
+static ssize_t aeon_sds_restart_write_proc(struct file *file, const char __user *buffer,
+					   size_t count, loff_t *pos)
+{
+	struct phy_device *phydev = file->private_data;
+	char val_string[MAX_BUF] = { 0 };
+	struct parsed_cmd cmdinfo = { 0 };
+
+	if (count >= sizeof(val_string))
+		return -EINVAL;
+
+	if (copy_from_user(val_string, buffer, count))
+		return -EFAULT;
+
+	val_string[count] = '\0';
+
+	if (parse_cmd_args(val_string, &cmdinfo, 1) != 0)
+		return -EINVAL;
+
+	if (!strcmp(cmdinfo.cmd, "sds")) {
+		if (cmdinfo.argc != 1)
+			return -EINVAL;
+		aeon_sds_restart(cmdinfo.args[0], phydev);
+		pr_info("  Set sds restart successful\n");
+	} else
+		printk_sds_restart_usage();
+
+	return count;
+}
+
+#else
+static ssize_t aeon_dpc_fc_read_proc(struct file *file, char __user *buffer,
+				     size_t count, loff_t *pos)
+{
+	printk_dpc_fc_usage();
+	return 0;
+}
+
+static ssize_t aeon_dpc_fc_write_proc(struct file *file, const char __user *buffer,
+				   size_t count, loff_t *pos)
+{
+	struct phy_device *phydev = file->private_data;
+	char val_string[MAX_BUF] = { 0 };
+	struct parsed_cmd cmdinfo = { 0 };
+	unsigned char enable[16] = {0};
+	unsigned char pcs_sel = 0, sds_spd = 0;
+
+	if (count >= sizeof(val_string))
+		return -EINVAL;
+
+	if (copy_from_user(val_string, buffer, count))
+		return -EFAULT;
+
+	val_string[count] = '\0';
+
+	if (parse_cmd_args(val_string, &cmdinfo, 1) != 0)
+		return -EINVAL;
+
+	if (!strcmp(cmdinfo.cmd, "FcCfg")) {
+		aeon_ipc_sync_parity(phydev);
+		aeon_sds_pcs_get_cfg(&pcs_sel, &sds_spd, phydev);
+		aeon_ipc_sync_parity(phydev);
+		if (pcs_sel == 0)
+			aeon_dpc_fc_cfg(1, phydev);
+		else
+			aeon_dpc_fc_cfg(0, phydev);
+		pr_info("Dpc Fc Write Successful\r\n");
+	} else if (!strcmp(cmdinfo.cmd, "FcGet")) {
+		aeon_ipc_sync_parity(phydev);
+		aeon_dpc_fc_cfg_get(enable, phydev);
+		pr_info("FcCfg Enable: %d\n", enable[0]);
+	} else
+		printk_dpc_fc_usage();
+
+	return count;
+}
+
+static ssize_t aeon_dpc_eee_mode_read_proc(struct file *file, char __user *buffer,
+					   size_t count, loff_t *pos)
+{
+	printk_dpc_eee_mode_usage();
+
+	return 0;
+}
+
+static ssize_t aeon_dpc_eee_mode_write_proc(struct file *file, const char __user *buffer,
+					    size_t count, loff_t *pos)
+{
+	struct phy_device *phydev = file->private_data;
+	char val_string[MAX_BUF] = { 0 };
+	struct parsed_cmd cmdinfo = { 0 };
+	unsigned char eee_mode[16] = {0};
+
+	if (count >= sizeof(val_string))
+		return -EINVAL;
+
+	if (copy_from_user(val_string, buffer, count))
+		return -EFAULT;
+
+	val_string[count] = '\0';
+
+	if (parse_cmd_args(val_string, &cmdinfo, 1) != 0)
+		return -EINVAL;
+
+	if (!strcmp(cmdinfo.cmd, "eee_mode")) {
+		if (cmdinfo.argc != 1)
+			return -EINVAL;
+
+		eee_mode[0] = cmdinfo.args[0];
+		aeon_ipc_sync_parity(phydev);
+		aeon_dpc_eee_mode(eee_mode[0], phydev);
+		pr_info("Dpc EEE Mode Write Successful\r\n");
+	} else if (!strcmp(cmdinfo.cmd, "eee_mode_get")) {
+		aeon_ipc_sync_parity(phydev);
+		aeon_dpc_eee_mode_get(eee_mode, phydev);
+		pr_info("Dpc EEE Mode mode: %d\n", eee_mode[0]);
+	} else
+		printk_dpc_eee_mode_usage();
+
+	return count;
+}
+
+static ssize_t aeon_dpc_buffer_mode_read_proc(struct file *file, char __user *buffer,
+					      size_t count, loff_t *pos)
+{
+	printk_buffer_mode_usage();
+
+	return 0;
+}
+
+static ssize_t aeon_dpc_buffer_mode_write_proc(struct file *file, const char __user *buffer,
+					       size_t count, loff_t *pos)
+{
+	struct phy_device *phydev = file->private_data;
+	char val_string[MAX_BUF] = { 0 };
+	struct parsed_cmd cmdinfo = { 0 };
+	unsigned char buffer_mode[16] = {0}, eee_mode[16] = {0};
+	unsigned char pcs_sel = 0, sds_spd = 0;
+
+	if (count >= sizeof(val_string))
+		return -EINVAL;
+
+	if (copy_from_user(val_string, buffer, count))
+		return -EFAULT;
+
+	val_string[count] = '\0';
+
+	if (parse_cmd_args(val_string, &cmdinfo, 1) != 0)
+		return -EINVAL;
+
+	if (!strcmp(cmdinfo.cmd, "buffer_mode")) {
+		if (cmdinfo.argc != 1)
+			return -EINVAL;
+
+		buffer_mode[0] = cmdinfo.args[0];
+		aeon_ipc_sync_parity(phydev);
+		aeon_sds_pcs_get_cfg(&pcs_sel, &sds_spd, phydev);
+		aeon_ipc_sync_parity(phydev);
+		aeon_dpc_eee_mode_get(eee_mode, phydev);
+		if (pcs_sel == 0)
+			aeon_dpc_buffer_mode(1, phydev);
+		else if (eee_mode[0] == 1)
+			aeon_dpc_buffer_mode(1, phydev);
+		else
+			aeon_dpc_buffer_mode(buffer_mode[0], phydev);
+		pr_info("Buffer Mode Write Successful\n");
+	} else if (!strcmp(cmdinfo.cmd, "buffer_mode_get")) {
+		aeon_ipc_sync_parity(phydev);
+		aeon_dpc_buffer_mode_get(buffer_mode, phydev);
+		pr_info("Buffer Mode Read: %d\n", buffer_mode[0]);
+	} else
+		printk_buffer_mode_usage();
+
+	return count;
+}
+
+static ssize_t aeon_eee_clk_read_proc(struct file *file, char __user *buffer,
+				      size_t count, loff_t *pos)
+{
+	printk_eee_clk_usage();
+	return 0;
+}
+
+static ssize_t aeon_eee_clk_write_proc(struct file *file, const char __user *buffer,
+				       size_t count, loff_t *pos)
+{
+	struct phy_device *phydev = file->private_data;
+	char val_string[MAX_BUF] = { 0 };
+	struct parsed_cmd cmdinfo = { 0 };
+	unsigned char eee_clk, eee_mode[16] = {0};
+
+	if (count >= sizeof(val_string))
+		return -EINVAL;
+
+	if (copy_from_user(val_string, buffer, count))
+		return -EFAULT;
+
+	val_string[count] = '\0';
+
+	if (parse_cmd_args(val_string, &cmdinfo, 1) != 0)
+		return -EINVAL;
+
+	if (!strcmp(cmdinfo.cmd, "eee_clk")) {
+		if (cmdinfo.argc != 1)
+			return -EINVAL;
+
+		eee_clk = cmdinfo.args[0];
+		aeon_ipc_sync_parity(phydev);
+		aeon_dpc_eee_mode_get(eee_mode, phydev);
+		aeon_ipc_sync_parity(phydev);
+		if (eee_mode[0] == 2)
+			aeon_dpc_eee_clk_mode(eee_clk, phydev);
+		else {
+			eee_clk = 0;
+			aeon_dpc_eee_clk_mode(eee_clk, phydev);
+		}
+		pr_info("EEE Clk  %d Write Successful\n", eee_clk);
+	} else
+		printk_eee_clk_usage();
+
+	return count;
+}
+
+static ssize_t aeon_sds_eq_read_proc(struct file *file, char __user *buffer,
+				     size_t count, loff_t *pos)
+{
+	printk_sds_eq_usage();
+
+	return 0;
+}
+
+static ssize_t aeon_sds_eq_write_proc(struct file *file, const char __user *buffer,
+				      size_t count, loff_t *pos)
+{
+	struct phy_device *phydev = file->private_data;
+	char val_string[MAX_BUF] = { 0 };
+	struct parsed_cmd cmdinfo = { 0 };
+	unsigned char vga, slc, ctle, dfe, ffe;
+	unsigned char cfg[5] = {0};
+
+	if (count >= sizeof(val_string))
+		return -EINVAL;
+
+	if (copy_from_user(val_string, buffer, count))
+		return -EFAULT;
+
+	val_string[count] = '\0';
+
+	if (parse_cmd_args(val_string, &cmdinfo, 5) != 0)
+		return -EINVAL;
+
+	if (!strcmp(cmdinfo.cmd, "sds_eq")) {
+		if (cmdinfo.argc != 5)
+			return -EINVAL;
+
+		vga = cmdinfo.args[0];
+		slc = cmdinfo.args[1];
+		ctle = cmdinfo.args[2];
+		dfe = cmdinfo.args[3];
+		ffe = cmdinfo.args[4];
+		aeon_ipc_sync_parity(phydev);
+		aeon_dpc_eq_cfg(vga, slc, ctle, dfe, ffe, phydev);
+		pr_info("Sds Eq Write Successful\n");
+	} else if (!strcmp(cmdinfo.cmd, "sds_eq_get")) {
+		aeon_dpc_eq_cfg_get(cfg, phydev);
+		pr_info("Sds Eq Vga: %d, Slc %d, Ctle %d, Dfe %d, Ffe %d\r\n",
+			cfg[0], cfg[1], cfg[2], cfg[3], cfg[4]);
+	} else
+		printk_sds_eq_usage();
+
+	return count;
+}
+
+static ssize_t aeon_i2c_enable_read_proc(struct file *file, char __user *buffer,
+					 size_t count, loff_t *pos)
+{
+	printk_i2c_enable_usage();
+	return 0;
+}
+
+static ssize_t aeon_i2c_enable_write_proc(struct file *file, const char __user *buffer,
+					  size_t count, loff_t *pos)
+{
+	struct phy_device *phydev = file->private_data;
+	char val_string[MAX_BUF] = {0};
+	struct parsed_cmd cmdinfo = {0};
+	unsigned short reg = 0;
+
+	if (count >= sizeof(val_string))
+		return -EINVAL;
+
+	if (copy_from_user(val_string, buffer, count))
+		return -EFAULT;
+
+	val_string[count] = '\0';
+
+	if (parse_cmd_args(val_string, &cmdinfo, 1) != 0)
+		return -EINVAL;
+
+	if (!strcmp(cmdinfo.cmd, "IIC")) {
+		if (cmdinfo.argc != 1)
+			return -EINVAL;
+
+		if (cmdinfo.args[0] == 0) {
+			reg = aeon_cl45_read(phydev, 30, 2);
+			reg &= 0xe7ff;
+			reg |= 0x1000;
+			aeon_cl45_write(phydev, 30, 2, reg);
+		} else if (cmdinfo.args[0] == 1) {
+			reg = aeon_cl45_read(phydev, 30, 2);
+			reg &= 0xe7ff;
+			reg |= 0x800;
+			aeon_cl45_write(phydev, 30, 2, reg);
+		} else
+			printk_i2c_enable_usage();
+
+		pr_info("IIC enable/disable write successful\r\n");
+	} else
+		printk_i2c_enable_usage();
+
+	return count;
+}
+
+static ssize_t aeon_fifofull_th_read_proc(struct file *file, char __user *buffer,
+					  size_t count, loff_t *pos)
+{
+	printk_fifofull_th_usage();
+
+	return 0;
+}
+
+static ssize_t aeon_fifofull_th_write_proc(struct file *file, const char __user *buffer,
+					   size_t count, loff_t *pos)
+{
+	struct phy_device *phydev = file->private_data;
+	char val_string[MAX_BUF] = {0};
+	struct parsed_cmd cmdinfo = {0};
+	unsigned short rx_th, tx_th;
+
+	if (count >= sizeof(val_string))
+		return -EINVAL;
+
+	if (copy_from_user(val_string, buffer, count))
+		return -EFAULT;
+
+	val_string[count] = '\0';
+
+	if (parse_cmd_args(val_string, &cmdinfo, 3) != 0)
+		return -EINVAL;
+
+	if (!strcmp(cmdinfo.cmd, "fifofull")) {
+		if (cmdinfo.argc != 3)
+			return -EINVAL;
+		aeon_ipc_sync_parity(phydev);
+		aeon_pkt_fifo_full_th(cmdinfo.args[0], cmdinfo.args[1], cmdinfo.args[2], phydev);
+		pr_info("fifo full th write successful\r\n");
+	} else if (!strcmp(cmdinfo.cmd, "fifofull_get")) {
+		aeon_ipc_sync_parity(phydev);
+		aeon_pkt_fifo_full_th_get(&rx_th, &tx_th, phydev);
+		pr_info("fifo full th get rx_th %d, tx_th %d\r\n", rx_th, tx_th);
+	} else
+		printk_fifofull_th_usage();
+
+	return count;
+}
+
+static ssize_t aeon_dbg_dump_read_proc(struct file *file, char __user *buffer,
+				       size_t count, loff_t *pos)
+{
+	printk_dbg_dump_usage();
+	return 0;
+}
+
+static ssize_t aeon_dbg_dump_write_proc(struct file *file, const char __user *buffer,
+					size_t count, loff_t *pos)
+{
+	struct phy_device *phydev = file->private_data;
+	char val_string[MAX_BUF] = {0};
+	struct parsed_cmd cmdinfo = {0};
+	unsigned int recv_buf[IPC_DP_DUMP_NUM] = {0};
+
+	if (count >= sizeof(val_string))
+		return -EINVAL;
+
+	if (copy_from_user(val_string, buffer, count))
+		return -EFAULT;
+
+	val_string[count] = '\0';
+
+	if (parse_cmd_args(val_string, &cmdinfo, 0) != 0)
+		return -EINVAL;
+
+	if (!strcmp(cmdinfo.cmd, "clr")) {
+		aeon_ipc_sync_parity(phydev);
+		aeon_ipc_cnt_clr(phydev);
+	} else if (!strcmp(cmdinfo.cmd, "cnt")) {
+		aeon_ipc_sync_parity(phydev);
+		aeon_ipc_cnt_dump(recv_buf, phydev);
+		pr_info("from sds:\n");
+		pr_info("  frm_cnt=%llu, crc_err=%llu, err_sym=%llu, runt=%d, oversize=%d\n",
+				((u64)recv_buf[1] << 32) | recv_buf[0],
+				((u64)recv_buf[3] << 32) | recv_buf[2],
+				((u64)recv_buf[5] << 32) | recv_buf[4],
+				recv_buf[6], recv_buf[7]);
+		pr_info("to eth:\n");
+		pr_info("  frm_cnt=%llu, crc_err=%llu, err_sym=%llu, runt=%d, oversize=%d\n",
+				((u64)recv_buf[9] << 32) | recv_buf[8],
+				((u64)recv_buf[11] << 32) | recv_buf[10],
+				((u64)recv_buf[13] << 32) | recv_buf[12],
+				recv_buf[14], recv_buf[15]);
+		pr_info("from eth:\n");
+		pr_info("  frm_cnt=%llu, crc_err=%llu, err_sym=%llu, runt=%d, oversize=%d\n",
+				((u64)recv_buf[17] << 32) | recv_buf[16],
+				((u64)recv_buf[19] << 32) | recv_buf[18],
+				((u64)recv_buf[21] << 32) | recv_buf[20],
+				recv_buf[22], recv_buf[23]);
+		pr_info("to sds:\n");
+		pr_info("  frm_cnt=%llu, crc_err=%llu, err_sym=%llu, runt=%d, oversize=%d\n",
+				((u64)recv_buf[25] << 32) | recv_buf[24],
+				((u64)recv_buf[27] << 32) | recv_buf[26],
+				((u64)recv_buf[29] << 32) | recv_buf[28],
+				recv_buf[30], recv_buf[31]);
+		pr_info("sds_rx_err: ber=%d, errblk=%d\n", recv_buf[32], recv_buf[33]);
+	} else
+		printk_dbg_dump_usage();
+
+	return count;
+}
+
+static ssize_t aeon_tm5_gain_idx_read_proc(struct file *file, char __user *buffer,
+					   size_t count, loff_t *pos)
+{
+	printk_testmode5_gain_idx_usage();
+
+	return 0;
+}
+
+static ssize_t aeon_tm5_gain_idx_write_proc(struct file *file, const char __user *buffer,
+					    size_t count, loff_t *pos)
+{
+	struct phy_device *phydev = file->private_data;
+	char val_string[MAX_BUF] = {0};
+	unsigned short val = 0;
+	struct parsed_cmd cmdinfo = {0};
+
+	if (count >= sizeof(val_string))
+		return -EINVAL;
+
+	if (copy_from_user(val_string, buffer, count))
+		return -EFAULT;
+
+	val_string[count] = '\0';
+
+	if (parse_cmd_args(val_string, &cmdinfo, 1) != 0)
+		return -EINVAL;
+
+	if (!strcmp(cmdinfo.cmd, "gain")) {
+		if (cmdinfo.argc != 1)
+			return -EINVAL;
+
+		aeon_ipc_sync_parity(phydev);
+		aeon_ipc_testmode5_gain_idx(cmdinfo.args[0], phydev);
+		pr_info("Set testmode5 gain idx %d successfull\n", cmdinfo.args[0]);
+	} else
+		printk_testmode5_gain_idx_usage();
+
+	return count;
+}
+#endif
+
+static ssize_t aeon_read_reg_read_proc(struct file *file, char __user *buf,
+				       size_t size, loff_t *ppos)
+{
+	printk_read_reg_usage();
+	return 0;
+}
+
+static ssize_t aeon_read_reg_write_proc(struct file *file, const char __user *buffer,
+					size_t count, loff_t *pos)
+{
+	struct phy_device *phydev = file->private_data;
+	char val_string[MAX_BUF] = { 0 };
+	struct parsed_cmd cmdinfo = { 0 };
+	unsigned short value = 0;
+
+	if (count >= sizeof(val_string))
+		return -EINVAL;
+
+	if (copy_from_user(val_string, buffer, count))
+		return -EFAULT;
+
+	val_string[count] = '\0';
+
+	if (parse_cmd_args(val_string, &cmdinfo, 2) != 0)
+		return -EINVAL;
+
+	if (!strcmp(cmdinfo.cmd, "ReadReg")) {
+		if (cmdinfo.argc != 2)
+			return -EINVAL;
+
+		value = aeon_cl45_read(phydev, cmdinfo.args[0], cmdinfo.args[1]);
+		pr_info("Read register value: 0x%x\n", value);
+	} else
+		printk_read_reg_usage();
+
+	return count;
+}
+
+static ssize_t aeon_write_reg_read_proc(struct file *file, char __user *buf,
+					size_t size, loff_t *ppos)
+{
+	printk_write_reg_usage();
+	return 0;
+}
+
+static ssize_t aeon_write_reg_write_proc(struct file *file, const char __user *buffer,
+					 size_t count, loff_t *pos)
+{
+	struct phy_device *phydev = file->private_data;
+	char val_string[MAX_BUF] = { 0 };
+	struct parsed_cmd cmdinfo = { 0 };
+
+	if (count >= sizeof(val_string))
+		return -EINVAL;
+
+	if (copy_from_user(val_string, buffer, count))
+		return -EFAULT;
+
+	val_string[count] = '\0';
+
+	if (parse_cmd_args(val_string, &cmdinfo, 3) != 0)
+		return -EINVAL;
+
+	if (!strcmp(cmdinfo.cmd, "WriteReg")) {
+		if (cmdinfo.argc != 3)
+			return -EINVAL;
+
+		phy_write_mmd(phydev, cmdinfo.args[0], cmdinfo.args[1], cmdinfo.args[2]);
+		pr_info("Write register successfully!\n");
+	} else
+		printk_write_reg_usage();
+
+	return count;
+}
+
+static ssize_t aeon_eth_status_read_proc(struct file *file, char __user *buf,
+					 size_t size, loff_t *ppos)
+{
+	printk_eth_status_usage();
+	return 0;
+}
+
+static ssize_t aeon_eth_status_write_proc(struct file *file, const char __user *buffer,
+					  size_t count, loff_t *pos)
+{
+	struct phy_device *phydev = file->private_data;
+	char val_string[MAX_BUF] = { 0 };
+	struct parsed_cmd cmdinfo = { 0 };
+	unsigned short link_status, speed, value;
+
+	if (count >= sizeof(val_string))
+		return -EINVAL;
+
+	if (copy_from_user(val_string, buffer, count))
+		return -EFAULT;
+
+	val_string[count] = '\0';
+
+	if (parse_cmd_args(val_string, &cmdinfo, 0) != 0)
+		return -EINVAL;
+
+	if (!strcmp(cmdinfo.cmd, "ethstatus")) {
+		if (cmdinfo.argc != 0)
+			return -EINVAL;
+
+		value = aeon_cl45_read(phydev, 0x7, 0x8005);
+		link_status = ((value & 0xF000) >> 12) == 9;
+		pr_info("Link Status : %d\n", link_status);
+		if (link_status) {
+			value = aeon_cl45_read(phydev, 0x1E, 0x4002);
+			speed = value & 0xFF;
+			if (speed == 0x3)
+				pr_info("Link up at 10G\n");
+			else if (speed == 0x5)
+				pr_info("Link up at 5G\n");
+			else if (speed == 0x9)
+				pr_info("Link up at 2.5G\n");
+			else if (speed == 0x10)
+				pr_info("Link up at 1G\n");
+			else if (speed == 0x20)
+				pr_info("Link up at 100M\n");
+		}
+	} else
+		printk_eth_status_usage();
+
+	return count;
+}
+
+static ssize_t aeon_restart_an_read_proc(struct file *file, char __user *buf,
+					 size_t size, loff_t *ppos)
+{
+	printk_restart_an_usage();
+	return 0;
+}
+
+static ssize_t aeon_restart_an_write_proc(struct file *file, const char __user *buffer,
+					  size_t count, loff_t *pos)
+{
+	struct phy_device *phydev = file->private_data;
+	struct as21xxx_priv *priv = phydev->priv;
+	struct an_mdi_cfg *__priv_data = &priv->mdi_cfg;
+	char val_string[MAX_BUF] = { 0 };
+	struct parsed_cmd cmdinfo = { 0 };
+	unsigned short ms_related_cfg[4] = { 0 };
+
+	if (count >= sizeof(val_string))
+		return -EINVAL;
+
+	if (copy_from_user(val_string, buffer, count))
+		return -EFAULT;
+
+	val_string[count] = '\0';
+
+	if (parse_cmd_args(val_string, &cmdinfo, 0) != 0)
+		return -EINVAL;
+
+	if (!strcmp(cmdinfo.cmd, "RestartAN")) {
+		if (cmdinfo.argc != 0)
+			return -EINVAL;
+
+		aeon_cu_an_get_ms_cfg(ms_related_cfg, phydev);
+		if (__priv_data->top_spd != 0xF)
+			aeon_cu_an_set_top_spd(__priv_data->top_spd, phydev);
+		if (__priv_data->eee_spd != 0xFF)
+			aeon_cu_an_set_eee_spd(__priv_data->eee_spd, phydev);
+		if (__priv_data->ms_en != 0xF) {
+			ms_related_cfg[1] = __priv_data->ms_en;
+			aeon_cu_an_set_ms_cfg(ms_related_cfg[0],
+				ms_related_cfg[1], ms_related_cfg[2], phydev);
+		}
+		if (__priv_data->ms_config != 0xF) {
+			ms_related_cfg[2] = __priv_data->ms_config;
+			aeon_cu_an_set_ms_cfg(ms_related_cfg[0],
+				ms_related_cfg[1], ms_related_cfg[2], phydev);
+		}
+		if (__priv_data->port_type != 0xF) {
+			ms_related_cfg[0] = __priv_data->port_type;
+			aeon_cu_an_set_ms_cfg(ms_related_cfg[0],
+				ms_related_cfg[1], ms_related_cfg[2], phydev);
+		}
+		if ((__priv_data->smt_spd.enable != 0xF) ||
+		    (__priv_data->smt_spd.retry_limit != 0xF)) {
+			aeon_cu_an_enable_downshift(__priv_data->smt_spd.enable,
+				__priv_data->smt_spd.retry_limit, phydev);
+		}
+		if (__priv_data->nstd_pbo != 0xFF)
+			aeon_cu_an_enable_aeon_oui(__priv_data->nstd_pbo, phydev);
+		if ((__priv_data->trd_swap != 0xF) ||
+		    (__priv_data->trd_ovrd != 0xF))
+			aeon_cu_an_set_trd_swap(__priv_data->trd_ovrd, __priv_data->trd_swap,
+						phydev);
+		if (__priv_data->cfr != 0xF)
+			aeon_cu_an_set_cfr(__priv_data->cfr, phydev);
+		aeon_ipc_sync_parity(phydev);
+		aeon_cu_an_restart(phydev);
+		pr_info("AN-related CFG finish, restart AN successfully!\n");
+	} else
+		printk_restart_an_usage();
+
+	return count;
+}
+
+static ssize_t aeon_speed_mode_read_proc(struct file *file, char __user *buf,
+					 size_t size, loff_t *ppos)
+{
+	printk_force_speed_usage();
+	return 0;
+}
+
+static ssize_t aeon_speed_mode_write_proc(struct file *file, const char __user *buffer,
+					  size_t count, loff_t *pos)
+{
+	struct phy_device *phydev = file->private_data;
+	struct as21xxx_priv *priv = phydev->priv;
+	struct an_mdi_cfg *__priv_data = &priv->mdi_cfg;
+	char val_string[MAX_BUF] = { 0 };
+	struct parsed_cmd cmdinfo = { 0 };
+
+	if (count >= sizeof(val_string))
+		return -EINVAL;
+
+	if (copy_from_user(val_string, buffer, count))
+		return -EFAULT;
+
+	val_string[count] = '\0';
+
+	if (parse_cmd_args(val_string, &cmdinfo, 0) != 0)
+		return -EINVAL;
+
+	if (cmdinfo.argc != 0)
+		return -EINVAL;
+
+	if (!strcmp(cmdinfo.cmd, "10Gbps")) {
+		__priv_data->top_spd = MDI_CFG_SPD_T10G;
+		pr_info("Set 10Gbps successfully!\n");
+	} else if (!strcmp(cmdinfo.cmd, "5Gbps")) {
+		__priv_data->top_spd = MDI_CFG_SPD_T5G;
+		pr_info("Set 5Gbps successfully!\n");
+	} else if (!strcmp(cmdinfo.cmd, "2.5Gbps")) {
+		__priv_data->top_spd = MDI_CFG_SPD_T2P5G;
+		pr_info("Set 2.5Gbps successfully!\n");
+	} else if (!strcmp(cmdinfo.cmd, "1Gbps")) {
+		__priv_data->top_spd = MDI_CFG_SPD_T1G;
+		pr_info("Set 1Gbps successfully!\n");
+	} else if (!strcmp(cmdinfo.cmd, "100Mbps")) {
+		__priv_data->top_spd = MDI_CFG_SPD_T100;
+		pr_info("Set 100Mbps successfully!\n");
+	} else
+		printk_force_speed_usage();
+
+	return count;
+}
+
+static ssize_t aeon_mdi_cfg_read_proc(struct file *file, char __user *buf, size_t size,
+				      loff_t *ppos)
+{
+	printk_mdi_cfg_usage();
+	return 0;
+}
+
+static ssize_t aeon_mdi_cfg_write_proc(struct file *file, const char __user *buffer,
+				       size_t count, loff_t *pos)
+{
+	struct phy_device *phydev = file->private_data;
+	struct as21xxx_priv *priv = phydev->priv;
+	struct an_mdi_cfg *__priv_data = &priv->mdi_cfg;
+	char val_string[MAX_BUF] = { 0 };
+	struct parsed_cmd cmdinfo = { 0 };
+
+	if (count >= sizeof(val_string))
+		return -EINVAL;
+
+	if (copy_from_user(val_string, buffer, count))
+		return -EFAULT;
+
+	val_string[count] = '\0';
+
+	if (parse_cmd_args(val_string, &cmdinfo, 2) != 0)
+		return -EINVAL;
+
+	if (!strcmp(cmdinfo.cmd, "FastRetrain")) {
+		if (cmdinfo.argc != 2)
+			return -EINVAL;
+		__priv_data->fr_spd = cmdinfo.args[0];
+		__priv_data->thp_byp = cmdinfo.args[1];
+		aeon_cu_an_set_fast_retrain(__priv_data->fr_spd, __priv_data->thp_byp, phydev);
+		pr_info("CFG Fast Retrain successfully!\n");
+	} else if (!strcmp(cmdinfo.cmd, "EEE")) {
+		if (cmdinfo.argc != 1)
+			return -EINVAL;
+		__priv_data->eee_spd = cmdinfo.args[0];
+		pr_info("CFG EEE successfully!\n");
+	} else if (!strcmp(cmdinfo.cmd, "ManualMS")) {
+		if (cmdinfo.argc != 1)
+			return -EINVAL;
+		__priv_data->ms_en = cmdinfo.args[0];
+		pr_info("CFG Manual M/S enable successfully!\n");
+	} else if (!strcmp(cmdinfo.cmd, "SetMS")) {
+		if (cmdinfo.argc != 1)
+			return -EINVAL;
+		__priv_data->ms_config = cmdinfo.args[0];
+		pr_info("CFG M/S successfully!\n");
+	} else if (!strcmp(cmdinfo.cmd, "PortType")) {
+		if (cmdinfo.argc != 1)
+			return -EINVAL;
+		__priv_data->port_type = cmdinfo.args[0];
+		pr_info("CFG Port Type successfully!\n");
+	} else if (!strcmp(cmdinfo.cmd, "Smartspd")) {
+		if (cmdinfo.argc != 2)
+			return -EINVAL;
+		__priv_data->smt_spd.enable = cmdinfo.args[0];
+		__priv_data->smt_spd.retry_limit = cmdinfo.args[1];
+		pr_info("CFG Smartspd successfully!\n");
+	} else if (!strcmp(cmdinfo.cmd, "AeonOUI")) {
+		if (cmdinfo.argc != 1)
+			return -EINVAL;
+		__priv_data->nstd_pbo = cmdinfo.args[0];
+		pr_info("CFG aeon oui successfully!\n");
+	} else if (!strcmp(cmdinfo.cmd, "TrdSwap")) {
+		if (cmdinfo.argc != 2)
+			return -EINVAL;
+		__priv_data->trd_ovrd = cmdinfo.args[0];
+		__priv_data->trd_swap = cmdinfo.args[1];
+		pr_info("CFG Trd Swap successfully!\n");
+	} else if (!strcmp(cmdinfo.cmd, "CFR")) {
+		if (cmdinfo.argc != 1)
+			return -EINVAL;
+		__priv_data->cfr = cmdinfo.args[0];
+		pr_info("CFG CFR successfully!\n");
+	} else
+		printk_mdi_cfg_usage();
+
+	return count;
+}
+
+static ssize_t aeon_sds_pcs_cfg_read_proc(struct file *file, char __user *buf,
+					  size_t size, loff_t *ppos)
+{
+	printk_sds_pcs_cfg_usage();
+	return 0;
+}
+
+static ssize_t aeon_sds_pcs_cfg_write_proc(struct file *file,
+					   const char __user *buffer, size_t count,
+					   loff_t *pos)
+{
+	struct phy_device *phydev = file->private_data;
+	char val_string[MAX_BUF] = { 0 };
+	struct parsed_cmd cmdinfo = { 0 };
+
+	if (count >= sizeof(val_string))
+		return -EINVAL;
+
+	if (copy_from_user(val_string, buffer, count))
+		return -EFAULT;
+
+	val_string[count] = '\0';
+
+	if (parse_cmd_args(val_string, &cmdinfo, 2) != 0)
+		return -EINVAL;
+
+	if (!strcmp(cmdinfo.cmd, "SdsPcs")) {
+		if (cmdinfo.argc != 2)
+			return -EINVAL;
+
+		aeon_ipc_sync_parity(phydev);
+		aeon_sds_pcs_set_cfg(cmdinfo.args[0], cmdinfo.args[1], 0, phydev);
+		pr_info("Set Sds Pcs successfully!\n");
+	} else
+		printk_sds_pcs_cfg_usage();
+
+	return count;
+}
+
+static ssize_t aeon_phy_enable_read_proc(struct file *file, char __user *buf,
+					 size_t size, loff_t *ppos)
+{
+	printk_phy_enable_usage();
+	return 0;
+}
+
+static ssize_t aeon_phy_enable_write_proc(struct file *file, const char __user *buffer,
+					  size_t count, loff_t *pos)
+{
+	struct phy_device *phydev = file->private_data;
+	char val_string[MAX_BUF] = { 0 };
+	struct parsed_cmd cmdinfo = { 0 };
+
+	if (count >= sizeof(val_string))
+		return -EINVAL;
+
+	if (copy_from_user(val_string, buffer, count))
+		return -EFAULT;
+
+	val_string[count] = '\0';
+
+	if (parse_cmd_args(val_string, &cmdinfo, 1) != 0)
+		return -EINVAL;
+
+	if (!strcmp(cmdinfo.cmd, "phyenable")) {
+		if (cmdinfo.argc != 1)
+			return -EINVAL;
+
+		aeon_ipc_sync_parity(phydev);
+		aeon_ipc_phy_enable_mode(cmdinfo.args[0], phydev);
+		pr_info("Set phy successfully!\n");
+	} else
+		printk_phy_enable_usage();
+
+	return count;
+}
+
+static ssize_t aeon_set_led_read_proc(struct file *file, char __user *buf, size_t size,
+				      loff_t *ppos)
+{
+	printk_set_led_usage();
+	return 0;
+}
+
+static ssize_t aeon_set_led_write_proc(struct file *file, const char __user *buffer,
+				       size_t count, loff_t *pos)
+{
+	struct phy_device *phydev = file->private_data;
+	char val_string[MAX_BUF] = { 0 };
+	struct parsed_cmd cmdinfo = { 0 };
+
+	if (count >= sizeof(val_string))
+		return -EINVAL;
+
+	if (copy_from_user(val_string, buffer, count))
+		return -EFAULT;
+
+	val_string[count] = '\0';
+
+	if (parse_cmd_args(val_string, &cmdinfo, 7) != 0)
+		return -EINVAL;
+
+	if (!strcmp(cmdinfo.cmd, "led")) {
+		if (cmdinfo.argc != 7)
+			return -EINVAL;
+
+		aeon_ipc_sync_parity(phydev);
+		aeon_ipc_set_led_cfg(cmdinfo.args[0], cmdinfo.args[1], cmdinfo.args[2],
+				     cmdinfo.args[3], cmdinfo.args[4], cmdinfo.args[5],
+				     cmdinfo.args[6], phydev);
+		pr_info("Set LED successfully!\n");
+	} else
+		printk_set_led_usage();
+
+	return count;
+}
+
+static ssize_t aeon_sds_pma_cfg_read_proc(struct file *file, char __user *buf,
+					  size_t size, loff_t *ppos)
+{
+	printk_sds_pma_cfg_usage();
+	return 0;
+}
+
+static ssize_t aeon_sds_pma_cfg_write_proc(struct file *file,
+					   const char __user *buffer, size_t count,
+					   loff_t *pos)
+{
+	struct phy_device *phydev = file->private_data;
+	char val_string[MAX_BUF] = { 0 };
+	struct parsed_cmd cmdinfo = { 0 };
+
+	if (count >= sizeof(val_string))
+		return -EINVAL;
+
+	if (copy_from_user(val_string, buffer, count))
+		return -EFAULT;
+
+	val_string[count] = '\0';
+
+	if (parse_cmd_args(val_string, &cmdinfo, 4) != 0)
+		return -EINVAL;
+
+	if (!strcmp(cmdinfo.cmd, "SdsPma")) {
+		if (cmdinfo.argc != 4)
+			return -EINVAL;
+
+		aeon_ipc_sync_parity(phydev);
+		aeon_sds_pma_set_cfg(cmdinfo.args[0], cmdinfo.args[1], cmdinfo.args[2],
+				     cmdinfo.args[3], phydev);
+		pr_info("Set Sds PMA successfully!\n");
+	} else
+		printk_sds_pma_cfg_usage();
+
+	return count;
+}
+
+static ssize_t aeon_fw_version_read_proc(struct file *file, char __user *buf,
+					 size_t size, loff_t *ppos)
+{
+	printk_get_fw_version_usage();
+	return 0;
+}
+
+static ssize_t aeon_fw_version_write_proc(struct file *file, const char __user *buffer,
+					  size_t count, loff_t *pos)
+{
+	struct phy_device *phydev = file->private_data;
+	char val_string[MAX_BUF] = { 0 }, version1[16] = { 0 };
+	struct parsed_cmd cmdinfo = { 0 };
+
+	if (count >= sizeof(val_string))
+		return -EINVAL;
+
+	if (copy_from_user(val_string, buffer, count))
+		return -EFAULT;
+
+	val_string[count] = '\0';
+
+	if (parse_cmd_args(val_string, &cmdinfo, 0) != 0)
+		return -EINVAL;
+
+	if (!strcmp(cmdinfo.cmd, "ver")) {
+		if (cmdinfo.argc != 0)
+			return -EINVAL;
+
+		aeon_ipc_sync_parity(phydev);
+		aeon_ipc_get_fw_version(version1, phydev);
+		pr_info("Get FW version : %32s\n", version1);
+	} else
+		printk_get_fw_version_usage();
+
+	return count;
+}
+
+static ssize_t aeon_temp_monitor_read_proc(struct file *file, char __user *buf,
+					   size_t size, loff_t *ppos)
+{
+	printk_temp_monitor_usage();
+	return 0;
+}
+
+static ssize_t aeon_temp_monitor_write_proc(struct file *file,
+					    const char __user *buffer, size_t count,
+					    loff_t *pos)
+{
+	struct phy_device *phydev = file->private_data;
+	char val_string[MAX_BUF] = { 0 };
+	struct parsed_cmd cmdinfo = { 0 };
+	unsigned short tempnow[16] = { 0 }, temperature = 0;
+	unsigned int params;
+
+	if (count >= sizeof(val_string))
+		return -EINVAL;
+
+	if (copy_from_user(val_string, buffer, count))
+		return -EFAULT;
+
+	val_string[count] = '\0';
+
+	if (parse_cmd_args(val_string, &cmdinfo, 2) != 0)
+		return -EINVAL;
+
+	if (!strcmp(cmdinfo.cmd, "temp")) {
+		aeon_ipc_sync_parity(phydev);
+		aeon_ipc_temp_monitor(cmdinfo.args[0], cmdinfo.args[1], tempnow, phydev);
+		pr_info("Set temperature monitor successfully!\n");
+		if (cmdinfo.args[0] == 0x4) {
+			params = (unsigned long)(tempnow[1] | (tempnow[2] << 16));
+			temperature = params / 65536;
+			if (temperature > 32768)
+				temperature = temperature - 1 - 0xFFFF;
+			pr_info("Get temperature : %u celsius\n", temperature);
+		}
+	} else
+		printk_temp_monitor_usage();
+
+	return count;
+}
+
+static ssize_t aeon_sys_reboot_read_proc(struct file *file, char __user *buf,
+					 size_t size, loff_t *ppos)
+{
+	printk_sys_reboot_usage();
+	return 0;
+}
+
+static ssize_t aeon_sys_reboot_write_proc(struct file *file, const char __user *buffer,
+					  size_t count, loff_t *pos)
+{
+	struct phy_device *phydev = file->private_data;
+	char val_string[MAX_BUF] = { 0 };
+	struct parsed_cmd cmdinfo = { 0 };
+
+	if (count >= sizeof(val_string))
+		return -EINVAL;
+
+	if (copy_from_user(val_string, buffer, count))
+		return -EFAULT;
+
+	val_string[count] = '\0';
+
+	if (parse_cmd_args(val_string, &cmdinfo, 0) != 0)
+		return -EINVAL;
+
+	if (!strcmp(cmdinfo.cmd, "reboot")) {
+		if (cmdinfo.argc != 0)
+			return -EINVAL;
+
+		aeon_ipc_sync_parity(phydev);
+		aeon_ipc_set_sys_reboot(phydev);
+		pr_info("Reboot successfully!\n");
+	} else
+		printk_sys_reboot_usage();
+
+	return count;
+}
+
+#ifdef DUAL_FLASH
+static ssize_t aeon_burn_flash_read_proc(struct file *file, char __user *buf,
+					 size_t size, loff_t *ppos)
+{
+	printk_sys_dual_flash();
+	return 0;
+}
+
+static ssize_t aeon_burn_flash_write_proc(struct file *file, const char __user *buffer,
+					  size_t count, loff_t *pos)
+{
+	struct phy_device *phydev = file->private_data;
+	char val_string[MAX_BUF] = { 0 };
+	struct parsed_cmd cmdinfo = { 0 };
+
+	if (count >= sizeof(val_string))
+		return -EINVAL;
+
+	if (copy_from_user(val_string, buffer, count))
+		return -EFAULT;
+
+	val_string[count] = '\0';
+
+	if (parse_cmd_args(val_string, &cmdinfo, 1) != 0)
+		return -EINVAL;
+
+	if (!strcmp(cmdinfo.cmd, "flash")) {
+		if (cmdinfo.argc != 1)
+			return -EINVAL;
+
+		aeon_ipc_sync_parity(phydev);
+		aeon_burn_image(cmdinfo.args[0], phydev);
+		pr_info("Set flash_burning successfully!\n");
+	} else
+		printk_sys_dual_flash();
+
+	return count;
+}
+
+static ssize_t aeon_erase_flash_read_proc(struct file *file, char __user *buf,
+					  size_t size, loff_t *ppos)
+{
+	printk_erase_flash();
+	return 0;
+}
+
+static ssize_t aeon_erase_flash_write_proc(struct file *file,
+					   const char __user *buffer, size_t count,
+					   loff_t *pos)
+{
+	struct phy_device *phydev = file->private_data;
+	char val_string[MAX_BUF] = { 0 };
+	struct parsed_cmd cmdinfo = { 0 };
+
+	if (count >= sizeof(val_string))
+		return -EINVAL;
+
+	if (copy_from_user(val_string, buffer, count))
+		return -EFAULT;
+
+	val_string[count] = '\0';
+
+	if (parse_cmd_args(val_string, &cmdinfo, 2) != 0)
+		return -EINVAL;
+
+	if (!strcmp(cmdinfo.cmd, "erase")) {
+		if (cmdinfo.argc != 2)
+			return -EINVAL;
+
+		aeon_ipc_sync_parity(phydev);
+		aeon_ipc_erase_flash(cmdinfo.args[0], cmdinfo.args[1], 2, phydev);
+		pr_info("Erase flash successfully!\n");
+	} else
+		printk_erase_flash();
+
+	return count;
+}
+#endif
+
+static ssize_t aeon_test_mode_read_proc(struct file *file, char __user *buf,
+					size_t size, loff_t *ppos)
+{
+	printk_test_mode_usage();
+	return 0;
+}
+
+static ssize_t aeon_test_mode_write_proc(struct file *file, const char __user *buffer,
+					 size_t count, loff_t *pos)
+{
+	struct phy_device *phydev = file->private_data;
+	char val_string[MAX_BUF] = { 0 };
+	struct parsed_cmd cmdinfo = { 0 };
+	unsigned short input1;
+
+	if (count >= sizeof(val_string))
+		return -EINVAL;
+
+	if (copy_from_user(val_string, buffer, count))
+		return -EFAULT;
+
+	val_string[count] = '\0';
+
+	if (parse_cmd_args(val_string, &cmdinfo, 3) != 0)
+		return -EINVAL;
+
+	if (!strcmp(cmdinfo.cmd, "100mtest")) {
+		if (cmdinfo.argc != 0)
+			return -EINVAL;
+		aeon_ipc_sync_parity(phydev);
+		aeon_100m_test_mode(phydev);
+		pr_info("Set 100M test mode successfully!\n");
+	} else if (!strcmp(cmdinfo.cmd, "1gtest")) {
+		if (cmdinfo.argc != 1)
+			return -EINVAL;
+		aeon_ipc_sync_parity(phydev);
+		aeon_1g_test_mode(cmdinfo.args[0], phydev);
+		pr_info("Set 1G test mode successfully!\n");
+	} else if (!strcmp(cmdinfo.cmd, "ngtest")) {
+		// Get top_speed
+		if (cmdinfo.args[0] == 1)
+			input1 = MDI_CFG_SPD_T2P5G;
+		else if (cmdinfo.args[0] == 2)
+			input1 = MDI_CFG_SPD_T5G;
+		else if (cmdinfo.args[0] == 3)
+			input1 = MDI_CFG_SPD_T10G;
+		if ((cmdinfo.args[1] == 4) && (cmdinfo.argc == 2)) {
+			pr_info("Please input test tone!\n");
+			printk_test_mode_usage();
+			return -EINVAL;
+		}
+		if ((cmdinfo.argc == 3) && (cmdinfo.args[1] != 4)) {
+			pr_info("Test tone is useless here!\n");
+			printk_test_mode_usage();
+			return -EINVAL;
+		}
+		aeon_ipc_sync_parity(phydev);
+		aeon_ng_test_mode(input1, cmdinfo.args[1], cmdinfo.args[2], phydev);
+		pr_info("Set NG test mode successfully!\n");
+	} else
+		printk_test_mode_usage();
+
+	return count;
+}
+
+static ssize_t aeon_tx_fullscale_read_proc(struct file *file, char __user *buffer,
+					   size_t count, loff_t *pos)
+{
+	printk_tx_fullscale_usage();
+	return 0;
+}
+
+
+static ssize_t aeon_tx_fullscale_write_proc(struct file *file,
+					    const char __user *buffer, size_t count,
+					    loff_t *pos)
+{
+	struct phy_device *phydev = file->private_data;
+	char val_string[MAX_BUF] = { 0 };
+	struct parsed_cmd cmdinfo = { 0 };
+	unsigned short short_delta[4] = { 0 }, speed_all[5] = {4, 8, 16, 32, 64}, i = 0;
+
+	if (count >= sizeof(val_string))
+		return -EINVAL;
+
+	if (copy_from_user(val_string, buffer, count))
+		return -EFAULT;
+
+	val_string[count] = '\0';
+
+	if (parse_cmd_args(val_string, &cmdinfo, 5) != 0)
+		return -EINVAL;
+
+	if (!strcmp(cmdinfo.cmd, "txfullscale")) {
+		if (cmdinfo.argc != 5)
+			return -EINVAL;
+
+		for (i = 0; i < 4; i++)
+			short_delta[i] = (unsigned short)(cmdinfo.args[i+1] + 32678);
+		aeon_ipc_sync_parity(phydev);
+		aeon_ipc_set_tx_fullscale_delta(cmdinfo.args[0], short_delta, phydev);
+		pr_info("Set TX full scale successfully!\n");
+	} else if (!strcmp(cmdinfo.cmd, "get")) {
+		if (cmdinfo.argc != 0)
+			return -EINVAL;
+
+		for (i = 0; i < 5; i++) {
+			aeon_ipc_sync_parity(phydev);
+			aeon_ipc_get_tx_fullscale_delta(speed_all[i], short_delta, phydev);
+			pr_info("speed : %u, tx_fullscale : %d %d %d %d\n", speed_all[i],
+					(short)short_delta[0], (short)short_delta[1],
+					(short)short_delta[2], (short)short_delta[3]);
+		}
+		pr_info("Get TX full scale successfully!\n");
+	} else
+		printk_tx_fullscale_usage();
+
+	return count;
+}
+
+static ssize_t aeon_wol_ctrl_read_proc(struct file *file, char __user *buffer,
+				       size_t count, loff_t *pos)
+{
+	printk_wol_ctrl_usage();
+	return 0;
+}
+
+static ssize_t aeon_wol_ctrl_write_proc(struct file *file, const char __user *buffer,
+					size_t count, loff_t *pos)
+{
+	struct phy_device *phydev = file->private_data;
+	char val_string[MAX_BUF] = { 0 };
+	struct parsed_cmd cmdinfo = { 0 };
+	unsigned short short_delta[3] = { 0 }, i = 0;
+
+	if (count >= sizeof(val_string))
+		return -EINVAL;
+
+	if (copy_from_user(val_string, buffer, count))
+		return -EFAULT;
+
+	val_string[count] = '\0';
+
+	if (parse_cmd_args(val_string, &cmdinfo, 4) != 0)
+		return -EINVAL;
+
+	if (!strcmp(cmdinfo.cmd, "wolctrl")) {
+		if (cmdinfo.argc != 4)
+			return -EINVAL;
+
+		for (i = 0; i < 3; i++)
+			short_delta[i] = (unsigned short)cmdinfo.args[i+1];
+		aeon_ipc_sync_parity(phydev);
+		aeon_ipc_set_wol(cmdinfo.args[0], short_delta, phydev);
+		pr_info("Set wol successfully!\n");
+	} else
+		printk_wol_ctrl_usage();
+
+	return count;
+}
+
+static ssize_t aeon_smi_command_read_proc(struct file *file, char __user *buffer,
+					  size_t count, loff_t *pos)
+{
+	printk_smi_ctrl_usage();
+	return 0;
+}
+
+static ssize_t aeon_smi_command_write_proc(struct file *file,
+					   const char __user *buffer, size_t count,
+					   loff_t *pos)
+{
+	struct phy_device *phydev = file->private_data;
+	char val_string[MAX_BUF] = { 0 };
+	struct parsed_cmd cmdinfo = { 0 };
+	unsigned short short_delta[3] = { 0 }, i = 0;
+
+	if (count >= sizeof(val_string))
+		return -EINVAL;
+
+	if (copy_from_user(val_string, buffer, count))
+		return -EFAULT;
+
+	val_string[count] = '\0';
+
+	if (parse_cmd_args(val_string, &cmdinfo, 2) != 0)
+		return -EINVAL;
+
+	if (!strcmp(cmdinfo.cmd, "smicommand")) {
+		if (cmdinfo.argc != 2)
+			return -EINVAL;
+
+		for (i = 0; i < 2; i++)
+			short_delta[i] = (unsigned short)cmdinfo.args[i];
+		aeon_ipc_sync_parity(phydev);
+		aeon_ipc_smi_command(short_delta, phydev);
+		pr_info("Set SMI Command successfully!\n");
+	} else
+		printk_smi_ctrl_usage();
+
+	return count;
+}
+
+static ssize_t aeon_set_irq_en_read_proc(struct file *file, char __user *buffer,
+					 size_t count, loff_t *pos)
+{
+	printk_set_irq_en_usage();
+	return 0;
+}
+
+static ssize_t aeon_set_irq_en_write_proc(struct file *file, const char __user *buffer,
+					  size_t count, loff_t *pos)
+{
+	struct phy_device *phydev = file->private_data;
+	char val_string[MAX_BUF] = { 0 };
+	struct parsed_cmd cmdinfo = { 0 };
+	unsigned short short_delta[6] = { 0 }, i = 0;
+
+	if (count >= sizeof(val_string))
+		return -EINVAL;
+
+	if (copy_from_user(val_string, buffer, count))
+		return -EFAULT;
+
+	val_string[count] = '\0';
+
+	if (parse_cmd_args(val_string, &cmdinfo, 4) != 0)
+		return -EINVAL;
+
+	if (!strcmp(cmdinfo.cmd, "setirqen")) {
+		if (cmdinfo.argc != 4)
+			return -EINVAL;
+
+		for (i = 0; i < 5; i++)
+			short_delta[i] = (unsigned short)cmdinfo.args[i];
+		aeon_ipc_sync_parity(phydev);
+		aeon_ipc_irq_en(short_delta, phydev);
+		pr_info("Set irq en successfully!\n");
+	} else
+		printk_set_irq_en_usage();
+
+	return count;
+}
+
+static ssize_t aeon_set_irq_clr_read_proc(struct file *file, char __user *buffer,
+					  size_t count, loff_t *pos)
+{
+	printk_set_irq_clr_usage();
+	return 0;
+}
+
+static ssize_t aeon_set_irq_clr_write_proc(struct file *file,
+					   const char __user *buffer, size_t count,
+					   loff_t *pos)
+{
+	struct phy_device *phydev = file->private_data;
+	char val_string[MAX_BUF] = { 0 };
+	struct parsed_cmd cmdinfo = { 0 };
+
+	if (count >= sizeof(val_string))
+		return -EINVAL;
+
+	if (copy_from_user(val_string, buffer, count))
+		return -EFAULT;
+
+	val_string[count] = '\0';
+
+	if (parse_cmd_args(val_string, &cmdinfo, 1) != 0)
+		return -EINVAL;
+
+	if (!strcmp(cmdinfo.cmd, "setirqclr")) {
+		if (cmdinfo.argc != 1)
+			return -EINVAL;
+
+		aeon_ipc_sync_parity(phydev);
+		aeon_ipc_irq_clr(cmdinfo.args[0], phydev);
+		pr_info("Set irq clr successfully!\n");
+	} else
+		printk_set_irq_clr_usage();
+
+	return count;
+}
+
+static ssize_t aeon_query_irq_read_proc(struct file *file, char __user *buffer,
+					size_t count, loff_t *pos)
+{
+	printk_query_irq_status_usage();
+
+	return 0;
+}
+
+static ssize_t aeon_query_irq_write_proc(struct file *file, const char __user *buffer,
+					 size_t count, loff_t *pos)
+{
+	struct phy_device *phydev = file->private_data;
+	char val_string[MAX_BUF] = { 0 };
+	struct parsed_cmd cmdinfo = { 0 };
+	unsigned short param = 0;
+	irq_stats_t stats;
+
+	if (count >= sizeof(val_string))
+		return -EINVAL;
+
+	if (copy_from_user(val_string, buffer, count))
+		return -EFAULT;
+
+	val_string[count] = '\0';
+
+	if (parse_cmd_args(val_string, &cmdinfo, 0) != 0)
+		return -EINVAL;
+
+	if (!strcmp(cmdinfo.cmd, "queryirq")) {
+		if (cmdinfo.argc != 0)
+			return -EINVAL;
+
+		aeon_ipc_sync_parity(phydev);
+		aeon_ipc_irq_query(&param, phydev);
+		pr_info("query irq status is 0x%x!\n", param);
+		*(unsigned char *)&stats = (unsigned char)param;
+		pr_info("wol_sts: %u, link_sts: %u\n", stats.wol_sts, stats.link_sts);
+	} else
+		printk_query_irq_status_usage();
+
+	return count;
+}
+
+static ssize_t aeon_cable_diag_read_proc(struct file *file, char __user *buffer,
+					 size_t count, loff_t *pos)
+{
+	printk_cable_diag_usage();
+	return 0;
+}
+
+static ssize_t aeon_cable_diag_write_proc(struct file *file, const char __user *buffer,
+					  size_t count, loff_t *pos)
+{
+	struct phy_device *phydev = file->private_data;
+	char val_string[MAX_BUF] = { 0 };
+	struct parsed_cmd cmdinfo = { 0 };
+	unsigned short ii = 0, temp[8] = { 0 }, mode = 0;
+	int output = 0;
+
+	if (count >= sizeof(val_string))
+		return -EINVAL;
+
+	if (copy_from_user(val_string, buffer, count))
+		return -EFAULT;
+
+	val_string[count] = '\0';
+
+	if (parse_cmd_args(val_string, &cmdinfo, 1) != 0)
+		return -EINVAL;
+
+	if (cmdinfo.argc > 1)
+		return -EINVAL;
+
+	if (!strcmp(cmdinfo.cmd, "chanlen")) {
+		aeon_ipc_sync_parity(phydev);
+		aeon_ipc_cable_diag(IPC_CMD_CABLE_DIAG_CHAN_LEN, temp, mode, phydev);
+		pr_info("channel length(m) : ");
+		for (ii = 0; ii < CHAN_NUM/2; ii++)
+			pr_info("%u  %u  ", temp[ii] & 0xff, (temp[ii] >> 8));
+		pr_info("\n");
+	} else if (!strcmp(cmdinfo.cmd, "ppmofst")) {
+		aeon_ipc_sync_parity(phydev);
+		aeon_ipc_cable_diag(IPC_CMD_CABLE_DIAG_PPM_OFST, temp, mode, phydev);
+		output = temp[0] | (temp[1] << 16);
+		pr_info("frequency offset : %d\n", output);
+	} else if (!strcmp(cmdinfo.cmd, "snrmargin")) {
+		aeon_ipc_sync_parity(phydev);
+		aeon_ipc_cable_diag(IPC_CMD_CABLE_DIAG_SNR_MARG, temp, mode, phydev);
+		pr_info("SNR margin : ");
+		for (ii = 0; ii < 2 * CHAN_NUM; ii++) {
+			output = temp[ii];
+			++ii;
+			output |= (temp[ii] << 16);
+			pr_info("%d  ", output);
+		}
+		pr_info("\n");
+	} else if (!strcmp(cmdinfo.cmd, "chanskew")) {
+		aeon_ipc_sync_parity(phydev);
+		aeon_ipc_cable_diag(IPC_CMD_CABLE_DIAG_CHAN_SKW, temp, mode, phydev);
+		pr_info("channel skew : ");
+		for (ii = 0; ii < 2 * CHAN_NUM; ii++) {
+			output = temp[ii];
+			++ii;
+			output |= (temp[ii] << 16);
+			pr_info("%d  ", output);
+		}
+		pr_info("\n");
+	} else if (!strcmp(cmdinfo.cmd, "set")) {
+		mode = cmdinfo.args[0];
+		aeon_ipc_sync_parity(phydev);
+		aeon_ipc_cable_diag(IPC_CMD_CABLE_DIAG_SET, temp, mode, phydev);
+	} else if (!strcmp(cmdinfo.cmd, "get")) {
+		aeon_ipc_sync_parity(phydev);
+		aeon_ipc_cable_diag(IPC_CMD_CABLE_DIAG_GET, temp, mode, phydev);
+		pr_info("channel length(m) : ");
+		for (ii = 0; ii < CHAN_NUM/2; ii++)
+			pr_info("%u  %u  ", temp[ii] & 0xff, (temp[ii] >> 8));
+		pr_info("\nimp_type : ");
+		for (ii = 0; ii < CHAN_NUM/2; ii++)
+			pr_info("%s  %s  ", IMP_TYPE_STR[temp[ii+CHAN_NUM/2] & 0xff],
+				IMP_TYPE_STR[(temp[ii+CHAN_NUM/2] >> 8)]);
+		pr_info("\nres_conf : ");
+		pr_info("0x%x\n", temp[CHAN_NUM] & 0xff);
+	} else
+		printk_cable_diag_usage();
+
+	return count;
+}
+
+
+static ssize_t aeon_eye_diagram_read_proc(struct file *file, char __user *buffer,
+					  size_t count, loff_t *pos)
+{
+	printk_sds_eye_diagram_usage();
+	return 0;
+}
+
+static ssize_t aeon_eye_diagram_write_proc(struct file *file, const char __user *buffer,
+					   size_t count, loff_t *pos)
+{
+	struct phy_device *phydev = file->private_data;
+	struct as21xxx_priv *priv = phydev->priv;
+	unsigned short *raw_eye_data = priv->raw_eye_data;
+	char val_string[MAX_BUF] = {  0};
+	struct parsed_cmd cmdinfo = { 0 };
+	unsigned short ii, grp;
+
+	if (count >= sizeof(val_string))
+		return -EINVAL;
+
+	if (copy_from_user(val_string, buffer, count))
+		return -EFAULT;
+
+	val_string[count] = '\0';
+
+	if (parse_cmd_args(val_string, &cmdinfo, 1) != 0)
+		return -EINVAL;
+
+	if (!strcmp(cmdinfo.cmd, "eyescan"))
+		for (grp = 0; grp < EYE_GRPS ; ++grp) {
+			aeon_ipc_sync_parity(phydev);
+			aeon_ipc_eye_scan(0, grp, &raw_eye_data[grp * EYE_STRIDE], phydev);
+			msleep(1000);
+			aeon_ipc_sync_parity(phydev);
+			aeon_ipc_eye_scan(0, grp, &raw_eye_data[grp * EYE_STRIDE], phydev);
+		}
+	else if (!strcmp(cmdinfo.cmd, "eyeshow")) {
+		pr_info("RAW EYE data:\n");
+		for (ii = 0; ii < EYE_TOTAL_BYTES; ++ii) {
+			if (ii % 16 == 0)
+				pr_info("\n");
+			pr_info("0x%04x ", raw_eye_data[ii]);
+		}
+		pr_info("\n");
+
+		memset(raw_eye_data, 0, EYE_TOTAL_BYTES * sizeof(unsigned short));
+	} else
+		printk_sds_eye_diagram_usage();
+
+	return count;
+}
+
+static ssize_t aeon_force_mode_read_proc(struct file *file, char __user *buffer,
+					 size_t count, loff_t *pos)
+{
+	printk_force_mode_usage();
+
+	return 0;
+}
+
+static ssize_t aeon_force_mode_write_proc(struct file *file, const char __user *buffer,
+					  size_t count, loff_t *pos)
+{
+	struct phy_device *phydev = file->private_data;
+	char val_string[MAX_BUF] = { 0 };
+	struct parsed_cmd cmdinfo = { 0 };
+
+	if (count >= sizeof(val_string))
+		return -EINVAL;
+
+	if (copy_from_user(val_string, buffer, count))
+		return -EFAULT;
+
+	val_string[count] = '\0';
+
+	if (parse_cmd_args(val_string, &cmdinfo, 1) != 0)
+		return -EINVAL;
+
+	if (!strcmp(cmdinfo.cmd, "force100M")) {
+		if (cmdinfo.argc != 1)
+			return -EINVAL;
+
+		aeon_ipc_sync_parity(phydev);
+		aeon_set_man_duplex(cmdinfo.args[0], phydev);
+		// switch speed
+		aeon_cu_an_set_top_spd(MDI_CFG_SPD_T100, phydev);
+		// enable AN
+		aeon_cu_an_enable(0, phydev);
+		pr_info("Force 100M successfully!\n");
+	} else
+		printk_force_mode_usage();
+
+	return count;
+}
+
+static ssize_t aeon_parallel_det_read_proc(struct file *file, char __user *buffer,
+					   size_t count, loff_t *pos)
+{
+	printk_parallel_det_usage();
+	return 0;
+}
+
+static ssize_t aeon_parallel_det_write_proc(struct file *file, const char __user *buffer,
+					    size_t count, loff_t *pos)
+{
+	struct phy_device *phydev = file->private_data;
+	char val_string[MAX_BUF] = { 0 };
+	struct parsed_cmd cmdinfo = { 0 };
+
+	if (count >= sizeof(val_string))
+		return -EINVAL;
+
+	if (copy_from_user(val_string, buffer, count))
+		return -EFAULT;
+
+	val_string[count] = '\0';
+
+	if (parse_cmd_args(val_string, &cmdinfo, 1) != 0)
+		return -EINVAL;
+
+	if (!strcmp(cmdinfo.cmd, "paradet")) {
+		if (cmdinfo.argc != 1)
+			return -EINVAL;
+
+		aeon_parallel_det(cmdinfo.args[0], phydev);
+		pr_info("Set parallel detection successfully!\n");
+	} else
+		printk_parallel_det_usage();
+
+	return count;
+}
+
+static ssize_t aeon_force_mdi_mode_read_proc(struct file *file, char __user *buffer,
+					     size_t count, loff_t *pos)
+{
+	printk_force_mdi_mode_usage();
+
+	return 0;
+}
+
+static ssize_t aeon_force_mdi_mode_write_proc(struct file *file, const char __user *buffer,
+					      size_t count, loff_t *pos)
+{
+	struct phy_device *phydev = file->private_data;
+	char val_string[MAX_BUF] = { 0 };
+	struct parsed_cmd cmdinfo = { 0 };
+
+	if (count >= sizeof(val_string))
+		return -EINVAL;
+
+	if (copy_from_user(val_string, buffer, count))
+		return -EFAULT;
+
+	val_string[count] = '\0';
+
+	if (parse_cmd_args(val_string, &cmdinfo, 1) != 0)
+		return -EINVAL;
+
+	if (!strcmp(cmdinfo.cmd, "mdi")) {
+		if (cmdinfo.argc != 1)
+			return -EINVAL;
+
+		aeon_ipc_sync_parity(phydev);
+		if (cmdinfo.args[0] == 1)
+			aeon_set_man_mdi(phydev);
+		else if (cmdinfo.args[0] == 0)
+			aeon_set_man_mdix(phydev);
+		else
+			return -EINVAL;
+
+		pr_info("Force mdi/mdix mode successfully!\n");
+	} else
+		printk_force_mdi_mode_usage();
+
+	return count;
+}
+
+static ssize_t aeon_synce_master_mode_proc(struct file *file, char __user *buffer,
+					   size_t count, loff_t *pos)
+{
+	printk_synce_master_mode_usage();
+
+	return 0;
+}
+
+static ssize_t aeon_synce_master_mode_write_proc(struct file *file, const char __user *buffer,
+						 size_t count, loff_t *pos)
+{
+	struct phy_device *phydev = file->private_data;
+	char val_string[MAX_BUF] = { 0 };
+	struct parsed_cmd cmdinfo = { 0 };
+
+	if (count >= sizeof(val_string))
+		return -EINVAL;
+
+	if (copy_from_user(val_string, buffer, count))
+		return -EFAULT;
+
+	val_string[count] = '\0';
+
+	if (parse_cmd_args(val_string, &cmdinfo, 2) != 0)
+		return -EINVAL;
+
+	if (!strcmp(cmdinfo.cmd, "synce_master_mode")) {
+		if (cmdinfo.argc != 2)
+			return -EINVAL;
+
+		if ((cmdinfo.args[0] < 0) || (cmdinfo.args[0] > 1)) {
+			pr_info("Set synce enable fail, enable value is from 0 to 1!\n");
+			return -EFAULT;
+		}
+
+		if ((cmdinfo.args[1] < 1) || (cmdinfo.args[1] > 4)) {
+			pr_info("Set user bw fail, enable value is from 1 to 4!\n");
+			return -EFAULT;
+		}
+
+		aeon_ipc_sync_parity(phydev);
+		aeon_synce_mode_cfg(1, phydev);
+		aeon_synce_user_bw(cmdinfo.args[1], phydev);
+		aeon_synce_enable_cfg(cmdinfo.args[0], phydev);
+		pr_info("Set synce master mode successfully!\n");
+	} else
+		printk_synce_master_mode_usage();
+
+	return count;
+}
+
+static ssize_t aeon_synce_slave_mode1_proc(struct file *file, char __user *buffer,
+					   size_t count, loff_t *pos)
+{
+	printk_synce_slave_mode1_usage();
+
+	return 0;
+}
+
+static ssize_t aeon_synce_slave_mode1_write_proc(struct file *file, const char __user *buffer,
+						 size_t count, loff_t *pos)
+{
+	struct phy_device *phydev = file->private_data;
+	char val_string[MAX_BUF] = { 0 };
+	struct parsed_cmd cmdinfo = { 0 };
+
+	if (count >= sizeof(val_string))
+		return -EINVAL;
+
+	if (copy_from_user(val_string, buffer, count))
+		return -EFAULT;
+
+	val_string[count] = '\0';
+
+	if (parse_cmd_args(val_string, &cmdinfo, 2) != 0)
+		return -EINVAL;
+
+	if (!strcmp(cmdinfo.cmd, "synce_slave_mode1")) {
+		if (cmdinfo.argc != 2)
+			return -EINVAL;
+
+		if ((cmdinfo.args[0] < 0) || (cmdinfo.args[0] > 1)) {
+			pr_info("Set synce enable fail, enable value is from 0 to 1!\n");
+			return -EFAULT;
+		}
+
+		if ((cmdinfo.args[1] < 0) || (cmdinfo.args[1] > 4)) {
+			pr_info("Set synce output pin fail, enable value is from 0 to 4!\n");
+			return -EFAULT;
+		}
+
+		aeon_ipc_sync_parity(phydev);
+		aeon_synce_mode_cfg(0, phydev);
+		aeon_synce_user_bw(0, phydev);
+		aeon_synce_slave_output_ctrl_cfg(cmdinfo.args[1], phydev);
+		aeon_synce_enable_cfg(cmdinfo.args[0], phydev);
+		pr_info("Set synce slave mode1 successfully!\n");
+	} else
+		printk_synce_slave_mode1_usage();
+
+	return count;
+}
+
+static ssize_t aeon_synce_slave_mode2_read_proc(struct file *file, char __user *buffer,
+						size_t count, loff_t *pos)
+{
+	printk_synce_slave_mode2_usage();
+
+	return 0;
+}
+
+static ssize_t aeon_synce_slave_mode2_write_proc(struct file *file, const char __user *buffer,
+						 size_t count, loff_t *pos)
+{
+	struct phy_device *phydev = file->private_data;
+	char val_string[MAX_BUF] = { 0 };
+	struct parsed_cmd cmdinfo = { 0 };
+
+	if (count >= sizeof(val_string))
+		return -EINVAL;
+
+	if (copy_from_user(val_string, buffer, count))
+		return -EFAULT;
+
+	val_string[count] = '\0';
+
+	if (parse_cmd_args(val_string, &cmdinfo, 3) != 0)
+		return -EINVAL;
+
+	if (!strcmp(cmdinfo.cmd, "synce_slave_mode2")) {
+		if (cmdinfo.argc != 3)
+			return -EINVAL;
+
+		if ((cmdinfo.args[0] < 0) || (cmdinfo.args[0] > 1)) {
+			pr_info("Set synce enable fail, enable value is from 0 to 1!\n");
+			return -EFAULT;
+		}
+
+		if ((cmdinfo.args[1] < 0) || ((cmdinfo.args[1] > 6) && (cmdinfo.args[1] != 10))) {
+			pr_info("Set synce bw fail, enable value is from 0 to 6 and 10!\n");
+			return -EFAULT;
+		}
+
+		if ((cmdinfo.args[2] < 0) || (cmdinfo.args[2] > 1)) {
+			pr_info("Set synce output pin fail, enable value is from 0 to 1!\n");
+			return -EFAULT;
+		}
+
+		aeon_ipc_sync_parity(phydev);
+		aeon_synce_mode_cfg(2, phydev);
+		aeon_synce_user_bw(cmdinfo.args[1], phydev);
+		aeon_synce_slave_output_ctrl_cfg(cmdinfo.args[2], phydev);
+		aeon_synce_enable_cfg(cmdinfo.args[0], phydev);
+		pr_info("Set synce slave mode2 successfully!\n");
+	} else
+		printk_synce_slave_mode2_usage();
+
+	return count;
+}
+
+static ssize_t aeon_read_log_read_proc(struct file *file, char __user *buffer,
+				       size_t count, loff_t *pos)
+{
+	printk_phylog_usage();
+
+	return 0;
+}
+
+static ssize_t aeon_read_log_write_proc(struct file *file, const char __user *buffer,
+					size_t count, loff_t *pos)
+{
+	struct phy_device *phydev = file->private_data;
+	unsigned short log_size = 0, buf_size = 0, wptr = 0,  i = 0;
+	char *log_raw = NULL;
+	char val_string[MAX_BUF] = {0};
+	struct parsed_cmd cmdinfo = {0};
+
+	if (count >= sizeof(val_string))
+		return -EINVAL;
+
+	if (copy_from_user(val_string, buffer, count))
+		return -EFAULT;
+
+	val_string[count] = '\0';
+
+	if (parse_cmd_args(val_string, &cmdinfo, 1) != 0)
+		return -EINVAL;
+
+	if (!strcmp(cmdinfo.cmd, "readlog")) {
+		aeon_ipc_sync_parity(phydev);
+		aeon_ipc_log_size(&log_size, phydev);
+		pr_info("AEON console log, available: %u bytes\n", log_size);
+
+		log_raw = kcalloc(log_size + 1, 1, GFP_KERNEL);
+		if (!log_raw)
+			return -EINVAL;
+
+		while (log_size > wptr) {
+			buf_size = log_size - wptr;
+			if (buf_size > IPC_PAYLOAD_SIZE)
+				buf_size = IPC_PAYLOAD_SIZE;
+
+			aeon_ipc_read_log(buf_size, wptr, log_raw, phydev);
+			wptr += buf_size;
+		}
+
+		log_raw[log_size] = '\0';
+
+		for (i = 0; i < (log_size + 1); i++)
+			pr_info("%c", log_raw[i]);
+
+		pr_info("aeon_read_log_end\r\n");
+
+		kfree(log_raw);
+	} else if (!strcmp(cmdinfo.cmd, "cleanlog")) {
+		aeon_ipc_sync_parity(phydev);
+		aeon_ipc_log_clean(phydev);
+		pr_info("clean aeon log successfully\r\n");
+	} else
+		printk_phylog_usage();
+
+	return count;
+}
+
+static ssize_t aeon_enable_an_read_proc(struct file *file, char __user *buffer,
+					size_t count, loff_t *pos)
+{
+	printk_enable_an_usage();
+
+	return 0;
+}
+
+static ssize_t aeon_enable_an_write_proc(struct file *file, const char __user *buffer,
+					 size_t count, loff_t *pos)
+{
+	struct phy_device *phydev = file->private_data;
+	char val_string[MAX_BUF] = {0};
+	struct parsed_cmd cmdinfo = {0};
+
+	if (count >= sizeof(val_string))
+		return -EINVAL;
+
+	if (copy_from_user(val_string, buffer, count))
+		return -EFAULT;
+
+	val_string[count] = '\0';
+
+	if (parse_cmd_args(val_string, &cmdinfo, 1) != 0)
+		return -EINVAL;
+
+	if (!strcmp(cmdinfo.cmd, "enableAN")) {
+		if (cmdinfo.argc != 1)
+			return -EINVAL;
+
+		aeon_ipc_sync_parity(phydev);
+		aeon_cu_an_enable(cmdinfo.args[0], phydev);
+		pr_info("Enable/Disable AN successfully!\n");
+	} else
+		printk_enable_an_usage();
+
+	return count;
+}
+
+/******************************************************************************
+ * Register debugfs Read/Write Func
+ *****************************************************************************/
+#ifndef AEON_SEI2
+static const struct file_operations aeon_mdc_timing_fops = {
+	.owner = THIS_MODULE,
+	.open = simple_open,
+	.read = aeon_mdc_timing_read_proc,
+	.write = aeon_mdc_timing_write_proc,
+};
+
+static const struct file_operations aeon_auto_eee_cfg_fops = {
+	.owner = THIS_MODULE,
+	.open = simple_open,
+	.read = aeon_auto_eee_cfg_read_proc,
+	.write = aeon_auto_eee_cfg_write_proc,
+};
+
+static const struct file_operations aeon_pkt_chk_cfg_fops = {
+	.owner = THIS_MODULE,
+	.open = simple_open,
+	.read = aeon_pkt_chk_cfg_read_proc,
+	.write = aeon_pkt_chk_cfg_write_proc,
+};
+
+static const struct file_operations aeon_sds_wait_eth_fops = {
+	.owner = THIS_MODULE,
+	.open = simple_open,
+	.read = aeon_sds_wait_eth_cfg_read_proc,
+	.write = aeon_sds_wait_eth_cfg_write_proc,
+};
+
+static const struct file_operations aeon_sds_restart_an_fops = {
+	.owner = THIS_MODULE,
+	.open = simple_open,
+	.read = aeon_sds_restart_an_read_proc,
+	.write = aeon_sds_restart_an_write_proc,
+};
+
+static const struct file_operations aeon_tx_power_lvl = {
+	.owner = THIS_MODULE,
+	.open = simple_open,
+	.read = aeon_tx_power_lvl_read_proc,
+	.write = aeon_tx_power_lvl_write_proc,
+};
+
+static const struct file_operations aeon_sds2nd_enable_cfg = {
+	.owner = THIS_MODULE,
+	.open = simple_open,
+	.read = aeon_sds2nd_enable_read_proc,
+	.write = aeon_sds2nd_enable_write_proc,
+};
+
+static const struct file_operations aeon_sds2nd_eq = {
+	.owner = THIS_MODULE,
+	.open = simple_open,
+	.read = aeon_sds2nd_eq_read_proc,
+	.write = aeon_sds2nd_eq_write_proc,
+};
+
+static const struct file_operations aeon_sds2nd_mode = {
+	.owner = THIS_MODULE,
+	.open = simple_open,
+	.read = aeon_sds2nd_mode_read_proc,
+	.write = aeon_sds2nd_mode_write_proc,
+};
+
+static const struct file_operations aeon_sds2nd_eye_diagram_data = {
+	.owner = THIS_MODULE,
+	.open = simple_open,
+	.read = aeon_sds2nd_eye_diagram_read_proc,
+	.write = aeon_sds2nd_eye_diagram_write_proc,
+};
+
+static const struct file_operations aeon_normal_retrain = {
+	.owner = THIS_MODULE,
+	.open = simple_open,
+	.read = aeon_normal_retrain_read_proc,
+	.write = aeon_normal_retrain_write_proc,
+};
+
+static const struct file_operations aeon_auto_link = {
+	.owner = THIS_MODULE,
+	.open = simple_open,
+	.read = aeon_auto_link_read_proc,
+	.write = aeon_auto_link_write_proc,
+};
+
+static const struct file_operations aeon_sds_txfir = {
+	.owner = THIS_MODULE,
+	.open = simple_open,
+	.read = aeon_sds_txfir_read_proc,
+	.write = aeon_sds_txfir_write_proc,
+};
+
+static const struct file_operations aeon_ra_mode = {
+	.owner = THIS_MODULE,
+	.open = simple_open,
+	.read = aeon_ra_mode_read_proc,
+	.write = aeon_ra_mode_write_proc,
+};
+
+static const struct file_operations aeon_traffic_loopback = {
+	.owner = THIS_MODULE,
+	.open = simple_open,
+	.read = aeon_traffic_loopback_read_proc,
+	.write = aeon_traffic_loopback_write_proc,
+};
+
+static const struct file_operations aeon_restart_sds = {
+	.owner = THIS_MODULE,
+	.open = simple_open,
+	.read = aeon_sds_restart_read_proc,
+	.write = aeon_sds_restart_write_proc,
+};
+
+#else
+static const struct file_operations aeon_dpc_fc = {
+	.owner = THIS_MODULE,
+	.open = simple_open,
+	.read = aeon_dpc_fc_read_proc,
+	.write = aeon_dpc_fc_write_proc,
+};
+
+static const struct file_operations aeon_dpc_eee = {
+	.owner = THIS_MODULE,
+	.open = simple_open,
+	.read = aeon_dpc_eee_mode_read_proc,
+	.write = aeon_dpc_eee_mode_write_proc,
+};
+
+static const struct file_operations aeon_dpc_buffer = {
+	.owner = THIS_MODULE,
+	.open = simple_open,
+	.read = aeon_dpc_buffer_mode_read_proc,
+	.write = aeon_dpc_buffer_mode_write_proc,
+};
+
+static const struct file_operations aeon_eee_clk_mode = {
+	.owner = THIS_MODULE,
+	.open = simple_open,
+	.read = aeon_eee_clk_read_proc,
+	.write = aeon_eee_clk_write_proc,
+};
+
+static const struct file_operations aeon_sds_eq_mode = {
+	.owner = THIS_MODULE,
+	.open = simple_open,
+	.read = aeon_sds_eq_read_proc,
+	.write = aeon_sds_eq_write_proc,
+};
+
+static const struct file_operations aeon_i2c_enable = {
+	.owner = THIS_MODULE,
+	.open = simple_open,
+	.read = aeon_i2c_enable_read_proc,
+	.write = aeon_i2c_enable_write_proc,
+};
+
+static const struct file_operations aeon_fifofull_th = {
+	.owner = THIS_MODULE,
+	.open = simple_open,
+	.read = aeon_fifofull_th_read_proc,
+	.write = aeon_fifofull_th_write_proc,
+};
+
+static const struct file_operations aeon_tm5_gain = {
+	.owner = THIS_MODULE,
+	.open = simple_open,
+	.read = aeon_tm5_gain_idx_read_proc,
+	.write = aeon_tm5_gain_idx_write_proc,
+};
+#endif
+
+#ifdef DUAL_FLASH
+static const struct file_operations aeon_burn_flash_image_fops = {
+	.owner = THIS_MODULE,
+	.open = simple_open,
+	.read = aeon_burn_flash_read_proc,
+	.write = aeon_burn_flash_write_proc,
+};
+static const struct file_operations aeon_erase_flash_fops = {
+	.owner = THIS_MODULE,
+	.open = simple_open,
+	.read = aeon_erase_flash_read_proc,
+	.write = aeon_erase_flash_write_proc,
+};
+#endif
+
+static const struct file_operations aeon_set_speed_mode_fops = {
+	.owner = THIS_MODULE,
+	.open = simple_open,
+	.read = aeon_speed_mode_read_proc,
+	.write = aeon_speed_mode_write_proc,
+};
+
+static const struct file_operations aeon_set_mdi_cfg_fops = {
+	.owner = THIS_MODULE,
+	.open = simple_open,
+	.read = aeon_mdi_cfg_read_proc,
+	.write = aeon_mdi_cfg_write_proc,
+};
+
+static const struct file_operations aeon_set_sds_pcs_cfg_fops = {
+	.owner = THIS_MODULE,
+	.open = simple_open,
+	.read = aeon_sds_pcs_cfg_read_proc,
+	.write = aeon_sds_pcs_cfg_write_proc,
+};
+
+static const struct file_operations aeon_set_sds_pma_cfg_fops = {
+	.owner = THIS_MODULE,
+	.open = simple_open,
+	.read = aeon_sds_pma_cfg_read_proc,
+	.write = aeon_sds_pma_cfg_write_proc,
+};
+
+static const struct file_operations aeon_fw_version_fops = {
+	.owner = THIS_MODULE,
+	.open = simple_open,
+	.read = aeon_fw_version_read_proc,
+	.write = aeon_fw_version_write_proc,
+};
+
+static const struct file_operations aeon_restart_an_fops = {
+	.owner = THIS_MODULE,
+	.open = simple_open,
+	.read = aeon_restart_an_read_proc,
+	.write = aeon_restart_an_write_proc,
+};
+
+static const struct file_operations aeon_set_led_fops = {
+	.owner = THIS_MODULE,
+	.open = simple_open,
+	.read = aeon_set_led_read_proc,
+	.write = aeon_set_led_write_proc,
+};
+
+static const struct file_operations aeon_temp_monitor_fops = {
+	.owner = THIS_MODULE,
+	.open = simple_open,
+	.read = aeon_temp_monitor_read_proc,
+	.write = aeon_temp_monitor_write_proc,
+};
+
+static const struct file_operations aeon_set_sys_reboot_fops = {
+	.owner = THIS_MODULE,
+	.open = simple_open,
+	.read = aeon_sys_reboot_read_proc,
+	.write = aeon_sys_reboot_write_proc,
+};
+
+static const struct file_operations aeon_read_reg_fops = {
+	.owner = THIS_MODULE,
+	.open = simple_open,
+	.read = aeon_read_reg_read_proc,
+	.write = aeon_read_reg_write_proc,
+};
+
+static const struct file_operations aeon_write_reg_fops = {
+	.owner = THIS_MODULE,
+	.open = simple_open,
+	.read = aeon_write_reg_read_proc,
+	.write = aeon_write_reg_write_proc,
+};
+
+static const struct file_operations aeon_get_eth_status_fops = {
+	.owner = THIS_MODULE,
+	.open = simple_open,
+	.read = aeon_eth_status_read_proc,
+	.write = aeon_eth_status_write_proc,
+};
+
+static const struct file_operations aeon_phy_enable_fops = {
+	.owner = THIS_MODULE,
+	.open = simple_open,
+	.read = aeon_phy_enable_read_proc,
+	.write = aeon_phy_enable_write_proc,
+};
+
+static const struct file_operations aeon_test_mode_fops = {
+	.owner = THIS_MODULE,
+	.open = simple_open,
+	.read = aeon_test_mode_read_proc,
+	.write = aeon_test_mode_write_proc,
+};
+
+static const struct file_operations aeon_tx_fullscale_fops = {
+	.owner = THIS_MODULE,
+	.open = simple_open,
+	.read = aeon_tx_fullscale_read_proc,
+	.write = aeon_tx_fullscale_write_proc,
+};
+
+static const struct file_operations aeon_wol_ctrl = {
+	.owner = THIS_MODULE,
+	.open = simple_open,
+	.read = aeon_wol_ctrl_read_proc,
+	.write = aeon_wol_ctrl_write_proc,
+};
+
+static const struct file_operations aeon_smi_command = {
+	.owner = THIS_MODULE,
+	.open = simple_open,
+	.read = aeon_smi_command_read_proc,
+	.write = aeon_smi_command_write_proc,
+};
+
+static const struct file_operations aeon_setirq_en = {
+	.owner = THIS_MODULE,
+	.open = simple_open,
+	.read = aeon_set_irq_en_read_proc,
+	.write = aeon_set_irq_en_write_proc,
+};
+
+static const struct file_operations aeon_setirq_clr = {
+	.owner = THIS_MODULE,
+	.open = simple_open,
+	.read = aeon_set_irq_clr_read_proc,
+	.write = aeon_set_irq_clr_write_proc,
+};
+
+static const struct file_operations aeon_query_irq = {
+	.owner = THIS_MODULE,
+	.open = simple_open,
+	.read = aeon_query_irq_read_proc,
+	.write = aeon_query_irq_write_proc,
+};
+
+static const struct file_operations aeon_cable_diag = {
+	.owner = THIS_MODULE,
+	.open = simple_open,
+	.read = aeon_cable_diag_read_proc,
+	.write = aeon_cable_diag_write_proc,
+};
+
+static const struct file_operations aeon_eye_diagram_data = {
+	.owner = THIS_MODULE,
+	.open = simple_open,
+	.read = aeon_eye_diagram_read_proc,
+	.write = aeon_eye_diagram_write_proc,
+};
+
+static const struct file_operations aeon_force_mode = {
+	.owner = THIS_MODULE,
+	.open = simple_open,
+	.read = aeon_force_mode_read_proc,
+	.write = aeon_force_mode_write_proc,
+};
+
+static const struct file_operations aeon_parallel_det_cfg = {
+	.owner = THIS_MODULE,
+	.open = simple_open,
+	.read = aeon_parallel_det_read_proc,
+	.write = aeon_parallel_det_write_proc,
+};
+
+static const struct file_operations aeon_force_mdi_mode = {
+	.owner = THIS_MODULE,
+	.open = simple_open,
+	.read = aeon_force_mdi_mode_read_proc,
+	.write = aeon_force_mdi_mode_write_proc,
+};
+
+static const struct file_operations aeon_synce_master = {
+	.owner = THIS_MODULE,
+	.open = simple_open,
+	.read = aeon_synce_master_mode_proc,
+	.write = aeon_synce_master_mode_write_proc,
+};
+
+static const struct file_operations aeon_synce_slave_mode1 = {
+	.owner = THIS_MODULE,
+	.open = simple_open,
+	.read = aeon_synce_slave_mode1_proc,
+	.write = aeon_synce_slave_mode1_write_proc,
+};
+
+static const struct file_operations aeon_synce_slave_mode2 = {
+	.owner = THIS_MODULE,
+	.open = simple_open,
+	.read = aeon_synce_slave_mode2_read_proc,
+	.write = aeon_synce_slave_mode2_write_proc,
+};
+
+static const struct file_operations aeon_read_log = {
+	.owner = THIS_MODULE,
+	.open = simple_open,
+	.read = aeon_read_log_read_proc,
+	.write = aeon_read_log_write_proc,
+};
+
+static const struct file_operations aeon_enable_an = {
+	.owner = THIS_MODULE,
+	.open = simple_open,
+	.read = aeon_enable_an_read_proc,
+	.write = aeon_enable_an_write_proc,
+};
+
+static const struct file_operations aeon_dbg_dump = {
+	.owner = THIS_MODULE,
+	.open = simple_open,
+	.read = aeon_dbg_dump_read_proc,
+	.write = aeon_dbg_dump_write_proc,
+};
+
+int as21xxx_debugfs_init(struct phy_device *phydev)
+{
+	struct as21xxx_priv *priv = phydev->priv;
+	struct an_mdi_cfg *__priv_data = &priv->mdi_cfg;
+	struct dentry *dir = priv->debugfs_root;
+	int ret = 0;
+
+	if (!phydev) {
+		phydev_err(phydev, "%s:phydevice is NULL\n", __func__);
+		return -EINVAL;
+	}
+
+	dir = debugfs_create_dir(dev_name(&phydev->mdio.dev), NULL);
+	if (!dir) {
+		phydev_err(phydev, "%s:err at %d\n", __func__, __LINE__);
+		ret = -ENOMEM;
+	}
+
+	// init the data structure
+	__priv_data->top_spd = 0xF;
+	__priv_data->eee_spd = 0xFF;
+	__priv_data->fr_spd = 0xF;
+	__priv_data->thp_byp = 0xF;
+	__priv_data->port_type = 0xF;
+	__priv_data->ms_en = 0xF;
+	__priv_data->ms_config = 0xF;
+	__priv_data->nstd_pbo = 0xFF;
+	__priv_data->smt_spd.enable = 0xF;
+	__priv_data->smt_spd.retry_limit = 0xF;
+	__priv_data->trd_ovrd = 0xF;
+	__priv_data->trd_swap = 0xF;
+	__priv_data->cfr = 0xF;
+
+	debugfs_create_file("aeon_set_speed_mode", 0644, dir, phydev,
+			    &aeon_set_speed_mode_fops);
+	debugfs_create_file("aeon_set_mdi_cfg", 0644, dir, phydev,
+			    &aeon_set_mdi_cfg_fops);
+	debugfs_create_file("aeon_set_sds_pcs_cfg", 0644, dir, phydev,
+			    &aeon_set_sds_pcs_cfg_fops);
+	debugfs_create_file("aeon_set_sds_pma_cfg", 0644, dir, phydev,
+			    &aeon_set_sds_pma_cfg_fops);
+	debugfs_create_file("aeon_fw_version", 0644, dir, phydev,
+			    &aeon_fw_version_fops);
+	debugfs_create_file("aeon_restart_an", 0644, dir, phydev,
+			    &aeon_restart_an_fops);
+	debugfs_create_file("aeon_set_led", 0644, dir, phydev,
+			    &aeon_set_led_fops);
+	debugfs_create_file("aeon_temp_monitor", 0644, dir, phydev,
+			    &aeon_temp_monitor_fops);
+	debugfs_create_file("aeon_set_sys_reboot", 0644, dir, phydev,
+			    &aeon_set_sys_reboot_fops);
+#ifndef AEON_SEI2
+	debugfs_create_file("aeon_mdc_timing", 0644, dir, phydev,
+			    &aeon_mdc_timing_fops);
+	debugfs_create_file("aeon_auto_eee_cfg", 0644, dir, phydev,
+			    &aeon_auto_eee_cfg_fops);
+	debugfs_create_file("aeon_pkt_chk_cfg", 0644, dir, phydev,
+			    &aeon_pkt_chk_cfg_fops);
+	debugfs_create_file("aeon_sds_wait_eth", 0644, dir, phydev,
+			    &aeon_sds_wait_eth_fops);
+	debugfs_create_file("aeon_sds_restart_an", 0644, dir, phydev,
+			    &aeon_sds_restart_an_fops);
+	debugfs_create_file("aeon_tx_power_lvl", 0644, dir, phydev,
+			    &aeon_tx_power_lvl);
+	debugfs_create_file("aeon_sds2nd_eye_diagram_data", 0644, dir, phydev,
+			    &aeon_sds2nd_eye_diagram_data);
+	debugfs_create_file("aeon_sds2nd_enable", 0644, dir, phydev,
+				&aeon_sds2nd_enable_cfg);
+	debugfs_create_file("aeon_sds2nd_eq_cfg", 0644, dir, phydev,
+			    &aeon_sds2nd_eq);
+	debugfs_create_file("aeon_sds2nd_mode_cfg", 0644, dir, phydev,
+			    &aeon_sds2nd_mode);
+	debugfs_create_file("aeon_normal_retrain", 0644, dir, phydev,
+			    &aeon_normal_retrain);
+	debugfs_create_file("aeon_auto_link", 0644, dir, phydev,
+			    &aeon_auto_link);
+	debugfs_create_file("aeon_sds_txfir", 0644, dir, phydev,
+			    &aeon_sds_txfir);
+	debugfs_create_file("aeon_ra_mode", 0644, dir, phydev,
+			    &aeon_ra_mode);
+	debugfs_create_file("aeon_traffic_loopback", 0644, dir, phydev,
+			    &aeon_traffic_loopback);
+	debugfs_create_file("aeon_sds_restart", 0644, dir, phydev,
+			    &aeon_restart_sds);
+#else
+	debugfs_create_file("aeon_dpc_fc", 0644, dir, phydev,
+			    &aeon_dpc_fc);
+	debugfs_create_file("aeon_eee_mode", 0644, dir, phydev,
+			    &aeon_dpc_eee);
+	debugfs_create_file("aeon_buffer_mode", 0644, dir, phydev,
+			    &aeon_dpc_buffer);
+	debugfs_create_file("aeon_eee_clk", 0644, dir, phydev,
+			    &aeon_eee_clk_mode);
+	debugfs_create_file("aeon_sds_eq", 0644, dir, phydev,
+			    &aeon_sds_eq_mode);
+	debugfs_create_file("aeon_i2c_enable", 0644, dir, phydev,
+			    &aeon_i2c_enable);
+	debugfs_create_file("aeon_fifofull_th", 0644, dir, phydev,
+			    &aeon_fifofull_th);
+	debugfs_create_file("aeon_tm5_gain", 0644, dir, phydev,
+			    &aeon_tm5_gain);
+#endif
+	debugfs_create_file("aeon_read_reg", 0644, dir, phydev,
+			    &aeon_read_reg_fops);
+	debugfs_create_file("aeon_write_reg", 0644, dir, phydev,
+			    &aeon_write_reg_fops);
+	debugfs_create_file("aeon_get_eth_status", 0644, dir, phydev,
+			    &aeon_get_eth_status_fops);
+	debugfs_create_file("aeon_phy_enable", 0644, dir, phydev,
+			    &aeon_phy_enable_fops);
+#ifdef DUAL_FLASH
+	debugfs_create_file("aeon_burn_flash_image", 0644, dir, phydev,
+			    &aeon_burn_flash_image_fops);
+	debugfs_create_file("aeon_erase_flash", 0644, dir, phydev,
+			    &aeon_erase_flash_fops);
+#endif
+	debugfs_create_file("aeon_test_mode", 0644, dir, phydev,
+			    &aeon_test_mode_fops);
+	debugfs_create_file("aeon_tx_fullscale", 0644, dir, phydev,
+			    &aeon_tx_fullscale_fops);
+	debugfs_create_file("aeon_wol_ctrl", 0644, dir, phydev,
+			    &aeon_wol_ctrl);
+	debugfs_create_file("aeon_smi_command", 0644, dir, phydev,
+			    &aeon_smi_command);
+	debugfs_create_file("aeon_setirq_en", 0644, dir, phydev,
+			    &aeon_setirq_en);
+	debugfs_create_file("aeon_setirq_clr", 0644, dir, phydev,
+			    &aeon_setirq_clr);
+	debugfs_create_file("aeon_query_irq", 0644, dir, phydev,
+			    &aeon_query_irq);
+	debugfs_create_file("aeon_cable_diag", 0644, dir, phydev,
+			    &aeon_cable_diag);
+	debugfs_create_file("aeon_eye_diagram_data", 0644, dir, phydev,
+			    &aeon_eye_diagram_data);
+	debugfs_create_file("aeon_force_mode", 0644, dir, phydev,
+			    &aeon_force_mode);
+	debugfs_create_file("aeon_parallel_det", 0644, dir, phydev,
+			    &aeon_parallel_det_cfg);
+	debugfs_create_file("aeon_force_mdi_mode", 0644, dir, phydev,
+			    &aeon_force_mdi_mode);
+	debugfs_create_file("aeon_synce_master", 0644, dir, phydev,
+			    &aeon_synce_master);
+	debugfs_create_file("aeon_synce_slave_mode1", 0644, dir, phydev,
+			    &aeon_synce_slave_mode1);
+	debugfs_create_file("aeon_synce_slave_mode2", 0644, dir, phydev,
+			    &aeon_synce_slave_mode2);
+	debugfs_create_file("aeon_read_log", 0644, dir, phydev,
+			    &aeon_read_log);
+	debugfs_create_file("aeon_enable_an", 0644, dir, phydev,
+			    &aeon_enable_an);
+	debugfs_create_file("aeon_dbg_dump", 0644, dir, phydev,
+			    &aeon_dbg_dump);
+
+	priv->debugfs_root = dir;
+
+	return ret;
+}
+
+void as21xxx_debugfs_remove(struct phy_device *phydev)
+{
+	struct as21xxx_priv *priv = phydev->priv;
+
+	debugfs_remove_recursive(priv->debugfs_root);
+	priv->debugfs_root = NULL;
+}
diff --git a/drivers/net/phy/as21xx_bbu_api/as21xx_debugfs.h b/drivers/net/phy/as21xx_bbu_api/as21xx_debugfs.h
new file mode 100644
index 0000000..f11d6e2
--- /dev/null
+++ b/drivers/net/phy/as21xx_bbu_api/as21xx_debugfs.h
@@ -0,0 +1,45 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/******************************************************************************
+ *
+ * AEONSEMI CONFIDENTIAL
+ * _____________________
+ *
+ * Aeonsemi Inc., 2023
+ * All Rights Reserved.
+ *
+ * NOTICE:  All information contained herein is, and remains the property of
+ * Aeonsemi Inc. and its subsidiaries, if any. The intellectual and technical
+ * concepts contained herein are proprietary to Aeonsemi Inc. and its
+ * subsidiaries and may be covered by U.S. and Foreign Patents, patents in
+ * process, and are protected by trade secret or copyright law. Dissemination
+ * of this information or reproduction of this material is strictly forbidden
+ * unless prior written permission is obtained from Aeonsemi Inc.
+ *
+ *
+ *****************************************************************************/
+#ifndef _AS21XX_PROC_H_
+#define _AS21XX_PROC_H_
+
+/******************************************************************************
+ * MISC Macros
+ *****************************************************************************/
+#define MAX_BUF     64
+#define MAX_CMD_LEN 32
+#define MAX_ARGS    10
+
+#define CHAN_NUM 4
+#define AS21XX_PHY_NUM 2
+
+/******************************************************************************
+ * Common Structure
+ *****************************************************************************/
+struct parsed_cmd {
+	char cmd[MAX_CMD_LEN];
+	long args[MAX_ARGS];
+	int argc;
+};
+
+int as21xxx_debugfs_init(struct phy_device *phydev);
+void as21xxx_debugfs_remove(struct phy_device *phydev);
+
+#endif
diff --git a/drivers/net/phy/as21xxx.c b/drivers/net/phy/as21xxx.c
index 0052773..2b2a96f 100644
--- a/drivers/net/phy/as21xxx.c
+++ b/drivers/net/phy/as21xxx.c
@@ -10,6 +10,7 @@
 #include <linux/module.h>
 #include <linux/of.h>
 #include <linux/phy.h>
+#include "as21xxx.h"
 
 #define VEND1_GLB_REG_CPU_RESET_ADDR_LO_BASEADDR 0x3
 #define VEND1_GLB_REG_CPU_RESET_ADDR_HI_BASEADDR 0x4
@@ -21,10 +22,13 @@
 							 BIT(_n))
 
 #define VEND1_FW_START_ADDR		0x100
+#define AN_STATES1_ADDR	0x8005
+#define AN_STATES1_ARB_MASK	0xF000
+#define AN_STATES1_ARB_OFST	12
+#define LINK_GOOD 9
 
 #define VEND1_GLB_REG_MDIO_INDIRECT_ADDRCMD 0x101
 #define VEND1_GLB_REG_MDIO_INDIRECT_LOAD 0x102
-
 #define VEND1_GLB_REG_MDIO_INDIRECT_STATUS 0x103
 
 #define VEND1_PTP_CLK			0x142
@@ -112,12 +116,195 @@
 #define IPC_CFG_PARAM_DIRECT_TEMP_MON	0x11
 #define IPC_CFG_PARAM_DIRECT_WOL	0x12
 
+/* IPC_CFG_PARAM_DIRECT_CU_AN sub command */
+#define IPC_CMD_CFG_CU_AN_RESTART	0xa
+#define IPC_CMD_CFG_CU_AN_TOP_SPD	0xc
+
 /* Sub command of CMD_TEMP_MON */
 #define IPC_CMD_TEMP_MON_GET		0x4
-
 #define AS21XXX_MDIO_AN_C22		0xffe0
+#define AEON_MEM_DEFAULT_ADDR (0x300100 >> 1)
+#define MEM_WORD_SIZE 4
+#define MAX_WDATA_SIZE 16
+#define PHY_MAX_ADDR 32
+#define MDI_CFG_SPD_T10 0x2
+#define MDI_CFG_SPD_T100 0x4
+#define MDI_CFG_SPD_T1G 0x8
+#define MDI_CFG_SPD_T2P5G 0x10
+#define MDI_CFG_SPD_T5G 0x20
+#define MDI_CFG_SPD_T10G 0x40
+
+static int param1 = 1;
+module_param(param1, int, 0444);
+MODULE_PARM_DESC(param1, "First parameter");
+
+#define LED_NUM 5
+#define LED_PARAM 7
+
+#define LED_BLINK_RATE_15_625Hz 0x1
+#define LED_BLINK_RATE_7_8125Hz 0x2
+#define LED_BLINK_RATE_3_9063Hz 0x3
+#define LED_BLINK_RATE_1_9531Hz 0x4
+#define LED_BLINK_RATE_0_97656Hz 0x5
+#define LED_BLINK_RATE_0_48828Hz 0x6
+
+enum as21xxx_driver_event {
+	LED_MODE_OFF = 0x0,
+	LED_ON_NG_BLINK_ACT,
+	LED_ON_FE_GE_BLINK_ACT,
+	LED_LINK_EST,
+	LED_TX_RX_ACT,
+	LED_LINK_EST_BLINK_ACT,
+	LED_ON_NG_BLINK_FE_GE,
+	LED_ON_FE_GE,
+	LED_ON_NG,
+	LED_ON_FD,
+	LED_ON_COLL,
+	LED_TX_ACT,
+	LED_RX_ACT,
+	LED_ON_2P5G,
+	LED_ON_1000BT,
+	LED_ON_5G,
+	LED_LINK_EST_BLINK_RX,
+	LED_ON_100TX,
+	LED_ON_10BT,
+	LED_ON_10G,
+	LED_ON_FD_BLINK_COLL,
+	LED_MODE_ON,
+};
+
+#define LED_POLARITY_OFF 0x0
+
+enum as21xxx_led_event {
+	VEND1_LED_REG_A_EVENT_ON_10 = 0x0,
+	VEND1_LED_REG_A_EVENT_ON_100,
+	VEND1_LED_REG_A_EVENT_ON_1000,
+	VEND1_LED_REG_A_EVENT_ON_2500,
+	VEND1_LED_REG_A_EVENT_ON_5000,
+	VEND1_LED_REG_A_EVENT_ON_10000,
+	VEND1_LED_REG_A_EVENT_ON_FE_GE,
+	VEND1_LED_REG_A_EVENT_ON_NG,
+	VEND1_LED_REG_A_EVENT_ON_FULL_DUPLEX,
+	VEND1_LED_REG_A_EVENT_ON_COLLISION,
+	VEND1_LED_REG_A_EVENT_BLINK_TX,
+	VEND1_LED_REG_A_EVENT_BLINK_RX,
+	VEND1_LED_REG_A_EVENT_BLINK_ACT,
+	VEND1_LED_REG_A_EVENT_ON_LINK,
+	VEND1_LED_REG_A_EVENT_ON_LINK_BLINK_ACT,
+	VEND1_LED_REG_A_EVENT_ON_LINK_BLINK_RX,
+	VEND1_LED_REG_A_EVENT_ON_FE_GE_BLINK_ACT,
+	VEND1_LED_REG_A_EVENT_ON_NG_BLINK_ACT,
+	VEND1_LED_REG_A_EVENT_ON_NG_BLINK_FE_GE,
+	VEND1_LED_REG_A_EVENT_ON_FD_BLINK_COLLISION,
+	VEND1_LED_REG_A_EVENT_ON,
+	VEND1_LED_REG_A_EVENT_OFF,
+};
+
+
+struct as21xxx_led_map_info {
+	u16 mode;
+	u16 map;
+};
+
+static struct as21xxx_led_map_info as21xxx_led_map[] = {
+	{
+		.mode = LED_ON_10BT,
+		.map = VEND1_LED_REG_A_EVENT_ON_10
+	},
+	{
+		.mode = LED_ON_100TX,
+		.map = VEND1_LED_REG_A_EVENT_ON_100
+	},
+	{
+		.mode = LED_ON_1000BT,
+		.map = VEND1_LED_REG_A_EVENT_ON_1000
+	},
+	{
+		.mode = LED_ON_2P5G,
+		.map = VEND1_LED_REG_A_EVENT_ON_2500
+	},
+	{
+		.mode = LED_ON_5G,
+		.map = VEND1_LED_REG_A_EVENT_ON_5000
+	},
+	{
+		.mode = LED_ON_10G,
+		.map = VEND1_LED_REG_A_EVENT_ON_10000
+	},
+	{
+		.mode = LED_ON_FE_GE,
+		.map = VEND1_LED_REG_A_EVENT_ON_FE_GE
+	},
+	{
+		.mode = LED_ON_NG,
+		.map = VEND1_LED_REG_A_EVENT_ON_NG
+	},
+	{
+		.mode = LED_ON_FD,
+		.map = VEND1_LED_REG_A_EVENT_ON_FULL_DUPLEX
+	},
+	{
+		.mode = LED_ON_COLL,
+		.map = VEND1_LED_REG_A_EVENT_ON_COLLISION
+	},
+	{
+		.mode = LED_TX_ACT,
+		.map = VEND1_LED_REG_A_EVENT_BLINK_TX
+	},
+	{
+		.mode = LED_RX_ACT,
+		.map = VEND1_LED_REG_A_EVENT_BLINK_RX
+	},
+	{
+		.mode = LED_TX_RX_ACT,
+		.map = VEND1_LED_REG_A_EVENT_BLINK_ACT
+	},
+	{
+		.mode = LED_LINK_EST,
+		.map = VEND1_LED_REG_A_EVENT_ON_LINK
+	},
+	{
+		.mode = LED_LINK_EST_BLINK_ACT,
+		.map = VEND1_LED_REG_A_EVENT_ON_LINK_BLINK_ACT
+	},
+	{
+		.mode = LED_LINK_EST_BLINK_RX,
+		.map = VEND1_LED_REG_A_EVENT_ON_LINK_BLINK_RX
+	},
+	{
+		.mode = LED_ON_FE_GE_BLINK_ACT,
+		.map = VEND1_LED_REG_A_EVENT_ON_FE_GE_BLINK_ACT
+	},
+	{
+		.mode = LED_ON_NG_BLINK_ACT,
+		.map = VEND1_LED_REG_A_EVENT_ON_NG_BLINK_ACT
+	},
+	{
+		.mode = LED_ON_NG_BLINK_FE_GE,
+		.map = VEND1_LED_REG_A_EVENT_ON_NG_BLINK_FE_GE
+	},
+	{
+		.mode = LED_ON_FD_BLINK_COLL,
+		.map = VEND1_LED_REG_A_EVENT_ON_FD_BLINK_COLLISION
+	},
+	{
+		.mode = LED_MODE_ON,
+		.map = VEND1_LED_REG_A_EVENT_ON
+	},
+	{
+		.mode = LED_MODE_OFF,
+		.map = VEND1_LED_REG_A_EVENT_OFF
+	},
+	{
+		.mode = LED_ON_NG_BLINK_ACT,
+		.map = VEND1_LED_REG_A_EVENT_BLINK_RX
+	},
+};
+
+u16 custome_cfg[LED_PARAM] = {LED_ON_NG_BLINK_ACT, LED_ON_FE_GE_BLINK_ACT, LED_LINK_EST,
+	LED_TX_RX_ACT, LED_LINK_EST_BLINK_ACT, LED_POLARITY_OFF, LED_BLINK_RATE_3_9063Hz};
+EXPORT_SYMBOL(custome_cfg);
 
-#define PHY_ID_AS21XXX			0x75009410
 /* AS21xxx ID Legend
  * AS21x1xxB1
  *     ^ ^^
@@ -140,41 +327,24 @@
 #define PHY_ID_AS21210JB1		0x75009482
 #define PHY_ID_AS21210PB1		0x75009492
 #define PHY_VENDOR_AEONSEMI		0x75009400
-
+#define PHY_ID_AS21XXX			0x75009410
+#define PHY_ID_AS22XXX			0x750094a0
 #define AEON_MAX_LEDS			5
 #define AEON_IPC_DELAY			10000
 #define AEON_IPC_TIMEOUT		(AEON_IPC_DELAY * 100)
 #define AEON_IPC_DATA_NUM_REGISTERS	8
 #define AEON_IPC_DATA_MAX		(AEON_IPC_DATA_NUM_REGISTERS * sizeof(u16))
-
 #define AEON_BOOT_ADDR			0x1000
 #define AEON_CPU_BOOT_ADDR		0x2000
 #define AEON_CPU_CTRL_FW_LOAD		(BIT(4) | BIT(2) | BIT(1) | BIT(0))
 #define AEON_CPU_CTRL_FW_START		BIT(0)
 
-enum as21xxx_led_event {
-	VEND1_LED_REG_A_EVENT_ON_10 = 0x0,
-	VEND1_LED_REG_A_EVENT_ON_100,
-	VEND1_LED_REG_A_EVENT_ON_1000,
-	VEND1_LED_REG_A_EVENT_ON_2500,
-	VEND1_LED_REG_A_EVENT_ON_5000,
-	VEND1_LED_REG_A_EVENT_ON_10000,
-	VEND1_LED_REG_A_EVENT_ON_FE_GE,
-	VEND1_LED_REG_A_EVENT_ON_NG,
-	VEND1_LED_REG_A_EVENT_ON_FULL_DUPLEX,
-	VEND1_LED_REG_A_EVENT_ON_COLLISION,
-	VEND1_LED_REG_A_EVENT_BLINK_TX,
-	VEND1_LED_REG_A_EVENT_BLINK_RX,
-	VEND1_LED_REG_A_EVENT_BLINK_ACT,
-	VEND1_LED_REG_A_EVENT_ON_LINK,
-	VEND1_LED_REG_A_EVENT_ON_LINK_BLINK_ACT,
-	VEND1_LED_REG_A_EVENT_ON_LINK_BLINK_RX,
-	VEND1_LED_REG_A_EVENT_ON_FE_GE_BLINK_ACT,
-	VEND1_LED_REG_A_EVENT_ON_NG_BLINK_ACT,
-	VEND1_LED_REG_A_EVENT_ON_NG_BLINK_FE_GE,
-	VEND1_LED_REG_A_EVENT_ON_FD_BLINK_COLLISION,
-	VEND1_LED_REG_A_EVENT_ON,
-	VEND1_LED_REG_A_EVENT_OFF,
+enum as21xxx_led_num {
+	AEON_LED0 = 0,
+	AEON_LED1,
+	AEON_LED2,
+	AEON_LED3,
+	AEON_LED4,
 };
 
 struct as21xxx_led_pattern_info {
@@ -182,12 +352,6 @@ struct as21xxx_led_pattern_info {
 	u16 val;
 };
 
-struct as21xxx_priv {
-	bool parity_status;
-	/* Protect concurrent IPC access */
-	struct mutex ipc_lock;
-};
-
 static struct as21xxx_led_pattern_info as21xxx_led_supported_pattern[] = {
 	{
 		.pattern = BIT(TRIGGER_NETDEV_LINK_10),
@@ -294,6 +458,129 @@ static struct as21xxx_led_pattern_info as21xxx_led_supported_pattern[] = {
 	}
 };
 
+static void aeon_mdio_patch(struct phy_device *phydev)
+{
+	struct device *dev = &phydev->mdio.dev;
+	struct mii_bus *bus = phydev->mdio.bus;
+
+	if (!bus) {
+		dev_err(dev, "MDIO bus is NULL\r\n");
+		return;
+	}
+
+	mutex_lock(&bus->mdio_lock);
+	__mdiobus_c45_write(bus, 30, 0x1, 0x1, 0x1);
+	mutex_unlock(&bus->mdio_lock);
+}
+
+int aeon_cl45_read(struct phy_device *phydev, int dev_addr,
+		   unsigned int phy_reg)
+{
+	int ret = 0;
+	struct mii_bus *bus = phydev->mdio.bus;
+	int phy_addr = phydev->mdio.addr;
+
+	if (!bus) {
+		phydev_err(phydev, "MDIO bus is NULL\r\n");
+		return -ENODEV;
+	}
+
+	if (phy_addr >= PHY_MAX_ADDR) {
+		phydev_err(phydev, "Invaild PHY address: %d", phy_addr);
+		return -EINVAL;
+	}
+
+	mutex_lock(&bus->mdio_lock);
+	ret = __mdiobus_c45_read(bus, phy_addr, dev_addr, phy_reg);
+	mutex_unlock(&bus->mdio_lock);
+	aeon_mdio_patch(phydev);
+
+	return ret;
+}
+EXPORT_SYMBOL(aeon_cl45_read);
+
+void aeon_cl45_write(struct phy_device *phydev, int dev_addr,
+		     unsigned int phy_reg, unsigned short phy_data)
+{
+	struct mii_bus *bus = phydev->mdio.bus;
+	int phy_addr = phydev->mdio.addr;
+
+	if (!bus) {
+		phydev_err(phydev, "MDIO bus is NULL\r\n");
+		return;
+	}
+
+	if (phy_addr >= PHY_MAX_ADDR) {
+		phydev_err(phydev, "Invaild PHY address: %d", phy_addr);
+		return;
+	}
+
+	mutex_lock(&bus->mdio_lock);
+	__mdiobus_c45_write(bus, phy_addr, dev_addr, phy_reg, phy_data);
+	mutex_unlock(&bus->mdio_lock);
+	aeon_mdio_patch(phydev);
+}
+EXPORT_SYMBOL(aeon_cl45_write);
+
+static int aeon_mdio_read(struct phy_device *phydev, int dev_addr,
+			  unsigned short phy_reg)
+{
+	int ret = 0;
+	struct mii_bus *bus = phydev->mdio.bus;
+	int phy_addr = phydev->mdio.addr;
+
+	if (!bus) {
+		phydev_err(phydev, "MDIO bus is NULL\r\n");
+		return -ENODEV;
+	}
+
+	if (phy_addr >= PHY_MAX_ADDR) {
+		phydev_err(phydev, "Invaild PHY address: %d", phy_addr);
+		return -EINVAL;
+	}
+
+	ret = __mdiobus_c45_read(bus, phy_addr, dev_addr, phy_reg);
+	__mdiobus_c45_write(bus, 30, 0x1, 0x1, 0x1);
+
+	return ret;
+}
+
+static int aeon_mdio_write(struct phy_device *phydev, int dev_addr,
+			   unsigned short phy_reg, unsigned short val)
+{
+	int ret = 0;
+	struct mii_bus *bus = phydev->mdio.bus;
+	int phy_addr = phydev->mdio.addr;
+
+	if (!bus) {
+		phydev_err(phydev, "MDIO bus is NULL\r\n");
+		return -ENODEV;
+	}
+
+	if (phy_addr >= PHY_MAX_ADDR) {
+		phydev_err(phydev, "Invaild PHY address: %d", phy_addr);
+		return -EINVAL;
+	}
+
+	ret = __mdiobus_c45_write(bus, phy_addr, dev_addr, phy_reg, val);
+	__mdiobus_c45_write(bus, 30, 0x1, 0x1, 0x1);
+
+	return ret;
+}
+
+/* AEONSEMI burst write for load fw */
+static void aeon_cl45_write_burst(struct phy_device *phydev, unsigned int dev_addr,
+				  unsigned int phy_reg, const unsigned char *data,
+				  int size)
+{
+	unsigned short write_data = 0, i = 0;
+
+	for (i = 0; i < size; i += 2) {
+		write_data = (data[i + 1] << 8) | data[i];
+		phy_write_mmd(phydev, dev_addr, phy_reg, write_data);
+	}
+}
+
 static int aeon_firmware_boot(struct phy_device *phydev, const u8 *data,
 			      size_t size)
 {
@@ -326,7 +613,6 @@ static int aeon_firmware_boot(struct phy_device *phydev, const u8 *data,
 	/* Firmware is always aligned to u16 */
 	for (i = 0; i < size; i += 2) {
 		val = data[i + 1] << 8 | data[i];
-
 		ret = phy_write_mmd(phydev, MDIO_MMD_VEND1,
 				    VEND1_GLB_REG_MDIO_INDIRECT_LOAD, val);
 		if (ret)
@@ -349,6 +635,83 @@ static int aeon_firmware_boot(struct phy_device *phydev, const u8 *data,
 			      VEND1_GLB_CPU_CTRL_MASK, AEON_CPU_CTRL_FW_START);
 }
 
+static int aeon_set_default_value(struct phy_device *phydev)
+{
+	static const unsigned char base_data[] = {0x32, 0x30, 0x32, 0x33, 0x30, 0x37, 0x31, 0x34};
+	unsigned char bytebuf[16];
+	unsigned short *wdata;
+	unsigned int mask;
+	int byte_count, wdata_count = 0;
+	int pos = 0, val, ret = 0, remaining;
+	unsigned char padded_bytes[MEM_WORD_SIZE] = {0};
+
+	mask = param1 | 14;
+	memcpy(bytebuf, base_data, sizeof(base_data));
+	bytebuf[8] = mask & 0xff;
+	bytebuf[9] = (mask >> 8) & 0xff;
+	byte_count = 10;
+
+	wdata = kmalloc(MAX_WDATA_SIZE * sizeof(unsigned short), GFP_KERNEL);
+	if (!wdata)
+		return -ENOMEM;
+
+	while (pos + MEM_WORD_SIZE <= byte_count) {
+		if (wdata_count + 2 > MAX_WDATA_SIZE) {
+			pr_err("wdata array overflow\n");
+			ret = -ENOSPC;
+			goto cleanup;
+		}
+		wdata[wdata_count++] = le16_to_cpu(*(unsigned short *)&bytebuf[pos]);
+		wdata[wdata_count++] = le16_to_cpu(*(unsigned short *)&bytebuf[pos + 2]);
+		pos += MEM_WORD_SIZE;
+	}
+
+	remaining = byte_count - pos;
+	if (remaining > 0) {
+		if (wdata_count + 2 <= MAX_WDATA_SIZE) {
+			// Here we just need padded_bytes once, otherwise we need to read from mem
+			memcpy(padded_bytes, &bytebuf[pos], remaining);
+			wdata[wdata_count++] = le16_to_cpu(*(unsigned short *)&padded_bytes[0]);
+			wdata[wdata_count++] = le16_to_cpu(*(unsigned short *)&padded_bytes[2]);
+		}
+	}
+
+	val = phy_read_mmd(phydev, MDIO_MMD_VEND1, VEND1_GLB_REG_CPU_CTRL); //GLB_REG_CPU_CTRL
+	val |= 0x12;
+	phy_write_mmd(phydev, MDIO_MMD_VEND1, VEND1_GLB_REG_CPU_CTRL, val);
+	phy_write_mmd(phydev, MDIO_MMD_VEND1, VEND1_FW_START_ADDR,
+			(u16)(AEON_MEM_DEFAULT_ADDR & 0xFFFF));
+	phy_modify_mmd(phydev, MDIO_MMD_VEND1,
+			VEND1_GLB_REG_MDIO_INDIRECT_ADDRCMD,
+			0x3ffc, 0xc000);
+	aeon_cl45_write_burst(phydev, MDIO_MMD_VEND1, VEND1_GLB_REG_MDIO_INDIRECT_LOAD,
+			(unsigned char *)wdata, wdata_count*2);
+	val = phy_read_mmd(phydev, MDIO_MMD_VEND1,
+			VEND1_GLB_REG_MDIO_INDIRECT_ADDRCMD); //GLB_REG_MDIO_INDIRECT_ADDRCMD
+	val &= 0x3FFF;
+	phy_write_mmd(phydev, MDIO_MMD_VEND1, VEND1_GLB_REG_MDIO_INDIRECT_ADDRCMD, val);
+	val = phy_read_mmd(phydev, MDIO_MMD_VEND1, VEND1_GLB_REG_CPU_CTRL); //GLB_REG_CPU_CTRL
+	val &= 0xFFED;
+	phy_write_mmd(phydev, MDIO_MMD_VEND1, VEND1_GLB_REG_CPU_CTRL, val);
+
+cleanup:
+	kfree(wdata);
+	return 0;
+}
+
+static void aeon_set_fast_mdc_timing(struct phy_device *phydev)
+{
+	if (param1) {
+		phy_write_mmd(phydev, MDIO_MMD_VEND1, 0x53, 0xFFFF);
+		phy_write_mmd(phydev, MDIO_MMD_VEND1, 0x54, 0xFFFF);
+		phy_write_mmd(phydev, MDIO_MMD_VEND1, 0x55, 0xFFFF);
+	} else {
+		phy_write_mmd(phydev, MDIO_MMD_VEND1, 0x53, 0);
+		phy_write_mmd(phydev, MDIO_MMD_VEND1, 0x54, 0);
+		phy_write_mmd(phydev, MDIO_MMD_VEND1, 0x55, 0);
+	}
+}
+
 static int aeon_firmware_load(struct phy_device *phydev)
 {
 	struct device *dev = &phydev->mdio.dev;
@@ -369,45 +732,18 @@ static int aeon_firmware_load(struct phy_device *phydev)
 	}
 
 	ret = aeon_firmware_boot(phydev, fw->data, fw->size);
-
 	release_firmware(fw);
 
 	return ret;
 }
 
-static bool aeon_ipc_ready(u16 val, bool parity_status)
-{
-	u16 status;
-
-	if (FIELD_GET(AEON_IPC_STS_PARITY, val) != parity_status)
-		return false;
-
-	status = val & AEON_IPC_STS_STATUS;
-
-	return status != AEON_IPC_STS_STATUS_RCVD &&
-	       status != AEON_IPC_STS_STATUS_PROCESS &&
-	       status != AEON_IPC_STS_STATUS_BUSY;
-}
-
-static int aeon_ipc_wait_cmd(struct phy_device *phydev, bool parity_status)
-{
-	u16 val;
-
-	/* Exit condition logic:
-	 * - Wait for parity bit equal
-	 * - Wait for status success, error OR ready
-	 */
-	return phy_read_mmd_poll_timeout(phydev, MDIO_MMD_VEND1, VEND1_IPC_STS, val,
-					 aeon_ipc_ready(val, parity_status),
-					 AEON_IPC_DELAY, AEON_IPC_TIMEOUT, false);
-}
-
 static int aeon_ipc_send_cmd(struct phy_device *phydev,
 			     struct as21xxx_priv *priv,
 			     u16 cmd, u16 *ret_sts)
 {
 	bool curr_parity;
 	int ret;
+	unsigned int val;
 
 	/* The IPC sync by using a single parity bit.
 	 * Each CMD have alternately this bit set or clear
@@ -416,7 +752,6 @@ static int aeon_ipc_send_cmd(struct phy_device *phydev,
 	curr_parity = priv->parity_status;
 	if (priv->parity_status)
 		cmd |= AEON_IPC_CMD_PARITY;
-
 	/* Always update parity for next packet */
 	priv->parity_status = !priv->parity_status;
 
@@ -426,39 +761,40 @@ static int aeon_ipc_send_cmd(struct phy_device *phydev,
 
 	/* Wait for packet to be processed */
 	usleep_range(AEON_IPC_DELAY, AEON_IPC_DELAY + 5000);
-
 	/* With no ret_sts, ignore waiting for packet completion
 	 * (ipc parity bit sync)
 	 */
 	if (!ret_sts)
 		return 0;
-
-	ret = aeon_ipc_wait_cmd(phydev, curr_parity);
+	/* Exit condition logic:
+	 * - Wait for parity bit equal
+	 * - Wait for status success, error OR ready
+	 */
+	ret = read_poll_timeout(phy_read_mmd, val,
+				(FIELD_GET(AEON_IPC_STS_PARITY, val) == curr_parity &&
+				(val & AEON_IPC_STS_STATUS) != AEON_IPC_STS_STATUS_RCVD &&
+				(val & AEON_IPC_STS_STATUS) != AEON_IPC_STS_STATUS_PROCESS &&
+				(val & AEON_IPC_STS_STATUS) != AEON_IPC_STS_STATUS_BUSY) ||
+				(val < 0),
+				10000, 2000000, false,
+				phydev, MDIO_MMD_VEND1, VEND1_IPC_STS);
+	if (val < 0)
+		ret = val;
 	if (ret)
-		return ret;
-
-	ret = phy_read_mmd(phydev, MDIO_MMD_VEND1, VEND1_IPC_STS);
-	if (ret < 0)
-		return ret;
-
-	*ret_sts = ret;
-	if ((*ret_sts & AEON_IPC_STS_STATUS) != AEON_IPC_STS_STATUS_SUCCESS)
+		phydev_err(phydev, "%s fail to polling status failed: %d\n", __func__, ret);
+	*ret_sts = val;
+	if ((val & AEON_IPC_STS_STATUS) != AEON_IPC_STS_STATUS_SUCCESS)
 		return -EINVAL;
 
 	return 0;
 }
 
-/* If data is NULL, return 0 or negative error.
- * If data not NULL, return number of Bytes received from IPC or
- * a negative error.
- */
 static int aeon_ipc_send_msg(struct phy_device *phydev,
 			     u16 opcode, u16 *data, unsigned int data_len,
-			     u16 *ret_data)
+			     u16 *ret_sts)
 {
 	struct as21xxx_priv *priv = phydev->priv;
-	unsigned int ret_size;
-	u16 cmd, ret_sts;
+	u16 cmd;
 	int ret;
 	int i;
 
@@ -468,55 +804,50 @@ static int aeon_ipc_send_msg(struct phy_device *phydev,
 	if (data_len > AEON_IPC_DATA_MAX)
 		return -EINVAL;
 
+	mutex_lock(&priv->ipc_lock);
 	for (i = 0; i < data_len / sizeof(u16); i++)
 		phy_write_mmd(phydev, MDIO_MMD_VEND1, VEND1_IPC_DATA(i),
 			      data[i]);
 
 	cmd = FIELD_PREP(AEON_IPC_CMD_SIZE, data_len) |
 	      FIELD_PREP(AEON_IPC_CMD_OPCODE, opcode);
-
-	mutex_lock(&priv->ipc_lock);
-
-	ret = aeon_ipc_send_cmd(phydev, priv, cmd, &ret_sts);
-	if (ret) {
+	ret = aeon_ipc_send_cmd(phydev, priv, cmd, ret_sts);
+	if (ret)
 		phydev_err(phydev, "failed to send ipc msg for %x: %d\n",
 			   opcode, ret);
-		goto out;
-	}
+	mutex_unlock(&priv->ipc_lock);
+
+	return ret;
+}
 
-	if (!data)
-		goto out;
+static int aeon_ipc_rcv_msg(struct phy_device *phydev,
+			    u16 ret_sts, u16 *data)
+{
+	struct as21xxx_priv *priv = phydev->priv;
+	unsigned int size;
+	int ret;
+	int i;
 
-	if ((ret_sts & AEON_IPC_STS_STATUS) == AEON_IPC_STS_STATUS_ERROR) {
-		ret = -EINVAL;
-		goto out;
-	}
+	if ((ret_sts & AEON_IPC_STS_STATUS) == AEON_IPC_STS_STATUS_ERROR)
+		return -EINVAL;
 
-	/* Prevent IPC from stack smashing the kernel.
-	 * We can't trust IPC to return a good value and we always
-	 * preallocate space for 16 Bytes.
-	 */
-	ret_size = FIELD_GET(AEON_IPC_STS_SIZE, ret_sts);
-	if (ret_size > AEON_IPC_DATA_MAX) {
-		ret = -EINVAL;
-		goto out;
-	}
+	/* Prevent IPC from stack smashing the kernel */
+	size = FIELD_GET(AEON_IPC_STS_SIZE, ret_sts);
+	if (size > AEON_IPC_DATA_MAX)
+		return -EINVAL;
 
-	/* Read data from IPC data register for ret_size value from IPC */
-	for (i = 0; i < DIV_ROUND_UP(ret_size, sizeof(u16)); i++) {
+	mutex_lock(&priv->ipc_lock);
+	for (i = 0; i < DIV_ROUND_UP(size, sizeof(u16)); i++) {
 		ret = phy_read_mmd(phydev, MDIO_MMD_VEND1, VEND1_IPC_DATA(i));
-		if (ret < 0)
+		if (ret < 0) {
+			size = ret;
 			goto out;
-
-		ret_data[i] = ret;
+		}
+		data[i] = ret;
 	}
-
-	ret = ret_size;
-
 out:
 	mutex_unlock(&priv->ipc_lock);
-
-	return ret;
+	return size;
 }
 
 static int aeon_ipc_noop(struct phy_device *phydev,
@@ -542,18 +873,13 @@ static int aeon_ipc_sync_parity(struct phy_device *phydev,
 	int ret;
 
 	mutex_lock(&priv->ipc_lock);
-
 	/* Send NOP with no parity */
 	aeon_ipc_noop(phydev, priv, NULL);
-
 	/* Reset packet parity */
 	priv->parity_status = false;
-
 	/* Send second NOP with no parity */
 	ret = aeon_ipc_noop(phydev, priv, &ret_sts);
-
 	mutex_unlock(&priv->ipc_lock);
-
 	/* We expect to return -EINVAL */
 	if (ret != -EINVAL)
 		return ret;
@@ -570,21 +896,22 @@ static int aeon_ipc_sync_parity(struct phy_device *phydev,
 static int aeon_ipc_get_fw_version(struct phy_device *phydev)
 {
 	u16 ret_data[AEON_IPC_DATA_NUM_REGISTERS], data[1];
-	char fw_version[AEON_IPC_DATA_MAX + 1];
+	u16 ret_sts;
 	int ret;
 
 	data[0] = IPC_INFO_VERSION;
-
 	ret = aeon_ipc_send_msg(phydev, IPC_CMD_INFO, data,
-				sizeof(data), ret_data);
+				sizeof(data), &ret_sts);
+	if (ret)
+		return ret;
+
+	ret = aeon_ipc_rcv_msg(phydev, ret_sts, ret_data);
 	if (ret < 0)
 		return ret;
 
 	/* Make sure FW version is NULL terminated */
-	memcpy(fw_version, ret_data, ret);
-	fw_version[ret] = '\0';
-
-	phydev_info(phydev, "Firmware Version: %s\n", fw_version);
+	ret_data[DIV_ROUND_UP(ret, sizeof(u16))] = '\0';
+	phydev_info(phydev, "Firmware Version: %s\n", (char *)ret_data);
 
 	return 0;
 }
@@ -592,15 +919,113 @@ static int aeon_ipc_get_fw_version(struct phy_device *phydev)
 static int aeon_dpc_ra_enable(struct phy_device *phydev)
 {
 	u16 data[2];
+	u16 ret_sts;
 
 	data[0] = IPC_CFG_PARAM_DIRECT;
 	data[1] = IPC_CFG_PARAM_DIRECT_DPC_RA;
 
 	return aeon_ipc_send_msg(phydev, IPC_CMD_CFG_PARAM, data,
-				 sizeof(data), NULL);
+				 sizeof(data), &ret_sts);
+}
+
+static int aeon_set_eth_speed(struct phy_device *phydev, unsigned short speed)
+{
+	u16 data[8];
+	u16 ret_sts;
+
+	data[0] = IPC_CFG_PARAM_DIRECT;
+	data[1] = IPC_CFG_PARAM_DIRECT_CU_AN;
+	data[2] = IPC_CMD_CFG_CU_AN_TOP_SPD;
+	data[3] = speed;
+
+	return aeon_ipc_send_msg(phydev, IPC_CMD_CFG_PARAM, data,
+				 sizeof(data), &ret_sts);
+}
+
+static int aeon_restart_an(struct phy_device *phydev)
+{
+	u16 data[8];
+	u16 ret_sts;
+
+	data[0] = IPC_CFG_PARAM_DIRECT;
+	data[1] = IPC_CFG_PARAM_DIRECT_CU_AN;
+	data[2] = IPC_CMD_CFG_CU_AN_RESTART;
+
+	return aeon_ipc_send_msg(phydev, IPC_CMD_CFG_PARAM, data,
+				 sizeof(data), &ret_sts);
+}
+
+static int aeon_modify_mmd_changed(struct phy_device *phydev, int devad, u32 regnum,
+				   u16 mask, u16 set)
+{
+	int new, ret;
+
+	ret = phy_read_mmd(phydev, devad, regnum);
+	if (ret < 0)
+		return ret;
+
+	new = (ret & ~mask) | set;
+	if (new == ret)
+		return 0;
+
+	if (set & MDIO_AN_10GBT_CTRL_ADV10G) {
+		ret = aeon_ipc_sync_parity(phydev, phydev->priv);
+		if (ret)
+			return ret;
+		ret = aeon_set_eth_speed(phydev, MDI_CFG_SPD_T10G);
+		if (ret)
+			return ret;
+	} else if (set & ADVERTISE_1000FULL) {
+		ret = aeon_ipc_sync_parity(phydev, phydev->priv);
+		if (ret)
+			return ret;
+		ret = aeon_set_eth_speed(phydev, MDI_CFG_SPD_T1G);
+		if (ret)
+			return ret;
+	} else if (set & ADVERTISE_100FULL) {
+		ret = aeon_ipc_sync_parity(phydev, phydev->priv);
+		if (ret)
+			return ret;
+		ret = aeon_set_eth_speed(phydev, MDI_CFG_SPD_T100);
+		if (ret)
+			return ret;
+	}
+
+	return 1;
+}
+
+static int aeon_get_features(struct phy_device *phydev)
+{
+	int ret;
+
+	ret = genphy_c45_pma_read_abilities(phydev);
+	if (ret)
+		return ret;
+
+	/* AS21xxx supports 100M/1G/2.5G/5G/10G speed. */
+	linkmode_clear_bit(ETHTOOL_LINK_MODE_10baseT_Half_BIT,
+			   phydev->supported);
+	linkmode_clear_bit(ETHTOOL_LINK_MODE_10baseT_Full_BIT,
+			   phydev->supported);
+	linkmode_clear_bit(ETHTOOL_LINK_MODE_100baseT_Half_BIT,
+			   phydev->supported);
+	linkmode_set_bit(ETHTOOL_LINK_MODE_100baseT_Full_BIT,
+			 phydev->supported);
+	linkmode_set_bit(ETHTOOL_LINK_MODE_1000baseT_Full_BIT,
+			 phydev->supported);
+	linkmode_set_bit(ETHTOOL_LINK_MODE_2500baseT_Full_BIT,
+			 phydev->supported);
+	linkmode_set_bit(ETHTOOL_LINK_MODE_5000baseT_Full_BIT,
+			 phydev->supported);
+	linkmode_set_bit(ETHTOOL_LINK_MODE_10000baseT_Full_BIT,
+			 phydev->supported);
+	/* AS21xxx does not support C22 registers */
+	phydev->c45_ids.devices_in_package &= ~BIT(0);
+
+	return 0;
 }
 
-static int as21xxx_probe(struct phy_device *phydev)
+static int aeon_gen1_probe(struct phy_device *phydev)
 {
 	struct as21xxx_priv *priv;
 	int ret;
@@ -610,9 +1035,10 @@ static int as21xxx_probe(struct phy_device *phydev)
 	if (!priv)
 		return -ENOMEM;
 	phydev->priv = priv;
-
-	ret = devm_mutex_init(&phydev->mdio.dev,
-			      &priv->ipc_lock);
+	aeon_set_fast_mdc_timing(phydev);
+	aeon_set_default_value(phydev);
+	ret = aeon_firmware_load(phydev);
+	mutex_init(&priv->ipc_lock);
 	if (ret)
 		return ret;
 
@@ -624,169 +1050,268 @@ static int as21xxx_probe(struct phy_device *phydev)
 	if (ret)
 		return ret;
 
+	ret = as21xxx_debugfs_init(phydev);
+	if (ret)
+		return ret;
+
 	/* Enable PTP clk if not already Enabled */
 	ret = phy_set_bits_mmd(phydev, MDIO_MMD_VEND1, VEND1_PTP_CLK,
 			       VEND1_PTP_CLK_EN);
 	if (ret)
 		return ret;
 
-	return aeon_dpc_ra_enable(phydev);
+	return 0;
 }
 
-static int as21xxx_read_link(struct phy_device *phydev, int *bmcr)
+static int aeon_gen2_probe(struct phy_device *phydev)
 {
-	int status;
+	struct as21xxx_priv *priv;
+	int ret = 0;
 
-	/* Normal C22 BMCR report inconsistent data, use
-	 * the mapped C22 in C45 to have more consistent link info.
-	 */
-	*bmcr = phy_read_mmd(phydev, MDIO_MMD_AN,
-			     AS21XXX_MDIO_AN_C22 + MII_BMCR);
-	if (*bmcr < 0)
-		return *bmcr;
+	priv = devm_kzalloc(&phydev->mdio.dev,
+				sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+	phydev->priv = priv;
+
+	ret = aeon_firmware_load(phydev);
+	if (ret) {
+		phydev_err(phydev, "AS22XX load firmware fail.\n");
+		return ret;
+	}
+
+	mutex_init(&priv->ipc_lock);
+	ret = aeon_ipc_sync_parity(phydev, priv);
+	if (ret)
+		return ret;
+
+	ret = aeon_ipc_get_fw_version(phydev);
+	if (ret)
+		return ret;
+
+	return 0;
+}
 
-	/* Autoneg is being started, therefore disregard current
-	 * link status and report link as down.
+static int aeon_update_link(struct phy_device *phydev)
+{
+	int status = 0, bmcr;
+	bool link_up;
+
+	bmcr = phy_read_mmd(phydev, MDIO_MMD_AN, AS21XXX_MDIO_AN_C22 + MII_BMCR);
+	if (bmcr < 0)
+		return bmcr;
+	/* Autoneg is being started, therefore disregard BMSR value and
+	 * report link as down.
 	 */
-	if (*bmcr & BMCR_ANRESTART) {
-		phydev->link = 0;
-		return 0;
+	if (bmcr & BMCR_ANRESTART)
+		goto done;
+	/* The link state is latched low so that momentary link
+	 * drops can be detected. Do not double-read the status
+	 * in polling mode to detect such short link drops.
+	 */
+	if (!phy_polling_mode(phydev)) {
+		status = phy_read_mmd(phydev, MDIO_MMD_AN, AN_STATES1_ADDR);
+		if (status < 0)
+			return status;
+		else if (status & AN_STATES1_ARB_MASK)
+			goto done;
 	}
 
-	status = phy_read_mmd(phydev, MDIO_MMD_AN, MDIO_STAT1);
+	/* Read link and autonegotiation status */
+	status = phy_read_mmd(phydev, MDIO_MMD_AN, AN_STATES1_ADDR);
 	if (status < 0)
 		return status;
-
-	phydev->link = !!(status & MDIO_STAT1_LSTATUS);
+done:
+	link_up = ((status & AN_STATES1_ARB_MASK) >> AN_STATES1_ARB_OFST) == LINK_GOOD;
+	phydev->link = link_up;
+	phydev->autoneg_complete = link_up;
+	/* Consider the case that autoneg was started and "aneg complete"
+	 * bit has been reset, but "link up" bit not yet.
+	 */
+	if (phydev->autoneg == AUTONEG_ENABLE && !phydev->autoneg_complete)
+		phydev->link = 0;
 
 	return 0;
 }
 
-static int as21xxx_read_c22_lpa(struct phy_device *phydev)
+static int aeon_read_lpa(struct phy_device *phydev)
 {
-	int lpagb;
+	int lpa, lpagb;
 
-	/* MII_STAT1000 are only filled in the mapped C22
-	 * in C45, use that to fill lpagb values and check.
-	 */
-	lpagb = phy_read_mmd(phydev, MDIO_MMD_AN,
-			     AS21XXX_MDIO_AN_C22 + MII_STAT1000);
-	if (lpagb < 0)
-		return lpagb;
+	if (phydev->autoneg == AUTONEG_ENABLE) {
+		if (!phydev->autoneg_complete) {
+			mii_stat1000_mod_linkmode_lpa_t(phydev->lp_advertising,
+							0);
+			mii_lpa_mod_linkmode_lpa_t(phydev->lp_advertising, 0);
+			return 0;
+		}
 
-	if (lpagb & LPA_1000MSFAIL) {
-		int adv = phy_read_mmd(phydev, MDIO_MMD_AN,
-				       AS21XXX_MDIO_AN_C22 + MII_CTRL1000);
+		if (phydev->is_gigabit_capable) {
+			lpagb = phy_read_mmd(phydev, MDIO_MMD_AN,
+					     AS21XXX_MDIO_AN_C22 + MII_STAT1000);
+			if (lpagb < 0)
+				return lpagb;
+			if (lpagb & LPA_1000MSFAIL) {
+				int adv = phy_read_mmd(phydev, MDIO_MMD_AN,
+						       AS21XXX_MDIO_AN_C22 + MII_CTRL1000);
+				if (adv < 0)
+					return adv;
+				if (adv & CTL1000_ENABLE_MASTER)
+					phydev_err(phydev,
+						"Master/Slave resolution failed, maybe conflicting manual settings?\n");
+				else
+					phydev_err(phydev,
+						"Master/Slave resolution failed\n");
+				return -ENOLINK;
+			}
+			mii_stat1000_mod_linkmode_lpa_t(phydev->lp_advertising,
+							lpagb);
+		}
 
-		if (adv < 0)
-			return adv;
+		lpa = phy_read_mmd(phydev, MDIO_MMD_AN, AS21XXX_MDIO_AN_C22 + MII_LPA);
+		if (lpa < 0)
+			return lpa;
+		mii_lpa_mod_linkmode_lpa_t(phydev->lp_advertising, lpa);
+		/* Read the link partner's 10G advertisement */
+		lpa = phy_read_mmd(phydev, MDIO_MMD_AN, MDIO_AN_10GBT_STAT);
+		if (lpa < 0)
+			return lpa;
+		mii_10gbt_stat_mod_linkmode_lpa_t(phydev->lp_advertising, lpa);
+	} else {
+		linkmode_zero(phydev->lp_advertising);
+	}
+	return 0;
+}
 
-		if (adv & CTL1000_ENABLE_MASTER)
-			phydev_err(phydev, "Master/Slave resolution failed, maybe conflicting manual settings?\n");
+static void aeon_read_speed(struct phy_device *phydev)
+{
+	int bmcr, speed;
+
+	bmcr = phy_read_mmd(phydev, MDIO_MMD_AN, AS21XXX_MDIO_AN_C22 + MII_BMCR);
+	if (bmcr < 0)
+		return;
+
+	speed = phy_read_mmd(phydev, MDIO_MMD_VEND1, VEND1_SPEED_STATUS);
+	if (speed < 0)
+		return;
+
+	speed &= 0xff;
+	if (speed == 0x3) {
+		phydev->speed = SPEED_10000;
+		phydev->duplex = DUPLEX_FULL;
+	} else if (speed == 0x5) {
+		phydev->speed = SPEED_5000;
+		phydev->duplex = DUPLEX_FULL;
+	} else if (speed == 0x9) {
+		phydev->speed = SPEED_2500;
+		phydev->duplex = DUPLEX_FULL;
+	} else if (speed == 0x10) {
+		phydev->speed = SPEED_1000;
+		if (bmcr & BMCR_FULLDPLX)
+			phydev->duplex = DUPLEX_FULL;
+		else
+			phydev->duplex = DUPLEX_HALF;
+	} else if (speed == 0x20) {
+		phydev->speed = SPEED_100;
+		if (bmcr & BMCR_FULLDPLX)
+			phydev->duplex = DUPLEX_FULL;
 		else
-			phydev_err(phydev, "Master/Slave resolution failed\n");
-		return -ENOLINK;
+			phydev->duplex = DUPLEX_HALF;
+	} else {
+		phydev->speed = SPEED_10;
+		phydev->duplex = DUPLEX_FULL;
 	}
+}
 
-	mii_stat1000_mod_linkmode_lpa_t(phydev->lp_advertising,
-					lpagb);
+static void aeon_resolve_aneg_linkmode(struct phy_device *phydev)
+{
+	__ETHTOOL_DECLARE_LINK_MODE_MASK(common);
 
-	return 0;
+	linkmode_and(common, phydev->lp_advertising, phydev->advertising);
+	phy_resolve_aneg_pause(phydev);
 }
 
-static int as21xxx_read_status(struct phy_device *phydev)
+static int aeon_read_status(struct phy_device *phydev)
 {
-	int bmcr, old_link = phydev->link;
-	int ret;
+	int err, old_link = phydev->link;
 
-	ret = as21xxx_read_link(phydev, &bmcr);
-	if (ret)
-		return ret;
+	/* Update the link, but return if there was an error */
+	err = aeon_update_link(phydev);
+	if (err)
+		return err;
 
 	/* why bother the PHY if nothing can have changed */
 	if (phydev->autoneg == AUTONEG_ENABLE && old_link && phydev->link)
 		return 0;
-
 	phydev->speed = SPEED_UNKNOWN;
 	phydev->duplex = DUPLEX_UNKNOWN;
 	phydev->pause = 0;
 	phydev->asym_pause = 0;
 
-	if (phydev->autoneg == AUTONEG_ENABLE) {
-		ret = genphy_c45_read_lpa(phydev);
-		if (ret)
-			return ret;
-
-		ret = as21xxx_read_c22_lpa(phydev);
-		if (ret)
-			return ret;
+	err = aeon_read_lpa(phydev);
+	if (err < 0)
+		return err;
+	if (phydev->autoneg == AUTONEG_ENABLE && phydev->autoneg_complete) {
+		aeon_read_speed(phydev);
+		aeon_resolve_aneg_linkmode(phydev);
+	} else if (phydev->autoneg == AUTONEG_DISABLE) {
+		aeon_read_speed(phydev);
+	}
 
-		phy_resolve_aneg_linkmode(phydev);
-	} else {
-		int speed;
+	return 0;
+}
 
-		linkmode_zero(phydev->lp_advertising);
+static int aeon_ipc_set_led_cfg(unsigned short led0, unsigned short led1,
+				unsigned short led2, unsigned short led3,
+				unsigned short led4, unsigned short polarity,
+				unsigned short blink, struct phy_device *phydev)
+{
+	u16 ret_size;
+	u16 cfg[7] = {
+		led0, led1, led2, led3, led4, polarity, blink
+	};
 
-		speed = phy_read_mmd(phydev, MDIO_MMD_VEND1,
-				     VEND1_SPEED_STATUS);
-		if (speed < 0)
-			return speed;
+	ret_size = aeon_ipc_sync_parity(phydev, phydev->priv);
+	if (ret_size)
+		return ret_size;
 
-		switch (speed & VEND1_SPEED_STATUS) {
-		case VEND1_SPEED_10000:
-			phydev->speed = SPEED_10000;
-			phydev->duplex = DUPLEX_FULL;
-			break;
-		case VEND1_SPEED_5000:
-			phydev->speed = SPEED_5000;
-			phydev->duplex = DUPLEX_FULL;
-			break;
-		case VEND1_SPEED_2500:
-			phydev->speed = SPEED_2500;
-			phydev->duplex = DUPLEX_FULL;
-			break;
-		case VEND1_SPEED_1000:
-			phydev->speed = SPEED_1000;
-			if (bmcr & BMCR_FULLDPLX)
-				phydev->duplex = DUPLEX_FULL;
-			else
-				phydev->duplex = DUPLEX_HALF;
-			break;
-		case VEND1_SPEED_100:
-			phydev->speed = SPEED_100;
-			phydev->duplex = DUPLEX_FULL;
-			break;
-		case VEND1_SPEED_10:
-			phydev->speed = SPEED_10;
-			phydev->duplex = DUPLEX_FULL;
-			break;
-		default:
-			return -EINVAL;
-		}
-	}
+	aeon_ipc_send_msg(phydev, IPC_CMD_SET_LED, cfg, sizeof(cfg), &ret_size);
 
-	return 0;
+	return 1;
 }
 
-static int as21xxx_led_brightness_set(struct phy_device *phydev,
-				      u8 index, enum led_brightness value)
+
+static int aeon_led_brightness_set(struct phy_device *phydev,
+				   u8 index, enum led_brightness value)
 {
-	u16 val = VEND1_LED_REG_A_EVENT_OFF;
+	u16 val = LED_MODE_OFF;
 
 	if (index > AEON_MAX_LEDS)
 		return -EINVAL;
-
 	if (value)
-		val = VEND1_LED_REG_A_EVENT_ON;
-
-	return phy_modify_mmd(phydev, MDIO_MMD_VEND1,
-			      VEND1_LED_REG(index),
-			      VEND1_LED_REG_A_EVENT,
-			      FIELD_PREP(VEND1_LED_REG_A_EVENT, val));
+		val = LED_MODE_ON;
+
+	if (index == AEON_LED0)
+		custome_cfg[0] = val;
+	else if (index == AEON_LED1)
+		custome_cfg[1] = val;
+	else if (index == AEON_LED2)
+		custome_cfg[2] = val;
+	else if (index == AEON_LED3)
+		custome_cfg[3] = val;
+	else if (index == AEON_LED4)
+		custome_cfg[4] = val;
+	else
+		phydev_dbg(phydev, "AEON support five leds, check index\r\n");
+
+	aeon_ipc_set_led_cfg(custome_cfg[0], custome_cfg[1], custome_cfg[2], custome_cfg[3],
+			     custome_cfg[4], custome_cfg[5], custome_cfg[6], phydev);
+
+	return 1;
 }
 
-static int as21xxx_led_hw_is_supported(struct phy_device *phydev, u8 index,
-				       unsigned long rules)
+static int aeon_led_hw_is_supported(struct phy_device *phydev, u8 index,
+				    unsigned long rules)
 {
 	int i;
 
@@ -800,19 +1325,37 @@ static int as21xxx_led_hw_is_supported(struct phy_device *phydev, u8 index,
 	return -EOPNOTSUPP;
 }
 
-static int as21xxx_led_hw_control_get(struct phy_device *phydev, u8 index,
-				      unsigned long *rules)
+static int aeon_led_hw_control_get(struct phy_device *phydev, u8 index,
+				   unsigned long *rules)
 {
 	int i, val;
 
 	if (index > AEON_MAX_LEDS)
 		return -EINVAL;
 
-	val = phy_read_mmd(phydev, MDIO_MMD_VEND1, VEND1_LED_REG(index));
-	if (val < 0)
-		return val;
+	if (index == AEON_LED0) {
+		for (i = 0; i < ARRAY_SIZE(as21xxx_led_map); i++)
+			if (custome_cfg[0] == as21xxx_led_map[i].mode)
+				val = as21xxx_led_map[i].map;
+	} else if (index == AEON_LED1) {
+		for (i = 0; i < ARRAY_SIZE(as21xxx_led_map); i++)
+			if (custome_cfg[1] == as21xxx_led_map[i].mode)
+				val = as21xxx_led_map[i].map;
+	} else if (index == AEON_LED2) {
+		for (i = 0; i < ARRAY_SIZE(as21xxx_led_map); i++)
+			if (custome_cfg[2] == as21xxx_led_map[i].mode)
+				val = as21xxx_led_map[i].map;
+	} else if (index == AEON_LED3) {
+		for (i = 0; i < ARRAY_SIZE(as21xxx_led_map); i++)
+			if (custome_cfg[3] == as21xxx_led_map[i].mode)
+				val = as21xxx_led_map[i].map;
+	} else if (index == AEON_LED4) {
+		for (i = 0; i < ARRAY_SIZE(as21xxx_led_map); i++)
+			if (custome_cfg[4] == as21xxx_led_map[i].mode)
+				val = as21xxx_led_map[i].map;
+	} else
+		phydev_dbg(phydev, "AEON support five leds, check index\r\n");
 
-	val = FIELD_GET(VEND1_LED_REG_A_EVENT, val);
 	for (i = 0; i < ARRAY_SIZE(as21xxx_led_supported_pattern); i++)
 		if (val == as21xxx_led_supported_pattern[i].val) {
 			*rules = as21xxx_led_supported_pattern[i].pattern;
@@ -823,32 +1366,35 @@ static int as21xxx_led_hw_control_get(struct phy_device *phydev, u8 index,
 	return -EINVAL;
 }
 
-static int as21xxx_led_hw_control_set(struct phy_device *phydev, u8 index,
-				      unsigned long rules)
+static int aeon_led_hw_control_set(struct phy_device *phydev, u8 index,
+				   unsigned long rules)
 {
-	u16 val = 0;
-	int i;
-
 	if (index > AEON_MAX_LEDS)
 		return -EINVAL;
 
-	for (i = 0; i < ARRAY_SIZE(as21xxx_led_supported_pattern); i++)
-		if (rules == as21xxx_led_supported_pattern[i].pattern) {
-			val = as21xxx_led_supported_pattern[i].val;
-			break;
-		}
-
-	return phy_modify_mmd(phydev, MDIO_MMD_VEND1,
-			      VEND1_LED_REG(index),
-			      VEND1_LED_REG_A_EVENT,
-			      FIELD_PREP(VEND1_LED_REG_A_EVENT, val));
+	if (index == AEON_LED0)
+		custome_cfg[0] = rules;
+	else if (index == AEON_LED1)
+		custome_cfg[1] = rules;
+	else if (index == AEON_LED2)
+		custome_cfg[2] = rules;
+	else if (index == AEON_LED3)
+		custome_cfg[3] = rules;
+	else if (index == AEON_LED4)
+		custome_cfg[4] = rules;
+	else
+		phydev_dbg(phydev, "AEON support five leds, check index\r\n");
+
+	aeon_ipc_set_led_cfg(custome_cfg[0], custome_cfg[1], custome_cfg[2], custome_cfg[3],
+			     custome_cfg[4], custome_cfg[5], custome_cfg[6], phydev);
+
+	return 1;
 }
 
-static int as21xxx_led_polarity_set(struct phy_device *phydev, int index,
-				    unsigned long modes)
+static int aeon_led_polarity_set(struct phy_device *phydev, int index,
+				 unsigned long modes)
 {
 	bool led_active_low = false;
-	u16 mask, val = 0;
 	u32 mode;
 
 	if (index > AEON_MAX_LEDS)
@@ -867,83 +1413,279 @@ static int as21xxx_led_polarity_set(struct phy_device *phydev, int index,
 		}
 	}
 
-	mask = VEND1_GLB_CPU_CTRL_LED_POLARITY(index);
 	if (led_active_low)
-		val = VEND1_GLB_CPU_CTRL_LED_POLARITY(index);
+		custome_cfg[5] |= (1 << index);
+
+	aeon_ipc_set_led_cfg(custome_cfg[0], custome_cfg[1], custome_cfg[2], custome_cfg[3],
+			     custome_cfg[4], custome_cfg[5], custome_cfg[6], phydev);
 
-	return phy_modify_mmd(phydev, MDIO_MMD_VEND1,
-			      VEND1_GLB_REG_CPU_CTRL,
-			      mask, val);
+	return 0;
 }
 
-static int as21xxx_match_phy_device(struct phy_device *phydev,
-				    const struct phy_driver *phydrv)
+static int aeon_gen1_read_pid(struct phy_device *phydev)
+{
+	int pid1 = 0, pid2 = 0, pid = 0;
+
+	pid1 = aeon_cl45_read(phydev, MDIO_MMD_PMAPMD, 2);
+	if (pid1 < 0)
+		return pid1;
+
+	if (pid1 == 0x7500 && param1) {
+		aeon_cl45_write(phydev, MDIO_MMD_VEND1, 0x53, 0xFFFF);
+		aeon_cl45_write(phydev, MDIO_MMD_VEND1, 0x54, 0xFFFF);
+		aeon_cl45_write(phydev, MDIO_MMD_VEND1, 0x55, 0xFFFF);
+	}
+
+	pid2 = aeon_cl45_read(phydev, MDIO_MMD_PMAPMD, 3);
+	if (pid2 < 0)
+		return pid2;
+
+	phydev_dbg(phydev, "%s aeonsemi PHY = %x - %x\n", __func__, pid1, pid2);
+	pid = ((pid1 & 0xffff) << 16) | (pid2 & 0xffff);
+
+	return pid;
+}
+
+static int aeon_gen2_read_pid(struct phy_device *phydev)
+{
+	int pid1 = 0, pid2 = 0, pid = 0;
+
+	pid1 = aeon_cl45_read(phydev, MDIO_MMD_PMAPMD, 2);
+	if (pid1 < 0)
+		return pid1;
+
+	pid2 = aeon_cl45_read(phydev, MDIO_MMD_PMAPMD, 3);
+	if (pid2 < 0)
+		return pid2;
+
+	phydev_dbg(phydev, "%s aeonsemi PHY = %x - %x\n", __func__, pid1, pid2);
+	pid = ((pid1 & 0xffff) << 16) | (pid2 & 0xffff);
+
+	return pid;
+}
+
+static int aeon_config_led(struct phy_device *phydev)
 {
-	struct as21xxx_priv *priv;
-	u16 ret_sts;
-	u32 phy_id;
 	int ret;
+	/* LED0 */
+	ret = aeon_led_hw_control_set(phydev, AEON_LED0, LED_LINK_EST);
+	if (ret < 0)
+		return ret;
+
+	/* LED1 */
+	return aeon_led_hw_control_set(phydev, AEON_LED1, LED_LINK_EST_BLINK_ACT);
+}
+
+static int aeon_gen1_match_phy_device(struct phy_device *phydev,
+				      const struct phy_driver *phydrv)
+{
+	u32 phy_id = aeon_gen1_read_pid(phydev);
+
+	if (phy_id != PHY_ID_AS21XXX)
+		return 0;
+
+	phydev->phy_id = phy_id;
+	aeon_cl45_write(phydev, MDIO_MMD_VEND1, VEND1_PTP_CLK, 0x48);
+
+	return 1;
+}
+
+static int aeon_gen2_match_phy_device(struct phy_device *phydev,
+				      const struct phy_driver *phydrv)
+{
+	/* AEONSEMI get pid. */
+	phydev->phy_id = aeon_gen2_read_pid(phydev);
+
+	if (phydev->phy_id == PHY_ID_AS22XXX)
+		return 1;
+
+	return 0;
+}
+
+static void aeon_gen1_remove(struct phy_device *phydev)
+{
+	as21xxx_debugfs_remove(phydev);
+}
+
+static int aeon_wait_reset_complete(struct phy_device *phydev)
+{
+	int val;
+
+	return read_poll_timeout(aeon_ipc_get_fw_version, val,
+				 val == 0, 10000, 2000000, false, phydev);
+}
+
+static int aeon_gen1_config_init(struct phy_device *phydev)
+{
+	int ret = aeon_wait_reset_complete(phydev);
 
-	/* Skip PHY that are not AS21xxx */
-	if (!phy_id_compare_vendor(phydev->c45_ids.device_ids[MDIO_MMD_PCS],
-				   PHY_VENDOR_AEONSEMI))
-		return genphy_match_phy_device(phydev, phydrv);
+	if (ret) {
+		aeon_cl45_write(phydev, MDIO_MMD_VEND1, VEND1_PTP_CLK, 0x48);
+		ret = aeon_firmware_load(phydev);
+		if (ret)
+			return ret;
+
+		ret = aeon_wait_reset_complete(phydev);
+		if (!ret) {
+			/* Enable PTP clk if not already Enabled */
+			ret = phy_set_bits_mmd(phydev, MDIO_MMD_VEND1, VEND1_PTP_CLK,
+					       VEND1_PTP_CLK_EN);
+			if (ret)
+				return ret;
+		} else
+			return -ENODEV;
+	}
+
+	aeon_config_led(phydev);
+	if (phydev->interface == PHY_INTERFACE_MODE_USXGMII)
+		ret = aeon_dpc_ra_enable(phydev);
+
+	return ret;
+}
+
+static int aeon_gen2_config_init(struct phy_device *phydev)
+{
+	int ret = aeon_wait_reset_complete(phydev);
+
+	if (ret) {
+		ret = aeon_firmware_load(phydev);
+		if (ret)
+			return ret;
+
+		ret = aeon_wait_reset_complete(phydev);
+		if (ret)
+			return -ENODEV;
+	}
+
+	aeon_config_led(phydev);
+	if (phydev->interface == PHY_INTERFACE_MODE_USXGMII)
+		ret = aeon_dpc_ra_enable(phydev);
+
+	return ret;
+}
 
-	/* Read PHY ID to handle firmware loaded or HW reset */
-	ret = phy_read_mmd(phydev, MDIO_MMD_PCS, MII_PHYSID1);
+static int aeon_gen1_c45_an_config_aneg(struct phy_device *phydev)
+{
+	int changed, ret;
+	u32 adv;
+
+	linkmode_and(phydev->advertising, phydev->advertising,
+		     phydev->supported);
+	// changed = genphy_c45_an_config_eee_aneg(phydev);
+
+	adv = linkmode_adv_to_mii_adv_t(phydev->advertising);
+	ret = aeon_modify_mmd_changed(phydev, MDIO_MMD_AN, MDIO_AN_ADVERTISE,
+				      ADVERTISE_ALL | ADVERTISE_100BASE4 |
+				      ADVERTISE_PAUSE_CAP | ADVERTISE_PAUSE_ASYM,
+				      adv);
 	if (ret < 0)
 		return ret;
-	phy_id = ret << 16;
+	if (ret > 0)
+		changed = 1;
+	if (ret == 0) {
+		if (adv & ADVERTISE_100FULL) {
+			ret = aeon_ipc_sync_parity(phydev, phydev->priv);
+			if (ret)
+				return ret;
+			ret = aeon_set_eth_speed(phydev, MDI_CFG_SPD_T100);
+			if (ret)
+				return ret;
+		}
+	}
 
-	ret = phy_read_mmd(phydev, MDIO_MMD_PCS, MII_PHYSID2);
+	adv = linkmode_adv_to_mii_ctrl1000_t(phydev->advertising);
+	ret = aeon_modify_mmd_changed(phydev, MDIO_MMD_AN, AS21XXX_MDIO_AN_C22 + MII_CTRL1000,
+				      ADVERTISE_1000FULL | ADVERTISE_1000HALF,
+				      adv);
 	if (ret < 0)
 		return ret;
-	phy_id |= ret;
+	if (ret > 0)
+		changed = 1;
+	if (ret == 0) {
+		if (adv & ADVERTISE_1000FULL) {
+			ret = aeon_ipc_sync_parity(phydev, phydev->priv);
+			if (ret)
+				return ret;
+			ret = aeon_set_eth_speed(phydev, MDI_CFG_SPD_T1G);
+			if (ret)
+				return ret;
+		}
+	}
 
-	/* With PHY ID not the generic AS21xxx one assume
-	 * the firmware just loaded
-	 */
-	if (phy_id != PHY_ID_AS21XXX)
-		return phy_id == phydrv->phy_id;
+	adv = linkmode_adv_to_mii_10gbt_adv_t(phydev->advertising);
+	ret = aeon_modify_mmd_changed(phydev, MDIO_MMD_AN, MDIO_AN_10GBT_CTRL,
+				      MDIO_AN_10GBT_CTRL_ADV10G |
+				      MDIO_AN_10GBT_CTRL_ADV5G |
+				      MDIO_AN_10GBT_CTRL_ADV2_5G, adv);
+	if (ret < 0)
+		return ret;
+	if (ret > 0)
+		changed = 1;
+	if (ret == 0) {
+		if (adv & MDIO_AN_10GBT_CTRL_ADV10G) {
+			ret = aeon_ipc_sync_parity(phydev, phydev->priv);
+			if (ret)
+				return ret;
+			ret = aeon_set_eth_speed(phydev, MDI_CFG_SPD_T10G);
+			if (ret)
+				return ret;
+		}
+	}
 
-	/* Allocate temp priv and load the firmware */
-	priv = kzalloc(sizeof(*priv), GFP_KERNEL);
-	if (!priv)
-		return -ENOMEM;
+	return changed;
+}
 
-	mutex_init(&priv->ipc_lock);
+static int aeon_gen1_c45_restart_aneg(struct phy_device *phydev)
+{
+	int ret = 0;
 
-	ret = aeon_firmware_load(phydev);
+	ret = aeon_ipc_sync_parity(phydev, phydev->priv);
 	if (ret)
-		goto out;
+		return ret;
 
-	/* Sync parity... */
-	ret = aeon_ipc_sync_parity(phydev, priv);
+	ret = aeon_restart_an(phydev);
 	if (ret)
-		goto out;
+		return ret;
 
-	/* ...and send a third NOOP cmd to wait for firmware finish loading */
-	ret = aeon_ipc_noop(phydev, priv, &ret_sts);
-	if (ret)
-		goto out;
+	return 1;
+}
+
+static int aeon_gen1_c45_check_and_restart_aneg(struct phy_device *phydev, bool restart)
+{
+	int ret = 0;
+
+	if (!restart) {
+		/* Configure and restart aneg if it wasn't set before */
+		ret = phy_read_mmd(phydev, MDIO_MMD_AN, MDIO_CTRL1);
+		if (ret < 0)
+			return ret;
+		if (!(ret & MDIO_AN_CTRL1_ENABLE))
+			restart = true;
+	}
+
+	if (restart)
+		ret = aeon_gen1_c45_restart_aneg(phydev);
 
-out:
-	mutex_destroy(&priv->ipc_lock);
-	kfree(priv);
-
-	/* Return can either be 0 or a negative error code.
-	 * Returning 0 here means THIS is NOT a suitable PHY.
-	 *
-	 * For the specific case of the generic Aeonsemi PHY ID that
-	 * needs the firmware the be loaded first to have a correct PHY ID,
-	 * this is OK as a matching PHY ID will be found right after.
-	 * This relies on the driver probe order where the first PHY driver
-	 * probed is the generic one.
-	 */
 	return ret;
 }
 
-static struct phy_driver as21xxx_drivers[] = {
+static int aeon_gen1_config_aneg(struct phy_device *phydev)
+{
+	bool changed = false;
+	int ret;
+
+	if (phydev->autoneg == AUTONEG_DISABLE)
+		return genphy_c45_pma_setup_forced(phydev);
+	ret = aeon_gen1_c45_an_config_aneg(phydev);
+	if (ret < 0)
+		return ret;
+	if (ret > 0)
+		changed = true;
+
+	return aeon_gen1_c45_check_and_restart_aneg(phydev, changed);
+}
+
+static struct phy_driver aeon_drivers[] = {
 	{
 		/* PHY expose in C45 as 0x7500 0x9410
 		 * before firmware is loaded.
@@ -952,136 +1694,183 @@ static struct phy_driver as21xxx_drivers[] = {
 		 */
 		PHY_ID_MATCH_EXACT(PHY_ID_AS21XXX),
 		.name		= "Aeonsemi AS21xxx",
-		.match_phy_device = as21xxx_match_phy_device,
+		.match_phy_device = aeon_gen1_match_phy_device,
+		.probe		= aeon_gen1_probe,
+		.remove		= aeon_gen1_remove,
+		.get_features	= aeon_get_features,
+		.read_status	= aeon_read_status,
+		.config_init	= aeon_gen1_config_init,
+		.config_aneg	= aeon_gen1_config_aneg,
+		.read_mmd	= aeon_mdio_read,
+		.write_mmd	= aeon_mdio_write,
+		.led_brightness_set = aeon_led_brightness_set,
+		.led_hw_is_supported = aeon_led_hw_is_supported,
+		.led_hw_control_set = aeon_led_hw_control_set,
+		.led_hw_control_get = aeon_led_hw_control_get,
+		.led_polarity_set = aeon_led_polarity_set,
 	},
 	{
 		PHY_ID_MATCH_EXACT(PHY_ID_AS21011JB1),
 		.name		= "Aeonsemi AS21011JB1",
-		.probe		= as21xxx_probe,
-		.match_phy_device = as21xxx_match_phy_device,
-		.read_status	= as21xxx_read_status,
-		.led_brightness_set = as21xxx_led_brightness_set,
-		.led_hw_is_supported = as21xxx_led_hw_is_supported,
-		.led_hw_control_set = as21xxx_led_hw_control_set,
-		.led_hw_control_get = as21xxx_led_hw_control_get,
-		.led_polarity_set = as21xxx_led_polarity_set,
+		.probe		= aeon_gen1_probe,
+		.remove		= aeon_gen1_remove,
+		.match_phy_device = aeon_gen1_match_phy_device,
+		.read_status	= aeon_read_status,
+		.get_features	= aeon_get_features,
+		.led_brightness_set = aeon_led_brightness_set,
+		.led_hw_is_supported = aeon_led_hw_is_supported,
+		.led_hw_control_set = aeon_led_hw_control_set,
+		.led_hw_control_get = aeon_led_hw_control_get,
+		.led_polarity_set = aeon_led_polarity_set,
 	},
 	{
 		PHY_ID_MATCH_EXACT(PHY_ID_AS21011PB1),
 		.name		= "Aeonsemi AS21011PB1",
-		.probe		= as21xxx_probe,
-		.match_phy_device = as21xxx_match_phy_device,
-		.read_status	= as21xxx_read_status,
-		.led_brightness_set = as21xxx_led_brightness_set,
-		.led_hw_is_supported = as21xxx_led_hw_is_supported,
-		.led_hw_control_set = as21xxx_led_hw_control_set,
-		.led_hw_control_get = as21xxx_led_hw_control_get,
-		.led_polarity_set = as21xxx_led_polarity_set,
+		.probe		= aeon_gen1_probe,
+		.remove		= aeon_gen1_remove,
+		.match_phy_device = aeon_gen1_match_phy_device,
+		.read_status	= aeon_read_status,
+		.get_features	= aeon_get_features,
+		.led_brightness_set = aeon_led_brightness_set,
+		.led_hw_is_supported = aeon_led_hw_is_supported,
+		.led_hw_control_set = aeon_led_hw_control_set,
+		.led_hw_control_get = aeon_led_hw_control_get,
+		.led_polarity_set = aeon_led_polarity_set,
 	},
 	{
 		PHY_ID_MATCH_EXACT(PHY_ID_AS21010PB1),
 		.name		= "Aeonsemi AS21010PB1",
-		.probe		= as21xxx_probe,
-		.match_phy_device = as21xxx_match_phy_device,
-		.read_status	= as21xxx_read_status,
-		.led_brightness_set = as21xxx_led_brightness_set,
-		.led_hw_is_supported = as21xxx_led_hw_is_supported,
-		.led_hw_control_set = as21xxx_led_hw_control_set,
-		.led_hw_control_get = as21xxx_led_hw_control_get,
-		.led_polarity_set = as21xxx_led_polarity_set,
+		.probe		= aeon_gen1_probe,
+		.remove		= aeon_gen1_remove,
+		.get_features	= aeon_get_features,
+		.read_status	= aeon_read_status,
+		.match_phy_device = aeon_gen1_match_phy_device,
+		.led_brightness_set = aeon_led_brightness_set,
+		.led_hw_is_supported = aeon_led_hw_is_supported,
+		.led_hw_control_set = aeon_led_hw_control_set,
+		.led_hw_control_get = aeon_led_hw_control_get,
+		.led_polarity_set = aeon_led_polarity_set,
 	},
 	{
 		PHY_ID_MATCH_EXACT(PHY_ID_AS21010JB1),
 		.name		= "Aeonsemi AS21010JB1",
-		.probe		= as21xxx_probe,
-		.match_phy_device = as21xxx_match_phy_device,
-		.read_status	= as21xxx_read_status,
-		.led_brightness_set = as21xxx_led_brightness_set,
-		.led_hw_is_supported = as21xxx_led_hw_is_supported,
-		.led_hw_control_set = as21xxx_led_hw_control_set,
-		.led_hw_control_get = as21xxx_led_hw_control_get,
-		.led_polarity_set = as21xxx_led_polarity_set,
+		.probe		= aeon_gen1_probe,
+		.remove		= aeon_gen1_remove,
+		.match_phy_device = aeon_gen1_match_phy_device,
+		.get_features	= aeon_get_features,
+		.read_status	= aeon_read_status,
+		.led_brightness_set = aeon_led_brightness_set,
+		.led_hw_is_supported = aeon_led_hw_is_supported,
+		.led_hw_control_set = aeon_led_hw_control_set,
+		.led_hw_control_get = aeon_led_hw_control_get,
+		.led_polarity_set = aeon_led_polarity_set,
 	},
 	{
 		PHY_ID_MATCH_EXACT(PHY_ID_AS21210PB1),
 		.name		= "Aeonsemi AS21210PB1",
-		.probe		= as21xxx_probe,
-		.match_phy_device = as21xxx_match_phy_device,
-		.read_status	= as21xxx_read_status,
-		.led_brightness_set = as21xxx_led_brightness_set,
-		.led_hw_is_supported = as21xxx_led_hw_is_supported,
-		.led_hw_control_set = as21xxx_led_hw_control_set,
-		.led_hw_control_get = as21xxx_led_hw_control_get,
-		.led_polarity_set = as21xxx_led_polarity_set,
+		.probe		= aeon_gen1_probe,
+		.remove		= aeon_gen1_remove,
+		.match_phy_device = aeon_gen1_match_phy_device,
+		.get_features	= aeon_get_features,
+		.read_status	= aeon_read_status,
+		.led_brightness_set = aeon_led_brightness_set,
+		.led_hw_is_supported = aeon_led_hw_is_supported,
+		.led_hw_control_set = aeon_led_hw_control_set,
+		.led_hw_control_get = aeon_led_hw_control_get,
+		.led_polarity_set = aeon_led_polarity_set,
 	},
 	{
 		PHY_ID_MATCH_EXACT(PHY_ID_AS21510JB1),
 		.name		= "Aeonsemi AS21510JB1",
-		.probe		= as21xxx_probe,
-		.match_phy_device = as21xxx_match_phy_device,
-		.read_status	= as21xxx_read_status,
-		.led_brightness_set = as21xxx_led_brightness_set,
-		.led_hw_is_supported = as21xxx_led_hw_is_supported,
-		.led_hw_control_set = as21xxx_led_hw_control_set,
-		.led_hw_control_get = as21xxx_led_hw_control_get,
-		.led_polarity_set = as21xxx_led_polarity_set,
+		.probe		= aeon_gen1_probe,
+		.remove		= aeon_gen1_remove,
+		.match_phy_device = aeon_gen1_match_phy_device,
+		.get_features	= aeon_get_features,
+		.read_status	= aeon_read_status,
+		.led_brightness_set = aeon_led_brightness_set,
+		.led_hw_is_supported = aeon_led_hw_is_supported,
+		.led_hw_control_set = aeon_led_hw_control_set,
+		.led_hw_control_get = aeon_led_hw_control_get,
+		.led_polarity_set = aeon_led_polarity_set,
 	},
 	{
 		PHY_ID_MATCH_EXACT(PHY_ID_AS21510PB1),
 		.name		= "Aeonsemi AS21510PB1",
-		.probe		= as21xxx_probe,
-		.match_phy_device = as21xxx_match_phy_device,
-		.read_status	= as21xxx_read_status,
-		.led_brightness_set = as21xxx_led_brightness_set,
-		.led_hw_is_supported = as21xxx_led_hw_is_supported,
-		.led_hw_control_set = as21xxx_led_hw_control_set,
-		.led_hw_control_get = as21xxx_led_hw_control_get,
-		.led_polarity_set = as21xxx_led_polarity_set,
+		.probe		= aeon_gen1_probe,
+		.remove		= aeon_gen1_remove,
+		.match_phy_device = aeon_gen1_match_phy_device,
+		.get_features	= aeon_get_features,
+		.read_status	= aeon_read_status,
+		.led_brightness_set = aeon_led_brightness_set,
+		.led_hw_is_supported = aeon_led_hw_is_supported,
+		.led_hw_control_set = aeon_led_hw_control_set,
+		.led_hw_control_get = aeon_led_hw_control_get,
+		.led_polarity_set = aeon_led_polarity_set,
 	},
 	{
 		PHY_ID_MATCH_EXACT(PHY_ID_AS21511JB1),
 		.name		= "Aeonsemi AS21511JB1",
-		.probe		= as21xxx_probe,
-		.match_phy_device = as21xxx_match_phy_device,
-		.read_status	= as21xxx_read_status,
-		.led_brightness_set = as21xxx_led_brightness_set,
-		.led_hw_is_supported = as21xxx_led_hw_is_supported,
-		.led_hw_control_set = as21xxx_led_hw_control_set,
-		.led_hw_control_get = as21xxx_led_hw_control_get,
-		.led_polarity_set = as21xxx_led_polarity_set,
+		.probe		= aeon_gen1_probe,
+		.remove		= aeon_gen1_remove,
+		.match_phy_device = aeon_gen1_match_phy_device,
+		.get_features	= aeon_get_features,
+		.read_status	= aeon_read_status,
+		.led_brightness_set = aeon_led_brightness_set,
+		.led_hw_is_supported = aeon_led_hw_is_supported,
+		.led_hw_control_set = aeon_led_hw_control_set,
+		.led_hw_control_get = aeon_led_hw_control_get,
+		.led_polarity_set = aeon_led_polarity_set,
 	},
 	{
 		PHY_ID_MATCH_EXACT(PHY_ID_AS21210JB1),
 		.name		= "Aeonsemi AS21210JB1",
-		.probe		= as21xxx_probe,
-		.match_phy_device = as21xxx_match_phy_device,
-		.read_status	= as21xxx_read_status,
-		.led_brightness_set = as21xxx_led_brightness_set,
-		.led_hw_is_supported = as21xxx_led_hw_is_supported,
-		.led_hw_control_set = as21xxx_led_hw_control_set,
-		.led_hw_control_get = as21xxx_led_hw_control_get,
-		.led_polarity_set = as21xxx_led_polarity_set,
+		.probe		= aeon_gen1_probe,
+		.remove		= aeon_gen1_remove,
+		.match_phy_device = aeon_gen1_match_phy_device,
+		.get_features	= aeon_get_features,
+		.read_status	= aeon_read_status,
+		.led_brightness_set = aeon_led_brightness_set,
+		.led_hw_is_supported = aeon_led_hw_is_supported,
+		.led_hw_control_set = aeon_led_hw_control_set,
+		.led_hw_control_get = aeon_led_hw_control_get,
+		.led_polarity_set = aeon_led_polarity_set,
 	},
 	{
 		PHY_ID_MATCH_EXACT(PHY_ID_AS21511PB1),
 		.name		= "Aeonsemi AS21511PB1",
-		.probe		= as21xxx_probe,
-		.match_phy_device = as21xxx_match_phy_device,
-		.read_status	= as21xxx_read_status,
-		.led_brightness_set = as21xxx_led_brightness_set,
-		.led_hw_is_supported = as21xxx_led_hw_is_supported,
-		.led_hw_control_set = as21xxx_led_hw_control_set,
-		.led_hw_control_get = as21xxx_led_hw_control_get,
-		.led_polarity_set = as21xxx_led_polarity_set,
+		.probe		= aeon_gen1_probe,
+		.remove		= aeon_gen1_remove,
+		.match_phy_device = aeon_gen1_match_phy_device,
+		.get_features	= aeon_get_features,
+		.read_status	= aeon_read_status,
+		.led_brightness_set = aeon_led_brightness_set,
+		.led_hw_is_supported = aeon_led_hw_is_supported,
+		.led_hw_control_set = aeon_led_hw_control_set,
+		.led_hw_control_get = aeon_led_hw_control_get,
+		.led_polarity_set = aeon_led_polarity_set,
+	},
+	{
+		PHY_ID_MATCH_EXACT(PHY_ID_AS22XXX),
+		.name		= "Aeonsemi AS22XXX",
+		.probe		= aeon_gen2_probe,
+		.match_phy_device = aeon_gen2_match_phy_device,
+		.get_features	= aeon_get_features,
+		.read_status	= aeon_read_status,
+		.config_init	= aeon_gen2_config_init,
+		.led_brightness_set = aeon_led_brightness_set,
+		.led_hw_is_supported = aeon_led_hw_is_supported,
+		.led_hw_control_set = aeon_led_hw_control_set,
+		.led_hw_control_get = aeon_led_hw_control_get,
+		.led_polarity_set = aeon_led_polarity_set,
 	},
 };
-module_phy_driver(as21xxx_drivers);
+module_phy_driver(aeon_drivers);
 
-static struct mdio_device_id __maybe_unused as21xxx_tbl[] = {
+static struct mdio_device_id __maybe_unused aeon_tbl[] = {
 	{ PHY_ID_MATCH_VENDOR(PHY_VENDOR_AEONSEMI) },
 	{ }
 };
-MODULE_DEVICE_TABLE(mdio, as21xxx_tbl);
+MODULE_DEVICE_TABLE(mdio, aeon_tbl);
 
 MODULE_DESCRIPTION("Aeonsemi AS21xxx PHY driver");
 MODULE_AUTHOR("Christian Marangi <ansuelsmth@gmail.com>");
diff --git a/drivers/net/phy/as21xxx.h b/drivers/net/phy/as21xxx.h
new file mode 100644
index 0000000..d3bfa7e
--- /dev/null
+++ b/drivers/net/phy/as21xxx.h
@@ -0,0 +1,65 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Aeonsemi AS21XXxX PHY Driver
+ *
+ */
+
+#include "./as21xx_bbu_api/as21xx_debugfs.h"
+
+// SDS Eye Scan Parameters
+#define EYE_GRPS	31
+#define EYE_COLS_GRP	4
+#define EYE_YRES	254
+#define EYE_NSAMP	256
+#define EYE_XRES	(EYE_GRPS * EYE_COLS_GRP)
+#define EYE_STRIDE	(EYE_COLS_GRP * EYE_YRES)
+#define EYE_TOTAL_BYTES	(EYE_XRES * EYE_YRES)
+#define EYE_PART_0	0
+#define EYE_PART_1	1
+#define EYE_PART_0_GRPS	(EYE_GRPS / 2)
+#define EYE_PART_1_GRPS	(EYE_GRPS - EYE_PART_0_GRPS)
+
+struct downshift_cfg {
+	uint8_t enable;
+	uint8_t retry_limit;
+};
+
+struct an_mdi_cfg {
+	uint8_t top_spd;
+	uint8_t eee_spd;
+	uint8_t fr_spd;
+	uint8_t thp_byp;
+	uint8_t port_type;
+	uint8_t ms_en;
+	uint8_t ms_config;
+	uint8_t nstd_pbo;
+	struct downshift_cfg smt_spd;
+	uint8_t trd_ovrd;
+	uint8_t trd_swap;
+	uint8_t cfr;
+};
+
+typedef struct {
+	unsigned char tm_done : 1;
+	unsigned char tm_alarm : 1;
+	unsigned char wol_sts : 1;
+	unsigned char link_sts : 1;
+	unsigned char reserved2 : 1;
+	unsigned char reserved3 : 1;
+	unsigned char reserved4 : 1;
+	unsigned char reserved5 : 1;
+} irq_stats_t;
+
+struct as21xxx_priv {
+	bool parity_status;
+	/* Protect concurrent IPC access */
+	struct mutex ipc_lock;
+	struct an_mdi_cfg mdi_cfg;
+	struct dentry *debugfs_root;
+	unsigned short raw_eye_data[EYE_TOTAL_BYTES];
+};
+
+int aeon_cl45_read(struct phy_device *phydev, int dev_addr,
+		   unsigned int phy_reg);
+void aeon_cl45_write(struct phy_device *phydev, int dev_addr,
+		     unsigned int phy_reg, unsigned short phy_data);
-- 
2.45.2

