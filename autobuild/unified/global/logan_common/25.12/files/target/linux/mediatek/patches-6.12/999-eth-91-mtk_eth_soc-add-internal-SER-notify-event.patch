From e3aabe817820da95a38b1b6ce7c6868d93693e9f Mon Sep 17 00:00:00 2001
From: Bo-Cun Chen <bc-bocun.chen@mediatek.com>
Date: Mon, 19 Jan 2026 10:16:30 +0800
Subject: [PATCH] net: ethernet: mtk_eth_soc: add internal SER notify event
 support

Signed-off-by: Bo-Cun Chen <bc-bocun.chen@mediatek.com>
---
 drivers/net/ethernet/mediatek/Makefile        |  2 +-
 drivers/net/ethernet/mediatek/mtk_eth_dbg.c   | 14 ++-
 drivers/net/ethernet/mediatek/mtk_eth_reset.c | 97 +++++++++++++++++++
 drivers/net/ethernet/mediatek/mtk_eth_reset.h | 34 +++++++
 drivers/net/ethernet/mediatek/mtk_eth_soc.c   | 76 ++++++++++++++-
 drivers/net/ethernet/mediatek/mtk_eth_soc.h   |  2 +
 6 files changed, 221 insertions(+), 4 deletions(-)
 create mode 100644 drivers/net/ethernet/mediatek/mtk_eth_reset.c
 create mode 100644 drivers/net/ethernet/mediatek/mtk_eth_reset.h

diff --git a/drivers/net/ethernet/mediatek/Makefile b/drivers/net/ethernet/mediatek/Makefile
index cfa54a6..96d0f74 100644
--- a/drivers/net/ethernet/mediatek/Makefile
+++ b/drivers/net/ethernet/mediatek/Makefile
@@ -4,7 +4,7 @@
 #
 
 obj-$(CONFIG_NET_MEDIATEK_SOC) += mtk_eth.o
-mtk_eth-y := mtk_eth_soc.o mtk_eth_path.o mtk_eth_ptp.o mtk_eth_dbg.o mtk_ppe.o mtk_ppe_debugfs.o mtk_ppe_offload.o
+mtk_eth-y := mtk_eth_soc.o mtk_eth_path.o mtk_eth_ptp.o mtk_eth_dbg.o mtk_eth_reset.o mtk_ppe.o mtk_ppe_debugfs.o mtk_ppe_offload.o
 mtk_eth-$(CONFIG_NET_MEDIATEK_SOC_WED) += mtk_wed.o mtk_wed_mcu.o mtk_wed_wo.o
 ifdef CONFIG_DEBUG_FS
 mtk_eth-$(CONFIG_NET_MEDIATEK_SOC_WED) += mtk_wed_debugfs.o
diff --git a/drivers/net/ethernet/mediatek/mtk_eth_dbg.c b/drivers/net/ethernet/mediatek/mtk_eth_dbg.c
index eac788b..58f5540 100644
--- a/drivers/net/ethernet/mediatek/mtk_eth_dbg.c
+++ b/drivers/net/ethernet/mediatek/mtk_eth_dbg.c
@@ -25,6 +25,7 @@
 
 #include "mtk_eth_soc.h"
 #include "mtk_eth_dbg.h"
+#include "mtk_eth_reset.h"
 #include "mtk_wed_regs.h"
 
 static int mtk_qdma_pppq_show(struct seq_file *m, void *v)
@@ -613,20 +614,29 @@ static ssize_t mtk_eth_debugfs_reset_write(struct file *file, const char __user
 		atomic_set(&eth->reset.force, 0);
 		break;
 	case 1:
-		if (atomic_read(&eth->reset.force) && !test_bit(MTK_RESETTING, &eth->state))
+		if (atomic_read(&eth->reset.force) && !test_bit(MTK_RESETTING, &eth->state)) {
+			eth->reset.event = MTK_FE_START_RESET;
 			schedule_work(&eth->pending_work);
-		else
+		} else
 			pr_info(" stat:disable\n");
 		break;
 	case 2:
 		atomic_set(&eth->reset.force, 1);
 		break;
+	case 3:
+		if (atomic_read(&eth->reset.force) && !test_bit(MTK_RESETTING, &eth->state)) {
+			eth->reset.event = MTK_FE_STOP_TRAFFIC;
+			schedule_work(&eth->pending_work);
+		} else
+			pr_info(" stat:disable\n");
+		break;
 	default:
 		pr_info("Usage: echo [level] > /sys/kernel/debug/mtketh/reset\n");
 		pr_info("Commands:   [level]\n");
 		pr_info("		0	disable FE force reset\n");
 		pr_info("		1	trigger FE and WDMA force reset\n");
 		pr_info("		2	enable FE force reset\n");
+		pr_info("		3	trigger FE force reset\n");
 		break;
 	}
 
diff --git a/drivers/net/ethernet/mediatek/mtk_eth_reset.c b/drivers/net/ethernet/mediatek/mtk_eth_reset.c
new file mode 100644
index 0000000..162d7c1
--- /dev/null
+++ b/drivers/net/ethernet/mediatek/mtk_eth_reset.c
@@ -0,0 +1,97 @@
+/* SPDX-License-Identifier: GPL-2.0
+ *
+ * Copyright (c) 2022 MediaTek Inc.
+ * Author: Henry Yen <henry.yen@mediatek.com>
+ */
+
+#include <linux/regmap.h>
+#include "mtk_eth_soc.h"
+#include "mtk_eth_reset.h"
+
+struct mtk_eth *g_eth;
+
+static int mtk_rest_cnt;
+int mtk_wifi_num;
+bool mtk_stop_fail;
+
+DECLARE_COMPLETION(wait_ack_done);
+DECLARE_COMPLETION(wait_ser_done);
+DECLARE_COMPLETION(wait_tops_done);
+
+bool (*mtk_check_wifi_busy)(u32 wdma_idx) = NULL;
+EXPORT_SYMBOL(mtk_check_wifi_busy);
+
+void mtk_set_pse_drop(u32 config)
+{
+	struct mtk_eth *eth = g_eth;
+
+	if (!eth || mtk_is_netsys_v1(eth))
+		return;
+
+	mtk_w32(eth, config, PSE_PPE_DROP(0));
+	if (MTK_HAS_CAPS(eth->soc->caps, MTK_RSTCTRL_PPE1))
+		mtk_w32(eth, config, PSE_PPE_DROP(1));
+	if (MTK_HAS_CAPS(eth->soc->caps, MTK_RSTCTRL_PPE2))
+		mtk_w32(eth, config, PSE_PPE_DROP(2));
+}
+EXPORT_SYMBOL(mtk_set_pse_drop);
+
+static int mtk_eth_netdevice_event(struct notifier_block *n, unsigned long event, void *ptr)
+{
+	struct mtk_eth *eth = container_of(n, struct mtk_eth, reset.netdevice_notifier);
+
+	switch (event) {
+	case MTK_TOPS_DUMP_DONE:
+		complete(&wait_tops_done);
+		break;
+	case MTK_WIFI_RESET_DONE:
+	case MTK_FE_STOP_TRAFFIC_DONE:
+		pr_info("%s rcv done event:%lx\n", __func__, event);
+		mtk_rest_cnt--;
+		if (!mtk_rest_cnt) {
+			complete(&wait_ser_done);
+			mtk_rest_cnt = mtk_wifi_num;
+		}
+		break;
+	case MTK_WIFI_CHIP_ONLINE:
+		mtk_wifi_num++;
+		mtk_rest_cnt = mtk_wifi_num;
+		break;
+	case MTK_WIFI_CHIP_OFFLINE:
+		mtk_wifi_num--;
+		mtk_rest_cnt = mtk_wifi_num;
+		break;
+	case MTK_FE_STOP_TRAFFIC_DONE_FAIL:
+		mtk_stop_fail = true;
+		eth->reset.event = MTK_FE_START_RESET;
+		pr_info("%s rcv done event:%lx\n", __func__, event);
+		complete(&wait_ser_done);
+		mtk_rest_cnt = mtk_wifi_num;
+		break;
+	case MTK_FE_START_RESET_INIT:
+		pr_info("%s rcv fe start reset init event:%lx\n", __func__, event);
+		if (!test_bit(MTK_RESETTING, &eth->state)) {
+			eth->reset.event = MTK_FE_START_RESET;
+			schedule_work(&eth->pending_work);
+		}
+		break;
+	case MTK_WIFI_L1SER_DONE:
+		pr_info("%s rcv wifi done ack :%lx\n", __func__, event);
+		complete(&wait_ack_done);
+		break;
+	default:
+		break;
+	}
+
+	return NOTIFY_DONE;
+}
+
+int mtk_eth_netdevice_event_init(struct mtk_eth *eth)
+{
+	g_eth = eth;
+
+	eth->reset.netdevice_notifier.notifier_call = mtk_eth_netdevice_event;
+	register_netdevice_notifier(&eth->reset.netdevice_notifier);
+
+	return 0;
+}
diff --git a/drivers/net/ethernet/mediatek/mtk_eth_reset.h b/drivers/net/ethernet/mediatek/mtk_eth_reset.h
new file mode 100644
index 0000000..00bc4ae
--- /dev/null
+++ b/drivers/net/ethernet/mediatek/mtk_eth_reset.h
@@ -0,0 +1,34 @@
+/* SPDX-License-Identifier: GPL-2.0
+ *
+ * Copyright (c) 2022 MediaTek Inc.
+ * Author: Henry Yen <henry.yen@mediatek.com>
+ */
+
+#ifndef MTK_ETH_RESET_H
+#define MTK_ETH_RESET_H
+
+/* Frame Engine Reset FSM */
+#define MTK_FE_START_RESET		(0x2000)
+#define MTK_FE_RESET_DONE		(0x2001)
+#define MTK_WIFI_RESET_DONE		(0x2002)
+#define MTK_WIFI_CHIP_ONLINE		(0x2003)
+#define MTK_WIFI_CHIP_OFFLINE		(0x2004)
+#define MTK_FE_STOP_TRAFFIC		(0x2005)
+#define MTK_FE_STOP_TRAFFIC_DONE	(0x2006)
+#define MTK_FE_START_TRAFFIC		(0x2007)
+#define MTK_FE_STOP_TRAFFIC_DONE_FAIL	(0x2008)
+#define MTK_FE_START_RESET_INIT		(0x2009)
+#define MTK_WIFI_L1SER_DONE		(0x200a)
+#define MTK_TOPS_DUMP_DONE		(0x3001)
+#define MTK_FE_RESET_NAT_DONE		(0x4001)
+
+extern struct completion wait_ser_done;
+extern struct completion wait_ack_done;
+extern struct completion wait_tops_done;
+extern int mtk_wifi_num;
+extern bool mtk_stop_fail;
+
+void mtk_set_pse_drop(u32 config);
+int mtk_eth_netdevice_event_init(struct mtk_eth *eth);
+
+#endif		/* MTK_ETH_RESET_H */
diff --git a/drivers/net/ethernet/mediatek/mtk_eth_soc.c b/drivers/net/ethernet/mediatek/mtk_eth_soc.c
index 64f6e83..7d713b6 100644
--- a/drivers/net/ethernet/mediatek/mtk_eth_soc.c
+++ b/drivers/net/ethernet/mediatek/mtk_eth_soc.c
@@ -37,6 +37,7 @@
 
 #include "mtk_eth_soc.h"
 #include "mtk_eth_dbg.h"
+#include "mtk_eth_reset.h"
 #include "mtk_wed.h"
 
 #if defined(CONFIG_NET_MEDIATEK_HNAT) || defined(CONFIG_NET_MEDIATEK_HNAT_MODULE)
@@ -5062,7 +5063,8 @@ static void mtk_hw_warm_reset(struct mtk_eth *eth)
 		if (MTK_HAS_CAPS(eth->soc->caps, MTK_RSTCTRL_PPE2))
 			rst_mask |= RSTCTRL_PPE2;
 
-		rst_mask |= RSTCTRL_WDMA0 | RSTCTRL_WDMA1 | RSTCTRL_WDMA2;
+		if (eth->reset.event == MTK_FE_START_RESET)
+			rst_mask |= RSTCTRL_WDMA0 | RSTCTRL_WDMA1 | RSTCTRL_WDMA2;
 	} else if (mtk_is_netsys_v2_or_greater(eth)) {
 		rst_mask = RSTCTRL_PPE0_V2;
 		if (MTK_HAS_CAPS(eth->soc->caps, MTK_RSTCTRL_PPE1))
@@ -5166,6 +5168,7 @@ static bool mtk_hw_check_dma_hang(struct mtk_eth *eth)
 		    wtx_busy && cdm_busy && oq_free) {
 			if (++eth->reset.wdma_hang_count[i] > 2) {
 				dev_warn(eth->dev, "detect WDMA%d Tx hang!\n", i);
+				eth->reset.event = MTK_FE_START_RESET;
 				eth->reset.wdma_hang_count[i] = 0;
 				ret = true;
 			}
@@ -5190,6 +5193,7 @@ static bool mtk_hw_check_dma_hang(struct mtk_eth *eth)
 	if (!qpse_fc && qfsm_hang && qfwd_hang) {
 		if (++eth->reset.qdma_hang_count > 2) {
 			dev_warn(eth->dev, "detect QDMA Tx hang !\n");
+			eth->reset.event = MTK_FE_STOP_TRAFFIC;
 			eth->reset.qdma_hang_count = 0;
 			ret = true;
 		}
@@ -5220,6 +5224,7 @@ static bool mtk_hw_check_dma_hang(struct mtk_eth *eth)
 		if (oq_hang && gmac_tx && (txgp_cnt == eth->reset.gdm_txgp_cnt[i])) {
 			if (++eth->reset.mac_tx_hang_count[i] > 2) {
 				dev_warn(eth->dev, "detect GMAC%d Tx hang!\n", i + 1);
+				eth->reset.event = MTK_FE_STOP_TRAFFIC;
 				eth->reset.mac_tx_hang_count[i] = 0;
 				ret = true;
 			}
@@ -5234,6 +5239,7 @@ static bool mtk_hw_check_dma_hang(struct mtk_eth *eth)
 		if (gmac_rx && (rxgp_cnt == eth->reset.gdm_rxgp_cnt[i])) {
 			if (++eth->reset.mac_rx_hang_count[i] > 2) {
 				dev_warn(eth->dev, "detect GMAC%d Rx hang!\n", i + 1);
+				eth->reset.event = MTK_FE_STOP_TRAFFIC;
 				eth->reset.mac_rx_hang_count[i] = 0;
 				ret = true;
 			}
@@ -5251,6 +5257,7 @@ static bool mtk_hw_check_dma_hang(struct mtk_eth *eth)
 		    ((gdm_txfsm == eth->reset.gdm_txfsm[i]) && (gdm_txfsm == 0x1033))) {
 			if (++eth->reset.gdm_tx_hang_count[i] > 2) {
 				dev_warn(eth->dev, "detect GDM%d Tx hang!\n", i + 1);
+				eth->reset.event = MTK_FE_STOP_TRAFFIC;
 				eth->reset.gdm_tx_hang_count[i] = 0;
 				ret = true;
 			}
@@ -5274,6 +5281,7 @@ static bool mtk_hw_check_dma_hang(struct mtk_eth *eth)
 		     (gdm_rxfsm == 0x23 || gdm_rxfsm == 0x24))) {
 			if (++eth->reset.gdm_rx_hang_count[i] > 2) {
 				dev_warn(eth->dev, "detect GDM%d Rx hang!\n", i + 1);
+				eth->reset.event = MTK_FE_STOP_TRAFFIC;
 				eth->reset.gdm_rx_hang_count[i] = 0;
 				ret = true;
 			}
@@ -5304,6 +5312,7 @@ static bool mtk_hw_check_dma_hang(struct mtk_eth *eth)
 	    ((cdma_rxfsm != 0) && (cdma_rxfsm != eth->reset.cdma_rxfsm))) {
 		if (++eth->reset.adma_hang_count > 2) {
 			dev_warn(eth->dev, "detect ADMA Rx hang!\n");
+			eth->reset.event = MTK_FE_STOP_TRAFFIC;
 			eth->reset.adma_hang_count = 0;
 			ret = true;
 		}
@@ -5797,7 +5806,41 @@ static void mtk_pending_work(struct work_struct *work)
 
 	mtk_save_qdma_cfg(eth);
 	mtk_prepare_for_reset(eth);
+#if defined(CONFIG_NET_MEDIATEK_HNAT) || defined(CONFIG_NET_MEDIATEK_HNAT_MODULE)
+	for (i = 0; i < MTK_MAX_DEVS; i++) {
+		if (!eth->netdev[i])
+			continue;
+
+		pr_info("send event:%x !\n", eth->reset.event);
+		if (eth->reset.event == MTK_FE_STOP_TRAFFIC)
+			call_netdevice_notifiers(MTK_FE_STOP_TRAFFIC,
+						 eth->netdev[i]);
+		else
+			call_netdevice_notifiers(MTK_FE_START_RESET,
+						 eth->netdev[i]);
+
+		rtnl_unlock();
+		if (mtk_wifi_num > 0) {
+			pr_info("waiting event from wifi\n");
+			wait_for_completion(&wait_ser_done);
+			if (mtk_is_netsys_v3_or_greater(eth) && mtk_stop_fail) {
+				rtnl_lock();
+				call_netdevice_notifiers(MTK_FE_START_RESET,
+							 eth->netdev[i]);
+				rtnl_unlock();
+				pr_info("waiting event when stop fail\n");
+				wait_for_completion(&wait_ser_done);
+				mtk_stop_fail = 0;
+			}
+		}
+		if (!try_wait_for_completion(&wait_tops_done))
+			pr_warn("wait for TOPS response timeout !\n");
+		rtnl_lock();
+		break;
+	}
+#else
 	mtk_wed_fe_reset();
+#endif
 	/* Run again reset preliminary configuration in order to avoid any
 	 * possible race during FE reset since it can run releasing RTNL lock.
 	 */
@@ -5838,6 +5881,34 @@ static void mtk_pending_work(struct work_struct *work)
 
 	mtk_mac_fe_reset_complete(eth, restart);
 
+#if defined(CONFIG_NET_MEDIATEK_HNAT) || defined(CONFIG_NET_MEDIATEK_HNAT_MODULE)
+	for (i = 0; i < MTK_MAX_DEVS; i++) {
+		if (!eth->netdev[i])
+			continue;
+
+		if (eth->reset.event == MTK_FE_STOP_TRAFFIC) {
+			pr_info("send MTK_FE_START_TRAFFIC event !\n");
+			call_netdevice_notifiers(MTK_FE_START_TRAFFIC,
+						 eth->netdev[i]);
+		} else {
+			pr_info("send MTK_FE_RESET_DONE event !\n");
+			call_netdevice_notifiers(MTK_FE_RESET_DONE,
+						 eth->netdev[i]);
+
+			if (mtk_is_netsys_v3_or_greater(eth) &&
+			    mtk_wifi_num > 0) {
+				pr_info("waiting done ack from wifi\n");
+				rtnl_unlock();
+				wait_for_completion(&wait_ack_done);
+				rtnl_lock();
+			}
+		}
+		call_netdevice_notifiers(MTK_FE_RESET_NAT_DONE,
+					 eth->netdev[i]);
+		break;
+	}
+#endif
+
 	clear_bit(MTK_RESETTING, &eth->state);
 
 	mtk_wed_fe_reset_complete();
@@ -7242,6 +7313,9 @@ static int mtk_probe(struct platform_device *pdev)
 	eth->rx_buf_len = MTK_MAX_RX_LENGTH;
 
 	platform_set_drvdata(pdev, eth);
+#if defined(CONFIG_NET_MEDIATEK_HNAT) || defined(CONFIG_NET_MEDIATEK_HNAT_MODULE)
+	mtk_eth_netdevice_event_init(eth);
+#endif
 	schedule_delayed_work(&eth->reset.monitor_work,
 			      MTK_DMA_MONITOR_TIMEOUT);
 
diff --git a/drivers/net/ethernet/mediatek/mtk_eth_soc.h b/drivers/net/ethernet/mediatek/mtk_eth_soc.h
index 792ff1d..97347ca 100644
--- a/drivers/net/ethernet/mediatek/mtk_eth_soc.h
+++ b/drivers/net/ethernet/mediatek/mtk_eth_soc.h
@@ -1761,7 +1761,9 @@ struct mtk_eth {
 
 	struct {
 		struct delayed_work monitor_work;
+		struct notifier_block netdevice_notifier;
 		atomic_t force;
+		u32 event;
 		u32 wdidx[3];
 		u32 adidx[3];
 		u32 gdm_txgp_cnt[3];
-- 
2.45.2

