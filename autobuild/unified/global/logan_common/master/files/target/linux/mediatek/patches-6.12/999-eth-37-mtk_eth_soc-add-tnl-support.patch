--- a/drivers/net/ethernet/mediatek/mtk_eth_soc.c
+++ b/drivers/net/ethernet/mediatek/mtk_eth_soc.c
@@ -327,6 +327,13 @@ static const char * const mtk_clks_sourc
 	"top_netsys_warp_sel",
 };
 
+u32 (*mtk_get_tnl_netsys_params)(struct sk_buff *skb) = NULL;
+EXPORT_SYMBOL(mtk_get_tnl_netsys_params);
+struct net_device *(*mtk_get_tnl_dev)(u8 tops_crsn) = NULL;
+EXPORT_SYMBOL(mtk_get_tnl_dev);
+void (*mtk_set_tops_crsn)(struct sk_buff *skb, u8 tops_crsn) = NULL;
+EXPORT_SYMBOL(mtk_set_tops_crsn);
+
 void mtk_w32(struct mtk_eth *eth, u32 val, unsigned reg)
 {
 	__raw_writel(val, eth->base + reg);
@@ -1765,6 +1772,7 @@ static void mtk_tx_set_dma_desc_v2(struc
 
 	WRITE_ONCE(desc->txd3, data);
 
+	data = 0;
 	 /* set forward port */
 	switch (mac->id) {
 	case MTK_GMAC1_ID:
@@ -1779,6 +1787,9 @@ static void mtk_tx_set_dma_desc_v2(struc
 	}
 
 	data |= TX_DMA_SWC_V2 | QID_BITS_V2(info->qid);
+
+	/* Set tport */
+	data |= FIELD_PREP(TX_DMA_TPORT_MASK, info->tport);
 	WRITE_ONCE(desc->txd4, data);
 
 	data = 0;
@@ -1799,7 +1810,11 @@ static void mtk_tx_set_dma_desc_v2(struc
 	WRITE_ONCE(desc->txd6, data);
 
 	WRITE_ONCE(desc->txd7, 0);
-	WRITE_ONCE(desc->txd8, 0);
+
+	data = 0;
+	data |= FIELD_PREP(TX_DMA_TOPS_ENTRY_MASK, info->tops_entry);
+	data |= FIELD_PREP(TX_DMA_CDRT_MASK, info->cdrt);
+	WRITE_ONCE(desc->txd8, data);
 }
 
 static void mtk_tx_set_dma_desc(struct net_device *dev, void *txd,
@@ -1916,6 +1931,7 @@ static int mtk_tx_map(struct sk_buff *sk
 	int i, frag_size = skb_headlen(skb);
 	bool gso_v4, gso_fraglist;
 	int offset = 0;
+	u32 params;
 
 	txq = netdev_get_tx_queue(dev, queue);
 	itxd = ring->next_free;
@@ -1938,6 +1954,26 @@ next:
 		.first = true,
 	};
 
+	if (mtk_get_tnl_netsys_params && !(skb->inner_protocol == IPPROTO_ESP)) {
+		params = mtk_get_tnl_netsys_params(skb);
+		txd_info.tops_entry = params & 0x000000FF;
+		txd_info.tport = (params & 0x0000FF00) >> 8;
+		txd_info.cdrt = (params & 0x00FF0000) >> 16;
+	}
+#if defined(CONFIG_NET_MEDIATEK_HNAT) || defined(CONFIG_NET_MEDIATEK_HNAT_MODULE)
+	else if (unlikely(skb->inner_protocol == IPPROTO_ESP &&
+		skb_hnat_cdrt(skb) && is_magic_tag_valid(skb))) {
+		txd_info.cdrt = skb_hnat_cdrt(skb);
+		skb_hnat_magic_tag(skb) = 0;
+#else
+	else if (unlikely(skb->inner_protocol == IPPROTO_ESP &&
+		skb_tnl_cdrt(skb) && is_tnl_tag_valid(skb))) {
+		txd_info.cdrt = skb_tnl_cdrt(skb);
+		skb_tnl_magic_tag(skb) = 0;
+#endif
+		txd_info.tport = EIP197_TPORT;
+	}
+
 	if (cur_skb != skb) {
 		struct tcphdr *th, *th2;
 
@@ -2605,13 +2641,14 @@ static int mtk_poll_rx(struct napi_struc
 	int done = 0, bytes = 0;
 	dma_addr_t dma_addr = DMA_MAPPING_ERROR;
 	int ppe_idx = 0;
+	u8 tops_crsn = 0;
 
 	if (unlikely(!ring))
 		goto rx_done;
 
 	while (done < budget) {
 		unsigned int pktlen, *rxdcsum;
-		struct net_device *netdev;
+		struct net_device *netdev = NULL;
 		u32 hash, reason;
 		int mac = 0;
 
@@ -2646,7 +2683,15 @@ static int mtk_poll_rx(struct napi_struc
 			     !eth->netdev[mac]))
 			goto release_desc;
 
-		netdev = eth->netdev[mac];
+		tops_crsn = RX_DMA_GET_TOPS_CRSN(trxd.rxd6);
+		if (mtk_get_tnl_dev && tops_crsn) {
+			netdev = mtk_get_tnl_dev(tops_crsn);
+			if (IS_ERR(netdev))
+				netdev = NULL;
+		}
+
+		if (!netdev)
+			netdev = eth->netdev[mac];
 		ppe_idx = eth->mac[mac]->ppe_idx;
 
 		if (unlikely(test_bit(MTK_RESETTING, &eth->state)))
@@ -2740,6 +2785,7 @@ static int mtk_poll_rx(struct napi_struc
 
 			skb_hnat_alg(skb) = 0;
 			skb_hnat_filled(skb) = 0;
+			skb_hnat_set_cdrt(skb, RX_DMA_GET_CDRT(trxd.rxd7));
 			skb_hnat_magic_tag(skb) = HNAT_MAGIC_TAG;
 			skb_hnat_set_tops(skb, 0);
 			skb_hnat_set_is_decap(skb, 0);
@@ -2755,6 +2801,8 @@ static int mtk_poll_rx(struct napi_struc
 				     __func__, skb_hnat_entry(skb), skb_hnat_sport(skb),
 				     skb_hnat_reason(skb), skb_hnat_alg(skb));
 #endif
+			if (mtk_set_tops_crsn && skb && tops_crsn)
+				mtk_set_tops_crsn(skb, tops_crsn);
 		}
 
 		skb->dev = netdev;
--- a/drivers/net/ethernet/mediatek/mtk_eth_soc.h
+++ b/drivers/net/ethernet/mediatek/mtk_eth_soc.h
@@ -440,6 +440,10 @@
 
 #define MTK_TX_DMA_BUF_SHIFT	8
 
+/* QDMA V2 descriptor txd8 */
+#define TX_DMA_CDRT_MASK           GENMASK(7, 0)
+#define TX_DMA_TOPS_ENTRY_MASK     GENMASK(13, 8)
+
 /* QDMA V2 descriptor txd6 */
 #define TX_DMA_INS_VLAN_V2	BIT(16)
 /* QDMA V2 descriptor txd5 */
@@ -449,6 +453,8 @@
 #define TX_DMA_SPTAG_V3         BIT(27)
 
 /* QDMA V2 descriptor txd4 */
+#define EIP197_TPORT			2
+#define TX_DMA_TPORT_MASK       GENMASK(3, 0)
 #define TX_DMA_FPORT_SHIFT_V2	8
 #define TX_DMA_FPORT_MASK_V2	0xf
 #define TX_DMA_SWC_V2		BIT(30)
@@ -531,6 +537,10 @@
 /* PDMA V2 descriptor rxd6 */
 #define RX_DMA_GET_FLUSH_RSN_V2	GENMASK(2, 0)
 #define RX_DMA_GET_AGG_CNT_V2	GENMASK(23, 16)
+#define RX_DMA_GET_TOPS_CRSN(x)	(((x) >> 24) & 0xff)
+
+/* PDMA V2 descriptor rxd7 */
+#define RX_DMA_GET_CDRT(x)	(((x) >> 8) & 0xff)
 
 /* PHY Polling and SMI Master Control registers */
 #define MTK_PPSC		0x10000
@@ -1469,6 +1479,9 @@ struct mtk_tx_dma_desc_info {
 	u32		size;
 	u16		vlan_tci;
 	u16		qid;
+	u8		cdrt;
+	u8		tport;
+	u8		tops_entry;
 	u8		gso:1;
 	u8		csum:1;
 	u8		vlan:1;
