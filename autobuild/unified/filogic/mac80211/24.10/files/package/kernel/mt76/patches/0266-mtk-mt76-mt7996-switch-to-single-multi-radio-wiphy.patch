From d1ec2768314a05da0c489313a87c824961528a3e Mon Sep 17 00:00:00 2001
From: Shayne Chen <shayne.chen@mediatek.com>
Date: Mon, 4 Nov 2024 10:34:05 +0800
Subject: [PATCH 266/277] mtk: mt76: mt7996: switch to single multi-radio wiphy

Signed-off-by: Shayne Chen <shayne.chen@mediatek.com>
---
 mac80211.c      |   1 +
 mt76.h          |   1 +
 mt7996/Makefile |   2 +-
 mt7996/eeprom.c |   1 +
 mt7996/init.c   | 306 ++++++++++++++++--------------
 mt7996/mac.c    |   6 +-
 mt7996/main.c   | 481 +++++++++++++++++++++++++++---------------------
 mt7996/mt7996.h |  32 ++--
 8 files changed, 459 insertions(+), 371 deletions(-)

diff --git a/mac80211.c b/mac80211.c
index 867b83bc..af761ed8 100644
--- a/mac80211.c
+++ b/mac80211.c
@@ -403,6 +403,7 @@ mt76_check_sband(struct mt76_phy *phy, struct mt76_sband *msband,
 		cfg80211_chandef_create(&phy->chandef, &sband->channels[0],
 					NL80211_CHAN_HT20);
 		phy->chan_state = &msband->chan[0];
+		phy->dev->band_phys[band] = phy;
 		return;
 	}
 
diff --git a/mt76.h b/mt76.h
index 77c83ac2..b7e781a7 100644
--- a/mt76.h
+++ b/mt76.h
@@ -1034,6 +1034,7 @@ struct mt76_phy {
 struct mt76_dev {
 	struct mt76_phy phy; /* must be first */
 	struct mt76_phy *phys[__MT_MAX_BAND];
+	struct mt76_phy *band_phys[NUM_NL80211_BANDS];
 
 	struct ieee80211_hw *hw;
 
diff --git a/mt7996/Makefile b/mt7996/Makefile
index dd652734..0de1555d 100644
--- a/mt7996/Makefile
+++ b/mt7996/Makefile
@@ -1,5 +1,5 @@
 # SPDX-License-Identifier: ISC
-EXTRA_CFLAGS += -Werror
+EXTRA_CFLAGS += -Werror -std=gnu11
 EXTRA_CFLAGS += -DCONFIG_MT76_LEDS
 EXTRA_CFLAGS += -DCONFIG_MTK_DEBUG
 EXTRA_CFLAGS += -DCONFIG_MTK_VENDOR
diff --git a/mt7996/eeprom.c b/mt7996/eeprom.c
index 2ae9aeac..57ea445b 100644
--- a/mt7996/eeprom.c
+++ b/mt7996/eeprom.c
@@ -476,6 +476,7 @@ int mt7996_eeprom_parse_hw_cap(struct mt7996_dev *dev, struct mt7996_phy *phy)
 
 	mphy->antenna_mask = BIT(nss) - 1;
 	mphy->chainmask = (BIT(path) - 1) << dev->chainshift[band_idx];
+	phy->orig_chainmask = mphy->chainmask;
 	dev->chainmask |= mphy->chainmask;
 	if (band_idx < MT_BAND2)
 		dev->chainshift[band_idx + 1] = dev->chainshift[band_idx] +
diff --git a/mt7996/init.c b/mt7996/init.c
index e36e6b17..0aed2bbb 100644
--- a/mt7996/init.c
+++ b/mt7996/init.c
@@ -14,49 +14,67 @@
 #include "coredump.h"
 #include "eeprom.h"
 
+static const struct ieee80211_iface_limit if_limits_global = {
+	.max = MT7996_MAX_INTERFACES * MT7996_MAX_RADIOS,
+	.types = BIT(NL80211_IFTYPE_STATION)
+		 | BIT(NL80211_IFTYPE_ADHOC)
+		 | BIT(NL80211_IFTYPE_AP)
+#ifdef CONFIG_MAC80211_MESH
+		 | BIT(NL80211_IFTYPE_MESH_POINT)
+#endif
+};
+
+static const struct ieee80211_iface_combination if_comb_global = {
+	.limits = &if_limits_global,
+	.n_limits = 1,
+	.max_interfaces = MT7996_MAX_INTERFACES * MT7996_MAX_RADIOS,
+	.num_different_channels = MT7996_MAX_RADIOS,
+	.radar_detect_widths = BIT(NL80211_CHAN_WIDTH_20_NOHT) |
+			       BIT(NL80211_CHAN_WIDTH_20) |
+			       BIT(NL80211_CHAN_WIDTH_40) |
+			       BIT(NL80211_CHAN_WIDTH_80) |
+			       BIT(NL80211_CHAN_WIDTH_160),
+};
+
 static const struct ieee80211_iface_limit if_limits[] = {
 	{
-		.max = 16 * 3,
+		.max = 16,
 		.types = BIT(NL80211_IFTYPE_AP)
 #ifdef CONFIG_MAC80211_MESH
 			 | BIT(NL80211_IFTYPE_MESH_POINT)
 #endif
 	}, {
-		.max = MT7996_MAX_INTERFACES * 3,
+		.max = MT7996_MAX_INTERFACES,
 		.types = BIT(NL80211_IFTYPE_STATION)
 	}
 };
 
-static const struct ieee80211_iface_combination if_comb[] = {
-	{
-		.limits = if_limits,
-		.n_limits = ARRAY_SIZE(if_limits),
-		.max_interfaces = MT7996_MAX_INTERFACES * 3,
-		.num_different_channels = 3,
-		.beacon_int_infra_match = true,
-		.radar_detect_widths = BIT(NL80211_CHAN_WIDTH_20_NOHT) |
-				       BIT(NL80211_CHAN_WIDTH_20) |
-				       BIT(NL80211_CHAN_WIDTH_40) |
-				       BIT(NL80211_CHAN_WIDTH_80) |
-				       BIT(NL80211_CHAN_WIDTH_160),
-		.beacon_int_min_gcd = 100,
-	}
+static const struct ieee80211_iface_combination if_comb = {
+	.limits = if_limits,
+	.n_limits = ARRAY_SIZE(if_limits),
+	.max_interfaces = MT7996_MAX_INTERFACES,
+	.num_different_channels = 1,
+	.beacon_int_infra_match = true,
+	.radar_detect_widths = BIT(NL80211_CHAN_WIDTH_20_NOHT) |
+			       BIT(NL80211_CHAN_WIDTH_20) |
+			       BIT(NL80211_CHAN_WIDTH_40) |
+			       BIT(NL80211_CHAN_WIDTH_80) |
+			       BIT(NL80211_CHAN_WIDTH_160),
+	.beacon_int_min_gcd = 100,
 };
 
-static const struct ieee80211_iface_combination if_comb_7992[] = {
-	{
-		.limits = if_limits,
-		.n_limits = ARRAY_SIZE(if_limits),
-		.max_interfaces = MT7996_MAX_INTERFACES * 2,
-		.num_different_channels = 2,
-		.beacon_int_infra_match = true,
-		.radar_detect_widths = BIT(NL80211_CHAN_WIDTH_20_NOHT) |
-				       BIT(NL80211_CHAN_WIDTH_20) |
-				       BIT(NL80211_CHAN_WIDTH_40) |
-				       BIT(NL80211_CHAN_WIDTH_80) |
-				       BIT(NL80211_CHAN_WIDTH_160),
-		.beacon_int_min_gcd = 100,
-	}
+static const struct ieee80211_iface_combination if_comb_7992 = {
+	.limits = if_limits,
+	.n_limits = ARRAY_SIZE(if_limits),
+	.max_interfaces = 16,
+	.num_different_channels = 1,
+	.beacon_int_infra_match = true,
+	.radar_detect_widths = BIT(NL80211_CHAN_WIDTH_20_NOHT) |
+			       BIT(NL80211_CHAN_WIDTH_20) |
+			       BIT(NL80211_CHAN_WIDTH_40) |
+			       BIT(NL80211_CHAN_WIDTH_80) |
+			       BIT(NL80211_CHAN_WIDTH_160),
+	.beacon_int_min_gcd = 100,
 };
 
 static const u8 mt7996_if_types_ext_capa_ap[] = {
@@ -229,28 +247,32 @@ static const struct thermal_cooling_device_ops mt7996_thermal_ops = {
 static void mt7996_unregister_thermal(struct mt7996_phy *phy)
 {
 	struct wiphy *wiphy = phy->mt76->hw->wiphy;
+	char name[sizeof("cooling_device%d")];
 
 	if (!phy->cdev)
 		return;
 
-	sysfs_remove_link(&wiphy->dev.kobj, "cooling_device");
+	snprintf(name, sizeof(name), "cooling_device%d", phy->mt76->band_idx);
+	sysfs_remove_link(&wiphy->dev.kobj, name);
 	thermal_cooling_device_unregister(phy->cdev);
 }
 
 static int mt7996_thermal_init(struct mt7996_phy *phy)
 {
 	struct wiphy *wiphy = phy->mt76->hw->wiphy;
+	char cname[sizeof("cooling_device%d")];
 	struct thermal_cooling_device *cdev;
 	struct device *hwmon;
 	const char *name;
 
-	name = devm_kasprintf(&wiphy->dev, GFP_KERNEL, "mt7996_%s",
-			      wiphy_name(wiphy));
+	name = devm_kasprintf(&wiphy->dev, GFP_KERNEL, "mt7996_%s.%d",
+			      wiphy_name(wiphy), phy->mt76->band_idx);
+	snprintf(cname, sizeof(cname), "cooling_device%d", phy->mt76->band_idx);
 
 	cdev = thermal_cooling_device_register(name, phy, &mt7996_thermal_ops);
 	if (!IS_ERR(cdev)) {
 		if (sysfs_create_link(&wiphy->dev.kobj, &cdev->device.kobj,
-				      "cooling_device") < 0)
+				      cname) < 0)
 			thermal_cooling_device_unregister(cdev);
 		else
 			phy->cdev = cdev;
@@ -377,17 +399,15 @@ static void __mt7996_init_txpower(struct mt7996_phy *phy,
 
 void mt7996_init_txpower(struct mt7996_phy *phy)
 {
-	struct ieee80211_hw *hw;
 	struct mt7996_phy *phy_2g, *phy_5g, *phy_6g;
 
 	if (!phy)
 		return;
 
-	hw = phy->mt76->hw;
 	/* FIXME refactor after single wiphy multiple radios merged */
-	phy_2g = mt7996_band_phy(hw, NL80211_BAND_2GHZ);
-	phy_5g = mt7996_band_phy(hw, NL80211_BAND_5GHZ);
-	phy_6g = mt7996_band_phy(hw, NL80211_BAND_6GHZ);
+	phy_2g = mt7996_band_phy(phy->dev, NL80211_BAND_2GHZ);
+	phy_5g = mt7996_band_phy(phy->dev, NL80211_BAND_5GHZ);
+	phy_6g = mt7996_band_phy(phy->dev, NL80211_BAND_6GHZ);
 
 	if (phy_2g && phy_2g->mt76->cap.has_2ghz)
 		__mt7996_init_txpower(phy_2g, &phy_2g->mt76->sband_2g.sband);
@@ -408,23 +428,84 @@ mt7996_regd_notifier(struct wiphy *wiphy,
 	memcpy(dev->mt76.alpha2, request->alpha2, sizeof(dev->mt76.alpha2));
 	dev->mt76.region = request->dfs_region;
 
-	if (dev->mt76.region == NL80211_DFS_UNSET)
-		mt7996_mcu_rdd_background_enable(phy, NULL);
+	mt7996_for_each_phy(dev, phy) {
+		if (dev->mt76.region == NL80211_DFS_UNSET)
+			mt7996_mcu_rdd_background_enable(phy, NULL);
 
-	mt7996_init_txpower(phy);
+		mt7996_init_txpower(phy);
+		phy->mt76->dfs_state = MT_DFS_STATE_UNKNOWN;
+		mt7996_dfs_init_radar_detector(phy);
+	}
+}
 
-	phy->mt76->dfs_state = MT_DFS_STATE_UNKNOWN;
-	mt7996_dfs_init_radar_detector(phy);
+static void
+mt7996_init_wiphy_band(struct ieee80211_hw *hw, struct mt7996_phy *phy)
+{
+	struct mt7996_dev *dev = phy->dev;
+	struct wiphy *wiphy = hw->wiphy;
+	int n_radios = hw->wiphy->n_radio;
+	struct wiphy_radio_freq_range *freq = &dev->radio_freqs[n_radios];
+	struct wiphy_radio *radio = &dev->radios[n_radios];
+
+	phy->slottime = 9;
+	phy->beacon_rate = -1;
+	phy->muru_onoff = OFDMA_UL | OFDMA_DL | MUMIMO_DL | MUMIMO_UL;
+
+	if (phy->mt76->cap.has_2ghz) {
+		phy->mt76->sband_2g.sband.ht_cap.cap |=
+			IEEE80211_HT_CAP_LDPC_CODING |
+			IEEE80211_HT_CAP_MAX_AMSDU;
+		phy->mt76->sband_2g.sband.ht_cap.ampdu_density =
+			IEEE80211_HT_MPDU_DENSITY_2;
+		freq->start_freq = 2400000;
+		freq->end_freq = 2500000;
+	} else if (phy->mt76->cap.has_5ghz) {
+		phy->mt76->sband_5g.sband.ht_cap.cap |=
+			IEEE80211_HT_CAP_LDPC_CODING |
+			IEEE80211_HT_CAP_MAX_AMSDU;
+
+		phy->mt76->sband_5g.sband.vht_cap.cap |=
+			IEEE80211_VHT_CAP_MAX_MPDU_LENGTH_11454 |
+			IEEE80211_VHT_CAP_MAX_A_MPDU_LENGTH_EXPONENT_MASK |
+			IEEE80211_VHT_CAP_SHORT_GI_160 |
+			IEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_160MHZ;
+		phy->mt76->sband_5g.sband.ht_cap.ampdu_density =
+			IEEE80211_HT_MPDU_DENSITY_1;
+
+		ieee80211_hw_set(hw, SUPPORTS_VHT_EXT_NSS_BW);
+		freq->start_freq = 5000000;
+		freq->end_freq = 5900000;
+	} else if (phy->mt76->cap.has_6ghz) {
+		freq->start_freq = 5900000;
+		freq->end_freq = 7200000;
+	} else {
+		return;
+	}
+
+	dev->radio_phy[n_radios] = phy;
+	radio->freq_range = freq;
+	radio->n_freq_range = 1;
+	radio->iface_combinations = is_mt7996(&dev->mt76) ? &if_comb : &if_comb_7992;
+	radio->n_iface_combinations = 1;
+	hw->wiphy->n_radio++;
+
+	wiphy->available_antennas_rx |= phy->mt76->chainmask;
+	wiphy->available_antennas_tx |= phy->mt76->chainmask;
+
+	mt76_set_stream_caps(phy->mt76, true);
+	mt7996_set_stream_vht_txbf_caps(phy);
+	mt7996_set_stream_he_eht_caps(phy);
+	mt7996_init_txpower(phy);
 }
 
 static void
 mt7996_init_wiphy(struct ieee80211_hw *hw, struct mtk_wed_device *wed)
 {
-	struct mt7996_phy *phy = mt7996_hw_phy(hw);
-	struct mt76_dev *mdev = &phy->dev->mt76;
+	struct mt7996_dev *dev = mt7996_hw_dev(hw);
+	struct mt76_dev *mdev = &dev->mt76;
 	struct wiphy *wiphy = hw->wiphy;
-	u16 max_subframes = phy->dev->has_eht ? IEEE80211_MAX_AMPDU_BUF_EHT :
-						IEEE80211_MAX_AMPDU_BUF_HE;
+	u16 max_subframes = dev->has_eht ? IEEE80211_MAX_AMPDU_BUF_EHT :
+					   IEEE80211_MAX_AMPDU_BUF_HE;
 
 	hw->queues = 4;
 	hw->max_rx_aggregation_subframes = max_subframes;
@@ -436,14 +517,15 @@ mt7996_init_wiphy(struct ieee80211_hw *hw, struct mtk_wed_device *wed)
 	hw->radiotap_timestamp.units_pos =
 		IEEE80211_RADIOTAP_TIMESTAMP_UNIT_US;
 
-	phy->slottime = 9;
-	phy->beacon_rate = -1;
-	phy->muru_onoff = OFDMA_UL | OFDMA_DL | MUMIMO_DL | MUMIMO_UL;
-
 	hw->sta_data_size = sizeof(struct mt7996_sta);
 	hw->vif_data_size = sizeof(struct mt7996_vif);
 	hw->chanctx_data_size = sizeof(struct mt7996_chanctx);
 
+	wiphy->iface_combinations = &if_comb_global;
+	wiphy->n_iface_combinations = 1;
+	wiphy->radio = dev->radios;
+
+#if 0
 	switch (mt76_chip(mdev)) {
 	case MT7996_DEVICE_ID:
 		wiphy->iface_combinations = if_comb;
@@ -458,6 +540,7 @@ mt7996_init_wiphy(struct ieee80211_hw *hw, struct mtk_wed_device *wed)
 		wiphy->mbssid_max_interfaces = 16 * 2;
 		break;
 	}
+#endif
 
 	wiphy->reg_notifier = mt7996_regd_notifier;
 	wiphy->flags |= WIPHY_FLAG_HAS_CHANNEL_SWITCH;
@@ -478,7 +561,7 @@ mt7996_init_wiphy(struct ieee80211_hw *hw, struct mtk_wed_device *wed)
 
 	wiphy_ext_feature_set(wiphy, NL80211_EXT_FEATURE_OPERATING_CHANNEL_VALIDATION);
 	wiphy_ext_feature_set(wiphy, NL80211_EXT_FEATURE_BEACON_PROTECTION);
-	if (mt7996_has_background_radar(phy->dev) &&
+	if (mt7996_has_background_radar(dev) &&
 	    (!mdev->dev->of_node ||
 	     !of_property_read_bool(mdev->dev->of_node,
 				    "mediatek,disable-radar-background")))
@@ -488,7 +571,7 @@ mt7996_init_wiphy(struct ieee80211_hw *hw, struct mtk_wed_device *wed)
 	ieee80211_hw_set(hw, HAS_RATE_CONTROL);
 	ieee80211_hw_set(hw, SUPPORTS_TX_ENCAP_OFFLOAD);
 	ieee80211_hw_set(hw, SUPPORTS_RX_DECAP_OFFLOAD);
-	ieee80211_hw_set(hw, WANT_MONITOR_VIF);
+	ieee80211_hw_set(hw, NO_VIRTUAL_MONITOR);
 	ieee80211_hw_set(hw, SUPPORTS_MULTI_BSSID);
 	ieee80211_hw_set(hw, CHANCTX_STA_CSA);
 	ieee80211_hw_set(hw, CONNECTION_MONITOR);
@@ -496,44 +579,12 @@ mt7996_init_wiphy(struct ieee80211_hw *hw, struct mtk_wed_device *wed)
 
 	hw->max_tx_fragments = 4;
 
-	if (phy->mt76->cap.has_2ghz) {
-		phy->mt76->sband_2g.sband.ht_cap.cap |=
-			IEEE80211_HT_CAP_LDPC_CODING |
-			IEEE80211_HT_CAP_MAX_AMSDU;
-		phy->mt76->sband_2g.sband.ht_cap.ampdu_density =
-			IEEE80211_HT_MPDU_DENSITY_2;
-	}
-
-	if (phy->mt76->cap.has_5ghz) {
-		phy->mt76->sband_5g.sband.ht_cap.cap |=
-			IEEE80211_HT_CAP_LDPC_CODING |
-			IEEE80211_HT_CAP_MAX_AMSDU;
-
-		phy->mt76->sband_5g.sband.vht_cap.cap |=
-			IEEE80211_VHT_CAP_MAX_MPDU_LENGTH_11454 |
-			IEEE80211_VHT_CAP_MAX_A_MPDU_LENGTH_EXPONENT_MASK |
-			IEEE80211_VHT_CAP_SHORT_GI_160 |
-			IEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_160MHZ;
-		phy->mt76->sband_5g.sband.ht_cap.ampdu_density =
-			IEEE80211_HT_MPDU_DENSITY_1;
-
-		ieee80211_hw_set(hw, SUPPORTS_VHT_EXT_NSS_BW);
-	}
-
 	/* init led callbacks */
 	if (IS_ENABLED(CONFIG_MT76_LEDS)) {
-		phy->mt76->leds.cdev.brightness_set = mt7996_led_set_brightness;
-		phy->mt76->leds.cdev.blink_set = mt7996_led_set_blink;
+		dev->mphy.leds.cdev.brightness_set = mt7996_led_set_brightness;
+		dev->mphy.leds.cdev.blink_set = mt7996_led_set_blink;
 	}
 
-	mt76_set_stream_caps(phy->mt76, true);
-	mt7996_set_stream_vht_txbf_caps(phy);
-	mt7996_set_stream_he_eht_caps(phy);
-	mt7996_init_txpower(phy);
-
-	wiphy->available_antennas_rx = phy->mt76->antenna_mask;
-	wiphy->available_antennas_tx = phy->mt76->antenna_mask;
-
 	wiphy->max_scan_ssids = 4;
 	wiphy->max_scan_ie_len = IEEE80211_MAX_DATA_LEN;
 
@@ -544,6 +595,8 @@ mt7996_init_wiphy(struct ieee80211_hw *hw, struct mtk_wed_device *wed)
 	wiphy->iftype_ext_capab = mt7996_iftypes_ext_capa;
 	wiphy->num_iftype_ext_capab = ARRAY_SIZE(mt7996_iftypes_ext_capa);
 	wiphy->features |= NL80211_FEATURE_AP_MODE_CHAN_WIDTH_CHANGE;
+
+	mt7996_init_wiphy_band(hw, &dev->phy);
 }
 
 static void
@@ -761,18 +814,15 @@ static void mt7996_init_chanctx(struct mt7996_phy *phy)
 	cfg80211_chandef_create(&phy->mt76->chandef, chan, NL80211_CHAN_HT20);
 }
 
-static int mt7996_register_phy(struct mt7996_dev *dev, struct mt7996_phy *phy,
-			       enum mt76_band_id band)
+static int mt7996_register_phy(struct mt7996_dev *dev, enum mt76_band_id band)
 {
+	struct mt7996_phy *phy;
 	struct mt76_phy *mphy;
 	u32 mac_ofs, hif1_ofs = 0;
 	int ret;
 	struct mtk_wed_device *wed = &dev->mt76.mmio.wed;
 
-	if (!mt7996_band_valid(dev, band) || band == MT_BAND0)
-		return 0;
-
-	if (phy)
+	if (!mt7996_band_valid(dev, band))
 		return 0;
 
 	if (dev->hif2) {
@@ -794,7 +844,7 @@ static int mt7996_register_phy(struct mt7996_dev *dev, struct mt7996_phy *phy,
 		}
 	}
 
-	mphy = mt76_alloc_phy(&dev->mt76, sizeof(*phy), &mt7996_ops, band);
+	mphy = mt76_alloc_radio_phy(&dev->mt76, sizeof(*phy), band);
 	if (!mphy)
 		return -ENOMEM;
 
@@ -827,7 +877,7 @@ static int mt7996_register_phy(struct mt7996_dev *dev, struct mt7996_phy *phy,
 	mt76_eeprom_override(mphy);
 
 	/* init wiphy according to mphy and phy */
-	mt7996_init_wiphy(mphy->hw, wed);
+	mt7996_init_wiphy_band(mphy->hw, phy);
 	ret = mt7996_init_tx_queues(mphy->priv,
 				    MT_TXQ_ID(band),
 				    MT7996_TX_RING_SIZE,
@@ -845,22 +895,12 @@ static int mt7996_register_phy(struct mt7996_dev *dev, struct mt7996_phy *phy,
 	if (ret)
 		goto error;
 
-	mt7996_init_chanctx(phy);
-
-	ret = mt7996_thermal_init(phy);
-	if (ret)
-		goto error;
-
 	if (mt7996_vow_should_enable(dev)) {
 		ret = mt7996_vow_init(phy);
 		if (ret)
 			goto error;
 	}
 
-	ret = mt7996_init_band_debugfs(phy);
-	if (ret)
-		goto error;
-
 	if (wed == &dev->mt76.mmio.wed_hif2 && mtk_wed_device_active(wed)) {
 		mt76_wr(dev, MT_INT_PCIE1_MASK_CSR, MT_INT_TX_RX_DONE_EXT);
 		mtk_wed_device_start(&dev->mt76.mmio.wed_hif2, MT_INT_TX_RX_DONE_EXT);
@@ -876,7 +916,6 @@ static int mt7996_register_phy(struct mt7996_dev *dev, struct mt7996_phy *phy,
 
 error:
 	mphy->dev->phys[band] = NULL;
-	ieee80211_free_hw(mphy->hw);
 	return ret;
 }
 
@@ -899,27 +938,16 @@ static int mt7996_unregister_csi(struct mt7996_phy *phy)
 #endif
 
 static void
-mt7996_unregister_phy(struct mt7996_phy *phy, enum mt76_band_id band)
+mt7996_unregister_phy(struct mt7996_phy *phy)
 {
-	struct mt76_phy *mphy;
-
 	if (!phy)
 		return;
 
-	/* TODO: FIXME: temp for normal mode single wiphy support */
-	if (!phy->dev->testmode_enable)
-		phy->mt76->hw = phy->mt76->ori_hw;
-
 #ifdef CONFIG_MTK_VENDOR
 	mt7996_unregister_csi(phy);
 #endif
 
 	mt7996_unregister_thermal(phy);
-
-	mphy = phy->dev->mt76.phys[band];
-	mt76_unregister_phy(mphy);
-	ieee80211_free_hw(mphy->hw);
-	phy->dev->mt76.phys[band] = NULL;
 }
 
 static void mt7996_init_work(struct work_struct *work)
@@ -1769,6 +1797,7 @@ void mt7996_set_stream_he_eht_caps(struct mt7996_phy *phy)
 int mt7996_register_device(struct mt7996_dev *dev)
 {
 	struct ieee80211_hw *hw = mt76_hw(dev);
+	struct mt7996_phy *phy;
 	int ret;
 
 	dev->phy.dev = dev;
@@ -1803,40 +1832,33 @@ int mt7996_register_device(struct mt7996_dev *dev)
 	mt7996_vendor_register(&dev->phy);
 #endif
 
-	ret = mt76_register_device(&dev->mt76, true, mt76_rates,
-				   ARRAY_SIZE(mt76_rates));
+	ret = mt7996_register_phy(dev, MT_BAND1);
 	if (ret)
 		return ret;
 
-	mt7996_init_chanctx(&dev->phy);
-
-	ret = mt7996_thermal_init(&dev->phy);
+	ret = mt7996_register_phy(dev, MT_BAND2);
 	if (ret)
 		return ret;
 
-	dev->mt76.token_threshold = MT7996_PER_BAND_TOKEN_SIZE;
-
-	ret = mt7996_init_dev_debugfs(&dev->phy);
+	ret = mt76_register_device(&dev->mt76, true, mt76_rates,
+				   ARRAY_SIZE(mt76_rates));
 	if (ret)
-		goto error;
+		return ret;
 
-	ret = mt7996_init_band_debugfs(&dev->phy);
+	ret = mt7996_init_dev_debugfs(&dev->phy);
 	if (ret)
 		goto error;
 
-	ret = mt7996_register_phy(dev, mt7996_phy2(dev), MT_BAND1);
-	if (ret)
-		return ret;
+	mt7996_for_each_phy(dev, phy) {
+		mt7996_init_chanctx(phy);
+		mt7996_thermal_init(phy);
+		ret = mt7996_init_band_debugfs(phy);
+		if (ret)
+			goto error;
 
-	ret = mt7996_register_phy(dev, mt7996_phy3(dev), MT_BAND2);
-	if (ret)
-		return ret;
+	}
 
-	hw->wiphy->bands[NL80211_BAND_2GHZ] = &dev->phy.mt76->sband_2g.sband;
-	if (mt7996_phy2(dev))
-		hw->wiphy->bands[NL80211_BAND_5GHZ] = &mt7996_phy2(dev)->mt76->sband_5g.sband;
-	if (mt7996_phy3(dev))
-		hw->wiphy->bands[NL80211_BAND_6GHZ] = &mt7996_phy3(dev)->mt76->sband_6g.sband;
+	dev->mt76.token_threshold = MT7996_PER_BAND_TOKEN_SIZE;
 
 	ieee80211_queue_work(mt76_hw(dev), &dev->init_work);
 
@@ -1866,8 +1888,8 @@ void mt7996_unregister_device(struct mt7996_dev *dev)
 	mt7996_unregister_thermal(&dev->phy);
 	mt7996_coredump_unregister(dev);
 	mt76_unregister_device(&dev->mt76);
-	mt7996_unregister_phy(mt7996_phy2(dev), MT_BAND1);
-	mt7996_unregister_phy(mt7996_phy3(dev), MT_BAND2);
+	mt7996_unregister_phy(mt7996_phy3(dev));
+	mt7996_unregister_phy(mt7996_phy2(dev));
 	mt7996_wed_rro_free(dev);
 	mt7996_mcu_exit(dev);
 	mt7996_tx_token_put(dev);
diff --git a/mt7996/mac.c b/mt7996/mac.c
index 64e4e2c6..5c67deb8 100644
--- a/mt7996/mac.c
+++ b/mt7996/mac.c
@@ -2263,19 +2263,19 @@ mt7996_mac_restart(struct mt7996_dev *dev)
 	ret = mt7996_txbf_init(dev);
 
 	if (test_bit(MT76_STATE_RUNNING, &dev->mphy.state)) {
-		ret = mt7996_run(dev->mphy.hw);
+		ret = mt7996_run(&dev->phy);
 		if (ret)
 			goto out;
 	}
 
 	if (phy2 && test_bit(MT76_STATE_RUNNING, &phy2->mt76->state)) {
-		ret = mt7996_run(phy2->mt76->hw);
+		ret = mt7996_run(phy2);
 		if (ret)
 			goto out;
 	}
 
 	if (phy3 && test_bit(MT76_STATE_RUNNING, &phy3->mt76->state)) {
-		ret = mt7996_run(phy3->mt76->hw);
+		ret = mt7996_run(phy3);
 		if (ret)
 			goto out;
 	}
diff --git a/mt7996/main.c b/mt7996/main.c
index 94caeb9b..907f3964 100644
--- a/mt7996/main.c
+++ b/mt7996/main.c
@@ -16,22 +16,6 @@ unsigned int mt7996_debug_mask = 0x1f;
 module_param(mt7996_debug_mask, uint, 0644);
 MODULE_PARM_DESC(mt7996_debug_mask, "Debugging mask");
 
-static bool mt7996_dev_running(struct mt7996_dev *dev)
-{
-	struct mt7996_phy *phy;
-
-	if (test_bit(MT76_STATE_RUNNING, &dev->mphy.state))
-		return true;
-
-	phy = mt7996_phy2(dev);
-	if (phy && test_bit(MT76_STATE_RUNNING, &phy->mt76->state))
-		return true;
-
-	phy = mt7996_phy3(dev);
-
-	return phy && test_bit(MT76_STATE_RUNNING, &phy->mt76->state);
-}
-
 static void mt7996_testmode_disable_all(struct mt7996_dev *dev)
 {
 	struct mt7996_phy *phy;
@@ -44,111 +28,66 @@ static void mt7996_testmode_disable_all(struct mt7996_dev *dev)
 	}
 }
 
-int mt7996_run(struct ieee80211_hw *hw)
+int mt7996_run(struct mt7996_phy *phy)
 {
-	struct mt7996_dev *dev = mt7996_hw_dev(hw);
-	bool running;
-	int band, ret;
-
-	running = mt7996_dev_running(dev);
-	if (!running) {
-		ret = mt7996_mcu_set_hdr_trans(dev, true);
-		if (ret)
-			goto out;
-
-		if (is_mt7992(&dev->mt76)) {
-			u8 queue = mt76_connac_lmac_mapping(IEEE80211_AC_VI);
-
-			ret = mt7996_mcu_cp_support(dev, queue);
-			if (ret)
-				goto out;
-#ifdef CONFIG_MTK_DEBUG
-			dev->sr_pp_enable = true;
-			dev->uba_enable = true;
-#endif
-		}
-	}
-
-	mt7996_testmode_disable_all(dev);
-
-	for (band = 0; band < NUM_NL80211_BANDS; band++) {
-		struct mt7996_phy *phy;
-
-		if (!hw->wiphy->bands[band])
-			continue;
-
-		phy = mt7996_band_phy(hw, band);
-
-		if (!phy || test_bit(MT76_STATE_RUNNING, &phy->mt76->state))
-			continue;
-
-		/* FIXME: In testmode (under the multi-wiphy model), only enable the radio
-		 * used by the current wiphy. This avoids the call trace of ieee80211_rx_list.
-		 */
-		if (dev->testmode_enable && phy->mt76->hw != hw)
-			continue;
+	struct mt7996_dev *dev = phy->dev;
+	int ret;
 
-		mt7996_mac_enable_nf(dev, phy->mt76->band_idx);
+	mt7996_mac_enable_nf(dev, phy->mt76->band_idx);
 
-		ret = mt7996_mcu_set_rts_thresh(phy, 0x92b);
-		if (ret)
-			goto out;
-
-		ret = mt7996_mcu_set_radio_en(phy, true);
-		if (ret)
-			goto out;
+	ret = mt7996_mcu_set_rts_thresh(phy, 0x92b);
+	if (ret)
+		return ret;
 
-		ret = mt7996_mcu_set_chan_info(phy, UNI_CHANNEL_RX_PATH, false);
-		if (ret)
-			goto out;
+	ret = mt7996_mcu_set_radio_en(phy, true);
+	if (ret)
+		return ret;
 
-		/* set a parking channel */
-		ret = mt7996_mcu_set_chan_info(phy, UNI_CHANNEL_SWITCH, false);
-		if (ret)
-			goto out;
+	ret = mt7996_mcu_set_chan_info(phy, UNI_CHANNEL_RX_PATH, false);
+	if (ret)
+		return ret;
 
-		ret = mt7996_mcu_set_thermal_throttling(phy, MT7996_THERMAL_THROTTLE_MAX);
-		if (ret)
-			goto out;
+	ret = mt7996_mcu_set_thermal_throttling(phy, MT7996_THERMAL_THROTTLE_MAX);
+	if (ret)
+		return ret;
 
-		ret = mt7996_mcu_set_thermal_protect(phy, true);
-		if (ret)
-			goto out;
+	ret = mt7996_mcu_set_thermal_protect(phy, true);
+	if (ret)
+		return ret;
 
-		ret = mt7996_mcu_set_scs(phy, SCS_ENABLE);
-		if (ret)
-			goto out;
+	ret = mt7996_mcu_set_scs(phy, SCS_ENABLE);
+	if (ret)
+		return ret;
 
 #ifdef CONFIG_MTK_DEBUG
-		phy->sr_enable = true;
-		phy->enhanced_sr_enable = true;
-		phy->thermal_protection_enable = true;
-		ret = mt7996_mcu_set_tx_power_ctrl(phy, UNI_TXPOWER_SKU_POWER_LIMIT_CTRL,
-						   dev->dbg.sku_disable ? 0 : phy->sku_limit_en);
-
-		ret = mt7996_mcu_set_tx_power_ctrl(phy, UNI_TXPOWER_BACKOFF_POWER_LIMIT_CTRL,
-						   dev->dbg.sku_disable ? 0 : phy->sku_path_en);
+	phy->sr_enable = true;
+	phy->enhanced_sr_enable = true;
+	phy->thermal_protection_enable = true;
+	ret = mt7996_mcu_set_tx_power_ctrl(phy, UNI_TXPOWER_SKU_POWER_LIMIT_CTRL,
+					   dev->dbg.sku_disable ? 0 : phy->sku_limit_en);
+
+	ret = mt7996_mcu_set_tx_power_ctrl(phy, UNI_TXPOWER_BACKOFF_POWER_LIMIT_CTRL,
+					   dev->dbg.sku_disable ? 0 : phy->sku_path_en);
 #else
-		ret = mt7996_mcu_set_tx_power_ctrl(phy, UNI_TXPOWER_SKU_POWER_LIMIT_CTRL,
-						   phy->sku_limit_en);
-		ret = mt7996_mcu_set_tx_power_ctrl(phy, UNI_TXPOWER_BACKOFF_POWER_LIMIT_CTRL,
-						   phy->sku_path_en);
+	ret = mt7996_mcu_set_tx_power_ctrl(phy, UNI_TXPOWER_SKU_POWER_LIMIT_CTRL,
+					   phy->sku_limit_en);
+	ret = mt7996_mcu_set_tx_power_ctrl(phy, UNI_TXPOWER_BACKOFF_POWER_LIMIT_CTRL,
+					   phy->sku_path_en);
 #endif
-		if (ret)
-			goto out;
+	if (ret)
+		return ret;
 
-		set_bit(MT76_STATE_RUNNING, &phy->mt76->state);
+	set_bit(MT76_STATE_RUNNING, &phy->mt76->state);
 
-		ieee80211_queue_delayed_work(hw, &phy->mt76->mac_work,
-					     MT7996_WATCHDOG_TIME);
+	ieee80211_queue_delayed_work(dev->mphy.hw, &phy->mt76->mac_work,
+				     MT7996_WATCHDOG_TIME);
 
-		if (!running)
-			mt7996_mac_reset_counters(phy);
+	if (!phy->counter_reset) {
+		mt7996_mac_reset_counters(phy);
+		phy->counter_reset = true;
 	}
 
-	ieee80211_queue_delayed_work(mt76_hw(dev), &dev->scs_work, HZ);
-out:
-	return ret;
+	return 0;
 }
 
 static int mt7996_start(struct ieee80211_hw *hw)
@@ -156,49 +95,52 @@ static int mt7996_start(struct ieee80211_hw *hw)
 	struct mt7996_dev *dev = mt7996_hw_dev(hw);
 	int ret;
 
-	/* only allow settings from hw0 for normal mode */
-	if (!dev->testmode_enable && hw != dev->phy.mt76->hw)
-		return -1;
-
 	flush_work(&dev->init_work);
 
 	mutex_lock(&dev->mt76.mutex);
-	ret = mt7996_run(hw);
+	ret = mt7996_mcu_set_hdr_trans(dev, true);
+	if (!ret && is_mt7992(&dev->mt76)) {
+		u8 queue = mt76_connac_lmac_mapping(IEEE80211_AC_VI);
+
+		ret = mt7996_mcu_cp_support(dev, queue);
+#ifdef CONFIG_MTK_DEBUG
+		dev->sr_pp_enable = true;
+		dev->uba_enable = true;
+#endif
+	}
+
+	mt7996_testmode_disable_all(dev);
+
 	mutex_unlock(&dev->mt76.mutex);
 
+	ieee80211_queue_delayed_work(hw, &dev->scs_work, HZ);
+
 	return ret;
 }
 
-static void mt7996_stop(struct ieee80211_hw *hw, bool suspend)
+static void mt7996_stop_phy(struct mt7996_phy *phy)
 {
-	struct mt7996_dev *dev = mt7996_hw_dev(hw);
-	int band;
+	struct mt7996_dev *dev = phy->dev;
 
-	/* only allow settings from hw0 for normal mode */
-	if (!dev->testmode_enable && hw != dev->phy.mt76->hw)
+	if (!phy || !test_bit(MT76_STATE_RUNNING, &phy->mt76->state))
 		return;
 
-	cancel_delayed_work_sync(&dev->scs_work);
+	cancel_delayed_work_sync(&phy->mt76->mac_work);
 
-	for (band = 0; band < NUM_NL80211_BANDS; band++) {
-		struct mt7996_phy *phy;
+	mutex_lock(&dev->mt76.mutex);
 
-		if (!hw->wiphy->bands[band])
-			continue;
+	mt7996_mcu_set_radio_en(phy, false);
 
-		phy = mt7996_band_phy(hw, band);
+	clear_bit(MT76_STATE_RUNNING, &phy->mt76->state);
 
-		if (!phy || !test_bit(MT76_STATE_RUNNING, &phy->mt76->state) ||
-		    (phy->chanctx && phy->chanctx->nbss_assigned))
-			continue;
+	mutex_unlock(&dev->mt76.mutex);
+}
 
-		cancel_delayed_work_sync(&phy->mt76->mac_work);
+static void mt7996_stop(struct ieee80211_hw *hw, bool suspend)
+{
+	struct mt7996_dev *dev = mt7996_hw_dev(hw);
 
-		mutex_lock(&dev->mt76.mutex);
-		mt7996_mcu_set_radio_en(phy, false);
-		clear_bit(MT76_STATE_RUNNING, &phy->mt76->state);
-		mutex_unlock(&dev->mt76.mutex);
-	}
+	cancel_delayed_work_sync(&dev->scs_work);
 }
 
 static inline int get_free_idx(u32 mask, u8 start, u8 end)
@@ -486,13 +428,58 @@ error:
 	return ret;
 }
 
+static void mt7996_phy_set_rxfilter(struct mt7996_phy *phy)
+{
+	struct mt7996_dev *dev = phy->dev;
+	u32 ctl_flags = MT_WF_RFCR1_DROP_ACK |
+			MT_WF_RFCR1_DROP_BF_POLL |
+			MT_WF_RFCR1_DROP_BA |
+			MT_WF_RFCR1_DROP_CFEND |
+			MT_WF_RFCR1_DROP_CFACK;
+	u32 filter = phy->rxfilter;
+
+	if (filter & MT_WF_RFCR_DROP_OTHER_UC) {
+		filter |= MT_WF_RFCR_DROP_CTS |
+			  MT_WF_RFCR_DROP_RTS |
+			  MT_WF_RFCR_DROP_CTL_RSV |
+			  MT_WF_RFCR_DROP_FCSFAIL;
+	}
+
+	mt76_wr(dev, MT_WF_RFCR(phy->mt76->band_idx), filter);
+	if (filter & MT_WF_RFCR_DROP_CTL_RSV)
+		mt76_set(dev, MT_WF_RFCR1(phy->mt76->band_idx), ctl_flags);
+	else
+		mt76_clear(dev, MT_WF_RFCR1(phy->mt76->band_idx), ctl_flags);
+}
+
+static void mt7996_set_monitor(struct mt7996_phy *phy, bool enabled)
+{
+	struct mt7996_dev *dev = phy->dev;
+
+	if (!phy)
+		return;
+
+	if (enabled == !(phy->rxfilter & MT_WF_RFCR_DROP_OTHER_UC))
+		return;
+
+	if (!enabled)
+		phy->rxfilter |= MT_WF_RFCR_DROP_OTHER_UC;
+	else
+		phy->rxfilter &= ~MT_WF_RFCR_DROP_OTHER_UC;
+
+	mt76_rmw_field(dev, MT_DMA_DCR0(phy->mt76->band_idx),
+		       MT_DMA_DCR0_RXD_G5_EN, enabled);
+	mt7996_phy_set_rxfilter(phy);
+}
+
 static int mt7996_add_interface(struct ieee80211_hw *hw,
 			        struct ieee80211_vif *vif)
 {
 	struct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;
+	struct wireless_dev *wdev = ieee80211_vif_to_wdev(vif);
 	struct mt7996_dev *dev = mt7996_hw_dev(hw);
 	struct mt7996_phy *phy = mt7996_hw_phy(hw);
-	int ret = 0;
+	int i, err = 0;
 
 	mutex_lock(&dev->mt76.mutex);
 	if (vif->type == NL80211_IFTYPE_MONITOR &&
@@ -505,6 +492,21 @@ static int mt7996_add_interface(struct ieee80211_hw *hw,
 		return -EINVAL;
 	}
 
+	for (i = 0; i < MT7996_MAX_RADIOS; i++) {
+		struct mt7996_phy *phy = dev->radio_phy[i];
+
+		if (!phy || !(wdev->radio_mask & BIT(i)) ||
+		    test_bit(MT76_STATE_RUNNING, &phy->mt76->state))
+			continue;
+
+		err = mt7996_run(phy);
+		if (err)
+			goto out;
+
+		if (vif->type == NL80211_IFTYPE_MONITOR)
+			mt7996_set_monitor(phy, true);
+	}
+
 	INIT_DELAYED_WORK(&mvif->beacon_mon_work, mt7996_beacon_mon_work);
 	mvif->dev = dev;
 	mvif->hw = hw;
@@ -515,10 +517,27 @@ static int mt7996_add_interface(struct ieee80211_hw *hw,
 	       sizeof(mvif->band_to_link));
 
 	if (vif->type == NL80211_IFTYPE_STATION)
-		ret = mt7996_add_bss_conf(phy, vif, &vif->bss_conf);
+		err = mt7996_add_bss_conf(phy, vif, &vif->bss_conf);
+
+out:
 	mutex_unlock(&dev->mt76.mutex);
 
-	return ret;
+	return err;
+}
+
+struct mt7996_radio_data {
+	u32 active_mask;
+	u32 monitor_mask;
+};
+
+static void mt7996_remove_iter(void *data, u8 *mac, struct ieee80211_vif *vif)
+{
+	struct wireless_dev *wdev = ieee80211_vif_to_wdev(vif);
+	struct mt7996_radio_data *rdata = data;
+
+	rdata->active_mask |= wdev->radio_mask;
+	if (vif->type == NL80211_IFTYPE_MONITOR)
+		rdata->monitor_mask |= wdev->radio_mask;
 }
 
 static void mt7996_remove_interface(struct ieee80211_hw *hw,
@@ -529,6 +548,11 @@ static void mt7996_remove_interface(struct ieee80211_hw *hw,
 	struct mt7996_bss_conf *mconf;
 	struct mt7996_dev *dev = mt7996_hw_dev(hw);
 	struct mt7996_phy *phy = mt7996_hw_phy(hw);
+	struct mt7996_radio_data rdata = {};
+	int i;
+
+	ieee80211_iterate_active_interfaces_mtx(hw, 0, mt7996_remove_iter,
+						&rdata);
 
 	cancel_delayed_work_sync(&phy->scan_work);
 	cancel_delayed_work_sync(&phy->roc_complete_work);
@@ -554,6 +578,17 @@ static void mt7996_remove_interface(struct ieee80211_hw *hw,
 
 out:
 	mutex_unlock(&dev->mt76.mutex);
+
+	for (i = 0; i < MT7996_MAX_RADIOS; i++) {
+		struct mt7996_phy *phy = dev->radio_phy[i];
+
+		if (!phy)
+			continue;
+		if (!(rdata.monitor_mask & BIT(i)))
+			mt7996_set_monitor(phy, false);
+		if (!(rdata.active_mask & BIT(i)))
+			mt7996_stop_phy(phy);
+	}
 }
 
 int mt7996_set_channel(struct mt76_phy *mphy)
@@ -702,26 +737,6 @@ out:
 
 static int mt7996_config(struct ieee80211_hw *hw, u32 changed)
 {
-	struct mt7996_dev *dev = mt7996_hw_dev(hw);
-	struct mt7996_phy *phy = mt7996_hw_phy(hw);
-
-	mutex_lock(&dev->mt76.mutex);
-
-	if (changed & IEEE80211_CONF_CHANGE_MONITOR) {
-		bool enabled = !!(hw->conf.flags & IEEE80211_CONF_MONITOR);
-
-		if (!enabled)
-			phy->rxfilter |= MT_WF_RFCR_DROP_OTHER_UC;
-		else
-			phy->rxfilter &= ~MT_WF_RFCR_DROP_OTHER_UC;
-
-		mt76_rmw_field(dev, MT_DMA_DCR0(phy->mt76->band_idx),
-			       MT_DMA_DCR0_RXD_G5_EN, enabled);
-		mt76_wr(dev, MT_WF_RFCR(phy->mt76->band_idx), phy->rxfilter);
-	}
-
-	mutex_unlock(&dev->mt76.mutex);
-
 	return 0;
 }
 
@@ -762,35 +777,18 @@ static void mt7996_configure_filter(struct ieee80211_hw *hw,
 				    u64 multicast)
 {
 	struct mt7996_dev *dev = mt7996_hw_dev(hw);
-	struct mt7996_phy *phy = mt7996_hw_phy(hw);
-	u32 ctl_flags = MT_WF_RFCR1_DROP_ACK |
-			MT_WF_RFCR1_DROP_BF_POLL |
-			MT_WF_RFCR1_DROP_BA |
-			MT_WF_RFCR1_DROP_CFEND |
-			MT_WF_RFCR1_DROP_CFACK;
+	struct mt7996_phy *phy;
+	u32 filter_mask = 0, filter_set = 0;
 	u32 flags = 0;
-	u8 band;
 
-#define MT76_FILTER(_flag, _hw) do {					\
-		flags |= *total_flags & FIF_##_flag;			\
-		phy->rxfilter &= ~(_hw);				\
-		phy->rxfilter |= !(flags & FIF_##_flag) * (_hw);	\
+#define MT76_FILTER(_flag, _hw) do {				\
+		flags |= *total_flags & FIF_##_flag;		\
+		filter_mask |= (_hw);				\
+		filter_set |= !(flags & FIF_##_flag) * (_hw);	\
 	} while (0)
 
 	mutex_lock(&dev->mt76.mutex);
 
-	phy->rxfilter &= ~(MT_WF_RFCR_DROP_OTHER_BSS |
-			   MT_WF_RFCR_DROP_OTHER_BEACON |
-			   MT_WF_RFCR_DROP_FRAME_REPORT |
-			   MT_WF_RFCR_DROP_PROBEREQ |
-			   MT_WF_RFCR_DROP_MCAST_FILTERED |
-			   MT_WF_RFCR_DROP_MCAST |
-			   MT_WF_RFCR_DROP_BCAST |
-			   MT_WF_RFCR_DROP_DUPLICATE |
-			   MT_WF_RFCR_DROP_A2_BSSID |
-			   MT_WF_RFCR_DROP_UNWANTED_CTL |
-			   MT_WF_RFCR_DROP_STBC_MULTI);
-
 	MT76_FILTER(OTHER_BSS, MT_WF_RFCR_DROP_OTHER_TIM |
 			       MT_WF_RFCR_DROP_A3_MAC |
 			       MT_WF_RFCR_DROP_A3_BSSID);
@@ -803,21 +801,21 @@ static void mt7996_configure_filter(struct ieee80211_hw *hw,
 
 	*total_flags = flags;
 
-	/* configure rx filter to all affliated phy */
-	for (band = 0; band < __MT_MAX_BAND; band++) {
-		struct mt7996_phy *tmp;
-
-		if (!hw->wiphy->bands[band])
-			continue;
-
-		tmp = dev->mt76.phys[band]->priv;
-		tmp->rxfilter = phy->rxfilter;
-		mt76_wr(dev, MT_WF_RFCR(tmp->mt76->band_idx), phy->rxfilter);
-
-		if (*total_flags & FIF_CONTROL)
-			mt76_clear(dev, MT_WF_RFCR1(tmp->mt76->band_idx), ctl_flags);
-		else
-			mt76_set(dev, MT_WF_RFCR1(tmp->mt76->band_idx), ctl_flags);
+	mt7996_for_each_phy(dev, phy) {
+		phy->rxfilter &= ~(MT_WF_RFCR_DROP_OTHER_BSS |
+				   MT_WF_RFCR_DROP_OTHER_BEACON |
+				   MT_WF_RFCR_DROP_FRAME_REPORT |
+				   MT_WF_RFCR_DROP_PROBEREQ |
+				   MT_WF_RFCR_DROP_MCAST_FILTERED |
+				   MT_WF_RFCR_DROP_MCAST |
+				   MT_WF_RFCR_DROP_BCAST |
+				   MT_WF_RFCR_DROP_DUPLICATE |
+				   MT_WF_RFCR_DROP_A2_BSSID |
+				   MT_WF_RFCR_DROP_UNWANTED_CTL |
+				   MT_WF_RFCR_DROP_STBC_MULTI |
+				   filter_mask);
+		phy->rxfilter |= filter_set;
+		mt7996_phy_set_rxfilter(phy);
 	}
 
 	mutex_unlock(&dev->mt76.mutex);
@@ -1080,7 +1078,7 @@ mt7996_channel_switch_beacon(struct ieee80211_hw *hw,
 {
 	struct mt7996_dev *dev = mt7996_hw_dev(hw);
 	struct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;
-	struct mt7996_phy *phy = mt7996_band_phy(hw, chandef->chan->band);
+	struct mt7996_phy *phy = mt7996_band_phy(dev, chandef->chan->band);
 	struct ieee80211_bss_conf *conf;
 	struct mt7996_bss_conf *mconf;
 	u16 valid_links = vif->valid_links ?: BIT(0);
@@ -1130,7 +1128,8 @@ mt7996_post_channel_switch(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 			   struct ieee80211_bss_conf *link_conf)
 {
 	struct cfg80211_chan_def *chandef = &link_conf->chanreq.oper;
-	struct mt7996_phy *phy = mt7996_band_phy(hw, chandef->chan->band);
+	struct mt7996_dev *dev = mt7996_hw_dev(hw);
+	struct mt7996_phy *phy = mt7996_band_phy(dev, chandef->chan->band);
 	int ret;
 
 	ret = cfg80211_chandef_dfs_required(hw->wiphy, chandef, NL80211_IFTYPE_AP);
@@ -1609,12 +1608,20 @@ unlock:
 
 static int mt7996_set_rts_threshold(struct ieee80211_hw *hw, u32 val)
 {
-	struct mt7996_phy *phy = mt7996_hw_phy(hw);
-	int ret;
+	struct mt7996_dev *dev = mt7996_hw_dev(hw);
+	int i, ret;
 
-	mutex_lock(&phy->dev->mt76.mutex);
-	ret = mt7996_mcu_set_rts_thresh(phy, val);
-	mutex_unlock(&phy->dev->mt76.mutex);
+	mutex_lock(&dev->mt76.mutex);
+
+	for (i = 0; i < hw->wiphy->n_radio; i++) {
+		struct mt7996_phy *phy = dev->radio_phy[i];
+
+		ret = mt7996_mcu_set_rts_thresh(phy, val);
+		if (ret)
+			break;
+	}
+
+	mutex_unlock(&dev->mt76.mutex);
 
 	return ret;
 }
@@ -1685,16 +1692,21 @@ static int
 mt7996_get_stats(struct ieee80211_hw *hw,
 		 struct ieee80211_low_level_stats *stats)
 {
-	struct mt7996_phy *phy = mt7996_hw_phy(hw);
 	struct mt7996_dev *dev = mt7996_hw_dev(hw);
-	struct mt76_mib_stats *mib = &phy->mib;
+	int i;
 
 	mutex_lock(&dev->mt76.mutex);
 
-	stats->dot11RTSSuccessCount = mib->rts_cnt;
-	stats->dot11RTSFailureCount = mib->rts_retries_cnt;
-	stats->dot11FCSErrorCount = mib->fcs_err_cnt;
-	stats->dot11ACKFailureCount = mib->ack_fail_cnt;
+	memset(stats, 0, sizeof(*stats));
+	for (i = 0; i < hw->wiphy->n_radio; i++) {
+		struct mt7996_phy *phy = dev->radio_phy[i];
+		struct mt76_mib_stats *mib = &phy->mib;
+
+		stats->dot11RTSSuccessCount += mib->rts_cnt;
+		stats->dot11RTSFailureCount += mib->rts_retries_cnt;
+		stats->dot11FCSErrorCount += mib->fcs_err_cnt;
+		stats->dot11ACKFailureCount += mib->ack_fail_cnt;
+	}
 
 	mutex_unlock(&dev->mt76.mutex);
 
@@ -1817,6 +1829,7 @@ mt7996_set_coverage_class(struct ieee80211_hw *hw, s16 coverage_class)
 	mutex_unlock(&dev->mt76.mutex);
 }
 
+#if 0
 static int
 mt7996_set_antenna(struct ieee80211_hw *hw, u32 tx_ant, u32 rx_ant)
 {
@@ -1846,7 +1859,7 @@ mt7996_set_antenna(struct ieee80211_hw *hw, u32 tx_ant, u32 rx_ant)
 		if (!hw->wiphy->bands[band])
 			continue;
 
-		phy = mt7996_band_phy(hw, band);
+		phy = mt7996_band_phy(dev, bandid);
 		if (!phy)
 			continue;
 
@@ -1872,6 +1885,44 @@ mt7996_set_antenna(struct ieee80211_hw *hw, u32 tx_ant, u32 rx_ant)
 
 	return 0;
 }
+#endif
+
+static int
+mt7996_set_antenna(struct ieee80211_hw *hw, u32 tx_ant, u32 rx_ant)
+{
+	struct mt7996_dev *dev = mt7996_hw_dev(hw);
+	int i;
+
+	if (tx_ant != rx_ant)
+		return -EINVAL;
+
+	for (i = 0; i < hw->wiphy->n_radio; i++) {
+		struct mt7996_phy *phy = dev->radio_phy[i];
+
+		if (!(tx_ant & phy->orig_chainmask))
+			return -EINVAL;
+	}
+
+	mutex_lock(&dev->mt76.mutex);
+
+	for (i = 0; i < hw->wiphy->n_radio; i++) {
+		struct mt7996_phy *phy = dev->radio_phy[i];
+		u8 band_idx = phy->mt76->band_idx;
+		u8 shift = dev->chainshift[band_idx];
+
+		phy->mt76->chainmask = tx_ant & phy->orig_chainmask;
+		phy->mt76->antenna_mask = phy->mt76->chainmask >> shift;
+
+		mt76_set_stream_caps(phy->mt76, true);
+		mt7996_set_stream_vht_txbf_caps(phy);
+		mt7996_set_stream_he_eht_caps(phy);
+		// mt7996_mcu_set_txpower_sku(phy);
+	}
+
+	mutex_unlock(&dev->mt76.mutex);
+
+	return 0;
+}
 
 static void mt7996_sta_statistics(struct ieee80211_hw *hw,
 				  struct ieee80211_vif *vif,
@@ -2315,6 +2366,9 @@ void mt7996_get_et_stats(struct ieee80211_hw *hw,
 	/* See mt7996_ampdu_stat_read_phy, etc */
 	int i, ei = 0;
 
+	if (!phy)
+		return;
+
 	mutex_lock(&dev->mt76.mutex);
 	mconf = mconf_dereference_protected(mvif, mvif->master_link_id);
 	wi.idx = mconf->mt76.idx,
@@ -2468,8 +2522,8 @@ static int
 mt7996_set_radar_background(struct ieee80211_hw *hw,
 			    struct cfg80211_chan_def *chandef)
 {
-	struct mt7996_phy *phy = mt7996_band_phy(hw, NL80211_BAND_5GHZ);
-	struct mt7996_dev *dev = phy->dev;
+	struct mt7996_dev *dev = mt7996_hw_dev(hw);
+	struct mt7996_phy *phy = mt7996_band_phy(dev, NL80211_BAND_5GHZ);
 	int ret = -EINVAL;
 	bool running;
 	struct cfg80211_chan_def ifem_chandef = {};
@@ -2617,8 +2671,8 @@ mt7996_hw_scan(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 	       struct ieee80211_scan_request *hw_req)
 {
 	struct cfg80211_scan_request *req = &hw_req->req;
-	struct mt7996_phy *phy = mt7996_band_phy(hw, req->channels[0]->band);
 	struct mt7996_dev *dev = mt7996_hw_dev(hw);
+	struct mt7996_phy *phy = mt7996_band_phy(dev, req->channels[0]->band);
 	struct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;
 	struct mt7996_bss_conf *mconf;
 	int ret;
@@ -2725,6 +2779,7 @@ static void
 mt7996_cancel_hw_scan(struct ieee80211_hw *hw, struct ieee80211_vif *vif)
 {
 	// struct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;
+	struct mt7996_dev *dev = mt7996_hw_dev(hw);
 	int band;
 
 	for (band = 0; band < NUM_NL80211_BANDS; band++) {
@@ -2733,7 +2788,7 @@ mt7996_cancel_hw_scan(struct ieee80211_hw *hw, struct ieee80211_vif *vif)
 		if (!hw->wiphy->bands[band])
 			continue;
 
-		phy = mt7996_band_phy(hw, band);
+		phy = mt7996_band_phy(dev, band);
 		if (!test_bit(MT76_SCANNING, &phy->mt76->state))
 			continue;
 
@@ -2800,6 +2855,7 @@ mt7996_remain_on_channel(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 			 struct ieee80211_channel *chan, int duration,
 			 enum ieee80211_roc_type type)
 {
+	struct mt7996_dev *dev = mt7996_hw_dev(hw);
 	struct cfg80211_chan_def chandef = {};
 	struct mt7996_bss_conf *mconf;
 	struct mt7996_vif *mvif;
@@ -2809,7 +2865,7 @@ mt7996_remain_on_channel(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 	if (!chan)
 		return -EINVAL;
 
-	phy = mt7996_band_phy(hw, chan->band);
+	phy = mt7996_band_phy(dev, chan->band);
 
 	if (!phy)
 		return -EINVAL;
@@ -2894,6 +2950,7 @@ error_unlock:
 static int
 mt7996_cancel_remain_on_channel(struct ieee80211_hw *hw, struct ieee80211_vif *vif)
 {
+	struct mt7996_dev *dev = mt7996_hw_dev(hw);
 	int band;
 	struct mt7996_phy *phy;
 
@@ -2901,7 +2958,7 @@ mt7996_cancel_remain_on_channel(struct ieee80211_hw *hw, struct ieee80211_vif *v
 		if (!hw->wiphy->bands[band])
 			continue;
 
-		phy = mt7996_band_phy(hw, band);
+		phy = mt7996_band_phy(dev, band);
 		if (!phy || !test_bit(MT76_STATE_ROC, &phy->mt76->state))
 			continue;
 
@@ -2914,9 +2971,9 @@ mt7996_cancel_remain_on_channel(struct ieee80211_hw *hw, struct ieee80211_vif *v
 static int
 mt7996_add_chanctx(struct ieee80211_hw *hw, struct ieee80211_chanctx_conf *conf)
 {
-	struct mt7996_phy *phy = mt7996_band_phy(hw, conf->def.chan->band);
-	struct mt7996_chanctx *ctx = mt7996_chanctx_get(conf);
 	struct mt7996_dev *dev = mt7996_hw_dev(hw);
+	struct mt7996_phy *phy = mt7996_band_phy(dev, conf->def.chan->band);
+	struct mt7996_chanctx *ctx = mt7996_chanctx_get(conf);
 	int ret;
 
 	mt7996_dbg(dev, MT7996_DBG_CHAN, "%s: add %u on mt76 band %d\n",
diff --git a/mt7996/mt7996.h b/mt7996/mt7996.h
index 40c01a51..3a1e2360 100644
--- a/mt7996/mt7996.h
+++ b/mt7996/mt7996.h
@@ -12,6 +12,7 @@
 #include "../mt76_connac.h"
 #include "regs.h"
 
+#define MT7996_MAX_RADIOS		3
 #define MT7996_MAX_INTERFACES		19	/* per-band */
 #define MT7996_MAX_WMM_SETS		4
 #define MT7996_WTBL_BMC_SIZE		(is_mt7992(&dev->mt76) ? 32 : 64)
@@ -714,12 +715,16 @@ struct mt7996_phy {
 
 	u32 rx_ampdu_ts;
 	u32 ampdu_ref;
+	int txpower;
 
 	struct mt76_mib_stats mib;
 	struct mt76_channel_state state_ts;
 	struct delayed_work ipi_work;
 
+	u16 orig_chainmask;
+
 	bool has_aux_rx;
+	bool counter_reset;
 
 	u8 pp_mode;
 	u16 punct_bitmap;
@@ -789,6 +794,10 @@ struct mt7996_dev {
 		struct mt76_phy mphy;
 	};
 
+	struct mt7996_phy *radio_phy[MT7996_MAX_RADIOS];
+	struct wiphy_radio radios[MT7996_MAX_RADIOS];
+	struct wiphy_radio_freq_range radio_freqs[MT7996_MAX_RADIOS];
+
 	struct mt7996_hif *hif2;
 	struct mt7996_reg_desc reg;
 	u8 q_id[MT7996_MAX_QUEUE];
@@ -1075,22 +1084,15 @@ mt7996_has_ext_eeprom(struct mt7996_dev *dev)
 }
 
 static inline struct mt7996_phy *
-mt7996_band_phy(struct ieee80211_hw *hw, enum nl80211_band band)
+mt7996_band_phy(struct mt7996_dev *dev, enum nl80211_band band)
 {
-	struct mt76_phy *phy = hw->priv;
-
-	/* TODO: mlo: temporarily hardcode */
-	if (band == NL80211_BAND_6GHZ)
-		phy = phy->dev->phys[MT_BAND2];
-	else if (band == NL80211_BAND_5GHZ)
-		phy = phy->dev->phys[MT_BAND1];
-	else
-		phy = phy->dev->phys[MT_BAND0];
+	struct mt76_phy *mphy;
 
-	if (!phy)
+	mphy = dev->mt76.band_phys[band];
+	if (!mphy)
 		return NULL;
 
-	return phy->priv;
+	return mphy->priv;
 }
 
 static inline struct mt7996_chanctx *
@@ -1180,6 +1182,10 @@ mt7996_get_active_link_wcid(struct mt7996_dev *dev, struct mt76_wcid *old_wcid)
 	return old_wcid;
 }
 
+#define mt7996_for_each_phy(dev, phy)					\
+	for (int __i = 0; __i < ARRAY_SIZE((dev)->radio_phy); __i++)	\
+		if (((phy) = (dev)->radio_phy[__i]) != NULL)
+
 extern const struct ieee80211_ops mt7996_ops;
 extern struct pci_driver mt7996_pci_driver;
 extern struct pci_driver mt7996_hif_driver;
@@ -1214,7 +1220,7 @@ void mt7996_get_hw(struct mt76_dev *dev, struct mt76_wcid *wcid, u8 phy_idx,
 		   struct ieee80211_hw **hw);
 void mt7996_reset(struct mt7996_dev *dev);
 void mt7996_coredump(struct mt7996_dev *dev, u8 state);
-int mt7996_run(struct ieee80211_hw *hw);
+int mt7996_run(struct mt7996_phy *phy);
 int mt7996_mcu_init(struct mt7996_dev *dev);
 int mt7996_mcu_init_firmware(struct mt7996_dev *dev);
 int mt7996_mcu_twt_agrt_update(struct mt7996_dev *dev,
-- 
2.45.2

