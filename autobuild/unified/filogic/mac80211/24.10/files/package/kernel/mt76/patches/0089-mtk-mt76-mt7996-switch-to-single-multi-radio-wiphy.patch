From 264a9da7ff219407759074d651381fdb81744fd9 Mon Sep 17 00:00:00 2001
From: Shayne Chen <shayne.chen@mediatek.com>
Date: Wed, 18 Dec 2024 16:47:04 +0800
Subject: [PATCH 089/146] mtk: mt76: mt7996: switch to single multi-radio wiphy

mtk: mt76: mt7996: add beacon interval minimum gcd on global wiphy iface
combination

mtk: mt76: mt7996: sync monitor fix

mtk: mt76: mt7996: fix configuring monitor mode

Fix disable monitor mode flow. The disable sniffer mode mcu command
shall not be sent if the interface type is not a monitor interface.
Sending the disable monitor mode mcu command unnecessarily can lead to
the RX filter control register being overwritten with invalid settings
and can not receive trigger frame.

Signed-off-by: Howard Hsu <howard-yh.hsu@mediatek.com>
Signed-off-by: Michael-CY Lee <michael-cy.lee@mediatek.com>
Signed-off-by: Shayne Chen <shayne.chen@mediatek.com>
---
 mac80211.c      |  60 +++--
 mt76.h          |   1 +
 mt7996/Makefile |   1 +
 mt7996/eeprom.c |   7 +-
 mt7996/init.c   | 306 ++++++++++++++++----------
 mt7996/mac.c    |   6 +-
 mt7996/main.c   | 566 ++++++++++++++++++++++++++++--------------------
 mt7996/mcu.c    |  20 ++
 mt7996/mt7996.h |  38 ++--
 9 files changed, 614 insertions(+), 391 deletions(-)

diff --git a/mac80211.c b/mac80211.c
index 6361f497..c75cea46 100644
--- a/mac80211.c
+++ b/mac80211.c
@@ -402,6 +402,7 @@ mt76_check_sband(struct mt76_phy *phy, struct mt76_sband *msband,
 		cfg80211_chandef_create(&phy->chandef, &sband->channels[0],
 					NL80211_CHAN_HT20);
 		phy->chan_state = &msband->chan[0];
+		phy->dev->band_phys[band] = phy;
 		return;
 	}
 
@@ -435,8 +436,10 @@ mt76_phy_init(struct mt76_phy *phy, struct ieee80211_hw *hw)
 	wiphy_ext_feature_set(wiphy, NL80211_EXT_FEATURE_AIRTIME_FAIRNESS);
 	wiphy_ext_feature_set(wiphy, NL80211_EXT_FEATURE_AQL);
 
-	wiphy->available_antennas_tx = phy->antenna_mask;
-	wiphy->available_antennas_rx = phy->antenna_mask;
+	if (!wiphy->available_antennas_tx)
+		wiphy->available_antennas_tx = phy->antenna_mask;
+	if (!wiphy->available_antennas_rx)
+		wiphy->available_antennas_rx = phy->antenna_mask;
 
 	wiphy->sar_capa = &mt76_sar_capa;
 	phy->frp = devm_kcalloc(dev->dev, wiphy->sar_capa->num_freq_ranges,
@@ -1006,19 +1009,44 @@ int mt76_get_survey(struct ieee80211_hw *hw, int idx,
 	if (idx == 0 && dev->drv->update_survey)
 		mt76_update_survey(phy);
 
-	if (idx >= phy->sband_2g.sband.n_channels +
-		   phy->sband_5g.sband.n_channels) {
-		idx -= (phy->sband_2g.sband.n_channels +
-			phy->sband_5g.sband.n_channels);
-		sband = &phy->sband_6g;
-	} else if (idx >= phy->sband_2g.sband.n_channels) {
-		idx -= phy->sband_2g.sband.n_channels;
-		sband = &phy->sband_5g;
+	if (phy->hw->wiphy->flags & WIPHY_FLAG_SUPPORTS_MLO) {
+		struct mt76_phy *phy0, *phy1, *phy2;
+
+		phy0 = dev->phys[MT_BAND0];
+		phy1 = dev->phys[MT_BAND1];
+		phy2 = dev->phys[MT_BAND2];
+
+		/* TODO: mlo: temporarily hardcode */
+		/* FIXME only works on Eagle & Kite */
+		if (idx >= phy0->sband_2g.sband.n_channels +
+		    phy1->sband_5g.sband.n_channels) {
+			idx -= (phy0->sband_2g.sband.n_channels +
+				phy1->sband_5g.sband.n_channels);
+			sband = phy2 ? &phy2->sband_6g : NULL;
+			phy = phy2;
+		} else if (idx >= phy0->sband_2g.sband.n_channels) {
+			idx -= phy0->sband_2g.sband.n_channels;
+			sband = &phy1->sband_5g;
+			phy = phy1;
+		} else {
+			sband = &phy0->sband_2g;
+			phy = phy0;
+		}
 	} else {
-		sband = &phy->sband_2g;
+		if (idx >= phy->sband_2g.sband.n_channels +
+		    phy->sband_5g.sband.n_channels) {
+			idx -= (phy->sband_2g.sband.n_channels +
+				phy->sband_5g.sband.n_channels);
+			sband = &phy->sband_6g;
+		} else if (idx >= phy->sband_2g.sband.n_channels) {
+			idx -= phy->sband_2g.sband.n_channels;
+			sband = &phy->sband_5g;
+		} else {
+			sband = &phy->sband_2g;
+		}
 	}
 
-	if (idx >= sband->sband.n_channels) {
+	if (!sband || idx >= sband->sband.n_channels) {
 		ret = -ENOENT;
 		goto out;
 	}
@@ -1794,10 +1822,14 @@ int mt76_get_antenna(struct ieee80211_hw *hw, u32 *tx_ant, u32 *rx_ant)
 {
 	struct mt76_phy *phy = hw->priv;
 	struct mt76_dev *dev = phy->dev;
+	int i;
 
 	mutex_lock(&dev->mutex);
-	*tx_ant = phy->antenna_mask;
-	*rx_ant = phy->antenna_mask;
+	*tx_ant = 0;
+	for (i = 0; i < ARRAY_SIZE(dev->phys); i++)
+		if (dev->phys[i] && dev->phys[i]->hw == hw)
+			*tx_ant |= dev->phys[i]->chainmask;
+	*rx_ant = *tx_ant;
 	mutex_unlock(&dev->mutex);
 
 	return 0;
diff --git a/mt76.h b/mt76.h
index 171069f2..e88984fe 100644
--- a/mt76.h
+++ b/mt76.h
@@ -899,6 +899,7 @@ struct mt76_phy {
 struct mt76_dev {
 	struct mt76_phy phy; /* must be first */
 	struct mt76_phy *phys[__MT_MAX_BAND];
+	struct mt76_phy *band_phys[NUM_NL80211_BANDS];
 
 	struct ieee80211_hw *hw;
 
diff --git a/mt7996/Makefile b/mt7996/Makefile
index dd5007e0..86000d0c 100644
--- a/mt7996/Makefile
+++ b/mt7996/Makefile
@@ -1,4 +1,5 @@
 # SPDX-License-Identifier: ISC
+EXTRA_CFLAGS += -Werror -std=gnu11
 EXTRA_CFLAGS += -DCONFIG_MT76_LEDS
 EXTRA_CFLAGS += -DCONFIG_MTK_DEBUG
 EXTRA_CFLAGS += -DCONFIG_MTK_VENDOR
diff --git a/mt7996/eeprom.c b/mt7996/eeprom.c
index 0727a598..a19c0bfb 100644
--- a/mt7996/eeprom.c
+++ b/mt7996/eeprom.c
@@ -424,12 +424,6 @@ static int mt7996_eeprom_parse_band_config(struct mt7996_phy *phy)
 		break;
 	}
 
-	/* TODO: for MLO, we enable all band capabilities */
-	phy->mt76->cap.has_2ghz = true;
-	phy->mt76->cap.has_5ghz = true;
-	if (is_mt7996(&phy->dev->mt76))
-		phy->mt76->cap.has_6ghz = true;
-
 	return ret;
 }
 
@@ -459,6 +453,7 @@ int mt7996_eeprom_parse_hw_cap(struct mt7996_dev *dev, struct mt7996_phy *phy)
 
 	mphy->antenna_mask = BIT(nss) - 1;
 	mphy->chainmask = (BIT(path) - 1) << dev->chainshift[band_idx];
+	phy->orig_chainmask = mphy->chainmask;
 	dev->chainmask |= mphy->chainmask;
 	if (band_idx < MT_BAND2)
 		dev->chainshift[band_idx + 1] = dev->chainshift[band_idx] +
diff --git a/mt7996/init.c b/mt7996/init.c
index a1a95671..5d6a02c7 100644
--- a/mt7996/init.c
+++ b/mt7996/init.c
@@ -14,6 +14,29 @@
 #include "coredump.h"
 #include "eeprom.h"
 
+static const struct ieee80211_iface_limit if_limits_global = {
+	.max = MT7996_MAX_INTERFACES * MT7996_MAX_RADIOS,
+	.types = BIT(NL80211_IFTYPE_STATION)
+		 | BIT(NL80211_IFTYPE_ADHOC)
+		 | BIT(NL80211_IFTYPE_AP)
+#ifdef CONFIG_MAC80211_MESH
+		 | BIT(NL80211_IFTYPE_MESH_POINT)
+#endif
+};
+
+static const struct ieee80211_iface_combination if_comb_global = {
+	.limits = &if_limits_global,
+	.n_limits = 1,
+	.max_interfaces = MT7996_MAX_INTERFACES * MT7996_MAX_RADIOS,
+	.num_different_channels = MT7996_MAX_RADIOS,
+	.radar_detect_widths = BIT(NL80211_CHAN_WIDTH_20_NOHT) |
+			       BIT(NL80211_CHAN_WIDTH_20) |
+			       BIT(NL80211_CHAN_WIDTH_40) |
+			       BIT(NL80211_CHAN_WIDTH_80) |
+			       BIT(NL80211_CHAN_WIDTH_160),
+	.beacon_int_min_gcd = 100,
+};
+
 static const struct ieee80211_iface_limit if_limits[] = {
 	{
 		.max = 16,
@@ -27,23 +50,42 @@ static const struct ieee80211_iface_limit if_limits[] = {
 	}
 };
 
-static const struct ieee80211_iface_combination if_comb[] = {
-	{
-		.limits = if_limits,
-		.n_limits = ARRAY_SIZE(if_limits),
-		.max_interfaces = MT7996_MAX_INTERFACES,
-		.num_different_channels = 3,
-		.beacon_int_infra_match = true,
-		.radar_detect_widths = BIT(NL80211_CHAN_WIDTH_20_NOHT) |
-				       BIT(NL80211_CHAN_WIDTH_20) |
-				       BIT(NL80211_CHAN_WIDTH_40) |
-				       BIT(NL80211_CHAN_WIDTH_80) |
-				       BIT(NL80211_CHAN_WIDTH_160),
-		.beacon_int_min_gcd = 100,
-	}
+static const struct ieee80211_iface_combination if_comb = {
+	.limits = if_limits,
+	.n_limits = ARRAY_SIZE(if_limits),
+	.max_interfaces = MT7996_MAX_INTERFACES,
+	.num_different_channels = 1,
+	.beacon_int_infra_match = true,
+	.radar_detect_widths = BIT(NL80211_CHAN_WIDTH_20_NOHT) |
+			       BIT(NL80211_CHAN_WIDTH_20) |
+			       BIT(NL80211_CHAN_WIDTH_40) |
+			       BIT(NL80211_CHAN_WIDTH_80) |
+			       BIT(NL80211_CHAN_WIDTH_160),
+	.beacon_int_min_gcd = 100,
 };
 
-static const u8 mt7996_if_types_ext_capa[] = {
+static const struct ieee80211_iface_combination if_comb_7992 = {
+	.limits = if_limits,
+	.n_limits = ARRAY_SIZE(if_limits),
+	.max_interfaces = 16,
+	.num_different_channels = 1,
+	.beacon_int_infra_match = true,
+	.radar_detect_widths = BIT(NL80211_CHAN_WIDTH_20_NOHT) |
+			       BIT(NL80211_CHAN_WIDTH_20) |
+			       BIT(NL80211_CHAN_WIDTH_40) |
+			       BIT(NL80211_CHAN_WIDTH_80) |
+			       BIT(NL80211_CHAN_WIDTH_160),
+	.beacon_int_min_gcd = 100,
+};
+
+static const u8 mt7996_if_types_ext_capa_ap[] = {
+	[0] = WLAN_EXT_CAPA1_EXT_CHANNEL_SWITCHING,
+	[2] = WLAN_EXT_CAPA3_MULTI_BSSID_SUPPORT,
+	[6] = WLAN_EXT_CAPA7_SCS_SUPPORT,
+	[7] = WLAN_EXT_CAPA8_OPMODE_NOTIF,
+};
+
+static const u8 mt7996_if_types_ext_capa_sta[] = {
 	[0] = WLAN_EXT_CAPA1_EXT_CHANNEL_SWITCHING,
 	[2] = WLAN_EXT_CAPA3_MULTI_BSSID_SUPPORT,
 	[7] = WLAN_EXT_CAPA8_OPMODE_NOTIF,
@@ -205,28 +247,32 @@ static const struct thermal_cooling_device_ops mt7996_thermal_ops = {
 static void mt7996_unregister_thermal(struct mt7996_phy *phy)
 {
 	struct wiphy *wiphy = phy->mt76->hw->wiphy;
+	char name[sizeof("cooling_device%d")];
 
 	if (!phy->cdev)
 		return;
 
-	sysfs_remove_link(&wiphy->dev.kobj, "cooling_device");
+	snprintf(name, sizeof(name), "cooling_device%d", phy->mt76->band_idx);
+	sysfs_remove_link(&wiphy->dev.kobj, name);
 	thermal_cooling_device_unregister(phy->cdev);
 }
 
 static int mt7996_thermal_init(struct mt7996_phy *phy)
 {
 	struct wiphy *wiphy = phy->mt76->hw->wiphy;
+	char cname[sizeof("cooling_device%d")];
 	struct thermal_cooling_device *cdev;
 	struct device *hwmon;
 	const char *name;
 
-	name = devm_kasprintf(&wiphy->dev, GFP_KERNEL, "mt7996_%s",
-			      wiphy_name(wiphy));
+	name = devm_kasprintf(&wiphy->dev, GFP_KERNEL, "mt7996_%s.%d",
+			      wiphy_name(wiphy), phy->mt76->band_idx);
+	snprintf(cname, sizeof(cname), "cooling_device%d", phy->mt76->band_idx);
 
 	cdev = thermal_cooling_device_register(name, phy, &mt7996_thermal_ops);
 	if (!IS_ERR(cdev)) {
 		if (sysfs_create_link(&wiphy->dev.kobj, &cdev->device.kobj,
-				      "cooling_device") < 0)
+				      cname) < 0)
 			thermal_cooling_device_unregister(cdev);
 		else
 			phy->cdev = cdev;
@@ -353,15 +399,22 @@ static void __mt7996_init_txpower(struct mt7996_phy *phy,
 
 void mt7996_init_txpower(struct mt7996_phy *phy)
 {
+	struct mt7996_phy *phy_2g, *phy_5g, *phy_6g;
+
 	if (!phy)
 		return;
 
-	if (phy->mt76->cap.has_2ghz)
-		__mt7996_init_txpower(phy, &phy->mt76->sband_2g.sband);
-	if (phy->mt76->cap.has_5ghz)
-		__mt7996_init_txpower(phy, &phy->mt76->sband_5g.sband);
-	if (phy->mt76->cap.has_6ghz)
-		__mt7996_init_txpower(phy, &phy->mt76->sband_6g.sband);
+	/* FIXME refactor after single wiphy multiple radios merged */
+	phy_2g = mt7996_band_phy(phy->dev, NL80211_BAND_2GHZ);
+	phy_5g = mt7996_band_phy(phy->dev, NL80211_BAND_5GHZ);
+	phy_6g = mt7996_band_phy(phy->dev, NL80211_BAND_6GHZ);
+
+	if (phy_2g && phy_2g->mt76->cap.has_2ghz)
+		__mt7996_init_txpower(phy_2g, &phy_2g->mt76->sband_2g.sband);
+	if (phy_5g && phy_5g->mt76->cap.has_5ghz)
+		__mt7996_init_txpower(phy_5g, &phy_5g->mt76->sband_5g.sband);
+	if (phy_6g && phy_6g->mt76->cap.has_6ghz)
+		__mt7996_init_txpower(phy_6g, &phy_6g->mt76->sband_6g.sband);
 }
 
 static void
@@ -370,30 +423,98 @@ mt7996_regd_notifier(struct wiphy *wiphy,
 {
 	struct ieee80211_hw *hw = wiphy_to_ieee80211_hw(wiphy);
 	struct mt7996_dev *dev = mt7996_hw_dev(hw);
-	struct mt7996_phy *phy = mt7996_hw_phy(hw);
+	struct mt7996_phy *phy;
 
 	memcpy(dev->mt76.alpha2, request->alpha2, sizeof(dev->mt76.alpha2));
 	dev->mt76.region = request->dfs_region;
 
-	if (dev->mt76.region == NL80211_DFS_UNSET)
-		mt7996_mcu_rdd_background_enable(phy, NULL);
+	mt7996_for_each_phy(dev, phy) {
+		if (dev->mt76.region == NL80211_DFS_UNSET)
+			mt7996_mcu_rdd_background_enable(phy, NULL);
 
-	mt7996_init_txpower(phy);
+		mt7996_init_txpower(phy);
+		phy->mt76->dfs_state = MT_DFS_STATE_UNKNOWN;
+		mt7996_dfs_init_radar_detector(phy);
+	}
+}
+
+static void
+mt7996_init_wiphy_band(struct ieee80211_hw *hw, struct mt7996_phy *phy)
+{
+	struct mt7996_dev *dev = phy->dev;
+	struct wiphy *wiphy = hw->wiphy;
+	int n_radios = hw->wiphy->n_radio;
+	struct wiphy_radio_freq_range *freq = &dev->radio_freqs[n_radios];
+	struct wiphy_radio *radio = &dev->radios[n_radios];
+
+	phy->slottime = 9;
+	phy->beacon_rate = -1;
+	phy->muru_onoff = OFDMA_UL | OFDMA_DL | MUMIMO_DL | MUMIMO_UL;
 
-	phy->mt76->dfs_state = MT_DFS_STATE_UNKNOWN;
-	mt7996_dfs_init_radar_detector(phy);
+	if (phy->mt76->cap.has_2ghz) {
+		phy->mt76->sband_2g.sband.ht_cap.cap |=
+			IEEE80211_HT_CAP_LDPC_CODING |
+			IEEE80211_HT_CAP_MAX_AMSDU;
+		phy->mt76->sband_2g.sband.ht_cap.ampdu_density =
+			IEEE80211_HT_MPDU_DENSITY_2;
+		freq->start_freq = 2400000;
+		freq->end_freq = 2500000;
+	} else if (phy->mt76->cap.has_5ghz) {
+		phy->mt76->sband_5g.sband.ht_cap.cap |=
+			IEEE80211_HT_CAP_LDPC_CODING |
+			IEEE80211_HT_CAP_MAX_AMSDU;
+
+		phy->mt76->sband_5g.sband.vht_cap.cap |=
+			IEEE80211_VHT_CAP_MAX_MPDU_LENGTH_11454 |
+			IEEE80211_VHT_CAP_MAX_A_MPDU_LENGTH_EXPONENT_MASK |
+			IEEE80211_VHT_CAP_SHORT_GI_160 |
+			IEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_160MHZ;
+		phy->mt76->sband_5g.sband.ht_cap.ampdu_density =
+			IEEE80211_HT_MPDU_DENSITY_1;
+
+		ieee80211_hw_set(hw, SUPPORTS_VHT_EXT_NSS_BW);
+		freq->start_freq = 5000000;
+		freq->end_freq = 5900000;
+	} else if (phy->mt76->cap.has_6ghz) {
+		freq->start_freq = 5925000;
+		freq->end_freq = 7200000;
+	} else {
+		return;
+	}
+
+	dev->radio_phy[n_radios] = phy;
+	radio->freq_range = freq;
+	radio->n_freq_range = 1;
+	radio->iface_combinations = is_mt7996(&dev->mt76) ? &if_comb : &if_comb_7992;
+	radio->n_iface_combinations = 1;
+	radio->antenna_mask = phy->mt76->chainmask;
+	hw->wiphy->n_radio++;
+
+	wiphy->available_antennas_rx |= phy->mt76->chainmask;
+	wiphy->available_antennas_tx |= phy->mt76->chainmask;
+
+	mt76_set_stream_caps(phy->mt76, true);
+	mt7996_set_stream_vht_txbf_caps(phy);
+	mt7996_set_stream_he_eht_caps(phy);
+	mt7996_init_txpower(phy);
 }
 
 static void
 mt7996_init_wiphy(struct ieee80211_hw *hw, struct mtk_wed_device *wed)
 {
-	struct mt7996_phy *phy = mt7996_hw_phy(hw);
-	struct mt76_dev *mdev = &phy->dev->mt76;
+	struct mt7996_dev *dev = mt7996_hw_dev(hw);
+	struct mt76_dev *mdev = &dev->mt76;
 	struct wiphy *wiphy = hw->wiphy;
 	u16 max_subframes = phy->dev->has_eht ? IEEE80211_MAX_AMPDU_BUF_EHT :
 						IEEE80211_MAX_AMPDU_BUF_HE;
 
 	hw->queues = 4;
+
+	if (dev->has_eht)
+		max_subframes = is_mt7990(mdev) ? 512 : IEEE80211_MAX_AMPDU_BUF_EHT;
+	else
+		max_subframes = IEEE80211_MAX_AMPDU_BUF_HE;
+
 	hw->max_rx_aggregation_subframes = max_subframes;
 	hw->max_tx_aggregation_subframes = max_subframes;
 	hw->netdev_features = NETIF_F_RXCSUM;
@@ -403,19 +524,17 @@ mt7996_init_wiphy(struct ieee80211_hw *hw, struct mtk_wed_device *wed)
 	hw->radiotap_timestamp.units_pos =
 		IEEE80211_RADIOTAP_TIMESTAMP_UNIT_US;
 
-	phy->slottime = 9;
-	phy->beacon_rate = -1;
-	phy->muru_onoff = OFDMA_UL | OFDMA_DL | MUMIMO_DL | MUMIMO_UL;
-
 	hw->sta_data_size = sizeof(struct mt7996_sta);
 	hw->vif_data_size = sizeof(struct mt7996_vif);
 	hw->chanctx_data_size = sizeof(struct mt7996_chanctx);
 
-	wiphy->iface_combinations = if_comb;
-	wiphy->n_iface_combinations = ARRAY_SIZE(if_comb);
+	wiphy->iface_combinations = &if_comb_global;
+	wiphy->n_iface_combinations = 1;
+	wiphy->mbssid_max_interfaces = is_mt7996(&dev->mt76) ? 48 : 32;
+	wiphy->radio = dev->radios;
+
 	wiphy->reg_notifier = mt7996_regd_notifier;
 	wiphy->flags |= WIPHY_FLAG_HAS_CHANNEL_SWITCH;
-	wiphy->mbssid_max_interfaces = 16;
 
 	wiphy_ext_feature_set(wiphy, NL80211_EXT_FEATURE_BSS_COLOR);
 	wiphy_ext_feature_set(wiphy, NL80211_EXT_FEATURE_VHT_IBSS);
@@ -433,7 +552,7 @@ mt7996_init_wiphy(struct ieee80211_hw *hw, struct mtk_wed_device *wed)
 
 	wiphy_ext_feature_set(wiphy, NL80211_EXT_FEATURE_OPERATING_CHANNEL_VALIDATION);
 	wiphy_ext_feature_set(wiphy, NL80211_EXT_FEATURE_BEACON_PROTECTION);
-	if (mt7996_has_background_radar(phy->dev) &&
+	if (mt7996_has_background_radar(dev) &&
 	    (!mdev->dev->of_node ||
 	     !of_property_read_bool(mdev->dev->of_node,
 				    "mediatek,disable-radar-background")))
@@ -443,51 +562,19 @@ mt7996_init_wiphy(struct ieee80211_hw *hw, struct mtk_wed_device *wed)
 	ieee80211_hw_set(hw, HAS_RATE_CONTROL);
 	ieee80211_hw_set(hw, SUPPORTS_TX_ENCAP_OFFLOAD);
 	ieee80211_hw_set(hw, SUPPORTS_RX_DECAP_OFFLOAD);
-	ieee80211_hw_set(hw, WANT_MONITOR_VIF);
+	ieee80211_hw_set(hw, NO_VIRTUAL_MONITOR);
 	ieee80211_hw_set(hw, SUPPORTS_MULTI_BSSID);
 	ieee80211_hw_set(hw, CHANCTX_STA_CSA);
 	ieee80211_hw_set(hw, CONNECTION_MONITOR);
 
 	hw->max_tx_fragments = 4;
 
-	if (phy->mt76->cap.has_2ghz) {
-		phy->mt76->sband_2g.sband.ht_cap.cap |=
-			IEEE80211_HT_CAP_LDPC_CODING |
-			IEEE80211_HT_CAP_MAX_AMSDU;
-		phy->mt76->sband_2g.sband.ht_cap.ampdu_density =
-			IEEE80211_HT_MPDU_DENSITY_2;
-	}
-
-	if (phy->mt76->cap.has_5ghz) {
-		phy->mt76->sband_5g.sband.ht_cap.cap |=
-			IEEE80211_HT_CAP_LDPC_CODING |
-			IEEE80211_HT_CAP_MAX_AMSDU;
-
-		phy->mt76->sband_5g.sband.vht_cap.cap |=
-			IEEE80211_VHT_CAP_MAX_MPDU_LENGTH_11454 |
-			IEEE80211_VHT_CAP_MAX_A_MPDU_LENGTH_EXPONENT_MASK |
-			IEEE80211_VHT_CAP_SHORT_GI_160 |
-			IEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_160MHZ;
-		phy->mt76->sband_5g.sband.ht_cap.ampdu_density =
-			IEEE80211_HT_MPDU_DENSITY_1;
-
-		ieee80211_hw_set(hw, SUPPORTS_VHT_EXT_NSS_BW);
-	}
-
 	/* init led callbacks */
 	if (IS_ENABLED(CONFIG_MT76_LEDS)) {
-		phy->mt76->leds.cdev.brightness_set = mt7996_led_set_brightness;
-		phy->mt76->leds.cdev.blink_set = mt7996_led_set_blink;
+		dev->mphy.leds.cdev.brightness_set = mt7996_led_set_brightness;
+		dev->mphy.leds.cdev.blink_set = mt7996_led_set_blink;
 	}
 
-	mt76_set_stream_caps(phy->mt76, true);
-	mt7996_set_stream_vht_txbf_caps(phy);
-	mt7996_set_stream_he_eht_caps(phy);
-	mt7996_init_txpower(phy);
-
-	wiphy->available_antennas_rx = phy->mt76->antenna_mask;
-	wiphy->available_antennas_tx = phy->mt76->antenna_mask;
-
 	wiphy->max_scan_ssids = 4;
 	wiphy->max_scan_ie_len = IEEE80211_MAX_DATA_LEN;
 
@@ -496,6 +583,8 @@ mt7996_init_wiphy(struct ieee80211_hw *hw, struct mtk_wed_device *wed)
 	wiphy->iftype_ext_capab = mt7996_iftypes_ext_capa;
 	wiphy->num_iftype_ext_capab = ARRAY_SIZE(mt7996_iftypes_ext_capa);
 	wiphy->features |= NL80211_FEATURE_AP_MODE_CHAN_WIDTH_CHANGE;
+
+	mt7996_init_wiphy_band(hw, &dev->phy);
 }
 
 static void
@@ -689,18 +778,15 @@ static void mt7996_init_chanctx(struct mt7996_phy *phy)
 	cfg80211_chandef_create(&phy->mt76->chandef, chan, NL80211_CHAN_HT20);
 }
 
-static int mt7996_register_phy(struct mt7996_dev *dev, struct mt7996_phy *phy,
-			       enum mt76_band_id band)
+static int mt7996_register_phy(struct mt7996_dev *dev, enum mt76_band_id band)
 {
+	struct mt7996_phy *phy;
 	struct mt76_phy *mphy;
 	u32 mac_ofs, hif1_ofs = 0;
 	int ret;
 	struct mtk_wed_device *wed = &dev->mt76.mmio.wed;
 
-	if (!mt7996_band_valid(dev, band) || band == MT_BAND0)
-		return 0;
-
-	if (phy)
+	if (!mt7996_band_valid(dev, band))
 		return 0;
 
 	if (dev->hif2) {
@@ -722,7 +808,7 @@ static int mt7996_register_phy(struct mt7996_dev *dev, struct mt7996_phy *phy,
 		}
 	}
 
-	mphy = mt76_alloc_phy(&dev->mt76, sizeof(*phy), &mt7996_ops, band);
+	mphy = mt76_alloc_radio_phy(&dev->mt76, sizeof(*phy), band);
 	if (!mphy)
 		return -ENOMEM;
 
@@ -754,7 +840,7 @@ static int mt7996_register_phy(struct mt7996_dev *dev, struct mt7996_phy *phy,
 	mt76_eeprom_override(mphy);
 
 	/* init wiphy according to mphy and phy */
-	mt7996_init_wiphy(mphy->hw, wed);
+	mt7996_init_wiphy_band(mphy->hw, phy);
 	ret = mt7996_init_tx_queues(mphy->priv,
 				    MT_TXQ_ID(band),
 				    MT7996_TX_RING_SIZE,
@@ -772,22 +858,12 @@ static int mt7996_register_phy(struct mt7996_dev *dev, struct mt7996_phy *phy,
 	if (ret)
 		goto error;
 
-	mt7996_init_chanctx(phy);
-
-	ret = mt7996_thermal_init(phy);
-	if (ret)
-		goto error;
-
 	if (mt7996_vow_should_enable(dev)) {
 		ret = mt7996_vow_init(phy);
 		if (ret)
 			goto error;
 	}
 
-	ret = mt7996_init_debugfs(phy);
-	if (ret)
-		goto error;
-
 	if (wed == &dev->mt76.mmio.wed_hif2 && mtk_wed_device_active(wed)) {
 		u32 irq_mask = dev->mt76.mmio.irqmask | MT_INT_TX_DONE_BAND2;
 
@@ -799,24 +875,16 @@ static int mt7996_register_phy(struct mt7996_dev *dev, struct mt7996_phy *phy,
 
 error:
 	mphy->dev->phys[band] = NULL;
-	ieee80211_free_hw(mphy->hw);
 	return ret;
 }
 
 static void
-mt7996_unregister_phy(struct mt7996_phy *phy, enum mt76_band_id band)
+mt7996_unregister_phy(struct mt7996_phy *phy)
 {
-	struct mt76_phy *mphy;
-
 	if (!phy)
 		return;
 
 	mt7996_unregister_thermal(phy);
-
-	mphy = phy->dev->mt76.phys[band];
-	mt76_unregister_phy(mphy);
-	ieee80211_free_hw(mphy->hw);
-	phy->dev->mt76.phys[band] = NULL;
 }
 
 static void mt7996_init_work(struct work_struct *work)
@@ -1664,6 +1732,7 @@ void mt7996_set_stream_he_eht_caps(struct mt7996_phy *phy)
 int mt7996_register_device(struct mt7996_dev *dev)
 {
 	struct ieee80211_hw *hw = mt76_hw(dev);
+	struct mt7996_phy *phy;
 	int ret;
 
 	dev->phy.dev = dev;
@@ -1697,24 +1766,31 @@ int mt7996_register_device(struct mt7996_dev *dev)
 	mt7996_vendor_register(&dev->phy);
 #endif
 
-	ret = mt76_register_device(&dev->mt76, true, mt76_rates,
-				   ARRAY_SIZE(mt76_rates));
+	ret = mt7996_register_phy(dev, MT_BAND1);
 	if (ret)
 		return ret;
 
-	mt7996_init_chanctx(&dev->phy);
-
-	ret = mt7996_thermal_init(&dev->phy);
+	ret = mt7996_register_phy(dev, MT_BAND2);
 	if (ret)
 		return ret;
 
-	ret = mt7996_register_phy(dev, mt7996_phy2(dev), MT_BAND1);
+	ret = mt76_register_device(&dev->mt76, true, mt76_rates,
+				   ARRAY_SIZE(mt76_rates));
 	if (ret)
 		return ret;
 
-	ret = mt7996_register_phy(dev, mt7996_phy3(dev), MT_BAND2);
+	ret = mt7996_init_dev_debugfs(&dev->phy);
 	if (ret)
-		return ret;
+		goto error;
+
+	mt7996_for_each_phy(dev, phy) {
+		mt7996_init_chanctx(phy);
+		mt7996_thermal_init(phy);
+		ret = mt7996_init_band_debugfs(phy);
+		if (ret)
+			goto error;
+
+	}
 
 	ieee80211_queue_work(mt76_hw(dev), &dev->init_work);
 
@@ -1726,10 +1802,6 @@ int mt7996_register_device(struct mt7996_dev *dev)
 			goto error;
 	}
 
-	ret = mt7996_init_debugfs(&dev->phy);
-	if (ret)
-		goto error;
-
 	ret = mt7996_coredump_register(dev);
 	if (ret)
 		goto error;
@@ -1745,8 +1817,8 @@ error:
 void mt7996_unregister_device(struct mt7996_dev *dev)
 {
 	cancel_work_sync(&dev->wed_rro.work);
-	mt7996_unregister_phy(mt7996_phy3(dev), MT_BAND2);
-	mt7996_unregister_phy(mt7996_phy2(dev), MT_BAND1);
+	mt7996_unregister_phy(mt7996_phy3(dev));
+	mt7996_unregister_phy(mt7996_phy2(dev));
 	mt7996_unregister_thermal(&dev->phy);
 	mt7996_coredump_unregister(dev);
 	mt76_unregister_device(&dev->mt76);
diff --git a/mt7996/mac.c b/mt7996/mac.c
index 34579d53..003ffb0e 100644
--- a/mt7996/mac.c
+++ b/mt7996/mac.c
@@ -1798,19 +1798,19 @@ mt7996_mac_restart(struct mt7996_dev *dev)
 	ret = mt7996_txbf_init(dev);
 
 	if (test_bit(MT76_STATE_RUNNING, &dev->mphy.state)) {
-		ret = mt7996_run(dev->mphy.hw);
+		ret = mt7996_run(&dev->phy);
 		if (ret)
 			goto out;
 	}
 
 	if (phy2 && test_bit(MT76_STATE_RUNNING, &phy2->mt76->state)) {
-		ret = mt7996_run(phy2->mt76->hw);
+		ret = mt7996_run(phy2);
 		if (ret)
 			goto out;
 	}
 
 	if (phy3 && test_bit(MT76_STATE_RUNNING, &phy3->mt76->state)) {
-		ret = mt7996_run(phy3->mt76->hw);
+		ret = mt7996_run(phy3);
 		if (ret)
 			goto out;
 	}
diff --git a/mt7996/main.c b/mt7996/main.c
index 408192b5..58a9515a 100644
--- a/mt7996/main.c
+++ b/mt7996/main.c
@@ -10,21 +10,9 @@
 #include "mtk_mcu.h"
 #endif
 
-static bool mt7996_dev_running(struct mt7996_dev *dev)
-{
-	struct mt7996_phy *phy;
-
-	if (test_bit(MT76_STATE_RUNNING, &dev->mphy.state))
-		return true;
-
-	phy = mt7996_phy2(dev);
-	if (phy && test_bit(MT76_STATE_RUNNING, &phy->mt76->state))
-		return true;
-
-	phy = mt7996_phy3(dev);
-
-	return phy && test_bit(MT76_STATE_RUNNING, &phy->mt76->state);
-}
+unsigned int mt7996_debug_mask = 0x1f;
+module_param(mt7996_debug_mask, uint, 0644);
+MODULE_PARM_DESC(mt7996_debug_mask, "Debugging mask");
 
 static void mt7996_testmode_disable_all(struct mt7996_dev *dev)
 {
@@ -38,101 +26,71 @@ static void mt7996_testmode_disable_all(struct mt7996_dev *dev)
 	}
 }
 
-int mt7996_run(struct ieee80211_hw *hw)
+int mt7996_run(struct mt7996_phy *phy)
 {
-	struct mt7996_dev *dev = mt7996_hw_dev(hw);
-	bool running;
-	int band, ret;
-
-	running = mt7996_dev_running(dev);
-	if (!running) {
-		ret = mt7996_mcu_set_hdr_trans(dev, true);
-		if (ret)
-			goto out;
-
-		if (is_mt7992(&dev->mt76)) {
-			u8 queue = mt76_connac_lmac_mapping(IEEE80211_AC_VI);
-
-			ret = mt7996_mcu_cp_support(dev, queue);
-			if (ret)
-				goto out;
-		}
-	}
-
-	mt7996_testmode_disable_all(dev);
-
-	for (band = 0; band < NUM_NL80211_BANDS; band++) {
-		struct mt7996_phy *phy;
-
-		if (!hw->wiphy->bands[band])
-			continue;
-
-		phy = mt7996_band_phy(hw, band);
-
-		if (!phy || test_bit(MT76_STATE_RUNNING, &phy->mt76->state))
-			continue;
+	struct mt7996_dev *dev = phy->dev;
+	int ret;
 
-		mt7996_mac_enable_nf(dev, phy->mt76->band_idx);
+	mt7996_mac_enable_nf(dev, phy->mt76->band_idx);
 
-		ret = mt7996_mcu_set_rts_thresh(phy, 0x92b);
-		if (ret)
-			goto out;
+	ret = mt7996_mcu_set_rts_thresh(phy, 0x92b);
+	if (ret)
+		return ret;
 
-		ret = mt7996_mcu_set_radio_en(phy, true);
-		if (ret)
-			goto out;
+	ret = mt7996_mcu_set_radio_en(phy, true);
+	if (ret)
+		return ret;
 
-		ret = mt7996_mcu_set_chan_info(phy, UNI_CHANNEL_RX_PATH);
-		if (ret)
-			goto out;
+	ret = mt7996_mcu_set_chan_info(phy, UNI_CHANNEL_RX_PATH, false);
+	if (ret)
+		return ret;
 
-		/* set a parking channel */
-		ret = mt7996_mcu_set_chan_info(phy, UNI_CHANNEL_SWITCH);
-		if (ret)
-			goto out;
+	/* set a parking channel */
+	ret = mt7996_mcu_set_chan_info(phy, UNI_CHANNEL_SWITCH, false);
+	if (ret)
+		return ret;
 
-		ret = mt7996_mcu_set_thermal_throttling(phy, MT7996_THERMAL_THROTTLE_MAX);
-		if (ret)
-			goto out;
+	ret = mt7996_mcu_set_thermal_throttling(phy, MT7996_THERMAL_THROTTLE_MAX);
+	if (ret)
+		return ret;
 
-		ret = mt7996_mcu_set_thermal_protect(phy, true);
-		if (ret)
-			goto out;
+	ret = mt7996_mcu_set_thermal_protect(phy, true);
+	if (ret)
+		return ret;
 
-		ret = mt7996_mcu_set_scs(phy, SCS_ENABLE);
-		if (ret)
-			goto out;
+	ret = mt7996_mcu_set_scs(phy, SCS_ENABLE);
+	if (ret)
+		return ret;
 
 #ifdef CONFIG_MTK_DEBUG
-		phy->sr_enable = true;
-		phy->enhanced_sr_enable = true;
-		phy->thermal_protection_enable = true;
-		ret = mt7996_mcu_set_tx_power_ctrl(phy, UNI_TXPOWER_SKU_POWER_LIMIT_CTRL,
-						   dev->dbg.sku_disable ? 0 : phy->sku_limit_en);
-
-		ret = mt7996_mcu_set_tx_power_ctrl(phy, UNI_TXPOWER_BACKOFF_POWER_LIMIT_CTRL,
-						   dev->dbg.sku_disable ? 0 : phy->sku_path_en);
+	phy->sr_enable = true;
+	phy->enhanced_sr_enable = true;
+	phy->thermal_protection_enable = true;
+	ret = mt7996_mcu_set_tx_power_ctrl(phy, UNI_TXPOWER_SKU_POWER_LIMIT_CTRL,
+					   dev->dbg.sku_disable ? 0 : phy->sku_limit_en);
+
+	ret = mt7996_mcu_set_tx_power_ctrl(phy, UNI_TXPOWER_BACKOFF_POWER_LIMIT_CTRL,
+					   dev->dbg.sku_disable ? 0 : phy->sku_path_en);
 #else
-		ret = mt7996_mcu_set_tx_power_ctrl(phy, UNI_TXPOWER_SKU_POWER_LIMIT_CTRL,
-						   phy->sku_limit_en);
-		ret = mt7996_mcu_set_tx_power_ctrl(phy, UNI_TXPOWER_BACKOFF_POWER_LIMIT_CTRL,
-						   phy->sku_path_en);
+	ret = mt7996_mcu_set_tx_power_ctrl(phy, UNI_TXPOWER_SKU_POWER_LIMIT_CTRL,
+					   phy->sku_limit_en);
+	ret = mt7996_mcu_set_tx_power_ctrl(phy, UNI_TXPOWER_BACKOFF_POWER_LIMIT_CTRL,
+					   phy->sku_path_en);
 #endif
-		if (ret)
-			goto out;
+	if (ret)
+		return ret;
 
-		set_bit(MT76_STATE_RUNNING, &phy->mt76->state);
+	set_bit(MT76_STATE_RUNNING, &phy->mt76->state);
 
-		ieee80211_queue_delayed_work(hw, &phy->mt76->mac_work,
-					     MT7996_WATCHDOG_TIME);
+	ieee80211_queue_delayed_work(dev->mphy.hw, &phy->mt76->mac_work,
+				     MT7996_WATCHDOG_TIME);
 
-		if (!running)
-			mt7996_mac_reset_counters(phy);
+	if (!phy->counter_reset) {
+		mt7996_mac_reset_counters(phy);
+		phy->counter_reset = true;
 	}
 
-	ieee80211_queue_delayed_work(mt76_hw(dev), &dev->scs_work, HZ);
-out:
-	return ret;
+	return 0;
 }
 
 static int mt7996_start(struct ieee80211_hw *hw)
@@ -143,38 +101,54 @@ static int mt7996_start(struct ieee80211_hw *hw)
 	flush_work(&dev->init_work);
 
 	mutex_lock(&dev->mt76.mutex);
-	ret = mt7996_run(hw);
+	ret = mt7996_mcu_set_hdr_trans(dev, true);
+	if (!ret && is_mt7992(&dev->mt76)) {
+		u8 queue = mt76_connac_lmac_mapping(IEEE80211_AC_VI);
+
+		ret = mt7996_mcu_cp_support(dev, queue);
+#ifdef CONFIG_MTK_DEBUG
+		dev->sr_pp_enable = true;
+		dev->uba_enable = true;
+#endif
+	}
+
+	mt7996_testmode_disable_all(dev);
+
 	mutex_unlock(&dev->mt76.mutex);
 
+	ieee80211_queue_delayed_work(hw, &dev->scs_work, HZ);
+
 	return ret;
 }
 
-static void mt7996_stop(struct ieee80211_hw *hw, bool suspend)
+static void mt7996_stop_phy(struct mt7996_phy *phy)
 {
-	struct mt7996_dev *dev = mt7996_hw_dev(hw);
-	int band;
+	struct mt7996_dev *dev = phy->dev;
 
-	cancel_delayed_work_sync(&dev->scs_work);
+	if (!phy || !test_bit(MT76_STATE_RUNNING, &phy->mt76->state))
+		return;
 
-	for (band = 0; band < NUM_NL80211_BANDS; band++) {
-		struct mt7996_phy *phy;
+	cancel_delayed_work_sync(&phy->mt76->mac_work);
+	cancel_delayed_work_sync(&phy->scan_work);
+	cancel_delayed_work_sync(&phy->roc_complete_work);
 
-		if (!hw->wiphy->bands[band])
-			continue;
+	mutex_lock(&dev->mt76.mutex);
 
-		phy = mt7996_band_phy(hw, band);
+	if (test_bit(MT76_SCANNING, &phy->mt76->state))
+		mt7996_scan_complete(phy, true);
 
-		if (!phy || !test_bit(MT76_STATE_RUNNING, &phy->mt76->state) ||
-		    (phy->chanctx && phy->chanctx->nbss_assigned))
-			continue;
+	mt7996_mcu_set_radio_en(phy, false);
 
-		cancel_delayed_work_sync(&phy->mt76->mac_work);
+	clear_bit(MT76_STATE_RUNNING, &phy->mt76->state);
 
-		mutex_lock(&dev->mt76.mutex);
-		mt7996_mcu_set_radio_en(phy, false);
-		clear_bit(MT76_STATE_RUNNING, &phy->mt76->state);
-		mutex_unlock(&dev->mt76.mutex);
-	}
+	mutex_unlock(&dev->mt76.mutex);
+}
+
+static void mt7996_stop(struct ieee80211_hw *hw, bool suspend)
+{
+	struct mt7996_dev *dev = mt7996_hw_dev(hw);
+
+	cancel_delayed_work_sync(&dev->scs_work);
 }
 
 static inline int get_free_idx(u64 mask, u8 start, u8 end)
@@ -288,16 +262,18 @@ static void mt7996_remove_bss_conf(struct ieee80211_vif *vif,
 				   struct ieee80211_bss_conf *conf,
 				   struct mt7996_bss_conf *mconf)
 {
-	struct mt7996_phy *phy = mconf->phy;
-	struct mt7996_dev *dev = phy->dev;
+	struct mt7996_phy *phy;
+	struct mt7996_dev *dev;
 	struct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;
 	u8 link_id = conf->link_id;
 	struct mt7996_link_sta *mlink =
 		mlink_dereference_protected(&mvif->sta, link_id);
 
-	if (!mlink)
+	if (!mlink || !mconf)
 		return;
 
+	phy = mconf->phy;
+	dev = phy->dev;
 	mt7996_mcu_add_sta(dev, conf, mconf, NULL, mlink, false, false);
 	mt7996_mcu_add_bss_info(phy, conf, mconf, mlink, false);
 	mt7996_mcu_add_dev_info(phy, conf, mconf, false);
@@ -441,26 +417,119 @@ error:
 	return ret;
 }
 
+static void mt7996_phy_set_rxfilter(struct mt7996_phy *phy)
+{
+	struct mt7996_dev *dev = phy->dev;
+	u32 ctl_flags = MT_WF_RFCR1_DROP_ACK |
+			MT_WF_RFCR1_DROP_BF_POLL |
+			MT_WF_RFCR1_DROP_BA |
+			MT_WF_RFCR1_DROP_CFEND |
+			MT_WF_RFCR1_DROP_CFACK;
+	u32 filter = phy->rxfilter;
+
+	if (filter & MT_WF_RFCR_DROP_OTHER_UC) {
+		filter |= MT_WF_RFCR_DROP_CTS |
+			  MT_WF_RFCR_DROP_RTS |
+			  MT_WF_RFCR_DROP_CTL_RSV |
+			  MT_WF_RFCR_DROP_FCSFAIL;
+	}
+
+	mt76_wr(dev, MT_WF_RFCR(phy->mt76->band_idx), filter);
+	if (filter & MT_WF_RFCR_DROP_CTL_RSV)
+		mt76_set(dev, MT_WF_RFCR1(phy->mt76->band_idx), ctl_flags);
+	else
+		mt76_clear(dev, MT_WF_RFCR1(phy->mt76->band_idx), ctl_flags);
+}
+
+static void mt7996_set_monitor(struct mt7996_phy *phy, bool enabled)
+{
+	struct mt7996_dev *dev = phy->dev;
+
+	if (!phy)
+		return;
+
+	if (enabled == !(phy->rxfilter & MT_WF_RFCR_DROP_OTHER_UC))
+		return;
+
+	if (!enabled)
+		phy->rxfilter |= MT_WF_RFCR_DROP_OTHER_UC;
+	else
+		phy->rxfilter &= ~MT_WF_RFCR_DROP_OTHER_UC;
+
+	mt76_rmw_field(dev, MT_DMA_DCR0(phy->mt76->band_idx),
+		       MT_DMA_DCR0_RXD_G5_EN, enabled);
+	mt7996_phy_set_rxfilter(phy);
+	mt7996_mcu_set_sniffer_mode(phy, enabled);
+}
+
 static int mt7996_add_interface(struct ieee80211_hw *hw,
 			        struct ieee80211_vif *vif)
 {
 	struct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;
+	struct wireless_dev *wdev = ieee80211_vif_to_wdev(vif);
 	struct mt7996_dev *dev = mt7996_hw_dev(hw);
-	struct mt7996_phy *phy = mt7996_hw_phy(hw);
-	int ret = 0;
+	struct mt7996_phy *phy;
+	int i, err = 0;
 
 	mutex_lock(&dev->mt76.mutex);
-	if (vif->type == NL80211_IFTYPE_MONITOR &&
-	    is_zero_ether_addr(vif->addr))
-		phy->monitor_vif = vif;
+	if (dev->testmode_enable && vif->type != NL80211_IFTYPE_MONITOR) {
+		mutex_unlock(&dev->mt76.mutex);
+		dev_err(dev->mt76.dev, "Only monitor interface is allowed in testmode\n");
+		return -EINVAL;
+	}
+
+	for (i = 0; i < MT7996_MAX_RADIOS; i++) {
+		/* FIXME: only set the required radio temporarily for testmode.
+		 * The TX speed of testmode will be affected if the unused radio is enabled.
+		 * Normal mode should also skip enabling the unused radio once the
+		 * real single wiphy codebase is stable.
+		 */
+		if (dev->testmode_enable && !(wdev->radio_mask & BIT(i)))
+			continue;
+
+		phy = dev->radio_phy[i];
+		if (!phy || test_bit(MT76_STATE_RUNNING, &phy->mt76->state))
+			continue;
+
+		err = mt7996_run(phy);
+		if (err)
+			goto out;
+
+		if (vif->type == NL80211_IFTYPE_MONITOR) {
+			mt7996_set_monitor(phy, true);
+			phy->monitor_vif = vif;
+		}
+	}
 
 	mvif->dev = dev;
 	mvif->sta.vif = mvif;
+	/* TODO: temporaily set this to prevent some crashes */
+	mvif->deflink.phy = mt7996_hw_phy(hw);
+	memset(mvif->band_to_link, IEEE80211_LINK_UNSPECIFIED,
+	       sizeof(mvif->band_to_link));
+
+	if (vif->type == NL80211_IFTYPE_STATION)
+		err = mt7996_add_bss_conf(mt7996_hw_phy(hw), vif, &vif->bss_conf);
 
-	ret = mt7996_add_bss_conf(phy, vif, &vif->bss_conf);
+out:
 	mutex_unlock(&dev->mt76.mutex);
 
-	return ret;
+	return err;
+}
+
+struct mt7996_radio_data {
+	u32 active_mask;
+	u32 monitor_mask;
+};
+
+static void mt7996_remove_iter(void *data, u8 *mac, struct ieee80211_vif *vif)
+{
+	struct wireless_dev *wdev = ieee80211_vif_to_wdev(vif);
+	struct mt7996_radio_data *rdata = data;
+
+	rdata->active_mask |= wdev->radio_mask;
+	if (vif->type == NL80211_IFTYPE_MONITOR)
+		rdata->monitor_mask |= wdev->radio_mask;
 }
 
 static void mt7996_remove_interface(struct ieee80211_hw *hw,
@@ -470,27 +539,49 @@ static void mt7996_remove_interface(struct ieee80211_hw *hw,
 	struct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;
 	struct mt7996_bss_conf *mconf;
 	struct mt7996_dev *dev = mt7996_hw_dev(hw);
-	struct mt7996_phy *phy = mt7996_hw_phy(hw);
+	struct mt7996_phy *phy;
+	struct mt7996_radio_data rdata = {};
+	int i;
 
-	cancel_delayed_work_sync(&phy->scan_work);
+	ieee80211_iterate_active_interfaces_mtx(hw, 0, mt7996_remove_iter,
+						&rdata);
 
 	mutex_lock(&dev->mt76.mutex);
 
-	if (test_bit(MT76_SCANNING, &phy->mt76->state))
-		mt7996_scan_complete(phy, true);
-
-	if (vif == phy->monitor_vif)
-		phy->monitor_vif = NULL;
-
 	conf = link_conf_dereference_protected(vif, 0);
 	mconf = mconf_dereference_protected(mvif, 0);
 	if (!mconf || !conf)
 		goto out;
 
-	mt7996_remove_bss_conf(vif, conf, mconf);
+	mt7996_remove_bss_conf(vif, mconf, 0);
+
+	for (i = 0; i < MT7996_MAX_RADIOS; i++) {
+		phy = dev->radio_phy[i];
+		if (!phy)
+			continue;
+
+		if (vif == phy->monitor_vif) {
+			phy->monitor_vif = NULL;
+
+			if (dev->testmode_enable)
+				kfree(phy->mt76->lists);
+		}
+	}
 
 out:
 	mutex_unlock(&dev->mt76.mutex);
+
+	for (i = 0; i < MT7996_MAX_RADIOS; i++) {
+		phy = dev->radio_phy[i];
+		if (!phy)
+			continue;
+
+		if (vif->type == NL80211_IFTYPE_MONITOR &&
+		    !(rdata.monitor_mask & BIT(i)))
+			mt7996_set_monitor(phy, false);
+		if (!(rdata.active_mask & BIT(i)))
+			mt7996_stop_phy(phy);
+	}
 }
 
 static void ___mt7996_set_channel(struct mt7996_phy *phy,
@@ -557,8 +648,13 @@ static int __mt7996_set_channel(struct mt7996_phy *phy,
 	phy->noise = 0;
 
 out:
-	ieee80211_queue_delayed_work(mphy->hw, &mphy->mac_work,
-				     MT7996_WATCHDOG_TIME);
+	clear_bit(MT76_RESET, &phy->mt76->state);
+	mutex_unlock(&dev->mt76.mutex);
+
+	mt76_txq_schedule_all(phy->mt76);
+
+	ieee80211_queue_delayed_work(phy->mt76->hw,
+				     &phy->mt76->mac_work,
 
 	return ret;
 }
@@ -669,26 +765,6 @@ out:
 
 static int mt7996_config(struct ieee80211_hw *hw, u32 changed)
 {
-	struct mt7996_dev *dev = mt7996_hw_dev(hw);
-	struct mt7996_phy *phy = mt7996_hw_phy(hw);
-
-	mutex_lock(&dev->mt76.mutex);
-
-	if (changed & IEEE80211_CONF_CHANGE_MONITOR) {
-		bool enabled = !!(hw->conf.flags & IEEE80211_CONF_MONITOR);
-
-		if (!enabled)
-			phy->rxfilter |= MT_WF_RFCR_DROP_OTHER_UC;
-		else
-			phy->rxfilter &= ~MT_WF_RFCR_DROP_OTHER_UC;
-
-		mt76_rmw_field(dev, MT_DMA_DCR0(phy->mt76->band_idx),
-			       MT_DMA_DCR0_RXD_G5_EN, enabled);
-		mt76_wr(dev, MT_WF_RFCR(phy->mt76->band_idx), phy->rxfilter);
-	}
-
-	mutex_unlock(&dev->mt76.mutex);
-
 	return 0;
 }
 
@@ -729,34 +805,18 @@ static void mt7996_configure_filter(struct ieee80211_hw *hw,
 				    u64 multicast)
 {
 	struct mt7996_dev *dev = mt7996_hw_dev(hw);
-	struct mt7996_phy *phy = mt7996_hw_phy(hw);
-	u32 ctl_flags = MT_WF_RFCR1_DROP_ACK |
-			MT_WF_RFCR1_DROP_BF_POLL |
-			MT_WF_RFCR1_DROP_BA |
-			MT_WF_RFCR1_DROP_CFEND |
-			MT_WF_RFCR1_DROP_CFACK;
+	struct mt7996_phy *phy;
+	u32 filter_mask = 0, filter_set = 0;
 	u32 flags = 0;
 
-#define MT76_FILTER(_flag, _hw) do {					\
-		flags |= *total_flags & FIF_##_flag;			\
-		phy->rxfilter &= ~(_hw);				\
-		phy->rxfilter |= !(flags & FIF_##_flag) * (_hw);	\
+#define MT76_FILTER(_flag, _hw) do {				\
+		flags |= *total_flags & FIF_##_flag;		\
+		filter_mask |= (_hw);				\
+		filter_set |= !(flags & FIF_##_flag) * (_hw);	\
 	} while (0)
 
 	mutex_lock(&dev->mt76.mutex);
 
-	phy->rxfilter &= ~(MT_WF_RFCR_DROP_OTHER_BSS |
-			   MT_WF_RFCR_DROP_OTHER_BEACON |
-			   MT_WF_RFCR_DROP_FRAME_REPORT |
-			   MT_WF_RFCR_DROP_PROBEREQ |
-			   MT_WF_RFCR_DROP_MCAST_FILTERED |
-			   MT_WF_RFCR_DROP_MCAST |
-			   MT_WF_RFCR_DROP_BCAST |
-			   MT_WF_RFCR_DROP_DUPLICATE |
-			   MT_WF_RFCR_DROP_A2_BSSID |
-			   MT_WF_RFCR_DROP_UNWANTED_CTL |
-			   MT_WF_RFCR_DROP_STBC_MULTI);
-
 	MT76_FILTER(OTHER_BSS, MT_WF_RFCR_DROP_OTHER_TIM |
 			       MT_WF_RFCR_DROP_A3_MAC |
 			       MT_WF_RFCR_DROP_A3_BSSID);
@@ -768,12 +828,23 @@ static void mt7996_configure_filter(struct ieee80211_hw *hw,
 			     MT_WF_RFCR_DROP_CTL_RSV);
 
 	*total_flags = flags;
-	mt76_wr(dev, MT_WF_RFCR(phy->mt76->band_idx), phy->rxfilter);
 
-	if (*total_flags & FIF_CONTROL)
-		mt76_clear(dev, MT_WF_RFCR1(phy->mt76->band_idx), ctl_flags);
-	else
-		mt76_set(dev, MT_WF_RFCR1(phy->mt76->band_idx), ctl_flags);
+	mt7996_for_each_phy(dev, phy) {
+		phy->rxfilter &= ~(MT_WF_RFCR_DROP_OTHER_BSS |
+				   MT_WF_RFCR_DROP_OTHER_BEACON |
+				   MT_WF_RFCR_DROP_FRAME_REPORT |
+				   MT_WF_RFCR_DROP_PROBEREQ |
+				   MT_WF_RFCR_DROP_MCAST_FILTERED |
+				   MT_WF_RFCR_DROP_MCAST |
+				   MT_WF_RFCR_DROP_BCAST |
+				   MT_WF_RFCR_DROP_DUPLICATE |
+				   MT_WF_RFCR_DROP_A2_BSSID |
+				   MT_WF_RFCR_DROP_UNWANTED_CTL |
+				   MT_WF_RFCR_DROP_STBC_MULTI |
+				   filter_mask);
+		phy->rxfilter |= filter_set;
+		mt7996_phy_set_rxfilter(phy);
+	}
 
 	mutex_unlock(&dev->mt76.mutex);
 }
@@ -887,8 +958,8 @@ static void mt7996_link_info_changed(struct ieee80211_hw *hw,
 	struct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;
 	struct mt7996_bss_conf *mconf;
 	struct mt7996_link_sta *mlink;
-	struct mt7996_phy *phy = mt7996_hw_phy(hw);
 	struct mt7996_dev *dev = mt7996_hw_dev(hw);
+	struct mt7996_phy *phy;
 
 	mutex_lock(&dev->mt76.mutex);
 
@@ -897,8 +968,7 @@ static void mt7996_link_info_changed(struct ieee80211_hw *hw,
 	if (!mconf || !mlink)
 		goto out;
 
-	if (mconf->phy)
-		phy = mconf->phy;
+	phy = mconf->phy;
 	/* station mode uses BSSID to map the wlan entry to a peer,
 	 * and then peer references bss_info_rfch to set bandwidth cap.
 	 */
@@ -991,8 +1061,10 @@ mt7996_channel_switch_beacon(struct ieee80211_hw *hw,
 {
 	struct mt7996_dev *dev = mt7996_hw_dev(hw);
 	struct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;
-	struct mt7996_phy *phy = mt7996_band_phy(hw, chandef->chan->band);
-	unsigned long valid_links = vif->valid_links ?: BIT(0);
+	struct mt7996_phy *phy = mt7996_band_phy(dev, chandef->chan->band);
+	struct ieee80211_bss_conf *conf;
+	struct mt7996_bss_conf *mconf;
+	u16 valid_links = vif->valid_links ?: BIT(0);
 	unsigned int link_id;
 
 	mutex_lock(&dev->mt76.mutex);
@@ -1402,12 +1474,20 @@ unlock:
 
 static int mt7996_set_rts_threshold(struct ieee80211_hw *hw, u32 val)
 {
-	struct mt7996_phy *phy = mt7996_hw_phy(hw);
-	int ret;
+	struct mt7996_dev *dev = mt7996_hw_dev(hw);
+	int i, ret;
 
-	mutex_lock(&phy->dev->mt76.mutex);
-	ret = mt7996_mcu_set_rts_thresh(phy, val);
-	mutex_unlock(&phy->dev->mt76.mutex);
+	mutex_lock(&dev->mt76.mutex);
+
+	for (i = 0; i < hw->wiphy->n_radio; i++) {
+		struct mt7996_phy *phy = dev->radio_phy[i];
+
+		ret = mt7996_mcu_set_rts_thresh(phy, val);
+		if (ret)
+			break;
+	}
+
+	mutex_unlock(&dev->mt76.mutex);
 
 	return ret;
 }
@@ -1475,16 +1555,21 @@ static int
 mt7996_get_stats(struct ieee80211_hw *hw,
 		 struct ieee80211_low_level_stats *stats)
 {
-	struct mt7996_phy *phy = mt7996_hw_phy(hw);
 	struct mt7996_dev *dev = mt7996_hw_dev(hw);
-	struct mt76_mib_stats *mib = &phy->mib;
+	int i;
 
 	mutex_lock(&dev->mt76.mutex);
 
-	stats->dot11RTSSuccessCount = mib->rts_cnt;
-	stats->dot11RTSFailureCount = mib->rts_retries_cnt;
-	stats->dot11FCSErrorCount = mib->fcs_err_cnt;
-	stats->dot11ACKFailureCount = mib->ack_fail_cnt;
+	memset(stats, 0, sizeof(*stats));
+	for (i = 0; i < hw->wiphy->n_radio; i++) {
+		struct mt7996_phy *phy = dev->radio_phy[i];
+		struct mt76_mib_stats *mib = &phy->mib;
+
+		stats->dot11RTSSuccessCount += mib->rts_cnt;
+		stats->dot11RTSFailureCount += mib->rts_retries_cnt;
+		stats->dot11FCSErrorCount += mib->fcs_err_cnt;
+		stats->dot11ACKFailureCount += mib->ack_fail_cnt;
+	}
 
 	mutex_unlock(&dev->mt76.mutex);
 
@@ -1494,7 +1579,7 @@ mt7996_get_stats(struct ieee80211_hw *hw,
 u64 __mt7996_get_tsf(struct ieee80211_hw *hw, struct mt7996_bss_conf *mconf)
 {
 	struct mt7996_dev *dev = mt7996_hw_dev(hw);
-	struct mt7996_phy *phy = mt7996_hw_phy(hw);
+	struct mt7996_phy *phy = mconf->phy;
 	union {
 		u64 t64;
 		u32 t32[2];
@@ -1545,7 +1630,7 @@ mt7996_set_tsf(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 {
 	struct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;
 	struct mt7996_dev *dev = mt7996_hw_dev(hw);
-	struct mt7996_phy *phy = mt7996_hw_phy(hw);
+	struct mt7996_phy *phy;
 	struct mt7996_bss_conf *mconf;
 	union {
 		u64 t64;
@@ -1556,6 +1641,9 @@ mt7996_set_tsf(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 	mutex_lock(&dev->mt76.mutex);
 
 	mconf = mconf_dereference_protected(mvif, mvif->master_link_id);
+	if (!mconf)
+		return;
+	phy = mconf->phy;
 	n = mconf->mt76.omac_idx > HW_BSSID_MAX ? HW_BSSID_0
 					       : mconf->mt76.omac_idx;
 	mt76_wr(dev, MT_LPON_UTTR0(phy->mt76->band_idx), tsf.t32[0]);
@@ -1573,7 +1661,7 @@ mt7996_offset_tsf(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 {
 	struct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;
 	struct mt7996_dev *dev = mt7996_hw_dev(hw);
-	struct mt7996_phy *phy = mt7996_hw_phy(hw);
+	struct mt7996_phy *phy;
 	struct mt7996_bss_conf *mconf;
 	union {
 		u64 t64;
@@ -1584,6 +1672,9 @@ mt7996_offset_tsf(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 	mutex_lock(&dev->mt76.mutex);
 
 	mconf = mconf_dereference_protected(mvif, mvif->master_link_id);
+	if (!mconf)
+		return;
+	phy = mconf->phy;
 	n = mconf->mt76.omac_idx > HW_BSSID_MAX ? HW_BSSID_0
 					       : mconf->mt76.omac_idx;
 	mt76_wr(dev, MT_LPON_UTTR0(phy->mt76->band_idx), tsf.t32[0]);
@@ -1598,12 +1689,14 @@ mt7996_offset_tsf(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 static void
 mt7996_set_coverage_class(struct ieee80211_hw *hw, s16 coverage_class)
 {
-	struct mt7996_phy *phy = mt7996_hw_phy(hw);
-	struct mt7996_dev *dev = phy->dev;
+	struct mt7996_dev *dev = mt7996_hw_dev(hw);
+	struct mt7996_phy *phy;
 
 	mutex_lock(&dev->mt76.mutex);
-	phy->coverage_class = max_t(s16, coverage_class, 0);
-	mt7996_mac_set_coverage_class(phy);
+	mt7996_for_each_phy(dev, phy) {
+		phy->coverage_class = max_t(s16, coverage_class, 0);
+		mt7996_mac_set_coverage_class(phy);
+	}
 	mutex_unlock(&dev->mt76.mutex);
 }
 
@@ -1611,32 +1704,32 @@ static int
 mt7996_set_antenna(struct ieee80211_hw *hw, u32 tx_ant, u32 rx_ant)
 {
 	struct mt7996_dev *dev = mt7996_hw_dev(hw);
-	struct mt7996_phy *phy = mt7996_hw_phy(hw);
-	int max_nss = hweight8(hw->wiphy->available_antennas_tx);
-	u8 band_idx = phy->mt76->band_idx, shift = dev->chainshift[band_idx];
+	int i;
 
-	if (!tx_ant || tx_ant != rx_ant || ffs(tx_ant) > max_nss)
+	if (tx_ant != rx_ant)
 		return -EINVAL;
 
-	if ((BIT(hweight8(tx_ant)) - 1) != tx_ant)
-		tx_ant = BIT(ffs(tx_ant) - 1) - 1;
+	for (i = 0; i < hw->wiphy->n_radio; i++) {
+		struct mt7996_phy *phy = dev->radio_phy[i];
+
+		if (!(tx_ant & phy->orig_chainmask))
+			return -EINVAL;
+	}
 
 	mutex_lock(&dev->mt76.mutex);
 
-	phy->mt76->antenna_mask = tx_ant;
+	for (i = 0; i < hw->wiphy->n_radio; i++) {
+		struct mt7996_phy *phy = dev->radio_phy[i];
+		u8 band_idx = phy->mt76->band_idx;
+		u8 shift = dev->chainshift[band_idx];
 
-	/* restore to the origin chainmask which might have auxiliary path */
-	if (hweight8(tx_ant) == max_nss && band_idx < MT_BAND2)
-		phy->mt76->chainmask = ((dev->chainmask >> shift) &
-					(BIT(dev->chainshift[band_idx + 1] - shift) - 1)) << shift;
-	else if (hweight8(tx_ant) == max_nss)
-		phy->mt76->chainmask = (dev->chainmask >> shift) << shift;
-	else
-		phy->mt76->chainmask = tx_ant << shift;
+		phy->mt76->chainmask = tx_ant & phy->orig_chainmask;
+		phy->mt76->antenna_mask = phy->mt76->chainmask >> shift;
 
-	mt76_set_stream_caps(phy->mt76, true);
-	mt7996_set_stream_vht_txbf_caps(phy);
-	mt7996_set_stream_he_eht_caps(phy);
+		mt76_set_stream_caps(phy->mt76, true);
+		mt7996_set_stream_vht_txbf_caps(phy);
+		mt7996_set_stream_he_eht_caps(phy);
+	}
 
 	mutex_unlock(&dev->mt76.mutex);
 
@@ -1649,7 +1742,6 @@ static void mt7996_sta_statistics(struct ieee80211_hw *hw,
 				  struct station_info *sinfo)
 {
 	struct mt7996_dev *dev = mt7996_hw_dev(hw);
-	struct mt7996_phy *phy = mt7996_hw_phy(hw);
 	struct mt7996_sta *msta = (struct mt7996_sta *)sta->drv_priv;
 	struct mt7996_link_sta *mlink;
 	struct rate_info *txrate;
@@ -1691,7 +1783,7 @@ static void mt7996_sta_statistics(struct ieee80211_hw *hw,
 	sinfo->avg_ack_signal = -(s8)ewma_avg_signal_read(&mlink->avg_ack_signal);
 	sinfo->filled |= BIT_ULL(NL80211_STA_INFO_ACK_SIGNAL_AVG);
 
-	if (mtk_wed_device_active(&phy->dev->mt76.mmio.wed)) {
+	if (mtk_wed_device_active(&dev->mt76.mmio.wed)) {
 		sinfo->tx_bytes = mlink->wcid.stats.tx_bytes;
 		sinfo->filled |= BIT_ULL(NL80211_STA_INFO_TX_BYTES64);
 
@@ -2013,6 +2105,9 @@ void mt7996_get_et_stats(struct ieee80211_hw *hw,
 	/* See mt7996_ampdu_stat_read_phy, etc */
 	int i, ei = 0;
 
+	if (!phy)
+		return;
+
 	mutex_lock(&dev->mt76.mutex);
 	mconf = mconf_dereference_protected(mvif, mvif->master_link_id);
 	wi.idx = mconf->mt76.idx,
@@ -2165,8 +2260,8 @@ static int
 mt7996_set_radar_background(struct ieee80211_hw *hw,
 			    struct cfg80211_chan_def *chandef)
 {
-	struct mt7996_phy *phy = mt7996_hw_phy(hw);
-	struct mt7996_dev *dev = phy->dev;
+	struct mt7996_dev *dev = mt7996_hw_dev(hw);
+	struct mt7996_phy *phy = mt7996_band_phy(dev, NL80211_BAND_5GHZ);
 	int ret = -EINVAL;
 	bool running;
 	struct cfg80211_chan_def ifem_chandef = {};
@@ -2298,7 +2393,8 @@ mt7996_hw_scan(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 	       struct ieee80211_scan_request *hw_req)
 {
 	struct cfg80211_scan_request *req = &hw_req->req;
-	struct mt7996_phy *phy = mt7996_band_phy(hw, req->channels[0]->band);
+	struct mt7996_dev *dev = mt7996_hw_dev(hw);
+	struct mt7996_phy *phy = mt7996_band_phy(dev, req->channels[0]->band);
 	struct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;
 	int ret;
 
@@ -2314,7 +2410,7 @@ mt7996_hw_scan(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 
 	if (vif->type == NL80211_IFTYPE_STATION && !ieee80211_vif_is_mld(vif) &&
 	    (phy->mt76 != mvif->deflink.phy->mt76)) {
-		phy->mt76->main_phy = hw->priv;
+		// phy->mt76->main_phy = hw->priv;
 		mt7996_remove_bss_conf(vif, &vif->bss_conf, &mvif->deflink);
 
 		ret = mt7996_add_bss_conf(phy, vif, &vif->bss_conf);
@@ -2327,7 +2423,7 @@ mt7996_hw_scan(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 	set_bit(MT76_SCANNING, &phy->mt76->state);
 	mutex_unlock(&phy->dev->mt76.mutex);
 
-	ieee80211_queue_delayed_work(hw, &phy->scan_work, 0);
+	ieee80211_queue_delayed_work(phy->mt76->hw, &phy->scan_work, 0);
 
 	return 0;
 }
@@ -2335,7 +2431,8 @@ mt7996_hw_scan(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 static void
 mt7996_cancel_hw_scan(struct ieee80211_hw *hw, struct ieee80211_vif *vif)
 {
-	struct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;
+	// struct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;
+	struct mt7996_dev *dev = mt7996_hw_dev(hw);
 	int band;
 
 	for (band = 0; band < NUM_NL80211_BANDS; band++) {
@@ -2344,17 +2441,17 @@ mt7996_cancel_hw_scan(struct ieee80211_hw *hw, struct ieee80211_vif *vif)
 		if (!hw->wiphy->bands[band])
 			continue;
 
-		phy = mt7996_band_phy(hw, band);
-		if (!(test_bit(MT76_SCANNING, &phy->mt76->state)))
+		phy = mt7996_band_phy(dev, band);
+		if (!test_bit(MT76_SCANNING, &phy->mt76->state))
 			continue;
 
 		cancel_delayed_work_sync(&phy->scan_work);
 
 		mutex_lock(&phy->dev->mt76.mutex);
 		mt7996_scan_complete(phy, true);
-		if (vif->type == NL80211_IFTYPE_STATION && !ieee80211_vif_is_mld(vif) &&
-		    (phy->mt76 != mvif->deflink.phy->mt76))
-			phy->mt76->main_phy = NULL;
+		// if (vif->type == NL80211_IFTYPE_STATION && !ieee80211_vif_is_mld(vif) &&
+		//     (phy->mt76 != mvif->deflink.phy->mt76))
+		// 	phy->mt76->main_phy = NULL;
 		mutex_unlock(&phy->dev->mt76.mutex);
 	}
 }
@@ -2362,7 +2459,8 @@ mt7996_cancel_hw_scan(struct ieee80211_hw *hw, struct ieee80211_vif *vif)
 static int
 mt7996_add_chanctx(struct ieee80211_hw *hw, struct ieee80211_chanctx_conf *conf)
 {
-	struct mt7996_phy *phy = mt7996_band_phy(hw, conf->def.chan->band);
+	struct mt7996_dev *dev = mt7996_hw_dev(hw);
+	struct mt7996_phy *phy = mt7996_band_phy(dev, conf->def.chan->band);
 	struct mt7996_chanctx *ctx = mt7996_chanctx_get(conf);
 	int ret;
 
diff --git a/mt7996/mcu.c b/mt7996/mcu.c
index 2964e9a3..62d49cfe 100644
--- a/mt7996/mcu.c
+++ b/mt7996/mcu.c
@@ -5512,6 +5512,26 @@ int mt7996_mcu_wed_rro_reset_sessions(struct mt7996_dev *dev, u16 id)
 				 sizeof(req), true);
 }
 
+int mt7996_mcu_set_sniffer_mode(struct mt7996_phy *phy, bool enabled)
+{
+	struct mt7996_dev *dev = phy->dev;
+	struct {
+		u8 band_idx;
+		u8 _rsv[3];
+		__le16 tag;
+		__le16 len;
+		u8 enable;
+		u8 _pad[3];
+	} __packed req = {
+		.band_idx = phy->mt76->band_idx,
+		.tag = 0,
+		.len = cpu_to_le16(sizeof(req) - 4),
+		.enable = enabled,
+	};
+	return mt76_mcu_send_msg(&dev->mt76, MCU_WM_UNI_CMD(SNIFFER), &req,
+				 sizeof(req), true);
+}
+
 static void
 mt7996_update_max_txpower_cur(struct mt7996_phy *phy, int tx_power)
 {
diff --git a/mt7996/mt7996.h b/mt7996/mt7996.h
index 1657f1fc..21d8435a 100644
--- a/mt7996/mt7996.h
+++ b/mt7996/mt7996.h
@@ -12,6 +12,7 @@
 #include "../mt76_connac.h"
 #include "regs.h"
 
+#define MT7996_MAX_RADIOS		3
 #define MT7996_MAX_INTERFACES		19	/* per-band */
 #define MT7996_MAX_WMM_SETS		4
 #define MT7996_WTBL_BMC_SIZE		(is_mt7992(&dev->mt76) ? 32 : 64)
@@ -500,12 +501,16 @@ struct mt7996_phy {
 
 	u32 rx_ampdu_ts;
 	u32 ampdu_ref;
+	int txpower;
 
 	struct mt76_mib_stats mib;
 	struct mt76_channel_state state_ts;
 	struct delayed_work ipi_work;
 
+	u16 orig_chainmask;
+
 	bool has_aux_rx;
+	bool counter_reset;
 
 	u8 pp_mode;
 	u16 punct_bitmap;
@@ -558,6 +563,10 @@ struct mt7996_dev {
 		struct mt76_phy mphy;
 	};
 
+	struct mt7996_phy *radio_phy[MT7996_MAX_RADIOS];
+	struct wiphy_radio radios[MT7996_MAX_RADIOS];
+	struct wiphy_radio_freq_range radio_freqs[MT7996_MAX_RADIOS];
+
 	struct mt7996_hif *hif2;
 	struct mt7996_reg_desc reg;
 	u8 q_id[MT7996_MAX_QUEUE];
@@ -808,25 +817,15 @@ mt7996_has_background_radar(struct mt7996_dev *dev)
 }
 
 static inline struct mt7996_phy *
-mt7996_band_phy(struct ieee80211_hw *hw, enum nl80211_band band)
+mt7996_band_phy(struct mt7996_dev *dev, enum nl80211_band band)
 {
-	struct mt76_phy *phy = hw->priv;
-
-	if (!(hw->wiphy->flags & WIPHY_FLAG_SUPPORTS_MLO))
-		return phy->priv;
-
-	/* TODO: mlo: temporarily hardcode */
-	if (band == NL80211_BAND_6GHZ)
-		phy = phy->dev->phys[MT_BAND2];
-	else if (band == NL80211_BAND_5GHZ)
-		phy = phy->dev->phys[MT_BAND1];
-	else
-		phy = phy->dev->phys[MT_BAND0];
+	struct mt76_phy *mphy;
 
-	if (!phy)
-		phy = hw->priv;
+	mphy = dev->mt76.band_phys[band];
+	if (!mphy)
+		return NULL;
 
-	return phy->priv;
+	return mphy->priv;
 }
 
 static inline struct mt7996_chanctx *
@@ -890,6 +889,10 @@ mt7996_get_link_wcid(struct mt7996_dev *dev, u16 idx, u8 band_idx)
 	return &mlink->wcid;
 }
 
+#define mt7996_for_each_phy(dev, phy)					\
+	for (int __i = 0; __i < ARRAY_SIZE((dev)->radio_phy); __i++)	\
+		if (((phy) = (dev)->radio_phy[__i]) != NULL)
+
 extern const struct ieee80211_ops mt7996_ops;
 extern struct pci_driver mt7996_pci_driver;
 extern struct pci_driver mt7996_hif_driver;
@@ -922,7 +925,7 @@ int mt7996_txbf_init(struct mt7996_dev *dev);
 int mt7996_get_chip_sku(struct mt7996_dev *dev);
 void mt7996_reset(struct mt7996_dev *dev);
 void mt7996_coredump(struct mt7996_dev *dev, u8 state);
-int mt7996_run(struct ieee80211_hw *hw);
+int mt7996_run(struct mt7996_phy *phy);
 int mt7996_mcu_init(struct mt7996_dev *dev);
 int mt7996_mcu_init_firmware(struct mt7996_dev *dev);
 int mt7996_mcu_twt_agrt_update(struct mt7996_dev *dev,
@@ -1022,6 +1025,7 @@ int mt7996_mcu_get_per_sta_info(struct mt76_dev *dev, u16 tag,
 int mt7996_mcu_get_rssi(struct mt76_dev *dev);
 int mt7996_mcu_get_all_sta_info(struct mt76_dev *dev, u16 tag);
 int mt7996_mcu_wed_rro_reset_sessions(struct mt7996_dev *dev, u16 id);
+int mt7996_mcu_set_sniffer_mode(struct mt7996_phy *phy, bool enabled);
 int mt7996_mcu_set_tx_power_ctrl(struct mt7996_phy *phy, u8 power_ctrl_id, u8 data);
 int mt7996_mcu_get_tx_power_info(struct mt7996_phy *phy, u8 category, void *event);
 int mt7996_mcu_apply_group_cal(struct mt7996_dev *dev);
-- 
2.45.2

