From 0331a0b58175aad51db20fe937ae66ee6eb3d3b3 Mon Sep 17 00:00:00 2001
From: Shayne Chen <shayne.chen@mediatek.com>
Date: Mon, 6 Jan 2025 18:00:56 +0800
Subject: [PATCH 13/75] sync basic mlo codebase

---
 Makefile               |    3 +-
 agg-rx.c               |   11 +
 dma.c                  |  237 ++-
 dma.h                  |   18 +-
 eeprom.c               |   85 +-
 mac80211.c             |  183 +-
 mcu.c                  |   70 +-
 mt76.h                 |  358 ++--
 mt76_connac_mac.c      |   15 +-
 mt76_connac_mcu.c      |   70 +-
 mt76_connac_mcu.h      |   54 +-
 mt7996/Makefile        |   10 +-
 mt7996/coredump.c      |  238 ++-
 mt7996/coredump.h      |   42 +-
 mt7996/debugfs.c       |  906 ++++++--
 mt7996/dma.c           |  254 ++-
 mt7996/eeprom.c        |  302 ++-
 mt7996/eeprom.h        |  147 ++
 mt7996/init.c          |  490 ++++-
 mt7996/mac.c           | 1148 +++++++---
 mt7996/main.c          | 2162 +++++++++++++++----
 mt7996/mcu.c           | 3114 ++++++++++++++++++++++-----
 mt7996/mcu.h           |  352 +++-
 mt7996/mmio.c          |   89 +-
 mt7996/mt7996.h        |  706 ++++++-
 mt7996/mt7996_trace.h  |  141 ++
 mt7996/mtk_debug.h     | 2951 ++++++++++++++++++++++++++
 mt7996/mtk_debug_i.h   | 1019 +++++++++
 mt7996/mtk_debugfs.c   | 4503 ++++++++++++++++++++++++++++++++++++++++
 mt7996/mtk_debugfs_i.c | 1017 +++++++++
 mt7996/mtk_mcu.c       | 1373 ++++++++++++
 mt7996/mtk_mcu.h       | 1167 +++++++++++
 mt7996/pci.c           |   39 +-
 mt7996/regs.h          |   64 +-
 mt7996/testmode.c      | 2192 +++++++++++++++++++
 mt7996/testmode.h      |  378 ++++
 mt7996/trace.c         |   12 +
 mt7996/vendor.c        | 1388 +++++++++++++
 mt7996/vendor.h        |  297 +++
 testmode.c             |  356 +++-
 testmode.h             |  150 +-
 tools/CMakeLists.txt   |    7 +
 tools/fields.c         |  162 +-
 tools/fwlog.c          |  247 ++-
 tools/main.c           |  127 ++
 tools/mt76-test.h      |    3 +
 trace.h                |   58 +
 tx.c                   |   81 +-
 util.c                 |   10 +-
 wed.c                  |   53 +-
 50 files changed, 26540 insertions(+), 2319 deletions(-)
 create mode 100644 mt7996/mt7996_trace.h
 create mode 100644 mt7996/mtk_debug.h
 create mode 100644 mt7996/mtk_debug_i.h
 create mode 100644 mt7996/mtk_debugfs.c
 create mode 100644 mt7996/mtk_debugfs_i.c
 create mode 100644 mt7996/mtk_mcu.c
 create mode 100644 mt7996/mtk_mcu.h
 create mode 100644 mt7996/testmode.c
 create mode 100644 mt7996/testmode.h
 create mode 100644 mt7996/trace.c
 create mode 100644 mt7996/vendor.c
 create mode 100644 mt7996/vendor.h

diff --git a/Makefile b/Makefile
index a4663ccd..f23e303f 100644
--- a/Makefile
+++ b/Makefile
@@ -1,5 +1,6 @@
 # SPDX-License-Identifier: GPL-2.0-only
 EXTRA_CFLAGS += -Werror -DCONFIG_MT76_LEDS
+ADDITIONAL_CFLAGS += $(ADDITIONAL_CFLAGS)
 obj-m := mt76.o
 obj-$(CONFIG_MT76_USB) += mt76-usb.o
 obj-$(CONFIG_MT76_SDIO) += mt76-sdio.o
@@ -11,7 +12,7 @@ obj-$(CONFIG_MT792x_USB) += mt792x-usb.o
 
 mt76-y := \
 	mmio.o util.o trace.o dma.o mac80211.o debugfs.o eeprom.o \
-	tx.o agg-rx.o mcu.o wed.o scan.o channel.o
+	tx.o agg-rx.o mcu.o wed.o
 
 mt76-$(CONFIG_PCI) += pci.o
 mt76-$(CONFIG_NL80211_TESTMODE) += testmode.o
diff --git a/agg-rx.c b/agg-rx.c
index 07c386c7..9875baa8 100644
--- a/agg-rx.c
+++ b/agg-rx.c
@@ -3,6 +3,7 @@
  * Copyright (C) 2018 Felix Fietkau <nbd@nbd.name>
  */
 #include "mt76.h"
+#include "trace.h"
 
 static unsigned long mt76_aggr_tid_to_timeo(u8 tidno)
 {
@@ -151,6 +152,7 @@ void mt76_rx_aggr_reorder(struct sk_buff *skb, struct sk_buff_head *frames)
 	struct mt76_wcid *wcid = status->wcid;
 	struct ieee80211_sta *sta;
 	struct mt76_rx_tid *tid;
+	struct mt76_phy *phy;
 	bool sn_less;
 	u16 seqno, head, size, idx;
 	u8 tidno = status->qos_ctl & IEEE80211_QOS_CTL_TID_MASK;
@@ -177,6 +179,8 @@ void mt76_rx_aggr_reorder(struct sk_buff *skb, struct sk_buff_head *frames)
 	if (!tid)
 		return;
 
+	phy = mt76_dev_phy(tid->dev, wcid->phy_idx);
+
 	status->flag |= RX_FLAG_DUP_VALIDATED;
 	spin_lock_bh(&tid->lock);
 
@@ -187,6 +191,7 @@ void mt76_rx_aggr_reorder(struct sk_buff *skb, struct sk_buff_head *frames)
 	seqno = status->seqno;
 	size = tid->size;
 	sn_less = ieee80211_sn_less(seqno, head);
+	trace_mt76_rx_aggr_reorder(tid->dev, wcid, head, seqno, sn_less);
 
 	if (!tid->started) {
 		if (sn_less)
@@ -198,6 +203,9 @@ void mt76_rx_aggr_reorder(struct sk_buff *skb, struct sk_buff_head *frames)
 	if (sn_less) {
 		__skb_unlink(skb, frames);
 		dev_kfree_skb(skb);
+		spin_lock_bh(&phy->rx_dbg_stats.lock);
+		phy->rx_dbg_stats.rx_drop[MT_RX_DROP_AGG_SN_LESS]++;
+		spin_unlock_bh(&phy->rx_dbg_stats.lock);
 		goto out;
 	}
 
@@ -224,6 +232,9 @@ void mt76_rx_aggr_reorder(struct sk_buff *skb, struct sk_buff_head *frames)
 	/* Discard if the current slot is already in use */
 	if (tid->reorder_buf[idx]) {
 		dev_kfree_skb(skb);
+		spin_lock_bh(&phy->rx_dbg_stats.lock);
+		phy->rx_dbg_stats.rx_drop[MT_RX_DROP_AGG_DUP]++;
+		spin_unlock_bh(&phy->rx_dbg_stats.lock);
 		goto out;
 	}
 
diff --git a/dma.c b/dma.c
index 2d01df74..3d9501ec 100644
--- a/dma.c
+++ b/dma.c
@@ -64,17 +64,17 @@ mt76_alloc_txwi(struct mt76_dev *dev)
 	return t;
 }
 
-static struct mt76_txwi_cache *
+static struct mt76_rxwi_cache *
 mt76_alloc_rxwi(struct mt76_dev *dev)
 {
-	struct mt76_txwi_cache *t;
+	struct mt76_rxwi_cache *r;
 
-	t = kzalloc(L1_CACHE_ALIGN(sizeof(*t)), GFP_ATOMIC);
-	if (!t)
+	r = kzalloc(L1_CACHE_ALIGN(sizeof(*r)), GFP_ATOMIC);
+	if (!r)
 		return NULL;
 
-	t->ptr = NULL;
-	return t;
+	r->ptr = NULL;
+	return r;
 }
 
 static struct mt76_txwi_cache *
@@ -93,20 +93,20 @@ __mt76_get_txwi(struct mt76_dev *dev)
 	return t;
 }
 
-static struct mt76_txwi_cache *
+static struct mt76_rxwi_cache *
 __mt76_get_rxwi(struct mt76_dev *dev)
 {
-	struct mt76_txwi_cache *t = NULL;
+	struct mt76_rxwi_cache *r = NULL;
 
-	spin_lock_bh(&dev->wed_lock);
+	spin_lock_bh(&dev->lock);
 	if (!list_empty(&dev->rxwi_cache)) {
-		t = list_first_entry(&dev->rxwi_cache, struct mt76_txwi_cache,
+		r = list_first_entry(&dev->rxwi_cache, struct mt76_rxwi_cache,
 				     list);
-		list_del(&t->list);
+		list_del(&r->list);
 	}
-	spin_unlock_bh(&dev->wed_lock);
+	spin_unlock_bh(&dev->lock);
 
-	return t;
+	return r;
 }
 
 static struct mt76_txwi_cache *
@@ -120,13 +120,13 @@ mt76_get_txwi(struct mt76_dev *dev)
 	return mt76_alloc_txwi(dev);
 }
 
-struct mt76_txwi_cache *
+struct mt76_rxwi_cache *
 mt76_get_rxwi(struct mt76_dev *dev)
 {
-	struct mt76_txwi_cache *t = __mt76_get_rxwi(dev);
+	struct mt76_rxwi_cache *r = __mt76_get_rxwi(dev);
 
-	if (t)
-		return t;
+	if (r)
+		return r;
 
 	return mt76_alloc_rxwi(dev);
 }
@@ -145,14 +145,14 @@ mt76_put_txwi(struct mt76_dev *dev, struct mt76_txwi_cache *t)
 EXPORT_SYMBOL_GPL(mt76_put_txwi);
 
 void
-mt76_put_rxwi(struct mt76_dev *dev, struct mt76_txwi_cache *t)
+mt76_put_rxwi(struct mt76_dev *dev, struct mt76_rxwi_cache *r)
 {
-	if (!t)
+	if (!r)
 		return;
 
-	spin_lock_bh(&dev->wed_lock);
-	list_add(&t->list, &dev->rxwi_cache);
-	spin_unlock_bh(&dev->wed_lock);
+	spin_lock_bh(&dev->lock);
+	list_add(&r->list, &dev->rxwi_cache);
+	spin_unlock_bh(&dev->lock);
 }
 EXPORT_SYMBOL_GPL(mt76_put_rxwi);
 
@@ -173,13 +173,13 @@ mt76_free_pending_txwi(struct mt76_dev *dev)
 void
 mt76_free_pending_rxwi(struct mt76_dev *dev)
 {
-	struct mt76_txwi_cache *t;
+	struct mt76_rxwi_cache *r;
 
 	local_bh_disable();
-	while ((t = __mt76_get_rxwi(dev)) != NULL) {
-		if (t->ptr)
-			mt76_put_page_pool_buf(t->ptr, false);
-		kfree(t);
+	while ((r = __mt76_get_rxwi(dev)) != NULL) {
+		if (r->ptr)
+			mt76_put_page_pool_buf(r->ptr, false);
+		kfree(r);
 	}
 	local_bh_enable();
 }
@@ -218,17 +218,17 @@ void __mt76_dma_queue_reset(struct mt76_dev *dev, struct mt76_queue *q,
 	mt76_dma_sync_idx(dev, q);
 }
 
-void mt76_dma_queue_reset(struct mt76_dev *dev, struct mt76_queue *q)
+void mt76_dma_queue_reset(struct mt76_dev *dev, struct mt76_queue *q, bool reset)
 {
-	__mt76_dma_queue_reset(dev, q, true);
+	__mt76_dma_queue_reset(dev, q, reset);
 }
 
 static int
 mt76_dma_add_rx_buf(struct mt76_dev *dev, struct mt76_queue *q,
-		    struct mt76_queue_buf *buf, void *data)
+		    struct mt76_queue_buf *buf, void *data,
+		    struct mt76_rxwi_cache *rxwi)
 {
 	struct mt76_queue_entry *entry = &q->entry[q->head];
-	struct mt76_txwi_cache *txwi = NULL;
 	struct mt76_desc *desc;
 	int idx = q->head;
 	u32 buf1 = 0, ctrl;
@@ -249,13 +249,18 @@ mt76_dma_add_rx_buf(struct mt76_dev *dev, struct mt76_queue *q,
 #endif
 
 	if (mt76_queue_is_wed_rx(q)) {
-		txwi = mt76_get_rxwi(dev);
-		if (!txwi)
-			return -ENOMEM;
+		if (!rxwi) {
+			rxwi = mt76_get_rxwi(dev);
+			if (!rxwi) {
+				q->rx_drop[MT_RX_DROP_DMAD_GET_RXWI_FAIL]++;
+				return -ENOMEM;
+			}
+		}
 
-		rx_token = mt76_rx_token_consume(dev, data, txwi, buf->addr);
+		rx_token = mt76_rx_token_consume(dev, data, rxwi, buf->addr);
 		if (rx_token < 0) {
-			mt76_put_rxwi(dev, txwi);
+			mt76_put_rxwi(dev, rxwi);
+			q->rx_drop[MT_RX_DROP_DMAD_GET_TOKEN_FAIL]++;
 			return -ENOMEM;
 		}
 
@@ -271,7 +276,7 @@ mt76_dma_add_rx_buf(struct mt76_dev *dev, struct mt76_queue *q,
 done:
 	entry->dma_addr[0] = buf->addr;
 	entry->dma_len[0] = buf->len;
-	entry->txwi = txwi;
+	entry->rxwi = rxwi;
 	entry->buf = data;
 	entry->wcid = 0xffff;
 	entry->skip_buf1 = true;
@@ -420,12 +425,13 @@ mt76_dma_tx_cleanup(struct mt76_dev *dev, struct mt76_queue *q, bool flush)
 
 static void *
 mt76_dma_get_buf(struct mt76_dev *dev, struct mt76_queue *q, int idx,
-		 int *len, u32 *info, bool *more, bool *drop)
+		 int *len, u32 *info, bool *more, bool *drop, bool flush)
 {
 	struct mt76_queue_entry *e = &q->entry[idx];
 	struct mt76_desc *desc = &q->desc[idx];
 	u32 ctrl, desc_info, buf1;
 	void *buf = e->buf;
+	int reason;
 
 	if (mt76_queue_is_wed_rro_ind(q))
 		goto done;
@@ -441,26 +447,89 @@ mt76_dma_get_buf(struct mt76_dev *dev, struct mt76_queue *q, int idx,
 		*info = desc_info;
 
 	buf1 = le32_to_cpu(desc->buf1);
-	mt76_dma_should_drop_buf(drop, ctrl, buf1, desc_info);
+	reason = mt76_dma_should_drop_buf(drop, ctrl, buf1, desc_info);
+	if (drop && *drop && reason >= 0)
+		q->rx_drop[reason]++;
 
 	if (mt76_queue_is_wed_rx(q)) {
+		u32 id, find = 0;
 		u32 token = FIELD_GET(MT_DMA_CTL_TOKEN, buf1);
-		struct mt76_txwi_cache *t = mt76_rx_token_release(dev, token);
+		struct mt76_rxwi_cache *r;
+
+		if (*more) {
+			spin_lock_bh(&dev->rx_token_lock);
+
+			idr_for_each_entry(&dev->rx_token, r, id) {
+				if (r->dma_addr == le32_to_cpu(desc->buf0)) {
+					find = 1;
+					token = id;
+
+					/* Write correct id back to DMA*/
+					u32p_replace_bits(&buf1, id,
+							  MT_DMA_CTL_TOKEN);
+					WRITE_ONCE(desc->buf1, cpu_to_le32(buf1));
+					break;
+				}
+			}
+
+			spin_unlock_bh(&dev->rx_token_lock);
+			if (!find) {
+				q->rx_drop[MT_RX_DROP_DMAD_ADDR_NOT_FOUND]++;
+				return NULL;
+			}
+		}
 
-		if (!t)
+		r = mt76_rx_token_release(dev, token);
+		if (!r) {
+			q->rx_drop[MT_RX_DROP_DMAD_TOKEN_NOT_FOUND]++;
 			return NULL;
+		}
 
-		dma_sync_single_for_cpu(dev->dma_dev, t->dma_addr,
+		dma_sync_single_for_cpu(dev->dma_dev, r->dma_addr,
 				SKB_WITH_OVERHEAD(q->buf_size),
 				page_pool_get_dma_dir(q->page_pool));
 
-		buf = t->ptr;
-		t->dma_addr = 0;
-		t->ptr = NULL;
+		if (flush) {
+			buf = r->ptr;
+			r->dma_addr = 0;
+			r->ptr = NULL;
+
+			mt76_put_rxwi(dev, r);
+		} else {
+			struct mt76_queue_buf qbuf = {};
+			enum dma_data_direction dir;
+			dma_addr_t addr;
+			int offset, len = SKB_WITH_OVERHEAD(q->buf_size);
+
+			buf = mt76_get_page_pool_buf(q, &offset, q->buf_size);
+			if (!buf) {
+				q->rx_drop[MT_RX_DROP_DMAD_NOMEM]++;
+				mt76_put_rxwi(dev, r);
+				return NULL;
+			}
+
+			memcpy(buf, r->ptr, len);
+
+			addr = page_pool_get_dma_addr(virt_to_head_page(buf)) + offset;
+			dir = page_pool_get_dma_dir(q->page_pool);
+			dma_sync_single_for_device(dev->dma_dev, addr, len, dir);
+
+			qbuf.addr = addr + q->buf_offset;
+			qbuf.len = len - q->buf_offset;
+			qbuf.skip_unmap = false;
+
+			if (mt76_dma_add_rx_buf(dev, q, &qbuf, r->ptr, r) < 0) {
+				mt76_put_page_pool_buf(buf, false);
+				mt76_put_rxwi(dev, r);
+				return NULL;
+			}
+		}
 
-		mt76_put_rxwi(dev, t);
-		if (drop)
+		if (drop) {
 			*drop |= !!(buf1 & MT_DMA_CTL_WO_DROP);
+			if (buf1 & MT_DMA_CTL_WO_DROP)
+				q->rx_drop[MT_RX_DROP_DMAD_WO_FRAG]++;
+		}
 	} else {
 		dma_sync_single_for_cpu(dev->dma_dev, e->dma_addr[0],
 				SKB_WITH_OVERHEAD(q->buf_size),
@@ -482,7 +551,8 @@ mt76_dma_dequeue(struct mt76_dev *dev, struct mt76_queue *q, bool flush,
 	if (!q->queued)
 		return NULL;
 
-	if (mt76_queue_is_wed_rro_data(q))
+	if (mt76_queue_is_wed_rro_data(q) ||
+	    mt76_queue_is_wed_rro_msdu_pg(q))
 		return NULL;
 
 	if (!mt76_queue_is_wed_rro_ind(q)) {
@@ -495,7 +565,7 @@ mt76_dma_dequeue(struct mt76_dev *dev, struct mt76_queue *q, bool flush,
 	q->tail = (q->tail + 1) % q->ndesc;
 	q->queued--;
 
-	return mt76_dma_get_buf(dev, q, idx, len, info, more, drop);
+	return mt76_dma_get_buf(dev, q, idx, len, info, more, drop, flush);
 }
 
 static int
@@ -504,9 +574,12 @@ mt76_dma_tx_queue_skb_raw(struct mt76_dev *dev, struct mt76_queue *q,
 {
 	struct mt76_queue_buf buf = {};
 	dma_addr_t addr;
+	int ret = -ENOMEM;
 
-	if (test_bit(MT76_MCU_RESET, &dev->phy.state))
+	if (test_bit(MT76_MCU_RESET, &dev->phy.state)) {
+		ret = -EAGAIN;
 		goto error;
+	}
 
 	if (q->queued + 1 >= q->ndesc - 1)
 		goto error;
@@ -528,7 +601,7 @@ mt76_dma_tx_queue_skb_raw(struct mt76_dev *dev, struct mt76_queue *q,
 
 error:
 	dev_kfree_skb(skb);
-	return -ENOMEM;
+	return ret;
 }
 
 static int
@@ -550,12 +623,16 @@ mt76_dma_tx_queue_skb(struct mt76_phy *phy, struct mt76_queue *q,
 	dma_addr_t addr;
 	u8 *txwi;
 
-	if (test_bit(MT76_RESET, &phy->state))
+	if (test_bit(MT76_RESET, &phy->state)) {
+		phy->tx_dbg_stats.tx_drop[MT_TX_DROP_RESET_STATE]++;
 		goto free_skb;
+	}
 
 	t = mt76_get_txwi(dev);
-	if (!t)
+	if (!t) {
+		dev->tx_dbg_stats.tx_drop[MT_TX_DROP_GET_TXWI_FAIL]++;
 		goto free_skb;
+	}
 
 	txwi = mt76_get_txwi_ptr(dev, t);
 
@@ -565,8 +642,10 @@ mt76_dma_tx_queue_skb(struct mt76_phy *phy, struct mt76_queue *q,
 
 	len = skb_headlen(skb);
 	addr = dma_map_single(dev->dma_dev, skb->data, len, DMA_TO_DEVICE);
-	if (unlikely(dma_mapping_error(dev->dma_dev, addr)))
+	if (unlikely(dma_mapping_error(dev->dma_dev, addr))) {
+		dev->tx_dbg_stats.tx_drop[MT_TX_DROP_DMA_FAIL]++;
 		goto free;
+	}
 
 	tx_info.buf[n].addr = t->dma_addr;
 	tx_info.buf[n++].len = dev->drv->txwi_size;
@@ -574,13 +653,17 @@ mt76_dma_tx_queue_skb(struct mt76_phy *phy, struct mt76_queue *q,
 	tx_info.buf[n++].len = len;
 
 	skb_walk_frags(skb, iter) {
-		if (n == ARRAY_SIZE(tx_info.buf))
+		if (n == ARRAY_SIZE(tx_info.buf)) {
+			dev->tx_dbg_stats.tx_drop[MT_TX_DROP_AGG_EXCEEDED]++;
 			goto unmap;
+		}
 
 		addr = dma_map_single(dev->dma_dev, iter->data, iter->len,
 				      DMA_TO_DEVICE);
-		if (unlikely(dma_mapping_error(dev->dma_dev, addr)))
+		if (unlikely(dma_mapping_error(dev->dma_dev, addr))) {
+			dev->tx_dbg_stats.tx_drop[MT_TX_DROP_DMA_FAIL]++;
 			goto unmap;
+		}
 
 		tx_info.buf[n].addr = addr;
 		tx_info.buf[n++].len = iter->len;
@@ -589,6 +672,7 @@ mt76_dma_tx_queue_skb(struct mt76_phy *phy, struct mt76_queue *q,
 
 	if (q->queued + (tx_info.nbuf + 1) / 2 >= q->ndesc - 1) {
 		ret = -ENOMEM;
+		phy->tx_dbg_stats.tx_drop[MT_TX_DROP_RING_FULL]++;
 		goto unmap;
 	}
 
@@ -600,6 +684,7 @@ mt76_dma_tx_queue_skb(struct mt76_phy *phy, struct mt76_queue *q,
 	if (ret < 0)
 		goto unmap;
 
+	phy->tx_dbg_stats.tx_to_hw++;
 	return mt76_dma_add_buf(dev, q, tx_info.buf, tx_info.nbuf,
 				tx_info.info, tx_info.skb, t);
 
@@ -631,8 +716,7 @@ free_skb:
 	return ret;
 }
 
-static int
-mt76_dma_rx_fill_buf(struct mt76_dev *dev, struct mt76_queue *q,
+int mt76_dma_rx_fill(struct mt76_dev *dev, struct mt76_queue *q,
 		     bool allow_direct)
 {
 	int len = SKB_WITH_OVERHEAD(q->buf_size);
@@ -641,6 +725,8 @@ mt76_dma_rx_fill_buf(struct mt76_dev *dev, struct mt76_queue *q,
 	if (!q->ndesc)
 		return 0;
 
+	spin_lock_bh(&q->lock);
+
 	while (q->queued < q->ndesc - 1) {
 		struct mt76_queue_buf qbuf = {};
 		enum dma_data_direction dir;
@@ -663,7 +749,7 @@ mt76_dma_rx_fill_buf(struct mt76_dev *dev, struct mt76_queue *q,
 done:
 		qbuf.len = len - q->buf_offset;
 		qbuf.skip_unmap = false;
-		if (mt76_dma_add_rx_buf(dev, q, &qbuf, buf) < 0) {
+		if (mt76_dma_add_rx_buf(dev, q, &qbuf, buf, NULL) < 0) {
 			mt76_put_page_pool_buf(buf, allow_direct);
 			break;
 		}
@@ -673,19 +759,6 @@ done:
 	if (frames || mt76_queue_is_wed_rx(q))
 		mt76_dma_kick_queue(dev, q);
 
-	return frames;
-}
-
-int mt76_dma_rx_fill(struct mt76_dev *dev, struct mt76_queue *q,
-		     bool allow_direct)
-{
-	int frames;
-
-	if (!q->ndesc)
-		return 0;
-
-	spin_lock_bh(&q->lock);
-	frames = mt76_dma_rx_fill_buf(dev, q, allow_direct);
 	spin_unlock_bh(&q->lock);
 
 	return frames;
@@ -745,7 +818,7 @@ mt76_dma_alloc_queue(struct mt76_dev *dev, struct mt76_queue *q,
 			return 0;
 	}
 
-	mt76_dma_queue_reset(dev, q);
+	mt76_dma_queue_reset(dev, q, true);
 
 	return 0;
 }
@@ -808,7 +881,7 @@ mt76_dma_rx_reset(struct mt76_dev *dev, enum mt76_rxq_id qid)
 		return;
 
 	mt76_dma_sync_idx(dev, q);
-	mt76_dma_rx_fill_buf(dev, q, false);
+	mt76_dma_rx_fill(dev, q, false);
 }
 
 static void
@@ -826,16 +899,19 @@ mt76_add_fragment(struct mt76_dev *dev, struct mt76_queue *q, void *data,
 		skb_add_rx_frag(skb, nr_frags, page, offset, len, q->buf_size);
 	} else {
 		mt76_put_page_pool_buf(data, allow_direct);
+		q->rx_drop[MT_RX_DROP_FRAG]++;
 	}
 
 	if (more)
 		return;
 
 	q->rx_head = NULL;
-	if (nr_frags < ARRAY_SIZE(shinfo->frags))
+	if (nr_frags < ARRAY_SIZE(shinfo->frags)) {
 		dev->drv->rx_skb(dev, q - dev->q_rx, skb, &info);
-	else
+	} else {
+		q->rx_drop[MT_RX_DROP_FRAG]++;
 		dev_kfree_skb(skb);
+	}
 }
 
 static int
@@ -871,7 +947,7 @@ mt76_dma_rx_process(struct mt76_dev *dev, struct mt76_queue *q, int budget)
 		if (!data)
 			break;
 
-		if (drop)
+		if (drop || (len == 0))
 			goto free_frag;
 
 		if (q->rx_head)
@@ -880,6 +956,7 @@ mt76_dma_rx_process(struct mt76_dev *dev, struct mt76_queue *q, int budget)
 			data_len = SKB_WITH_OVERHEAD(q->buf_size);
 
 		if (data_len < len + q->buf_offset) {
+			q->rx_drop[MT_RX_DROP_FRAG]++;
 			dev_kfree_skb(q->rx_head);
 			q->rx_head = NULL;
 			goto free_frag;
@@ -896,8 +973,10 @@ mt76_dma_rx_process(struct mt76_dev *dev, struct mt76_queue *q, int budget)
 			goto free_frag;
 
 		skb = napi_build_skb(data, q->buf_size);
-		if (!skb)
+		if (!skb) {
+			q->rx_drop[MT_RX_DROP_BUILD_SKB_FAIL]++;
 			goto free_frag;
+		}
 
 		skb_reserve(skb, q->buf_offset);
 		skb_mark_for_recycle(skb);
@@ -968,7 +1047,7 @@ mt76_dma_init(struct mt76_dev *dev,
 			continue;
 
 		netif_napi_add(&dev->napi_dev, &dev->napi[i], poll);
-		mt76_dma_rx_fill_buf(dev, &dev->q_rx[i], false);
+		mt76_dma_rx_fill(dev, &dev->q_rx[i], false);
 		napi_enable(&dev->napi[i]);
 	}
 
diff --git a/dma.h b/dma.h
index 1de5a2b2..718122d5 100644
--- a/dma.h
+++ b/dma.h
@@ -83,37 +83,39 @@ int mt76_dma_rx_fill(struct mt76_dev *dev, struct mt76_queue *q,
 		     bool allow_direct);
 void __mt76_dma_queue_reset(struct mt76_dev *dev, struct mt76_queue *q,
 			    bool reset_idx);
-void mt76_dma_queue_reset(struct mt76_dev *dev, struct mt76_queue *q);
+void mt76_dma_queue_reset(struct mt76_dev *dev, struct mt76_queue *q, bool reset);
 
 static inline void
 mt76_dma_reset_tx_queue(struct mt76_dev *dev, struct mt76_queue *q)
 {
-	dev->queue_ops->reset_q(dev, q);
+	dev->queue_ops->reset_q(dev, q, true);
 	if (mtk_wed_device_active(&dev->mmio.wed))
 		mt76_wed_dma_setup(dev, q, true);
 }
 
-static inline void
+static inline int
 mt76_dma_should_drop_buf(bool *drop, u32 ctrl, u32 buf1, u32 info)
 {
 	if (!drop)
-		return;
+		return -1;
 
 	*drop = !!(ctrl & (MT_DMA_CTL_TO_HOST_A | MT_DMA_CTL_DROP));
 	if (!(ctrl & MT_DMA_CTL_VER_MASK))
-		return;
+		return MT_RX_DROP_DMAD_WO_DROP;
 
 	switch (FIELD_GET(MT_DMA_WED_IND_REASON, buf1)) {
 	case MT_DMA_WED_IND_REASON_REPEAT:
 		*drop = true;
-		break;
+		return MT_RX_DROP_DMAD_RRO_REPEAT;
 	case MT_DMA_WED_IND_REASON_OLDPKT:
 		*drop = !(info & MT_DMA_INFO_DMA_FRAG);
-		break;
+		return MT_RX_DROP_DMAD_RRO_OLDPKT;
 	default:
 		*drop = !!(ctrl & MT_DMA_CTL_PN_CHK_FAIL);
-		break;
+		return MT_RX_DROP_DMAD_RRO_PN_CHK_FAIL;
 	}
+
+	return -1;
 }
 
 #endif
diff --git a/eeprom.c b/eeprom.c
index ab4fab11..27a898fa 100644
--- a/eeprom.c
+++ b/eeprom.c
@@ -94,8 +94,10 @@ int mt76_get_of_data_from_mtd(struct mt76_dev *dev, void *eep, int offset, int l
 	}
 
 #ifdef CONFIG_NL80211_TESTMODE
-	dev->test_mtd.name = devm_kstrdup(dev->dev, part, GFP_KERNEL);
-	dev->test_mtd.offset = offset;
+	if (len == dev->eeprom.size) {
+		dev->test_mtd.name = devm_kstrdup(dev->dev, part, GFP_KERNEL);
+		dev->test_mtd.offset = offset;
+	}
 #endif
 
 out_put_node:
@@ -159,6 +161,31 @@ static int mt76_get_of_eeprom(struct mt76_dev *dev, void *eep, int len)
 	return mt76_get_of_data_from_nvmem(dev, eep, "eeprom", len);
 }
 
+bool mt76_check_bin_file_mode(struct mt76_dev *dev)
+{
+	struct device_node *np = dev->dev->of_node;
+	const char *bin_file_name = NULL;
+
+	if (!np)
+		return false;
+
+	of_property_read_string(np, "bin_file_name", &bin_file_name);
+
+	dev->bin_file_name = bin_file_name;
+	if (dev->bin_file_name) {
+		dev_info(dev->dev, "Using bin file %s\n", dev->bin_file_name);
+#ifdef CONFIG_NL80211_TESTMODE
+		dev->test_mtd.name = devm_kstrdup(dev->dev, bin_file_name, GFP_KERNEL);
+		dev->test_mtd.offset = -1;
+#endif
+	}
+
+	of_node_put(np);
+
+	return dev->bin_file_name ? true : false;
+}
+EXPORT_SYMBOL_GPL(mt76_check_bin_file_mode);
+
 void
 mt76_eeprom_override(struct mt76_phy *phy)
 {
@@ -318,9 +345,10 @@ mt76_apply_array_limit(s8 *pwr, size_t pwr_len, const __be32 *data,
 static void
 mt76_apply_multi_array_limit(s8 *pwr, size_t pwr_len, s8 pwr_num,
 			     const __be32 *data, size_t len, s8 target_power,
-			     s8 nss_delta, s8 *max_power)
+			     s8 nss_delta)
 {
 	int i, cur;
+	s8 max_power = -128;
 
 	if (!data)
 		return;
@@ -332,7 +360,7 @@ mt76_apply_multi_array_limit(s8 *pwr, size_t pwr_len, s8 pwr_num,
 			break;
 
 		mt76_apply_array_limit(pwr + pwr_len * i, pwr_len, data + 1,
-				       target_power, nss_delta, max_power);
+				       target_power, nss_delta, &max_power);
 		if (--cur > 0)
 			continue;
 
@@ -348,6 +376,7 @@ mt76_apply_multi_array_limit(s8 *pwr, size_t pwr_len, s8 pwr_num,
 s8 mt76_get_rate_power_limits(struct mt76_phy *phy,
 			      struct ieee80211_channel *chan,
 			      struct mt76_power_limits *dest,
+			      struct mt76_power_path_limits *dest_path,
 			      s8 target_power)
 {
 	struct mt76_dev *dev = phy->dev;
@@ -355,16 +384,20 @@ s8 mt76_get_rate_power_limits(struct mt76_phy *phy,
 	const __be32 *val;
 	char name[16];
 	u32 mcs_rates = dev->drv->mcs_rates;
-	u32 ru_rates = ARRAY_SIZE(dest->ru[0]);
 	char band;
 	size_t len;
-	s8 max_power = 0;
+	s8 max_power = -127;
+	s8 max_power_backoff = -127;
 	s8 txs_delta;
+	int n_chains = hweight16(phy->chainmask);
+	s8 target_power_combine = target_power + mt76_tx_power_path_delta(n_chains);
 
 	if (!mcs_rates)
-		mcs_rates = 10;
+		mcs_rates = 12;
 
 	memset(dest, target_power, sizeof(*dest));
+	if (dest_path != NULL)
+		memset(dest_path, 0, sizeof(*dest_path));
 
 	if (!IS_ENABLED(CONFIG_OF))
 		return target_power;
@@ -410,12 +443,44 @@ s8 mt76_get_rate_power_limits(struct mt76_phy *phy,
 	val = mt76_get_of_array(np, "rates-mcs", &len, mcs_rates + 1);
 	mt76_apply_multi_array_limit(dest->mcs[0], ARRAY_SIZE(dest->mcs[0]),
 				     ARRAY_SIZE(dest->mcs), val, len,
-				     target_power, txs_delta, &max_power);
+				     target_power, txs_delta);
 
-	val = mt76_get_of_array(np, "rates-ru", &len, ru_rates + 1);
+	val = mt76_get_of_array(np, "rates-ru", &len, ARRAY_SIZE(dest->ru[0]) + 1);
 	mt76_apply_multi_array_limit(dest->ru[0], ARRAY_SIZE(dest->ru[0]),
 				     ARRAY_SIZE(dest->ru), val, len,
-				     target_power, txs_delta, &max_power);
+				     target_power, txs_delta);
+
+	val = mt76_get_of_array(np, "rates-eht", &len, ARRAY_SIZE(dest->eht[0]) + 1);
+	mt76_apply_multi_array_limit(dest->eht[0], ARRAY_SIZE(dest->eht[0]),
+				     ARRAY_SIZE(dest->eht), val, len,
+				     target_power, txs_delta);
+
+	if (dest_path == NULL)
+		return max_power;
+
+	max_power_backoff = max_power;
+
+	val = mt76_get_of_array(np, "paths-cck", &len, ARRAY_SIZE(dest_path->cck));
+	mt76_apply_array_limit(dest_path->cck, ARRAY_SIZE(dest_path->cck), val,
+			       target_power_combine, txs_delta, &max_power_backoff);
+
+	val = mt76_get_of_array(np, "paths-ofdm", &len, ARRAY_SIZE(dest_path->ofdm));
+	mt76_apply_array_limit(dest_path->ofdm, ARRAY_SIZE(dest_path->ofdm), val,
+			       target_power_combine, txs_delta, &max_power_backoff);
+
+	val = mt76_get_of_array(np, "paths-ofdm-bf", &len, ARRAY_SIZE(dest_path->ofdm_bf));
+	mt76_apply_array_limit(dest_path->ofdm_bf, ARRAY_SIZE(dest_path->ofdm_bf), val,
+			       target_power_combine, txs_delta, &max_power_backoff);
+
+	val = mt76_get_of_array(np, "paths-ru", &len, ARRAY_SIZE(dest_path->ru[0]) + 1);
+	mt76_apply_multi_array_limit(dest_path->ru[0], ARRAY_SIZE(dest_path->ru[0]),
+				     ARRAY_SIZE(dest_path->ru), val, len,
+				     target_power_combine, txs_delta);
+
+	val = mt76_get_of_array(np, "paths-ru-bf", &len, ARRAY_SIZE(dest_path->ru_bf[0]) + 1);
+	mt76_apply_multi_array_limit(dest_path->ru_bf[0], ARRAY_SIZE(dest_path->ru_bf[0]),
+				     ARRAY_SIZE(dest_path->ru_bf), val, len,
+				     target_power_combine, txs_delta);
 
 	return max_power;
 }
diff --git a/mac80211.c b/mac80211.c
index 5d419d4f..4d9c7034 100644
--- a/mac80211.c
+++ b/mac80211.c
@@ -5,27 +5,7 @@
 #include <linux/sched.h>
 #include <linux/of.h>
 #include "mt76.h"
-
-#define CHAN2G(_idx, _freq) {			\
-	.band = NL80211_BAND_2GHZ,		\
-	.center_freq = (_freq),			\
-	.hw_value = (_idx),			\
-	.max_power = 30,			\
-}
-
-#define CHAN5G(_idx, _freq) {			\
-	.band = NL80211_BAND_5GHZ,		\
-	.center_freq = (_freq),			\
-	.hw_value = (_idx),			\
-	.max_power = 30,			\
-}
-
-#define CHAN6G(_idx, _freq) {			\
-	.band = NL80211_BAND_6GHZ,		\
-	.center_freq = (_freq),			\
-	.hw_value = (_idx),			\
-	.max_power = 30,			\
-}
+#include "trace.h"
 
 static const struct ieee80211_channel mt76_channels_2ghz[] = {
 	CHAN2G(1, 2412),
@@ -55,6 +35,15 @@ static const struct ieee80211_channel mt76_channels_5ghz[] = {
 	CHAN5G(60, 5300),
 	CHAN5G(64, 5320),
 
+	CHAN5G(68, 5340),
+	CHAN5G(72, 5360),
+	CHAN5G(76, 5380),
+	CHAN5G(80, 5400),
+	CHAN5G(84, 5420),
+	CHAN5G(88, 5440),
+	CHAN5G(92, 5460),
+	CHAN5G(96, 5480),
+
 	CHAN5G(100, 5500),
 	CHAN5G(104, 5520),
 	CHAN5G(108, 5540),
@@ -431,7 +420,8 @@ mt76_phy_init(struct mt76_phy *phy, struct ieee80211_hw *hw)
 
 	INIT_LIST_HEAD(&phy->tx_list);
 	spin_lock_init(&phy->tx_lock);
-	INIT_DELAYED_WORK(&phy->roc_work, mt76_roc_complete_work);
+	spin_lock_init(&phy->tx_dbg_stats.lock);
+	spin_lock_init(&phy->rx_dbg_stats.lock);
 
 	if ((void *)phy != hw->priv)
 		return 0;
@@ -449,8 +439,10 @@ mt76_phy_init(struct mt76_phy *phy, struct ieee80211_hw *hw)
 	wiphy_ext_feature_set(wiphy, NL80211_EXT_FEATURE_AIRTIME_FAIRNESS);
 	wiphy_ext_feature_set(wiphy, NL80211_EXT_FEATURE_AQL);
 
-	wiphy->available_antennas_tx = phy->antenna_mask;
-	wiphy->available_antennas_rx = phy->antenna_mask;
+	if (!wiphy->available_antennas_tx)
+		wiphy->available_antennas_tx = phy->antenna_mask;
+	if (!wiphy->available_antennas_rx)
+		wiphy->available_antennas_rx = phy->antenna_mask;
 
 	wiphy->sar_capa = &mt76_sar_capa;
 	phy->frp = devm_kcalloc(dev->dev, wiphy->sar_capa->num_freq_ranges,
@@ -680,7 +672,7 @@ mt76_alloc_device(struct device *pdev, unsigned int size,
 	spin_lock_init(&dev->lock);
 	spin_lock_init(&dev->cc_lock);
 	spin_lock_init(&dev->status_lock);
-	spin_lock_init(&dev->wed_lock);
+	spin_lock_init(&dev->tx_dbg_stats.lock);
 	mutex_init(&dev->mutex);
 	init_waitqueue_head(&dev->tx_wait);
 
@@ -713,7 +705,7 @@ mt76_alloc_device(struct device *pdev, unsigned int size,
 	INIT_LIST_HEAD(&dev->txwi_cache);
 	INIT_LIST_HEAD(&dev->rxwi_cache);
 	dev->token_size = dev->drv->token_size;
-	INIT_DELAYED_WORK(&dev->scan_work, mt76_scan_work);
+	dev->rx_token_size = dev->drv->rx_token_size;
 
 	for (i = 0; i < ARRAY_SIZE(dev->q_rx); i++)
 		skb_queue_head_init(&dev->rx_skb[i]);
@@ -736,7 +728,7 @@ int mt76_register_device(struct mt76_dev *dev, bool vht,
 	int ret;
 
 	dev_set_drvdata(dev->dev, dev);
-	mt76_wcid_init(&dev->global_wcid, phy->band_idx);
+	mt76_wcid_init(&dev->global_wcid);
 	ret = mt76_phy_init(phy, hw);
 	if (ret)
 		return ret;
@@ -808,22 +800,6 @@ void mt76_free_device(struct mt76_dev *dev)
 }
 EXPORT_SYMBOL_GPL(mt76_free_device);
 
-static struct mt76_phy *
-mt76_vif_phy(struct ieee80211_hw *hw, struct ieee80211_vif *vif)
-{
-	struct mt76_vif_link *mlink = (struct mt76_vif_link *)vif->drv_priv;
-	struct mt76_chanctx *ctx;
-
-	if (!hw->wiphy->n_radio)
-		return hw->priv;
-
-	if (!mlink->ctx)
-		return NULL;
-
-	ctx = (struct mt76_chanctx *)mlink->ctx->drv_priv;
-	return ctx->phy;
-}
-
 static void mt76_rx_release_amsdu(struct mt76_phy *phy, enum mt76_rxq_id q)
 {
 	struct sk_buff *skb = phy->rx_amsdu[q].head;
@@ -853,6 +829,9 @@ static void mt76_rx_release_amsdu(struct mt76_phy *phy, enum mt76_rxq_id q)
 		}
 
 		if (ether_addr_equal(skb->data + offset, rfc1042_header)) {
+			spin_lock_bh(&phy->rx_dbg_stats.lock);
+			phy->rx_dbg_stats.rx_drop[MT_RX_DROP_RFC_PKT]++;
+			spin_unlock_bh(&phy->rx_dbg_stats.lock);
 			dev_kfree_skb(skb);
 			return;
 		}
@@ -890,11 +869,15 @@ void mt76_rx(struct mt76_dev *dev, enum mt76_rxq_id q, struct sk_buff *skb)
 
 	if (!test_bit(MT76_STATE_RUNNING, &phy->state)) {
 		dev_kfree_skb(skb);
+		spin_lock_bh(&phy->rx_dbg_stats.lock);
+		phy->rx_dbg_stats.rx_drop[MT_RX_DROP_STATE_ERR]++;
+		spin_unlock_bh(&phy->rx_dbg_stats.lock);
 		return;
 	}
 
 #ifdef CONFIG_NL80211_TESTMODE
-	if (phy->test.state == MT76_TM_STATE_RX_FRAMES) {
+	if (!(phy->test.flag & MT_TM_FW_RX_COUNT) &&
+	    phy->test.state == MT76_TM_STATE_RX_FRAMES) {
 		phy->test.rx_stats.packets[q]++;
 		if (status->flag & RX_FLAG_FAILED_FCS_CRC)
 			phy->test.rx_stats.fcs_error[q]++;
@@ -920,7 +903,7 @@ bool mt76_has_tx_pending(struct mt76_phy *phy)
 }
 EXPORT_SYMBOL_GPL(mt76_has_tx_pending);
 
-static struct mt76_channel_state *
+struct mt76_channel_state *
 mt76_channel_state(struct mt76_phy *phy, struct ieee80211_channel *c)
 {
 	struct mt76_sband *msband;
@@ -936,6 +919,7 @@ mt76_channel_state(struct mt76_phy *phy, struct ieee80211_channel *c)
 	idx = c - &msband->sband.channels[0];
 	return &msband->chan[idx];
 }
+EXPORT_SYMBOL_GPL(mt76_channel_state);
 
 void mt76_update_survey_active_time(struct mt76_phy *phy, ktime_t time)
 {
@@ -969,13 +953,17 @@ void mt76_update_survey(struct mt76_phy *phy)
 }
 EXPORT_SYMBOL_GPL(mt76_update_survey);
 
-int __mt76_set_channel(struct mt76_phy *phy, struct cfg80211_chan_def *chandef,
-		       bool offchannel)
+int mt76_set_channel(struct mt76_phy *phy, struct cfg80211_chan_def *chandef,
+		     bool offchannel)
 {
 	struct mt76_dev *dev = phy->dev;
 	int timeout = HZ / 5;
 	int ret;
+	unsigned long was_scanning = ieee80211_get_scanning(phy->hw);
 
+	cancel_delayed_work_sync(&phy->mac_work);
+
+	mutex_lock(&dev->mutex);
 	set_bit(MT76_RESET, &phy->state);
 
 	mt76_worker_disable(&dev->tx_worker);
@@ -991,30 +979,17 @@ int __mt76_set_channel(struct mt76_phy *phy, struct cfg80211_chan_def *chandef,
 	phy->offchannel = offchannel;
 
 	if (!offchannel)
-		phy->main_chandef = *chandef;
+		phy->main_chan = chandef->chan;
 
-	if (chandef->chan != phy->main_chandef.chan)
+	if (chandef->chan != phy->main_chan || was_scanning)
 		memset(phy->chan_state, 0, sizeof(*phy->chan_state));
+	mt76_worker_enable(&dev->tx_worker);
 
 	ret = dev->drv->set_channel(phy);
 
 	clear_bit(MT76_RESET, &phy->state);
-	mt76_worker_enable(&dev->tx_worker);
 	mt76_worker_schedule(&dev->tx_worker);
 
-	return ret;
-}
-
-int mt76_set_channel(struct mt76_phy *phy, struct cfg80211_chan_def *chandef,
-		     bool offchannel)
-{
-	struct mt76_dev *dev = phy->dev;
-	int ret;
-
-	cancel_delayed_work_sync(&phy->mac_work);
-
-	mutex_lock(&dev->mutex);
-	ret = __mt76_set_channel(phy, chandef, offchannel);
 	mutex_unlock(&dev->mutex);
 
 	return ret;
@@ -1026,8 +1001,6 @@ int mt76_update_channel(struct mt76_phy *phy)
 	struct cfg80211_chan_def *chandef = &hw->conf.chandef;
 	bool offchannel = hw->conf.flags & IEEE80211_CONF_OFFCHANNEL;
 
-	phy->radar_enabled = hw->conf.radar_enabled;
-
 	return mt76_set_channel(phy, chandef, offchannel);
 }
 EXPORT_SYMBOL_GPL(mt76_update_channel);
@@ -1182,6 +1155,7 @@ mt76_rx_convert(struct mt76_dev *dev, struct sk_buff *skb,
 {
 	struct ieee80211_rx_status *status = IEEE80211_SKB_RXCB(skb);
 	struct ieee80211_hdr *hdr = mt76_skb_get_hdr(skb);
+	struct mt76_phy *phy;
 	struct mt76_rx_status mstat;
 
 	mstat = *((struct mt76_rx_status *)skb->cb);
@@ -1229,6 +1203,11 @@ mt76_rx_convert(struct mt76_dev *dev, struct sk_buff *skb,
 
 	*sta = wcid_to_sta(mstat.wcid);
 	*hw = mt76_phy_hw(dev, mstat.phy_idx);
+
+	phy = mt76_dev_phy(dev, mstat.phy_idx);
+	spin_lock_bh(&phy->rx_dbg_stats.lock);
+	phy->rx_dbg_stats.rx_to_mac80211++;
+	spin_unlock_bh(&phy->rx_dbg_stats.lock);
 }
 
 static void
@@ -1462,6 +1441,7 @@ void mt76_rx_complete(struct mt76_dev *dev, struct sk_buff_head *frames,
 
 		mt76_check_ccmp_pn(skb);
 		skb_shinfo(skb)->frag_list = NULL;
+		trace_mt76_rx_complete(dev, (struct mt76_rx_status *)skb->cb, 0);
 		mt76_rx_convert(dev, skb, &hw, &sta);
 		ieee80211_rx_list(hw, sta, skb, &list);
 
@@ -1471,6 +1451,7 @@ void mt76_rx_complete(struct mt76_dev *dev, struct sk_buff_head *frames,
 			nskb = nskb->next;
 			skb->next = NULL;
 
+			trace_mt76_rx_complete(dev, (struct mt76_rx_status *)skb->cb, 1);
 			mt76_rx_convert(dev, skb, &hw, &sta);
 			ieee80211_rx_list(hw, sta, skb, &list);
 		}
@@ -1523,6 +1504,9 @@ mt76_sta_add(struct mt76_phy *phy, struct ieee80211_vif *vif,
 	if (ret)
 		goto out;
 
+	if (phy->hw->wiphy->flags & WIPHY_FLAG_SUPPORTS_MLO)
+		goto out;
+
 	for (i = 0; i < ARRAY_SIZE(sta->txq); i++) {
 		struct mt76_txq *mtxq;
 
@@ -1534,44 +1518,46 @@ mt76_sta_add(struct mt76_phy *phy, struct ieee80211_vif *vif,
 	}
 
 	ewma_signal_init(&wcid->rssi);
+	if (phy->band_idx == MT_BAND1)
+		mt76_wcid_mask_set(dev->wcid_phy_mask, wcid->idx);
+	wcid->phy_idx = phy->band_idx;
 	rcu_assign_pointer(dev->wcid[wcid->idx], wcid);
-	phy->num_sta++;
 
-	mt76_wcid_init(wcid, phy->band_idx);
+	mt76_wcid_init(wcid);
 out:
 	mutex_unlock(&dev->mutex);
 
 	return ret;
 }
 
-void __mt76_sta_remove(struct mt76_phy *phy, struct ieee80211_vif *vif,
+void __mt76_sta_remove(struct mt76_dev *dev, struct ieee80211_vif *vif,
 		       struct ieee80211_sta *sta)
 {
-	struct mt76_dev *dev = phy->dev;
 	struct mt76_wcid *wcid = (struct mt76_wcid *)sta->drv_priv;
 	int i, idx = wcid->idx;
 
-	for (i = 0; i < ARRAY_SIZE(wcid->aggr); i++)
+	for (i = 0; !sta->valid_links && i < ARRAY_SIZE(wcid->aggr); i++)
 		mt76_rx_aggr_stop(dev, wcid, i);
 
 	if (dev->drv->sta_remove)
 		dev->drv->sta_remove(dev, vif, sta);
 
+	if (sta->valid_links)
+		return;
+
 	mt76_wcid_cleanup(dev, wcid);
 
 	mt76_wcid_mask_clear(dev->wcid_mask, idx);
-	phy->num_sta--;
+	mt76_wcid_mask_clear(dev->wcid_phy_mask, idx);
 }
 EXPORT_SYMBOL_GPL(__mt76_sta_remove);
 
 static void
-mt76_sta_remove(struct mt76_phy *phy, struct ieee80211_vif *vif,
+mt76_sta_remove(struct mt76_dev *dev, struct ieee80211_vif *vif,
 		struct ieee80211_sta *sta)
 {
-	struct mt76_dev *dev = phy->dev;
-
 	mutex_lock(&dev->mutex);
-	__mt76_sta_remove(phy, vif, sta);
+	__mt76_sta_remove(dev, vif, sta);
 	mutex_unlock(&dev->mutex);
 }
 
@@ -1584,17 +1570,13 @@ int mt76_sta_state(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 	struct mt76_dev *dev = phy->dev;
 	enum mt76_sta_event ev;
 
-	phy = mt76_vif_phy(hw, vif);
-	if (!phy)
-		return -EINVAL;
-
 	if (old_state == IEEE80211_STA_NOTEXIST &&
 	    new_state == IEEE80211_STA_NONE)
 		return mt76_sta_add(phy, vif, sta);
 
 	if (old_state == IEEE80211_STA_NONE &&
 	    new_state == IEEE80211_STA_NOTEXIST)
-		mt76_sta_remove(phy, vif, sta);
+		mt76_sta_remove(dev, vif, sta);
 
 	if (!dev->drv->sta_event)
 		return 0;
@@ -1630,19 +1612,14 @@ void mt76_sta_pre_rcu_remove(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 }
 EXPORT_SYMBOL_GPL(mt76_sta_pre_rcu_remove);
 
-void mt76_wcid_init(struct mt76_wcid *wcid, u8 band_idx)
+void mt76_wcid_init(struct mt76_wcid *wcid)
 {
-	wcid->hw_key_idx = -1;
-	wcid->phy_idx = band_idx;
-
 	INIT_LIST_HEAD(&wcid->tx_list);
 	skb_queue_head_init(&wcid->tx_pending);
 	skb_queue_head_init(&wcid->tx_offchannel);
 
 	INIT_LIST_HEAD(&wcid->list);
 	idr_init(&wcid->pktid);
-
-	INIT_LIST_HEAD(&wcid->poll_list);
 }
 EXPORT_SYMBOL_GPL(mt76_wcid_init);
 
@@ -1677,29 +1654,13 @@ void mt76_wcid_cleanup(struct mt76_dev *dev, struct mt76_wcid *wcid)
 }
 EXPORT_SYMBOL_GPL(mt76_wcid_cleanup);
 
-void mt76_wcid_add_poll(struct mt76_dev *dev, struct mt76_wcid *wcid)
-{
-	if (test_bit(MT76_MCU_RESET, &dev->phy.state))
-		return;
-
-	spin_lock_bh(&dev->sta_poll_lock);
-	if (list_empty(&wcid->poll_list))
-		list_add_tail(&wcid->poll_list, &dev->sta_poll_list);
-	spin_unlock_bh(&dev->sta_poll_lock);
-}
-EXPORT_SYMBOL_GPL(mt76_wcid_add_poll);
-
 int mt76_get_txpower(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 		     int *dbm)
 {
-	struct mt76_phy *phy = mt76_vif_phy(hw, vif);
-	int n_chains, delta;
-
-	if (!phy)
-		return -EINVAL;
+	struct mt76_phy *phy = hw->priv;
+	int n_chains = hweight16(phy->chainmask);
+	int delta = mt76_tx_power_path_delta(n_chains);
 
-	n_chains = hweight16(phy->chainmask);
-	delta = mt76_tx_power_path_delta(n_chains);
 	*dbm = DIV_ROUND_UP(phy->txpower_cur + delta, 2);
 
 	return 0;
@@ -1984,15 +1945,3 @@ enum mt76_dfs_state mt76_phy_dfs_state(struct mt76_phy *phy)
 	return MT_DFS_STATE_ACTIVE;
 }
 EXPORT_SYMBOL_GPL(mt76_phy_dfs_state);
-
-void mt76_vif_cleanup(struct mt76_dev *dev, struct ieee80211_vif *vif)
-{
-	struct mt76_vif_link *mlink = (struct mt76_vif_link *)vif->drv_priv;
-	struct mt76_vif_data *mvif = mlink->mvif;
-
-	rcu_assign_pointer(mvif->link[0], NULL);
-	mt76_abort_scan(dev);
-	if (mvif->roc_phy)
-		mt76_abort_roc(mvif->roc_phy);
-}
-EXPORT_SYMBOL_GPL(mt76_vif_cleanup);
diff --git a/mcu.c b/mcu.c
index 3353012e..700d3ce8 100644
--- a/mcu.c
+++ b/mcu.c
@@ -4,6 +4,7 @@
  */
 
 #include "mt76.h"
+#include "mt76_connac.h"
 
 struct sk_buff *
 __mt76_mcu_msg_alloc(struct mt76_dev *dev, const void *data,
@@ -74,7 +75,7 @@ int mt76_mcu_skb_send_and_get_msg(struct mt76_dev *dev, struct sk_buff *skb,
 				  struct sk_buff **ret_skb)
 {
 	unsigned int retry = 0;
-	struct sk_buff *orig_skb = NULL;
+	struct sk_buff *skb_tmp;
 	unsigned long expires;
 	int ret, seq;
 
@@ -83,48 +84,49 @@ int mt76_mcu_skb_send_and_get_msg(struct mt76_dev *dev, struct sk_buff *skb,
 
 	mutex_lock(&dev->mcu.mutex);
 
-	if (dev->mcu_ops->mcu_skb_prepare_msg) {
-		orig_skb = skb;
-		ret = dev->mcu_ops->mcu_skb_prepare_msg(dev, skb, cmd, &seq);
-		if (ret < 0)
+	while (retry < dev->mcu_ops->max_retry) {
+		skb_tmp = mt76_mcu_msg_alloc(dev, skb->data, skb->len);
+		if (!skb_tmp)
 			goto out;
-	}
-
-retry:
-	/* orig skb might be needed for retry, mcu_skb_send_msg consumes it */
-	if (orig_skb)
-		skb_get(orig_skb);
-	ret = dev->mcu_ops->mcu_skb_send_msg(dev, skb, cmd, &seq);
-	if (ret < 0)
-		goto out;
-
-	if (!wait_resp) {
-		ret = 0;
-		goto out;
-	}
-
-	expires = jiffies + dev->mcu.timeout;
 
-	do {
-		skb = mt76_mcu_get_response(dev, expires);
-		if (!skb && !test_bit(MT76_MCU_RESET, &dev->phy.state) &&
-		    orig_skb && retry++ < dev->mcu_ops->max_retry) {
+		if (wait_resp && retry) {
+			if (test_bit(MT76_MCU_RESET, &dev->phy.state))
+				usleep_range(200000, 500000);
 			dev_err(dev->dev, "Retry message %08x (seq %d)\n",
 				cmd, seq);
-			skb = orig_skb;
-			goto retry;
 		}
 
-		ret = dev->mcu_ops->mcu_parse_response(dev, cmd, skb, seq);
-		if (!ret && ret_skb)
-			*ret_skb = skb;
-		else
-			dev_kfree_skb(skb);
-	} while (ret == -EAGAIN);
+		ret = dev->mcu_ops->mcu_skb_send_msg(dev, skb_tmp, cmd, &seq);
+		if (ret < 0 && ret != -EAGAIN)
+			goto out;
 
+		if (!wait_resp) {
+			ret = 0;
+			goto out;
+		}
+
+		expires = jiffies + dev->mcu.timeout;
+
+		do {
+			skb_tmp = mt76_mcu_get_response(dev, expires);
+			ret = dev->mcu_ops->mcu_parse_response(dev, cmd, skb_tmp, seq);
+			if (ret == -ETIMEDOUT)
+				break;
+
+			if (!ret && ret_skb)
+				*ret_skb = skb_tmp;
+			else
+				dev_kfree_skb(skb_tmp);
+
+			if (ret != -EAGAIN)
+				goto out;
+		} while (ret == -EAGAIN);
+
+		retry++;
+	}
 
 out:
-	dev_kfree_skb(orig_skb);
+	dev_kfree_skb(skb);
 	mutex_unlock(&dev->mcu.mutex);
 
 	return ret;
diff --git a/mt76.h b/mt76.h
index 711d82a0..a26f64d1 100644
--- a/mt76.h
+++ b/mt76.h
@@ -24,6 +24,27 @@
 #include "util.h"
 #include "testmode.h"
 
+#define CHAN2G(_idx, _freq) {			\
+	.band = NL80211_BAND_2GHZ,		\
+	.center_freq = (_freq),			\
+	.hw_value = (_idx),			\
+	.max_power = 30,			\
+}
+
+#define CHAN5G(_idx, _freq) {			\
+	.band = NL80211_BAND_5GHZ,		\
+	.center_freq = (_freq),			\
+	.hw_value = (_idx),			\
+	.max_power = 30,			\
+}
+
+#define CHAN6G(_idx, _freq) {			\
+	.band = NL80211_BAND_6GHZ,		\
+	.center_freq = (_freq),			\
+	.hw_value = (_idx),			\
+	.max_power = 30,			\
+}
+
 #define MT_MCU_RING_SIZE	32
 #define MT_RX_BUF_SIZE		2048
 #define MT_SKB_HEAD_LEN		256
@@ -33,6 +54,8 @@
 
 #define MT76_TOKEN_FREE_THR	64
 
+#define MT76_WED_SW_TOKEN_SIZE	15360
+
 #define MT_QFLAG_WED_RING	GENMASK(1, 0)
 #define MT_QFLAG_WED_TYPE	GENMASK(4, 2)
 #define MT_QFLAG_WED		BIT(5)
@@ -55,8 +78,6 @@ struct mt76_dev;
 struct mt76_phy;
 struct mt76_wcid;
 struct mt76s_intr;
-struct mt76_chanctx;
-struct mt76_vif_link;
 
 struct mt76_reg_pair {
 	u32 reg;
@@ -167,6 +188,34 @@ enum mt76_dfs_state {
 	MT_DFS_STATE_ACTIVE,
 };
 
+enum {
+	/* Per dev counters*/
+	MT_RX_DROP_DMAD_RRO_REPEAT,
+	MT_RX_DROP_DMAD_RRO_OLDPKT,
+	MT_RX_DROP_DMAD_RRO_PN_CHK_FAIL,
+	MT_RX_DROP_DMAD_WO_FRAG,
+	MT_RX_DROP_DMAD_WO_DROP,
+	MT_RX_DROP_DMAD_ADDR_NOT_FOUND,
+	MT_RX_DROP_DMAD_TOKEN_NOT_FOUND,
+	MT_RX_DROP_DMAD_GET_TOKEN_FAIL,
+	MT_RX_DROP_DMAD_GET_RXWI_FAIL,
+	MT_RX_DROP_DMAD_NOMEM,
+	MT_RX_DROP_DMAD_DMA_MAPPING_FAIL,
+	MT_RX_DROP_FRAG,
+	MT_RX_DROP_BUILD_SKB_FAIL,
+
+	MT_RX_DROP_PER_Q_MAX,
+
+	/* Per phy counters */
+	MT_RX_DROP_RXD_ERR = 0,
+	MT_RX_DROP_STATE_ERR,
+	MT_RX_DROP_RFC_PKT,
+	MT_RX_DROP_AGG_SN_LESS,
+	MT_RX_DROP_AGG_DUP,
+
+	MT_RX_DROP_PER_PHY_MAX,
+};
+
 struct mt76_queue_buf {
 	dma_addr_t addr;
 	u16 len:15,
@@ -187,6 +236,7 @@ struct mt76_queue_entry {
 	};
 	union {
 		struct mt76_txwi_cache *txwi;
+		struct mt76_rxwi_cache *rxwi;
 		struct urb *urb;
 		int buf_sz;
 	};
@@ -234,6 +284,7 @@ struct mt76_queue {
 	dma_addr_t desc_dma;
 	struct sk_buff *rx_head;
 	struct page_pool *page_pool;
+	u32 rx_drop[MT_RX_DROP_PER_Q_MAX];
 };
 
 struct mt76_mcu_ops {
@@ -285,7 +336,7 @@ struct mt76_queue_ops {
 
 	void (*kick)(struct mt76_dev *dev, struct mt76_queue *q);
 
-	void (*reset_q)(struct mt76_dev *dev, struct mt76_queue *q);
+	void (*reset_q)(struct mt76_dev *dev, struct mt76_queue *q, bool reset);
 };
 
 enum mt76_phy_type {
@@ -314,11 +365,13 @@ struct mt76_sta_stats {
 	u32 tx_packets;		/* unit: MSDU */
 	u32 tx_retries;
 	u32 tx_failed;
+	u64 tx_airtime;
 	/* WED RX */
 	u64 rx_bytes;
 	u32 rx_packets;
 	u32 rx_errors;
 	u32 rx_drops;
+	u64 rx_airtime;
 };
 
 enum mt76_wcid_flags {
@@ -356,7 +409,6 @@ struct mt76_wcid {
 	u8 hw_key_idx;
 	u8 hw_key_idx2;
 
-	u8 offchannel:1;
 	u8 sta:1;
 	u8 sta_disabled:1;
 	u8 amsdu:1;
@@ -408,10 +460,16 @@ struct mt76_txwi_cache {
 	struct list_head list;
 	dma_addr_t dma_addr;
 
-	union {
-		struct sk_buff *skb;
-		void *ptr;
-	};
+	unsigned long jiffies;
+
+	struct sk_buff *skb;
+};
+
+struct mt76_rxwi_cache {
+	struct list_head list;
+	dma_addr_t dma_addr;
+
+	void *ptr;
 };
 
 struct mt76_rx_tid {
@@ -428,6 +486,7 @@ struct mt76_rx_tid {
 	u16 nframes;
 
 	u8 num;
+	u16 session_id;
 
 	u8 started:1, stopped:1, timer_pending:1;
 
@@ -504,8 +563,7 @@ struct mt76_driver_ops {
 	u16 txwi_size;
 	u16 token_size;
 	u8 mcs_rates;
-
-	unsigned int link_data_size;
+	u16 rx_token_size;
 
 	void (*update_survey)(struct mt76_phy *phy);
 	int (*set_channel)(struct mt76_phy *phy);
@@ -538,15 +596,6 @@ struct mt76_driver_ops {
 
 	void (*sta_remove)(struct mt76_dev *dev, struct ieee80211_vif *vif,
 			   struct ieee80211_sta *sta);
-
-	int (*vif_link_add)(struct mt76_phy *phy, struct ieee80211_vif *vif,
-			    struct ieee80211_bss_conf *link_conf,
-			    struct mt76_vif_link *mlink);
-
-	void (*vif_link_remove)(struct mt76_phy *phy,
-				struct ieee80211_vif *vif,
-				struct ieee80211_bss_conf *link_conf,
-				struct mt76_vif_link *mlink);
 };
 
 struct mt76_channel_state {
@@ -730,14 +779,22 @@ struct mt76_testmode_ops {
 	int (*set_params)(struct mt76_phy *phy, struct nlattr **tb,
 			  enum mt76_testmode_state new_state);
 	int (*dump_stats)(struct mt76_phy *phy, struct sk_buff *msg);
+	void (*reset_rx_stats)(struct mt76_phy *phy);
+	void (*tx_stop)(struct mt76_phy *phy);
+	int (*set_eeprom)(struct mt76_phy *phy, u32 offset, u8 *val, u8 action);
+	int (*dump_precal)(struct mt76_phy *mphy, struct sk_buff *msg, int flag, int type);
 };
 
+#define MT_TM_FW_RX_COUNT	BIT(0)
+
 struct mt76_testmode_data {
 	enum mt76_testmode_state state;
 
 	u32 param_set[DIV_ROUND_UP(NUM_MT76_TM_ATTRS, 32)];
 	struct sk_buff *tx_skb;
 
+	u8 sku_en;
+
 	u32 tx_count;
 	u16 tx_mpdu_len;
 
@@ -747,6 +804,7 @@ struct mt76_testmode_data {
 	u8 tx_rate_sgi;
 	u8 tx_rate_ldpc;
 	u8 tx_rate_stbc;
+	u16 tx_preamble_puncture;
 	u8 tx_ltf;
 
 	u8 tx_antenna_mask;
@@ -756,6 +814,14 @@ struct mt76_testmode_data {
 	u32 tx_time;
 	u32 tx_ipg;
 
+	u8 txbf_act;
+	u16 txbf_param[8];
+	bool is_txbf_dut;
+	bool bf_en;
+	bool bf_ever_en;
+	bool ibf;
+	bool ebf;
+
 	u32 freq_offset;
 
 	u8 tx_power[4];
@@ -770,10 +836,27 @@ struct mt76_testmode_data {
 	struct {
 		u64 packets[__MT_RXQ_MAX];
 		u64 fcs_error[__MT_RXQ_MAX];
+		u64 len_mismatch;
 	} rx_stats;
+	u8 flag;
+
+	struct {
+		u8 type;
+		u8 enable;
+	} cfg;
+
+	u8 aid;
+
+	u8 offchan_ch;
+	u8 offchan_center_ch;
+	u8 offchan_bw;
+
+	u8 ipi_threshold;
+	u32 ipi_period;
+	u8 ipi_reset;
 };
 
-struct mt76_vif_link {
+struct mt76_vif {
 	u8 idx;
 	u8 omac_idx;
 	u8 band_idx;
@@ -783,20 +866,40 @@ struct mt76_vif_link {
 	u8 basic_rates_idx;
 	u8 mcast_rates_idx;
 	u8 beacon_rates_idx;
-	bool offchannel;
 	struct ieee80211_chanctx_conf *ctx;
-	struct mt76_wcid *wcid;
-	struct mt76_vif_data *mvif;
-	struct rcu_head rcu_head;
 };
 
-struct mt76_vif_data {
-	struct mt76_vif_link __rcu *link[IEEE80211_MLD_MAX_NUM_LINKS];
-	struct mt76_vif_link __rcu *offchannel_link;
+enum {
+	MT_TX_DROP_IN_TESTMODE,
+	MT_TX_DROP_WCID_NOT_INIT,
+	MT_TX_DROP_STOPPED_QUEUE,
+	MT_TX_DROP_RESET_STATE,
+	MT_TX_DROP_GET_TXWI_FAIL,
+	MT_TX_DROP_DMA_FAIL,
+	MT_TX_DROP_AGG_EXCEEDED,
+	MT_TX_DROP_RING_FULL,
+	MT_TX_DROP_INVALID_SKB,
+	MT_TX_DROP_GET_TOKEN_FAIL,
+	MT_TX_DROP_ADDR_TRANS_FAIL,
+	MT_TX_DROP_INVALID_WCID,
+	MT_TX_DROP_INVALID_LINK,
+	MT_TX_DROP_MAX,
+};
+
+struct mt76_tx_debug {
+	u32 tx_from_mac80211;
+	u32 tx_to_hw;
 
-	struct mt76_phy *roc_phy;
-	u16 valid_links;
-	u8 deflink_id;
+	u32 tx_drop[MT_TX_DROP_MAX];
+	spinlock_t lock;
+};
+
+struct mt76_rx_debug {
+	u32 rx_from_hw;
+	u32 rx_to_mac80211;
+
+	u32 rx_drop[MT_RX_DROP_PER_PHY_MAX];
+	spinlock_t lock;
 };
 
 struct mt76_phy {
@@ -805,7 +908,6 @@ struct mt76_phy {
 	void *priv;
 
 	unsigned long state;
-	unsigned int num_sta;
 	u8 band_idx;
 
 	spinlock_t tx_lock;
@@ -813,18 +915,12 @@ struct mt76_phy {
 	struct mt76_queue *q_tx[__MT_TXQ_MAX];
 
 	struct cfg80211_chan_def chandef;
-	struct cfg80211_chan_def main_chandef;
+	struct ieee80211_channel *main_chan;
 	bool offchannel;
-	bool radar_enabled;
-
-	struct delayed_work roc_work;
-	struct ieee80211_vif *roc_vif;
-	struct mt76_vif_link *roc_link;
-
-	struct mt76_chanctx *chanctx;
 
 	struct mt76_channel_state *chan_state;
 	enum mt76_dfs_state dfs_state;
+	bool radar_enabled;
 	ktime_t survey_time;
 
 	u32 aggr_stats[32];
@@ -861,6 +957,8 @@ struct mt76_phy {
 		bool al;
 		u8 pin;
 	} leds;
+	struct mt76_tx_debug tx_dbg_stats;
+	struct mt76_rx_debug rx_dbg_stats;
 };
 
 struct mt76_dev {
@@ -870,7 +968,6 @@ struct mt76_dev {
 
 	struct ieee80211_hw *hw;
 
-	spinlock_t wed_lock;
 	spinlock_t lock;
 	spinlock_t cc_lock;
 
@@ -922,6 +1019,7 @@ struct mt76_dev {
 	spinlock_t status_lock;
 
 	u32 wcid_mask[DIV_ROUND_UP(MT76_N_WCIDS, 32)];
+	u32 wcid_phy_mask[DIV_ROUND_UP(MT76_N_WCIDS, 32)];
 
 	u64 vif_mask;
 
@@ -950,16 +1048,6 @@ struct mt76_dev {
 
 	u32 rxfilter;
 
-	struct delayed_work scan_work;
-	struct {
-		struct cfg80211_scan_request *req;
-		struct ieee80211_channel *chan;
-		struct ieee80211_vif *vif;
-		struct mt76_vif_link *mlink;
-		struct mt76_phy *phy;
-		int chan_idx;
-	} scan;
-
 #ifdef CONFIG_NL80211_TESTMODE
 	const struct mt76_testmode_ops *test_ops;
 	struct {
@@ -974,8 +1062,12 @@ struct mt76_dev {
 		struct mt76_usb usb;
 		struct mt76_sdio sdio;
 	};
+
+	const char *bin_file_name;
+	struct mt76_tx_debug tx_dbg_stats;
 };
 
+#define MT76_MAX_AMSDU_NUM 8
 /* per-phy stats.  */
 struct mt76_mib_stats {
 	u32 ack_fail_cnt;
@@ -1035,7 +1127,7 @@ struct mt76_mib_stats {
 	u32 rx_vec_queue_overflow_drop_cnt;
 	u32 rx_ba_cnt;
 
-	u32 tx_amsdu[8];
+	u32 tx_amsdu[MT76_MAX_AMSDU_NUM];
 	u32 tx_amsdu_cnt;
 
 	/* mcu_muru_stats */
@@ -1079,6 +1171,14 @@ struct mt76_power_limits {
 	s8 eht[16][16];
 };
 
+struct mt76_power_path_limits {
+	s8 cck[5];
+	s8 ofdm[5];
+	s8 ofdm_bf[4];
+	s8 ru[16][15];
+	s8 ru_bf[16][15];
+};
+
 struct mt76_ethtool_worker_info {
 	u64 *data;
 	int idx;
@@ -1087,10 +1187,6 @@ struct mt76_ethtool_worker_info {
 	int sta_count;
 };
 
-struct mt76_chanctx {
-	struct mt76_phy *phy;
-};
-
 #define CCK_RATE(_idx, _rate) {					\
 	.bitrate = _rate,					\
 	.flags = IEEE80211_RATE_SHORT_PREAMBLE,			\
@@ -1211,10 +1307,6 @@ static inline int mt76_wed_dma_setup(struct mt76_dev *dev, struct mt76_queue *q,
 	for (i = 0; i < ARRAY_SIZE((dev)->q_rx); i++)	\
 		if ((dev)->q_rx[i].ndesc)
 
-
-#define mt76_dereference(p, dev) \
-	rcu_dereference_protected(p, lockdep_is_held(&(dev)->mutex))
-
 struct mt76_dev *mt76_alloc_device(struct device *pdev, unsigned int size,
 				   const struct ieee80211_ops *ops,
 				   const struct mt76_driver_ops *drv_ops);
@@ -1248,6 +1340,7 @@ void mt76_eeprom_override(struct mt76_phy *phy);
 int mt76_get_of_data_from_mtd(struct mt76_dev *dev, void *eep, int offset, int len);
 int mt76_get_of_data_from_nvmem(struct mt76_dev *dev, void *eep,
 				const char *cell_name, int len);
+bool mt76_check_bin_file_mode(struct mt76_dev *dev);
 
 struct mt76_queue *
 mt76_init_queue(struct mt76_dev *dev, int qid, int idx, int n_desc,
@@ -1317,6 +1410,22 @@ static inline int mt76_decr(int val, int size)
 
 u8 mt76_ac_to_hwq(u8 ac);
 
+static inline u8
+mt76_ac_to_tid(u8 ac)
+{
+	static const u8 ac_to_tid[] = {
+		[IEEE80211_AC_BE] = 0,
+		[IEEE80211_AC_BK] = 1,
+		[IEEE80211_AC_VI] = 4,
+		[IEEE80211_AC_VO] = 6
+	};
+
+	if (WARN_ON(ac >= IEEE80211_NUM_ACS))
+		return 0;
+
+	return ac_to_tid[ac];
+}
+
 static inline struct ieee80211_txq *
 mtxq_to_txq(struct mt76_txq *mtxq)
 {
@@ -1443,6 +1552,8 @@ void mt76_release_buffered_frames(struct ieee80211_hw *hw,
 				  bool more_data);
 bool mt76_has_tx_pending(struct mt76_phy *phy);
 int mt76_update_channel(struct mt76_phy *phy);
+struct mt76_channel_state *
+mt76_channel_state(struct mt76_phy *phy, struct ieee80211_channel *c);
 void mt76_update_survey(struct mt76_phy *phy);
 void mt76_update_survey_active_time(struct mt76_phy *phy, ktime_t time);
 int mt76_get_survey(struct ieee80211_hw *hw, int idx,
@@ -1482,12 +1593,12 @@ int mt76_sta_state(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 		   struct ieee80211_sta *sta,
 		   enum ieee80211_sta_state old_state,
 		   enum ieee80211_sta_state new_state);
-void __mt76_sta_remove(struct mt76_phy *phy, struct ieee80211_vif *vif,
+void __mt76_sta_remove(struct mt76_dev *dev, struct ieee80211_vif *vif,
 		       struct ieee80211_sta *sta);
 void mt76_sta_pre_rcu_remove(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 			     struct ieee80211_sta *sta);
 
-int mt76_get_min_avg_rssi(struct mt76_dev *dev, u8 phy_idx);
+int mt76_get_min_avg_rssi(struct mt76_dev *dev, bool ext_phy);
 
 int mt76_get_txpower(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 		     int *dbm);
@@ -1506,38 +1617,11 @@ void mt76_insert_ccmp_hdr(struct sk_buff *skb, u8 key_id);
 int mt76_get_rate(struct mt76_dev *dev,
 		  struct ieee80211_supported_band *sband,
 		  int idx, bool cck);
-int mt76_hw_scan(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
-		 struct ieee80211_scan_request *hw_req);
-void mt76_cancel_hw_scan(struct ieee80211_hw *hw, struct ieee80211_vif *vif);
 void mt76_sw_scan(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 		  const u8 *mac);
 void mt76_sw_scan_complete(struct ieee80211_hw *hw,
 			   struct ieee80211_vif *vif);
 enum mt76_dfs_state mt76_phy_dfs_state(struct mt76_phy *phy);
-int mt76_add_chanctx(struct ieee80211_hw *hw,
-		     struct ieee80211_chanctx_conf *conf);
-void mt76_remove_chanctx(struct ieee80211_hw *hw,
-			 struct ieee80211_chanctx_conf *conf);
-void mt76_change_chanctx(struct ieee80211_hw *hw,
-			 struct ieee80211_chanctx_conf *conf,
-			 u32 changed);
-int mt76_assign_vif_chanctx(struct ieee80211_hw *hw,
-			    struct ieee80211_vif *vif,
-			    struct ieee80211_bss_conf *link_conf,
-			    struct ieee80211_chanctx_conf *conf);
-void mt76_unassign_vif_chanctx(struct ieee80211_hw *hw,
-			       struct ieee80211_vif *vif,
-			       struct ieee80211_bss_conf *link_conf,
-			       struct ieee80211_chanctx_conf *conf);
-int mt76_switch_vif_chanctx(struct ieee80211_hw *hw,
-			    struct ieee80211_vif_chanctx_switch *vifs,
-			    int n_vifs,
-			    enum ieee80211_chanctx_switch_mode mode);
-int mt76_remain_on_channel(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
-			   struct ieee80211_channel *chan, int duration,
-			   enum ieee80211_roc_type type);
-int mt76_cancel_remain_on_channel(struct ieee80211_hw *hw,
-				  struct ieee80211_vif *vif);
 int mt76_testmode_cmd(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 		      void *data, int len);
 int mt76_testmode_dump(struct ieee80211_hw *hw, struct sk_buff *skb,
@@ -1545,6 +1629,24 @@ int mt76_testmode_dump(struct ieee80211_hw *hw, struct sk_buff *skb,
 int mt76_testmode_set_state(struct mt76_phy *phy, enum mt76_testmode_state state);
 int mt76_testmode_alloc_skb(struct mt76_phy *phy, u32 len);
 
+static inline void
+mt76_testmode_param_set(struct mt76_testmode_data *td, u16 idx)
+{
+#ifdef CONFIG_NL80211_TESTMODE
+	td->param_set[idx / 32] |= BIT(idx % 32);
+#endif
+}
+
+static inline bool
+mt76_testmode_param_present(struct mt76_testmode_data *td, u16 idx)
+{
+#ifdef CONFIG_NL80211_TESTMODE
+	return td->param_set[idx / 32] & BIT(idx % 32);
+#else
+	return false;
+#endif
+}
+
 static inline void mt76_testmode_reset(struct mt76_phy *phy, bool disable)
 {
 #ifdef CONFIG_NL80211_TESTMODE
@@ -1573,8 +1675,8 @@ mt76_tx_status_get_hw(struct mt76_dev *dev, struct sk_buff *skb)
 }
 
 void mt76_put_txwi(struct mt76_dev *dev, struct mt76_txwi_cache *t);
-void mt76_put_rxwi(struct mt76_dev *dev, struct mt76_txwi_cache *t);
-struct mt76_txwi_cache *mt76_get_rxwi(struct mt76_dev *dev);
+void mt76_put_rxwi(struct mt76_dev *dev, struct mt76_rxwi_cache *r);
+struct mt76_rxwi_cache *mt76_get_rxwi(struct mt76_dev *dev);
 void mt76_free_pending_rxwi(struct mt76_dev *dev);
 void mt76_rx_complete(struct mt76_dev *dev, struct sk_buff_head *frames,
 		      struct napi_struct *napi);
@@ -1584,18 +1686,8 @@ void mt76_rx_aggr_reorder(struct sk_buff *skb, struct sk_buff_head *frames);
 void mt76_testmode_tx_pending(struct mt76_phy *phy);
 void mt76_queue_tx_complete(struct mt76_dev *dev, struct mt76_queue *q,
 			    struct mt76_queue_entry *e);
-int __mt76_set_channel(struct mt76_phy *phy, struct cfg80211_chan_def *chandef,
-		       bool offchannel);
 int mt76_set_channel(struct mt76_phy *phy, struct cfg80211_chan_def *chandef,
 		     bool offchannel);
-void mt76_scan_work(struct work_struct *work);
-void mt76_abort_scan(struct mt76_dev *dev);
-void mt76_roc_complete_work(struct work_struct *work);
-void mt76_abort_roc(struct mt76_phy *phy);
-struct mt76_vif_link *mt76_get_vif_phy_link(struct mt76_phy *phy,
-					    struct ieee80211_vif *vif);
-void mt76_put_vif_phy_link(struct mt76_phy *phy, struct ieee80211_vif *vif,
-			   struct mt76_vif_link *mlink);
 
 /* usb */
 static inline bool mt76u_urb_error(struct urb *urb)
@@ -1725,6 +1817,7 @@ mt76_find_channel_node(struct device_node *np, struct ieee80211_channel *chan);
 s8 mt76_get_rate_power_limits(struct mt76_phy *phy,
 			      struct ieee80211_channel *chan,
 			      struct mt76_power_limits *dest,
+			      struct mt76_power_path_limits *dest_path,
 			      s8 target_power);
 
 static inline bool mt76_queue_is_rx(struct mt76_dev *dev, struct mt76_queue *q)
@@ -1759,8 +1852,13 @@ static inline bool mt76_queue_is_wed_rro_ind(struct mt76_queue *q)
 static inline bool mt76_queue_is_wed_rro_data(struct mt76_queue *q)
 {
 	return mt76_queue_is_wed_rro(q) &&
-	       (FIELD_GET(MT_QFLAG_WED_TYPE, q->flags) == MT76_WED_RRO_Q_DATA ||
-		FIELD_GET(MT_QFLAG_WED_TYPE, q->flags) == MT76_WED_RRO_Q_MSDU_PG);
+	       (FIELD_GET(MT_QFLAG_WED_TYPE, q->flags) == MT76_WED_RRO_Q_DATA);
+}
+
+static inline bool mt76_queue_is_wed_rro_msdu_pg(struct mt76_queue *q)
+{
+	return mt76_queue_is_wed_rro(q) &&
+	       (FIELD_GET(MT_QFLAG_WED_TYPE, q->flags) == MT76_WED_RRO_Q_MSDU_PG);
 }
 
 static inline bool mt76_queue_is_wed_rx(struct mt76_queue *q)
@@ -1769,7 +1867,8 @@ static inline bool mt76_queue_is_wed_rx(struct mt76_queue *q)
 		return false;
 
 	return FIELD_GET(MT_QFLAG_WED_TYPE, q->flags) == MT76_WED_Q_RX ||
-	       mt76_queue_is_wed_rro_ind(q) || mt76_queue_is_wed_rro_data(q);
+	       mt76_queue_is_wed_rro_ind(q) || mt76_queue_is_wed_rro_data(q) ||
+	       mt76_queue_is_wed_rro_msdu_pg(q);
 
 }
 
@@ -1777,9 +1876,9 @@ struct mt76_txwi_cache *
 mt76_token_release(struct mt76_dev *dev, int token, bool *wake);
 int mt76_token_consume(struct mt76_dev *dev, struct mt76_txwi_cache **ptxwi);
 void __mt76_set_tx_blocked(struct mt76_dev *dev, bool blocked);
-struct mt76_txwi_cache *mt76_rx_token_release(struct mt76_dev *dev, int token);
+struct mt76_rxwi_cache *mt76_rx_token_release(struct mt76_dev *dev, int token);
 int mt76_rx_token_consume(struct mt76_dev *dev, void *ptr,
-			  struct mt76_txwi_cache *r, dma_addr_t phys);
+			  struct mt76_rxwi_cache *r, dma_addr_t phys);
 int mt76_create_page_pool(struct mt76_dev *dev, struct mt76_queue *q);
 static inline void mt76_put_page_pool_buf(void *buf, bool allow_direct)
 {
@@ -1831,54 +1930,7 @@ mt76_token_put(struct mt76_dev *dev, int token)
 	return txwi;
 }
 
-void mt76_wcid_init(struct mt76_wcid *wcid, u8 band_idx);
+void mt76_wcid_init(struct mt76_wcid *wcid);
 void mt76_wcid_cleanup(struct mt76_dev *dev, struct mt76_wcid *wcid);
-void mt76_wcid_add_poll(struct mt76_dev *dev, struct mt76_wcid *wcid);
-
-static inline void
-mt76_vif_init(struct ieee80211_vif *vif, struct mt76_vif_data *mvif)
-{
-	struct mt76_vif_link *mlink = (struct mt76_vif_link *)vif->drv_priv;
-
-	mlink->mvif = mvif;
-	rcu_assign_pointer(mvif->link[0], mlink);
-}
-
-void mt76_vif_cleanup(struct mt76_dev *dev, struct ieee80211_vif *vif);
-
-static inline struct mt76_vif_link *
-mt76_vif_link(struct mt76_dev *dev, struct ieee80211_vif *vif, int link_id)
-{
-	struct mt76_vif_link *mlink = (struct mt76_vif_link *)vif->drv_priv;
-	struct mt76_vif_data *mvif = mlink->mvif;
-
-	return mt76_dereference(mvif->link[link_id], dev);
-}
-
-static inline struct mt76_vif_link *
-mt76_vif_conf_link(struct mt76_dev *dev, struct ieee80211_vif *vif,
-		   struct ieee80211_bss_conf *link_conf)
-{
-	struct mt76_vif_link *mlink = (struct mt76_vif_link *)vif->drv_priv;
-	struct mt76_vif_data *mvif = mlink->mvif;
-
-	if (link_conf == &vif->bss_conf)
-		return mlink;
-
-	return mt76_dereference(mvif->link[link_conf->link_id], dev);
-}
-
-static inline struct mt76_phy *
-mt76_vif_link_phy(struct mt76_vif_link *mlink)
-{
-	struct mt76_chanctx *ctx;
-
-	if (!mlink->ctx)
-		return NULL;
-
-	ctx = (struct mt76_chanctx *)mlink->ctx->drv_priv;
-
-	return ctx->phy;
-}
 
 #endif
diff --git a/mt76_connac_mac.c b/mt76_connac_mac.c
index e9ac8a73..95453577 100644
--- a/mt76_connac_mac.c
+++ b/mt76_connac_mac.c
@@ -297,14 +297,13 @@ u16 mt76_connac2_mac_tx_rate_val(struct mt76_phy *mphy,
 				 struct ieee80211_bss_conf *conf,
 				 bool beacon, bool mcast)
 {
-	struct mt76_vif_link *mvif = mt76_vif_conf_link(mphy->dev, conf->vif, conf);
-	struct cfg80211_chan_def *chandef = mvif->ctx ?
-					    &mvif->ctx->def : &mphy->chandef;
+	struct ieee80211_vif *vif = conf->vif;
+	struct cfg80211_chan_def *chandef = &mphy->chandef;
 	u8 nss = 0, mode = 0, band = chandef->chan->band;
 	int rateidx = 0, mcast_rate;
 	int offset = 0;
 
-	if (!conf)
+	if (!vif)
 		goto legacy;
 
 	if (is_mt7921(mphy->dev)) {
@@ -508,7 +507,7 @@ void mt76_connac2_mac_write_txwi(struct mt76_dev *dev, __le32 *txwi,
 	bool amsdu_en = wcid->amsdu;
 
 	if (vif) {
-		struct mt76_vif_link *mvif = (struct mt76_vif_link *)vif->drv_priv;
+		struct mt76_vif *mvif = (struct mt76_vif *)vif->drv_priv;
 
 		omac_idx = mvif->omac_idx;
 		wmm_idx = mvif->wmm_idx;
@@ -1177,7 +1176,11 @@ void mt76_connac2_txwi_free(struct mt76_dev *dev, struct mt76_txwi_cache *t,
 		if (wcid && wcid->sta) {
 			sta = container_of((void *)wcid, struct ieee80211_sta,
 					   drv_priv);
-			mt76_wcid_add_poll(dev, wcid);
+			spin_lock_bh(&dev->sta_poll_lock);
+			if (list_empty(&wcid->poll_list))
+				list_add_tail(&wcid->poll_list,
+					      &dev->sta_poll_list);
+			spin_unlock_bh(&dev->sta_poll_lock);
 		}
 	}
 
diff --git a/mt76_connac_mcu.c b/mt76_connac_mcu.c
index f30cf9e7..03078522 100644
--- a/mt76_connac_mcu.c
+++ b/mt76_connac_mcu.c
@@ -189,7 +189,7 @@ EXPORT_SYMBOL_GPL(mt76_connac_mcu_set_mac_enable);
 
 int mt76_connac_mcu_set_vif_ps(struct mt76_dev *dev, struct ieee80211_vif *vif)
 {
-	struct mt76_vif_link *mvif = (struct mt76_vif_link *)vif->drv_priv;
+	struct mt76_vif *mvif = (struct mt76_vif *)vif->drv_priv;
 	struct {
 		u8 bss_idx;
 		u8 ps_state; /* 0: device awake
@@ -232,7 +232,7 @@ EXPORT_SYMBOL_GPL(mt76_connac_mcu_set_rts_thresh);
 void mt76_connac_mcu_beacon_loss_iter(void *priv, u8 *mac,
 				      struct ieee80211_vif *vif)
 {
-	struct mt76_vif_link *mvif = (struct mt76_vif_link *)vif->drv_priv;
+	struct mt76_vif *mvif = (struct mt76_vif *)vif->drv_priv;
 	struct mt76_connac_beacon_loss_event *event = priv;
 
 	if (mvif->idx != event->bss_idx)
@@ -273,7 +273,7 @@ mt76_connac_mcu_add_nested_tlv(struct sk_buff *skb, int tag, int len,
 EXPORT_SYMBOL_GPL(mt76_connac_mcu_add_nested_tlv);
 
 struct sk_buff *
-__mt76_connac_mcu_alloc_sta_req(struct mt76_dev *dev, struct mt76_vif_link *mvif,
+__mt76_connac_mcu_alloc_sta_req(struct mt76_dev *dev, struct mt76_vif *mvif,
 				struct mt76_wcid *wcid, int len)
 {
 	struct sta_req_hdr hdr = {
@@ -329,7 +329,7 @@ EXPORT_SYMBOL_GPL(mt76_connac_mcu_alloc_wtbl_req);
 void mt76_connac_mcu_bss_omac_tlv(struct sk_buff *skb,
 				  struct ieee80211_vif *vif)
 {
-	struct mt76_vif_link *mvif = (struct mt76_vif_link *)vif->drv_priv;
+	struct mt76_vif *mvif = (struct mt76_vif *)vif->drv_priv;
 	u8 omac_idx = mvif->omac_idx;
 	struct bss_info_omac *omac;
 	struct tlv *tlv;
@@ -369,11 +369,11 @@ void mt76_connac_mcu_bss_omac_tlv(struct sk_buff *skb,
 EXPORT_SYMBOL_GPL(mt76_connac_mcu_bss_omac_tlv);
 
 void mt76_connac_mcu_sta_basic_tlv(struct mt76_dev *dev, struct sk_buff *skb,
-				   struct ieee80211_bss_conf *link_conf,
+				   struct ieee80211_bss_conf *conf,
 				   struct ieee80211_link_sta *link_sta,
 				   int conn_state, bool newly)
 {
-	struct ieee80211_vif *vif = link_conf->vif;
+	struct ieee80211_vif *vif = conf->vif;
 	struct sta_rec_basic *basic;
 	struct tlv *tlv;
 	int conn_type;
@@ -389,10 +389,9 @@ void mt76_connac_mcu_sta_basic_tlv(struct mt76_dev *dev, struct sk_buff *skb,
 
 	if (!link_sta) {
 		basic->conn_type = cpu_to_le32(CONNECTION_INFRA_BC);
-
 		if (vif->type == NL80211_IFTYPE_STATION &&
-		    !is_zero_ether_addr(link_conf->bssid)) {
-			memcpy(basic->peer_addr, link_conf->bssid, ETH_ALEN);
+		    conf && !is_zero_ether_addr(conf->bssid)) {
+			memcpy(basic->peer_addr, conf->bssid, ETH_ALEN);
 			basic->aid = cpu_to_le16(vif->cfg.aid);
 		} else {
 			eth_broadcast_addr(basic->peer_addr);
@@ -428,6 +427,7 @@ void mt76_connac_mcu_sta_basic_tlv(struct mt76_dev *dev, struct sk_buff *skb,
 	}
 
 	memcpy(basic->peer_addr, link_sta->addr, ETH_ALEN);
+	pr_info("%s: link %u addr [%pM]\n", __func__, link_sta->link_id, basic->peer_addr);
 	basic->qos = link_sta->sta->wme;
 }
 EXPORT_SYMBOL_GPL(mt76_connac_mcu_sta_basic_tlv);
@@ -498,7 +498,7 @@ int mt76_connac_mcu_sta_update_hdr_trans(struct mt76_dev *dev,
 					 struct ieee80211_vif *vif,
 					 struct mt76_wcid *wcid, int cmd)
 {
-	struct mt76_vif_link *mvif = (struct mt76_vif_link *)vif->drv_priv;
+	struct mt76_vif *mvif = (struct mt76_vif *)vif->drv_priv;
 	struct wtbl_req_hdr *wtbl_hdr;
 	struct tlv *sta_wtbl;
 	struct sk_buff *skb;
@@ -546,7 +546,7 @@ void mt76_connac_mcu_wtbl_generic_tlv(struct mt76_dev *dev,
 				      struct ieee80211_sta *sta,
 				      void *sta_wtbl, void *wtbl_tlv)
 {
-	struct mt76_vif_link *mvif = (struct mt76_vif_link *)vif->drv_priv;
+	struct mt76_vif *mvif = (struct mt76_vif *)vif->drv_priv;
 	struct wtbl_generic *generic;
 	struct wtbl_rx *rx;
 	struct wtbl_spe *spe;
@@ -850,7 +850,7 @@ void mt76_connac_mcu_sta_tlv(struct mt76_phy *mphy, struct sk_buff *skb,
 			     struct ieee80211_vif *vif,
 			     u8 rcpi, u8 sta_state)
 {
-	struct mt76_vif_link *mvif = (struct mt76_vif_link *)vif->drv_priv;
+	struct mt76_vif *mvif = (struct mt76_vif *)vif->drv_priv;
 	struct cfg80211_chan_def *chandef = mvif->ctx ?
 					    &mvif->ctx->def : &mphy->chandef;
 	enum nl80211_band band = chandef->chan->band;
@@ -1042,7 +1042,7 @@ EXPORT_SYMBOL_GPL(mt76_connac_mcu_wtbl_ht_tlv);
 int mt76_connac_mcu_sta_cmd(struct mt76_phy *phy,
 			    struct mt76_sta_cmd_info *info)
 {
-	struct mt76_vif_link *mvif = (struct mt76_vif_link *)info->vif->drv_priv;
+	struct mt76_vif *mvif = (struct mt76_vif *)info->vif->drv_priv;
 	struct ieee80211_link_sta *link_sta;
 	struct mt76_dev *dev = phy->dev;
 	struct wtbl_req_hdr *wtbl_hdr;
@@ -1050,9 +1050,6 @@ int mt76_connac_mcu_sta_cmd(struct mt76_phy *phy,
 	struct sk_buff *skb;
 	int conn_state;
 
-	if (!info->link_conf)
-		info->link_conf = &info->vif->bss_conf;
-
 	skb = mt76_connac_mcu_alloc_sta_req(dev, mvif, info->wcid);
 	if (IS_ERR(skb))
 		return PTR_ERR(skb);
@@ -1061,7 +1058,7 @@ int mt76_connac_mcu_sta_cmd(struct mt76_phy *phy,
 				    CONN_STATE_DISCONNECT;
 	link_sta = info->sta ? &info->sta->deflink : NULL;
 	if (info->sta || !info->offload_fw)
-		mt76_connac_mcu_sta_basic_tlv(dev, skb, info->link_conf,
+		mt76_connac_mcu_sta_basic_tlv(dev, skb, &info->vif->bss_conf,
 					      link_sta, conn_state,
 					      info->newly);
 	if (info->sta && info->enable)
@@ -1141,7 +1138,6 @@ EXPORT_SYMBOL_GPL(mt76_connac_mcu_wtbl_ba_tlv);
 
 int mt76_connac_mcu_uni_add_dev(struct mt76_phy *phy,
 				struct ieee80211_bss_conf *bss_conf,
-				struct mt76_vif_link *mvif,
 				struct mt76_wcid *wcid,
 				bool enable)
 {
@@ -1270,7 +1266,7 @@ int mt76_connac_mcu_sta_wed_update(struct mt76_dev *dev, struct sk_buff *skb)
 }
 EXPORT_SYMBOL_GPL(mt76_connac_mcu_sta_wed_update);
 
-int mt76_connac_mcu_sta_ba(struct mt76_dev *dev, struct mt76_vif_link *mvif,
+int mt76_connac_mcu_sta_ba(struct mt76_dev *dev, struct mt76_vif *mvif,
 			   struct ieee80211_ampdu_params *params,
 			   int cmd, bool enable, bool tx)
 {
@@ -1408,7 +1404,7 @@ EXPORT_SYMBOL_GPL(mt76_connac_get_phy_mode_ext);
 const struct ieee80211_sta_he_cap *
 mt76_connac_get_he_phy_cap(struct mt76_phy *phy, struct ieee80211_vif *vif)
 {
-	struct mt76_vif_link *mvif = (struct mt76_vif_link *)vif->drv_priv;
+	struct mt76_vif *mvif = (struct mt76_vif *)vif->drv_priv;
 	struct cfg80211_chan_def *chandef = mvif->ctx ?
 					    &mvif->ctx->def : &phy->chandef;
 	enum nl80211_band band = chandef->chan->band;
@@ -1457,7 +1453,7 @@ mt76_connac_mcu_uni_bss_he_tlv(struct mt76_phy *phy, struct ieee80211_vif *vif,
 	he->max_nss_mcs[CMD_HE_MCS_BW8080] = cap->he_mcs_nss_supp.tx_mcs_80p80;
 }
 
-int mt76_connac_mcu_uni_set_chctx(struct mt76_phy *phy, struct mt76_vif_link *mvif,
+int mt76_connac_mcu_uni_set_chctx(struct mt76_phy *phy, struct mt76_vif *mvif,
 				  struct ieee80211_chanctx_conf *ctx)
 {
 	struct cfg80211_chan_def *chandef = ctx ? &ctx->def : &phy->chandef;
@@ -1545,7 +1541,7 @@ int mt76_connac_mcu_uni_add_bss(struct mt76_phy *phy,
 				bool enable,
 				struct ieee80211_chanctx_conf *ctx)
 {
-	struct mt76_vif_link *mvif = (struct mt76_vif_link *)vif->drv_priv;
+	struct mt76_vif *mvif = (struct mt76_vif *)vif->drv_priv;
 	struct cfg80211_chan_def *chandef = ctx ? &ctx->def : &phy->chandef;
 	enum nl80211_band band = chandef->chan->band;
 	struct mt76_dev *mdev = phy->dev;
@@ -1671,7 +1667,7 @@ EXPORT_SYMBOL_GPL(mt76_connac_mcu_uni_add_bss);
 int mt76_connac_mcu_hw_scan(struct mt76_phy *phy, struct ieee80211_vif *vif,
 			    struct ieee80211_scan_request *scan_req)
 {
-	struct mt76_vif_link *mvif = (struct mt76_vif_link *)vif->drv_priv;
+	struct mt76_vif *mvif = (struct mt76_vif *)vif->drv_priv;
 	struct cfg80211_scan_request *sreq = &scan_req->req;
 	int n_ssids = 0, err, i, duration;
 	int ext_channels_num = max_t(int, sreq->n_channels - 32, 0);
@@ -1777,7 +1773,7 @@ EXPORT_SYMBOL_GPL(mt76_connac_mcu_hw_scan);
 int mt76_connac_mcu_cancel_hw_scan(struct mt76_phy *phy,
 				   struct ieee80211_vif *vif)
 {
-	struct mt76_vif_link *mvif = (struct mt76_vif_link *)vif->drv_priv;
+	struct mt76_vif *mvif = (struct mt76_vif *)vif->drv_priv;
 	struct {
 		u8 seq_num;
 		u8 is_ext_channel;
@@ -1803,7 +1799,7 @@ int mt76_connac_mcu_sched_scan_req(struct mt76_phy *phy,
 				   struct ieee80211_vif *vif,
 				   struct cfg80211_sched_scan_request *sreq)
 {
-	struct mt76_vif_link *mvif = (struct mt76_vif_link *)vif->drv_priv;
+	struct mt76_vif *mvif = (struct mt76_vif *)vif->drv_priv;
 	struct ieee80211_channel **scan_list = sreq->channels;
 	struct mt76_connac_mcu_scan_channel *chan;
 	struct mt76_connac_sched_scan_req *req;
@@ -2163,7 +2159,7 @@ mt76_connac_mcu_rate_txpower_band(struct mt76_phy *phy,
 			sar_power = mt76_get_sar_power(phy, &chan, reg_power);
 
 			mt76_get_rate_power_limits(phy, &chan, limits,
-						   sar_power);
+						   NULL, sar_power);
 
 			tx_power_tlv.last_msg = ch_list[idx] == last_ch;
 			sku_tlbv.channel = ch_list[idx];
@@ -2215,7 +2211,7 @@ int mt76_connac_mcu_set_rate_txpower(struct mt76_phy *phy)
 EXPORT_SYMBOL_GPL(mt76_connac_mcu_set_rate_txpower);
 
 int mt76_connac_mcu_update_arp_filter(struct mt76_dev *dev,
-				      struct mt76_vif_link *vif,
+				      struct mt76_vif *vif,
 				      struct ieee80211_bss_conf *info)
 {
 	struct ieee80211_vif *mvif = container_of(info, struct ieee80211_vif,
@@ -2258,7 +2254,7 @@ EXPORT_SYMBOL_GPL(mt76_connac_mcu_update_arp_filter);
 int mt76_connac_mcu_set_p2p_oppps(struct ieee80211_hw *hw,
 				  struct ieee80211_vif *vif)
 {
-	struct mt76_vif_link *mvif = (struct mt76_vif_link *)vif->drv_priv;
+	struct mt76_vif *mvif = (struct mt76_vif *)vif->drv_priv;
 	int ct_window = vif->bss_conf.p2p_noa_attr.oppps_ctwindow;
 	struct mt76_phy *phy = hw->priv;
 	struct {
@@ -2325,7 +2321,7 @@ int mt76_connac_mcu_update_gtk_rekey(struct ieee80211_hw *hw,
 				     struct ieee80211_vif *vif,
 				     struct cfg80211_gtk_rekey_data *key)
 {
-	struct mt76_vif_link *mvif = (struct mt76_vif_link *)vif->drv_priv;
+	struct mt76_vif *mvif = (struct mt76_vif *)vif->drv_priv;
 	struct mt76_connac_gtk_rekey_tlv *gtk_tlv;
 	struct mt76_phy *phy = hw->priv;
 	struct sk_buff *skb;
@@ -2366,7 +2362,7 @@ static int
 mt76_connac_mcu_set_arp_filter(struct mt76_dev *dev, struct ieee80211_vif *vif,
 			       bool suspend)
 {
-	struct mt76_vif_link *mvif = (struct mt76_vif_link *)vif->drv_priv;
+	struct mt76_vif *mvif = (struct mt76_vif *)vif->drv_priv;
 	struct {
 		struct {
 			u8 bss_idx;
@@ -2392,7 +2388,7 @@ int
 mt76_connac_mcu_set_gtk_rekey(struct mt76_dev *dev, struct ieee80211_vif *vif,
 			      bool suspend)
 {
-	struct mt76_vif_link *mvif = (struct mt76_vif_link *)vif->drv_priv;
+	struct mt76_vif *mvif = (struct mt76_vif *)vif->drv_priv;
 	struct {
 		struct {
 			u8 bss_idx;
@@ -2421,7 +2417,7 @@ mt76_connac_mcu_set_suspend_mode(struct mt76_dev *dev,
 				 bool enable, u8 mdtim,
 				 bool wow_suspend)
 {
-	struct mt76_vif_link *mvif = (struct mt76_vif_link *)vif->drv_priv;
+	struct mt76_vif *mvif = (struct mt76_vif *)vif->drv_priv;
 	struct {
 		struct {
 			u8 bss_idx;
@@ -2452,7 +2448,7 @@ mt76_connac_mcu_set_wow_pattern(struct mt76_dev *dev,
 				u8 index, bool enable,
 				struct cfg80211_pkt_pattern *pattern)
 {
-	struct mt76_vif_link *mvif = (struct mt76_vif_link *)vif->drv_priv;
+	struct mt76_vif *mvif = (struct mt76_vif *)vif->drv_priv;
 	struct mt76_connac_wow_pattern_tlv *ptlv;
 	struct sk_buff *skb;
 	struct req_hdr {
@@ -2484,7 +2480,7 @@ int
 mt76_connac_mcu_set_wow_ctrl(struct mt76_phy *phy, struct ieee80211_vif *vif,
 			     bool suspend, struct cfg80211_wowlan *wowlan)
 {
-	struct mt76_vif_link *mvif = (struct mt76_vif_link *)vif->drv_priv;
+	struct mt76_vif *mvif = (struct mt76_vif *)vif->drv_priv;
 	struct mt76_dev *dev = phy->dev;
 	struct {
 		struct {
@@ -2693,7 +2689,7 @@ int mt76_connac_mcu_add_key(struct mt76_dev *dev, struct ieee80211_vif *vif,
 			    struct ieee80211_key_conf *key, int mcu_cmd,
 			    struct mt76_wcid *wcid, enum set_key_cmd cmd)
 {
-	struct mt76_vif_link *mvif = (struct mt76_vif_link *)vif->drv_priv;
+	struct mt76_vif *mvif = (struct mt76_vif *)vif->drv_priv;
 	struct sk_buff *skb;
 	int ret;
 
@@ -2715,7 +2711,7 @@ EXPORT_SYMBOL_GPL(mt76_connac_mcu_add_key);
 
 /* SIFS 20us + 512 byte beacon transmitted by 1Mbps (3906us) */
 #define BCN_TX_ESTIMATE_TIME (4096 + 20)
-void mt76_connac_mcu_bss_ext_tlv(struct sk_buff *skb, struct mt76_vif_link *mvif)
+void mt76_connac_mcu_bss_ext_tlv(struct sk_buff *skb, struct mt76_vif *mvif)
 {
 	struct bss_info_ext_bss *ext;
 	int ext_bss_idx, tsf_offset;
@@ -2739,7 +2735,7 @@ int mt76_connac_mcu_bss_basic_tlv(struct sk_buff *skb,
 				  struct mt76_phy *phy, u16 wlan_idx,
 				  bool enable)
 {
-	struct mt76_vif_link *mvif = (struct mt76_vif_link *)vif->drv_priv;
+	struct mt76_vif *mvif = (struct mt76_vif *)vif->drv_priv;
 	u32 type = vif->p2p ? NETWORK_P2P : NETWORK_INFRA;
 	struct bss_info_basic *bss;
 	struct tlv *tlv;
diff --git a/mt76_connac_mcu.h b/mt76_connac_mcu.h
index 43237e51..7aff6cdd 100644
--- a/mt76_connac_mcu.h
+++ b/mt76_connac_mcu.h
@@ -493,7 +493,8 @@ struct sta_rec_bf {
 	bool codebook75_mu;
 
 	u8 he_ltf;
-	u8 rsv[3];
+	u8 pp_fd_val;
+	u8 rsv[2];
 } __packed;
 
 struct sta_rec_bfee {
@@ -833,6 +834,7 @@ enum {
 	STA_REC_KEY_V3 = 0x27,
 	STA_REC_HDRT = 0x28,
 	STA_REC_HDR_TRANS = 0x2B,
+	STA_REC_TX_CAP = 0x2f,
 	STA_REC_MAX_NUM
 };
 
@@ -1041,9 +1043,9 @@ enum {
 	MCU_EXT_EVENT_ASSERT_DUMP = 0x23,
 	MCU_EXT_EVENT_RDD_REPORT = 0x3a,
 	MCU_EXT_EVENT_CSA_NOTIFY = 0x4f,
+	MCU_EXT_EVENT_BSS_ACQ_PKT_CNT = 0x52,
 	MCU_EXT_EVENT_WA_TX_STAT = 0x74,
 	MCU_EXT_EVENT_BCC_NOTIFY = 0x75,
-	MCU_EXT_EVENT_WF_RF_PIN_CTRL = 0x9a,
 	MCU_EXT_EVENT_MURU_CTRL = 0x9f,
 };
 
@@ -1058,10 +1060,14 @@ enum {
 	MCU_UNI_EVENT_BSS_BEACON_LOSS = 0x0c,
 	MCU_UNI_EVENT_SCAN_DONE = 0x0e,
 	MCU_UNI_EVENT_RDD_REPORT = 0x11,
+	MCU_UNI_EVENT_SR = 0x25,
 	MCU_UNI_EVENT_ROC = 0x27,
 	MCU_UNI_EVENT_TX_DONE = 0x2d,
+	MCU_UNI_EVENT_BF = 0x33,
 	MCU_UNI_EVENT_THERMAL = 0x35,
 	MCU_UNI_EVENT_NIC_CAPAB = 0x43,
+	MCU_UNI_EVENT_TESTMODE_CTRL = 0x46,
+	MCU_UNI_EVENT_CSI_REPORT = 0x4A,
 	MCU_UNI_EVENT_WED_RRO = 0x57,
 	MCU_UNI_EVENT_PER_STA_INFO = 0x6d,
 	MCU_UNI_EVENT_ALL_STA_INFO = 0x6e,
@@ -1239,6 +1245,7 @@ enum {
 	MCU_EXT_CMD_TXDPD_CAL = 0x60,
 	MCU_EXT_CMD_CAL_CACHE = 0x67,
 	MCU_EXT_CMD_RED_ENABLE = 0x68,
+	MCU_EXT_CMD_PKT_BUDGET_CTRL = 0x6c,
 	MCU_EXT_CMD_CP_SUPPORT = 0x75,
 	MCU_EXT_CMD_SET_RADAR_TH = 0x7c,
 	MCU_EXT_CMD_SET_RDD_PATTERN = 0x7d,
@@ -1253,7 +1260,6 @@ enum {
 	MCU_EXT_CMD_GROUP_PRE_CAL_INFO = 0xab,
 	MCU_EXT_CMD_DPD_PRE_CAL_INFO = 0xac,
 	MCU_EXT_CMD_PHY_STAT_INFO = 0xad,
-	MCU_EXT_CMD_WF_RF_PIN_CTRL = 0xbd,
 };
 
 enum {
@@ -1270,6 +1276,7 @@ enum {
 	MCU_UNI_CMD_REG_ACCESS = 0x0d,
 	MCU_UNI_CMD_CHIP_CONFIG = 0x0e,
 	MCU_UNI_CMD_POWER_CTRL = 0x0f,
+	MCU_UNI_CMD_CFG_SMESH = 0x10,
 	MCU_UNI_CMD_RX_HDR_TRANS = 0x12,
 	MCU_UNI_CMD_SER = 0x13,
 	MCU_UNI_CMD_TWT = 0x14,
@@ -1280,6 +1287,7 @@ enum {
 	MCU_UNI_CMD_GET_STAT_INFO = 0x23,
 	MCU_UNI_CMD_SNIFFER = 0x24,
 	MCU_UNI_CMD_SR = 0x25,
+	MCU_UNI_CMD_SCS = 0x26,
 	MCU_UNI_CMD_ROC = 0x27,
 	MCU_UNI_CMD_SET_DBDC_PARMS = 0x28,
 	MCU_UNI_CMD_TXPOWER = 0x2b,
@@ -1287,16 +1295,26 @@ enum {
 	MCU_UNI_CMD_EFUSE_CTRL = 0x2d,
 	MCU_UNI_CMD_RA = 0x2f,
 	MCU_UNI_CMD_MURU = 0x31,
+	MCU_UNI_CMD_TESTMODE_RX_STAT = 0x32,
 	MCU_UNI_CMD_BF = 0x33,
 	MCU_UNI_CMD_CHANNEL_SWITCH = 0x34,
 	MCU_UNI_CMD_THERMAL = 0x35,
 	MCU_UNI_CMD_VOW = 0x37,
+	MCU_UNI_CMD_PP = 0x38,
+	MCU_UNI_CMD_MEC = 0x3a,
 	MCU_UNI_CMD_FIXED_RATE_TABLE = 0x40,
+	MCU_UNI_CMD_TESTMODE_TRX_PARAM = 0x42,
+	MCU_UNI_CMD_TESTMODE_CTRL = 0x46,
+	MCU_UNI_CMD_PRECAL_RESULT = 0x47,
+	MCU_UNI_CMD_CSI_CTRL = 0x4A,
+	MCU_UNI_CMD_THERMAL_CAL = 0x4c,
 	MCU_UNI_CMD_RRO = 0x57,
 	MCU_UNI_CMD_OFFCH_SCAN_CTRL = 0x58,
+	MCU_UNI_CMD_MLO = 0x59,
 	MCU_UNI_CMD_PER_STA_INFO = 0x6d,
 	MCU_UNI_CMD_ALL_STA_INFO = 0x6e,
 	MCU_UNI_CMD_ASSERT_DUMP = 0x6f,
+	MCU_UNI_CMD_PTA_3WIRE_CTRL = 0x78,
 };
 
 enum {
@@ -1378,11 +1396,23 @@ enum {
 	UNI_OFFLOAD_OFFLOAD_BMC_RPY_DETECT,
 };
 
+enum UNI_PER_STA_INFO_TAG {
+	UNI_PER_STA_RSSI,
+	UNI_PER_STA_CONTENTION_RX_RATE,
+	UNI_PER_STA_PER,
+	UNI_PER_STA_SNR,
+	UNI_PER_STA_TX_RATE,
+	UNI_PER_STA_TX_CNT,
+	UNI_PER_STA_TID_SN_GET,
+	UNI_PER_STA_TID_SN_SET,
+	UNI_PER_STA_MAX_NUM
+};
+
 enum UNI_ALL_STA_INFO_TAG {
 	UNI_ALL_STA_TXRX_RATE,
 	UNI_ALL_STA_TX_STAT,
 	UNI_ALL_STA_TXRX_ADM_STAT,
-	UNI_ALL_STA_TXRX_AIR_TIME,
+	UNI_ALL_STA_TXRX_AIRTIME,
 	UNI_ALL_STA_DATA_TX_RETRY_COUNT,
 	UNI_ALL_STA_GI_MODE,
 	UNI_ALL_STA_TXRX_MSDU_COUNT,
@@ -1759,7 +1789,6 @@ struct mt76_sta_cmd_info {
 	struct mt76_wcid *wcid;
 
 	struct ieee80211_vif *vif;
-	struct ieee80211_bss_conf *link_conf;
 
 	bool offload_fw;
 	bool enable;
@@ -1880,10 +1909,10 @@ mt76_connac_mcu_get_wlan_idx(struct mt76_dev *dev, struct mt76_wcid *wcid,
 }
 
 struct sk_buff *
-__mt76_connac_mcu_alloc_sta_req(struct mt76_dev *dev, struct mt76_vif_link *mvif,
+__mt76_connac_mcu_alloc_sta_req(struct mt76_dev *dev, struct mt76_vif *mvif,
 				struct mt76_wcid *wcid, int len);
 static inline struct sk_buff *
-mt76_connac_mcu_alloc_sta_req(struct mt76_dev *dev, struct mt76_vif_link *mvif,
+mt76_connac_mcu_alloc_sta_req(struct mt76_dev *dev, struct mt76_vif *mvif,
 			      struct mt76_wcid *wcid)
 {
 	return __mt76_connac_mcu_alloc_sta_req(dev, mvif, wcid,
@@ -1905,7 +1934,7 @@ mt76_connac_mcu_add_tlv(struct sk_buff *skb, int tag, int len)
 int mt76_connac_mcu_set_channel_domain(struct mt76_phy *phy);
 int mt76_connac_mcu_set_vif_ps(struct mt76_dev *dev, struct ieee80211_vif *vif);
 void mt76_connac_mcu_sta_basic_tlv(struct mt76_dev *dev, struct sk_buff *skb,
-				   struct ieee80211_bss_conf *link_conf,
+				   struct ieee80211_bss_conf *conf,
 				   struct ieee80211_link_sta *link_sta,
 				   int state, bool newly);
 void mt76_connac_mcu_wtbl_generic_tlv(struct mt76_dev *dev, struct sk_buff *skb,
@@ -1942,14 +1971,13 @@ void mt76_connac_mcu_sta_ba_tlv(struct sk_buff *skb,
 				bool enable, bool tx);
 int mt76_connac_mcu_uni_add_dev(struct mt76_phy *phy,
 				struct ieee80211_bss_conf *bss_conf,
-				struct mt76_vif_link *mvif,
 				struct mt76_wcid *wcid,
 				bool enable);
-int mt76_connac_mcu_sta_ba(struct mt76_dev *dev, struct mt76_vif_link *mvif,
+int mt76_connac_mcu_sta_ba(struct mt76_dev *dev, struct mt76_vif *mvif,
 			   struct ieee80211_ampdu_params *params,
 			   int cmd, bool enable, bool tx);
 int mt76_connac_mcu_uni_set_chctx(struct mt76_phy *phy,
-				  struct mt76_vif_link *vif,
+				  struct mt76_vif *vif,
 				  struct ieee80211_chanctx_conf *ctx);
 int mt76_connac_mcu_uni_add_bss(struct mt76_phy *phy,
 				struct ieee80211_vif *vif,
@@ -1980,7 +2008,7 @@ int mt76_connac_mcu_sched_scan_enable(struct mt76_phy *phy,
 				      struct ieee80211_vif *vif,
 				      bool enable);
 int mt76_connac_mcu_update_arp_filter(struct mt76_dev *dev,
-				      struct mt76_vif_link *vif,
+				      struct mt76_vif *vif,
 				      struct ieee80211_bss_conf *info);
 int mt76_connac_mcu_set_gtk_rekey(struct mt76_dev *dev, struct ieee80211_vif *vif,
 				  bool suspend);
@@ -2027,7 +2055,7 @@ int mt76_connac_mcu_add_key(struct mt76_dev *dev, struct ieee80211_vif *vif,
 			    struct ieee80211_key_conf *key, int mcu_cmd,
 			    struct mt76_wcid *wcid, enum set_key_cmd cmd);
 
-void mt76_connac_mcu_bss_ext_tlv(struct sk_buff *skb, struct mt76_vif_link *mvif);
+void mt76_connac_mcu_bss_ext_tlv(struct sk_buff *skb, struct mt76_vif *mvif);
 void mt76_connac_mcu_bss_omac_tlv(struct sk_buff *skb,
 				  struct ieee80211_vif *vif);
 int mt76_connac_mcu_bss_basic_tlv(struct sk_buff *skb,
diff --git a/mt7996/Makefile b/mt7996/Makefile
index 07c8b555..c9299490 100644
--- a/mt7996/Makefile
+++ b/mt7996/Makefile
@@ -1,8 +1,16 @@
 # SPDX-License-Identifier: ISC
+EXTRA_CFLAGS += -Werror -std=gnu11
+EXTRA_CFLAGS += -DCONFIG_MT76_LEDS
+EXTRA_CFLAGS += -DCONFIG_MTK_DEBUG
+EXTRA_CFLAGS += -DCONFIG_MTK_VENDOR
+EXTRA_CFLAGS += $(ADDITIONAL_CFLAGS)
 
 obj-$(CONFIG_MT7996E) += mt7996e.o
 
 mt7996e-y := pci.o init.o dma.o eeprom.o main.o mcu.o mac.o \
-	     debugfs.o mmio.o
+	     debugfs.o mmio.o vendor.o
 
 mt7996e-$(CONFIG_DEV_COREDUMP) += coredump.o
+mt7996e-$(CONFIG_NL80211_TESTMODE) += testmode.o
+
+mt7996e-y += mtk_debugfs.o mtk_mcu.o mtk_debugfs_i.o trace.o
diff --git a/mt7996/coredump.c b/mt7996/coredump.c
index 303d6e80..9f4b14ce 100644
--- a/mt7996/coredump.c
+++ b/mt7996/coredump.c
@@ -7,11 +7,11 @@
 #include <linux/utsname.h>
 #include "coredump.h"
 
-static bool coredump_memdump;
+static bool coredump_memdump = true;
 module_param(coredump_memdump, bool, 0644);
 MODULE_PARM_DESC(coredump_memdump, "Optional ability to dump firmware memory");
 
-static const struct mt7996_mem_region mt7996_mem_regions[] = {
+static const struct mt7996_mem_region mt7996_wm_mem_regions[] = {
 	{
 		.start = 0x00800000,
 		.len = 0x0004ffff,
@@ -44,27 +44,101 @@ static const struct mt7996_mem_region mt7996_mem_regions[] = {
 	},
 };
 
+static const struct mt7996_mem_region mt7996_wa_mem_regions[] = {
+	{
+		.start = 0xE0000000,
+		.len = 0x0000ffff,
+		.name = "CRAM",
+	},
+	{
+		.start = 0xE0010000,
+		.len = 0x000117ff,
+		.name = "CRAM2",
+	},
+	{
+		.start = 0x10000000,
+		.len = 0x0001bfff,
+		.name = "ILM",
+	},
+	{
+		.start = 0x10200000,
+		.len = 0x00063fff,
+		.name = "DLM",
+	},
+};
+
+static const struct mt7996_mem_region mt7992_wm_mem_regions[] = {
+	{
+		.start = 0x00800000,
+		.len = 0x0004bfff,
+		.name = "ULM0",
+	},
+	{
+		.start = 0x00900000,
+		.len = 0x00035fff,
+		.name = "ULM1",
+	},
+	{
+		.start = 0x02200000,
+		.len = 0x0003ffff,
+		.name = "ULM2",
+	},
+	{
+		.start = 0x00400000,
+		.len = 0x00027fff,
+		.name = "SRAM",
+	},
+	{
+		.start = 0xe0000000,
+		.len = 0x0015ffff,
+		.name = "CRAM0",
+	},
+	{
+		.start = 0xe0160000,
+		.len = 0x00c7fff,
+		.name = "CRAM1",
+	},
+	{
+		.start = 0x7c050000,
+		.len = 0x00007fff,
+		.name = "CONN_INFRA",
+	},
+};
+
 const struct mt7996_mem_region*
-mt7996_coredump_get_mem_layout(struct mt7996_dev *dev, u32 *num)
+mt7996_coredump_get_mem_layout(struct mt7996_dev *dev, u8 type, u32 *num)
 {
 	switch (mt76_chip(&dev->mt76)) {
 	case MT7996_DEVICE_ID:
 	case MT7996_DEVICE_ID_2:
-		*num = ARRAY_SIZE(mt7996_mem_regions);
-		return &mt7996_mem_regions[0];
+		if (type == MT7996_RAM_TYPE_WA) {
+			*num = ARRAY_SIZE(mt7996_wa_mem_regions);
+			return &mt7996_wa_mem_regions[0];
+		}
+
+		*num = ARRAY_SIZE(mt7996_wm_mem_regions);
+		return &mt7996_wm_mem_regions[0];
+	case MT7992_DEVICE_ID:
+		if (type == MT7996_RAM_TYPE_WA) {
+			/* mt7992 wa memory regions is the same as mt7996 */
+			*num = ARRAY_SIZE(mt7996_wa_mem_regions);
+			return &mt7996_wa_mem_regions[0];
+		}
+		*num = ARRAY_SIZE(mt7992_wm_mem_regions);
+		return &mt7992_wm_mem_regions[0];
 	default:
 		return NULL;
 	}
 }
 
-static int mt7996_coredump_get_mem_size(struct mt7996_dev *dev)
+static int mt7996_coredump_get_mem_size(struct mt7996_dev *dev, u8 type)
 {
 	const struct mt7996_mem_region *mem_region;
 	size_t size = 0;
 	u32 num;
 	int i;
 
-	mem_region = mt7996_coredump_get_mem_layout(dev, &num);
+	mem_region = mt7996_coredump_get_mem_layout(dev, type, &num);
 	if (!mem_region)
 		return 0;
 
@@ -81,14 +155,13 @@ static int mt7996_coredump_get_mem_size(struct mt7996_dev *dev)
 	return size;
 }
 
-struct mt7996_crash_data *mt7996_coredump_new(struct mt7996_dev *dev)
+struct mt7996_crash_data *mt7996_coredump_new(struct mt7996_dev *dev, u8 type)
 {
-	struct mt7996_crash_data *crash_data = dev->coredump.crash_data;
+	struct mt7996_crash_data *crash_data = dev->coredump.crash_data[type];
 
 	lockdep_assert_held(&dev->dump_mutex);
 
-	if (coredump_memdump &&
-	    !mt76_poll_msec(dev, MT_FW_DUMP_STATE, 0x3, 0x2, 500))
+	if (!coredump_memdump || !crash_data->supported)
 		return NULL;
 
 	guid_gen(&crash_data->guid);
@@ -98,12 +171,15 @@ struct mt7996_crash_data *mt7996_coredump_new(struct mt7996_dev *dev)
 }
 
 static void
-mt7996_coredump_fw_state(struct mt7996_dev *dev, struct mt7996_coredump *dump,
+mt7996_coredump_fw_state(struct mt7996_dev *dev, u8 type, struct mt7996_coredump *dump,
 			 bool *exception)
 {
-	u32 count;
+	u32 count, reg = MT_FW_WM_DUMP_STATE;
+
+	if (type == MT7996_RAM_TYPE_WA)
+		reg = MT_FW_WA_DUMP_STATE;
 
-	count = mt76_rr(dev, MT_FW_ASSERT_CNT);
+	count = mt76_rr(dev, reg);
 
 	/* normal mode: driver can manually trigger assert for detail info */
 	if (!count)
@@ -115,53 +191,59 @@ mt7996_coredump_fw_state(struct mt7996_dev *dev, struct mt7996_coredump *dump,
 }
 
 static void
-mt7996_coredump_fw_stack(struct mt7996_dev *dev, struct mt7996_coredump *dump,
+mt7996_coredump_fw_stack(struct mt7996_dev *dev, u8 type, struct mt7996_coredump *dump,
 			 bool exception)
 {
-	u32 oldest, i, idx;
+	u32 reg, i, offset = 0, val = MT7996_RAM_TYPE_WM;
 
-	strscpy(dump->pc_current, "program counter", sizeof(dump->pc_current));
+	if (type == MT7996_RAM_TYPE_WA) {
+		offset = MT_MCU_WA_EXCP_BASE - MT_MCU_WM_EXCP_BASE;
+		val = MT7996_RAM_TYPE_WA;
+	}
 
-	/* 0: WM PC log output */
-	mt76_wr(dev, MT_CONN_DBG_CTL_OUT_SEL, 0);
+	/* 0: WM PC log output, 1: WA PC log output  */
+	mt76_wr(dev, MT_CONN_DBG_CTL_OUT_SEL, val);
 	/* choose 33th PC log buffer to read current PC index */
 	mt76_wr(dev, MT_CONN_DBG_CTL_PC_LOG_SEL, 0x3f);
 
 	/* read current PC */
-	dump->pc_stack[0] = mt76_rr(dev, MT_CONN_DBG_CTL_PC_LOG);
+	for (i = 0; i < 10; i++)
+		dump->pc_cur[i] = mt76_rr(dev, MT_CONN_DBG_CTL_PC_LOG);
 
 	/* stop call stack record */
 	if (!exception) {
-		mt76_clear(dev, MT_MCU_WM_EXCP_PC_CTRL, BIT(0));
-		mt76_clear(dev, MT_MCU_WM_EXCP_LR_CTRL, BIT(0));
+		mt76_clear(dev, MT_MCU_WM_EXCP_PC_CTRL + offset, BIT(0));
+		mt76_clear(dev, MT_MCU_WM_EXCP_LR_CTRL + offset, BIT(0));
 	}
 
-	oldest = (u32)mt76_get_field(dev, MT_MCU_WM_EXCP_PC_CTRL,
-				     GENMASK(20, 16)) + 2;
-	for (i = 0; i < 16; i++) {
-		idx = ((oldest + 2 * i + 1) % 32);
-		dump->pc_stack[i + 1] =
-			mt76_rr(dev, MT_MCU_WM_EXCP_PC_LOG + idx * 4);
+	/* read PC log */
+	dump->pc_dbg_ctrl = mt76_rr(dev, MT_MCU_WM_EXCP_PC_CTRL + offset);
+	dump->pc_cur_idx = FIELD_GET(MT_MCU_WM_EXCP_PC_CTRL_IDX_STATUS,
+				     dump->pc_dbg_ctrl);
+	for (i = 0; i < 32; i++) {
+		reg = MT_MCU_WM_EXCP_PC_LOG + i * 4 + offset;
+		dump->pc_stack[i] = mt76_rr(dev, reg);
 	}
 
-	oldest = (u32)mt76_get_field(dev, MT_MCU_WM_EXCP_LR_CTRL,
-				     GENMASK(20, 16)) + 2;
-	for (i = 0; i < 16; i++) {
-		idx = ((oldest + 2 * i + 1) % 32);
-		dump->lr_stack[i] =
-			mt76_rr(dev, MT_MCU_WM_EXCP_LR_LOG + idx * 4);
+	/* read LR log */
+	dump->lr_dbg_ctrl = mt76_rr(dev, MT_MCU_WM_EXCP_LR_CTRL + offset);
+	dump->lr_cur_idx = FIELD_GET(MT_MCU_WM_EXCP_LR_CTRL_IDX_STATUS,
+				     dump->lr_dbg_ctrl);
+	for (i = 0; i < 32; i++) {
+		reg = MT_MCU_WM_EXCP_LR_LOG + i * 4 + offset;
+		dump->lr_stack[i] = mt76_rr(dev, reg);
 	}
 
 	/* start call stack record */
 	if (!exception) {
-		mt76_set(dev, MT_MCU_WM_EXCP_PC_CTRL, BIT(0));
-		mt76_set(dev, MT_MCU_WM_EXCP_LR_CTRL, BIT(0));
+		mt76_set(dev, MT_MCU_WM_EXCP_PC_CTRL + offset, BIT(0));
+		mt76_set(dev, MT_MCU_WM_EXCP_LR_CTRL + offset, BIT(0));
 	}
 }
 
-static struct mt7996_coredump *mt7996_coredump_build(struct mt7996_dev *dev)
+struct mt7996_coredump *mt7996_coredump_build(struct mt7996_dev *dev, u8 type, bool full_dump)
 {
-	struct mt7996_crash_data *crash_data = dev->coredump.crash_data;
+	struct mt7996_crash_data *crash_data = dev->coredump.crash_data[type];
 	struct mt7996_coredump *dump;
 	struct mt7996_coredump_mem *dump_mem;
 	size_t len, sofar = 0, hdr_len = sizeof(*dump);
@@ -170,7 +252,7 @@ static struct mt7996_coredump *mt7996_coredump_build(struct mt7996_dev *dev)
 
 	len = hdr_len;
 
-	if (coredump_memdump && crash_data->memdump_buf_len)
+	if (full_dump && coredump_memdump && crash_data->memdump_buf_len)
 		len += sizeof(*dump_mem) + crash_data->memdump_buf_len;
 
 	sofar += hdr_len;
@@ -186,20 +268,34 @@ static struct mt7996_coredump *mt7996_coredump_build(struct mt7996_dev *dev)
 
 	dump = (struct mt7996_coredump *)(buf);
 	dump->len = len;
+	dump->hdr_len = hdr_len;
 
 	/* plain text */
 	strscpy(dump->magic, "mt76-crash-dump", sizeof(dump->magic));
 	strscpy(dump->kernel, init_utsname()->release, sizeof(dump->kernel));
+	strscpy(dump->fw_type, ((type == MT7996_RAM_TYPE_WA) ? "WA" : "WM"),
+		sizeof(dump->fw_type));
 	strscpy(dump->fw_ver, dev->mt76.hw->wiphy->fw_version,
 		sizeof(dump->fw_ver));
+	strscpy(dump->fw_patch_date, dev->patch_build_date,
+		sizeof(dump->fw_patch_date));
+	strscpy(dump->fw_ram_date[MT7996_RAM_TYPE_WM],
+		dev->ram_build_date[MT7996_RAM_TYPE_WM],
+		MT7996_BUILD_TIME_LEN);
+	strscpy(dump->fw_ram_date[MT7996_RAM_TYPE_WA],
+		dev->ram_build_date[MT7996_RAM_TYPE_WA],
+		MT7996_BUILD_TIME_LEN);
 
 	guid_copy(&dump->guid, &crash_data->guid);
 	dump->tv_sec = crash_data->timestamp.tv_sec;
 	dump->tv_nsec = crash_data->timestamp.tv_nsec;
 	dump->device_id = mt76_chip(&dev->mt76);
 
-	mt7996_coredump_fw_state(dev, dump, &exception);
-	mt7996_coredump_fw_stack(dev, dump, exception);
+	mt7996_coredump_fw_state(dev, type, dump, &exception);
+	mt7996_coredump_fw_stack(dev, type, dump, exception);
+
+	if (!full_dump)
+		goto skip_dump_mem;
 
 	/* gather memory content */
 	dump_mem = (struct mt7996_coredump_mem *)(buf + sofar);
@@ -208,22 +304,25 @@ static struct mt7996_coredump *mt7996_coredump_build(struct mt7996_dev *dev)
 		memcpy(dump_mem->data, crash_data->memdump_buf,
 		       crash_data->memdump_buf_len);
 
+skip_dump_mem:
 	mutex_unlock(&dev->dump_mutex);
 
 	return dump;
 }
 
-int mt7996_coredump_submit(struct mt7996_dev *dev)
+int mt7996_coredump_submit(struct mt7996_dev *dev, u8 type)
 {
 	struct mt7996_coredump *dump;
 
-	dump = mt7996_coredump_build(dev);
+	dump = mt7996_coredump_build(dev, type, true);
 	if (!dump) {
 		dev_warn(dev->mt76.dev, "no crash dump data found\n");
 		return -ENODATA;
 	}
 
 	dev_coredumpv(dev->mt76.dev, dump, dump->len, GFP_KERNEL);
+	dev_info(dev->mt76.dev, "%s coredump completed\n",
+		 wiphy_name(dev->mt76.hw->wiphy));
 
 	return 0;
 }
@@ -231,38 +330,51 @@ int mt7996_coredump_submit(struct mt7996_dev *dev)
 int mt7996_coredump_register(struct mt7996_dev *dev)
 {
 	struct mt7996_crash_data *crash_data;
+	int i;
+
+	for (i = 0; i < MT7996_COREDUMP_MAX; i++) {
+		crash_data = vzalloc(sizeof(*dev->coredump.crash_data[i]));
+		if (!crash_data)
+			goto nomem;
 
-	crash_data = vzalloc(sizeof(*dev->coredump.crash_data));
-	if (!crash_data)
-		return -ENOMEM;
+		dev->coredump.crash_data[i] = crash_data;
+		crash_data->supported = false;
 
-	dev->coredump.crash_data = crash_data;
+		if (coredump_memdump) {
+			crash_data->memdump_buf_len = mt7996_coredump_get_mem_size(dev, i);
+			if (!crash_data->memdump_buf_len)
+				/* no memory content */
+				continue;
 
-	if (coredump_memdump) {
-		crash_data->memdump_buf_len = mt7996_coredump_get_mem_size(dev);
-		if (!crash_data->memdump_buf_len)
-			/* no memory content */
-			return 0;
+			crash_data->memdump_buf = vzalloc(crash_data->memdump_buf_len);
+			if (!crash_data->memdump_buf)
+				goto nomem;
 
-		crash_data->memdump_buf = vzalloc(crash_data->memdump_buf_len);
-		if (!crash_data->memdump_buf) {
-			vfree(crash_data);
-			return -ENOMEM;
+			crash_data->supported = true;
 		}
 	}
 
 	return 0;
+nomem:
+	mt7996_coredump_unregister(dev);
+	return -ENOMEM;
 }
 
 void mt7996_coredump_unregister(struct mt7996_dev *dev)
 {
-	if (dev->coredump.crash_data->memdump_buf) {
-		vfree(dev->coredump.crash_data->memdump_buf);
-		dev->coredump.crash_data->memdump_buf = NULL;
-		dev->coredump.crash_data->memdump_buf_len = 0;
-	}
+	int i;
+	struct mt7996_crash_data *crash_data;
+
+	for (i = 0; i < MT7996_COREDUMP_MAX; i++) {
+		crash_data = dev->coredump.crash_data[i];
 
-	vfree(dev->coredump.crash_data);
-	dev->coredump.crash_data = NULL;
+		if (!crash_data)
+			continue;
+
+		if (crash_data->memdump_buf)
+			vfree(crash_data->memdump_buf);
+
+		vfree(crash_data);
+	}
 }
 
diff --git a/mt7996/coredump.h b/mt7996/coredump.h
index af2ba219..93cd84a0 100644
--- a/mt7996/coredump.h
+++ b/mt7996/coredump.h
@@ -6,10 +6,13 @@
 
 #include "mt7996.h"
 
+#define MT7996_COREDUMP_MAX	(MT7996_RAM_TYPE_WA + 1)
+
 struct mt7996_coredump {
 	char magic[16];
 
 	u32 len;
+	u32 hdr_len;
 
 	guid_t guid;
 
@@ -21,17 +24,28 @@ struct mt7996_coredump {
 	char kernel[64];
 	/* firmware version */
 	char fw_ver[ETHTOOL_FWVERS_LEN];
+	char fw_patch_date[MT7996_BUILD_TIME_LEN];
+	char fw_ram_date[MT7996_COREDUMP_MAX][MT7996_BUILD_TIME_LEN];
 
 	u32 device_id;
 
+	/* fw type */
+	char fw_type[8];
+
 	/* exception state */
 	char fw_state[12];
 
 	/* program counters */
-	char pc_current[16];
-	u32 pc_stack[17];
-	/* link registers */
-	u32 lr_stack[16];
+	u32 pc_dbg_ctrl;
+	u32 pc_cur_idx;
+	u32 pc_cur[10];
+	/* PC registers */
+	u32 pc_stack[32];
+
+	u32 lr_dbg_ctrl;
+	u32 lr_cur_idx;
+	/* LR registers */
+	u32 lr_stack[32];
 
 	/* memory content */
 	u8 data[];
@@ -43,6 +57,7 @@ struct mt7996_coredump_mem {
 } __packed;
 
 struct mt7996_mem_hdr {
+	char name[64];
 	u32 start;
 	u32 len;
 	u8 data[];
@@ -58,27 +73,34 @@ struct mt7996_mem_region {
 #ifdef CONFIG_DEV_COREDUMP
 
 const struct mt7996_mem_region *
-mt7996_coredump_get_mem_layout(struct mt7996_dev *dev, u32 *num);
-struct mt7996_crash_data *mt7996_coredump_new(struct mt7996_dev *dev);
-int mt7996_coredump_submit(struct mt7996_dev *dev);
+mt7996_coredump_get_mem_layout(struct mt7996_dev *dev, u8 type, u32 *num);
+struct mt7996_crash_data *mt7996_coredump_new(struct mt7996_dev *dev, u8 type);
+struct mt7996_coredump *mt7996_coredump_build(struct mt7996_dev *dev, u8 type, bool full_dump);
+int mt7996_coredump_submit(struct mt7996_dev *dev, u8 type);
 int mt7996_coredump_register(struct mt7996_dev *dev);
 void mt7996_coredump_unregister(struct mt7996_dev *dev);
 
 #else /* CONFIG_DEV_COREDUMP */
 
 static inline const struct mt7996_mem_region *
-mt7996_coredump_get_mem_layout(struct mt7996_dev *dev, u32 *num)
+mt7996_coredump_get_mem_layout(struct mt7996_dev *dev, u8 type, u32 *num)
 {
 	return NULL;
 }
 
-static inline int mt7996_coredump_submit(struct mt7996_dev *dev)
+static inline int mt7996_coredump_submit(struct mt7996_dev *dev, u8 type)
 {
 	return 0;
 }
 
 static inline struct
-mt7996_crash_data *mt7996_coredump_new(struct mt7996_dev *dev)
+mt7996_coredump *mt7996_coredump_build(struct mt7996_dev *dev, u8 type, bool full_dump)
+{
+	return NULL;
+}
+
+static inline struct
+mt7996_crash_data *mt7996_coredump_new(struct mt7996_dev *dev, u8 type)
 {
 	return NULL;
 }
diff --git a/mt7996/debugfs.c b/mt7996/debugfs.c
index 75b5e3e1..f2af4ba9 100644
--- a/mt7996/debugfs.c
+++ b/mt7996/debugfs.c
@@ -51,10 +51,12 @@ static ssize_t
 mt7996_sys_recovery_set(struct file *file, const char __user *user_buf,
 			size_t count, loff_t *ppos)
 {
-	struct mt7996_dev *dev = file->private_data;
-	char buf[16], *sep;
+	struct mt7996_phy *phy = file->private_data;
+	struct mt7996_dev *dev = phy->dev;
+	bool band = phy->mt76->band_idx;
+	char buf[16];
 	int ret = 0;
-	u16 band, val;
+	u16 val;
 
 	if (count >= sizeof(buf))
 		return -EINVAL;
@@ -67,26 +69,21 @@ mt7996_sys_recovery_set(struct file *file, const char __user *user_buf,
 	else
 		buf[count] = '\0';
 
-	sep = strchr(buf, ',');
-	if (!sep)
-		return -EINVAL;
-
-	*sep = 0;
-	if (kstrtou16(buf, 0, &band) || kstrtou16(sep + 1, 0, &val))
+	if (kstrtou16(buf, 0, &val))
 		return -EINVAL;
 
 	switch (val) {
 	/*
-	 * <band>,0: grab firmware current SER state.
-	 * <band>,1: trigger & enable system error L1 recovery.
-	 * <band>,2: trigger & enable system error L2 recovery.
-	 * <band>,3: trigger & enable system error L3 rx abort.
-	 * <band>,4: trigger & enable system error L3 tx abort
-	 * <band>,5: trigger & enable system error L3 tx disable.
-	 * <band>,6: trigger & enable system error L3 bf recovery.
-	 * <band>,7: trigger & enable system error L4 mdp recovery.
-	 * <band>,8: trigger & enable system error full recovery.
-	 * <band>,9: trigger firmware crash.
+	 * 0: grab firmware current SER state.
+	 * 1: trigger & enable system error L1 recovery.
+	 * 2: trigger & enable system error L2 recovery.
+	 * 3: trigger & enable system error L3 rx abort.
+	 * 4: trigger & enable system error L3 tx abort
+	 * 5: trigger & enable system error L3 tx disable.
+	 * 6: trigger & enable system error L3 bf recovery.
+	 * 7: trigger & enable system error L4 mdp recovery.
+	 * 8: trigger & enable system error full recovery.
+	 * 9: trigger firmware crash.
 	 * 10: trigger grab wa firmware coredump.
 	 * 11: trigger grab wm firmware coredump.
 	 * 12: hw bit detect only.
@@ -111,15 +108,25 @@ mt7996_sys_recovery_set(struct file *file, const char __user *user_buf,
 	/* enable full chip reset */
 	case UNI_CMD_SER_SET_RECOVER_FULL:
 		mt76_set(dev, MT_WFDMA0_MCU_HOST_INT_ENA, MT_MCU_CMD_WDT_MASK);
-		dev->recovery.state |= MT_MCU_CMD_WDT_MASK;
+		dev->recovery.state |= MT_MCU_CMD_WM_WDT;
 		mt7996_reset(dev);
 		break;
 
 	/* WARNING: trigger firmware crash */
 	case UNI_CMD_SER_SET_SYSTEM_ASSERT:
+		// trigger wm assert exception
 		ret = mt7996_mcu_trigger_assert(dev);
 		if (ret)
 			return ret;
+		// trigger wa assert exception
+		mt76_wr(dev, 0x89098108, 0x20);
+		mt76_wr(dev, 0x89098118, 0x20);
+		break;
+	case UNI_CMD_SER_FW_COREDUMP_WA:
+		mt7996_coredump(dev, MT7996_COREDUMP_MANUAL_WA);
+		break;
+	case UNI_CMD_SER_FW_COREDUMP_WM:
+		mt7996_coredump(dev, MT7996_COREDUMP_MANUAL_WM);
 		break;
 	case UNI_CMD_SER_SET_HW_BIT_DETECT_ONLY:
 		ret = mt7996_mcu_set_ser(dev, UNI_CMD_SER_SET, BIT(0), band);
@@ -137,7 +144,8 @@ static ssize_t
 mt7996_sys_recovery_get(struct file *file, char __user *user_buf,
 			size_t count, loff_t *ppos)
 {
-	struct mt7996_dev *dev = file->private_data;
+	struct mt7996_phy *phy = file->private_data;
+	struct mt7996_dev *dev = phy->dev;
 	char *buff;
 	int desc = 0;
 	ssize_t ret;
@@ -151,25 +159,35 @@ mt7996_sys_recovery_get(struct file *file, char __user *user_buf,
 	desc += scnprintf(buff + desc, bufsz - desc,
 			  "Please echo the correct value ...\n");
 	desc += scnprintf(buff + desc, bufsz - desc,
-			  "<band>,0: grab firmware transient SER state\n");
+			  "%2d: grab firmware transient SER state\n",
+			  UNI_CMD_SER_QUERY);
 	desc += scnprintf(buff + desc, bufsz - desc,
-			  "<band>,1: trigger system error L1 recovery\n");
+			  "%2d: trigger system error L1 recovery\n",
+			  UNI_CMD_SER_SET_RECOVER_L1);
 	desc += scnprintf(buff + desc, bufsz - desc,
-			  "<band>,2: trigger system error L2 recovery\n");
+			  "%2d: trigger system error L2 recovery\n",
+			  UNI_CMD_SER_SET_RECOVER_L2);
 	desc += scnprintf(buff + desc, bufsz - desc,
-			  "<band>,3: trigger system error L3 rx abort\n");
+			  "%2d: trigger system error L3 rx abort\n",
+			  UNI_CMD_SER_SET_RECOVER_L3_RX_ABORT);
 	desc += scnprintf(buff + desc, bufsz - desc,
-			  "<band>,4: trigger system error L3 tx abort\n");
+			  "%2d: trigger system error L3 tx abort\n",
+			  UNI_CMD_SER_SET_RECOVER_L3_TX_ABORT);
 	desc += scnprintf(buff + desc, bufsz - desc,
-			  "<band>,5: trigger system error L3 tx disable\n");
+			  "%2d: trigger system error L3 tx disable\n",
+			  UNI_CMD_SER_SET_RECOVER_L3_TX_DISABLE);
 	desc += scnprintf(buff + desc, bufsz - desc,
-			  "<band>,6: trigger system error L3 bf recovery\n");
+			  "%2d: trigger system error L3 bf recovery\n",
+			  UNI_CMD_SER_SET_RECOVER_L3_BF);
 	desc += scnprintf(buff + desc, bufsz - desc,
-			  "<band>,7: trigger system error L4 mdp recovery\n");
+			  "%2d: trigger system error L4 mdp recovery\n",
+			  UNI_CMD_SER_SET_RECOVER_L4_MDP);
 	desc += scnprintf(buff + desc, bufsz - desc,
-			  "<band>,8: trigger system error full recovery\n");
+			  "%2d: trigger system error full recovery\n",
+			  UNI_CMD_SER_SET_RECOVER_FULL);
 	desc += scnprintf(buff + desc, bufsz - desc,
-			  "<band>,9: trigger firmware crash\n");
+			  "%2d: trigger firmware crash\n",
+			  UNI_CMD_SER_SET_SYSTEM_ASSERT);
 	desc += scnprintf(buff + desc, bufsz - desc,
 			  "%2d: trigger grab wa firmware coredump\n",
 			  UNI_CMD_SER_FW_COREDUMP_WA);
@@ -265,6 +283,11 @@ mt7996_rdd_monitor(struct seq_file *s, void *data)
 
 	mutex_lock(&dev->mt76.mutex);
 
+	if (!mt7996_has_background_radar(dev)) {
+		seq_puts(s, "no background radar capability\n");
+		goto out;
+	}
+
 	if (!cfg80211_chandef_valid(chandef)) {
 		ret = -EINVAL;
 		goto out;
@@ -312,12 +335,44 @@ mt7996_fw_debug_wm_set(void *data, u64 val)
 		DEBUG_CMD_RPT_TRIG,
 		DEBUG_SPL,
 		DEBUG_RPT_RX,
-		DEBUG_RPT_RA = 68,
-	} debug;
+		DEBUG_IDS_SND = 84,
+		DEBUG_IDS_BSRP,
+		DEBUG_IDS_TPUT_MON,
+		DEBUG_IDS_PP = 93,
+		DEBUG_IDS_RA,
+		DEBUG_IDS_BF,
+		DEBUG_IDS_SR,
+		DEBUG_IDS_RU,
+		DEBUG_IDS_MUMIMO,
+		DEBUG_IDS_MLO = 100,
+		DEBUG_IDS_ERR_LOG,
+	};
+	u8 debug_category[] = {
+		DEBUG_TXCMD,
+		DEBUG_CMD_RPT_TX,
+		DEBUG_CMD_RPT_TRIG,
+		DEBUG_SPL,
+		DEBUG_RPT_RX,
+		DEBUG_IDS_SND,
+		DEBUG_IDS_BSRP,
+		DEBUG_IDS_TPUT_MON,
+		DEBUG_IDS_PP,
+		DEBUG_IDS_RA,
+		DEBUG_IDS_BF,
+		DEBUG_IDS_SR,
+		DEBUG_IDS_RU,
+		DEBUG_IDS_MUMIMO,
+		DEBUG_IDS_MLO,
+		DEBUG_IDS_ERR_LOG,
+	};
 	bool tx, rx, en;
 	int ret;
+	u8 i;
 
 	dev->fw_debug_wm = val ? MCU_FW_LOG_TO_HOST : 0;
+#ifdef CONFIG_MTK_DEBUG
+	dev->fw_debug_wm = val;
+#endif
 
 	if (dev->fw_debug_bin)
 		val = MCU_FW_LOG_RELAY;
@@ -332,18 +387,22 @@ mt7996_fw_debug_wm_set(void *data, u64 val)
 	if (ret)
 		return ret;
 
-	for (debug = DEBUG_TXCMD; debug <= DEBUG_RPT_RA; debug++) {
-		if (debug == 67)
-			continue;
-
-		if (debug == DEBUG_RPT_RX)
+	for (i = 0; i < ARRAY_SIZE(debug_category); i++) {
+		if (debug_category[i] == DEBUG_RPT_RX)
 			val = en && rx;
 		else
 			val = en && tx;
 
-		ret = mt7996_mcu_fw_dbg_ctrl(dev, debug, val);
+		ret = mt7996_mcu_fw_dbg_ctrl(dev, debug_category[i], val);
 		if (ret)
 			return ret;
+
+		if ((debug_category[i] == DEBUG_TXCMD ||
+		     debug_category[i] == DEBUG_IDS_SND) && en) {
+			ret = mt7996_mcu_fw_dbg_ctrl(dev, debug_category[i], 2);
+			if (ret)
+				return ret;
+		}
 	}
 
 	return 0;
@@ -397,8 +456,8 @@ create_buf_file_cb(const char *filename, struct dentry *parent, umode_t mode,
 {
 	struct dentry *f;
 
-	f = debugfs_create_file("fwlog_data", mode, parent, buf,
-				&relay_file_operations);
+	f = debugfs_create_file(filename[0] == 'f' ? "fwlog_data" : "idxlog_data",
+	                        mode, parent, buf, &relay_file_operations);
 	if (IS_ERR(f))
 		return NULL;
 
@@ -415,6 +474,39 @@ remove_buf_file_cb(struct dentry *f)
 	return 0;
 }
 
+static int
+mt7996_fw_debug_muru_set(void *data)
+{
+	struct mt7996_dev *dev = data;
+	enum {
+		DEBUG_BSRP_STATUS = 256,
+		DEBUG_TX_DATA_BYTE_CONUT,
+		DEBUG_RX_DATA_BYTE_CONUT,
+		DEBUG_RX_TOTAL_BYTE_CONUT,
+		DEBUG_INVALID_TID_BSR,
+		DEBUG_UL_LONG_TERM_PPDU_TYPE,
+		DEBUG_DL_LONG_TERM_PPDU_TYPE,
+		DEBUG_PPDU_CLASS_TRIG_ONOFF,
+		DEBUG_AIRTIME_BUSY_STATUS,
+		DEBUG_UL_OFDMA_MIMO_STATUS,
+		DEBUG_RU_CANDIDATE,
+		DEBUG_MEC_UPDATE_AMSDU,
+	} debug;
+	int ret;
+
+	if (dev->fw_debug_muru_disable)
+		return 0;
+
+	for (debug = DEBUG_BSRP_STATUS; debug <= DEBUG_MEC_UPDATE_AMSDU; debug++) {
+		ret = mt7996_mcu_muru_dbg_info(dev, debug,
+					       dev->fw_debug_bin & BIT(0));
+		if (ret)
+			return ret;
+	}
+
+	return 0;
+}
+
 static int
 mt7996_fw_debug_bin_set(void *data, u64 val)
 {
@@ -423,17 +515,32 @@ mt7996_fw_debug_bin_set(void *data, u64 val)
 		.remove_buf_file = remove_buf_file_cb,
 	};
 	struct mt7996_dev *dev = data;
+	int ret;
 
-	if (!dev->relay_fwlog)
+	if (!dev->relay_fwlog) {
 		dev->relay_fwlog = relay_open("fwlog_data", dev->debugfs_dir,
 					      1500, 512, &relay_cb, NULL);
-	if (!dev->relay_fwlog)
-		return -ENOMEM;
+		if (!dev->relay_fwlog)
+			return -ENOMEM;
+	}
 
 	dev->fw_debug_bin = val;
 
 	relay_reset(dev->relay_fwlog);
 
+	ret = mt7996_fw_debug_muru_set(dev);
+	if (ret)
+		return ret;
+
+#ifdef CONFIG_MTK_DEBUG
+	dev->dbg.dump_mcu_pkt = !!(val & BIT(4));
+	dev->dbg.dump_txd = !!(val & BIT(5));
+	dev->dbg.dump_tx_pkt = !!(val & BIT(6));
+	dev->dbg.dump_rx_pkt = !!(val & BIT(7));
+	dev->dbg.dump_rx_raw = !!(val & BIT(8));
+	dev->dbg.dump_mcu_event = !!(val & BIT(9));
+#endif
+
 	return mt7996_fw_debug_wm_set(dev, dev->fw_debug_wm);
 }
 
@@ -450,6 +557,53 @@ mt7996_fw_debug_bin_get(void *data, u64 *val)
 DEFINE_DEBUGFS_ATTRIBUTE(fops_fw_debug_bin, mt7996_fw_debug_bin_get,
 			 mt7996_fw_debug_bin_set, "%lld\n");
 
+static int
+mt7996_idxlog_enable_get(void *data, u64 *val)
+{
+	struct mt7996_dev *dev = data;
+
+	*val = dev->idxlog_enable;
+
+	return 0;
+}
+
+static int
+mt7996_idxlog_enable_set(void *data, u64 val)
+{
+	static struct rchan_callbacks relay_cb = {
+		.create_buf_file = create_buf_file_cb,
+		.remove_buf_file = remove_buf_file_cb,
+	};
+	struct mt7996_dev *dev = data;
+
+	if (dev->idxlog_enable == !!val)
+		return 0;
+
+	if (!dev->relay_idxlog) {
+		dev->relay_idxlog = relay_open("idxlog_data", dev->debugfs_dir,
+		                               1500, 512, &relay_cb, NULL);
+		if (!dev->relay_idxlog)
+			return -ENOMEM;
+	}
+
+	dev->idxlog_enable = !!val;
+
+	if (val) {
+		int ret = mt7996_mcu_fw_time_sync(&dev->mt76);
+		if (ret)
+			return ret;
+
+		/* Reset relay channel only when it is not being written to. */
+		relay_reset(dev->relay_idxlog);
+	}
+
+	return mt7996_mcu_fw_log_2_host(dev, MCU_FW_LOG_WM,
+	                                val ? MCU_FW_LOG_RELAY_IDX : 0);
+}
+
+DEFINE_DEBUGFS_ATTRIBUTE(fops_idxlog_enable, mt7996_idxlog_enable_get,
+	                 mt7996_idxlog_enable_set, "%llu\n");
+
 static int
 mt7996_fw_util_wa_show(struct seq_file *file, void *data)
 {
@@ -542,12 +696,15 @@ mt7996_txbf_stat_read_phy(struct mt7996_phy *phy, struct seq_file *s)
 	seq_puts(s, "\n");
 }
 
-static void
-mt7996_tx_stats_show_phy(struct seq_file *file, struct mt7996_phy *phy)
+static int
+mt7996_tx_stats_show(struct seq_file *file, void *data)
 {
+	struct mt7996_phy *phy = file->private;
+	struct mt7996_dev *dev = phy->dev;
 	struct mt76_mib_stats *mib = &phy->mib;
 	u32 attempts, success, per;
-	int i;
+
+	mutex_lock(&dev->mt76.mutex);
 
 	mt7996_mac_update_stats(phy);
 	mt7996_ampdu_stat_read_phy(phy, file);
@@ -558,38 +715,10 @@ mt7996_tx_stats_show_phy(struct seq_file *file, struct mt7996_phy *phy)
 	seq_printf(file, "Tx attempts: %8u (MPDUs)\n", attempts);
 	seq_printf(file, "Tx success: %8u (MPDUs)\n", success);
 	seq_printf(file, "Tx PER: %u%%\n", per);
+	seq_printf(file, "Tx RED drop: %8u\n", phy->red_drop);
 
 	mt7996_txbf_stat_read_phy(phy, file);
 
-	/* Tx amsdu info */
-	seq_puts(file, "Tx MSDU statistics:\n");
-	for (i = 0; i < ARRAY_SIZE(mib->tx_amsdu); i++) {
-		seq_printf(file, "AMSDU pack count of %d MSDU in TXD: %8d ",
-			   i + 1, mib->tx_amsdu[i]);
-		if (mib->tx_amsdu_cnt)
-			seq_printf(file, "(%3d%%)\n",
-				   mib->tx_amsdu[i] * 100 / mib->tx_amsdu_cnt);
-		else
-			seq_puts(file, "\n");
-	}
-}
-
-static int
-mt7996_tx_stats_show(struct seq_file *file, void *data)
-{
-	struct mt7996_dev *dev = file->private;
-	struct mt7996_phy *phy = &dev->phy;
-
-	mutex_lock(&dev->mt76.mutex);
-
-	mt7996_tx_stats_show_phy(file, phy);
-	phy = mt7996_phy2(dev);
-	if (phy)
-		mt7996_tx_stats_show_phy(file, phy);
-	phy = mt7996_phy3(dev);
-	if (phy)
-		mt7996_tx_stats_show_phy(file, phy);
-
 	mutex_unlock(&dev->mt76.mutex);
 
 	return 0;
@@ -632,14 +761,15 @@ static void
 mt7996_sta_hw_queue_read(void *data, struct ieee80211_sta *sta)
 {
 	struct mt7996_sta *msta = (struct mt7996_sta *)sta->drv_priv;
+	struct mt7996_link_sta *mlink = &msta->deflink;
 	struct mt7996_dev *dev = msta->vif->deflink.phy->dev;
 	struct seq_file *s = data;
 	u8 ac;
 
 	for (ac = 0; ac < 4; ac++) {
 		u32 qlen, ctrl, val;
-		u32 idx = msta->wcid.idx >> 5;
-		u8 offs = msta->wcid.idx & GENMASK(4, 0);
+		u32 idx = mlink->wcid.idx >> 5;
+		u8 offs = mlink->wcid.idx & GENMASK(4, 0);
 
 		ctrl = BIT(31) | BIT(11) | (ac << 24);
 		val = mt76_rr(dev, MT_PLE_AC_QEMPTY(ac, idx));
@@ -647,11 +777,11 @@ mt7996_sta_hw_queue_read(void *data, struct ieee80211_sta *sta)
 		if (val & BIT(offs))
 			continue;
 
-		mt76_wr(dev, MT_FL_Q0_CTRL, ctrl | msta->wcid.idx);
+		mt76_wr(dev, MT_FL_Q0_CTRL, ctrl | mlink->wcid.idx);
 		qlen = mt76_get_field(dev, MT_FL_Q3_CTRL,
 				      GENMASK(11, 0));
 		seq_printf(s, "\tSTA %pM wcid %d: AC%d%d queued:%d\n",
-			   sta->addr, msta->wcid.idx,
+			   sta->addr, mlink->wcid.idx,
 			   msta->vif->deflink.mt76.wmm_idx, ac, qlen);
 	}
 }
@@ -659,8 +789,8 @@ mt7996_sta_hw_queue_read(void *data, struct ieee80211_sta *sta)
 static int
 mt7996_hw_queues_show(struct seq_file *file, void *data)
 {
-	struct mt7996_dev *dev = file->private;
-	struct mt7996_phy *phy = &dev->phy;
+	struct mt7996_phy *phy = file->private;
+	struct mt7996_dev *dev = phy->dev;
 	static const struct hw_queue_map ple_queue_map[] = {
 		{ "CPU_Q0",  0,  1, MT_CTX0	      },
 		{ "CPU_Q1",  1,  1, MT_CTX0 + 1	      },
@@ -716,15 +846,6 @@ mt7996_hw_queues_show(struct seq_file *file, void *data)
 	/* iterate per-sta ple queue */
 	ieee80211_iterate_stations_atomic(phy->mt76->hw,
 					  mt7996_sta_hw_queue_read, file);
-	phy = mt7996_phy2(dev);
-	if (phy)
-		ieee80211_iterate_stations_atomic(phy->mt76->hw,
-						  mt7996_sta_hw_queue_read, file);
-	phy = mt7996_phy3(dev);
-	if (phy)
-		ieee80211_iterate_stations_atomic(phy->mt76->hw,
-						  mt7996_sta_hw_queue_read, file);
-
 	/* pse queue */
 	seq_puts(file, "PSE non-empty queue info:\n");
 	mt7996_hw_queue_read(file, ARRAY_SIZE(pse_queue_map),
@@ -738,29 +859,19 @@ DEFINE_SHOW_ATTRIBUTE(mt7996_hw_queues);
 static int
 mt7996_xmit_queues_show(struct seq_file *file, void *data)
 {
-	struct mt7996_dev *dev = file->private;
-	struct mt7996_phy *phy;
+	struct mt7996_phy *phy = file->private;
+	struct mt7996_dev *dev = phy->dev;
 	struct {
 		struct mt76_queue *q;
 		char *queue;
 	} queue_map[] = {
-		{ dev->mphy.q_tx[MT_TXQ_BE],	 "  MAIN0"  },
-		{ NULL,				 "  MAIN1"  },
-		{ NULL,				 "  MAIN2"  },
+		{ phy->mt76->q_tx[MT_TXQ_BE],	 "   MAIN"  },
 		{ dev->mt76.q_mcu[MT_MCUQ_WM],	 "  MCUWM"  },
 		{ dev->mt76.q_mcu[MT_MCUQ_WA],	 "  MCUWA"  },
 		{ dev->mt76.q_mcu[MT_MCUQ_FWDL], "MCUFWDL" },
 	};
 	int i;
 
-	phy = mt7996_phy2(dev);
-	if (phy)
-		queue_map[1].q = phy->mt76->q_tx[MT_TXQ_BE];
-
-	phy = mt7996_phy3(dev);
-	if (phy)
-		queue_map[2].q = phy->mt76->q_tx[MT_TXQ_BE];
-
 	seq_puts(file, "     queue | hw-queued |      head |      tail |\n");
 	for (i = 0; i < ARRAY_SIZE(queue_map); i++) {
 		struct mt76_queue *q = queue_map[i].q;
@@ -835,24 +946,205 @@ mt7996_rf_regval_set(void *data, u64 val)
 DEFINE_DEBUGFS_ATTRIBUTE(fops_rf_regval, mt7996_rf_regval_get,
 			 mt7996_rf_regval_set, "0x%08llx\n");
 
-int mt7996_init_debugfs(struct mt7996_dev *dev)
+static int
+mt7996_fw_debug_muru_disable_set(void *data, u64 val)
+{
+	struct mt7996_dev *dev = data;
+
+	dev->fw_debug_muru_disable = !!val;
+
+	return 0;
+}
+
+static int
+mt7996_fw_debug_muru_disable_get(void *data, u64 *val)
+{
+	struct mt7996_dev *dev = data;
+
+	*val = dev->fw_debug_muru_disable;
+
+	return 0;
+}
+
+DEFINE_DEBUGFS_ATTRIBUTE(fops_fw_debug_muru_disable,
+			 mt7996_fw_debug_muru_disable_get,
+			 mt7996_fw_debug_muru_disable_set, "%lld\n");
+
+static ssize_t
+mt7996_efuse_get(struct file *file, char __user *user_buf,
+		 size_t count, loff_t *ppos)
+{
+	struct mt7996_dev *dev = file->private_data;
+	struct mt76_dev *mdev = &dev->mt76;
+	u8 *buff = mdev->otp.data;
+	int i;
+	ssize_t ret;
+	u32 block_num;
+
+	mdev->otp.size = MT7996_EEPROM_SIZE;
+	if (is_mt7996(&dev->mt76) && dev->var.type == MT7996_VAR_TYPE_444)
+		mdev->otp.size += 3 * MT_EE_CAL_UNIT;
+
+	if (!mdev->otp.data) {
+		mdev->otp.data = devm_kzalloc(mdev->dev, mdev->otp.size, GFP_KERNEL);
+		if (!mdev->otp.data)
+			return -ENOMEM;
+
+		block_num = DIV_ROUND_UP(mdev->otp.size, MT7996_EEPROM_BLOCK_SIZE);
+		for (i = 0; i < block_num; i++) {
+			buff = mdev->otp.data + i * MT7996_EEPROM_BLOCK_SIZE;
+			ret = mt7996_mcu_get_eeprom(dev, i * MT7996_EEPROM_BLOCK_SIZE, buff);
+			if (ret && ret != -EINVAL)
+				return ret;
+		}
+	}
+
+	ret = simple_read_from_buffer(user_buf, count, ppos, mdev->otp.data, mdev->otp.size);
+
+	return ret;
+}
+
+static const struct file_operations mt7996_efuse_ops = {
+	.read = mt7996_efuse_get,
+	.open = simple_open,
+	.llseek = default_llseek,
+};
+
+static int
+mt7996_vow_info_read(struct seq_file *s, void *data)
+{
+	struct mt7996_dev *dev = dev_get_drvdata(s->private);
+	struct mt7996_vow_ctrl *vow = &dev->vow;
+	int i;
+
+	seq_printf(s, "VoW ATF Configuration:\n");
+	seq_printf(s, "ATF: %s\n", vow->atf_enable ? "enabled" : "disabled");
+	seq_printf(s, "WATF: %s\n", vow->watf_enable ? "enabled" : "disabled");
+	seq_printf(s, "Airtime Quantums (unit: 256 us)\n");
+	for (i = 0; i < VOW_DRR_QUANTUM_NUM; ++i)
+		seq_printf(s, "\tL%d: %hhu\n", i, vow->drr_quantum[i]);
+	seq_printf(s, "Max Airtime Deficit: %hhu (unit: 256 us)\n", vow->max_deficit);
+
+	return 0;
+}
+
+static int
+mt7996_atf_enable_get(void *data, u64 *val)
+{
+	struct mt7996_phy *phy = data;
+
+	*val = phy->dev->vow.atf_enable;
+
+	return 0;
+}
+
+static int
+mt7996_atf_enable_set(void *data, u64 val)
 {
+	struct mt7996_phy *phy = data;
+	struct mt7996_vow_ctrl *vow = &phy->dev->vow;
+	int ret;
+
+	vow->max_deficit = val ? 64 : 1;
+	ret = mt7996_mcu_set_vow_drr_ctrl(phy, NULL, NULL, VOW_DRR_CTRL_AIRTIME_DEFICIT_BOUND);
+	if (ret)
+		return ret;
+
+	vow->atf_enable = !!val;
+	return mt7996_mcu_set_vow_feature_ctrl(phy);
+}
+
+DEFINE_DEBUGFS_ATTRIBUTE(fops_atf_enable, mt7996_atf_enable_get,
+	                 mt7996_atf_enable_set, "%llu\n");
+
+static int
+mt7996_airtime_read(struct seq_file *s, void *data)
+{
+	struct mt7996_dev *dev = dev_get_drvdata(s->private);
+	struct mt76_dev *mdev = &dev->mt76;
+	struct mt76_sta_stats *stats;
+	struct ieee80211_sta *sta;
+	struct mt7996_link_sta *mlink;
+	struct mt76_wcid *wcid;
+	struct mt76_vif *vif;
+	u16 i;
+
+	seq_printf(s, "VoW Airtime Information:\n");
+	rcu_read_lock();
+	for (i = 1; i < MT7996_WTBL_STA; ++i) {
+		wcid = rcu_dereference(mdev->wcid[i]);
+		if (!wcid || !wcid->sta)
+			continue;
+
+		mlink = container_of(wcid, struct mt7996_link_sta, wcid);
+		sta = container_of((void *)mlink->sta, struct ieee80211_sta, drv_priv);
+		vif = &mlink->sta->vif->deflink.mt76;
+		stats = &wcid->stats;
+
+		seq_printf(s, "%pM WCID: %hu BandIdx: %hhu OmacIdx: 0x%hhx\t"
+		              "TxAirtime: %llu\tRxAirtime: %llu\n",
+		              sta->addr, i, vif->band_idx, vif->omac_idx,
+		              stats->tx_airtime, stats->rx_airtime);
+
+		stats->tx_airtime = 0;
+		stats->rx_airtime = 0;
+	}
+	rcu_read_unlock();
+
+	return 0;
+}
+
+int mt7996_init_band_debugfs(struct mt7996_phy *phy)
+{
+	struct mt7996_dev *dev = phy->dev;
 	struct dentry *dir;
+	char dir_name[10];
+
+	if (!dev->debugfs_dir)
+		return -EINVAL;
 
-	dir = mt76_register_debugfs_fops(&dev->mphy, NULL);
+	snprintf(dir_name, sizeof(dir_name), "band%d", phy->mt76->band_idx);
+
+	dir = debugfs_create_dir(dir_name, dev->debugfs_dir);
 	if (!dir)
 		return -ENOMEM;
 
-	debugfs_create_file("hw-queues", 0400, dir, dev,
+	debugfs_create_file("hw-queues", 0400, dir, phy,
 			    &mt7996_hw_queues_fops);
-	debugfs_create_file("xmit-queues", 0400, dir, dev,
+	debugfs_create_file("xmit-queues", 0400, dir, phy,
 			    &mt7996_xmit_queues_fops);
-	debugfs_create_file("tx_stats", 0400, dir, dev, &mt7996_tx_stats_fops);
-	debugfs_create_file("sys_recovery", 0600, dir, dev,
+	debugfs_create_file("sys_recovery", 0600, dir, phy,
 			    &mt7996_sys_recovery_ops);
+	debugfs_create_file("atf_enable", 0600, dir, phy, &fops_atf_enable);
+	debugfs_create_file("tx_stats", 0400, dir, phy, &mt7996_tx_stats_fops);
+	if (phy->mt76->cap.has_5ghz) {
+		debugfs_create_u32("dfs_hw_pattern", 0400, dir,
+				   &dev->hw_pattern);
+		debugfs_create_file("radar_trigger", 0200, dir, dev,
+				    &fops_radar_trigger);
+		debugfs_create_devm_seqfile(dev->mt76.dev, "rdd_monitor", dir,
+					    mt7996_rdd_monitor);
+	}
+
+#ifdef CONFIG_MTK_DEBUG
+	mt7996_mtk_init_band_debugfs(phy, dir);
+	mt7996_mtk_init_band_debugfs_internal(phy, dir);
+#endif
+	return 0;
+}
+
+int mt7996_init_dev_debugfs(struct mt7996_phy *phy)
+{
+	struct mt7996_dev *dev = phy->dev;
+	struct dentry *dir;
+
+	dir = mt76_register_debugfs_fops(phy->mt76, NULL);
+	if (!dir)
+		return -ENOMEM;
 	debugfs_create_file("fw_debug_wm", 0600, dir, dev, &fops_fw_debug_wm);
 	debugfs_create_file("fw_debug_wa", 0600, dir, dev, &fops_fw_debug_wa);
 	debugfs_create_file("fw_debug_bin", 0600, dir, dev, &fops_fw_debug_bin);
+	debugfs_create_file("idxlog_enable", 0600, dir, dev, &fops_idxlog_enable);
 	/* TODO: wm fw cpu utilization */
 	debugfs_create_file("fw_util_wa", 0400, dir, dev,
 			    &mt7996_fw_util_wa_fops);
@@ -861,14 +1153,26 @@ int mt7996_init_debugfs(struct mt7996_dev *dev)
 	debugfs_create_devm_seqfile(dev->mt76.dev, "twt_stats", dir,
 				    mt7996_twt_stats);
 	debugfs_create_file("rf_regval", 0600, dir, dev, &fops_rf_regval);
+	debugfs_create_file("otp", 0400, dir, dev, &mt7996_efuse_ops);
+	debugfs_create_devm_seqfile(dev->mt76.dev, "vow_info", dir,
+	                            mt7996_vow_info_read);
+	debugfs_create_devm_seqfile(dev->mt76.dev, "airtime", dir,
+	                            mt7996_airtime_read);
+
+	debugfs_create_file("fw_debug_muru_disable", 0600, dir, dev,
+			    &fops_fw_debug_muru_disable);
+
+	if (phy == &dev->phy) {
+		dev->debugfs_dir = dir;
+#ifdef CONFIG_MTK_DEBUG
+		mt7996_mtk_init_dev_debugfs_internal(phy, dir);
+#endif
+	}
 
-	debugfs_create_u32("dfs_hw_pattern", 0400, dir, &dev->hw_pattern);
-	debugfs_create_file("radar_trigger", 0200, dir, dev,
-			    &fops_radar_trigger);
-	debugfs_create_devm_seqfile(dev->mt76.dev, "rdd_monitor", dir,
-				    mt7996_rdd_monitor);
-
-	dev->debugfs_dir = dir;
+#ifdef CONFIG_MTK_DEBUG
+	debugfs_create_u16("wlan_idx", 0600, dir, &dev->wlan_idx);
+	mt7996_mtk_init_dev_debugfs(dev, dir);
+#endif
 
 	return 0;
 }
@@ -881,7 +1185,11 @@ mt7996_debugfs_write_fwlog(struct mt7996_dev *dev, const void *hdr, int hdrlen,
 	unsigned long flags;
 	void *dest;
 
+	if (!dev->relay_fwlog)
+		return;
+
 	spin_lock_irqsave(&lock, flags);
+
 	dest = relay_reserve(dev->relay_fwlog, hdrlen + len + 4);
 	if (dest) {
 		*(u32 *)dest = hdrlen + len;
@@ -898,6 +1206,32 @@ mt7996_debugfs_write_fwlog(struct mt7996_dev *dev, const void *hdr, int hdrlen,
 	spin_unlock_irqrestore(&lock, flags);
 }
 
+static void
+mt7996_debugfs_write_idxlog(struct mt7996_dev *dev, const void *data, int len)
+{
+	static DEFINE_SPINLOCK(lock);
+	unsigned long flags;
+	void *dest;
+
+	if (!dev->relay_idxlog)
+		return;
+
+	spin_lock_irqsave(&lock, flags);
+
+	dest = relay_reserve(dev->relay_idxlog, len + 4);
+	if (!dest)
+		dev_err(dev->mt76.dev, "Failed to reserve slot in %s\n",
+		        dev->relay_idxlog->base_filename);
+	else {
+		*(u32 *)dest = len;
+		dest += 4;
+		memcpy(dest, data, len);
+		relay_flush(dev->relay_idxlog);
+	}
+
+	spin_unlock_irqrestore(&lock, flags);
+}
+
 void mt7996_debugfs_rx_fw_monitor(struct mt7996_dev *dev, const void *data, int len)
 {
 	struct {
@@ -914,9 +1248,6 @@ void mt7996_debugfs_rx_fw_monitor(struct mt7996_dev *dev, const void *data, int
 		.msg_type = cpu_to_le16(PKT_TYPE_RX_FW_MONITOR),
 	};
 
-	if (!dev->relay_fwlog)
-		return;
-
 	hdr.serial_id = cpu_to_le16(dev->fw_debug_seq++);
 	hdr.timestamp = cpu_to_le32(mt76_rr(dev, MT_LPON_FRCR(0)));
 	hdr.len = *(__le16 *)data;
@@ -925,11 +1256,18 @@ void mt7996_debugfs_rx_fw_monitor(struct mt7996_dev *dev, const void *data, int
 
 bool mt7996_debugfs_rx_log(struct mt7996_dev *dev, const void *data, int len)
 {
-	if (get_unaligned_le32(data) != FW_BIN_LOG_MAGIC)
-		return false;
+	bool is_fwlog = get_unaligned_le32(data) == FW_BIN_LOG_MAGIC;
+#ifdef CONFIG_MTK_DEBUG
+	is_fwlog |= get_unaligned_le32(data) == PKT_BIN_DEBUG_MAGIC;
+#endif
 
-	if (dev->relay_fwlog)
-		mt7996_debugfs_write_fwlog(dev, NULL, 0, data, len);
+	if (is_fwlog) {
+		if (dev->relay_fwlog)
+			mt7996_debugfs_write_fwlog(dev, NULL, 0, data, len);
+	} else if (dev->relay_idxlog)
+		mt7996_debugfs_write_idxlog(dev, data, len);
+	else
+		return false;
 
 	return true;
 }
@@ -945,6 +1283,7 @@ static ssize_t mt7996_sta_fixed_rate_set(struct file *file,
 #define LONG_PREAMBLE 1
 	struct ieee80211_sta *sta = file->private_data;
 	struct mt7996_sta *msta = (struct mt7996_sta *)sta->drv_priv;
+	struct mt7996_link_sta *mlink = &msta->deflink;
 	struct mt7996_dev *dev = msta->vif->deflink.phy->dev;
 	struct ra_rate phy = {};
 	char buf[100];
@@ -980,7 +1319,7 @@ static ssize_t mt7996_sta_fixed_rate_set(struct file *file,
 		goto out;
 	}
 
-	phy.wlan_idx = cpu_to_le16(msta->wcid.idx);
+	phy.wlan_idx = cpu_to_le16(mlink->wcid.idx);
 	phy.gi = cpu_to_le16(gi);
 	phy.ltf = cpu_to_le16(ltf);
 	phy.ldpc = phy.ldpc ? 7 : 0;
@@ -1013,11 +1352,328 @@ mt7996_queues_show(struct seq_file *s, void *data)
 
 DEFINE_SHOW_ATTRIBUTE(mt7996_queues);
 
+static int
+mt7996_sta_links_info_show(struct seq_file *s, void *data)
+{
+	struct ieee80211_sta *sta = s->private;
+	struct mt7996_sta *msta = (struct mt7996_sta *)sta->drv_priv;
+	u64 tx_cnt = 0, tx_fails = 0, tx_retries = 0, rx_cnt = 0;
+	struct mt7996_dev *dev = msta->vif->dev;
+	unsigned long valid_links;
+	u8 link_id;
+
+	seq_printf(s, "primary link, link ID = %d\n", msta->pri_link);
+	seq_printf(s, "secondary link, link ID = %d\n", msta->sec_link);
+	seq_printf(s, "valid links = 0x%x\n", sta->valid_links);
+
+	mutex_lock(&dev->mt76.mutex);
+	valid_links = sta->valid_links ?: BIT(0);
+	for_each_set_bit(link_id, &valid_links, IEEE80211_MLD_MAX_NUM_LINKS) {
+		struct mt7996_link_sta *mlink =
+			mlink_dereference_protected(msta, link_id);
+		struct mt76_wcid *wcid;
+
+		if (!mlink)
+			continue;
+
+		wcid = &mlink->wcid;
+
+		tx_cnt += wcid->stats.tx_packets;
+		tx_fails += wcid->stats.tx_packets_failed;
+		tx_retries += wcid->stats.tx_packets_retried;
+		rx_cnt += wcid->stats.rx_packets;
+
+		seq_printf(s, "link%d: wcid=%d, phy=%d, link_valid=%d\n",
+			    wcid->link_id, wcid->idx, wcid->phy_idx, wcid->link_valid);
+	}
+	mutex_unlock(&dev->mt76.mutex);
+
+	/* PER may be imprecise, because MSDU total and failed counts
+	 * are updated at different times.
+	 */
+	seq_printf(s, "TX MSDU Count: %llu\n", tx_cnt);
+	seq_printf(s, "TX MSDU Fails: %llu (PER: %llu.%llu%%)\n", tx_fails,
+		   tx_cnt ? tx_fails * 1000 / tx_cnt / 10 : 0,
+		   tx_cnt ? tx_fails * 1000 / tx_cnt % 10 : 0);
+	seq_printf(s, "TX MSDU Retries: %llu\n", tx_retries);
+	seq_printf(s, "RX MSDU Count: %llu\n", rx_cnt);
+
+	return 0;
+}
+DEFINE_SHOW_ATTRIBUTE(mt7996_sta_links_info);
+
 void mt7996_sta_add_debugfs(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 			    struct ieee80211_sta *sta, struct dentry *dir)
 {
 	debugfs_create_file("fixed_rate", 0600, dir, sta, &fops_fixed_rate);
 	debugfs_create_file("hw-queues", 0400, dir, sta, &mt7996_queues_fops);
+	debugfs_create_file("mt76_links_info", 0400, dir, sta,
+			    &mt7996_sta_links_info_fops);
+}
+
+static int
+mt7996_vif_links_info_show(struct seq_file *s, void *data)
+{
+	struct ieee80211_vif *vif = s->private;
+	struct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;
+	struct mt7996_dev *dev = mvif->dev;
+	struct mt7996_bss_conf *mconf;
+	struct mt7996_link_sta *mlink;
+	unsigned long valid_links;
+	u8 link_id, i;
+
+	static const char* width_to_bw[] = {
+		[NL80211_CHAN_WIDTH_40] = "40",
+		[NL80211_CHAN_WIDTH_80] = "80",
+		[NL80211_CHAN_WIDTH_80P80] = "80+80",
+		[NL80211_CHAN_WIDTH_160] = "160",
+		[NL80211_CHAN_WIDTH_5] = "5",
+		[NL80211_CHAN_WIDTH_10] = "10",
+		[NL80211_CHAN_WIDTH_20] = "20",
+		[NL80211_CHAN_WIDTH_20_NOHT] = "20_NOHT",
+		[NL80211_CHAN_WIDTH_320] = "320",
+	};
+
+	seq_printf(s, "master link id = %d\n", mvif->master_link_id);
+	seq_printf(s, "group mld id = %d\n", mvif->group_mld_id);
+	seq_printf(s, "mld remap id = %d\n", mvif->mld_remap_id);
+
+	seq_printf(s, "valid links = 0x%x\n", vif->valid_links);
+	for (i = 0; i < __MT_MAX_BAND; i++)
+		seq_printf(s, "band%d_link_id = %d\n", i, mvif->band_to_link[i]);
+
+	mutex_lock(&dev->mt76.mutex);
+	valid_links = vif->valid_links ?: BIT(0);
+	for_each_set_bit(link_id, &valid_links, IEEE80211_MLD_MAX_NUM_LINKS) {
+		mconf = mconf_dereference_protected(mvif, link_id);
+		mlink = mlink_dereference_protected(&mvif->sta, link_id);
+
+		if (!mconf || !mlink)
+			continue;
+
+		seq_printf(s, "- link[%02d]: bss_idx = %d, wcid = %d\n",
+			   mconf->link_id, mconf->mt76.idx, mlink->wcid.idx);
+		seq_printf(s, "            omac_idx = %d, own_mld_id=%d\n",
+			   mconf->mt76.omac_idx, mconf->own_mld_id);
+
+		if (!mconf->phy->chanctx)
+			continue;
+
+		seq_printf(s, "            band_idx=%d, channel=%d, bw%s\n",
+			   mconf->mt76.band_idx,
+			   mconf->phy->chanctx->chandef.chan->hw_value,
+			   width_to_bw[mconf->phy->chanctx->chandef.width]);
+	}
+	mutex_unlock(&dev->mt76.mutex);
+
+	return 0;
+}
+DEFINE_SHOW_ATTRIBUTE(mt7996_vif_links_info);
+
+void mt7996_vif_add_debugfs(struct ieee80211_hw *hw, struct ieee80211_vif *vif)
+{
+	debugfs_create_file("mt76_links_info", 0400, vif->debugfs_dir, vif,
+			    &mt7996_vif_links_info_fops);
 }
 
+static void
+mt7996_parse_rate(struct rate_info *rate, char *buf, size_t size)
+{
+	u32 bitrate = cfg80211_calculate_bitrate(rate);
+	bool legacy = false;
+	char *pos = buf;
+	enum {
+		GI_0_4,
+		GI_0_8,
+		GI_1_6,
+		GI_3_2
+	} gi = GI_0_8;
+
+	pos += snprintf(pos, size - (pos - buf), "%u.%u Mbit/s",
+			bitrate / 10, bitrate % 10);
+
+	if (rate->flags & RATE_INFO_FLAGS_MCS) {
+		pos += snprintf(pos, size - (pos - buf), " HT");
+
+		if (rate->flags & RATE_INFO_FLAGS_SHORT_GI)
+			gi = GI_0_4;
+	} else if (rate->flags & RATE_INFO_FLAGS_VHT_MCS) {
+		pos += snprintf(pos, size - (pos - buf), " VHT");
+
+		if (rate->flags & RATE_INFO_FLAGS_SHORT_GI)
+			gi = GI_0_4;
+	} else if (rate->flags & RATE_INFO_FLAGS_HE_MCS) {
+		pos += snprintf(pos, size - (pos - buf), " HE");
+
+		if (rate->he_gi == NL80211_RATE_INFO_HE_GI_1_6)
+			gi = GI_1_6;
+		else if (rate->he_gi == NL80211_RATE_INFO_HE_GI_3_2)
+			gi = GI_3_2;
+	} else if (rate->flags & RATE_INFO_FLAGS_EHT_MCS) {
+		pos += snprintf(pos, size - (pos - buf), " EHT");
+
+		if (rate->eht_gi == NL80211_RATE_INFO_EHT_GI_1_6)
+			gi = GI_1_6;
+		else if (rate->eht_gi == NL80211_RATE_INFO_EHT_GI_3_2)
+			gi = GI_3_2;
+	} else {
+		pos += snprintf(pos, size - (pos - buf), " Legacy");
+		legacy = true;
+	}
+
+	switch (rate->bw) {
+	case RATE_INFO_BW_20:
+		pos += snprintf(pos, size - (pos - buf), " 20MHz");
+		break;
+	case RATE_INFO_BW_40:
+		pos += snprintf(pos, size - (pos - buf), " 40MHz");
+		break;
+	case RATE_INFO_BW_80:
+		pos += snprintf(pos, size - (pos - buf), " 80MHz");
+		break;
+	case RATE_INFO_BW_160:
+		pos += snprintf(pos, size - (pos - buf), " 160MHz");
+		break;
+	case RATE_INFO_BW_320:
+		pos += snprintf(pos, size - (pos - buf), " 320MHz");
+		break;
+	case RATE_INFO_BW_HE_RU:
+		if (rate->he_ru_alloc == NL80211_RATE_INFO_HE_RU_ALLOC_106) {
+			pos += snprintf(pos, size - (pos - buf), " 106-tone RU");
+			break;
+		}
+		fallthrough;
+	default:
+		pos += snprintf(pos, size - (pos - buf), " (Unknown BW)");
+	}
+
+	if (!legacy) {
+		pos += snprintf(pos, size - (pos - buf), " MCS %hhu", rate->mcs);
+		pos += snprintf(pos, size - (pos - buf), " NSS %hhu", rate->nss);
+	}
+
+	switch (gi) {
+	case GI_0_4:
+		pos += snprintf(pos, size - (pos - buf), " GI 0.4us");
+		break;
+	case GI_0_8:
+		pos += snprintf(pos, size - (pos - buf), " GI 0.8us");
+		break;
+	case GI_1_6:
+		pos += snprintf(pos, size - (pos - buf), " GI 1.6us");
+		break;
+	default:
+		pos += snprintf(pos, size - (pos - buf), " GI 3.2us");
+		break;
+	}
+}
+
+static int
+mt7996_link_sta_info_show(struct seq_file *file, void *data)
+{
+	struct ieee80211_link_sta *link_sta = file->private;
+	struct mt7996_sta *msta = (struct mt7996_sta *)link_sta->sta->drv_priv;
+	struct mt7996_link_sta *mlink;
+	struct mt76_sta_stats *stats;
+	struct mt76_wcid *wcid;
+	char buf[100];
+
+	mutex_lock(&msta->vif->dev->mt76.mutex);
+
+	mlink = mlink_dereference_protected(msta, link_sta->link_id);
+	if (!mlink) {
+		mutex_unlock(&msta->vif->dev->mt76.mutex);
+		return -EINVAL;
+	}
+	wcid = &mlink->wcid;
+	stats = &wcid->stats;
+
+	seq_printf(file, "WCID: %hu\n", wcid->idx);
+	seq_printf(file, "Link ID: %hhu\n", link_sta->link_id);
+	seq_printf(file, "Link Address: %pM\n", link_sta->addr);
+	seq_printf(file, "Status:\n");
+	seq_printf(file, "\tRSSI: %d [%hhd, %hhd, %hhd, %hhd] dBm\n",
+		   mlink->signal, mlink->chain_signal[0], mlink->chain_signal[1],
+		   mlink->chain_signal[2], mlink->chain_signal[3]);
+	seq_printf(file, "\tACK RSSI: %d [%hhd, %hhd, %hhd, %hhd] dBm\n",
+		   mlink->ack_signal, mlink->chain_ack_signal[0],
+		   mlink->chain_ack_signal[1], mlink->chain_ack_signal[2],
+		   mlink->chain_ack_signal[3]);
+	seq_printf(file, "\tACK SNR: [%hhd, %hhd, %hhd, %hhd] dBm\n",
+		   mlink->chain_ack_snr[0], mlink->chain_ack_snr[1],
+		   mlink->chain_ack_snr[2], mlink->chain_ack_snr[3]);
+	seq_printf(file, "Rate:\n");
+
+	mt7996_parse_rate(&wcid->rate, buf, sizeof(buf));
+	seq_printf(file, "\tTX: %s\n", buf);
+	mt7996_parse_rate(&wcid->rx_rate, buf, sizeof(buf));
+	seq_printf(file, "\tRX: %s\n", buf);
+
+	seq_printf(file, "Statistics:\n");
+	seq_printf(file, "\tTX:\n");
+	seq_printf(file, "\t\tBytes: %llu\n", stats->tx_bytes);
+	seq_printf(file, "\t\tMPDU Count: %u\n", stats->tx_mpdus);
+	seq_printf(file, "\t\tMPDU Fails: %u (PER: %u.%u%%)\n", stats->tx_failed,
+		   stats->tx_mpdus ? stats->tx_failed * 1000 / stats->tx_mpdus / 10 : 0,
+		   stats->tx_mpdus ? stats->tx_failed * 1000 / stats->tx_mpdus % 10 : 0);
+	seq_printf(file, "\t\tMPDU Retries: %u\n", stats->tx_retries);
+	seq_printf(file, "\t\tAirtime: %llu (unit: 1.024 us)\n", stats->tx_airtime);
+	seq_printf(file, "\tRX:\n");
+	seq_printf(file, "\t\tBytes: %llu\n", stats->rx_bytes);
+	seq_printf(file, "\t\tMPDU Count: %u\n", stats->rx_mpdus);
+	seq_printf(file, "\t\tMPDU FCS Errors: %u (PER: %u.%u%%)\n", stats->rx_fcs_err,
+		   stats->rx_mpdus ? stats->rx_fcs_err * 1000 / stats->rx_mpdus / 10 : 0,
+		   stats->rx_mpdus ? stats->rx_fcs_err * 1000 / stats->rx_mpdus % 10 : 0);
+	seq_printf(file, "\t\tAirtime: %llu (unit: 1.024 us)\n", stats->rx_airtime);
+
+	mutex_unlock(&msta->vif->dev->mt76.mutex);
+
+	return 0;
+}
+DEFINE_SHOW_ATTRIBUTE(mt7996_link_sta_info);
+
+void mt7996_link_sta_add_debugfs(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
+				 struct ieee80211_link_sta *link_sta,
+				 struct dentry *dir)
+{
+	debugfs_create_file("link_sta_info", 0400, dir, link_sta,
+			    &mt7996_link_sta_info_fops);
+}
+
+static int
+mt7996_link_info_show(struct seq_file *file, void *data)
+{
+	struct ieee80211_bss_conf *conf = file->private;
+	struct mt7996_vif *mvif = (struct mt7996_vif *)conf->vif->drv_priv;
+	struct mt7996_sta *msta = &mvif->sta;
+	struct mt7996_bss_conf *mconf;
+	struct mt7996_link_sta *mlink;
+	struct mt7996_dev *dev = mvif->dev;
+	struct rate_info *r;
+
+	mutex_lock(&dev->mt76.mutex);
+
+	mconf = mconf_dereference_protected(mvif, conf->link_id);
+	mlink = mlink_dereference_protected(msta, conf->link_id);
+	if (!mconf || !mlink) {
+		mutex_unlock(&dev->mt76.mutex);
+		return -EINVAL;
+	}
+
+	r = &mlink->wcid.rate;
+	seq_printf(file, "band mapping=%u\n", mconf->phy->mt76->band_idx);
+	seq_printf(file, "tx rate: flags=0x%x,legacy=%u,mcs=%u,nss=%u,bw=%u,he_gi=%u,he_dcm=%u,he_ru_alloc=%u,eht_gi=%u,eht_ru_alloc=%u\n",
+		   r->flags, r->legacy, r->mcs, r->nss, r->bw, r->he_gi, r->he_dcm, r->he_ru_alloc, r->eht_gi, r->eht_ru_alloc);
+
+	mutex_unlock(&dev->mt76.mutex);
+
+	return 0;
+}
+DEFINE_SHOW_ATTRIBUTE(mt7996_link_info);
+
+void mt7996_link_add_debugfs(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
+			     struct ieee80211_bss_conf *link_conf, struct dentry *dir)
+{
+	debugfs_create_file("link_info", 0600, dir, link_conf, &mt7996_link_info_fops);
+}
 #endif
diff --git a/mt7996/dma.c b/mt7996/dma.c
index 73e633d0..bec7286f 100644
--- a/mt7996/dma.c
+++ b/mt7996/dma.c
@@ -12,12 +12,20 @@ int mt7996_init_tx_queues(struct mt7996_phy *phy, int idx, int n_desc,
 {
 	struct mt7996_dev *dev = phy->dev;
 	u32 flags = 0;
+	int i;
+
+	if (phy->mt76->band_idx == MT_BAND1 && !dev->hif2 && is_mt7996(&dev->mt76)) {
+		phy->mt76->q_tx[0] = phy->mt76->dev->phys[MT_BAND0]->q_tx[0];
+		for (i = 1; i <= MT_TXQ_PSD; i++)
+			phy->mt76->q_tx[i] = phy->mt76->q_tx[0];
+		return 0;
+	}
 
 	if (mtk_wed_device_active(wed)) {
 		ring_base += MT_TXQ_ID(0) * MT_RING_SIZE;
 		idx -= MT_TXQ_ID(0);
 
-		if (phy->mt76->band_idx == MT_BAND2)
+		if (wed == &dev->mt76.mmio.wed_hif2)
 			flags = MT_WED_Q_TX(0);
 		else
 			flags = MT_WED_Q_TX(idx);
@@ -77,30 +85,55 @@ static void mt7996_dma_config(struct mt7996_dev *dev)
 			   MT7996_RXQ_RRO_BAND0);
 		RXQ_CONFIG(MT_RXQ_MSDU_PAGE_BAND0, WFDMA0, MT_INT_RX_DONE_MSDU_PG_BAND0,
 			   MT7996_RXQ_MSDU_PG_BAND0);
-		RXQ_CONFIG(MT_RXQ_TXFREE_BAND0, WFDMA0, MT_INT_RX_TXFREE_MAIN,
-			   MT7996_RXQ_TXFREE0);
-		/* band1 */
-		RXQ_CONFIG(MT_RXQ_MSDU_PAGE_BAND1, WFDMA0, MT_INT_RX_DONE_MSDU_PG_BAND1,
-			   MT7996_RXQ_MSDU_PG_BAND1);
-		/* band2 */
-		RXQ_CONFIG(MT_RXQ_RRO_BAND2, WFDMA0, MT_INT_RX_DONE_RRO_BAND2,
-			   MT7996_RXQ_RRO_BAND2);
-		RXQ_CONFIG(MT_RXQ_MSDU_PAGE_BAND2, WFDMA0, MT_INT_RX_DONE_MSDU_PG_BAND2,
-			   MT7996_RXQ_MSDU_PG_BAND2);
-		RXQ_CONFIG(MT_RXQ_TXFREE_BAND2, WFDMA0, MT_INT_RX_TXFREE_TRI,
-			   MT7996_RXQ_TXFREE2);
+		if (is_mt7996(&dev->mt76)) {
+			RXQ_CONFIG(MT_RXQ_TXFREE_BAND0, WFDMA0, MT_INT_RX_TXFREE_MAIN,
+				   MT7996_RXQ_TXFREE0);
+			/* band1 */
+			RXQ_CONFIG(MT_RXQ_MSDU_PAGE_BAND1, WFDMA0, MT_INT_RX_DONE_MSDU_PG_BAND1,
+				   MT7996_RXQ_MSDU_PG_BAND1);
+			/* band2 */
+			RXQ_CONFIG(MT_RXQ_RRO_BAND2, WFDMA0, MT_INT_RX_DONE_RRO_BAND2,
+				   MT7996_RXQ_RRO_BAND2);
+			RXQ_CONFIG(MT_RXQ_MSDU_PAGE_BAND2, WFDMA0, MT_INT_RX_DONE_MSDU_PG_BAND2,
+				   MT7996_RXQ_MSDU_PG_BAND2);
+			RXQ_CONFIG(MT_RXQ_TXFREE_BAND2, WFDMA0, MT_INT_RX_TXFREE_TRI,
+				   MT7996_RXQ_TXFREE2);
+		} else {
+			RXQ_CONFIG(MT_RXQ_RRO_BAND1, WFDMA0, MT_INT_RX_DONE_RRO_BAND1,
+				   MT7996_RXQ_RRO_BAND1);
+		}
 
 		RXQ_CONFIG(MT_RXQ_RRO_IND, WFDMA0, MT_INT_RX_DONE_RRO_IND,
 			   MT7996_RXQ_RRO_IND);
 	}
 
 	/* data tx queue */
-	TXQ_CONFIG(0, WFDMA0, MT_INT_TX_DONE_BAND0, MT7996_TXQ_BAND0);
 	if (is_mt7996(&dev->mt76)) {
-		TXQ_CONFIG(1, WFDMA0, MT_INT_TX_DONE_BAND1, MT7996_TXQ_BAND1);
-		TXQ_CONFIG(2, WFDMA0, MT_INT_TX_DONE_BAND2, MT7996_TXQ_BAND2);
+		TXQ_CONFIG(0, WFDMA0, MT_INT_TX_DONE_BAND0, MT7996_TXQ_BAND0);
+		if (dev->hif2) {
+			if (dev->option_type == 2) {
+				/*  bn1:ring21 bn2:ring19 */
+				TXQ_CONFIG(1, WFDMA0, MT_INT_TX_DONE_BAND2, MT7996_TXQ_BAND2);
+				TXQ_CONFIG(2, WFDMA0, MT_INT_TX_DONE_BAND1, MT7996_TXQ_BAND1);
+			} else {
+				/* default bn1:ring19 bn2:ring21 */
+				TXQ_CONFIG(1, WFDMA0, MT_INT_TX_DONE_BAND1, MT7996_TXQ_BAND1);
+				TXQ_CONFIG(2, WFDMA0, MT_INT_TX_DONE_BAND2, MT7996_TXQ_BAND2);
+			}
+		} else {
+			/* single pcie bn0/1:ring18 bn2:ring19 */
+			TXQ_CONFIG(2, WFDMA0, MT_INT_TX_DONE_BAND1, MT7996_TXQ_BAND1);
+		}
 	} else {
-		TXQ_CONFIG(1, WFDMA0, MT_INT_TX_DONE_BAND1, MT7996_TXQ_BAND1);
+		if (dev->hif2) {
+			/*  bn0:ring18 bn1:ring21 */
+			TXQ_CONFIG(0, WFDMA0, MT_INT_TX_DONE_BAND0, MT7996_TXQ_BAND0);
+			TXQ_CONFIG(1, WFDMA0, MT_INT_TX_DONE_BAND2, MT7996_TXQ_BAND2);
+		} else {
+			/* single pcie bn0:ring18 bn1:ring19 */
+			TXQ_CONFIG(0, WFDMA0, MT_INT_TX_DONE_BAND0, MT7996_TXQ_BAND0);
+			TXQ_CONFIG(1, WFDMA0, MT_INT_TX_DONE_BAND1, MT7996_TXQ_BAND1);
+		}
 	}
 
 	/* mcu tx queue */
@@ -146,8 +179,13 @@ static void __mt7996_dma_prefetch(struct mt7996_dev *dev, u32 ofs)
 	if (dev->has_rro) {
 		mt76_wr(dev, MT_RXQ_BAND1_CTRL(MT_RXQ_RRO_BAND0) + ofs,
 			PREFETCH(0x10));
-		mt76_wr(dev, MT_RXQ_BAND1_CTRL(MT_RXQ_RRO_BAND2) + ofs,
-			PREFETCH(0x10));
+		if (is_mt7996(&dev->mt76))
+			mt76_wr(dev, MT_RXQ_BAND1_CTRL(MT_RXQ_RRO_BAND2) + ofs,
+				PREFETCH(0x10));
+		else
+			mt76_wr(dev, MT_RXQ_BAND1_CTRL(MT_RXQ_RRO_BAND1) + ofs,
+				PREFETCH(0x10));
+
 		mt76_wr(dev, MT_RXQ_BAND1_CTRL(MT_RXQ_MSDU_PAGE_BAND0) + ofs,
 			PREFETCH(0x4));
 		mt76_wr(dev, MT_RXQ_BAND1_CTRL(MT_RXQ_MSDU_PAGE_BAND1) + ofs,
@@ -255,8 +293,11 @@ void mt7996_dma_start(struct mt7996_dev *dev, bool reset, bool wed_reset)
 	if (mt7996_band_valid(dev, MT_BAND0))
 		irq_mask |= MT_INT_BAND0_RX_DONE;
 
-	if (mt7996_band_valid(dev, MT_BAND1))
+	if (mt7996_band_valid(dev, MT_BAND1)) {
 		irq_mask |= MT_INT_BAND1_RX_DONE;
+		if (is_mt7992(&dev->mt76) && dev->hif2)
+			irq_mask |= MT_INT_RX_TXFREE_BAND1_EXT;
+	}
 
 	if (mt7996_band_valid(dev, MT_BAND2))
 		irq_mask |= MT_INT_BAND2_RX_DONE;
@@ -342,13 +383,60 @@ static void mt7996_dma_enable(struct mt7996_dev *dev, bool reset)
 			 WF_WFDMA0_GLO_CFG_EXT1_TX_FCTRL_MODE);
 
 		mt76_set(dev, MT_WFDMA_HOST_CONFIG,
-			 MT_WFDMA_HOST_CONFIG_PDMA_BAND |
-			 MT_WFDMA_HOST_CONFIG_BAND2_PCIE1);
+			 MT_WFDMA_HOST_CONFIG_PDMA_BAND);
+
+		mt76_clear(dev, MT_WFDMA_HOST_CONFIG,
+			   MT_WFDMA_HOST_CONFIG_BAND0_PCIE1 |
+			   MT_WFDMA_HOST_CONFIG_BAND1_PCIE1 |
+			   MT_WFDMA_HOST_CONFIG_BAND2_PCIE1);
+
+		switch (dev->option_type) {
+		case 2:
+			/* eagle + 7988d */
+			if (is_mt7996(&dev->mt76))
+				mt76_set(dev, MT_WFDMA_HOST_CONFIG,
+					 MT_WFDMA_HOST_CONFIG_BAND0_PCIE1 |
+					 MT_WFDMA_HOST_CONFIG_BAND1_PCIE1);
+			else
+				mt76_set(dev, MT_WFDMA_HOST_CONFIG,
+					 MT_WFDMA_HOST_CONFIG_BAND1_PCIE1);
+			break;
+		case 3:
+			mt76_set(dev, MT_WFDMA_HOST_CONFIG,
+				 MT_WFDMA_HOST_CONFIG_BAND0_PCIE1);
+
+			break;
+		default:
+			if (is_mt7996(&dev->mt76))
+				mt76_set(dev, MT_WFDMA_HOST_CONFIG,
+					 MT_WFDMA_HOST_CONFIG_BAND2_PCIE1);
+			else
+				mt76_set(dev, MT_WFDMA_HOST_CONFIG,
+					 MT_WFDMA_HOST_CONFIG_BAND1_PCIE1);
+			break;
+		}
 
 		/* AXI read outstanding number */
 		mt76_rmw(dev, MT_WFDMA_AXI_R2A_CTRL,
 			 MT_WFDMA_AXI_R2A_CTRL_OUTSTAND_MASK, 0x14);
 
+		if (dev->hif2->speed < PCIE_SPEED_5_0GT ||
+		    (dev->hif2->speed == PCIE_SPEED_5_0GT && dev->hif2->width < 2)) {
+			mt76_rmw(dev, WF_WFDMA0_GLO_CFG_EXT0 + hif1_ofs,
+				 WF_WFDMA0_GLO_CFG_EXT0_OUTSTAND_MASK,
+				 FIELD_PREP(WF_WFDMA0_GLO_CFG_EXT0_OUTSTAND_MASK, 0x1));
+			mt76_rmw(dev, MT_WFDMA_AXI_R2A_CTRL2,
+				 MT_WFDMA_AXI_R2A_CTRL2_OUTSTAND_MASK,
+				 FIELD_PREP(MT_WFDMA_AXI_R2A_CTRL2_OUTSTAND_MASK, 0x1));
+		} else if (dev->hif2->speed < PCIE_SPEED_8_0GT ||
+			   (dev->hif2->speed == PCIE_SPEED_8_0GT && dev->hif2->width < 2)) {
+			mt76_rmw(dev, WF_WFDMA0_GLO_CFG_EXT0 + hif1_ofs,
+				 WF_WFDMA0_GLO_CFG_EXT0_OUTSTAND_MASK,
+				 FIELD_PREP(WF_WFDMA0_GLO_CFG_EXT0_OUTSTAND_MASK, 0x2));
+			mt76_rmw(dev, MT_WFDMA_AXI_R2A_CTRL2,
+				 MT_WFDMA_AXI_R2A_CTRL2_OUTSTAND_MASK,
+				 FIELD_PREP(MT_WFDMA_AXI_R2A_CTRL2_OUTSTAND_MASK, 0x2));
+		}
 		/* WFDMA rx threshold */
 		mt76_wr(dev, MT_WFDMA0_PAUSE_RX_Q_45_TH + hif1_ofs, 0xc000c);
 		mt76_wr(dev, MT_WFDMA0_PAUSE_RX_Q_67_TH + hif1_ofs, 0x10008);
@@ -361,12 +449,17 @@ static void mt7996_dma_enable(struct mt7996_dev *dev, bool reset)
 		 * so, redirect pcie0 rx ring3 interrupt to pcie1
 		 */
 		if (mtk_wed_device_active(&dev->mt76.mmio.wed) &&
-		    dev->has_rro)
+		    dev->has_rro) {
+			u32 intr = is_mt7996(&dev->mt76) ?
+				   MT_WFDMA0_RX_INT_SEL_RING6 :
+				   MT_WFDMA0_RX_INT_SEL_RING9 |
+				   MT_WFDMA0_RX_INT_SEL_RING5;
 			mt76_set(dev, MT_WFDMA0_RX_INT_PCIE_SEL + hif1_ofs,
-				 MT_WFDMA0_RX_INT_SEL_RING6);
-		else
+				 intr);
+		} else {
 			mt76_set(dev, MT_WFDMA0_RX_INT_PCIE_SEL,
 				 MT_WFDMA0_RX_INT_SEL_RING3);
+		}
 	}
 
 	mt7996_dma_start(dev, reset, true);
@@ -401,7 +494,7 @@ int mt7996_dma_rro_init(struct mt7996_dev *dev)
 	if (ret)
 		return ret;
 
-	if (mt7996_band_valid(dev, MT_BAND1)) {
+	if (mt7996_band_valid(dev, MT_BAND1) && is_mt7996(&dev->mt76)) {
 		/* rx msdu page queue for band1 */
 		mdev->q_rx[MT_RXQ_MSDU_PAGE_BAND1].flags =
 			MT_WED_RRO_Q_MSDU_PG(1) | MT_QFLAG_WED_RRO_EN;
@@ -522,7 +615,9 @@ int mt7996_dma_init(struct mt7996_dev *dev)
 		return ret;
 
 	/* tx free notify event from WA for band0 */
-	if (mtk_wed_device_active(wed) && !dev->has_rro) {
+	if (mtk_wed_device_active(wed) &&
+	    ((is_mt7996(&dev->mt76) && !dev->has_rro) ||
+	     (is_mt7992(&dev->mt76)))) {
 		dev->mt76.q_rx[MT_RXQ_MAIN_WA].flags = MT_WED_Q_TXFREE;
 		dev->mt76.q_rx[MT_RXQ_MAIN_WA].wed = wed;
 	}
@@ -538,6 +633,10 @@ int mt7996_dma_init(struct mt7996_dev *dev)
 	if (mt7996_band_valid(dev, MT_BAND2)) {
 		/* rx data queue for mt7996 band2 */
 		rx_base = MT_RXQ_RING_BASE(MT_RXQ_BAND2) + hif1_ofs;
+		if (mtk_wed_device_active(wed_hif2) && mtk_wed_get_rx_capa(wed_hif2)) {
+			dev->mt76.q_rx[MT_RXQ_BAND2].flags = MT_WED_Q_RX(0);
+			dev->mt76.q_rx[MT_RXQ_BAND2].wed = wed_hif2;
+		}
 		ret = mt76_queue_alloc(dev, &dev->mt76.q_rx[MT_RXQ_BAND2],
 				       MT_RXQ_ID(MT_RXQ_BAND2),
 				       MT7996_RX_RING_SIZE,
@@ -564,6 +663,11 @@ int mt7996_dma_init(struct mt7996_dev *dev)
 	} else if (mt7996_band_valid(dev, MT_BAND1)) {
 		/* rx data queue for mt7992 band1 */
 		rx_base = MT_RXQ_RING_BASE(MT_RXQ_BAND1) + hif1_ofs;
+		if (mtk_wed_device_active(wed) && mtk_wed_get_rx_capa(wed)) {
+			dev->mt76.q_rx[MT_RXQ_BAND1].flags = MT_WED_Q_RX(1);
+			dev->mt76.q_rx[MT_RXQ_BAND1].wed = wed;
+		}
+
 		ret = mt76_queue_alloc(dev, &dev->mt76.q_rx[MT_RXQ_BAND1],
 				       MT_RXQ_ID(MT_RXQ_BAND1),
 				       MT7996_RX_RING_SIZE,
@@ -574,6 +678,10 @@ int mt7996_dma_init(struct mt7996_dev *dev)
 
 		/* tx free notify event from WA for mt7992 band1 */
 		rx_base = MT_RXQ_RING_BASE(MT_RXQ_BAND1_WA) + hif1_ofs;
+		if (mtk_wed_device_active(wed_hif2)) {
+			dev->mt76.q_rx[MT_RXQ_BAND1_WA].flags = MT_WED_Q_TXFREE;
+			dev->mt76.q_rx[MT_RXQ_BAND1_WA].wed = wed_hif2;
+		}
 		ret = mt76_queue_alloc(dev, &dev->mt76.q_rx[MT_RXQ_BAND1_WA],
 				       MT_RXQ_ID(MT_RXQ_BAND1_WA),
 				       MT7996_RX_MCU_RING_SIZE,
@@ -597,17 +705,30 @@ int mt7996_dma_init(struct mt7996_dev *dev)
 		if (ret)
 			return ret;
 
-		/* tx free notify event from WA for band0 */
-		dev->mt76.q_rx[MT_RXQ_TXFREE_BAND0].flags = MT_WED_Q_TXFREE;
-		dev->mt76.q_rx[MT_RXQ_TXFREE_BAND0].wed = wed;
+		if (is_mt7992(&dev->mt76)) {
+			dev->mt76.q_rx[MT_RXQ_RRO_BAND1].flags =
+				MT_WED_RRO_Q_DATA(1) | MT_QFLAG_WED_RRO_EN;
+			dev->mt76.q_rx[MT_RXQ_RRO_BAND1].wed = wed;
+			ret = mt76_queue_alloc(dev, &dev->mt76.q_rx[MT_RXQ_RRO_BAND1],
+					       MT_RXQ_ID(MT_RXQ_RRO_BAND1),
+					       MT7996_RX_RING_SIZE,
+					       MT7996_RX_BUF_SIZE,
+					       MT_RXQ_RING_BASE(MT_RXQ_RRO_BAND1) + hif1_ofs);
+			if (ret)
+				return ret;
+		} else {
+			/* tx free notify event from WA for band0 */
+			dev->mt76.q_rx[MT_RXQ_TXFREE_BAND0].flags = MT_WED_Q_TXFREE;
+			dev->mt76.q_rx[MT_RXQ_TXFREE_BAND0].wed = wed;
 
-		ret = mt76_queue_alloc(dev, &dev->mt76.q_rx[MT_RXQ_TXFREE_BAND0],
-				       MT_RXQ_ID(MT_RXQ_TXFREE_BAND0),
-				       MT7996_RX_MCU_RING_SIZE,
-				       MT7996_RX_BUF_SIZE,
-				       MT_RXQ_RING_BASE(MT_RXQ_TXFREE_BAND0));
-		if (ret)
-			return ret;
+			ret = mt76_queue_alloc(dev, &dev->mt76.q_rx[MT_RXQ_TXFREE_BAND0],
+					       MT_RXQ_ID(MT_RXQ_TXFREE_BAND0),
+					       MT7996_RX_MCU_RING_SIZE,
+					       MT7996_RX_BUF_SIZE,
+					       MT_RXQ_RING_BASE(MT_RXQ_TXFREE_BAND0));
+			if (ret)
+				return ret;
+		}
 
 		if (mt7996_band_valid(dev, MT_BAND2)) {
 			/* rx rro data queue for band2 */
@@ -679,11 +800,23 @@ void mt7996_dma_reset(struct mt7996_dev *dev, bool force)
 	for (i = 0; i < __MT_MCUQ_MAX; i++)
 		mt76_queue_tx_cleanup(dev, dev->mt76.q_mcu[i], true);
 
+	if (!force)
+		dev_info(dev->mt76.dev,"%s L1 SER tx queue clean up done.",
+			 wiphy_name(dev->mt76.hw->wiphy));
+
 	mt76_for_each_q_rx(&dev->mt76, i)
 		mt76_queue_rx_cleanup(dev, &dev->mt76.q_rx[i]);
 
+	if (!force)
+		dev_info(dev->mt76.dev,"%s L1 SER rx queue clean up done.",
+			 wiphy_name(dev->mt76.hw->wiphy));
+
 	mt76_tx_status_check(&dev->mt76, true);
 
+	if (!force)
+		dev_info(dev->mt76.dev,"%s L1 SER mt76_tx_status_check done.",
+			 wiphy_name(dev->mt76.hw->wiphy));
+
 	/* reset wfsys */
 	if (force)
 		mt7996_wfsys_reset(dev);
@@ -694,7 +827,15 @@ void mt7996_dma_reset(struct mt7996_dev *dev, bool force)
 	if (mtk_wed_device_active(&dev->mt76.mmio.wed))
 		mtk_wed_device_dma_reset(&dev->mt76.mmio.wed);
 
+	if (!force)
+		dev_info(dev->mt76.dev,"%s L1 SER wed dma reset done.",
+			 wiphy_name(dev->mt76.hw->wiphy));
+
 	mt7996_dma_disable(dev, force);
+
+	if (!force)
+		dev_info(dev->mt76.dev,"%s L1 SER dma disable done.",
+			 wiphy_name(dev->mt76.hw->wiphy));
 	mt76_wed_dma_reset(&dev->mt76);
 
 	/* reset hw queues */
@@ -706,24 +847,53 @@ void mt7996_dma_reset(struct mt7996_dev *dev, bool force)
 			mt76_dma_reset_tx_queue(&dev->mt76, phy3->q_tx[i]);
 	}
 
+	if (!force)
+		dev_info(dev->mt76.dev,"%s L1 SER dma tx queue reset done.",
+			 wiphy_name(dev->mt76.hw->wiphy));
+
 	for (i = 0; i < __MT_MCUQ_MAX; i++)
-		mt76_queue_reset(dev, dev->mt76.q_mcu[i]);
+		mt76_queue_reset(dev, dev->mt76.q_mcu[i], true);
 
+	if (!force)
+		dev_info(dev->mt76.dev,"%s L1 SER mcu queue reset done.",
+			 wiphy_name(dev->mt76.hw->wiphy));
 	mt76_for_each_q_rx(&dev->mt76, i) {
-		if (mtk_wed_device_active(&dev->mt76.mmio.wed))
+		if (mtk_wed_device_active(&dev->mt76.mmio.wed)) {
 			if (mt76_queue_is_wed_rro(&dev->mt76.q_rx[i]) ||
-			    mt76_queue_is_wed_tx_free(&dev->mt76.q_rx[i]))
+			    mt76_queue_is_wed_tx_free(&dev->mt76.q_rx[i])) {
+				if (force && mt76_queue_is_wed_rro_data(&dev->mt76.q_rx[i]))
+					mt76_queue_reset(dev, &dev->mt76.q_rx[i], false);
 				continue;
+			}
+		}
 
-		mt76_queue_reset(dev, &dev->mt76.q_rx[i]);
+		mt76_queue_reset(dev, &dev->mt76.q_rx[i], true);
 	}
 
+	if (!force)
+		dev_info(dev->mt76.dev,"%s L1 SER rx queue reset done.",
+			 wiphy_name(dev->mt76.hw->wiphy));
+
 	mt76_tx_status_check(&dev->mt76, true);
 
-	mt76_for_each_q_rx(&dev->mt76, i)
+	mt76_for_each_q_rx(&dev->mt76, i) {
+		if (mtk_wed_device_active(&dev->mt76.mmio.wed) && force &&
+		    (mt76_queue_is_wed_rro_ind(&dev->mt76.q_rx[i]) ||
+		     mt76_queue_is_wed_rro_msdu_pg(&dev->mt76.q_rx[i])))
+			continue;
+
 		mt76_queue_rx_reset(dev, i);
+	}
+
+	if (!force)
+		dev_info(dev->mt76.dev,"%s L1 SER rx queue rx reset done.",
+			 wiphy_name(dev->mt76.hw->wiphy));
 
 	mt7996_dma_enable(dev, !force);
+
+	if (!force)
+		dev_info(dev->mt76.dev,"%s L1 SER dma enable done.",
+			 wiphy_name(dev->mt76.hw->wiphy));
 }
 
 void mt7996_dma_cleanup(struct mt7996_dev *dev)
diff --git a/mt7996/eeprom.c b/mt7996/eeprom.c
index 51b09956..a19c0bfb 100644
--- a/mt7996/eeprom.c
+++ b/mt7996/eeprom.c
@@ -6,6 +6,80 @@
 #include <linux/firmware.h>
 #include "mt7996.h"
 #include "eeprom.h"
+#include <linux/moduleparam.h>
+
+static bool testmode_enable;
+module_param(testmode_enable, bool, 0644);
+MODULE_PARM_DESC(testmode_enable, "Enable testmode");
+
+const struct ieee80211_channel dpd_2g_ch_list_bw20[] = {
+	CHAN2G(3, 2422),
+	CHAN2G(7, 2442),
+	CHAN2G(11, 2462)
+};
+
+const struct ieee80211_channel dpd_5g_skip_ch_list[] = {
+	CHAN5G(68, 5340),
+	CHAN5G(72, 5360),
+	CHAN5G(76, 5380),
+	CHAN5G(80, 5400),
+	CHAN5G(84, 5420),
+	CHAN5G(88, 5440),
+	CHAN5G(92, 5460),
+	CHAN5G(96, 5480)
+};
+
+const struct ieee80211_channel dpd_5g_ch_list_bw80[] = {
+	CHAN5G(42, 5210),
+	CHAN5G(58, 5290),
+	CHAN5G(106, 5530),
+	CHAN5G(122, 5610),
+	CHAN5G(138, 5690),
+	CHAN5G(155, 5775),
+	CHAN5G(171, 5855)
+};
+
+const struct ieee80211_channel dpd_5g_ch_list_bw160[] = {
+	CHAN5G(50, 5250),
+	CHAN5G(114, 5570),
+	CHAN5G(163, 5815)
+};
+
+const struct ieee80211_channel dpd_6g_ch_list_bw80[] = {
+	CHAN6G(7, 5985),
+	CHAN6G(23, 6065),
+	CHAN6G(39, 6145),
+	CHAN6G(55, 6225),
+	CHAN6G(71, 6305),
+	CHAN6G(87, 6385),
+	CHAN6G(103, 6465),
+	CHAN6G(119, 6545),
+	CHAN6G(135, 6625),
+	CHAN6G(151, 6705),
+	CHAN6G(167, 6785),
+	CHAN6G(183, 6865),
+	CHAN6G(199, 6945),
+	CHAN6G(215, 7025)
+};
+
+const struct ieee80211_channel dpd_6g_ch_list_bw160[] = {
+	CHAN6G(15, 6025),
+	CHAN6G(47, 6185),
+	CHAN6G(79, 6345),
+	CHAN6G(111, 6505),
+	CHAN6G(143, 6665),
+	CHAN6G(175, 6825),
+	CHAN6G(207, 6985)
+};
+
+const struct ieee80211_channel dpd_6g_ch_list_bw320[] = {
+	CHAN6G(31, 6105),
+	CHAN6G(63, 6265),
+	CHAN6G(95, 6425),
+	CHAN6G(127, 6585),
+	CHAN6G(159, 6745),
+	CHAN6G(191, 6905)
+};
 
 static int mt7996_check_eeprom(struct mt7996_dev *dev)
 {
@@ -22,7 +96,7 @@ static int mt7996_check_eeprom(struct mt7996_dev *dev)
 	}
 }
 
-static char *mt7996_eeprom_name(struct mt7996_dev *dev)
+const char *mt7996_eeprom_name(struct mt7996_dev *dev)
 {
 	switch (mt76_chip(&dev->mt76)) {
 	case MT7992_DEVICE_ID:
@@ -31,6 +105,8 @@ static char *mt7996_eeprom_name(struct mt7996_dev *dev)
 			if (dev->var.fem == MT7996_FEM_INT)
 				return MT7992_EEPROM_DEFAULT_23_INT;
 			return MT7992_EEPROM_DEFAULT_23;
+		case MT7992_VAR_TYPE_24:
+			return MT7992_EEPROM_DEFAULT_24;
 		case MT7992_VAR_TYPE_44:
 		default:
 			if (dev->var.fem == MT7996_FEM_INT)
@@ -46,6 +122,8 @@ static char *mt7996_eeprom_name(struct mt7996_dev *dev)
 			if (dev->var.fem == MT7996_FEM_INT)
 				return MT7996_EEPROM_DEFAULT_233_INT;
 			return MT7996_EEPROM_DEFAULT_233;
+		case MT7996_VAR_TYPE_404:
+			return MT7996_EEPROM_DEFAULT_404;
 		case MT7996_VAR_TYPE_444:
 		default:
 			if (dev->var.fem == MT7996_FEM_INT)
@@ -147,7 +225,10 @@ mt7996_eeprom_check_or_use_default(struct mt7996_dev *dev, bool use_default)
 
 	dev_warn(dev->mt76.dev, "eeprom load fail, use default bin\n");
 	memcpy(eeprom, fw->data, MT7996_EEPROM_SIZE);
+	dev->bin_file_mode = false;
 	dev->flash_mode = true;
+	dev->eeprom_mode = DEFAULT_BIN_MODE;
+	eeprom[MT_EE_TESTMODE_EN] = dev->testmode_enable;
 
 out:
 	release_firmware(fw);
@@ -155,20 +236,84 @@ out:
 	return ret;
 }
 
-static int mt7996_eeprom_load(struct mt7996_dev *dev)
+static int
+mt7996_eeprom_load_bin(struct mt7996_dev *dev)
 {
-	bool use_default = false;
+	u8 *eeprom = dev->mt76.eeprom.data;
+	const struct firmware *fw = NULL;
 	int ret;
 
-	ret = mt76_eeprom_init(&dev->mt76, MT7996_EEPROM_SIZE);
-	if (ret < 0)
+	ret = request_firmware(&fw, dev->mt76.bin_file_name, dev->mt76.dev);
+	if (ret)
 		return ret;
 
-	if (ret && !mt7996_check_eeprom(dev)) {
-		dev->flash_mode = true;
+	if (!fw || !fw->data) {
+		dev_err(dev->mt76.dev, "Invalid bin %s\n", dev->mt76.bin_file_name);
+		ret = -EINVAL;
 		goto out;
 	}
 
+	memcpy(eeprom, fw->data, MT7996_EEPROM_SIZE);
+	dev->flash_mode = true;
+
+out:
+	release_firmware(fw);
+	return ret;
+}
+
+static int mt7996_eeprom_load_flash(struct mt7996_dev *dev)
+{
+	int ret = 1;
+
+	/* return > 0 for load success, return 0 for load failed, return < 0 for no memory */
+	dev->bin_file_mode = mt76_check_bin_file_mode(&dev->mt76);
+	if (dev->bin_file_mode) {
+		dev->mt76.eeprom.size = MT7996_EEPROM_SIZE;
+		dev->mt76.eeprom.data = devm_kzalloc(dev->mt76.dev, dev->mt76.eeprom.size,
+						     GFP_KERNEL);
+		if (!dev->mt76.eeprom.data)
+			return -ENOMEM;
+
+		if (mt7996_eeprom_load_bin(dev))
+			return 0;
+	} else {
+		ret = mt76_eeprom_init(&dev->mt76, MT7996_EEPROM_SIZE);
+	}
+
+	if (mt7996_check_eeprom(dev))
+		return 0;
+
+	return ret;
+}
+
+int mt7996_eeprom_check_fw_mode(struct mt7996_dev *dev)
+{
+	u8 *eeprom;
+	int ret;
+
+	dev->testmode_enable = testmode_enable;
+
+	/* load eeprom in flash or bin file mode to determine fw mode */
+	ret = mt7996_eeprom_load_flash(dev);
+	if (ret <= 0)
+		goto out;
+
+	dev->flash_mode = true;
+	dev->eeprom_mode = dev->bin_file_mode ? BIN_FILE_MODE : FLASH_MODE;
+	eeprom = dev->mt76.eeprom.data;
+	/* testmode enable priority: eeprom field > module parameter */
+	dev->testmode_enable = eeprom[MT_EE_TESTMODE_EN];
+
+out:
+	return ret;
+}
+
+static int mt7996_eeprom_load(struct mt7996_dev *dev)
+{
+	bool use_default = false;
+	int ret;
+
+	/* flash or bin file mode eeprom is loaded before mcu init */
 	if (!dev->flash_mode) {
 		u32 eeprom_blk_size = MT7996_EEPROM_BLOCK_SIZE;
 		u32 block_num = DIV_ROUND_UP(MT7996_EEPROM_SIZE, eeprom_blk_size);
@@ -206,6 +351,7 @@ static int mt7996_eeprom_load(struct mt7996_dev *dev)
 				goto out;
 			}
 		}
+		dev->eeprom_mode = EFUSE_MODE;
 	}
 
 out:
@@ -226,6 +372,8 @@ static int mt7996_eeprom_parse_efuse_hw_cap(struct mt7996_phy *phy,
 	if (ret)
 		return ret;
 
+	/* for internal development */
+	dev->has_eht = true;
 	if (cap) {
 		u8 band_offs = phy->mt76->band_idx * 3;
 
@@ -314,14 +462,118 @@ int mt7996_eeprom_parse_hw_cap(struct mt7996_dev *dev, struct mt7996_phy *phy)
 	return mt7996_eeprom_parse_band_config(phy);
 }
 
+static int
+mt7996_eeprom_load_precal_binfile(struct mt7996_dev *dev, u32 offs, u32 size)
+{
+	const struct firmware *fw = NULL;
+	int ret;
+
+	ret = request_firmware(&fw, dev->mt76.bin_file_name, dev->mt76.dev);
+	if (ret)
+		return ret;
+
+	if (!fw || !fw->data) {
+		dev_err(dev->mt76.dev, "Invalid bin (bin file mode), load precal fail\n");
+		ret = -EINVAL;
+		goto out;
+	}
+
+	memcpy(dev->cal, fw->data + offs, size);
+
+out:
+	release_firmware(fw);
+
+	return ret;
+}
+
+static void mt7996_eeprom_init_precal(struct mt7996_dev *dev)
+{
+#define MT76_CHANNELS_5GHZ_SIZE		36	/* ARRAY_SIZE(mt76_channels_5ghz) */
+#define MT76_CHANNELS_6GHZ_SIZE		59	/* ARRAY_SIZE(mt76_channels_6ghz) */
+
+	dev->prek.dpd_ch_num[DPD_CH_NUM_BW20_2G] = ARRAY_SIZE(dpd_2g_ch_list_bw20);
+	dev->prek.dpd_ch_num[DPD_CH_NUM_BW20_5G_SKIP] = ARRAY_SIZE(dpd_5g_skip_ch_list);
+	dev->prek.dpd_ch_num[DPD_CH_NUM_BW20_5G] = MT76_CHANNELS_5GHZ_SIZE -
+						   DPD_CH_NUM(BW20_5G_SKIP);
+	dev->prek.dpd_ch_num[DPD_CH_NUM_BW160_5G] = ARRAY_SIZE(dpd_5g_ch_list_bw160);
+	dev->prek.dpd_ch_num[DPD_CH_NUM_BW20_6G] = MT76_CHANNELS_6GHZ_SIZE;
+	dev->prek.dpd_ch_num[DPD_CH_NUM_BW160_6G] = ARRAY_SIZE(dpd_6g_ch_list_bw160);
+
+	switch (mt76_chip(&dev->mt76)) {
+	case MT7996_DEVICE_ID:
+		dev->prek.rev = mt7996_prek_rev;
+		if (dev->var.type == MT7996_VAR_TYPE_233)
+			dev->prek.rev = mt7996_prek_rev_233;
+		/* 5g & 6g bw 80 dpd channel list is not used */
+		dev->prek.dpd_ch_num[DPD_CH_NUM_BW320_6G] = ARRAY_SIZE(dpd_6g_ch_list_bw320);
+		break;
+	case MT7992_DEVICE_ID:
+		dev->prek.rev  = mt7992_prek_rev;
+		dev->prek.dpd_ch_num[DPD_CH_NUM_BW80_5G] = ARRAY_SIZE(dpd_5g_ch_list_bw80);
+		/* 6g is not used in current sku */
+		dev->prek.dpd_ch_num[DPD_CH_NUM_BW20_6G] = 0;
+		dev->prek.dpd_ch_num[DPD_CH_NUM_BW80_6G] = 0;
+		dev->prek.dpd_ch_num[DPD_CH_NUM_BW160_6G] = 0;
+		break;
+	default:
+		dev->prek.rev  = mt7996_prek_rev;
+		break;
+	}
+}
+
+static int mt7996_eeprom_load_precal(struct mt7996_dev *dev)
+{
+	struct mt76_dev *mdev = &dev->mt76;
+	u8 *eeprom = mdev->eeprom.data;
+	u32 offs = MT_EE_DO_PRE_CAL;
+	u32 size, val = eeprom[offs];
+	int ret;
+
+	mt7996_eeprom_init_precal(dev);
+
+	if (!dev->flash_mode || !val)
+		return 0;
+
+	size = MT_EE_CAL_GROUP_SIZE + MT_EE_CAL_DPD_SIZE;
+
+	dev->cal = devm_kzalloc(mdev->dev, size, GFP_KERNEL);
+	if (!dev->cal) {
+		ret = -ENOMEM;
+		goto fail;
+	}
+
+	if (dev->bin_file_mode) {
+		ret = mt7996_eeprom_load_precal_binfile(dev, MT_EE_PRECAL, size);
+		if (ret)
+			goto fail;
+	}
+
+	ret = mt76_get_of_data_from_mtd(mdev, dev->cal, offs, size);
+	if (!ret)
+		return 0;
+
+	ret = mt76_get_of_data_from_nvmem(mdev, dev->cal, "precal", size);
+	if (!ret)
+		return 0;
+
+fail:
+	dev_warn(dev->mt76.dev, "Failed to load precal data: %d\n", ret);
+	devm_kfree(dev->mt76.dev, dev->cal);
+	dev->cal = NULL;
+
+	return ret;
+}
+
 int mt7996_eeprom_init(struct mt7996_dev *dev)
 {
 	int ret;
 
 	ret = mt7996_eeprom_load(dev);
-	if (ret < 0)
+	if (ret)
 		return ret;
 
+	mt7996_eeprom_load_precal(dev);
+
 	ret = mt7996_eeprom_parse_hw_cap(dev, &dev->phy);
 	if (ret < 0)
 		return ret;
@@ -370,3 +622,37 @@ s8 mt7996_eeprom_get_power_delta(struct mt7996_dev *dev, int band)
 
 	return val & MT_EE_RATE_DELTA_SIGN ? delta : -delta;
 }
+
+const u8 mt7996_sku_group_len[] = {
+	[SKU_CCK] = 4,
+	[SKU_OFDM] = 8,
+	[SKU_HT20] = 8,
+	[SKU_HT40] = 9,
+	[SKU_VHT20] = 12,
+	[SKU_VHT40] = 12,
+	[SKU_VHT80] = 12,
+	[SKU_VHT160] = 12,
+	[SKU_HE26] = 12,
+	[SKU_HE52] = 12,
+	[SKU_HE106] = 12,
+	[SKU_HE242] = 12,
+	[SKU_HE484] = 12,
+	[SKU_HE996] = 12,
+	[SKU_HE2x996] = 12,
+	[SKU_EHT26] = 16,
+	[SKU_EHT52] = 16,
+	[SKU_EHT106] = 16,
+	[SKU_EHT242] = 16,
+	[SKU_EHT484] = 16,
+	[SKU_EHT996] = 16,
+	[SKU_EHT2x996] = 16,
+	[SKU_EHT4x996] = 16,
+	[SKU_EHT26_52] = 16,
+	[SKU_EHT26_106] = 16,
+	[SKU_EHT484_242] = 16,
+	[SKU_EHT996_484] = 16,
+	[SKU_EHT996_484_242] = 16,
+	[SKU_EHT2x996_484] = 16,
+	[SKU_EHT3x996] = 16,
+	[SKU_EHT3x996_484] = 16,
+};
diff --git a/mt7996/eeprom.h b/mt7996/eeprom.h
index 7a771ca2..788c33c8 100644
--- a/mt7996/eeprom.h
+++ b/mt7996/eeprom.h
@@ -14,6 +14,8 @@ enum mt7996_eeprom_field {
 	MT_EE_MAC_ADDR =	0x004,
 	MT_EE_MAC_ADDR2 =	0x00a,
 	MT_EE_WIFI_CONF =	0x190,
+	MT_EE_DO_PRE_CAL =	0x1a5,
+	MT_EE_TESTMODE_EN =	0x1af,
 	MT_EE_MAC_ADDR3 =	0x2c0,
 	MT_EE_RATE_DELTA_2G =	0x1400,
 	MT_EE_RATE_DELTA_5G =	0x147d,
@@ -23,12 +25,108 @@ enum mt7996_eeprom_field {
 	MT_EE_TX0_POWER_6G =	0x1310,
 
 	__MT_EE_MAX =	0x1dff,
+	/* 0x1e10 ~ 0x2d644 used to save group cal data */
+	MT_EE_PRECAL =		0x1e10,
 };
 
 #define MT_EE_WIFI_CONF0_TX_PATH		GENMASK(2, 0)
 #define MT_EE_WIFI_CONF0_BAND_SEL		GENMASK(2, 0)
 #define MT_EE_WIFI_CONF1_BAND_SEL		GENMASK(5, 3)
 #define MT_EE_WIFI_CONF2_BAND_SEL		GENMASK(2, 0)
+#define MT_EE_WIFI_PA_LNA_CONFIG		GENMASK(1, 0)
+
+#define MT_EE_WIFI_CAL_GROUP_2G			BIT(0)
+#define MT_EE_WIFI_CAL_GROUP_5G			BIT(1)
+#define MT_EE_WIFI_CAL_GROUP_6G			BIT(2)
+#define MT_EE_WIFI_CAL_GROUP			GENMASK(2, 0)
+#define MT_EE_WIFI_CAL_DPD_2G			BIT(3)
+#define MT_EE_WIFI_CAL_DPD_5G			BIT(4)
+#define MT_EE_WIFI_CAL_DPD_6G			BIT(5)
+#define MT_EE_WIFI_CAL_DPD			GENMASK(5, 3)
+
+#define MT_EE_CAL_UNIT				1024
+
+enum mt7996_prek_rev {
+	GROUP_SIZE_2G,
+	GROUP_SIZE_5G,
+	GROUP_SIZE_6G,
+	ADCDCOC_SIZE_2G,
+	ADCDCOC_SIZE_5G,
+	ADCDCOC_SIZE_6G,
+	DPD_LEGACY_SIZE,
+	DPD_MEM_SIZE,
+	DPD_OTFG0_SIZE,
+};
+
+static const u32 mt7996_prek_rev[] = {
+	[GROUP_SIZE_2G] =			4 * MT_EE_CAL_UNIT,
+	[GROUP_SIZE_5G] =			45 * MT_EE_CAL_UNIT,
+	[GROUP_SIZE_6G] =			125 * MT_EE_CAL_UNIT,
+	[ADCDCOC_SIZE_2G] =			4 * 4,
+	[ADCDCOC_SIZE_5G] =			4 * 4,
+	[ADCDCOC_SIZE_6G] =			4 * 5,
+	[DPD_LEGACY_SIZE] =			4 * MT_EE_CAL_UNIT,
+	[DPD_MEM_SIZE] =			13 * MT_EE_CAL_UNIT,
+	[DPD_OTFG0_SIZE] =			2 * MT_EE_CAL_UNIT,
+};
+
+static const u32 mt7996_prek_rev_233[] = {
+	[GROUP_SIZE_2G] =			4 * MT_EE_CAL_UNIT,
+	[GROUP_SIZE_5G] =			44 * MT_EE_CAL_UNIT,
+	[GROUP_SIZE_6G] =			100 * MT_EE_CAL_UNIT,
+	[ADCDCOC_SIZE_2G] =			4 * 4,
+	[ADCDCOC_SIZE_5G] =			4 * 4,
+	[ADCDCOC_SIZE_6G] =			4 * 5,
+	[DPD_LEGACY_SIZE] =			4 * MT_EE_CAL_UNIT,
+	[DPD_MEM_SIZE] =			13 * MT_EE_CAL_UNIT,
+	[DPD_OTFG0_SIZE] =			2 * MT_EE_CAL_UNIT,
+};
+
+/* kite 2/5g config */
+static const u32 mt7992_prek_rev[] = {
+	[GROUP_SIZE_2G] =			4 * MT_EE_CAL_UNIT,
+	[GROUP_SIZE_5G] =			110 * MT_EE_CAL_UNIT,
+	[GROUP_SIZE_6G] =			0,
+	[ADCDCOC_SIZE_2G] =			4 * 4,
+	[ADCDCOC_SIZE_5G] =			4 * 5,
+	[ADCDCOC_SIZE_6G] =			0,
+	[DPD_LEGACY_SIZE] =			5 * MT_EE_CAL_UNIT,
+	[DPD_MEM_SIZE] =			16 * MT_EE_CAL_UNIT,
+	[DPD_OTFG0_SIZE] =			2 * MT_EE_CAL_UNIT,
+};
+
+extern const struct ieee80211_channel dpd_2g_ch_list_bw20[];
+extern const struct ieee80211_channel dpd_5g_skip_ch_list[];
+extern const struct ieee80211_channel dpd_5g_ch_list_bw80[];
+extern const struct ieee80211_channel dpd_5g_ch_list_bw160[];
+extern const struct ieee80211_channel dpd_6g_ch_list_bw80[];
+extern const struct ieee80211_channel dpd_6g_ch_list_bw160[];
+extern const struct ieee80211_channel dpd_6g_ch_list_bw320[];
+
+#define PREK(id)				(dev->prek.rev[(id)])
+#define DPD_CH_NUM(_type)			(dev->prek.dpd_ch_num[DPD_CH_NUM_##_type])
+#define MT_EE_CAL_GROUP_SIZE			(PREK(GROUP_SIZE_2G) + PREK(GROUP_SIZE_5G) + \
+						 PREK(GROUP_SIZE_6G) + PREK(ADCDCOC_SIZE_2G) + \
+						 PREK(ADCDCOC_SIZE_5G) + PREK(ADCDCOC_SIZE_6G))
+#define DPD_PER_CH_BW20_SIZE			(PREK(DPD_LEGACY_SIZE) + PREK(DPD_OTFG0_SIZE))
+#define DPD_PER_CH_GT_BW20_SIZE			(PREK(DPD_MEM_SIZE) + PREK(DPD_OTFG0_SIZE))
+#define MT_EE_CAL_DPD_SIZE_2G			(DPD_CH_NUM(BW20_2G) * DPD_PER_CH_BW20_SIZE)
+#define MT_EE_CAL_DPD_SIZE_5G			(DPD_CH_NUM(BW20_5G) * DPD_PER_CH_BW20_SIZE + \
+						 DPD_CH_NUM(BW80_5G) * DPD_PER_CH_GT_BW20_SIZE + \
+						 DPD_CH_NUM(BW160_5G) * DPD_PER_CH_GT_BW20_SIZE)
+#define MT_EE_CAL_DPD_SIZE_6G			(DPD_CH_NUM(BW20_6G) * DPD_PER_CH_BW20_SIZE + \
+						 DPD_CH_NUM(BW80_6G) * DPD_PER_CH_GT_BW20_SIZE + \
+						 DPD_CH_NUM(BW160_6G) * DPD_PER_CH_GT_BW20_SIZE + \
+						 DPD_CH_NUM(BW320_6G) * DPD_PER_CH_GT_BW20_SIZE)
+#define MT_EE_CAL_DPD_SIZE			(MT_EE_CAL_DPD_SIZE_2G + MT_EE_CAL_DPD_SIZE_5G + \
+						 MT_EE_CAL_DPD_SIZE_6G)
+
+#define RF_DPD_FLAT_CAL				BIT(28)
+#define RF_PRE_CAL				BIT(29)
+#define RF_DPD_FLAT_5G_CAL			GENMASK(29, 28)
+#define RF_DPD_FLAT_5G_MEM_CAL			(BIT(30) | BIT(28))
+#define RF_DPD_FLAT_6G_CAL			GENMASK(30, 28)
+#define RF_DPD_FLAT_6G_MEM_CAL			(BIT(31) | BIT(28))
 
 #define MT_EE_WIFI_CONF1_TX_PATH_BAND0		GENMASK(5, 3)
 #define MT_EE_WIFI_CONF2_TX_PATH_BAND1		GENMASK(2, 0)
@@ -53,6 +151,13 @@ enum mt7996_eeprom_band {
 	MT_EE_BAND_SEL_6GHZ,
 };
 
+enum mt7915_eeprom_mode {
+	DEFAULT_BIN_MODE,
+	EFUSE_MODE,
+	FLASH_MODE,
+	BIN_FILE_MODE,
+};
+
 static inline int
 mt7996_get_channel_group_5g(int channel)
 {
@@ -76,4 +181,46 @@ mt7996_get_channel_group_6g(int channel)
 	return DIV_ROUND_UP(channel - 29, 32);
 }
 
+enum mt7996_sku_rate_group {
+	SKU_CCK,
+	SKU_OFDM,
+
+	SKU_HT20,
+	SKU_HT40,
+
+	SKU_VHT20,
+	SKU_VHT40,
+	SKU_VHT80,
+	SKU_VHT160,
+
+	SKU_HE26,
+	SKU_HE52,
+	SKU_HE106,
+	SKU_HE242,
+	SKU_HE484,
+	SKU_HE996,
+	SKU_HE2x996,
+
+	SKU_EHT26,
+	SKU_EHT52,
+	SKU_EHT106,
+	SKU_EHT242,
+	SKU_EHT484,
+	SKU_EHT996,
+	SKU_EHT2x996,
+	SKU_EHT4x996,
+	SKU_EHT26_52,
+	SKU_EHT26_106,
+	SKU_EHT484_242,
+	SKU_EHT996_484,
+	SKU_EHT996_484_242,
+	SKU_EHT2x996_484,
+	SKU_EHT3x996,
+	SKU_EHT3x996_484,
+
+	MAX_SKU_RATE_GROUP_NUM,
+};
+
+extern const u8 mt7996_sku_group_len[MAX_SKU_RATE_GROUP_NUM];
+
 #endif
diff --git a/mt7996/init.c b/mt7996/init.c
index cd8a694d..f5598a7f 100644
--- a/mt7996/init.c
+++ b/mt7996/init.c
@@ -34,6 +34,7 @@ static const struct ieee80211_iface_combination if_comb_global = {
 			       BIT(NL80211_CHAN_WIDTH_40) |
 			       BIT(NL80211_CHAN_WIDTH_80) |
 			       BIT(NL80211_CHAN_WIDTH_160),
+	.beacon_int_min_gcd = 100,
 };
 
 static const struct ieee80211_iface_limit if_limits[] = {
@@ -63,6 +64,55 @@ static const struct ieee80211_iface_combination if_comb = {
 	.beacon_int_min_gcd = 100,
 };
 
+static const struct ieee80211_iface_combination if_comb_7992 = {
+	.limits = if_limits,
+	.n_limits = ARRAY_SIZE(if_limits),
+	.max_interfaces = 16,
+	.num_different_channels = 1,
+	.beacon_int_infra_match = true,
+	.radar_detect_widths = BIT(NL80211_CHAN_WIDTH_20_NOHT) |
+			       BIT(NL80211_CHAN_WIDTH_20) |
+			       BIT(NL80211_CHAN_WIDTH_40) |
+			       BIT(NL80211_CHAN_WIDTH_80) |
+			       BIT(NL80211_CHAN_WIDTH_160),
+	.beacon_int_min_gcd = 100,
+};
+
+static const u8 mt7996_if_types_ext_capa_ap[] = {
+	[0] = WLAN_EXT_CAPA1_EXT_CHANNEL_SWITCHING,
+	[2] = WLAN_EXT_CAPA3_MULTI_BSSID_SUPPORT,
+	[6] = WLAN_EXT_CAPA7_SCS_SUPPORT,
+	[7] = WLAN_EXT_CAPA8_OPMODE_NOTIF,
+};
+
+static const u8 mt7996_if_types_ext_capa_sta[] = {
+	[0] = WLAN_EXT_CAPA1_EXT_CHANNEL_SWITCHING,
+	[2] = WLAN_EXT_CAPA3_MULTI_BSSID_SUPPORT,
+	[7] = WLAN_EXT_CAPA8_OPMODE_NOTIF,
+};
+
+static const struct wiphy_iftype_ext_capab mt7996_iftypes_ext_capa[] = {
+	{
+		.iftype = NL80211_IFTYPE_STATION,
+		.extended_capabilities = mt7996_if_types_ext_capa,
+		.extended_capabilities_mask = mt7996_if_types_ext_capa,
+		.extended_capabilities_len = sizeof(mt7996_if_types_ext_capa),
+		.mld_capa_and_ops = 2,
+	},
+	{
+		.iftype = NL80211_IFTYPE_AP,
+		.extended_capabilities = mt7996_if_types_ext_capa,
+		.extended_capabilities_mask = mt7996_if_types_ext_capa,
+		.extended_capabilities_len = sizeof(mt7996_if_types_ext_capa),
+		.mld_capa_and_ops = 2,
+		/* the max number of simultaneous links is defined as the
+		 * maximum number of affiliated APs minus 1.
+		 * mt7996 could have 3 links in an MLD AP, so currently
+		 * hardcode it to 2.
+		 */
+	},
+};
+
 static ssize_t mt7996_thermal_temp_show(struct device *dev,
 					struct device_attribute *attr,
 					char *buf)
@@ -102,7 +152,7 @@ static ssize_t mt7996_thermal_temp_store(struct device *dev,
 		return ret;
 
 	mutex_lock(&phy->dev->mt76.mutex);
-	val = DIV_ROUND_CLOSEST(clamp_val(val, 40 * 1000, 130 * 1000), 1000);
+	val = clamp_val(DIV_ROUND_CLOSEST(val, 1000), 40, 130);
 
 	/* add a safety margin ~10 */
 	if ((i - 1 == MT7996_CRIT_TEMP_IDX &&
@@ -318,7 +368,12 @@ static void __mt7996_init_txpower(struct mt7996_phy *phy,
 	int path_delta = mt76_tx_power_path_delta(path);
 	int pwr_delta = mt7996_eeprom_get_power_delta(dev, sband->band);
 	struct mt76_power_limits limits;
+	struct mt76_power_path_limits limits_path;
+	struct device_node *np;
 
+	phy->sku_limit_en = true;
+	phy->sku_path_en = true;
+	np = mt76_find_power_limits_node(&dev->mt76);
 	for (i = 0; i < sband->n_channels; i++) {
 		struct ieee80211_channel *chan = &sband->channels[i];
 		int target_power = mt7996_eeprom_get_target_power(dev, chan);
@@ -326,27 +381,40 @@ static void __mt7996_init_txpower(struct mt7996_phy *phy,
 		target_power += pwr_delta;
 		target_power = mt76_get_rate_power_limits(phy->mt76, chan,
 							  &limits,
+							  &limits_path,
 							  target_power);
+		if (!limits_path.ofdm[0])
+			phy->sku_path_en = false;
+
 		target_power += path_delta;
 		target_power = DIV_ROUND_UP(target_power, 2);
-		chan->max_power = min_t(int, chan->max_reg_power,
-					target_power);
-		phy->txpower = max(phy->txpower, chan->max_power);
+		if (!np)
+			chan->max_power = min_t(int, chan->max_reg_power,
+						target_power);
+		else
+			chan->max_power = target_power;
 		chan->orig_mpwr = target_power;
 	}
 }
 
 void mt7996_init_txpower(struct mt7996_phy *phy)
 {
+	struct mt7996_phy *phy_2g, *phy_5g, *phy_6g;
+
 	if (!phy)
 		return;
 
-	if (phy->mt76->cap.has_2ghz)
-		__mt7996_init_txpower(phy, &phy->mt76->sband_2g.sband);
-	if (phy->mt76->cap.has_5ghz)
-		__mt7996_init_txpower(phy, &phy->mt76->sband_5g.sband);
-	if (phy->mt76->cap.has_6ghz)
-		__mt7996_init_txpower(phy, &phy->mt76->sband_6g.sband);
+	/* FIXME refactor after single wiphy multiple radios merged */
+	phy_2g = mt7996_band_phy(phy->dev, NL80211_BAND_2GHZ);
+	phy_5g = mt7996_band_phy(phy->dev, NL80211_BAND_5GHZ);
+	phy_6g = mt7996_band_phy(phy->dev, NL80211_BAND_6GHZ);
+
+	if (phy_2g && phy_2g->mt76->cap.has_2ghz)
+		__mt7996_init_txpower(phy_2g, &phy_2g->mt76->sband_2g.sband);
+	if (phy_5g && phy_5g->mt76->cap.has_5ghz)
+		__mt7996_init_txpower(phy_5g, &phy_5g->mt76->sband_5g.sband);
+	if (phy_6g && phy_6g->mt76->cap.has_6ghz)
+		__mt7996_init_txpower(phy_6g, &phy_6g->mt76->sband_6g.sband);
 }
 
 static void
@@ -381,6 +449,7 @@ mt7996_init_wiphy_band(struct ieee80211_hw *hw, struct mt7996_phy *phy)
 
 	phy->slottime = 9;
 	phy->beacon_rate = -1;
+	phy->muru_onoff = OFDMA_UL | OFDMA_DL | MUMIMO_DL | MUMIMO_UL;
 
 	if (phy->mt76->cap.has_2ghz) {
 		phy->mt76->sband_2g.sband.ht_cap.cap |=
@@ -407,7 +476,7 @@ mt7996_init_wiphy_band(struct ieee80211_hw *hw, struct mt7996_phy *phy)
 		freq->start_freq = 5000000;
 		freq->end_freq = 5900000;
 	} else if (phy->mt76->cap.has_6ghz) {
-		freq->start_freq = 5900000;
+		freq->start_freq = 5925000;
 		freq->end_freq = 7200000;
 	} else {
 		return;
@@ -416,8 +485,9 @@ mt7996_init_wiphy_band(struct ieee80211_hw *hw, struct mt7996_phy *phy)
 	dev->radio_phy[n_radios] = phy;
 	radio->freq_range = freq;
 	radio->n_freq_range = 1;
-	radio->iface_combinations = &if_comb;
+	radio->iface_combinations = is_mt7996(&dev->mt76) ? &if_comb : &if_comb_7992;
 	radio->n_iface_combinations = 1;
+	radio->antenna_mask = phy->mt76->chainmask;
 	hw->wiphy->n_radio++;
 
 	wiphy->available_antennas_rx |= phy->mt76->chainmask;
@@ -435,10 +505,16 @@ mt7996_init_wiphy(struct ieee80211_hw *hw, struct mtk_wed_device *wed)
 	struct mt7996_dev *dev = mt7996_hw_dev(hw);
 	struct mt76_dev *mdev = &dev->mt76;
 	struct wiphy *wiphy = hw->wiphy;
-	u16 max_subframes = dev->has_eht ? IEEE80211_MAX_AMPDU_BUF_EHT :
-					   IEEE80211_MAX_AMPDU_BUF_HE;
+	u16 max_subframes = phy->dev->has_eht ? IEEE80211_MAX_AMPDU_BUF_EHT :
+						IEEE80211_MAX_AMPDU_BUF_HE;
 
 	hw->queues = 4;
+
+	if (dev->has_eht)
+		max_subframes = is_mt7990(mdev) ? 512 : IEEE80211_MAX_AMPDU_BUF_EHT;
+	else
+		max_subframes = IEEE80211_MAX_AMPDU_BUF_HE;
+
 	hw->max_rx_aggregation_subframes = max_subframes;
 	hw->max_tx_aggregation_subframes = max_subframes;
 	hw->netdev_features = NETIF_F_RXCSUM;
@@ -450,16 +526,15 @@ mt7996_init_wiphy(struct ieee80211_hw *hw, struct mtk_wed_device *wed)
 
 	hw->sta_data_size = sizeof(struct mt7996_sta);
 	hw->vif_data_size = sizeof(struct mt7996_vif);
-	hw->chanctx_data_size = sizeof(struct mt76_chanctx);
+	hw->chanctx_data_size = sizeof(struct mt7996_chanctx);
 
 	wiphy->iface_combinations = &if_comb_global;
 	wiphy->n_iface_combinations = 1;
-
+	wiphy->mbssid_max_interfaces = is_mt7996(&dev->mt76) ? 48 : 32;
 	wiphy->radio = dev->radios;
 
 	wiphy->reg_notifier = mt7996_regd_notifier;
 	wiphy->flags |= WIPHY_FLAG_HAS_CHANNEL_SWITCH;
-	wiphy->mbssid_max_interfaces = 16;
 
 	wiphy_ext_feature_set(wiphy, NL80211_EXT_FEATURE_BSS_COLOR);
 	wiphy_ext_feature_set(wiphy, NL80211_EXT_FEATURE_VHT_IBSS);
@@ -472,7 +547,11 @@ mt7996_init_wiphy(struct ieee80211_hw *hw, struct mtk_wed_device *wed)
 	wiphy_ext_feature_set(wiphy, NL80211_EXT_FEATURE_ACK_SIGNAL_SUPPORT);
 	wiphy_ext_feature_set(wiphy, NL80211_EXT_FEATURE_CAN_REPLACE_PTK0);
 	wiphy_ext_feature_set(wiphy, NL80211_EXT_FEATURE_MU_MIMO_AIR_SNIFFER);
+	wiphy_ext_feature_set(wiphy, NL80211_EXT_FEATURE_PUNCT);
+	wiphy_ext_feature_set(wiphy, NL80211_EXT_FEATURE_STAS_COUNT);
 
+	wiphy_ext_feature_set(wiphy, NL80211_EXT_FEATURE_OPERATING_CHANNEL_VALIDATION);
+	wiphy_ext_feature_set(wiphy, NL80211_EXT_FEATURE_BEACON_PROTECTION);
 	if (mt7996_has_background_radar(dev) &&
 	    (!mdev->dev->of_node ||
 	     !of_property_read_bool(mdev->dev->of_node,
@@ -485,6 +564,9 @@ mt7996_init_wiphy(struct ieee80211_hw *hw, struct mtk_wed_device *wed)
 	ieee80211_hw_set(hw, SUPPORTS_RX_DECAP_OFFLOAD);
 	ieee80211_hw_set(hw, NO_VIRTUAL_MONITOR);
 	ieee80211_hw_set(hw, SUPPORTS_MULTI_BSSID);
+	ieee80211_hw_set(hw, CHANCTX_STA_CSA);
+	ieee80211_hw_set(hw, CONNECTION_MONITOR);
+	ieee80211_hw_set(hw, HANDLES_QUIET_CSA);
 
 	hw->max_tx_fragments = 4;
 
@@ -497,6 +579,12 @@ mt7996_init_wiphy(struct ieee80211_hw *hw, struct mtk_wed_device *wed)
 	wiphy->max_scan_ssids = 4;
 	wiphy->max_scan_ie_len = IEEE80211_MAX_DATA_LEN;
 
+	/* enable MLO support */
+	wiphy->flags |= WIPHY_FLAG_SUPPORTS_MLO;
+	wiphy->iftype_ext_capab = mt7996_iftypes_ext_capa;
+	wiphy->num_iftype_ext_capab = ARRAY_SIZE(mt7996_iftypes_ext_capa);
+	wiphy->features |= NL80211_FEATURE_AP_MODE_CHAN_WIDTH_CHANGE;
+
 	mt7996_init_wiphy_band(hw, &dev->phy);
 }
 
@@ -516,10 +604,6 @@ mt7996_mac_init_band(struct mt7996_dev *dev, u8 band)
 	mt76_clear(dev, MT_WF_RMAC_MIB_AIRTIME4(band),
 		   MT_WF_RMAC_MIB_QOS23_BACKOFF);
 
-	/* clear backoff time for Tx duration */
-	mt76_clear(dev, MT_WTBLOFF_ACR(band),
-		   MT_WTBLOFF_ADM_BACKOFFTIME);
-
 	/* clear backoff time and set software compensation for OBSS time */
 	mask = MT_WF_RMAC_MIB_OBSS_BACKOFF | MT_WF_RMAC_MIB_ED_OFFSET;
 	set = FIELD_PREP(MT_WF_RMAC_MIB_OBSS_BACKOFF, 0) |
@@ -556,7 +640,7 @@ static void mt7996_mac_init_basic_rates(struct mt7996_dev *dev)
 void mt7996_mac_init(struct mt7996_dev *dev)
 {
 #define HIF_TXD_V2_1	0x21
-	int i;
+	int i, rx_path_type, rro_bypass, txfree_path;
 
 	mt76_clear(dev, MT_MDP_DCR2, MT_MDP_DCR2_RX_TRANS_SHORT);
 
@@ -570,22 +654,52 @@ void mt7996_mac_init(struct mt7996_dev *dev)
 	}
 
 	/* rro module init */
-	if (is_mt7996(&dev->mt76))
-		mt7996_mcu_set_rro(dev, UNI_RRO_SET_PLATFORM_TYPE, 2);
-	else
-		mt7996_mcu_set_rro(dev, UNI_RRO_SET_PLATFORM_TYPE,
-				   dev->hif2 ? 7 : 0);
+	rx_path_type = is_mt7996(&dev->mt76) ? 2 : 7;
+	rro_bypass = is_mt7996(&dev->mt76) ? 1 : 2;
+	txfree_path = is_mt7996(&dev->mt76) ? 0: 1;
+
+	switch (dev->option_type) {
+	case 2:
+		if (is_mt7996(&dev->mt76)) {
+			/* eagle + 7988d */
+			rx_path_type = 3;
+			rro_bypass = 1;
+			txfree_path = 0;
+		}
+		break;
+	case 3:
+		/* Airoha */
+		if (is_mt7996(&dev->mt76)) {
+			rx_path_type = 6;
+			rro_bypass = 1;
+			txfree_path = 0;
+		} else {
+			rx_path_type = 8;
+			rro_bypass = 2;
+			txfree_path = 1;
+		}
+		break;
+	case 4:
+		if (is_mt7996(&dev->mt76)) {
+			/* Bollinger */
+			rx_path_type = 2;
+			rro_bypass = 1;
+			txfree_path = 0;
+		}
+		break;
+	default:
+		break;
+	}
+
+	mt7996_mcu_set_rro(dev, UNI_RRO_SET_PLATFORM_TYPE, dev->hif2 ? rx_path_type : 0);
+	mt7996_mcu_set_rro(dev, UNI_RRO_SET_BYPASS_MODE, dev->has_rro ? rro_bypass : 3);
+	mt7996_mcu_set_rro(dev, UNI_RRO_SET_TXFREE_PATH, dev->has_rro ? txfree_path : 1);
 
 	if (dev->has_rro) {
 		u16 timeout;
 
 		timeout = mt76_rr(dev, MT_HW_REV) == MT_HW_REV1 ? 512 : 128;
 		mt7996_mcu_set_rro(dev, UNI_RRO_SET_FLUSH_TIMEOUT, timeout);
-		mt7996_mcu_set_rro(dev, UNI_RRO_SET_BYPASS_MODE, 1);
-		mt7996_mcu_set_rro(dev, UNI_RRO_SET_TXFREE_PATH, 0);
-	} else {
-		mt7996_mcu_set_rro(dev, UNI_RRO_SET_BYPASS_MODE, 3);
-		mt7996_mcu_set_rro(dev, UNI_RRO_SET_TXFREE_PATH, 1);
 	}
 
 	mt7996_mcu_wa_cmd(dev, MCU_WA_PARAM_CMD(SET),
@@ -618,6 +732,53 @@ int mt7996_txbf_init(struct mt7996_dev *dev)
 	return mt7996_mcu_set_txbf(dev, BF_HW_EN_UPDATE);
 }
 
+static int mt7996_vow_init(struct mt7996_phy *phy)
+{
+	struct mt7996_vow_ctrl *vow = &phy->dev->vow;
+	int ret;
+
+	vow->atf_enable = true;
+	vow->watf_enable = false;
+	vow->max_deficit = 64;
+	vow->sch_type = VOW_SCH_TYPE_FOLLOW_POLICY;
+	vow->sch_policy = VOW_SCH_POLICY_SRR;
+
+	vow->drr_quantum[0] = VOW_DRR_QUANTUM_L0;
+	vow->drr_quantum[1] = VOW_DRR_QUANTUM_L1;
+	vow->drr_quantum[2] = VOW_DRR_QUANTUM_L2;
+	vow->drr_quantum[3] = VOW_DRR_QUANTUM_L3;
+	vow->drr_quantum[4] = VOW_DRR_QUANTUM_L4;
+	vow->drr_quantum[5] = VOW_DRR_QUANTUM_L5;
+	vow->drr_quantum[6] = VOW_DRR_QUANTUM_L6;
+	vow->drr_quantum[7] = VOW_DRR_QUANTUM_L7;
+
+	ret = mt7996_mcu_set_vow_drr_ctrl(phy, NULL, NULL, VOW_DRR_CTRL_AIRTIME_DEFICIT_BOUND);
+	if (ret)
+		return ret;
+
+	ret = mt7996_mcu_set_vow_drr_ctrl(phy, NULL, NULL, VOW_DRR_CTRL_AIRTIME_QUANTUM_ALL);
+	if (ret)
+		return ret;
+
+	return mt7996_mcu_set_vow_feature_ctrl(phy);
+}
+
+static void mt7996_init_chanctx(struct mt7996_phy *phy)
+{
+	struct ieee80211_supported_band *sband;
+	struct ieee80211_channel *chan;
+
+	if (phy->mt76->band_idx == MT_BAND2)
+		sband = &phy->mt76->sband_6g.sband;
+	else if (phy->mt76->band_idx == MT_BAND1)
+		sband = &phy->mt76->sband_5g.sband;
+	else
+		sband = &phy->mt76->sband_2g.sband;
+
+	chan = &sband->channels[0];
+	cfg80211_chandef_create(&phy->mt76->chandef, chan, NL80211_CHAN_HT20);
+}
+
 static int mt7996_register_phy(struct mt7996_dev *dev, enum mt76_band_id band)
 {
 	struct mt7996_phy *phy;
@@ -629,9 +790,23 @@ static int mt7996_register_phy(struct mt7996_dev *dev, enum mt76_band_id band)
 	if (!mt7996_band_valid(dev, band))
 		return 0;
 
-	if (is_mt7996(&dev->mt76) && band == MT_BAND2 && dev->hif2) {
-		hif1_ofs = MT_WFDMA0_PCIE1(0) - MT_WFDMA0(0);
-		wed = &dev->mt76.mmio.wed_hif2;
+	if (dev->hif2) {
+		switch (dev->option_type) {
+		case 2:
+			/* eagle + 7988d */
+			if (band == MT_BAND1) {
+				hif1_ofs = MT_WFDMA0_PCIE1(0) - MT_WFDMA0(0);
+				wed = &dev->mt76.mmio.wed_hif2;
+			}
+			break;
+		default:
+			if ((is_mt7996(&dev->mt76) && band == MT_BAND2) ||
+			    (is_mt7992(&dev->mt76) && band == MT_BAND1)) {
+				hif1_ofs = MT_WFDMA0_PCIE1(0) - MT_WFDMA0(0);
+				wed = &dev->mt76.mmio.wed_hif2;
+			}
+			break;
+		}
 	}
 
 	mphy = mt76_alloc_radio_phy(&dev->mt76, sizeof(*phy), band);
@@ -644,6 +819,7 @@ static int mt7996_register_phy(struct mt7996_dev *dev, enum mt76_band_id band)
 	mphy->dev->phys[band] = mphy;
 
 	INIT_DELAYED_WORK(&mphy->mac_work, mt7996_mac_work);
+	INIT_DELAYED_WORK(&phy->scan_work, mt7996_scan_work);
 
 	ret = mt7996_eeprom_parse_hw_cap(dev, phy);
 	if (ret)
@@ -674,16 +850,24 @@ static int mt7996_register_phy(struct mt7996_dev *dev, enum mt76_band_id band)
 	if (ret)
 		goto error;
 
+#ifdef CONFIG_MTK_VENDOR
+	mt7996_vendor_register(phy);
+#endif
+
 	ret = mt76_register_phy(mphy, true, mt76_rates,
 				ARRAY_SIZE(mt76_rates));
 	if (ret)
 		goto error;
 
-	if (wed == &dev->mt76.mmio.wed_hif2 && mtk_wed_device_active(wed)) {
-		u32 irq_mask = dev->mt76.mmio.irqmask | MT_INT_TX_DONE_BAND2;
+	if (mt7996_vow_should_enable(dev)) {
+		ret = mt7996_vow_init(phy);
+		if (ret)
+			goto error;
+	}
 
-		mt76_wr(dev, MT_INT1_MASK_CSR, irq_mask);
-		mtk_wed_device_start(&dev->mt76.mmio.wed_hif2, irq_mask);
+	if (wed == &dev->mt76.mmio.wed_hif2 && mtk_wed_device_active(wed)) {
+		mt76_wr(dev, MT_INT_PCIE1_MASK_CSR, MT_INT_TX_RX_DONE_EXT);
+		mtk_wed_device_start(&dev->mt76.mmio.wed_hif2, MT_INT_TX_RX_DONE_EXT);
 	}
 
 	return 0;
@@ -693,11 +877,35 @@ error:
 	return ret;
 }
 
+#ifdef CONFIG_MTK_VENDOR
+static int mt7996_unregister_csi(struct mt7996_phy *phy)
+{
+	struct csi_data *c, *tmp_c;
+
+	spin_lock_bh(&phy->csi.lock);
+	phy->csi.enable = 0;
+
+	list_for_each_entry_safe(c, tmp_c, &phy->csi.list, node) {
+		list_del(&c->node);
+		kfree(c);
+	}
+	spin_unlock_bh(&phy->csi.lock);
+
+	return 0;
+}
+#endif
+
 static void
 mt7996_unregister_phy(struct mt7996_phy *phy)
 {
-	if (phy)
-		mt7996_unregister_thermal(phy);
+	if (!phy)
+		return;
+
+#ifdef CONFIG_MTK_VENDOR
+	mt7996_unregister_csi(phy);
+#endif
+
+	mt7996_unregister_thermal(phy);
 }
 
 static void mt7996_init_work(struct work_struct *work)
@@ -708,6 +916,7 @@ static void mt7996_init_work(struct work_struct *work)
 	mt7996_mcu_set_eeprom(dev);
 	mt7996_mac_init(dev);
 	mt7996_txbf_init(dev);
+	mt7996_mcu_set_dup_wtbl(dev);
 }
 
 void mt7996_wfsys_reset(struct mt7996_dev *dev)
@@ -719,11 +928,96 @@ void mt7996_wfsys_reset(struct mt7996_dev *dev)
 	msleep(20);
 }
 
-static int mt7996_wed_rro_init(struct mt7996_dev *dev)
+void mt7996_rro_hw_init(struct mt7996_dev *dev)
 {
 #ifdef CONFIG_NET_MEDIATEK_SOC_WED
 	struct mtk_wed_device *wed = &dev->mt76.mmio.wed;
 	u32 reg = MT_RRO_ADDR_ELEM_SEG_ADDR0;
+	int i;
+
+	if (!dev->has_rro)
+		return;
+
+	if (is_mt7992(&dev->mt76)) {
+		/* set emul 3.0 function */
+		mt76_wr(dev, MT_RRO_3_0_EMU_CONF,
+			MT_RRO_3_0_EMU_CONF_EN_MASK);
+
+		mt76_wr(dev, MT_RRO_ADDR_ARRAY_BASE0,
+			dev->wed_rro.addr_elem[0].phy_addr);
+	} else {
+		INIT_LIST_HEAD(&dev->wed_rro.pg_addr_cache);
+		for (i = 0; i < MT7996_RRO_MSDU_PG_HASH_SIZE; i++)
+			INIT_LIST_HEAD(&dev->wed_rro.pg_hash_head[i]);
+
+		/* TODO: remove line after WM has set */
+		mt76_clear(dev, WF_RRO_AXI_MST_CFG, WF_RRO_AXI_MST_CFG_DIDX_OK);
+
+		/* setup BA bitmap cache address */
+		mt76_wr(dev, MT_RRO_BA_BITMAP_BASE0,
+			dev->wed_rro.ba_bitmap[0].phy_addr);
+		mt76_wr(dev, MT_RRO_BA_BITMAP_BASE1, 0);
+		mt76_wr(dev, MT_RRO_BA_BITMAP_BASE_EXT0,
+			dev->wed_rro.ba_bitmap[1].phy_addr);
+		mt76_wr(dev, MT_RRO_BA_BITMAP_BASE_EXT1, 0);
+
+		/* setup Address element address */
+		for (i = 0; i < ARRAY_SIZE(dev->wed_rro.addr_elem); i++) {
+			mt76_wr(dev, reg, dev->wed_rro.addr_elem[i].phy_addr >> 4);
+			reg += 4;
+		}
+
+		/* setup Address element address - separate address segment mode */
+		mt76_wr(dev, MT_RRO_ADDR_ARRAY_BASE1,
+			MT_RRO_ADDR_ARRAY_ELEM_ADDR_SEG_MODE);
+	}
+	wed->wlan.ind_cmd.win_size = ffs(MT7996_RRO_WINDOW_MAX_LEN) - 6;
+	if (is_mt7996(&dev->mt76))
+		wed->wlan.ind_cmd.particular_sid = MT7996_RRO_MAX_SESSION;
+	else
+		wed->wlan.ind_cmd.particular_sid = 1;
+	wed->wlan.ind_cmd.particular_se_phys = dev->wed_rro.session.phy_addr;
+	wed->wlan.ind_cmd.se_group_nums = MT7996_RRO_ADDR_ELEM_LEN;
+	wed->wlan.ind_cmd.ack_sn_addr = MT_RRO_ACK_SN_CTRL;
+
+	mt76_wr(dev, MT_RRO_IND_CMD_SIGNATURE_BASE0, 0x15010e00);
+	mt76_set(dev, MT_RRO_IND_CMD_SIGNATURE_BASE1,
+		 MT_RRO_IND_CMD_SIGNATURE_BASE1_EN);
+
+	/* particular session configure */
+	/* use max session idx + 1 as particular session id */
+	mt76_wr(dev, MT_RRO_PARTICULAR_CFG0, dev->wed_rro.session.phy_addr);
+
+	if (is_mt7992(&dev->mt76)) {
+		reg = MT_RRO_MSDU_PG_SEG_ADDR0;
+
+		mt76_set(dev, MT_RRO_3_1_GLOBAL_CONFIG,
+			 MT_RRO_3_1_GLOBAL_CONFIG_INTERLEAVE_EN);
+
+		/* setup Msdu page address */
+		for (i = 0; i < MT7996_RRO_MSDU_PG_CR_CNT; i++) {
+			mt76_wr(dev, reg, dev->wed_rro.msdu_pg[i].phy_addr >> 4);
+			reg += 4;
+		}
+		mt76_wr(dev, MT_RRO_PARTICULAR_CFG1,
+			MT_RRO_PARTICULAR_CONFG_EN |
+			FIELD_PREP(MT_RRO_PARTICULAR_SID, 1));
+	} else {
+		mt76_wr(dev, MT_RRO_PARTICULAR_CFG1,
+			MT_RRO_PARTICULAR_CONFG_EN |
+			FIELD_PREP(MT_RRO_PARTICULAR_SID, MT7996_RRO_MAX_SESSION));
+	}
+	/* interrupt enable */
+	mt76_wr(dev, MT_RRO_HOST_INT_ENA,
+		MT_RRO_HOST_INT_ENA_HOST_RRO_DONE_ENA);
+
+#endif
+}
+
+static int mt7996_wed_rro_init(struct mt7996_dev *dev)
+{
+#ifdef CONFIG_NET_MEDIATEK_SOC_WED
+	struct mtk_wed_device *wed = &dev->mt76.mmio.wed;
 	struct mt7996_wed_rro_addr *addr;
 	void *ptr;
 	int i;
@@ -769,6 +1063,17 @@ static int mt7996_wed_rro_init(struct mt7996_dev *dev)
 			dev->wed_rro.addr_elem[i].phy_addr;
 	}
 
+	for (i = 0; i < MT7996_RRO_MSDU_PG_CR_CNT; i++) {
+		ptr = dmam_alloc_coherent(dev->mt76.dma_dev, MT7996_RRO_MSDU_PG_SIZE_PER_CR,
+					  &dev->wed_rro.msdu_pg[i].phy_addr,
+					  GFP_KERNEL);
+		if (!ptr)
+			return -ENOMEM;
+		dev->wed_rro.msdu_pg[i].ptr = ptr;
+
+		memset(dev->wed_rro.msdu_pg[i].ptr, 0, MT7996_RRO_MSDU_PG_SIZE_PER_CR);
+	}
+
 	ptr = dmam_alloc_coherent(dev->mt76.dma_dev,
 				  MT7996_RRO_WINDOW_MAX_LEN * sizeof(*addr),
 				  &dev->wed_rro.session.phy_addr,
@@ -783,50 +1088,9 @@ static int mt7996_wed_rro_init(struct mt7996_dev *dev)
 		addr++;
 	}
 
-	/* rro hw init */
-	/* TODO: remove line after WM has set */
-	mt76_clear(dev, WF_RRO_AXI_MST_CFG, WF_RRO_AXI_MST_CFG_DIDX_OK);
-
-	/* setup BA bitmap cache address */
-	mt76_wr(dev, MT_RRO_BA_BITMAP_BASE0,
-		dev->wed_rro.ba_bitmap[0].phy_addr);
-	mt76_wr(dev, MT_RRO_BA_BITMAP_BASE1, 0);
-	mt76_wr(dev, MT_RRO_BA_BITMAP_BASE_EXT0,
-		dev->wed_rro.ba_bitmap[1].phy_addr);
-	mt76_wr(dev, MT_RRO_BA_BITMAP_BASE_EXT1, 0);
-
-	/* setup Address element address */
-	for (i = 0; i < ARRAY_SIZE(dev->wed_rro.addr_elem); i++) {
-		mt76_wr(dev, reg, dev->wed_rro.addr_elem[i].phy_addr >> 4);
-		reg += 4;
-	}
-
-	/* setup Address element address - separate address segment mode */
-	mt76_wr(dev, MT_RRO_ADDR_ARRAY_BASE1,
-		MT_RRO_ADDR_ARRAY_ELEM_ADDR_SEG_MODE);
-
-	wed->wlan.ind_cmd.win_size = ffs(MT7996_RRO_WINDOW_MAX_LEN) - 6;
-	wed->wlan.ind_cmd.particular_sid = MT7996_RRO_MAX_SESSION;
-	wed->wlan.ind_cmd.particular_se_phys = dev->wed_rro.session.phy_addr;
-	wed->wlan.ind_cmd.se_group_nums = MT7996_RRO_ADDR_ELEM_LEN;
-	wed->wlan.ind_cmd.ack_sn_addr = MT_RRO_ACK_SN_CTRL;
-
-	mt76_wr(dev, MT_RRO_IND_CMD_SIGNATURE_BASE0, 0x15010e00);
-	mt76_set(dev, MT_RRO_IND_CMD_SIGNATURE_BASE1,
-		 MT_RRO_IND_CMD_SIGNATURE_BASE1_EN);
-
-	/* particular session configure */
-	/* use max session idx + 1 as particular session id */
-	mt76_wr(dev, MT_RRO_PARTICULAR_CFG0, dev->wed_rro.session.phy_addr);
-	mt76_wr(dev, MT_RRO_PARTICULAR_CFG1,
-		MT_RRO_PARTICULAR_CONFG_EN |
-		FIELD_PREP(MT_RRO_PARTICULAR_SID, MT7996_RRO_MAX_SESSION));
-
-	/* interrupt enable */
-	mt76_wr(dev, MT_RRO_HOST_INT_ENA,
-		MT_RRO_HOST_INT_ENA_HOST_RRO_DONE_ENA);
-
 	/* rro ind cmd queue init */
+	mt7996_rro_hw_init(dev);
+
 	return mt7996_dma_rro_init(dev);
 #else
 	return 0;
@@ -865,6 +1129,16 @@ static void mt7996_wed_rro_free(struct mt7996_dev *dev)
 				   dev->wed_rro.addr_elem[i].phy_addr);
 	}
 
+	for (i = 0; i < ARRAY_SIZE(dev->wed_rro.msdu_pg); i++) {
+		if (!dev->wed_rro.msdu_pg[i].ptr)
+			continue;
+
+		dmam_free_coherent(dev->mt76.dma_dev,
+				   MT7996_RRO_MSDU_PG_SIZE_PER_CR,
+				   dev->wed_rro.msdu_pg[i].ptr,
+				   dev->wed_rro.msdu_pg[i].phy_addr);
+	}
+
 	if (!dev->wed_rro.session.ptr)
 		return;
 
@@ -942,7 +1216,7 @@ static int mt7996_variant_type_init(struct mt7996_dev *dev)
 		else if (u32_get_bits(val, MT_PAD_GPIO_ADIE_COMB_7992))
 			var_type = MT7992_VAR_TYPE_44;
 		else
-			return -EINVAL;
+			var_type = MT7992_VAR_TYPE_24;
 		break;
 	default:
 		return -EINVAL;
@@ -997,6 +1271,9 @@ static int mt7996_variant_fem_init(struct mt7996_dev *dev)
 static int mt7996_init_hardware(struct mt7996_dev *dev)
 {
 	int ret, idx;
+	struct device_node *np = dev->mt76.dev->of_node;
+
+	of_property_read_u32(np, "option_type", &dev->option_type);
 
 	mt76_wr(dev, MT_INT_SOURCE_CSR, ~0);
 	if (is_mt7992(&dev->mt76)) {
@@ -1019,6 +1296,10 @@ static int mt7996_init_hardware(struct mt7996_dev *dev)
 
 	set_bit(MT76_STATE_INITIALIZED, &dev->mphy.state);
 
+	ret = mt7996_eeprom_check_fw_mode(dev);
+	if (ret < 0)
+		return ret;
+
 	ret = mt7996_mcu_init(dev);
 	if (ret)
 		return ret;
@@ -1035,6 +1316,12 @@ static int mt7996_init_hardware(struct mt7996_dev *dev)
 	if (ret < 0)
 		return ret;
 
+	if (dev->cal) {
+		ret = mt7996_mcu_apply_group_cal(dev);
+		if (ret)
+			return ret;
+	}
+
 	/* Beacon and mgmt frames should occupy wcid 0 */
 	idx = mt76_wcid_alloc(dev->mt76.wcid_mask, MT7996_WTBL_STA);
 	if (idx)
@@ -1479,6 +1766,8 @@ int mt7996_register_device(struct mt7996_dev *dev)
 	dev->mt76.phy.priv = &dev->phy;
 	INIT_WORK(&dev->rc_work, mt7996_mac_sta_rc_work);
 	INIT_DELAYED_WORK(&dev->mphy.mac_work, mt7996_mac_work);
+	INIT_DELAYED_WORK(&dev->phy.scan_work, mt7996_scan_work);
+	INIT_DELAYED_WORK(&dev->scs_work, mt7996_mcu_scs_sta_poll);
 	INIT_LIST_HEAD(&dev->sta_rc_list);
 	INIT_LIST_HEAD(&dev->twt_list);
 
@@ -1487,12 +1776,22 @@ int mt7996_register_device(struct mt7996_dev *dev)
 	INIT_WORK(&dev->dump_work, mt7996_mac_dump_work);
 	mutex_init(&dev->dump_mutex);
 
+	INIT_WORK(&dev->wmm_pbc_work, mt7996_mcu_wmm_pbc_work);
+
 	ret = mt7996_init_hardware(dev);
 	if (ret)
 		return ret;
 
 	mt7996_init_wiphy(hw, &dev->mt76.mmio.wed);
 
+#ifdef CONFIG_NL80211_TESTMODE
+	dev->mt76.test_ops = &mt7996_testmode_ops;
+#endif
+
+#ifdef CONFIG_MTK_VENDOR
+	mt7996_vendor_register(&dev->phy);
+#endif
+
 	ret = mt7996_register_phy(dev, MT_BAND1);
 	if (ret)
 		return ret;
@@ -1506,16 +1805,27 @@ int mt7996_register_device(struct mt7996_dev *dev)
 	if (ret)
 		return ret;
 
-	mt7996_for_each_phy(dev, phy)
+	ret = mt7996_init_dev_debugfs(&dev->phy);
+	if (ret)
+		goto error;
+
+	mt7996_for_each_phy(dev, phy) {
+		mt7996_init_chanctx(phy);
 		mt7996_thermal_init(phy);
+		ret = mt7996_init_band_debugfs(phy);
+		if (ret)
+			goto error;
+	}
 
 	ieee80211_queue_work(mt76_hw(dev), &dev->init_work);
 
 	dev->recovery.hw_init_done = true;
 
-	ret = mt7996_init_debugfs(dev);
-	if (ret)
-		goto error;
+	if (mt7996_vow_should_enable(dev)) {
+		ret = mt7996_vow_init(&dev->phy);
+		if (ret)
+			goto error;
+	}
 
 	ret = mt7996_coredump_register(dev);
 	if (ret)
diff --git a/mt7996/mac.c b/mt7996/mac.c
index e06ea024..672f072d 100644
--- a/mt7996/mac.c
+++ b/mt7996/mac.c
@@ -10,8 +10,8 @@
 #include "../dma.h"
 #include "mac.h"
 #include "mcu.h"
-
-#define to_rssi(field, rcpi)	((FIELD_GET(field, rcpi) - 220) / 2)
+#include "vendor.h"
+#include "mt7996_trace.h"
 
 static const struct mt7996_dfs_radar_spec etsi_radar_specs = {
 	.pulse_th = { 110, -10, -80, 40, 5200, 128, 5200 },
@@ -52,29 +52,6 @@ static const struct mt7996_dfs_radar_spec jp_radar_specs = {
 	},
 };
 
-static struct mt76_wcid *mt7996_rx_get_wcid(struct mt7996_dev *dev,
-					    u16 idx, bool unicast)
-{
-	struct mt7996_sta *sta;
-	struct mt76_wcid *wcid;
-
-	if (idx >= ARRAY_SIZE(dev->mt76.wcid))
-		return NULL;
-
-	wcid = rcu_dereference(dev->mt76.wcid[idx]);
-	if (unicast || !wcid)
-		return wcid;
-
-	if (!wcid->sta)
-		return NULL;
-
-	sta = container_of(wcid, struct mt7996_sta, wcid);
-	if (!sta->vif)
-		return NULL;
-
-	return &sta->vif->deflink.sta.wcid;
-}
-
 bool mt7996_mac_wtbl_update(struct mt7996_dev *dev, int idx, u32 mask)
 {
 	mt76_rmw(dev, MT_WTBL_UPDATE, MT_WTBL_UPDATE_WLAN_IDX,
@@ -92,113 +69,16 @@ u32 mt7996_mac_wtbl_lmac_addr(struct mt7996_dev *dev, u16 wcid, u8 dw)
 	return MT_WTBL_LMAC_OFFS(wcid, dw);
 }
 
-static void mt7996_mac_sta_poll(struct mt7996_dev *dev)
-{
-	static const u8 ac_to_tid[] = {
-		[IEEE80211_AC_BE] = 0,
-		[IEEE80211_AC_BK] = 1,
-		[IEEE80211_AC_VI] = 4,
-		[IEEE80211_AC_VO] = 6
-	};
-	struct ieee80211_sta *sta;
-	struct mt7996_sta *msta;
-	u32 tx_time[IEEE80211_NUM_ACS], rx_time[IEEE80211_NUM_ACS];
-	LIST_HEAD(sta_poll_list);
-	int i;
-
-	spin_lock_bh(&dev->mt76.sta_poll_lock);
-	list_splice_init(&dev->mt76.sta_poll_list, &sta_poll_list);
-	spin_unlock_bh(&dev->mt76.sta_poll_lock);
-
-	rcu_read_lock();
-
-	while (true) {
-		bool clear = false;
-		u32 addr, val;
-		u16 idx;
-		s8 rssi[4];
-
-		spin_lock_bh(&dev->mt76.sta_poll_lock);
-		if (list_empty(&sta_poll_list)) {
-			spin_unlock_bh(&dev->mt76.sta_poll_lock);
-			break;
-		}
-		msta = list_first_entry(&sta_poll_list,
-					struct mt7996_sta, wcid.poll_list);
-		list_del_init(&msta->wcid.poll_list);
-		spin_unlock_bh(&dev->mt76.sta_poll_lock);
-
-		idx = msta->wcid.idx;
-
-		/* refresh peer's airtime reporting */
-		addr = mt7996_mac_wtbl_lmac_addr(dev, idx, 20);
-
-		for (i = 0; i < IEEE80211_NUM_ACS; i++) {
-			u32 tx_last = msta->airtime_ac[i];
-			u32 rx_last = msta->airtime_ac[i + 4];
-
-			msta->airtime_ac[i] = mt76_rr(dev, addr);
-			msta->airtime_ac[i + 4] = mt76_rr(dev, addr + 4);
-
-			tx_time[i] = msta->airtime_ac[i] - tx_last;
-			rx_time[i] = msta->airtime_ac[i + 4] - rx_last;
-
-			if ((tx_last | rx_last) & BIT(30))
-				clear = true;
-
-			addr += 8;
-		}
-
-		if (clear) {
-			mt7996_mac_wtbl_update(dev, idx,
-					       MT_WTBL_UPDATE_ADM_COUNT_CLEAR);
-			memset(msta->airtime_ac, 0, sizeof(msta->airtime_ac));
-		}
-
-		if (!msta->wcid.sta)
-			continue;
-
-		sta = container_of((void *)msta, struct ieee80211_sta,
-				   drv_priv);
-		for (i = 0; i < IEEE80211_NUM_ACS; i++) {
-			u8 q = mt76_connac_lmac_mapping(i);
-			u32 tx_cur = tx_time[q];
-			u32 rx_cur = rx_time[q];
-			u8 tid = ac_to_tid[i];
-
-			if (!tx_cur && !rx_cur)
-				continue;
-
-			ieee80211_sta_register_airtime(sta, tid, tx_cur, rx_cur);
-		}
-
-		/* get signal strength of resp frames (CTS/BA/ACK) */
-		addr = mt7996_mac_wtbl_lmac_addr(dev, idx, 34);
-		val = mt76_rr(dev, addr);
-
-		rssi[0] = to_rssi(GENMASK(7, 0), val);
-		rssi[1] = to_rssi(GENMASK(15, 8), val);
-		rssi[2] = to_rssi(GENMASK(23, 16), val);
-		rssi[3] = to_rssi(GENMASK(31, 14), val);
-
-		msta->ack_signal =
-			mt76_rx_signal(msta->vif->deflink.phy->mt76->antenna_mask, rssi);
-
-		ewma_avg_signal_add(&msta->avg_ack_signal, -msta->ack_signal);
-	}
-
-	rcu_read_unlock();
-}
-
 /* The HW does not translate the mac header to 802.3 for mesh point */
 static int mt7996_reverse_frag0_hdr_trans(struct sk_buff *skb, u16 hdr_gap)
 {
 	struct mt76_rx_status *status = (struct mt76_rx_status *)skb->cb;
 	struct ethhdr *eth_hdr = (struct ethhdr *)(skb->data + hdr_gap);
-	struct mt7996_sta *msta = (struct mt7996_sta *)status->wcid;
+	struct mt7996_link_sta *mlink = (struct mt7996_link_sta *)status->wcid;
 	__le32 *rxd = (__le32 *)skb->data;
 	struct ieee80211_sta *sta;
 	struct ieee80211_vif *vif;
+	struct ieee80211_bss_conf *conf;
 	struct ieee80211_hdr hdr;
 	u16 frame_control;
 
@@ -209,11 +89,14 @@ static int mt7996_reverse_frag0_hdr_trans(struct sk_buff *skb, u16 hdr_gap)
 	if (!(le32_to_cpu(rxd[1]) & MT_RXD1_NORMAL_GROUP_4))
 		return -EINVAL;
 
-	if (!msta || !msta->vif)
+	if (!mlink->sta || !mlink->sta->vif)
 		return -EINVAL;
 
-	sta = container_of((void *)msta, struct ieee80211_sta, drv_priv);
-	vif = container_of((void *)msta->vif, struct ieee80211_vif, drv_priv);
+	sta = wcid_to_sta(status->wcid);
+	vif = container_of((void *)mlink->sta->vif, struct ieee80211_vif, drv_priv);
+	conf = rcu_dereference(vif->link_conf[mlink->wcid.link_id]);
+	if (unlikely(!conf))
+		return -ENOLINK;
 
 	/* store the info from RXD and ethhdr to avoid being overridden */
 	frame_control = le32_get_bits(rxd[8], MT_RXD8_FRAME_CONTROL);
@@ -226,7 +109,7 @@ static int mt7996_reverse_frag0_hdr_trans(struct sk_buff *skb, u16 hdr_gap)
 	switch (frame_control & (IEEE80211_FCTL_TODS |
 				 IEEE80211_FCTL_FROMDS)) {
 	case 0:
-		ether_addr_copy(hdr.addr3, vif->bss_conf.bssid);
+		ether_addr_copy(hdr.addr3, conf->bssid);
 		break;
 	case IEEE80211_FCTL_FROMDS:
 		ether_addr_copy(hdr.addr3, eth_hdr->h_source);
@@ -435,8 +318,13 @@ mt7996_mac_fill_rx(struct mt7996_dev *dev, enum mt76_rxq_id q,
 	__le16 fc = 0;
 	int idx;
 	u8 hw_aggr = false;
-	struct mt7996_sta *msta = NULL;
+	struct mt7996_link_sta *mlink = NULL;
 
+#ifdef CONFIG_MTK_DEBUG
+	if (dev->dbg.dump_rx_raw)
+		mt7996_packet_log_to_host(dev, skb->data, skb->len, PKT_BIN_DEBUG_RX_RAW, 0);
+	mt7996_dump_bmac_rxd_info(dev, rxd);
+#endif
 	hw_aggr = status->aggr;
 	memset(status, 0, sizeof(*status));
 
@@ -445,6 +333,8 @@ mt7996_mac_fill_rx(struct mt7996_dev *dev, enum mt76_rxq_id q,
 	phy = mphy->priv;
 	status->phy_idx = mphy->band_idx;
 
+	trace_mt7996_fill_rx(phy, skb->data, skb->len);
+
 	if (!test_bit(MT76_STATE_RUNNING, &mphy->state))
 		return -EINVAL;
 
@@ -461,11 +351,15 @@ mt7996_mac_fill_rx(struct mt7996_dev *dev, enum mt76_rxq_id q,
 
 	unicast = FIELD_GET(MT_RXD3_NORMAL_ADDR_TYPE, rxd3) == MT_RXD3_NORMAL_U2M;
 	idx = FIELD_GET(MT_RXD1_NORMAL_WLAN_IDX, rxd1);
-	status->wcid = mt7996_rx_get_wcid(dev, idx, unicast);
+	status->wcid = mt7996_get_link_wcid(dev, idx, band_idx);
 
 	if (status->wcid) {
-		msta = container_of(status->wcid, struct mt7996_sta, wcid);
-		mt76_wcid_add_poll(&dev->mt76, &msta->wcid);
+		mlink = wcid_to_mlink(status->wcid);
+		spin_lock_bh(&dev->mt76.sta_poll_lock);
+		if (list_empty(&mlink->wcid.poll_list))
+			list_add_tail(&mlink->wcid.poll_list,
+				      &dev->mt76.sta_poll_list);
+		spin_unlock_bh(&dev->mt76.sta_poll_lock);
 	}
 
 	status->freq = mphy->chandef.chan->center_freq;
@@ -607,6 +501,10 @@ mt7996_mac_fill_rx(struct mt7996_dev *dev, enum mt76_rxq_id q,
 	}
 
 	hdr_gap = (u8 *)rxd - skb->data + 2 * remove_pad;
+#ifdef CONFIG_MTK_DEBUG
+	if (dev->dbg.dump_rx_pkt)
+		mt7996_packet_log_to_host(dev, skb->data, skb->len, PKT_BIN_DEBUG_RX, hdr_gap);
+#endif
 	if (hdr_trans && ieee80211_has_morefrags(fc)) {
 		if (mt7996_reverse_frag0_hdr_trans(skb, hdr_gap))
 			return -EINVAL;
@@ -661,15 +559,47 @@ mt7996_mac_fill_rx(struct mt7996_dev *dev, enum mt76_rxq_id q,
 			 */
 			if (ieee80211_has_a4(fc) && is_mesh && status->amsdu)
 				*qos &= ~IEEE80211_QOS_CTL_A_MSDU_PRESENT;
+		} else if (ieee80211_is_beacon(fc)) {
+			struct ieee80211_hw *hw = phy->mt76->hw;
+			struct ieee80211_sta *sta;
+			struct mt7996_sta *msta;
+			unsigned int link_id = 0;
+
+			sta = ieee80211_find_sta_by_link_addrs(hw, hdr->addr2, NULL, &link_id);
+			if (!sta)
+				sta = ieee80211_find_sta_by_ifaddr(hw, hdr->addr2, NULL);
+
+			if (sta) {
+				msta = (struct mt7996_sta *)sta->drv_priv;
+				if (msta && msta->vif) {
+					msta->vif->beacon_received_time[band_idx] = jiffies;
+					/* FIXME: This is a temporary workaround.
+					 * Lost links should be resumed via TTLM or
+					 * link reconfig.
+					 */
+					if (msta->vif->lost_links & BIT(link_id)) {
+						msta->vif->lost_links &= ~BIT(link_id);
+						wiphy_info(hw->wiphy,
+							   "link %d: resume beacon monitoring\n",
+							   link_id);
+					}
+				}
+			}
 		}
 		skb_set_mac_header(skb, (unsigned char *)hdr - skb->data);
+
+#ifdef CONFIG_MTK_VENDOR
+		if (phy->amnt_ctrl.enable && !ieee80211_is_beacon(fc))
+			mt7996_vendor_amnt_fill_rx(phy, skb);
+#endif
 	} else {
 		status->flag |= RX_FLAG_8023;
-		mt7996_wed_check_ppe(dev, &dev->mt76.q_rx[q], msta, skb,
+		mt7996_wed_check_ppe(dev, &dev->mt76.q_rx[q], mlink ? mlink->sta : NULL, skb,
 				     *info);
 	}
 
-	if (rxv && !(status->flag & RX_FLAG_8023)) {
+	if (rxv && !(status->flag & RX_FLAG_8023) &&
+	    (mode >= MT_PHY_TYPE_HE_SU && mode < MT_PHY_TYPE_EHT_SU)) {
 		switch (status->encoding) {
 		case RX_ENC_EHT:
 			mt76_connac3_mac_decode_eht_radiotap(skb, rxv, mode);
@@ -682,6 +612,8 @@ mt7996_mac_fill_rx(struct mt7996_dev *dev, enum mt76_rxq_id q,
 		}
 	}
 
+	trace_mt7996_fill_rx_done(phy, status->seqno, hdr_gap);
+
 	if (!status->wcid || !ieee80211_is_data_qos(fc) || hw_aggr)
 		return 0;
 
@@ -704,9 +636,8 @@ mt7996_mac_write_txwi_8023(struct mt7996_dev *dev, __le32 *txwi,
 	u32 val;
 
 	if (wcid->sta) {
-		struct ieee80211_sta *sta;
+		struct ieee80211_sta *sta = wcid_to_sta(wcid);
 
-		sta = container_of((void *)wcid, struct ieee80211_sta, drv_priv);
 		wmm = sta->wme;
 	}
 
@@ -733,17 +664,29 @@ mt7996_mac_write_txwi_8023(struct mt7996_dev *dev, __le32 *txwi,
 
 static void
 mt7996_mac_write_txwi_80211(struct mt7996_dev *dev, __le32 *txwi,
-			    struct sk_buff *skb, struct ieee80211_key_conf *key)
+			    struct sk_buff *skb, struct ieee80211_key_conf *key,
+			    struct mt76_wcid *wcid)
 {
+	struct mt76_phy *mphy =
+		mt76_dev_phy(&dev->mt76, le32_get_bits(txwi[1], MT_TXD1_TGID));
 	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;
 	struct ieee80211_mgmt *mgmt = (struct ieee80211_mgmt *)skb->data;
 	struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);
 	bool multicast = is_multicast_ether_addr(hdr->addr1);
 	u8 tid = skb->priority & IEEE80211_QOS_CTL_TID_MASK;
 	__le16 fc = hdr->frame_control, sc = hdr->seq_ctrl;
+	u16 seqno = le16_to_cpu(sc);
 	u8 fc_type, fc_stype;
 	u32 val;
 
+	if (ieee80211_is_cert_mode(mphy->hw) && ieee80211_is_deauth(fc)) {
+		/* In WPA3 cert TC-4.8.1, the deauth must be transmitted without
+		 * considering PSM bit
+		 */
+		txwi[0] &= ~cpu_to_le32(MT_TXD0_Q_IDX);
+		txwi[0] |= cpu_to_le32(FIELD_PREP(MT_TXD0_Q_IDX, MT_LMAC_ALTX0));
+	}
+
 	if (ieee80211_is_action(fc) &&
 	    mgmt->u.action.category == WLAN_CATEGORY_BACK &&
 	    mgmt->u.action.u.addba_req.action_code == WLAN_ACTION_ADDBA_REQ)
@@ -790,9 +733,13 @@ mt7996_mac_write_txwi_80211(struct mt7996_dev *dev, __le32 *txwi,
 		txwi[3] |= cpu_to_le32(MT_TXD3_REM_TX_COUNT);
 	}
 
-	if (info->flags & IEEE80211_TX_CTL_INJECTED) {
-		u16 seqno = le16_to_cpu(sc);
+	if (ieee80211_vif_is_mld(info->control.vif) && multicast) {
+		val = MT_TXD3_SN_VALID |
+		      FIELD_PREP(MT_TXD3_SEQ, IEEE80211_SEQ_TO_SN(seqno));
+		txwi[3] |= cpu_to_le32(val);
+	}
 
+	if (info->flags & IEEE80211_TX_CTL_INJECTED) {
 		if (ieee80211_is_back_req(hdr->frame_control)) {
 			struct ieee80211_bar *bar;
 
@@ -805,6 +752,20 @@ mt7996_mac_write_txwi_80211(struct mt7996_dev *dev, __le32 *txwi,
 		txwi[3] |= cpu_to_le32(val);
 		txwi[3] &= ~cpu_to_le32(MT_TXD3_HW_AMSDU);
 	}
+
+	if (ieee80211_vif_is_mld(info->control.vif) &&
+	    (multicast || unlikely(skb->protocol == cpu_to_be16(ETH_P_PAE)) ||
+	     info->flags & IEEE80211_TX_CTL_INJECTED))
+		txwi[5] |= cpu_to_le32(MT_TXD5_FL);
+
+	if (unlikely(ieee80211_is_nullfunc(fc)) && ieee80211_has_a4(fc) &&
+	    ieee80211_vif_is_mld(info->control.vif)) {
+		txwi[5] |= cpu_to_le32(MT_TXD5_FL);
+		txwi[6] |= cpu_to_le32(MT_TXD6_DIS_MAT);
+	}
+
+	if (!wcid->sta && ieee80211_is_mgmt(fc))
+		txwi[6] |= cpu_to_le32(MT_TXD6_DIS_MAT);
 }
 
 void mt7996_mac_write_txwi(struct mt7996_dev *dev, __le32 *txwi,
@@ -815,11 +776,12 @@ void mt7996_mac_write_txwi(struct mt7996_dev *dev, __le32 *txwi,
 	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;
 	struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);
 	struct ieee80211_vif *vif = info->control.vif;
+	struct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;
+	struct mt7996_bss_conf *mconf;
 	u8 band_idx = (info->hw_queue & MT_TX_HW_QUEUE_PHY) >> 2;
 	u8 p_fmt, q_idx, omac_idx = 0, wmm_idx = 0;
+	u8 link_id;
 	bool is_8023 = info->flags & IEEE80211_TX_CTL_HW_80211_ENCAP;
-	struct mt76_vif_link *mlink = NULL;
-	struct mt7996_vif *mvif;
 	u16 tx_count = 15;
 	u32 val;
 	bool inband_disc = !!(changed & (BSS_CHANGED_UNSOL_BCAST_PROBE_RESP |
@@ -827,18 +789,16 @@ void mt7996_mac_write_txwi(struct mt7996_dev *dev, __le32 *txwi,
 	bool beacon = !!(changed & (BSS_CHANGED_BEACON |
 				    BSS_CHANGED_BEACON_ENABLED)) && (!inband_disc);
 
-	if (vif) {
-		mvif = (struct mt7996_vif *)vif->drv_priv;
-		if (wcid->offchannel)
-			mlink = rcu_dereference(mvif->mt76.offchannel_link);
-		if (!mlink)
-			mlink = &mvif->deflink.mt76;
-	}
+	if (likely(wcid != &dev->mt76.global_wcid))
+		link_id = wcid->link_id;
+	else
+		link_id = u32_get_bits(info->control.flags, IEEE80211_TX_CTRL_MLO_LINK);
 
-	if (mlink) {
-		omac_idx = mlink->omac_idx;
-		wmm_idx = mlink->wmm_idx;
-		band_idx = mlink->band_idx;
+	mconf = rcu_dereference(mvif->link[link_id]);
+	if (mconf) {
+		omac_idx = mconf->mt76.omac_idx;
+		wmm_idx = mconf->mt76.wmm_idx;
+		band_idx = mconf->mt76.band_idx;
 	}
 
 	if (inband_disc) {
@@ -885,7 +845,11 @@ void mt7996_mac_write_txwi(struct mt7996_dev *dev, __le32 *txwi,
 		val |= MT_TXD5_TX_STATUS_HOST;
 	txwi[5] = cpu_to_le32(val);
 
-	val = MT_TXD6_DIS_MAT | MT_TXD6_DAS;
+	val = MT_TXD6_DAS;
+	if ((q_idx >= MT_LMAC_ALTX0 && q_idx <= MT_LMAC_BCN0) ||
+	    unlikely(skb->protocol == cpu_to_be16(ETH_P_PAE)))
+		val |= MT_TXD6_DIS_MAT;
+
 	if (is_mt7996(&dev->mt76))
 		val |= FIELD_PREP(MT_TXD6_MSDU_CNT, 1);
 	else if (is_8023 || !ieee80211_is_mgmt(hdr->frame_control))
@@ -897,23 +861,25 @@ void mt7996_mac_write_txwi(struct mt7996_dev *dev, __le32 *txwi,
 	if (is_8023)
 		mt7996_mac_write_txwi_8023(dev, txwi, skb, wcid);
 	else
-		mt7996_mac_write_txwi_80211(dev, txwi, skb, key);
+		mt7996_mac_write_txwi_80211(dev, txwi, skb, key, wcid);
 
 	if (txwi[1] & cpu_to_le32(MT_TXD1_FIXED_RATE)) {
 		bool mcast = ieee80211_is_data(hdr->frame_control) &&
 			     is_multicast_ether_addr(hdr->addr1);
 		u8 idx = MT7996_BASIC_RATES_TBL;
 
-		if (mlink) {
-			if (mcast && mlink->mcast_rates_idx)
-				idx = mlink->mcast_rates_idx;
-			else if (beacon && mlink->beacon_rates_idx)
-				idx = mlink->beacon_rates_idx;
+		if (mconf) {
+			if (mcast && mconf->mt76.mcast_rates_idx)
+				idx = mconf->mt76.mcast_rates_idx;
+			else if (beacon && mconf->mt76.beacon_rates_idx)
+				idx = mconf->mt76.beacon_rates_idx;
 			else
-				idx = mlink->basic_rates_idx;
+				idx = mconf->mt76.basic_rates_idx;
 		}
 
 		val = FIELD_PREP(MT_TXD6_TX_RATE, idx) | MT_TXD6_FIXED_BW;
+		if (mcast)
+			val |= MT_TXD6_DIS_MAT;
 		txwi[6] |= cpu_to_le32(val);
 		txwi[3] |= cpu_to_le32(MT_TXD3_BA_DISABLE);
 	}
@@ -929,28 +895,110 @@ int mt7996_tx_prepare_skb(struct mt76_dev *mdev, void *txwi_ptr,
 	struct ieee80211_tx_info *info = IEEE80211_SKB_CB(tx_info->skb);
 	struct ieee80211_key_conf *key = info->control.hw_key;
 	struct ieee80211_vif *vif = info->control.vif;
+	struct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;
+	struct mt7996_sta *msta;
+	struct mt7996_bss_conf *mconf;
 	struct mt76_connac_txp_common *txp;
 	struct mt76_txwi_cache *t;
 	int id, i, pid, nbuf = tx_info->nbuf - 1;
 	bool is_8023 = info->flags & IEEE80211_TX_CTL_HW_80211_ENCAP;
 	u8 *txwi = (u8 *)txwi_ptr;
+	u8 link_id;
 
-	if (unlikely(tx_info->skb->len <= ETH_HLEN))
+	if (unlikely(tx_info->skb->len <= ETH_HLEN)) {
+		mdev->tx_dbg_stats.tx_drop[MT_TX_DROP_INVALID_SKB]++;
 		return -EINVAL;
+	}
 
-	if (!wcid)
-		wcid = &dev->mt76.global_wcid;
+	if (WARN_ON(!wcid)) {
+		mdev->tx_dbg_stats.tx_drop[MT_TX_DROP_INVALID_WCID]++;
+		return -EINVAL;
+	}
+
+	msta = sta ? (struct mt7996_sta *)sta->drv_priv : &mvif->sta;
+	if ((is_8023 || ieee80211_is_data_qos(hdr->frame_control)) && sta && sta->mlo) {
+		if (unlikely(tx_info->skb->protocol == cpu_to_be16(ETH_P_PAE))) {
+			link_id = msta->pri_link;
+		} else {
+			u8 tid = tx_info->skb->priority & IEEE80211_QOS_CTL_TID_MASK;
+
+			link_id = (tid % 2) ? msta->sec_link : msta->pri_link;
+		}
+	} else {
+		link_id = u32_get_bits(info->control.flags, IEEE80211_TX_CTRL_MLO_LINK);
+
+		if (link_id == IEEE80211_LINK_UNSPECIFIED || (sta && !sta->mlo))
+			link_id = wcid->link_id;
+	}
+
+	if (link_id != wcid->link_id) {
+		struct mt7996_link_sta *mlink = rcu_dereference(msta->link[link_id]);
+
+		if (mlink)
+			wcid = &mlink->wcid;
+	}
+
+	mconf = rcu_dereference(mvif->link[wcid->link_id]);
+	if (!mconf) {
+		mdev->tx_dbg_stats.tx_drop[MT_TX_DROP_INVALID_LINK]++;
+		return -ENOLINK;
+	}
 
 	t = (struct mt76_txwi_cache *)(txwi + mdev->drv->txwi_size);
 	t->skb = tx_info->skb;
 
 	id = mt76_token_consume(mdev, &t);
-	if (id < 0)
+	if (id < 0) {
+		mdev->tx_dbg_stats.tx_drop[MT_TX_DROP_GET_TOKEN_FAIL]++;
 		return id;
+	}
+#ifdef CONFIG_MTK_DEBUG
+	t->jiffies = jiffies;
+#endif
 
 	pid = mt76_tx_status_skb_add(mdev, wcid, tx_info->skb);
-	mt7996_mac_write_txwi(dev, txwi_ptr, tx_info->skb, wcid, key,
-			      pid, qid, 0);
+	memset(txwi_ptr, 0, MT_TXD_SIZE);
+	/* Transmit non qos data by 802.11 header and need to fill txd by host*/
+	if (!is_8023 || pid >= MT_PACKET_ID_FIRST)
+		mt7996_mac_write_txwi(dev, txwi_ptr, tx_info->skb, wcid, key,
+				      pid, qid, 0);
+
+	/* Since the rules of HW MLD address translation are not fully compatible
+	 * with 802.11 EAPOL frame, we do the translation by software
+	 */
+	if (unlikely(tx_info->skb->protocol == cpu_to_be16(ETH_P_PAE)) && sta->mlo) {
+		struct ieee80211_bss_conf *conf;
+		struct ieee80211_link_sta *link_sta;
+		__le16 fc = hdr->frame_control;
+
+		conf = rcu_dereference(vif->link_conf[wcid->link_id]);
+		link_sta = rcu_dereference(sta->link[wcid->link_id]);
+		if (!conf || !link_sta) {
+			mdev->tx_dbg_stats.tx_drop[MT_TX_DROP_INVALID_LINK]++;
+			return -ENOLINK;
+		}
+
+		dma_sync_single_for_cpu(mdev->dma_dev, tx_info->buf[1].addr,
+					tx_info->buf[1].len, DMA_TO_DEVICE);
+
+		memcpy(hdr->addr1, link_sta->addr, ETH_ALEN);
+		memcpy(hdr->addr2, conf->addr, ETH_ALEN);
+
+		/* EAPOL's SA/DA need to be MLD address in MLO */
+		if (ieee80211_has_a4(fc)) {
+			memcpy(hdr->addr3, sta->addr, ETH_ALEN);
+			memcpy(hdr->addr4, vif->addr, ETH_ALEN);
+		} else if (ieee80211_has_tods(fc)) {
+			memcpy(hdr->addr3, sta->addr, ETH_ALEN);
+		} else if (ieee80211_has_fromds(fc)) {
+			memcpy(hdr->addr3, vif->addr, ETH_ALEN);
+		}
+
+		dma_sync_single_for_device(mdev->dma_dev, tx_info->buf[1].addr,
+					   tx_info->buf[1].len, DMA_TO_DEVICE);
+
+		pr_info("EAPOL: a1=%pM, a2=%pM, a3=%pM\n", hdr->addr1, hdr->addr2, hdr->addr3);
+	}
 
 	txp = (struct mt76_connac_txp_common *)(txwi + MT_TXD_SIZE);
 	for (i = 0; i < nbuf; i++) {
@@ -967,8 +1015,10 @@ int mt7996_tx_prepare_skb(struct mt76_dev *mdev, void *txwi_ptr,
 	}
 	txp->fw.nbuf = nbuf;
 
-	txp->fw.flags =
-		cpu_to_le16(MT_CT_INFO_FROM_HOST | MT_CT_INFO_APPLY_TXD);
+	txp->fw.flags = cpu_to_le16(MT_CT_INFO_FROM_HOST);
+
+	if (!is_8023 || pid >= MT_PACKET_ID_FIRST)
+		txp->fw.flags |= cpu_to_le16(MT_CT_INFO_APPLY_TXD);
 
 	if (!key)
 		txp->fw.flags |= cpu_to_le16(MT_CT_INFO_NONE_CIPHER_FRAME);
@@ -976,18 +1026,7 @@ int mt7996_tx_prepare_skb(struct mt76_dev *mdev, void *txwi_ptr,
 	if (!is_8023 && ieee80211_is_mgmt(hdr->frame_control))
 		txp->fw.flags |= cpu_to_le16(MT_CT_INFO_MGMT_FRAME);
 
-	if (vif) {
-		struct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;
-		struct mt76_vif_link *mlink = NULL;
-
-		if (wcid->offchannel)
-			mlink = rcu_dereference(mvif->mt76.offchannel_link);
-		if (!mlink)
-			mlink = &mvif->deflink.mt76;
-
-		txp->fw.bss_idx = mlink->idx;
-	}
-
+	txp->fw.bss_idx = mconf->mt76.idx;
 	txp->fw.token = cpu_to_le16(id);
 	txp->fw.rept_wds_wcid = cpu_to_le16(sta ? wcid->idx : 0xfff);
 
@@ -998,6 +1037,15 @@ int mt7996_tx_prepare_skb(struct mt76_dev *mdev, void *txwi_ptr,
 	tx_info->buf[1].skip_unmap = true;
 	tx_info->nbuf = MT_CT_DMA_BUF_NUM;
 
+#ifdef CONFIG_MTK_DEBUG
+	if (dev->dbg.dump_txd)
+		mt7996_packet_log_to_host(dev, txwi, MT_TXD_SIZE, PKT_BIN_DEBUG_TXD, 0);
+	if (dev->dbg.dump_tx_pkt)
+		mt7996_packet_log_to_host(dev, t->skb->data, t->skb->len, PKT_BIN_DEBUG_TX, 0);
+	mt7996_dump_bmac_txd_info(NULL, dev, (__le32 *)txwi, true, false);
+#endif
+	trace_mt7996_tx_prepare(dev, wcid, qid, txwi, t->skb->data, t->skb->len);
+
 	return 0;
 }
 
@@ -1025,20 +1073,25 @@ u32 mt7996_wed_init_buf(void *ptr, dma_addr_t phys, int token_id)
 }
 
 static void
-mt7996_tx_check_aggr(struct ieee80211_sta *sta, struct sk_buff *skb)
+mt7996_tx_check_aggr(struct ieee80211_sta *sta, struct sk_buff *skb,
+		     struct mt76_wcid *wcid)
 {
 	struct mt7996_sta *msta;
+	struct mt7996_link_sta *mlink;
+	struct ieee80211_link_sta *link_sta;
 	struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);
 	bool is_8023 = info->flags & IEEE80211_TX_CTL_HW_80211_ENCAP;
 	u16 fc, tid;
 
-	if (!sta || !(sta->deflink.ht_cap.ht_supported || sta->deflink.he_cap.has_he))
+	link_sta = rcu_dereference(sta->link[wcid->link_id]);
+	if (!link_sta)
 		return;
 
-	tid = skb->priority & IEEE80211_QOS_CTL_TID_MASK;
-	if (tid >= 6) /* skip VO queue */
+	if (!sta->mlo && !(link_sta->ht_cap.ht_supported || link_sta->he_cap.has_he))
 		return;
 
+	tid = skb->priority & IEEE80211_QOS_CTL_TID_MASK;
+
 	if (is_8023) {
 		fc = IEEE80211_FTYPE_DATA |
 		     (sta->wme ? IEEE80211_STYPE_QOS_DATA : IEEE80211_STYPE_DATA);
@@ -1058,16 +1111,17 @@ mt7996_tx_check_aggr(struct ieee80211_sta *sta, struct sk_buff *skb)
 		return;
 
 	msta = (struct mt7996_sta *)sta->drv_priv;
-	if (!test_and_set_bit(tid, &msta->wcid.ampdu_state))
+	mlink = rcu_dereference(msta->link[msta->pri_link]);
+	if (!test_and_set_bit(tid, &mlink->wcid.ampdu_state))
 		ieee80211_start_tx_ba_session(sta, tid, 0);
 }
 
 static void
 mt7996_txwi_free(struct mt7996_dev *dev, struct mt76_txwi_cache *t,
-		 struct ieee80211_sta *sta, struct list_head *free_list)
+		 struct ieee80211_sta *sta, struct mt76_wcid *wcid,
+		 struct list_head *free_list)
 {
 	struct mt76_dev *mdev = &dev->mt76;
-	struct mt76_wcid *wcid;
 	__le32 *txwi;
 	u16 wcid_idx;
 
@@ -1077,11 +1131,10 @@ mt7996_txwi_free(struct mt7996_dev *dev, struct mt76_txwi_cache *t,
 
 	txwi = (__le32 *)mt76_get_txwi_ptr(mdev, t);
 	if (sta) {
-		wcid = (struct mt76_wcid *)sta->drv_priv;
 		wcid_idx = wcid->idx;
 
 		if (likely(t->skb->protocol != cpu_to_be16(ETH_P_PAE)))
-			mt7996_tx_check_aggr(sta, t->skb);
+			mt7996_tx_check_aggr(sta, t->skb, wcid);
 	} else {
 		wcid_idx = le32_get_bits(txwi[9], MT_TXD9_WLAN_IDX);
 	}
@@ -1137,6 +1190,8 @@ mt7996_mac_tx_free(struct mt7996_dev *dev, void *data, int len)
 		info = le32_to_cpu(*cur_info);
 		if (info & MT_TXFREE_INFO_PAIR) {
 			struct mt7996_sta *msta;
+			unsigned long valid_links;
+			unsigned int link_id;
 			u16 idx;
 
 			idx = FIELD_GET(MT_TXFREE_INFO_WLAN_ID, info);
@@ -1145,8 +1200,18 @@ mt7996_mac_tx_free(struct mt7996_dev *dev, void *data, int len)
 			if (!sta)
 				continue;
 
-			msta = container_of(wcid, struct mt7996_sta, wcid);
-			mt76_wcid_add_poll(&dev->mt76, &msta->wcid);
+			valid_links = sta->valid_links ?: BIT(0);
+			msta = (struct mt7996_sta *)sta->drv_priv;
+			/* for MLD STA, add all link's wcid to sta_poll_list */
+			spin_lock_bh(&mdev->sta_poll_lock);
+			for_each_set_bit(link_id, &valid_links, IEEE80211_MLD_MAX_NUM_LINKS) {
+				struct mt7996_link_sta *mlink =
+					rcu_dereference(msta->link[link_id]);
+
+				if (mlink && list_empty(&mlink->wcid.poll_list))
+					list_add_tail(&mlink->wcid.poll_list, &mdev->sta_poll_list);
+			}
+			spin_unlock_bh(&mdev->sta_poll_lock);
 			continue;
 		} else if (info & MT_TXFREE_INFO_HEADER) {
 			u32 tx_retries = 0, tx_failed = 0;
@@ -1161,6 +1226,13 @@ mt7996_mac_tx_free(struct mt7996_dev *dev, void *data, int len)
 
 			wcid->stats.tx_retries += tx_retries;
 			wcid->stats.tx_failed += tx_failed;
+
+			if (FIELD_GET(MT_TXFREE_INFO_STAT, info) == 2) {
+				struct mt7996_phy *mphy =
+					__mt7996_phy(dev, wcid->phy_idx);
+
+				mphy->red_drop++;
+			}
 			continue;
 		}
 
@@ -1174,12 +1246,11 @@ mt7996_mac_tx_free(struct mt7996_dev *dev, void *data, int len)
 			if (!txwi)
 				continue;
 
-			mt7996_txwi_free(dev, txwi, sta, &free_list);
+			mt7996_txwi_free(dev, txwi, sta, wcid, &free_list);
+			txwi->jiffies = 0;
 		}
 	}
 
-	mt7996_mac_sta_poll(dev);
-
 	if (wake)
 		mt76_set_tx_blocked(&dev->mt76, false);
 
@@ -1214,6 +1285,10 @@ mt7996_mac_add_txs_skb(struct mt7996_dev *dev, struct mt76_wcid *wcid,
 	if (le32_get_bits(txs_data[0], MT_TXS0_TXS_FORMAT) == 0) {
 		skb = mt76_tx_status_skb_get(mdev, wcid, pid, &list);
 		if (skb) {
+			struct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;
+			struct mt7996_link_sta *mlink = wcid_to_mlink(wcid);
+			struct mt7996_vif *mvif;
+
 			info = IEEE80211_SKB_CB(skb);
 			if (!(txs & MT_TXS0_ACK_ERROR_MASK))
 				info->flags |= IEEE80211_TX_STAT_ACK;
@@ -1223,6 +1298,18 @@ mt7996_mac_add_txs_skb(struct mt7996_dev *dev, struct mt76_wcid *wcid,
 				!!(info->flags & IEEE80211_TX_STAT_ACK);
 
 			info->status.rates[0].idx = -1;
+
+			/* connection monitoring */
+			if (mlink && mlink->sta)
+				mvif = mlink->sta->vif;
+			if (ieee80211_is_nullfunc(hdr->frame_control) && mvif &&
+			    mvif->probe[wcid->phy_idx] == (void *)skb &&
+			    info->flags & IEEE80211_TX_STAT_ACK) {
+				/* reset beacon monitoring */
+				mvif->probe[wcid->phy_idx] = NULL;
+				mvif->beacon_received_time[wcid->phy_idx] = jiffies;
+				mvif->probe_send_count[wcid->phy_idx] = 0;
+			}
 		}
 	}
 
@@ -1230,7 +1317,7 @@ mt7996_mac_add_txs_skb(struct mt7996_dev *dev, struct mt76_wcid *wcid,
 		struct ieee80211_sta *sta;
 		u8 tid;
 
-		sta = container_of((void *)wcid, struct ieee80211_sta, drv_priv);
+		sta = wcid_to_sta(wcid);
 		tid = FIELD_GET(MT_TXS0_TID, txs);
 		ieee80211_refresh_tx_agg_session_timer(sta, tid);
 	}
@@ -1344,7 +1431,7 @@ out:
 
 static void mt7996_mac_add_txs(struct mt7996_dev *dev, void *data)
 {
-	struct mt7996_sta *msta = NULL;
+	struct mt7996_link_sta *mlink;
 	struct mt76_wcid *wcid;
 	__le32 *txs_data = data;
 	u16 wcidx;
@@ -1365,14 +1452,16 @@ static void mt7996_mac_add_txs(struct mt7996_dev *dev, void *data)
 	if (!wcid)
 		goto out;
 
-	msta = container_of(wcid, struct mt7996_sta, wcid);
-
 	mt7996_mac_add_txs_skb(dev, wcid, pid, txs_data);
 
 	if (!wcid->sta)
 		goto out;
 
-	mt76_wcid_add_poll(&dev->mt76, &msta->wcid);
+	mlink = wcid_to_mlink(wcid);
+	spin_lock_bh(&dev->mt76.sta_poll_lock);
+	if (list_empty(&mlink->wcid.poll_list))
+		list_add_tail(&mlink->wcid.poll_list, &dev->mt76.sta_poll_list);
+	spin_unlock_bh(&dev->mt76.sta_poll_lock);
 
 out:
 	rcu_read_unlock();
@@ -1414,9 +1503,11 @@ void mt7996_queue_rx_skb(struct mt76_dev *mdev, enum mt76_rxq_id q,
 			 struct sk_buff *skb, u32 *info)
 {
 	struct mt7996_dev *dev = container_of(mdev, struct mt7996_dev, mt76);
+	struct mt76_phy *phy;
 	__le32 *rxd = (__le32 *)skb->data;
 	__le32 *end = (__le32 *)&skb->data[skb->len];
 	enum rx_pkt_type type;
+	u8 band_idx;
 
 	type = le32_get_bits(rxd[0], MT_RXD0_PKT_TYPE);
 	if (type != PKT_TYPE_NORMAL) {
@@ -1451,12 +1542,23 @@ void mt7996_queue_rx_skb(struct mt76_dev *mdev, enum mt76_rxq_id q,
 		dev_kfree_skb(skb);
 		break;
 	case PKT_TYPE_NORMAL:
+		band_idx = le32_get_bits(rxd[1], MT_RXD1_NORMAL_BAND_IDX);
+		phy = mt76_dev_phy(mdev, band_idx);
+		spin_lock_bh(&phy->rx_dbg_stats.lock);
+		phy->rx_dbg_stats.rx_from_hw++;
+		spin_unlock_bh(&phy->rx_dbg_stats.lock);
+
 		if (!mt7996_mac_fill_rx(dev, q, skb, info)) {
 			mt76_rx(&dev->mt76, q, skb);
 			return;
 		}
 		fallthrough;
 	default:
+		band_idx = le32_get_bits(rxd[1], MT_RXD1_NORMAL_BAND_IDX);
+		phy = mt76_dev_phy(mdev, band_idx);
+		spin_lock_bh(&phy->rx_dbg_stats.lock);
+		phy->rx_dbg_stats.rx_drop[MT_RX_DROP_RXD_ERR]++;
+		spin_unlock_bh(&phy->rx_dbg_stats.lock);
 		dev_kfree_skb(skb);
 		break;
 	}
@@ -1589,16 +1691,29 @@ static void
 mt7996_update_vif_beacon(void *priv, u8 *mac, struct ieee80211_vif *vif)
 {
 	struct ieee80211_hw *hw = priv;
+	struct mt7996_dev *dev = mt7996_hw_dev(hw);
+	struct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;
+	unsigned long update = vif->valid_links ?: BIT(0);
+	unsigned int link_id;
 
+	mutex_lock(&dev->mt76.mutex);
 	switch (vif->type) {
 	case NL80211_IFTYPE_MESH_POINT:
 	case NL80211_IFTYPE_ADHOC:
 	case NL80211_IFTYPE_AP:
-		mt7996_mcu_add_beacon(hw, vif, &vif->bss_conf);
+		for_each_set_bit(link_id, &update, IEEE80211_MLD_MAX_NUM_LINKS) {
+			struct mt7996_bss_conf *mconf =
+					mconf_dereference_protected(mvif, link_id);
+			struct ieee80211_bss_conf *conf =
+					link_conf_dereference_protected(vif, link_id);
+
+			mt7996_mcu_add_beacon(hw, conf, mconf, conf->enable_beacon);
+		}
 		break;
 	default:
 		break;
 	}
+	mutex_unlock(&dev->mt76.mutex);
 }
 
 static void
@@ -1634,7 +1749,7 @@ void mt7996_tx_token_put(struct mt7996_dev *dev)
 
 	spin_lock_bh(&dev->mt76.token_lock);
 	idr_for_each_entry(&dev->mt76.token, txwi, id) {
-		mt7996_txwi_free(dev, txwi, NULL, NULL);
+		mt7996_txwi_free(dev, txwi, NULL, NULL, NULL);
 		dev->mt76.token_count--;
 	}
 	spin_unlock_bh(&dev->mt76.token_lock);
@@ -1727,6 +1842,31 @@ mt7996_mac_restart(struct mt7996_dev *dev)
 	if (ret)
 		goto out;
 
+	if (mtk_wed_device_active(&dev->mt76.mmio.wed) && dev->has_rro) {
+		u32 wed_irq_mask = dev->mt76.mmio.irqmask |
+				   MT_INT_RRO_RX_DONE |
+				   MT_INT_TX_DONE_BAND2;
+
+		mt7996_rro_hw_init(dev);
+		mt76_for_each_q_rx(&dev->mt76, i) {
+			if (mt76_queue_is_wed_rro_ind(&dev->mt76.q_rx[i]) ||
+			    mt76_queue_is_wed_rro_msdu_pg(&dev->mt76.q_rx[i]))
+				mt76_queue_rx_reset(dev, i);
+		}
+
+		mt76_wr(dev, MT_INT_MASK_CSR, wed_irq_mask);
+		mtk_wed_device_start_hw_rro(&dev->mt76.mmio.wed, wed_irq_mask, false);
+		mt7996_irq_enable(dev, wed_irq_mask);
+		mt7996_irq_disable(dev, 0);
+	}
+
+	if (mtk_wed_device_active(&dev->mt76.mmio.wed_hif2)) {
+		mt76_wr(dev, MT_INT_PCIE1_MASK_CSR,
+			MT_INT_TX_RX_DONE_EXT);
+		mtk_wed_device_start(&dev->mt76.mmio.wed_hif2,
+				     MT_INT_TX_RX_DONE_EXT);
+	}
+
 	/* set the necessary init items */
 	ret = mt7996_mcu_set_eeprom(dev);
 	if (ret)
@@ -1783,19 +1923,31 @@ mt7996_mac_full_reset(struct mt7996_dev *dev)
 	phy3 = mt7996_phy3(dev);
 	dev->recovery.hw_full_reset = true;
 
-	wake_up(&dev->mt76.mcu.wait);
 	ieee80211_stop_queues(mt76_hw(dev));
 	if (phy2)
 		ieee80211_stop_queues(phy2->mt76->hw);
 	if (phy3)
 		ieee80211_stop_queues(phy3->mt76->hw);
 
+	set_bit(MT76_RESET, &dev->mphy.state);
+	set_bit(MT76_MCU_RESET, &dev->mphy.state);
+	wake_up(&dev->mt76.mcu.wait);
+	if (phy2) {
+		set_bit(MT76_RESET, &phy2->mt76->state);
+		set_bit(MT76_MCU_RESET, &phy2->mt76->state);
+	}
+	if (phy3) {
+		set_bit(MT76_RESET, &phy3->mt76->state);
+		set_bit(MT76_MCU_RESET, &phy3->mt76->state);
+	}
+
 	cancel_work_sync(&dev->wed_rro.work);
 	cancel_delayed_work_sync(&dev->mphy.mac_work);
 	if (phy2)
 		cancel_delayed_work_sync(&phy2->mt76->mac_work);
 	if (phy3)
 		cancel_delayed_work_sync(&phy3->mt76->mac_work);
+	cancel_delayed_work_sync(&dev->scs_work);
 
 	mutex_lock(&dev->mt76.mutex);
 	for (i = 0; i < 10; i++) {
@@ -1831,6 +1983,7 @@ mt7996_mac_full_reset(struct mt7996_dev *dev)
 		ieee80211_queue_delayed_work(phy3->mt76->hw,
 					     &phy3->mt76->mac_work,
 					     MT7996_WATCHDOG_TIME);
+	ieee80211_queue_delayed_work(mt76_hw(dev), &dev->scs_work, HZ);
 }
 
 void mt7996_mac_reset_work(struct work_struct *work)
@@ -1871,6 +2024,7 @@ void mt7996_mac_reset_work(struct work_struct *work)
 	if (!(READ_ONCE(dev->recovery.state) & MT_MCU_CMD_STOP_DMA))
 		return;
 
+	dev->recovery.l1_reset_last = dev->recovery.l1_reset;
 	dev_info(dev->mt76.dev,"\n%s L1 SER recovery start.",
 		 wiphy_name(dev->mt76.hw->wiphy));
 
@@ -1880,21 +2034,22 @@ void mt7996_mac_reset_work(struct work_struct *work)
 	if (phy3)
 		ieee80211_stop_queues(phy3->mt76->hw);
 
+	dev_info(dev->mt76.dev,"%s L1 SER queue stop done.",
+		 wiphy_name(dev->mt76.hw->wiphy));
+
 	set_bit(MT76_RESET, &dev->mphy.state);
 	set_bit(MT76_MCU_RESET, &dev->mphy.state);
-	wake_up(&dev->mt76.mcu.wait);
-
-	cancel_work_sync(&dev->wed_rro.work);
-	cancel_delayed_work_sync(&dev->mphy.mac_work);
-	if (phy2) {
+	if (phy2)
 		set_bit(MT76_RESET, &phy2->mt76->state);
-		cancel_delayed_work_sync(&phy2->mt76->mac_work);
-	}
-	if (phy3) {
+	if (phy3)
 		set_bit(MT76_RESET, &phy3->mt76->state);
-		cancel_delayed_work_sync(&phy3->mt76->mac_work);
-	}
+	wake_up(&dev->mt76.mcu.wait);
+
 	mt76_worker_disable(&dev->mt76.tx_worker);
+
+	dev_info(dev->mt76.dev,"%s L1 SER disable tx_work done.",
+		 wiphy_name(dev->mt76.hw->wiphy));
+
 	mt76_for_each_q_rx(&dev->mt76, i) {
 		if (mtk_wed_device_active(&dev->mt76.mmio.wed) &&
 		    mt76_queue_is_wed_rro(&dev->mt76.q_rx[i]))
@@ -1904,16 +2059,30 @@ void mt7996_mac_reset_work(struct work_struct *work)
 	}
 	napi_disable(&dev->mt76.tx_napi);
 
-	mutex_lock(&dev->mt76.mutex);
+	dev_info(dev->mt76.dev,"%s L1 SER napi disable done.",
+		 wiphy_name(dev->mt76.hw->wiphy));
 
 	mt76_wr(dev, MT_MCU_INT_EVENT, MT_MCU_INT_EVENT_DMA_STOPPED);
 
+	dev_info(dev->mt76.dev,"%s L1 SER dma stop done.",
+		 wiphy_name(dev->mt76.hw->wiphy));
+
 	if (mt7996_wait_reset_state(dev, MT_MCU_CMD_RESET_DONE)) {
 		mt7996_dma_reset(dev, false);
 
+		dev_info(dev->mt76.dev,"%s L1 SER dma reset done.",
+			wiphy_name(dev->mt76.hw->wiphy));
+
 		mt7996_tx_token_put(dev);
+
+		dev_info(dev->mt76.dev,"%s L1 SER token put done.",
+			wiphy_name(dev->mt76.hw->wiphy));
+
 		idr_init(&dev->mt76.token);
 
+		dev_info(dev->mt76.dev,"%s L1 SER idr init done.",
+			wiphy_name(dev->mt76.hw->wiphy));
+
 		mt76_wr(dev, MT_MCU_INT_EVENT, MT_MCU_INT_EVENT_DMA_INIT);
 		mt7996_wait_reset_state(dev, MT_MCU_CMD_RECOVERY_DONE);
 	}
@@ -1924,6 +2093,9 @@ void mt7996_mac_reset_work(struct work_struct *work)
 	/* enable DMA Tx/Tx and interrupt */
 	mt7996_dma_start(dev, false, false);
 
+	dev_info(dev->mt76.dev,"%s L1 SER dma start done.",
+		 wiphy_name(dev->mt76.hw->wiphy));
+
 	if (mtk_wed_device_active(&dev->mt76.mmio.wed)) {
 		u32 wed_irq_mask = MT_INT_RRO_RX_DONE | MT_INT_TX_DONE_BAND2 |
 				   dev->mt76.mmio.irqmask;
@@ -1933,8 +2105,13 @@ void mt7996_mac_reset_work(struct work_struct *work)
 
 		mt76_wr(dev, MT_INT_MASK_CSR, wed_irq_mask);
 
+		if (is_mt7992(&dev->mt76) && dev->has_rro)
+			mt76_wr(dev, MT_RRO_3_0_EMU_CONF,
+				MT_RRO_3_0_EMU_CONF_EN_MASK);
+
 		mtk_wed_device_start_hw_rro(&dev->mt76.mmio.wed, wed_irq_mask,
 					    true);
+
 		mt7996_irq_enable(dev, wed_irq_mask);
 		mt7996_irq_disable(dev, 0);
 	}
@@ -1945,6 +2122,9 @@ void mt7996_mac_reset_work(struct work_struct *work)
 				     MT_INT_TX_RX_DONE_EXT);
 	}
 
+	dev_info(dev->mt76.dev,"%s L1 SER wed start done.",
+		 wiphy_name(dev->mt76.hw->wiphy));
+
 	clear_bit(MT76_MCU_RESET, &dev->mphy.state);
 	clear_bit(MT76_RESET, &dev->mphy.state);
 	if (phy2)
@@ -1978,47 +2158,32 @@ void mt7996_mac_reset_work(struct work_struct *work)
 	if (phy3)
 		ieee80211_wake_queues(phy3->mt76->hw);
 
-	mutex_unlock(&dev->mt76.mutex);
-
 	mt7996_update_beacons(dev);
 
-	ieee80211_queue_delayed_work(mt76_hw(dev), &dev->mphy.mac_work,
-				     MT7996_WATCHDOG_TIME);
-	if (phy2)
-		ieee80211_queue_delayed_work(phy2->mt76->hw,
-					     &phy2->mt76->mac_work,
-					     MT7996_WATCHDOG_TIME);
-	if (phy3)
-		ieee80211_queue_delayed_work(phy3->mt76->hw,
-					     &phy3->mt76->mac_work,
-					     MT7996_WATCHDOG_TIME);
 	dev_info(dev->mt76.dev,"\n%s L1 SER recovery completed.",
 		 wiphy_name(dev->mt76.hw->wiphy));
 }
 
 /* firmware coredump */
-void mt7996_mac_dump_work(struct work_struct *work)
+void mt7996_mac_fw_coredump(struct mt7996_dev *dev, u8 type)
 {
 	const struct mt7996_mem_region *mem_region;
 	struct mt7996_crash_data *crash_data;
-	struct mt7996_dev *dev;
 	struct mt7996_mem_hdr *hdr;
 	size_t buf_len;
 	int i;
 	u32 num;
 	u8 *buf;
 
-	dev = container_of(work, struct mt7996_dev, dump_work);
-
 	mutex_lock(&dev->dump_mutex);
 
-	crash_data = mt7996_coredump_new(dev);
+	crash_data = mt7996_coredump_new(dev, type);
 	if (!crash_data) {
 		mutex_unlock(&dev->dump_mutex);
-		goto skip_coredump;
+		return;
 	}
 
-	mem_region = mt7996_coredump_get_mem_layout(dev, &num);
+	mem_region = mt7996_coredump_get_mem_layout(dev, type, &num);
 	if (!mem_region || !crash_data->memdump_buf_len) {
 		mutex_unlock(&dev->dump_mutex);
 		goto skip_memdump;
@@ -2028,6 +2193,9 @@ void mt7996_mac_dump_work(struct work_struct *work)
 	buf_len = crash_data->memdump_buf_len;
 
 	/* dumping memory content... */
+	dev_info(dev->mt76.dev, "%s start coredump for %s\n",
+		 wiphy_name(dev->mt76.hw->wiphy),
+		 ((type == MT7996_RAM_TYPE_WA) ? "WA" : "WM"));
 	memset(buf, 0, buf_len);
 	for (i = 0; i < num; i++) {
 		if (mem_region->len > buf_len) {
@@ -2044,6 +2212,7 @@ void mt7996_mac_dump_work(struct work_struct *work)
 		mt7996_memcpy_fromio(dev, buf, mem_region->start,
 				     mem_region->len);
 
+		strscpy(hdr->name, mem_region->name, sizeof(mem_region->name));
 		hdr->start = mem_region->start;
 		hdr->len = mem_region->len;
 
@@ -2060,13 +2229,49 @@ void mt7996_mac_dump_work(struct work_struct *work)
 	mutex_unlock(&dev->dump_mutex);
 
 skip_memdump:
-	mt7996_coredump_submit(dev);
-skip_coredump:
-	queue_work(dev->mt76.wq, &dev->reset_work);
+	mt7996_coredump_submit(dev, type);
+}
+
+void mt7996_mac_dump_work(struct work_struct *work)
+{
+	struct mt7996_dev *dev;
+
+	dev = container_of(work, struct mt7996_dev, dump_work);
+	if (dev->dump_state == MT7996_COREDUMP_MANUAL_WA ||
+	    READ_ONCE(dev->recovery.state) & MT_MCU_CMD_WA_WDT)
+		mt7996_mac_fw_coredump(dev, MT7996_RAM_TYPE_WA);
+
+	if (dev->dump_state == MT7996_COREDUMP_MANUAL_WM ||
+	    READ_ONCE(dev->recovery.state) & MT_MCU_CMD_WM_WDT)
+		mt7996_mac_fw_coredump(dev, MT7996_RAM_TYPE_WM);
+
+	if (READ_ONCE(dev->recovery.state) & MT_MCU_CMD_WDT_MASK)
+		queue_work(dev->mt76.wq, &dev->reset_work);
+
+	dev->dump_state = MT7996_COREDUMP_IDLE;
 }
 
+void mt7996_coredump(struct mt7996_dev *dev, u8 state)
+{
+	if (state == MT7996_COREDUMP_IDLE ||
+	    state >= __MT7996_COREDUMP_TYPE_MAX)
+		return;
+
+	if (dev->dump_state != MT7996_COREDUMP_IDLE)
+		return;
+
+	dev->dump_state = state;
+	dev_info(dev->mt76.dev, "%s attempting grab coredump\n",
+		 wiphy_name(dev->mt76.hw->wiphy));
+
+	queue_work(dev->mt76.wq, &dev->dump_work);
+ }
+
 void mt7996_reset(struct mt7996_dev *dev)
 {
+	dev_info(dev->mt76.dev, "%s SER recovery state: 0x%08x\n",
+		 wiphy_name(dev->mt76.hw->wiphy), READ_ONCE(dev->recovery.state));
+
 	if (!dev->recovery.hw_init_done)
 		return;
 
@@ -2082,9 +2287,13 @@ void mt7996_reset(struct mt7996_dev *dev)
 
 		mt7996_irq_disable(dev, MT_INT_MCU_CMD);
 		queue_work(dev->mt76.wq, &dev->dump_work);
+		mt7996_coredump(dev, MT7996_COREDUMP_AUTO);
 		return;
 	}
 
+	if ((READ_ONCE(dev->recovery.state) & MT_MCU_CMD_STOP_DMA))
+		dev->recovery.l1_reset++;
+
 	queue_work(dev->mt76.wq, &dev->reset_work);
 	wake_up(&dev->reset_wait);
 }
@@ -2093,10 +2302,19 @@ void mt7996_mac_update_stats(struct mt7996_phy *phy)
 {
 	struct mt76_mib_stats *mib = &phy->mib;
 	struct mt7996_dev *dev = phy->dev;
+	struct mt76_mib_stats *main_mib = &dev->phy.mib;
 	u8 band_idx = phy->mt76->band_idx;
 	u32 cnt;
 	int i;
 
+	/* Update per-dev structures */
+	for (i = 0; i < ARRAY_SIZE(main_mib->tx_amsdu); i++) {
+		cnt = mt76_rr(dev, MT_PLE_AMSDU_PACK_MSDU_CNT(i));
+		main_mib->tx_amsdu[i] += cnt;
+		main_mib->tx_amsdu_cnt += cnt;
+	}
+
+	/* Update per-phy structures */
 	cnt = mt76_rr(dev, MT_MIB_RSCR1(band_idx));
 	mib->fcs_err_cnt += cnt;
 
@@ -2202,12 +2420,6 @@ void mt7996_mac_update_stats(struct mt7996_phy *phy)
 	cnt = mt76_rr(dev, MT_MIB_BSCR17(band_idx));
 	mib->tx_bf_fb_cpl_cnt += cnt;
 
-	for (i = 0; i < ARRAY_SIZE(mib->tx_amsdu); i++) {
-		cnt = mt76_rr(dev, MT_PLE_AMSDU_PACK_MSDU_CNT(i));
-		mib->tx_amsdu[i] += cnt;
-		mib->tx_amsdu_cnt += cnt;
-	}
-
 	/* rts count */
 	cnt = mt76_rr(dev, MT_MIB_BTSCR5(band_idx));
 	mib->rts_cnt += cnt;
@@ -2230,70 +2442,114 @@ void mt7996_mac_update_stats(struct mt7996_phy *phy)
 	}
 }
 
+void mt7996_set_wireless_amsdu(struct ieee80211_hw *hw, u8 en)
+{
+	if (en)
+		ieee80211_hw_set(hw, SUPPORTS_AMSDU_IN_AMPDU);
+	else
+		ieee80211_hw_clear(hw, SUPPORTS_AMSDU_IN_AMPDU);
+}
+
 void mt7996_mac_sta_rc_work(struct work_struct *work)
 {
 	struct mt7996_dev *dev = container_of(work, struct mt7996_dev, rc_work);
 	struct ieee80211_sta *sta;
 	struct ieee80211_vif *vif;
-	struct mt7996_sta *msta;
+	struct ieee80211_bss_conf *conf;
+	struct ieee80211_link_sta *link_sta;
+	struct mt7996_bss_conf *mconf;
+	struct mt7996_link_sta *mlink;
 	u32 changed;
 	LIST_HEAD(list);
 
+	rcu_read_lock();
 	spin_lock_bh(&dev->mt76.sta_poll_lock);
 	list_splice_init(&dev->sta_rc_list, &list);
 
 	while (!list_empty(&list)) {
-		msta = list_first_entry(&list, struct mt7996_sta, rc_list);
-		list_del_init(&msta->rc_list);
-		changed = msta->changed;
-		msta->changed = 0;
+		u8 link_id;
+
+		mlink = list_first_entry(&list, struct mt7996_link_sta, rc_list);
+		link_id = mlink->wcid.link_id;
+
+		list_del_init(&mlink->rc_list);
+		changed = mlink->changed;
+		mlink->changed = 0;
 		spin_unlock_bh(&dev->mt76.sta_poll_lock);
 
-		sta = container_of((void *)msta, struct ieee80211_sta, drv_priv);
-		vif = container_of((void *)msta->vif, struct ieee80211_vif, drv_priv);
+		vif = container_of((void *)mlink->sta->vif, struct ieee80211_vif, drv_priv);
+		conf = rcu_dereference(vif->link_conf[link_id]);
+		mconf = rcu_dereference(mlink->sta->vif->link[link_id]);
+		sta = wcid_to_sta(&mlink->wcid);
+		link_sta = rcu_dereference(sta->link[link_id]);
+
+		if (unlikely(!conf || !mconf || !link_sta)) {
+			spin_lock_bh(&dev->mt76.sta_poll_lock);
+			continue;
+		}
 
 		if (changed & (IEEE80211_RC_SUPP_RATES_CHANGED |
 			       IEEE80211_RC_NSS_CHANGED |
 			       IEEE80211_RC_BW_CHANGED))
-			mt7996_mcu_add_rate_ctrl(dev, vif, sta, true);
+			mt7996_mcu_add_rate_ctrl(dev, conf, mconf, link_sta, mlink, true);
 
 		if (changed & IEEE80211_RC_SMPS_CHANGED)
-			mt7996_mcu_set_fixed_field(dev, vif, sta, NULL,
+			mt7996_mcu_set_fixed_field(dev, mconf, link_sta, mlink, NULL,
 						   RATE_PARAM_MMPS_UPDATE);
 
 		spin_lock_bh(&dev->mt76.sta_poll_lock);
 	}
 
 	spin_unlock_bh(&dev->mt76.sta_poll_lock);
+	rcu_read_unlock();
 }
 
 void mt7996_mac_work(struct work_struct *work)
 {
-	struct mt7996_phy *phy;
-	struct mt76_phy *mphy;
-
-	mphy = (struct mt76_phy *)container_of(work, struct mt76_phy,
-					       mac_work.work);
-	phy = mphy->priv;
+	struct mt76_phy *mphy = (struct mt76_phy *)container_of(work, struct mt76_phy,
+	                                                        mac_work.work);
+	struct mt7996_phy *phy = mphy->priv;
+	struct mt76_dev *mdev = mphy->dev;
 
-	mutex_lock(&mphy->dev->mutex);
+	mutex_lock(&mdev->mutex);
 
 	mt76_update_survey(mphy);
-	if (++mphy->mac_work_count == 5) {
-		mphy->mac_work_count = 0;
+	if (++mphy->mac_work_count % 5 == 0) {
+		int i;
 
 		mt7996_mac_update_stats(phy);
 
-		mt7996_mcu_get_all_sta_info(phy, UNI_ALL_STA_TXRX_RATE);
-		if (mtk_wed_device_active(&phy->dev->mt76.mmio.wed)) {
-			mt7996_mcu_get_all_sta_info(phy, UNI_ALL_STA_TXRX_ADM_STAT);
-			mt7996_mcu_get_all_sta_info(phy, UNI_ALL_STA_TXRX_MSDU_COUNT);
+		/* Update DEV-wise information only in
+		 * the MAC work of the first band running.
+		 */
+		for (i = MT_BAND0; i <= mphy->band_idx; ++i) {
+			if (i == mphy->band_idx) {
+				mt7996_mcu_get_all_sta_info(mdev, UNI_ALL_STA_TXRX_RATE);
+				mt7996_mcu_get_all_sta_info(mdev, UNI_ALL_STA_TXRX_AIRTIME);
+				mt7996_mcu_get_rssi(mdev);
+				// if (mtk_wed_device_active(&mdev->mmio.wed)) {
+					mt7996_mcu_get_all_sta_info(mdev, UNI_ALL_STA_TXRX_ADM_STAT);
+					mt7996_mcu_get_all_sta_info(mdev, UNI_ALL_STA_TXRX_MSDU_COUNT);
+				// }
+
+				if (mt7996_mcu_wa_cmd(phy->dev, MCU_WA_PARAM_CMD(QUERY), MCU_WA_PARAM_BSS_ACQ_PKT_CNT,
+				                      BSS_ACQ_PKT_CNT_BSS_BITMAP_ALL | BSS_ACQ_PKT_CNT_READ_CLR, 0))
+					dev_err(mdev->dev, "Failed to query per-AC-queue packet counts.\n");
+
+				if (mphy->mac_work_count == 100) {
+					if (phy->dev->idxlog_enable && mt7996_mcu_fw_time_sync(mdev))
+						dev_err(mdev->dev, "Failed to synchronize time with FW.\n");
+					mphy->mac_work_count = 0;
+				}
+			} else if (mt7996_band_valid(phy->dev, i) &&
+			           test_bit(MT76_STATE_RUNNING, &mdev->phys[i]->state))
+				break;
 		}
 	}
 
-	mutex_unlock(&mphy->dev->mutex);
+	mutex_unlock(&mdev->mutex);
 
-	mt76_tx_status_check(mphy->dev, false);
+	mt76_tx_status_check(mdev, false);
 
 	ieee80211_queue_delayed_work(mphy->hw, &mphy->mac_work,
 				     MT7996_WATCHDOG_TIME);
@@ -2532,7 +2788,7 @@ static int mt7996_mac_check_twt_req(struct ieee80211_twt_setup *twt)
 }
 
 static bool
-mt7996_mac_twt_param_equal(struct mt7996_sta *msta,
+mt7996_mac_twt_param_equal(struct mt7996_link_sta *mlink,
 			   struct ieee80211_twt_params *twt_agrt)
 {
 	u16 type = le16_to_cpu(twt_agrt->req_type);
@@ -2543,10 +2799,10 @@ mt7996_mac_twt_param_equal(struct mt7996_sta *msta,
 	for (i = 0; i < MT7996_MAX_STA_TWT_AGRT; i++) {
 		struct mt7996_twt_flow *f;
 
-		if (!(msta->twt.flowid_mask & BIT(i)))
+		if (!(mlink->twt.flowid_mask & BIT(i)))
 			continue;
 
-		f = &msta->twt.flow[i];
+		f = &mlink->twt.flow[i];
 		if (f->duration == twt_agrt->min_twt_dur &&
 		    f->mantissa == twt_agrt->mantissa &&
 		    f->exp == exp &&
@@ -2565,6 +2821,7 @@ void mt7996_mac_add_twt_setup(struct ieee80211_hw *hw,
 {
 	enum ieee80211_twt_setup_cmd setup_cmd = TWT_SETUP_CMD_REJECT;
 	struct mt7996_sta *msta = (struct mt7996_sta *)sta->drv_priv;
+	struct mt7996_link_sta *mlink;
 	struct ieee80211_twt_params *twt_agrt = (void *)twt->params;
 	u16 req_type = le16_to_cpu(twt_agrt->req_type);
 	enum ieee80211_twt_setup_cmd sta_setup_cmd;
@@ -2576,11 +2833,12 @@ void mt7996_mac_add_twt_setup(struct ieee80211_hw *hw,
 		goto out;
 
 	mutex_lock(&dev->mt76.mutex);
+	mlink = mlink_dereference_protected(msta, 0);
 
 	if (dev->twt.n_agrt == MT7996_MAX_TWT_AGRT)
 		goto unlock;
 
-	if (hweight8(msta->twt.flowid_mask) == ARRAY_SIZE(msta->twt.flow))
+	if (hweight8(mlink->twt.flowid_mask) == ARRAY_SIZE(mlink->twt.flow))
 		goto unlock;
 
 	if (twt_agrt->min_twt_dur < MT7996_MIN_TWT_DUR) {
@@ -2589,10 +2847,10 @@ void mt7996_mac_add_twt_setup(struct ieee80211_hw *hw,
 		goto unlock;
 	}
 
-	if (mt7996_mac_twt_param_equal(msta, twt_agrt))
+	if (mt7996_mac_twt_param_equal(mlink, twt_agrt))
 		goto unlock;
 
-	flowid = ffs(~msta->twt.flowid_mask) - 1;
+	flowid = ffs(~mlink->twt.flowid_mask) - 1;
 	twt_agrt->req_type &= ~cpu_to_le16(IEEE80211_TWT_REQTYPE_FLOWID);
 	twt_agrt->req_type |= le16_encode_bits(flowid,
 					       IEEE80211_TWT_REQTYPE_FLOWID);
@@ -2601,10 +2859,10 @@ void mt7996_mac_add_twt_setup(struct ieee80211_hw *hw,
 	exp = FIELD_GET(IEEE80211_TWT_REQTYPE_WAKE_INT_EXP, req_type);
 	sta_setup_cmd = FIELD_GET(IEEE80211_TWT_REQTYPE_SETUP_CMD, req_type);
 
-	flow = &msta->twt.flow[flowid];
+	flow = &mlink->twt.flow[flowid];
 	memset(flow, 0, sizeof(*flow));
 	INIT_LIST_HEAD(&flow->list);
-	flow->wcid = msta->wcid.idx;
+	flow->wcid = mlink->wcid.idx;
 	flow->table_id = table_id;
 	flow->id = flowid;
 	flow->duration = twt_agrt->min_twt_dur;
@@ -2622,7 +2880,7 @@ void mt7996_mac_add_twt_setup(struct ieee80211_hw *hw,
 
 		flow->sched = true;
 		flow->start_tsf = mt7996_mac_twt_sched_list_add(dev, flow);
-		curr_tsf = __mt7996_get_tsf(hw, msta->vif);
+		curr_tsf = __mt7996_get_tsf(hw, &mlink->sta->vif->deflink);
 		div_u64_rem(curr_tsf - flow->start_tsf, interval, &rem);
 		flow_tsf = curr_tsf + interval - rem;
 		twt_agrt->twt = cpu_to_le64(flow_tsf);
@@ -2631,12 +2889,13 @@ void mt7996_mac_add_twt_setup(struct ieee80211_hw *hw,
 	}
 	flow->tsf = le64_to_cpu(twt_agrt->twt);
 
-	if (mt7996_mcu_twt_agrt_update(dev, msta->vif, flow, MCU_TWT_AGRT_ADD))
+	if (mt7996_mcu_twt_agrt_update(dev, &mlink->sta->vif->deflink, flow,
+				       MCU_TWT_AGRT_ADD))
 		goto unlock;
 
 	setup_cmd = TWT_SETUP_CMD_ACCEPT;
 	dev->twt.table_mask |= BIT(table_id);
-	msta->twt.flowid_mask |= BIT(flowid);
+	mlink->twt.flowid_mask |= BIT(flowid);
 	dev->twt.n_agrt++;
 
 unlock:
@@ -2649,26 +2908,347 @@ out:
 }
 
 void mt7996_mac_twt_teardown_flow(struct mt7996_dev *dev,
-				  struct mt7996_sta *msta,
-				  u8 flowid)
+				  struct mt7996_link_sta *mlink, u8 flowid)
 {
 	struct mt7996_twt_flow *flow;
+	struct mt7996_bss_conf *mconf = mconf_dereference_protected(mlink->sta->vif, 0);
 
 	lockdep_assert_held(&dev->mt76.mutex);
 
-	if (flowid >= ARRAY_SIZE(msta->twt.flow))
+	if (flowid >= ARRAY_SIZE(mlink->twt.flow))
 		return;
 
-	if (!(msta->twt.flowid_mask & BIT(flowid)))
+	if (!(mlink->twt.flowid_mask & BIT(flowid)))
 		return;
 
-	flow = &msta->twt.flow[flowid];
-	if (mt7996_mcu_twt_agrt_update(dev, msta->vif, flow,
-				       MCU_TWT_AGRT_DELETE))
+	flow = &mlink->twt.flow[flowid];
+	if (mt7996_mcu_twt_agrt_update(dev, mconf, flow, MCU_TWT_AGRT_DELETE))
 		return;
 
 	list_del_init(&flow->list);
-	msta->twt.flowid_mask &= ~BIT(flowid);
+	mlink->twt.flowid_mask &= ~BIT(flowid);
 	dev->twt.table_mask &= ~BIT(flow->table_id);
 	dev->twt.n_agrt--;
 }
+
+static void
+mt7996_scan_send_probe(struct mt7996_phy *phy, struct cfg80211_ssid *ssid,
+		       const u8 *dst)
+{
+	struct cfg80211_scan_request *req = phy->scan_req;
+	struct ieee80211_vif *vif = phy->scan_vif;
+	struct ieee80211_bss_conf *conf;
+	struct mt7996_vif *mvif;
+	struct mt7996_link_sta *mlink;
+	struct ieee80211_tx_info *info;
+	struct ieee80211_hw *hw;
+	struct sk_buff *skb;
+	unsigned long valid_links;
+	unsigned int link_id;
+
+	if (!req || !vif)
+		return;
+
+	valid_links = vif->valid_links ?: BIT(0);
+	mvif = (struct mt7996_vif *)vif->drv_priv;
+	hw = phy->mt76->hw;
+
+	rcu_read_lock();
+
+	for_each_set_bit(link_id, &valid_links, IEEE80211_MLD_MAX_NUM_LINKS) {
+		conf = rcu_dereference(vif->link_conf[link_id]);
+		mlink = rcu_dereference(mvif->sta.link[link_id]);
+		if (mlink->wcid.phy_idx != phy->mt76->band_idx)
+			continue;
+	}
+
+	if (unlikely(!conf))
+		goto unlock;
+
+	skb = ieee80211_probereq_get(hw, conf->addr,
+				     ssid->ssid, ssid->ssid_len, req->ie_len);
+	if (!skb)
+		goto unlock;
+
+	if (is_unicast_ether_addr(dst)) {
+		struct ieee80211_hdr_3addr *hdr =
+			(struct ieee80211_hdr_3addr *)skb->data;
+		memcpy(hdr->addr1, dst, ETH_ALEN);
+		memcpy(hdr->addr3, dst, ETH_ALEN);
+	}
+
+	info = IEEE80211_SKB_CB(skb);
+	if (req->no_cck)
+		info->flags |= IEEE80211_TX_CTL_NO_CCK_RATE;
+
+	if (req->ie_len)
+		skb_put_data(skb, req->ie, req->ie_len);
+
+	skb_set_queue_mapping(skb, IEEE80211_AC_VO);
+
+	if (!ieee80211_tx_prepare_skb(hw, vif, skb,
+				      phy->scan_chan->band, NULL)) {
+		rcu_read_unlock();
+		ieee80211_free_txskb(hw, skb);
+		return;
+	}
+
+	local_bh_disable();
+	mt76_tx(phy->mt76, NULL, &mlink->wcid, skb);
+	local_bh_enable();
+
+unlock:
+	rcu_read_unlock();
+}
+
+static void mt7996_scan_check_sta(void *data, struct ieee80211_sta *sta)
+{
+	bool *has_sta = data;
+
+	if (*has_sta)
+		return;
+	*has_sta = true;
+}
+
+void mt7996_scan_work(struct work_struct *work)
+{
+	struct mt7996_phy *phy = container_of(work, struct mt7996_phy, scan_work.work);
+	struct ieee80211_hw *hw = phy->mt76->hw;
+	struct cfg80211_scan_request *req = phy->scan_req;
+	struct cfg80211_chan_def chandef = {};
+	int duration;
+	bool has_sta = false, active_scan = false;
+
+	mutex_lock(&phy->dev->mt76.mutex);
+
+	if (phy->scan_chan_idx >= req->n_channels) {
+		mt7996_scan_complete(phy, false);
+		mutex_unlock(&phy->dev->mt76.mutex);
+
+		if (phy->chanctx)
+			mt7996_set_channel(phy, &phy->chanctx->chandef);
+		else
+			mt7996_set_channel(phy, &phy->mt76->chandef);
+
+		return;
+	}
+
+	ieee80211_iterate_stations_atomic(hw, mt7996_scan_check_sta, &has_sta);
+
+	/* go back to operating channel */
+	if (has_sta && phy->scan_chan) {
+		phy->scan_chan = NULL;
+		mutex_unlock(&phy->dev->mt76.mutex);
+
+		if (phy->chanctx)
+			mt7996_set_channel(phy, &phy->chanctx->chandef);
+		else
+			mt7996_set_channel(phy, &phy->mt76->chandef);
+
+		ieee80211_queue_delayed_work(hw, &phy->scan_work, HZ / 10);
+
+		return;
+	}
+
+	wiphy_info(hw->wiphy, "hw scan %d MHz\n",
+		   req->channels[phy->scan_chan_idx]->center_freq);
+
+	phy->scan_chan = req->channels[phy->scan_chan_idx++];
+
+	if (!req->n_ssids ||
+	    (phy->scan_chan->flags & (IEEE80211_CHAN_NO_IR |
+				      IEEE80211_CHAN_RADAR))) {
+		duration = HZ / 9; /* ~110 ms */
+	} else {
+		duration = HZ / 16; /* ~60 ms */
+		active_scan = true;
+	}
+
+	cfg80211_chandef_create(&chandef, phy->scan_chan, NL80211_CHAN_HT20);
+	mutex_unlock(&phy->dev->mt76.mutex);
+
+	mt7996_set_channel(phy, &chandef);
+
+	if (active_scan) {
+		int i;
+
+		mutex_lock(&phy->dev->mt76.mutex);
+		for (i = 0; i < req->n_ssids; i++)
+			mt7996_scan_send_probe(phy, &req->ssids[i], req->bssid);
+		mutex_unlock(&phy->dev->mt76.mutex);
+	}
+
+	ieee80211_queue_delayed_work(hw, &phy->scan_work, duration);
+}
+
+static int
+mt7996_beacon_mon_send_probe(struct mt7996_phy *phy, struct mt7996_vif *mvif,
+			     struct ieee80211_bss_conf *conf, unsigned int link_id)
+{
+	struct ieee80211_vif *vif = container_of((void *)mvif, struct ieee80211_vif, drv_priv);
+	struct ieee80211_hw *hw = phy->mt76->hw;
+	struct mt7996_link_sta *mlink;
+	struct ieee80211_tx_info *info;
+	struct sk_buff *skb;
+	int ret = 0, band_idx = phy->mt76->band_idx;
+	int band;
+
+	rcu_read_lock();
+
+	mlink = rcu_dereference(mvif->sta.link[link_id]);
+	if (!mlink || mlink->wcid.phy_idx != band_idx) {
+		ret = -EINVAL;
+		goto unlock;
+	}
+
+	if (!ieee80211_hw_check(hw, REPORTS_TX_ACK_STATUS)) {
+		/* probe request is not supported yet */
+		ret = -EOPNOTSUPP;
+		goto unlock;
+	}
+
+	/* FIXME: bss conf should not be all-zero before beacon mon work is canecled */
+	if (!is_valid_ether_addr(conf->bssid) ||
+	    !is_valid_ether_addr(conf->addr)) {
+		/* invalid address */
+		ret = -EINVAL;
+		goto unlock;
+	}
+
+	skb = ieee80211_nullfunc_get(hw, vif, link_id, false);
+	if (!skb) {
+		ret = -ENOMEM;
+		goto unlock;
+	}
+
+	info = IEEE80211_SKB_CB(skb);
+	/* frame injected by driver */
+	info->flags |= (IEEE80211_TX_CTL_REQ_TX_STATUS |
+			IEEE80211_TX_CTL_INJECTED |
+			IEEE80211_TX_CTL_NO_PS_BUFFER);
+	if (ieee80211_vif_is_mld(vif))
+		info->control.flags |= u32_encode_bits(link_id, IEEE80211_TX_CTRL_MLO_LINK);
+
+	if (phy->chanctx)
+		band = phy->chanctx->chandef.chan->band;
+	else
+		band = phy->mt76->chandef.chan->band;
+
+	skb_set_queue_mapping(skb, IEEE80211_AC_VO);
+	if (!ieee80211_tx_prepare_skb(hw, vif, skb, band, NULL)) {
+		rcu_read_unlock();
+		ieee80211_free_txskb(hw, skb);
+		return -EINVAL;
+	}
+
+	local_bh_disable();
+	mt76_tx(phy->mt76, NULL, &mlink->wcid, skb);
+	local_bh_enable();
+
+	mvif->probe[band_idx] = (void *)skb;
+	mvif->probe_send_count[band_idx]++;
+	mvif->probe_send_time[band_idx] = jiffies;
+
+unlock:
+	rcu_read_unlock();
+	return ret;
+}
+
+void mt7996_beacon_mon_work(struct work_struct *work)
+{
+	struct mt7996_vif *mvif = container_of(work, struct mt7996_vif, beacon_mon_work.work);
+	struct ieee80211_vif *vif = container_of((void *)mvif, struct ieee80211_vif, drv_priv);
+	struct mt7996_dev *dev = mvif->dev;
+	struct ieee80211_hw *hw = mt76_hw(dev);
+	unsigned long next_time = ULONG_MAX, valid_links = vif->valid_links ?: BIT(0);
+	unsigned int link_id;
+	enum monitor_state {
+		MON_STATE_BEACON_MON,
+		MON_STATE_SEND_PROBE,
+		MON_STATE_LINK_LOST,
+		MON_STATE_DISCONN,
+	};
+
+	mutex_lock(&dev->mt76.mutex);
+
+	for_each_set_bit(link_id, &valid_links, IEEE80211_MLD_MAX_NUM_LINKS) {
+		struct ieee80211_bss_conf *conf;
+		struct mt7996_bss_conf *mconf;
+		struct mt7996_phy *phy;
+		unsigned long timeout, loss_duration;
+		int band_idx;
+		enum monitor_state state = MON_STATE_BEACON_MON;
+
+		conf = link_conf_dereference_protected(vif, link_id);
+		mconf = mconf_dereference_protected(mvif, link_id);
+		if (!conf || !mconf)
+			continue;
+
+		/* skip lost links */
+		if (mvif->lost_links & BIT(link_id))
+			continue;
+
+		phy = mconf->phy;
+		band_idx = phy->mt76->band_idx;
+		if (mvif->probe[band_idx]) {
+			loss_duration = msecs_to_jiffies(MT7996_MAX_PROBE_TIMEOUT);
+			timeout = mvif->probe_send_time[band_idx] + loss_duration;
+			if (time_after_eq(jiffies, timeout)) {
+				if (mvif->probe_send_count[band_idx] == MT7996_MAX_PROBE_TRIES)
+					state = MON_STATE_LINK_LOST;
+				else
+					state = MON_STATE_SEND_PROBE;
+			}
+		} else {
+			loss_duration = msecs_to_jiffies(MT7996_MAX_BEACON_LOSS *
+							 conf->beacon_int);
+			timeout = mvif->beacon_received_time[band_idx] + loss_duration;
+			if (time_after_eq(jiffies, timeout)) {
+				wiphy_info(hw->wiphy, "link %d: detect %d beacon loss\n",
+					   link_id, MT7996_MAX_BEACON_LOSS);
+				state = MON_STATE_SEND_PROBE;
+			}
+		}
+
+		switch (state) {
+		case MON_STATE_BEACON_MON:
+			break;
+		case MON_STATE_SEND_PROBE:
+			if (!mt7996_beacon_mon_send_probe(phy, mvif, conf, link_id)) {
+				timeout = MT7996_MAX_PROBE_TIMEOUT +
+					  mvif->probe_send_time[band_idx];
+				wiphy_info(hw->wiphy,
+					   "link %d: send nullfunc to AP %pM, try %d/%d\n",
+					   link_id, conf->bssid,
+					   mvif->probe_send_count[band_idx],
+					   MT7996_MAX_PROBE_TRIES);
+				break;
+			}
+			fallthrough;
+		case MON_STATE_LINK_LOST:
+			mvif->lost_links |= BIT(link_id);
+			wiphy_info(hw->wiphy,
+				   "link %d: %s to AP %pM, stop monitoring the lost link\n",
+				   link_id,
+				   state == MON_STATE_LINK_LOST ? "No ack for nullfunc frame" :
+								  "Failed to send nullfunc frame",
+				   conf->bssid);
+			mvif->probe[band_idx] = NULL;
+			mvif->probe_send_count[band_idx] = 0;
+			/* TODO: disable single link TX via TTLM/link reconfig for MLD */
+			if (mvif->lost_links != valid_links)
+				break;
+			fallthrough;
+		case MON_STATE_DISCONN:
+		default:
+			mutex_unlock(&dev->mt76.mutex);
+			wiphy_info(hw->wiphy, "all links are lost, disconnecting\n");
+			ieee80211_connection_loss(vif);
+			return;
+		}
+		next_time = min(next_time, timeout - jiffies);
+	}
+	mutex_unlock(&dev->mt76.mutex);
+
+	ieee80211_queue_delayed_work(hw, &mvif->beacon_mon_work, next_time);
+}
diff --git a/mt7996/main.c b/mt7996/main.c
index 7752a834..e0a9dde7 100644
--- a/mt7996/main.c
+++ b/mt7996/main.c
@@ -6,6 +6,25 @@
 #include "mt7996.h"
 #include "mcu.h"
 #include "mac.h"
+#ifdef CONFIG_MTK_DEBUG
+#include "mtk_mcu.h"
+#endif
+
+unsigned int mt7996_debug_mask = 0x1f;
+module_param(mt7996_debug_mask, uint, 0644);
+MODULE_PARM_DESC(mt7996_debug_mask, "Debugging mask");
+
+static void mt7996_testmode_disable_all(struct mt7996_dev *dev)
+{
+	struct mt7996_phy *phy;
+	int i;
+
+	for (i = 0; i < __MT_MAX_BAND; i++) {
+		phy = __mt7996_phy(dev, i);
+		if (phy)
+			mt76_testmode_set_state(phy->mt76, MT76_TM_STATE_OFF);
+	}
+}
 
 int mt7996_run(struct mt7996_phy *phy)
 {
@@ -22,7 +41,12 @@ int mt7996_run(struct mt7996_phy *phy)
 	if (ret)
 		return ret;
 
-	ret = mt7996_mcu_set_chan_info(phy, UNI_CHANNEL_RX_PATH);
+	ret = mt7996_mcu_set_chan_info(phy, UNI_CHANNEL_RX_PATH, false);
+	if (ret)
+		return ret;
+
+	/* set a parking channel */
+	ret = mt7996_mcu_set_chan_info(phy, UNI_CHANNEL_SWITCH, false);
 	if (ret)
 		return ret;
 
@@ -34,6 +58,28 @@ int mt7996_run(struct mt7996_phy *phy)
 	if (ret)
 		return ret;
 
+	ret = mt7996_mcu_set_scs(phy, SCS_ENABLE);
+	if (ret)
+		return ret;
+
+#ifdef CONFIG_MTK_DEBUG
+	phy->sr_enable = true;
+	phy->enhanced_sr_enable = true;
+	phy->thermal_protection_enable = true;
+	ret = mt7996_mcu_set_tx_power_ctrl(phy, UNI_TXPOWER_SKU_POWER_LIMIT_CTRL,
+					   dev->dbg.sku_disable ? 0 : phy->sku_limit_en);
+
+	ret = mt7996_mcu_set_tx_power_ctrl(phy, UNI_TXPOWER_BACKOFF_POWER_LIMIT_CTRL,
+					   dev->dbg.sku_disable ? 0 : phy->sku_path_en);
+#else
+	ret = mt7996_mcu_set_tx_power_ctrl(phy, UNI_TXPOWER_SKU_POWER_LIMIT_CTRL,
+					   phy->sku_limit_en);
+	ret = mt7996_mcu_set_tx_power_ctrl(phy, UNI_TXPOWER_BACKOFF_POWER_LIMIT_CTRL,
+					   phy->sku_path_en);
+#endif
+	if (ret)
+		return ret;
+
 	set_bit(MT76_STATE_RUNNING, &phy->mt76->state);
 
 	ieee80211_queue_delayed_work(dev->mphy.hw, &phy->mt76->mac_work,
@@ -60,9 +106,18 @@ static int mt7996_start(struct ieee80211_hw *hw)
 		u8 queue = mt76_connac_lmac_mapping(IEEE80211_AC_VI);
 
 		ret = mt7996_mcu_cp_support(dev, queue);
+#ifdef CONFIG_MTK_DEBUG
+		dev->sr_pp_enable = true;
+		dev->uba_enable = true;
+#endif
 	}
+
+	mt7996_testmode_disable_all(dev);
+
 	mutex_unlock(&dev->mt76.mutex);
 
+	ieee80211_queue_delayed_work(hw, &dev->scs_work, HZ);
+
 	return ret;
 }
 
@@ -74,9 +129,14 @@ static void mt7996_stop_phy(struct mt7996_phy *phy)
 		return;
 
 	cancel_delayed_work_sync(&phy->mt76->mac_work);
+	cancel_delayed_work_sync(&phy->scan_work);
+	cancel_delayed_work_sync(&phy->roc_complete_work);
 
 	mutex_lock(&dev->mt76.mutex);
 
+	if (test_bit(MT76_SCANNING, &phy->mt76->state))
+		mt7996_scan_complete(phy, true);
+
 	mt7996_mcu_set_radio_en(phy, false);
 
 	clear_bit(MT76_STATE_RUNNING, &phy->mt76->state);
@@ -86,11 +146,16 @@ static void mt7996_stop_phy(struct mt7996_phy *phy)
 
 static void mt7996_stop(struct ieee80211_hw *hw, bool suspend)
 {
+	struct mt7996_dev *dev = mt7996_hw_dev(hw);
+
+	cancel_delayed_work_sync(&dev->scs_work);
 }
 
-static inline int get_free_idx(u32 mask, u8 start, u8 end)
+static inline int get_free_idx(u64 mask, u8 start, u8 end)
 {
-	return ffs(~mask & GENMASK(end, start));
+	if (~mask & GENMASK_ULL(end, start))
+		return __ffs64(~mask & GENMASK_ULL(end, start)) + 1;
+	return 0;
 }
 
 static int get_omac_idx(enum nl80211_iftype type, u64 mask)
@@ -136,134 +201,186 @@ static int get_omac_idx(enum nl80211_iftype type, u64 mask)
 	return -1;
 }
 
-static void
-mt7996_init_bitrate_mask(struct ieee80211_vif *vif, struct mt7996_vif_link *mlink)
+static int get_own_mld_idx(u64 mask, bool group_mld)
 {
+	u8 start, end;
 	int i;
 
-	for (i = 0; i < ARRAY_SIZE(mlink->bitrate_mask.control); i++) {
-		mlink->bitrate_mask.control[i].gi = NL80211_TXRATE_DEFAULT_GI;
-		mlink->bitrate_mask.control[i].he_gi = 0xff;
-		mlink->bitrate_mask.control[i].he_ltf = 0xff;
-		mlink->bitrate_mask.control[i].legacy = GENMASK(31, 0);
-		memset(mlink->bitrate_mask.control[i].ht_mcs, 0xff,
-		       sizeof(mlink->bitrate_mask.control[i].ht_mcs));
-		memset(mlink->bitrate_mask.control[i].vht_mcs, 0xff,
-		       sizeof(mlink->bitrate_mask.control[i].vht_mcs));
-		memset(mlink->bitrate_mask.control[i].he_mcs, 0xff,
-		       sizeof(mlink->bitrate_mask.control[i].he_mcs));
+	if (group_mld) {
+		start = 0;
+		end = 15;
+	} else {
+		start = 16;
+		end = 63;
 	}
-}
-
-static int
-mt7996_set_hw_key(struct ieee80211_hw *hw, enum set_key_cmd cmd,
-		  struct ieee80211_vif *vif, struct ieee80211_sta *sta,
-		  struct mt7996_vif_link *mlink, struct ieee80211_key_conf *key)
-{
-	struct mt7996_dev *dev = mt7996_hw_dev(hw);
-	struct mt7996_sta *msta = sta ? (struct mt7996_sta *)sta->drv_priv :
-				  &mlink->sta;
-	struct mt76_wcid *wcid = &msta->wcid;
-	u8 *wcid_keyidx = &wcid->hw_key_idx;
-	struct mt7996_phy *phy;
-	int idx = key->keyidx;
 
-	phy = mt7996_vif_link_phy(mlink);
-	if (!phy)
-		return -EINVAL;
+	i = get_free_idx(mask, start, end);
+	if (i)
+		return i - 1;
 
-	if (sta && !wcid->sta)
-		return -EOPNOTSUPP;
-
-	switch (key->cipher) {
-	case WLAN_CIPHER_SUITE_AES_CMAC:
-	case WLAN_CIPHER_SUITE_BIP_CMAC_256:
-	case WLAN_CIPHER_SUITE_BIP_GMAC_128:
-	case WLAN_CIPHER_SUITE_BIP_GMAC_256:
-		if (key->keyidx == 6 || key->keyidx == 7) {
-			wcid_keyidx = &wcid->hw_key_idx2;
-			key->flags |= IEEE80211_KEY_FLAG_GENERATE_MMIE;
-		}
-		break;
-	default:
-		break;
+	/* if 16-63 are fully used, find again from 0-15 */
+	if (!group_mld && !i) {
+		i = get_free_idx(mask, 0, 15);
+		if (i)
+			return i - 1;
 	}
 
-	if (cmd == SET_KEY && !sta && !mlink->mt76.cipher) {
-		mlink->mt76.cipher = mt76_connac_mcu_get_cipher(key->cipher);
-		mt7996_mcu_add_bss_info(phy, vif, &vif->bss_conf, &mlink->mt76, true);
-	}
+	return -1;
+}
 
-	if (cmd == SET_KEY) {
-		*wcid_keyidx = idx;
-	} else {
-		if (idx == *wcid_keyidx)
-			*wcid_keyidx = -1;
-		return 0;
-	}
+static int get_mld_remap_idx(u64 mask)
+{
+	u8 start = 0, end = 15;
+	int i;
 
-	mt76_wcid_key_setup(&dev->mt76, wcid, key);
+	i = get_free_idx(mask, start, end);
+	if (i)
+		return i - 1;
+
+	return -1;
+}
 
-	if (key->keyidx == 6 || key->keyidx == 7)
-		return mt7996_mcu_bcn_prot_enable(dev, vif, key);
+static void mt7996_init_bitrate_mask(struct mt7996_bss_conf *mconf)
+{
+	int i;
 
-	return mt7996_mcu_add_key(&dev->mt76, vif, key,
-				  MCU_WMWA_UNI_CMD(STA_REC_UPDATE),
-				  &msta->wcid, cmd);
+	for (i = 0; i < ARRAY_SIZE(mconf->bitrate_mask.control); i++) {
+		mconf->bitrate_mask.control[i].gi = NL80211_TXRATE_DEFAULT_GI;
+		mconf->bitrate_mask.control[i].he_gi = 0xff;
+		mconf->bitrate_mask.control[i].he_ltf = 0xff;
+		mconf->bitrate_mask.control[i].legacy = GENMASK(31, 0);
+		memset(mconf->bitrate_mask.control[i].ht_mcs, 0xff,
+		       sizeof(mconf->bitrate_mask.control[i].ht_mcs));
+		memset(mconf->bitrate_mask.control[i].vht_mcs, 0xff,
+		       sizeof(mconf->bitrate_mask.control[i].vht_mcs));
+		memset(mconf->bitrate_mask.control[i].he_mcs, 0xff,
+		       sizeof(mconf->bitrate_mask.control[i].he_mcs));
+	}
 }
 
-static void
-mt7996_key_iter(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
-		struct ieee80211_sta *sta, struct ieee80211_key_conf *key,
-		void *data)
+static void mt7996_remove_bss_conf(struct ieee80211_vif *vif,
+				   struct ieee80211_bss_conf *conf,
+				   struct mt7996_bss_conf *mconf)
 {
-	struct mt7996_vif_link *mlink = data;
+	struct mt7996_phy *phy;
+	struct mt7996_dev *dev;
+	struct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;
+	u8 link_id = conf->link_id;
+	struct mt7996_link_sta *mlink =
+		mlink_dereference_protected(&mvif->sta, link_id);
 
-	if (sta)
+	if (!mlink || !mconf)
 		return;
 
-	WARN_ON(mt7996_set_hw_key(hw, SET_KEY, vif, NULL, mlink, key));
+	phy = mconf->phy;
+	dev = phy->dev;
+	mt7996_mcu_add_sta(dev, conf, mconf, NULL, mlink, false, false);
+	mt7996_mcu_add_bss_info(phy, conf, mconf, mlink, false);
+	mt7996_mcu_add_dev_info(phy, conf, mconf, false);
+
+	rcu_assign_pointer(dev->mt76.wcid[mlink->wcid.idx], NULL);
+	rcu_assign_pointer(mvif->link[link_id], NULL);
+	rcu_assign_pointer(mvif->sta.link[link_id], NULL);
+
+	dev->mt76.vif_mask &= ~BIT_ULL(mconf->mt76.idx);
+	dev->mld_id_mask &= ~BIT_ULL(mconf->own_mld_id);
+	phy->omac_mask &= ~BIT_ULL(mconf->mt76.omac_idx);
+
+	spin_lock_bh(&dev->mt76.sta_poll_lock);
+	if (!list_empty(&mlink->wcid.poll_list))
+		list_del_init(&mlink->wcid.poll_list);
+	spin_unlock_bh(&dev->mt76.sta_poll_lock);
+
+	mt76_wcid_cleanup(&dev->mt76, &mlink->wcid);
+
+	if (mlink != &mvif->sta.deflink)
+		kfree(mlink);
+
+	if (mconf != &mvif->deflink)
+		kfree(mconf);
 }
 
-int mt7996_vif_link_add(struct mt76_phy *mphy, struct ieee80211_vif *vif,
-			struct ieee80211_bss_conf *link_conf,
-			struct mt76_vif_link *mlink)
+static int mt7996_add_bss_conf(struct mt7996_phy *phy,
+			       struct ieee80211_vif *vif,
+			       struct ieee80211_bss_conf *conf)
 {
-	struct mt7996_vif_link *link = container_of(mlink, struct mt7996_vif_link, mt76);
-	struct mt7996_phy *phy = mphy->priv;
+	struct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;
 	struct mt7996_dev *dev = phy->dev;
-	u8 band_idx = phy->mt76->band_idx;
+	struct mt7996_bss_conf *mconf;
+	struct mt7996_link_sta *mlink;
 	struct mt76_txq *mtxq;
+	u8 band_idx = phy->mt76->band_idx;
+	u8 link_id = conf->link_id;
 	int idx, ret;
 
-	mlink->idx = __ffs64(~dev->mt76.vif_mask);
-	if (mlink->idx >= mt7996_max_interface_num(dev))
-		return -ENOSPC;
+	if (rcu_access_pointer(mvif->link[link_id]))
+		return 0;
+
+	if (conf != &vif->bss_conf) {
+		mconf = kzalloc(sizeof(*mconf), GFP_KERNEL);
+		if (!mconf)
+			return -ENOMEM;
+	} else {
+		mconf = &mvif->deflink;
+	}
+
+	mconf->mt76.idx = __ffs64(~dev->mt76.vif_mask);
+	if (mconf->mt76.idx >= mt7996_max_interface_num(dev)) {
+		ret = -ENOSPC;
+		goto error;
+	}
 
 	idx = get_omac_idx(vif->type, phy->omac_mask);
-	if (idx < 0)
-		return -ENOSPC;
+	if (idx < 0) {
+		ret = -ENOSPC;
+		goto error;
+	}
+
+	mconf->own_mld_id = get_own_mld_idx(dev->mld_id_mask, false);
+	if (mconf->own_mld_id < 0) {
+		ret = -ENOSPC;
+		goto error;
+	}
 
-	link->phy = phy;
-	mlink->omac_idx = idx;
-	mlink->band_idx = band_idx;
-	mlink->wmm_idx = vif->type == NL80211_IFTYPE_AP ? 0 : 3;
-	mlink->wcid = &link->sta.wcid;
-	mlink->wcid->offchannel = mlink->offchannel;
+	mconf->mt76.omac_idx = idx;
+	mconf->vif = mvif;
+	mconf->phy = phy;
+	mconf->mt76.band_idx = band_idx;
+	mconf->mt76.wmm_idx = vif->type == NL80211_IFTYPE_AP ? 0 : 3;
+	mconf->link_id = link_id;
 
-	ret = mt7996_mcu_add_dev_info(phy, vif, link_conf, mlink, true);
+	ret = mt7996_mcu_add_dev_info(phy, conf, mconf, true);
 	if (ret)
-		return ret;
+		goto error;
 
-	dev->mt76.vif_mask |= BIT_ULL(mlink->idx);
-	phy->omac_mask |= BIT_ULL(mlink->omac_idx);
-
-	idx = MT7996_WTBL_RESERVED - mlink->idx;
+	if (ieee80211_vif_is_mld(vif)) {
+		mlink = kzalloc(sizeof(*mlink), GFP_KERNEL);
+		if (!mlink) {
+			ret = -ENOMEM;
+			goto error;
+		}
+	} else {
+		mlink = &mvif->sta.deflink;
+	}
 
-	INIT_LIST_HEAD(&link->sta.rc_list);
-	link->sta.wcid.idx = idx;
-	link->sta.wcid.tx_info |= MT_WCID_TX_INFO_SET;
-	mt76_wcid_init(&link->sta.wcid, band_idx);
+	dev->mt76.vif_mask |= BIT_ULL(mconf->mt76.idx);
+	dev->mld_id_mask |= BIT_ULL(mconf->own_mld_id);
+	phy->omac_mask |= BIT_ULL(mconf->mt76.omac_idx);
+
+	idx = MT7996_WTBL_RESERVED - mconf->mt76.idx;
+
+	INIT_LIST_HEAD(&mlink->rc_list);
+	INIT_LIST_HEAD(&mlink->wcid.poll_list);
+	mlink->wcid.idx = idx;
+	mlink->wcid.phy_idx = band_idx;
+	mlink->wcid.hw_key_idx = -1;
+	mlink->wcid.tx_info |= MT_WCID_TX_INFO_SET;
+	mlink->wcid.def_wcid = &mvif->sta.deflink.wcid;
+	mlink->wcid.link_id = link_id;
+	mlink->wcid.link_valid = ieee80211_vif_is_mld(vif);
+	mlink->sta = &mvif->sta;
+	mlink->sta->vif = mvif;
+	mt76_wcid_init(&mlink->wcid);
 
 	mt7996_mac_wtbl_update(dev, idx,
 			       MT_WTBL_UPDATE_ADM_COUNT_CLEAR);
@@ -274,57 +391,33 @@ int mt7996_vif_link_add(struct mt76_phy *mphy, struct ieee80211_vif *vif,
 	}
 
 	if (vif->type != NL80211_IFTYPE_AP &&
-	    (!mlink->omac_idx || mlink->omac_idx > 3))
+	    (!mconf->mt76.omac_idx || mconf->mt76.omac_idx > 3))
 		vif->offload_flags = 0;
+	vif->offload_flags |= IEEE80211_OFFLOAD_ENCAP_4ADDR;
 
 	if (phy->mt76->chandef.chan->band != NL80211_BAND_2GHZ)
-		mlink->basic_rates_idx = MT7996_BASIC_RATES_TBL + 4;
+		mconf->mt76.basic_rates_idx = MT7996_BASIC_RATES_TBL + 4;
 	else
-		mlink->basic_rates_idx = MT7996_BASIC_RATES_TBL;
-
-	mt7996_init_bitrate_mask(vif, link);
+		mconf->mt76.basic_rates_idx = MT7996_BASIC_RATES_TBL;
+	mt7996_init_bitrate_mask(mconf);
 
-	mt7996_mcu_add_bss_info(phy, vif, link_conf, mlink, true);
+	mt7996_mcu_add_bss_info(phy, conf, mconf, mlink, true);
 	/* defer the first STA_REC of BMC entry to BSS_CHANGED_BSSID for STA
 	 * interface, since firmware only records BSSID when the entry is new
 	 */
 	if (vif->type != NL80211_IFTYPE_STATION)
-		mt7996_mcu_add_sta(dev, vif, mlink, NULL, CONN_STATE_PORT_SECURE, true);
-	rcu_assign_pointer(dev->mt76.wcid[idx], &link->sta.wcid);
+		mt7996_mcu_add_sta(dev, conf, mconf, NULL, mlink, true, true);
+	rcu_assign_pointer(dev->mt76.wcid[idx], &mlink->wcid);
+	rcu_assign_pointer(mvif->link[link_id], mconf);
+	rcu_assign_pointer(mvif->sta.link[link_id], mlink);
 
-	ieee80211_iter_keys(mphy->hw, vif, mt7996_key_iter, link);
+	mlo_dbg(phy, "bss_idx=%u, link_id=%u, wcid=%u\n",
+		mconf->mt76.idx, mconf->link_id, mlink->wcid.idx);
 
 	return 0;
-}
-
-void mt7996_vif_link_remove(struct mt76_phy *mphy, struct ieee80211_vif *vif,
-			    struct ieee80211_bss_conf *link_conf,
-			    struct mt76_vif_link *mlink)
-{
-	struct mt7996_vif_link *link = container_of(mlink, struct mt7996_vif_link, mt76);
-	struct mt7996_phy *phy = mphy->priv;
-	struct mt7996_dev *dev = phy->dev;
-	struct mt7996_sta *msta;
-	int idx;
-
-	msta = &link->sta;
-	idx = msta->wcid.idx;
-	mt7996_mcu_add_sta(dev, vif, mlink, NULL, CONN_STATE_DISCONNECT, false);
-	mt7996_mcu_add_bss_info(phy, vif, link_conf, mlink, false);
-
-	mt7996_mcu_add_dev_info(phy, vif, link_conf, mlink, false);
-
-	rcu_assign_pointer(dev->mt76.wcid[idx], NULL);
-
-	dev->mt76.vif_mask &= ~BIT_ULL(mlink->idx);
-	phy->omac_mask &= ~BIT_ULL(mlink->omac_idx);
-
-	spin_lock_bh(&dev->mt76.sta_poll_lock);
-	if (!list_empty(&msta->wcid.poll_list))
-		list_del_init(&msta->wcid.poll_list);
-	spin_unlock_bh(&dev->mt76.sta_poll_lock);
-
-	mt76_wcid_cleanup(&dev->mt76, &msta->wcid);
+error:
+	mt7996_remove_bss_conf(vif, conf, mconf);
+	return ret;
 }
 
 static void mt7996_phy_set_rxfilter(struct mt7996_phy *phy)
@@ -373,33 +466,54 @@ static void mt7996_set_monitor(struct mt7996_phy *phy, bool enabled)
 }
 
 static int mt7996_add_interface(struct ieee80211_hw *hw,
-				struct ieee80211_vif *vif)
+			        struct ieee80211_vif *vif)
 {
 	struct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;
 	struct wireless_dev *wdev = ieee80211_vif_to_wdev(vif);
 	struct mt7996_dev *dev = mt7996_hw_dev(hw);
+	struct mt7996_phy *phy;
 	int i, err = 0;
 
 	mutex_lock(&dev->mt76.mutex);
+	if (dev->testmode_enable && vif->type != NL80211_IFTYPE_MONITOR) {
+		mutex_unlock(&dev->mt76.mutex);
+		dev_err(dev->mt76.dev, "Only monitor interface is allowed in testmode\n");
+		return -EINVAL;
+	}
 
 	for (i = 0; i < MT7996_MAX_RADIOS; i++) {
-		struct mt7996_phy *phy = dev->radio_phy[i];
+		/* FIXME: only set the required radio temporarily for testmode.
+		 * The TX speed of testmode will be affected if the unused radio is enabled.
+		 * Normal mode should also skip enabling the unused radio once the
+		 * real single wiphy codebase is stable.
+		 */
+		if (dev->testmode_enable && !(wdev->radio_mask & BIT(i)))
+			continue;
 
-		if (!phy || !(wdev->radio_mask & BIT(i)) ||
-		    test_bit(MT76_STATE_RUNNING, &phy->mt76->state))
+		phy = dev->radio_phy[i];
+		if (!phy || test_bit(MT76_STATE_RUNNING, &phy->mt76->state))
 			continue;
 
 		err = mt7996_run(phy);
 		if (err)
 			goto out;
 
-		if (vif->type == NL80211_IFTYPE_MONITOR)
+		if (vif->type == NL80211_IFTYPE_MONITOR) {
 			mt7996_set_monitor(phy, true);
+			phy->monitor_vif = vif;
+		}
 	}
 
-	mt76_vif_init(vif, &mvif->mt76);
+	INIT_DELAYED_WORK(&mvif->beacon_mon_work, mt7996_beacon_mon_work);
+	mvif->dev = dev;
+	mvif->sta.vif = mvif;
+	/* TODO: temporaily set this to prevent some crashes */
+	mvif->deflink.phy = mt7996_hw_phy(hw);
+	memset(mvif->band_to_link, IEEE80211_LINK_UNSPECIFIED,
+	       sizeof(mvif->band_to_link));
 
-	vif->offload_flags |= IEEE80211_OFFLOAD_ENCAP_4ADDR;
+	if (vif->type == NL80211_IFTYPE_STATION)
+		err = mt7996_add_bss_conf(mt7996_hw_phy(hw), vif, &vif->bss_conf);
 
 out:
 	mutex_unlock(&dev->mt76.mutex);
@@ -425,40 +539,112 @@ static void mt7996_remove_iter(void *data, u8 *mac, struct ieee80211_vif *vif)
 static void mt7996_remove_interface(struct ieee80211_hw *hw,
 				    struct ieee80211_vif *vif)
 {
+	struct ieee80211_bss_conf *conf;
+	struct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;
+	struct mt7996_bss_conf *mconf;
 	struct mt7996_dev *dev = mt7996_hw_dev(hw);
+	struct mt7996_phy *phy;
 	struct mt7996_radio_data rdata = {};
 	int i;
 
 	ieee80211_iterate_active_interfaces_mtx(hw, 0, mt7996_remove_iter,
 						&rdata);
-	mt76_vif_cleanup(&dev->mt76, vif);
+
+	cancel_delayed_work(&mvif->beacon_mon_work);
+
+	mutex_lock(&dev->mt76.mutex);
+
+	conf = link_conf_dereference_protected(vif, 0);
+	mconf = mconf_dereference_protected(mvif, 0);
+	if (!mconf || !conf)
+		goto out;
+
+	mt7996_remove_bss_conf(vif, mconf, 0);
 
 	for (i = 0; i < MT7996_MAX_RADIOS; i++) {
-		struct mt7996_phy *phy = dev->radio_phy[i];
+		phy = dev->radio_phy[i];
+		if (!phy)
+			continue;
+
+		if (vif == phy->monitor_vif) {
+			phy->monitor_vif = NULL;
+
+			if (dev->testmode_enable)
+				kfree(phy->mt76->lists);
+		}
+	}
+
+out:
+	mutex_unlock(&dev->mt76.mutex);
 
+	for (i = 0; i < MT7996_MAX_RADIOS; i++) {
+		phy = dev->radio_phy[i];
 		if (!phy)
 			continue;
-		if (!(rdata.monitor_mask & BIT(i)))
+
+		if (vif->type == NL80211_IFTYPE_MONITOR &&
+		    !(rdata.monitor_mask & BIT(i)))
 			mt7996_set_monitor(phy, false);
 		if (!(rdata.active_mask & BIT(i)))
 			mt7996_stop_phy(phy);
 	}
 }
 
-int mt7996_set_channel(struct mt76_phy *mphy)
+static void ___mt7996_set_channel(struct mt7996_phy *phy,
+				 struct cfg80211_chan_def *chandef)
+{
+	struct mt76_dev *mdev = phy->mt76->dev;
+	struct mt76_phy *mphy = phy->mt76;
+	bool offchannel = phy->scan_chan != NULL;
+	int timeout = HZ / 5;
+	unsigned long was_scanning = ieee80211_get_scanning(mphy->hw);
+
+	wait_event_timeout(mdev->tx_wait, !mt76_has_tx_pending(mphy), timeout);
+	mt76_update_survey(mphy);
+
+	if (mphy->chandef.chan->center_freq != chandef->chan->center_freq ||
+	    mphy->chandef.width != chandef->width)
+		mphy->dfs_state = MT_DFS_STATE_UNKNOWN;
+
+	mphy->chandef = *chandef;
+	mphy->chan_state = mt76_channel_state(mphy, chandef->chan);
+
+	if (!offchannel)
+		mphy->main_chan = chandef->chan;
+
+	if (chandef->chan != mphy->main_chan || was_scanning)
+		memset(mphy->chan_state, 0, sizeof(*mphy->chan_state));
+}
+
+static int __mt7996_set_channel(struct mt7996_phy *phy,
+				struct cfg80211_chan_def *chandef)
 {
-	struct mt7996_phy *phy = mphy->priv;
+	struct mt7996_dev *dev = phy->dev;
 	int ret;
 
-	ret = mt7996_mcu_set_chan_info(phy, UNI_CHANNEL_SWITCH);
-	if (ret)
+	cancel_delayed_work_sync(&phy->mt76->mac_work);
+
+	mutex_lock(&dev->mt76.mutex);
+	set_bit(MT76_RESET, &phy->mt76->state);
+
+	___mt7996_set_channel(phy, chandef);
+
+	if (dev->cal) {
+		ret = mt7996_mcu_apply_tx_dpd(phy);
+		if (ret)
+			goto out;
+	}
+
+	if (mt76_testmode_enabled(phy->mt76) || phy->mt76->test.bf_en) {
+		mt7996_tm_update_channel(phy);
 		goto out;
+	}
 
-	ret = mt7996_mcu_set_chan_info(phy, UNI_CHANNEL_RX_PATH);
+	ret = mt7996_mcu_set_chan_info(phy, UNI_CHANNEL_SWITCH);
 	if (ret)
 		goto out;
 
-	ret = mt7996_mcu_set_txpower_sku(phy);
+	ret = mt7996_mcu_set_chan_info(phy, UNI_CHANNEL_RX_PATH);
 	if (ret)
 		goto out;
 
@@ -469,58 +655,121 @@ int mt7996_set_channel(struct mt76_phy *mphy)
 	phy->noise = 0;
 
 out:
-	ieee80211_queue_delayed_work(mphy->hw, &mphy->mac_work,
-				     MT7996_WATCHDOG_TIME);
+	clear_bit(MT76_RESET, &phy->mt76->state);
+	mutex_unlock(&dev->mt76.mutex);
+
+	mt76_txq_schedule_all(phy->mt76);
+
+	ieee80211_queue_delayed_work(phy->mt76->hw,
+				     &phy->mt76->mac_work,
 
 	return ret;
 }
 
+int mt7996_set_channel(struct mt7996_phy *phy, struct cfg80211_chan_def *chandef)
+{
+	int ret;
+
+	ieee80211_stop_queues(phy->mt76->hw);
+	ret = __mt7996_set_channel(phy, chandef);
+	if (ret)
+		return ret;
+	ieee80211_wake_queues(phy->mt76->hw);
+
+	return 0;
+}
+
 static int mt7996_set_key(struct ieee80211_hw *hw, enum set_key_cmd cmd,
 			  struct ieee80211_vif *vif, struct ieee80211_sta *sta,
 			  struct ieee80211_key_conf *key)
 {
 	struct mt7996_dev *dev = mt7996_hw_dev(hw);
 	struct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;
-	struct mt7996_vif_link *mlink = &mvif->deflink;
-	int err;
+	struct mt7996_sta *msta = sta ? (struct mt7996_sta *)sta->drv_priv :
+				  &mvif->sta;
+	struct mt7996_bss_conf *mconf;
+	struct mt7996_link_sta *mlink;
+	struct ieee80211_bss_conf *conf;
+	u8 *wcid_keyidx;
+	int idx = key->keyidx;
+	int err = 0;
+	unsigned long add;
+	unsigned int link_id;
 
-	/* The hardware does not support per-STA RX GTK, fallback
-	 * to software mode for these.
-	 */
-	if ((vif->type == NL80211_IFTYPE_ADHOC ||
-	     vif->type == NL80211_IFTYPE_MESH_POINT) &&
-	    (key->cipher == WLAN_CIPHER_SUITE_TKIP ||
-	     key->cipher == WLAN_CIPHER_SUITE_CCMP) &&
-	    !(key->flags & IEEE80211_KEY_FLAG_PAIRWISE))
-		return -EOPNOTSUPP;
-
-	/* fall back to sw encryption for unsupported ciphers */
-	switch (key->cipher) {
-	case WLAN_CIPHER_SUITE_TKIP:
-	case WLAN_CIPHER_SUITE_CCMP:
-	case WLAN_CIPHER_SUITE_CCMP_256:
-	case WLAN_CIPHER_SUITE_GCMP:
-	case WLAN_CIPHER_SUITE_GCMP_256:
-	case WLAN_CIPHER_SUITE_SMS4:
-		break;
-	case WLAN_CIPHER_SUITE_AES_CMAC:
-	case WLAN_CIPHER_SUITE_BIP_CMAC_256:
-	case WLAN_CIPHER_SUITE_BIP_GMAC_128:
-	case WLAN_CIPHER_SUITE_BIP_GMAC_256:
-		if (key->keyidx == 6 || key->keyidx == 7)
-			break;
-		fallthrough;
-	case WLAN_CIPHER_SUITE_WEP40:
-	case WLAN_CIPHER_SUITE_WEP104:
-	default:
-		return -EOPNOTSUPP;
+	if (key->link_id >= 0) {
+		add = BIT(key->link_id);
+	} else {
+		if (sta)
+			add = sta->valid_links ?: BIT(0);
+		else
+			add = vif->valid_links ?: BIT(0);
 	}
 
-	if (!mt7996_vif_link_phy(mlink))
-	    return 0; /* defer until after link add */
+	mlo_dbg(mt7996_hw_phy(hw), "cipher = 0x%x, icv_len = %u, iv_len = %u, hw_key_idx = %u, keyidx = %d, flags = 0x%x, link_id = %d, keylen = %u\n",
+		     key->cipher, key->icv_len, key->iv_len, key->hw_key_idx, key->keyidx, key->flags, key->link_id, key->keylen);
+	// print_hex_dump(KERN_INFO , "", DUMP_PREFIX_OFFSET, 16, 1, key->key, key->keylen, false);
+	mlo_dbg(mt7996_hw_phy(hw), "add=%lx, valid_links=%x, active_links=%x\n", add, vif->valid_links, vif->active_links);
 
 	mutex_lock(&dev->mt76.mutex);
-	err = mt7996_set_hw_key(hw, cmd, vif, sta, mlink, key);
+
+	for_each_set_bit(link_id, &add, IEEE80211_MLD_MAX_NUM_LINKS) {
+		conf = link_conf_dereference_protected(vif, link_id);
+		mconf = mconf_dereference_protected(mvif, link_id);
+		mlink = mlink_dereference_protected(msta, link_id);
+		wcid_keyidx = &mlink->wcid.hw_key_idx;
+
+		if (!conf || !mconf || !mlink)
+			continue;
+
+		/* fall back to sw encryption for unsupported ciphers */
+		switch (key->cipher) {
+		case WLAN_CIPHER_SUITE_TKIP:
+		case WLAN_CIPHER_SUITE_CCMP:
+		case WLAN_CIPHER_SUITE_CCMP_256:
+		case WLAN_CIPHER_SUITE_GCMP:
+		case WLAN_CIPHER_SUITE_GCMP_256:
+		case WLAN_CIPHER_SUITE_SMS4:
+			break;
+		case WLAN_CIPHER_SUITE_AES_CMAC:
+		case WLAN_CIPHER_SUITE_BIP_CMAC_256:
+		case WLAN_CIPHER_SUITE_BIP_GMAC_128:
+		case WLAN_CIPHER_SUITE_BIP_GMAC_256:
+			if (key->keyidx == 6 || key->keyidx == 7) {
+				wcid_keyidx = &mlink->wcid.hw_key_idx2;
+				key->flags |= IEEE80211_KEY_FLAG_GENERATE_MMIE;
+				break;
+			}
+			fallthrough;
+		case WLAN_CIPHER_SUITE_WEP40:
+		case WLAN_CIPHER_SUITE_WEP104:
+		default:
+			mutex_unlock(&dev->mt76.mutex);
+			return -EOPNOTSUPP;
+		}
+
+		if (cmd == SET_KEY && !sta && !mconf->mt76.cipher) {
+			mconf->mt76.cipher = mt76_connac_mcu_get_cipher(key->cipher);
+			mt7996_mcu_add_bss_info(mconf->phy, conf, mconf, mlink, true);
+		}
+
+		if (cmd == SET_KEY) {
+			*wcid_keyidx = idx;
+		} else {
+			if (idx == *wcid_keyidx)
+				*wcid_keyidx = -1;
+			goto out;
+		}
+
+		mt76_wcid_key_setup(&dev->mt76, &mlink->wcid, key);
+
+		if (key->keyidx == 6 || key->keyidx == 7)
+			err = mt7996_mcu_bcn_prot_enable(dev, conf, mconf, mlink, key);
+		else
+			err = mt7996_mcu_add_key(&dev->mt76, mconf, key,
+						 MCU_WMWA_UNI_CMD(STA_REC_UPDATE),
+						 &mlink->wcid, cmd);
+	}
+out:
 	mutex_unlock(&dev->mt76.mutex);
 
 	return err;
@@ -537,7 +786,8 @@ mt7996_conf_tx(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 	       const struct ieee80211_tx_queue_params *params)
 {
 	struct mt7996_dev *dev = mt7996_hw_dev(hw);
-	struct mt7996_vif_link *mlink = mt7996_vif_link(dev, vif, link_id);
+	struct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;
+	struct mt7996_bss_conf *mconf;
 	static const u8 mq_to_aci[] = {
 		[IEEE80211_AC_VO] = 3,
 		[IEEE80211_AC_VI] = 2,
@@ -545,10 +795,19 @@ mt7996_conf_tx(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 		[IEEE80211_AC_BK] = 1,
 	};
 
+	mutex_lock(&dev->mt76.mutex);
+	mconf = mconf_dereference_protected(mvif, link_id);
+	if (!mconf) {
+		mutex_unlock(&dev->mt76.mutex);
+		return -EINVAL;
+	}
+
 	/* firmware uses access class index */
-	mlink->queue_params[mq_to_aci[queue]] = *params;
+	mconf->queue_params[mq_to_aci[queue]] = *params;
 	/* no need to update right away, we'll get BSS_CHANGED_QOS */
 
+	mutex_unlock(&dev->mt76.mutex);
+
 	return 0;
 }
 
@@ -602,43 +861,44 @@ static void mt7996_configure_filter(struct ieee80211_hw *hw,
 	mutex_unlock(&dev->mt76.mutex);
 }
 
-static int
-mt7996_get_txpower(struct ieee80211_hw *hw, struct ieee80211_vif *vif, int *dbm)
+static void
+mt7996_update_bss_color(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
+			struct mt7996_bss_conf *mconf,
+			struct cfg80211_he_bss_color *bss_color)
 {
-	struct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;
-	struct mt7996_phy *phy = mt7996_vif_link_phy(&mvif->deflink);
 	struct mt7996_dev *dev = mt7996_hw_dev(hw);
-	struct wireless_dev *wdev;
-	int n_chains, delta, i;
-
-	if (!phy) {
-		wdev = ieee80211_vif_to_wdev(vif);
-		for (i = 0; i < hw->wiphy->n_radio; i++)
-			if (wdev->radio_mask & BIT(i))
-				phy = dev->radio_phy[i];
 
-		if (!phy)
-			return -EINVAL;
+	switch (vif->type) {
+	case NL80211_IFTYPE_AP: {
+		if (mconf->mt76.omac_idx > HW_BSSID_MAX)
+			return;
+		fallthrough;
+	}
+	case NL80211_IFTYPE_STATION:
+		mt7996_mcu_update_bss_color(dev, mconf, bss_color);
+		break;
+	default:
+		break;
 	}
-
-	n_chains = hweight16(phy->mt76->chainmask);
-	delta = mt76_tx_power_nss_delta(n_chains);
-	*dbm = DIV_ROUND_UP(phy->mt76->txpower_cur + delta, 2);
-
-	return 0;
 }
+
 static u8
-mt7996_get_rates_table(struct mt7996_phy *phy, struct ieee80211_bss_conf *conf,
-		       bool beacon, bool mcast)
+mt7996_get_rates_table(struct ieee80211_hw *hw, struct ieee80211_bss_conf *conf,
+		       struct mt7996_bss_conf *mconf, bool beacon, bool mcast)
 {
-	struct mt7996_dev *dev = phy->dev;
-	struct mt76_vif_link *mvif = mt76_vif_conf_link(&dev->mt76, conf->vif, conf);
+	struct mt7996_dev *dev = mt7996_hw_dev(hw);
+	struct mt76_phy *mphy = mconf->phy->mt76;
 	u16 rate;
 	u8 i, idx;
 
-	rate = mt76_connac2_mac_tx_rate_val(phy->mt76, conf, beacon, mcast);
+	rate = mt76_connac2_mac_tx_rate_val(mphy, conf, beacon, mcast);
 
 	if (beacon) {
+		struct mt7996_phy *phy = mphy->priv;
+
+		if (dev->cert_mode && phy->mt76->band_idx == MT_BAND2)
+			rate = 0x0200;
+
 		/* odd index for driver, even index for firmware */
 		idx = MT7996_BEACON_RATES_TBL + 2 * phy->mt76->band_idx;
 		if (phy->beacon_rate != rate)
@@ -652,59 +912,82 @@ mt7996_get_rates_table(struct mt7996_phy *phy, struct ieee80211_bss_conf *conf,
 		if ((mt76_rates[i].hw_value & GENMASK(7, 0)) == idx)
 			return MT7996_BASIC_RATES_TBL + 2 * i;
 
-	return mvif->basic_rates_idx;
+	return mconf->mt76.basic_rates_idx;
 }
 
 static void
-mt7996_update_mu_group(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
-		       struct ieee80211_bss_conf *info)
+mt7996_update_mu_group(struct ieee80211_hw *hw, struct ieee80211_bss_conf *conf,
+		       struct mt7996_bss_conf *mconf)
 {
-	struct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;
 	struct mt7996_dev *dev = mt7996_hw_dev(hw);
-	u8 band = mvif->deflink.mt76.band_idx;
+	u8 band = mconf->mt76.band_idx;
 	u32 *mu;
 
-	mu = (u32 *)info->mu_group.membership;
+	mu = (u32 *)conf->mu_group.membership;
 	mt76_wr(dev, MT_WF_PHYRX_BAND_GID_TAB_VLD0(band), mu[0]);
 	mt76_wr(dev, MT_WF_PHYRX_BAND_GID_TAB_VLD1(band), mu[1]);
 
-	mu = (u32 *)info->mu_group.position;
+	mu = (u32 *)conf->mu_group.position;
 	mt76_wr(dev, MT_WF_PHYRX_BAND_GID_TAB_POS0(band), mu[0]);
 	mt76_wr(dev, MT_WF_PHYRX_BAND_GID_TAB_POS1(band), mu[1]);
 	mt76_wr(dev, MT_WF_PHYRX_BAND_GID_TAB_POS2(band), mu[2]);
 	mt76_wr(dev, MT_WF_PHYRX_BAND_GID_TAB_POS3(band), mu[3]);
 }
 
-static void mt7996_bss_info_changed(struct ieee80211_hw *hw,
-				    struct ieee80211_vif *vif,
-				    struct ieee80211_bss_conf *info,
-				    u64 changed)
+static void mt7996_vif_cfg_changed(struct ieee80211_hw *hw,
+				   struct ieee80211_vif *vif, u64 changed)
 {
 	struct mt7996_dev *dev = mt7996_hw_dev(hw);
-	struct mt76_vif_link *mvif;
-	struct mt7996_phy *phy;
-	struct mt76_phy *mphy;
 
 	mutex_lock(&dev->mt76.mutex);
 
-	mvif = mt76_vif_conf_link(&dev->mt76, vif, info);
-	if (!mvif)
-		goto out;
+	if (changed & BSS_CHANGED_ASSOC && vif->cfg.assoc) {
+		struct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;
+		unsigned long valid_links = vif->valid_links ?: BIT(0);
+		unsigned int link_id;
+
+		for_each_set_bit(link_id, &valid_links, IEEE80211_MLD_MAX_NUM_LINKS) {
+			struct ieee80211_bss_conf *conf =
+				link_conf_dereference_protected(vif, link_id);
+			struct mt7996_bss_conf *mconf =
+				mconf_dereference_protected(mvif, link_id);
+			struct mt7996_link_sta *mlink =
+				mlink_dereference_protected(&mvif->sta, link_id);
+
+			mt7996_mcu_add_bss_info(mconf->phy, conf, mconf, mlink, true);
+			mt7996_mcu_add_sta(dev, conf, mconf, NULL, mlink, true, false);
+		}
+	}
 
-	mphy = mt76_vif_link_phy(mvif);
-	if (!mphy)
-		goto out;
+	mutex_unlock(&dev->mt76.mutex);
+}
+
+static void mt7996_link_info_changed(struct ieee80211_hw *hw,
+				     struct ieee80211_vif *vif,
+				     struct ieee80211_bss_conf *info,
+				     u64 changed)
+{
+	struct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;
+	struct mt7996_bss_conf *mconf;
+	struct mt7996_link_sta *mlink;
+	struct mt7996_dev *dev = mt7996_hw_dev(hw);
+	struct mt7996_phy *phy;
+
+	mutex_lock(&dev->mt76.mutex);
 
-	phy = mphy->priv;
+	mconf = mconf_dereference_protected(mvif, info->link_id);
+	mlink = mlink_dereference_protected(&mvif->sta, info->link_id);
+	if (!mconf || !mlink)
+		goto out;
 
+	phy = mconf->phy;
 	/* station mode uses BSSID to map the wlan entry to a peer,
 	 * and then peer references bss_info_rfch to set bandwidth cap.
 	 */
 	if ((changed & BSS_CHANGED_BSSID && !is_zero_ether_addr(info->bssid)) ||
-	    (changed & BSS_CHANGED_ASSOC && vif->cfg.assoc) ||
 	    (changed & BSS_CHANGED_BEACON_ENABLED && info->enable_beacon)) {
-		mt7996_mcu_add_bss_info(phy, vif, info, mvif, true);
-		mt7996_mcu_add_sta(dev, vif, mvif, NULL, CONN_STATE_PORT_SECURE,
+		mt7996_mcu_add_bss_info(phy, info, mconf, mlink, true);
+		mt7996_mcu_add_sta(dev, info, mconf, NULL, mlink, true,
 				   !!(changed & BSS_CHANGED_BSSID));
 	}
 
@@ -713,201 +996,524 @@ static void mt7996_bss_info_changed(struct ieee80211_hw *hw,
 
 		if (slottime != phy->slottime) {
 			phy->slottime = slottime;
-			mt7996_mcu_set_timing(phy, vif, info);
+			mt7996_mcu_set_timing(phy, mconf);
 		}
 	}
 
 	if (changed & BSS_CHANGED_MCAST_RATE)
-		mvif->mcast_rates_idx =
-			mt7996_get_rates_table(phy, info, false, true);
+		mconf->mt76.mcast_rates_idx =
+			mt7996_get_rates_table(hw, info, mconf, false, true);
 
 	if (changed & BSS_CHANGED_BASIC_RATES)
-		mvif->basic_rates_idx =
-			mt7996_get_rates_table(phy, info, false, false);
+		mconf->mt76.basic_rates_idx =
+			mt7996_get_rates_table(hw, info, mconf, false, false);
 
 	/* ensure that enable txcmd_mode after bss_info */
 	if (changed & (BSS_CHANGED_QOS | BSS_CHANGED_BEACON_ENABLED))
-		mt7996_mcu_set_tx(dev, vif, info);
+		mt7996_mcu_set_tx(dev, mconf);
 
 	if (changed & BSS_CHANGED_HE_OBSS_PD)
-		mt7996_mcu_add_obss_spr(phy, vif, &info->he_obss_pd);
+		mt7996_mcu_add_obss_spr(phy, mconf, &info->he_obss_pd);
 
-	if (changed & BSS_CHANGED_HE_BSS_COLOR) {
-		if ((vif->type == NL80211_IFTYPE_AP &&
-		    mvif->omac_idx <= HW_BSSID_MAX) ||
-		   vif->type == NL80211_IFTYPE_STATION)
-			mt7996_mcu_update_bss_color(dev, mvif,
-						    &info->he_bss_color);
-	}
+	if (changed & BSS_CHANGED_HE_BSS_COLOR)
+		mt7996_update_bss_color(hw, vif, mconf, &info->he_bss_color);
 
 	if (changed & (BSS_CHANGED_BEACON |
 		       BSS_CHANGED_BEACON_ENABLED)) {
-		mvif->beacon_rates_idx =
-			mt7996_get_rates_table(phy, info, true, false);
+		mconf->mt76.beacon_rates_idx =
+			mt7996_get_rates_table(hw, info, mconf, true, false);
 
-		mt7996_mcu_add_beacon(hw, vif, info);
+		mt7996_mcu_add_beacon(hw, info, mconf, info->enable_beacon);
 	}
 
 	if (changed & (BSS_CHANGED_UNSOL_BCAST_PROBE_RESP |
 		       BSS_CHANGED_FILS_DISCOVERY))
-		mt7996_mcu_beacon_inband_discov(dev, vif, changed);
+		mt7996_mcu_beacon_inband_discov(dev, info, mconf, changed);
 
 	if (changed & BSS_CHANGED_MU_GROUPS)
-		mt7996_update_mu_group(hw, vif, info);
+		mt7996_update_mu_group(hw, info, mconf);
 
-	if (changed & BSS_CHANGED_TXPOWER &&
-	    info->txpower != phy->txpower) {
-		phy->txpower = info->txpower;
-		mt7996_mcu_set_txpower_sku(phy);
-	}
+	if (changed & BSS_CHANGED_TXPOWER)
+		mt7996_mcu_set_txpower_sku(phy, info);
 
 out:
 	mutex_unlock(&dev->mt76.mutex);
 }
 
-static void
-mt7996_channel_switch_beacon(struct ieee80211_hw *hw,
-			     struct ieee80211_vif *vif,
-			     struct cfg80211_chan_def *chandef)
+int mt7996_get_txpower(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
+		       unsigned int link_id, int *dbm)
 {
+	struct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;
+	struct mt7996_bss_conf *mconf;
 	struct mt7996_dev *dev = mt7996_hw_dev(hw);
+	struct mt76_phy *mphy;
+	int delta;
 
 	mutex_lock(&dev->mt76.mutex);
-	mt7996_mcu_add_beacon(hw, vif, &vif->bss_conf);
+	mconf = mconf_dereference_protected(mvif, link_id);
+	if (!mconf || !mconf->phy) {
+		*dbm = 0;
+		goto out;
+	}
+
+	mphy = mconf->phy->mt76;
+
+	delta = mt76_tx_power_path_delta(hweight16(mphy->chainmask));
+
+	*dbm = DIV_ROUND_UP(mphy->txpower_cur + delta, 2);
+out:
 	mutex_unlock(&dev->mt76.mutex);
+	return 0;
 }
 
-int mt7996_mac_sta_add(struct mt76_dev *mdev, struct ieee80211_vif *vif,
-		       struct ieee80211_sta *sta)
+static void
+mt7996_channel_switch_beacon(struct ieee80211_hw *hw,
+			     struct ieee80211_vif *vif,
+			     struct cfg80211_chan_def *chandef)
 {
-	struct mt7996_dev *dev = container_of(mdev, struct mt7996_dev, mt76);
-	struct mt7996_sta *msta = (struct mt7996_sta *)sta->drv_priv;
+	struct mt7996_dev *dev = mt7996_hw_dev(hw);
 	struct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;
-	struct mt7996_vif_link *link = &mvif->deflink;
-	u8 band_idx = link->phy->mt76->band_idx;
-	int idx;
+	struct mt7996_phy *phy = mt7996_band_phy(dev, chandef->chan->band);
+	struct ieee80211_bss_conf *conf;
+	struct mt7996_bss_conf *mconf;
+	u16 valid_links = vif->valid_links ?: BIT(0);
+	unsigned int link_id;
 
-	idx = mt76_wcid_alloc(dev->mt76.wcid_mask, MT7996_WTBL_STA);
-	if (idx < 0)
-		return -ENOSPC;
+	mutex_lock(&dev->mt76.mutex);
+	for_each_set_bit(link_id, &valid_links, IEEE80211_MLD_MAX_NUM_LINKS) {
+		struct mt7996_bss_conf *mconf =
+			mconf_dereference_protected(mvif, link_id);
+		struct ieee80211_bss_conf *conf =
+			link_conf_dereference_protected(vif, link_id);
 
-	INIT_LIST_HEAD(&msta->rc_list);
-	INIT_LIST_HEAD(&msta->wcid.poll_list);
-	msta->vif = mvif;
-	msta->wcid.sta = 1;
-	msta->wcid.idx = idx;
-	msta->wcid.phy_idx = band_idx;
+		if (!mconf || phy != mconf->phy)
+			continue;
 
-	ewma_avg_signal_init(&msta->avg_ack_signal);
+		mt7996_mcu_add_beacon(hw, conf, mconf, true);
+	}
+	mutex_unlock(&dev->mt76.mutex);
+}
 
-	mt7996_mac_wtbl_update(dev, idx,
+static int
+mt7996_post_channel_switch(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
+			   struct ieee80211_bss_conf *link_conf)
+{
+	struct cfg80211_chan_def *chandef = &link_conf->chanreq.oper;
+	struct mt7996_dev *dev = mt7996_hw_dev(hw);
+	struct mt7996_phy *phy = mt7996_band_phy(dev, chandef->chan->band);
+	int ret;
+
+	ret = cfg80211_chandef_dfs_required(hw->wiphy, chandef, NL80211_IFTYPE_AP);
+	if (ret <= 0)
+		return ret;
+
+	return mt7996_set_channel(phy, chandef);
+}
+
+static void mt7996_remove_link_sta(struct mt7996_dev *dev,
+				   struct ieee80211_bss_conf *conf,
+				   struct mt7996_bss_conf *mconf,
+				   struct ieee80211_link_sta *link_sta,
+				   struct mt7996_link_sta *mlink,
+				   bool last_link)
+{
+	struct ieee80211_sta *sta = link_sta->sta;
+	struct mt7996_sta *msta = (struct mt7996_sta *)sta->drv_priv;
+	int i;
+
+	if (!mlink)
+		return;
+
+	for (i = 0; i < ARRAY_SIZE(mlink->wcid.aggr); i++)
+			mt76_rx_aggr_stop(&dev->mt76, &mlink->wcid, i);
+
+	if (sta->mlo && last_link)
+		mt7996_mcu_teardown_mld_sta(dev, mconf, mlink);
+	else
+		mt7996_mcu_add_sta(dev, conf, mconf, link_sta, mlink, false, false);
+
+	mt7996_mac_wtbl_update(dev, mlink->wcid.idx,
 			       MT_WTBL_UPDATE_ADM_COUNT_CLEAR);
-	mt7996_mcu_add_sta(dev, vif, &link->mt76, sta, CONN_STATE_DISCONNECT,
-			   true);
+
+	for (i = 0; i < ARRAY_SIZE(mlink->twt.flow); i++)
+		mt7996_mac_twt_teardown_flow(dev, mlink, i);
+
+	rcu_assign_pointer(mlink->sta->link[mlink->wcid.link_id], NULL);
+
+	spin_lock_bh(&dev->mt76.sta_poll_lock);
+	if (!list_empty(&mlink->wcid.poll_list))
+		list_del_init(&mlink->wcid.poll_list);
+	if (!list_empty(&mlink->rc_list))
+		list_del_init(&mlink->rc_list);
+	spin_unlock_bh(&dev->mt76.sta_poll_lock);
+
+	/* TODO: update primary link */
+	if (sta->valid_links) {
+		if (mlink->wcid.link_id == msta->pri_link)
+			msta->pri_link = msta->sec_link;
+
+		if (sta->valid_links & ~(BIT(msta->pri_link)))
+			msta->sec_link = __ffs(sta->valid_links & ~(BIT(msta->pri_link)));
+		else
+			msta->sec_link = msta->pri_link;
+	}
+
+	mt76_wcid_cleanup(&dev->mt76, &mlink->wcid);
+	mt76_wcid_mask_clear(dev->mt76.wcid_mask, mlink->wcid.idx);
+	mt76_wcid_mask_clear(dev->mt76.wcid_phy_mask, mlink->wcid.idx);
+
+	if (mlink != &msta->deflink)
+		kfree(mlink);
+}
+
+static int mt7996_add_link_sta(struct mt7996_dev *dev,
+			       struct ieee80211_bss_conf *conf,
+			       struct mt7996_bss_conf *mconf,
+			       struct ieee80211_link_sta *link_sta, bool assoc)
+{
+	struct ieee80211_sta *sta = link_sta->sta;
+	struct mt7996_vif *mvif = (struct mt7996_vif *)conf->vif->drv_priv;
+	struct mt7996_sta *msta = (struct mt7996_sta *)sta->drv_priv;
+	u8 link_id = link_sta->link_id;
+	struct mt7996_link_sta *mlink = NULL;
+	int idx, ret;
+
+	if (!rcu_access_pointer(msta->link[link_id])) {
+		idx = mt76_wcid_alloc(dev->mt76.wcid_mask, MT7996_WTBL_STA);
+		if (idx < 0)
+			return -ENOSPC;
+
+		if (sta->mlo) {
+			mlink = kzalloc(sizeof(*mlink), GFP_KERNEL);
+			if (!mlink)
+				return -ENOMEM;
+		} else {
+			mlink = &msta->deflink;
+		}
+
+		INIT_LIST_HEAD(&mlink->rc_list);
+		INIT_LIST_HEAD(&mlink->wcid.poll_list);
+		msta->vif = mvif;
+		mlink->wcid.sta = 1;
+		mlink->wcid.idx = idx;
+		mlink->wcid.phy_idx = mconf->phy->mt76->band_idx;
+		mlink->wcid.tx_info |= MT_WCID_TX_INFO_SET;
+		mlink->wcid.def_wcid = &msta->deflink.wcid;
+		mlink->sta = msta;
+		if (sta->valid_links) {
+			mlink->wcid.link_valid = true;
+			mlink->wcid.link_id = link_id;
+			if (sta->valid_links & ~(BIT(msta->pri_link)))
+				msta->sec_link = __ffs(sta->valid_links &
+						       ~(BIT(msta->pri_link)));
+			else
+				msta->sec_link = msta->pri_link;
+		}
+
+		rcu_assign_pointer(msta->link[link_id], mlink);
+
+		ewma_signal_init(&mlink->wcid.rssi);
+		if (mconf->phy->mt76->band_idx == MT_BAND1)
+			mt76_wcid_mask_set(dev->mt76.wcid_phy_mask, idx);
+		rcu_assign_pointer(dev->mt76.wcid[idx], &mlink->wcid);
+		mt76_wcid_init(&mlink->wcid);
+
+		mlo_dbg(mconf->phy, "wcid=%u, link_id=%u, link_addr=%pM, pri_link=%u, sec_link=%u\n", mlink->wcid.idx, link_id, link_sta->addr, msta->pri_link, msta->sec_link);
+	}
+
+	if (!assoc)
+		return 0;
+
+	if (!mlink)
+		mlink = mlink_dereference_protected(msta, link_id);
+	mt7996_mac_wtbl_update(dev, mlink->wcid.idx,
+			       MT_WTBL_UPDATE_ADM_COUNT_CLEAR);
+
+	ret = mt7996_mcu_add_sta(dev, conf, mconf, link_sta, mlink, true, true);
+	if (ret)
+		goto error;
+
+	ret = mt7996_mcu_add_rate_ctrl(dev, conf, mconf, link_sta, mlink, false);
+	if (ret)
+		goto error;
+
+	ewma_avg_signal_init(&mlink->avg_ack_signal);
 
 	return 0;
+error:
+	mt7996_remove_link_sta(dev, conf, mconf, link_sta, mlink,
+			       hweight16(sta->valid_links) <= 1);
+	return ret;
 }
 
-int mt7996_mac_sta_event(struct mt76_dev *mdev, struct ieee80211_vif *vif,
-			 struct ieee80211_sta *sta, enum mt76_sta_event ev)
+static void
+mt7996_mac_sta_remove_links(struct mt7996_dev *dev, struct ieee80211_vif *vif,
+			    struct ieee80211_sta *sta, unsigned long rem)
 {
-	struct mt7996_dev *dev = container_of(mdev, struct mt7996_dev, mt76);
+	struct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;
 	struct mt7996_sta *msta = (struct mt7996_sta *)sta->drv_priv;
+	unsigned int link_id;
+
+	if (!ieee80211_vif_is_mld(vif) || rem == sta->valid_links)
+		cancel_delayed_work(&mvif->beacon_mon_work);
+
+	mlo_dbg(mt7996_hw_phy(mvif->hw), "rem=%lu\n", rem);
+	for_each_set_bit(link_id, &rem, IEEE80211_MLD_MAX_NUM_LINKS) {
+		struct mt7996_bss_conf *mconf =
+			mconf_dereference_protected(mvif, link_id);
+		struct mt7996_link_sta *mlink =
+			mlink_dereference_protected(msta, link_id);
+		struct ieee80211_bss_conf *conf =
+			link_conf_dereference_protected(vif, link_id);
+		struct ieee80211_link_sta *link_sta =
+			link_sta_dereference_protected(sta, link_id);
+		bool last_link = rem == sta->valid_links && link_id == __fls(rem);
+
+		mt7996_remove_link_sta(dev, conf, mconf, link_sta, mlink, last_link);
+	}
+}
+
+static int
+mt7996_mac_sta_add_links(struct mt7996_dev *dev, struct ieee80211_vif *vif,
+			 struct ieee80211_sta *sta, unsigned long add,
+			 bool assoc)
+{
 	struct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;
-	struct mt7996_vif_link *link = &mvif->deflink;
+	struct mt7996_sta *msta = (struct mt7996_sta *)sta->drv_priv;
+	struct mt7996_link_sta *mlink;
+	unsigned int link_id;
 	int i, ret;
 
-	switch (ev) {
-	case MT76_STA_EVENT_ASSOC:
-		ret = mt7996_mcu_add_sta(dev, vif, &link->mt76, sta,
-					 CONN_STATE_CONNECT, true);
-		if (ret)
-			return ret;
+	mlo_dbg(mt7996_hw_phy(mvif->hw), "add=%lu, assoc=%d\n", add, assoc);
+	for_each_set_bit(link_id, &add, IEEE80211_MLD_MAX_NUM_LINKS) {
+		struct mt7996_bss_conf *mconf =
+			mconf_dereference_protected(mvif, link_id);
+		struct ieee80211_bss_conf *conf =
+			link_conf_dereference_protected(vif, link_id);
+		struct ieee80211_link_sta *link_sta =
+			link_sta_dereference_protected(sta, link_id);
 
-		ret = mt7996_mcu_add_rate_ctrl(dev, vif, sta, false);
+		ret = mt7996_add_link_sta(dev, conf, mconf, link_sta, assoc);
 		if (ret)
-			return ret;
-
-		msta->wcid.tx_info |= MT_WCID_TX_INFO_SET;
-		msta->wcid.sta = 1;
+			goto error;
+	}
 
+	if (!assoc)
 		return 0;
 
-	case MT76_STA_EVENT_AUTHORIZE:
-		return mt7996_mcu_add_sta(dev, vif, &link->mt76, sta,
-					  CONN_STATE_PORT_SECURE, false);
+	mlink = mlink_dereference_protected(msta, msta->pri_link);
+	for (i = 0; i < ARRAY_SIZE(sta->txq); i++) {
+		struct mt76_txq *mtxq;
 
-	case MT76_STA_EVENT_DISASSOC:
-		for (i = 0; i < ARRAY_SIZE(msta->twt.flow); i++)
-			mt7996_mac_twt_teardown_flow(dev, msta, i);
+		if (!sta->txq[i])
+			continue;
+		mtxq = (struct mt76_txq *)sta->txq[i]->drv_priv;
+		mtxq->wcid = mlink->wcid.idx;
+	}
 
-		mt7996_mcu_add_sta(dev, vif, &link->mt76, sta,
-				   CONN_STATE_DISCONNECT, false);
-		msta->wcid.sta_disabled = 1;
-		msta->wcid.sta = 0;
+	ret = mt7996_mcu_add_mld_sta(dev, vif, sta, add);
+	if (ret)
+		goto error;
 
-		return 0;
+	return 0;
+error:
+	mt7996_mac_sta_remove_links(dev, vif, sta, add);
+	return ret;
+}
+
+int mt7996_mac_sta_add(struct mt76_dev *mdev, struct ieee80211_vif *vif,
+		       struct ieee80211_sta *sta)
+{
+	struct mt7996_dev *dev = container_of(mdev, struct mt7996_dev, mt76);
+	struct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;
+	struct mt7996_sta *msta = (struct mt7996_sta *)sta->drv_priv;
+	struct mt7996_bss_conf *mconf;
+	u8 link_id = sta->valid_links ? __ffs(sta->valid_links) : 0;
+	unsigned long add = BIT(link_id);
+	int ret;
+
+#ifdef CONFIG_MTK_VENDOR
+	struct mt7996_phy *phy = &dev->phy;
+#endif
+
+	msta->pri_link = link_id;
+	ret = mt7996_mac_sta_add_links(dev, vif, sta, add, false);
+	if (ret)
+		return ret;
+
+#ifdef CONFIG_MTK_VENDOR
+	mconf = mconf_dereference_protected(mvif, link_id);
+	mt7996_vendor_amnt_sta_remove(mconf->phy, sta);
+#endif
+
+#ifdef CONFIG_MTK_VENDOR
+	switch (mconf->phy->mt76->band_idx) {
+	case MT_BAND1:
+		phy = mt7996_phy2(dev);
+		break;
+	case MT_BAND2:
+		phy = mt7996_phy3(dev);
+		break;
+	case MT_BAND0:
+	default:
+		break;
 	}
 
+	if (phy && phy->muru_onoff & MUMIMO_DL_CERT)
+		mt7996_mcu_set_mimo(phy);
+#endif
+
 	return 0;
 }
 
+int mt7996_mac_sta_event(struct mt76_dev *mdev, struct ieee80211_vif *vif,
+			 struct ieee80211_sta *sta, enum mt76_sta_event ev)
+{
+	struct mt7996_dev *dev = container_of(mdev, struct mt7996_dev, mt76);
+	unsigned long add = sta->valid_links ?: BIT(0);
+	int ret = 0;
+
+	mutex_lock(&dev->mt76.mutex);
+
+	if (ev == MT76_STA_EVENT_ASSOC)
+		ret = mt7996_mac_sta_add_links(dev, vif, sta, add, true);
+
+	mutex_unlock(&dev->mt76.mutex);
+
+	return ret;
+}
+
 void mt7996_mac_sta_remove(struct mt76_dev *mdev, struct ieee80211_vif *vif,
 			   struct ieee80211_sta *sta)
 {
 	struct mt7996_dev *dev = container_of(mdev, struct mt7996_dev, mt76);
+	unsigned long rem = sta->valid_links ?: BIT(0);
+
+#ifdef CONFIG_MTK_VENDOR
+	mt7996_mcu_set_csi(&dev->phy, 2, 8, 1, 0, sta->addr);
+#endif
+	mt7996_mac_sta_remove_links(dev, vif, sta, rem);
+}
+
+static void
+mt7996_sta_pre_rcu_remove(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
+			  struct ieee80211_sta *sta)
+{
+	struct mt7996_dev *dev = mt7996_hw_dev(hw);
 	struct mt7996_sta *msta = (struct mt7996_sta *)sta->drv_priv;
+	unsigned long rem = sta->valid_links ?: BIT(0);
+	unsigned int link_id;
 
-	mt7996_mac_wtbl_update(dev, msta->wcid.idx,
-			       MT_WTBL_UPDATE_ADM_COUNT_CLEAR);
+	mutex_lock(&dev->mt76.mutex);
+	spin_lock_bh(&dev->mt76.status_lock);
+	for_each_set_bit(link_id, &rem, IEEE80211_MLD_MAX_NUM_LINKS) {
+		struct mt7996_link_sta *mlink =
+			mlink_dereference_protected(msta, link_id);
 
-	spin_lock_bh(&mdev->sta_poll_lock);
-	if (!list_empty(&msta->wcid.poll_list))
-		list_del_init(&msta->wcid.poll_list);
-	if (!list_empty(&msta->rc_list))
-		list_del_init(&msta->rc_list);
-	spin_unlock_bh(&mdev->sta_poll_lock);
+		if (!mlink)
+			continue;
+		rcu_assign_pointer(dev->mt76.wcid[mlink->wcid.idx], NULL);
+	}
+	spin_unlock_bh(&dev->mt76.status_lock);
+	mutex_unlock(&dev->mt76.mutex);
 }
 
 static void mt7996_tx(struct ieee80211_hw *hw,
 		      struct ieee80211_tx_control *control,
 		      struct sk_buff *skb)
 {
+	struct mt76_phy *mphy;
 	struct mt7996_dev *dev = mt7996_hw_dev(hw);
-	struct mt76_phy *mphy = hw->priv;
 	struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);
 	struct ieee80211_vif *vif = info->control.vif;
-	struct mt76_wcid *wcid = &dev->mt76.global_wcid;
-
-	if (vif) {
-		struct mt7996_vif *mvif;
+	struct mt76_wcid *wcid;
+	struct mt7996_vif *mvif;
+	struct mt7996_sta *msta;
+	bool addr_trans_success = false;
 
+	if (control->sta) {
+		msta = (struct mt7996_sta *)control->sta->drv_priv;
+		mvif = msta->vif;
+	} else if (vif) {
 		mvif = (struct mt7996_vif *)vif->drv_priv;
-		wcid = &mvif->deflink.sta.wcid;
+		msta = &mvif->sta;
+	}
 
-		if (mvif->mt76.roc_phy &&
-		    (info->flags & IEEE80211_TX_CTL_TX_OFFCHAN)) {
-			mphy = mvif->mt76.roc_phy;
-			if (mphy->roc_link)
-				wcid = mphy->roc_link->wcid;
-		} else {
-			mphy = mt76_vif_link_phy(&mvif->deflink.mt76);
+	rcu_read_lock();
+	if (mvif && msta) {
+		struct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;
+		struct mt7996_bss_conf *mconf;
+		struct mt7996_link_sta *mlink;
+		u8 link_id = u32_get_bits(info->control.flags,
+					  IEEE80211_TX_CTRL_MLO_LINK);
+		struct ieee80211_sta *sta = ieee80211_find_sta(vif, hdr->addr1);
+
+		if (link_id >= IEEE80211_LINK_UNSPECIFIED) {
+			if (sta) {
+				struct mt7996_sta *peer;
+
+				peer = (struct mt7996_sta *)sta->drv_priv;
+				link_id = peer->pri_link;
+			} else {
+				link_id = mvif->master_link_id;
+			}
 		}
-	}
 
-	if (control->sta) {
-		struct mt7996_sta *sta;
+		/* translate mld addr to link addr */
+		if (ieee80211_vif_is_mld(vif)) {
+			struct ieee80211_bss_conf *conf;
+			if (sta) {
+				struct ieee80211_link_sta *link_sta =
+					rcu_dereference(sta->link[link_id]);
+
+				if (!link_sta) {
+					mlo_dbg(mt7996_hw_phy(mvif->hw), "request TX on invalid link_id=%u, use primary link (id=%u) instead.\n",
+						      link_id, msta->pri_link);
+					link_id = msta->pri_link;
+					link_sta = rcu_dereference(sta->link[link_id]);
+
+					if (!link_sta) {
+						mlo_dbg(mt7996_hw_phy(mvif->hw), "primary link became invalid, give up the TX\n");
+						goto unlock;
+					}
+				}
+
+				memcpy(hdr->addr1, link_sta->addr, ETH_ALEN);
+				if (ether_addr_equal(sta->addr, hdr->addr3))
+					memcpy(hdr->addr3, link_sta->addr, ETH_ALEN);
+			}
+
+			conf = rcu_dereference(vif->link_conf[link_id]);
+			if (unlikely(!conf))
+				goto unlock;
+
+			memcpy(hdr->addr2, conf->addr, ETH_ALEN);
+			if (ether_addr_equal(vif->addr, hdr->addr3))
+				memcpy(hdr->addr3, conf->addr, ETH_ALEN);
+		}
 
-		sta = (struct mt7996_sta *)control->sta->drv_priv;
-		wcid = &sta->wcid;
-	}
+		mconf = rcu_dereference(mvif->link[link_id]);
+		mlink = rcu_dereference(msta->link[link_id]);
 
-	if (!mphy) {
-		ieee80211_free_txskb(hw, skb);
-		return;
+		if (!mconf || !mlink)
+			goto unlock;
+
+		mphy = mconf->phy->mt76;
+		wcid = &mlink->wcid;
+	} else {
+		mphy = hw->priv;
+		wcid = &dev->mt76.global_wcid;
 	}
 
+	addr_trans_success = true;
 	mt76_tx(mphy, control->sta, wcid, skb);
+unlock:
+	if (!addr_trans_success) {
+		spin_lock_bh(&dev->mt76.tx_dbg_stats.lock);
+		dev->mt76.tx_dbg_stats.tx_drop[MT_TX_DROP_ADDR_TRANS_FAIL]++;
+		spin_unlock_bh(&dev->mt76.tx_dbg_stats.lock);
+	}
+	rcu_read_unlock();
 }
 
 static int mt7996_set_rts_threshold(struct ieee80211_hw *hw, u32 val)
@@ -939,6 +1545,7 @@ mt7996_ampdu_action(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 	struct ieee80211_sta *sta = params->sta;
 	struct ieee80211_txq *txq = sta->txq[params->tid];
 	struct mt7996_sta *msta = (struct mt7996_sta *)sta->drv_priv;
+	struct mt7996_link_sta *mlink;
 	u16 tid = params->tid;
 	u16 ssn = params->ssn;
 	struct mt76_txq *mtxq;
@@ -950,14 +1557,15 @@ mt7996_ampdu_action(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 	mtxq = (struct mt76_txq *)txq->drv_priv;
 
 	mutex_lock(&dev->mt76.mutex);
+	mlink = mlink_dereference_protected(msta, msta->pri_link);
 	switch (action) {
 	case IEEE80211_AMPDU_RX_START:
-		mt76_rx_aggr_start(&dev->mt76, &msta->wcid, tid, ssn,
+		mt76_rx_aggr_start(&dev->mt76, &mlink->wcid, tid, ssn,
 				   params->buf_size);
 		ret = mt7996_mcu_add_rx_ba(dev, params, true);
 		break;
 	case IEEE80211_AMPDU_RX_STOP:
-		mt76_rx_aggr_stop(&dev->mt76, &msta->wcid, tid);
+		mt76_rx_aggr_stop(&dev->mt76, &mlink->wcid, tid);
 		ret = mt7996_mcu_add_rx_ba(dev, params, false);
 		break;
 	case IEEE80211_AMPDU_TX_OPERATIONAL:
@@ -968,16 +1576,16 @@ mt7996_ampdu_action(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 	case IEEE80211_AMPDU_TX_STOP_FLUSH:
 	case IEEE80211_AMPDU_TX_STOP_FLUSH_CONT:
 		mtxq->aggr = false;
-		clear_bit(tid, &msta->wcid.ampdu_state);
+		clear_bit(tid, &mlink->wcid.ampdu_state);
 		ret = mt7996_mcu_add_tx_ba(dev, params, false);
 		break;
 	case IEEE80211_AMPDU_TX_START:
-		set_bit(tid, &msta->wcid.ampdu_state);
+		set_bit(tid, &mlink->wcid.ampdu_state);
 		ret = IEEE80211_AMPDU_TX_START_IMMEDIATE;
 		break;
 	case IEEE80211_AMPDU_TX_STOP_CONT:
 		mtxq->aggr = false;
-		clear_bit(tid, &msta->wcid.ampdu_state);
+		clear_bit(tid, &mlink->wcid.ampdu_state);
 		ret = mt7996_mcu_add_tx_ba(dev, params, false);
 		ieee80211_stop_tx_ba_cb_irqsafe(vif, sta->addr, tid);
 		break;
@@ -1012,23 +1620,20 @@ mt7996_get_stats(struct ieee80211_hw *hw,
 	return 0;
 }
 
-u64 __mt7996_get_tsf(struct ieee80211_hw *hw, struct mt7996_vif *mvif)
+u64 __mt7996_get_tsf(struct ieee80211_hw *hw, struct mt7996_bss_conf *mconf)
 {
 	struct mt7996_dev *dev = mt7996_hw_dev(hw);
-	struct mt7996_phy *phy = mt7996_vif_link_phy(&mvif->deflink);
+	struct mt7996_phy *phy = mconf->phy;
 	union {
 		u64 t64;
 		u32 t32[2];
 	} tsf;
 	u16 n;
 
-	if (!phy)
-		return 0;
-
 	lockdep_assert_held(&dev->mt76.mutex);
 
-	n = mvif->deflink.mt76.omac_idx > HW_BSSID_MAX ? HW_BSSID_0
-					       : mvif->deflink.mt76.omac_idx;
+	n = mconf->mt76.omac_idx > HW_BSSID_MAX ? HW_BSSID_0
+					       : mconf->mt76.omac_idx;
 	/* TSF software read */
 	mt76_rmw(dev, MT_LPON_TCR(phy->mt76->band_idx, n), MT_LPON_TCR_SW_MODE,
 		 MT_LPON_TCR_SW_READ);
@@ -1043,10 +1648,21 @@ mt7996_get_tsf(struct ieee80211_hw *hw, struct ieee80211_vif *vif)
 {
 	struct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;
 	struct mt7996_dev *dev = mt7996_hw_dev(hw);
-	u64 ret;
+	struct mt7996_bss_conf *mconf;
+	u64 ret = -1ULL;
+	int i;
 
 	mutex_lock(&dev->mt76.mutex);
-	ret = __mt7996_get_tsf(hw, mvif);
+	/* FIXME workaround for preventing kernel crash during ACS
+	 * (i.e., link 0 is doing ACS while link 1 queries tsf)
+	 */
+	for (i = 0; i < IEEE80211_MLD_MAX_NUM_LINKS; i++) {
+		mconf = mconf_dereference_protected(mvif, i);
+		if (mconf)
+			break;
+	}
+	if (mconf)
+		ret = __mt7996_get_tsf(hw, mconf);
 	mutex_unlock(&dev->mt76.mutex);
 
 	return ret;
@@ -1058,20 +1674,22 @@ mt7996_set_tsf(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 {
 	struct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;
 	struct mt7996_dev *dev = mt7996_hw_dev(hw);
-	struct mt7996_phy *phy = mt7996_vif_link_phy(&mvif->deflink);
+	struct mt7996_phy *phy;
+	struct mt7996_bss_conf *mconf;
 	union {
 		u64 t64;
 		u32 t32[2];
 	} tsf = { .t64 = timestamp, };
 	u16 n;
 
-	if (!phy)
-		return;
-
 	mutex_lock(&dev->mt76.mutex);
 
-	n = mvif->deflink.mt76.omac_idx > HW_BSSID_MAX ? HW_BSSID_0
-					       : mvif->deflink.mt76.omac_idx;
+	mconf = mconf_dereference_protected(mvif, mvif->master_link_id);
+	if (!mconf)
+		return;
+	phy = mconf->phy;
+	n = mconf->mt76.omac_idx > HW_BSSID_MAX ? HW_BSSID_0
+					       : mconf->mt76.omac_idx;
 	mt76_wr(dev, MT_LPON_UTTR0(phy->mt76->band_idx), tsf.t32[0]);
 	mt76_wr(dev, MT_LPON_UTTR1(phy->mt76->band_idx), tsf.t32[1]);
 	/* TSF software overwrite */
@@ -1087,20 +1705,22 @@ mt7996_offset_tsf(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 {
 	struct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;
 	struct mt7996_dev *dev = mt7996_hw_dev(hw);
-	struct mt7996_phy *phy = mt7996_vif_link_phy(&mvif->deflink);
+	struct mt7996_phy *phy;
+	struct mt7996_bss_conf *mconf;
 	union {
 		u64 t64;
 		u32 t32[2];
 	} tsf = { .t64 = timestamp, };
 	u16 n;
 
-	if (!phy)
-		return;
-
 	mutex_lock(&dev->mt76.mutex);
 
-	n = mvif->deflink.mt76.omac_idx > HW_BSSID_MAX ? HW_BSSID_0
-					       : mvif->deflink.mt76.omac_idx;
+	mconf = mconf_dereference_protected(mvif, mvif->master_link_id);
+	if (!mconf)
+		return;
+	phy = mconf->phy;
+	n = mconf->mt76.omac_idx > HW_BSSID_MAX ? HW_BSSID_0
+					       : mconf->mt76.omac_idx;
 	mt76_wr(dev, MT_LPON_UTTR0(phy->mt76->band_idx), tsf.t32[0]);
 	mt76_wr(dev, MT_LPON_UTTR1(phy->mt76->band_idx), tsf.t32[1]);
 	/* TSF software adjust*/
@@ -1153,7 +1773,6 @@ mt7996_set_antenna(struct ieee80211_hw *hw, u32 tx_ant, u32 rx_ant)
 		mt76_set_stream_caps(phy->mt76, true);
 		mt7996_set_stream_vht_txbf_caps(phy);
 		mt7996_set_stream_he_eht_caps(phy);
-		mt7996_mcu_set_txpower_sku(phy);
 	}
 
 	mutex_unlock(&dev->mt76.mutex);
@@ -1168,8 +1787,16 @@ static void mt7996_sta_statistics(struct ieee80211_hw *hw,
 {
 	struct mt7996_dev *dev = mt7996_hw_dev(hw);
 	struct mt7996_sta *msta = (struct mt7996_sta *)sta->drv_priv;
-	struct rate_info *txrate = &msta->wcid.rate;
+	struct mt7996_link_sta *mlink;
+	struct rate_info *txrate;
 
+	/* TODO: support per-link rate report */
+	mutex_lock(&dev->mt76.mutex);
+	mlink = mlink_dereference_protected(msta, msta->pri_link);
+	if (!mlink)
+		goto out;
+
+	txrate = &mlink->wcid.rate;
 	if (txrate->legacy || txrate->flags) {
 		if (txrate->legacy) {
 			sinfo->txrate.legacy = txrate->legacy;
@@ -1188,44 +1815,133 @@ static void mt7996_sta_statistics(struct ieee80211_hw *hw,
 	sinfo->txrate.flags = txrate->flags;
 	sinfo->filled |= BIT_ULL(NL80211_STA_INFO_TX_BITRATE);
 
-	sinfo->tx_failed = msta->wcid.stats.tx_failed;
+	sinfo->tx_failed = mlink->wcid.stats.tx_failed;
 	sinfo->filled |= BIT_ULL(NL80211_STA_INFO_TX_FAILED);
 
-	sinfo->tx_retries = msta->wcid.stats.tx_retries;
+	sinfo->tx_retries = mlink->wcid.stats.tx_retries;
 	sinfo->filled |= BIT_ULL(NL80211_STA_INFO_TX_RETRIES);
 
-	sinfo->ack_signal = (s8)msta->ack_signal;
+	sinfo->ack_signal = (s8)mlink->ack_signal;
 	sinfo->filled |= BIT_ULL(NL80211_STA_INFO_ACK_SIGNAL);
 
-	sinfo->avg_ack_signal = -(s8)ewma_avg_signal_read(&msta->avg_ack_signal);
+	sinfo->avg_ack_signal = -(s8)ewma_avg_signal_read(&mlink->avg_ack_signal);
 	sinfo->filled |= BIT_ULL(NL80211_STA_INFO_ACK_SIGNAL_AVG);
 
 	if (mtk_wed_device_active(&dev->mt76.mmio.wed)) {
-		sinfo->tx_bytes = msta->wcid.stats.tx_bytes;
+		sinfo->tx_bytes = mlink->wcid.stats.tx_bytes;
 		sinfo->filled |= BIT_ULL(NL80211_STA_INFO_TX_BYTES64);
 
-		sinfo->rx_bytes = msta->wcid.stats.rx_bytes;
+		sinfo->rx_bytes = mlink->wcid.stats.rx_bytes;
 		sinfo->filled |= BIT_ULL(NL80211_STA_INFO_RX_BYTES64);
 
-		sinfo->tx_packets = msta->wcid.stats.tx_packets;
+		sinfo->tx_packets = mlink->wcid.stats.tx_packets;
 		sinfo->filled |= BIT_ULL(NL80211_STA_INFO_TX_PACKETS);
 
-		sinfo->rx_packets = msta->wcid.stats.rx_packets;
+		sinfo->rx_packets = mlink->wcid.stats.rx_packets;
 		sinfo->filled |= BIT_ULL(NL80211_STA_INFO_RX_PACKETS);
 	}
+out:
+	mutex_unlock(&dev->mt76.mutex);
+}
+
+static void mt7996_sta_link_statistics(struct ieee80211_hw *hw,
+				       struct ieee80211_vif *vif,
+				       struct ieee80211_sta *sta,
+				       unsigned int link_id,
+				       struct station_link_info *linfo)
+{
+	struct mt7996_dev *dev = mt7996_hw_dev(hw);
+	struct mt7996_sta *msta = (struct mt7996_sta *)sta->drv_priv;
+	struct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;
+	struct mt7996_link_sta *mlink;
+	struct mt7996_bss_conf *mconf;
+	struct mt76_sta_stats *stats;
+	int i;
+
+	mutex_lock(&dev->mt76.mutex);
+	mlink = mlink_dereference_protected(msta, link_id);
+	if (!mlink)
+		goto out;
+	stats = &mlink->wcid.stats;
+
+	mconf = mconf_dereference_protected(mvif, link_id);
+	if (!mconf)
+		goto out;
+
+	linfo->signal = (s8)mlink->signal;
+	linfo->filled |= BIT_ULL(NL80211_STA_INFO_SIGNAL);
+
+	linfo->chains = mconf->phy->mt76->antenna_mask;
+	memcpy(linfo->chain_signal, mlink->chain_signal, IEEE80211_MAX_CHAINS);
+	linfo->filled |= BIT_ULL(NL80211_STA_INFO_CHAIN_SIGNAL);
+
+	linfo->signal_avg = -(s8)ewma_avg_signal_read(&mlink->signal_avg);
+	linfo->filled |= BIT_ULL(NL80211_STA_INFO_SIGNAL_AVG);
+
+	for (i = 0; i < IEEE80211_MAX_CHAINS; ++i)
+		linfo->chain_signal_avg[i] = -(s8)ewma_avg_signal_read(mlink->chain_signal_avg + i);
+	linfo->filled |= BIT_ULL(NL80211_STA_INFO_CHAIN_SIGNAL_AVG);
+
+	linfo->ack_signal = (s8)mlink->ack_signal;
+	linfo->filled |= BIT_ULL(NL80211_STA_INFO_ACK_SIGNAL);
+
+	linfo->avg_ack_signal = -(s8)ewma_avg_signal_read(&mlink->avg_ack_signal);
+	linfo->filled |= BIT_ULL(NL80211_STA_INFO_ACK_SIGNAL_AVG);
+
+	linfo->txrate = mlink->wcid.rate;
+	linfo->filled |= BIT_ULL(NL80211_STA_INFO_TX_BITRATE);
+
+	linfo->rxrate = mlink->wcid.rx_rate;
+	linfo->filled |= BIT_ULL(NL80211_STA_INFO_RX_BITRATE);
+
+	linfo->tx_bytes = stats->tx_bytes;
+	linfo->filled |= BIT_ULL(NL80211_STA_INFO_TX_BYTES64);
+
+	linfo->rx_bytes = stats->rx_bytes;
+	linfo->filled |= BIT_ULL(NL80211_STA_INFO_RX_BYTES64);
+
+	linfo->tx_failed = stats->tx_failed;
+	linfo->filled |= BIT_ULL(NL80211_STA_INFO_TX_FAILED);
+
+	linfo->tx_retries = stats->tx_retries;
+	linfo->filled |= BIT_ULL(NL80211_STA_INFO_TX_RETRIES);
+
+	linfo->rx_mpdu_count = stats->rx_mpdus;
+	linfo->filled |= BIT_ULL(NL80211_STA_INFO_RX_MPDUS);
+
+	linfo->fcs_err_count = stats->rx_fcs_err;
+	linfo->filled |= BIT_ULL(NL80211_STA_INFO_FCS_ERROR_COUNT);
+
+	linfo->tx_duration = stats->tx_airtime;
+	linfo->filled |= BIT_ULL(NL80211_STA_INFO_TX_DURATION);
+
+	linfo->rx_duration = stats->rx_airtime;
+	linfo->filled |= BIT_ULL(NL80211_STA_INFO_RX_DURATION);
+out:
+	mutex_unlock(&dev->mt76.mutex);
 }
 
 static void mt7996_sta_rc_work(void *data, struct ieee80211_sta *sta)
 {
 	struct mt7996_sta *msta = (struct mt7996_sta *)sta->drv_priv;
-	struct mt7996_dev *dev = msta->vif->deflink.phy->dev;
-	u32 *changed = data;
+	struct mt7996_link_sta *mlink;
+	struct mt7996_dev *dev = msta->vif->dev;
+	struct mt7996_sta_rc_work_data *wd = data;
+
+	rcu_read_lock();
+	mlink = rcu_dereference(msta->link[wd->link_id]);
+
+	if (!mlink)
+		goto unlock;
 
 	spin_lock_bh(&dev->mt76.sta_poll_lock);
-	msta->changed |= *changed;
-	if (list_empty(&msta->rc_list))
-		list_add_tail(&msta->rc_list, &dev->sta_rc_list);
+	mlink->changed |= wd->changed;
+	if (list_empty(&mlink->rc_list))
+		list_add_tail(&mlink->rc_list, &dev->sta_rc_list);
 	spin_unlock_bh(&dev->mt76.sta_poll_lock);
+
+unlock:
+	rcu_read_unlock();
 }
 
 static void mt7996_link_sta_rc_update(struct ieee80211_hw *hw,
@@ -1234,21 +1950,48 @@ static void mt7996_link_sta_rc_update(struct ieee80211_hw *hw,
 				      u32 changed)
 {
 	struct ieee80211_sta *sta = link_sta->sta;
-	struct mt7996_dev *dev = mt7996_hw_dev(hw);
+	struct mt7996_sta *msta = (struct mt7996_sta *)sta->drv_priv;
+	struct mt7996_phy *phy = mt7996_hw_phy(hw);
+	struct mt7996_dev *dev = phy->dev;
+	struct mt7996_sta_rc_work_data data = {
+		.link_id = msta->pri_link,
+		.changed = changed,
+	};
+
+	if (!msta->vif) {
+		dev_warn(dev->mt76.dev, "Un-initialized STA %pM wcid %d in rc_work\n",
+			 sta->addr, msta->deflink.wcid.idx);
+		return;
+	}
 
-	mt7996_sta_rc_work(&changed, sta);
+	mt7996_sta_rc_work(&data, sta);
 	ieee80211_queue_work(hw, &dev->rc_work);
 }
 
 static int
 mt7996_set_bitrate_mask(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
-			const struct cfg80211_bitrate_mask *mask)
+			const struct cfg80211_bitrate_mask *mask,
+			unsigned int link_id)
 {
-	struct mt7996_dev *dev = mt7996_hw_dev(hw);
 	struct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;
-	u32 changed = IEEE80211_RC_SUPP_RATES_CHANGED;
+	struct mt7996_phy *phy = mt7996_hw_phy(hw);
+	struct mt7996_dev *dev = phy->dev;
+	struct mt7996_bss_conf *mconf;
+	struct mt7996_sta_rc_work_data data = {
+		.link_id = link_id,
+		.changed = IEEE80211_RC_SUPP_RATES_CHANGED,
+	};
+
+	mutex_lock(&dev->mt76.mutex);
+	mconf = mconf_dereference_protected(mvif, link_id);
 
-	mvif->deflink.bitrate_mask = *mask;
+	if (!mconf) {
+		mutex_unlock(&dev->mt76.mutex);
+		return -EINVAL;
+	}
+
+	mconf->bitrate_mask = *mask;
+	mutex_unlock(&dev->mt76.mutex);
 
 	/* if multiple rates across different preambles are given we can
 	 * reconfigure this info with all peers using sta_rec command with
@@ -1258,7 +2001,7 @@ mt7996_set_bitrate_mask(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 	 * - multiple rates: if it's not in range format i.e 0-{7,8,9} for VHT
 	 * then multiple MCS setting (MCS 4,5,6) is not supported.
 	 */
-	ieee80211_iterate_stations_atomic(hw, mt7996_sta_rc_work, &changed);
+	ieee80211_iterate_stations_atomic(hw, mt7996_sta_rc_work, &data);
 	ieee80211_queue_work(hw, &dev->rc_work);
 
 	return 0;
@@ -1270,17 +2013,29 @@ static void mt7996_sta_set_4addr(struct ieee80211_hw *hw,
 				 bool enabled)
 {
 	struct mt7996_dev *dev = mt7996_hw_dev(hw);
+	struct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;
 	struct mt7996_sta *msta = (struct mt7996_sta *)sta->drv_priv;
+	unsigned long valid_links = sta->valid_links ?: BIT(0);
+	unsigned int link_id;
 
-	if (enabled)
-		set_bit(MT_WCID_FLAG_4ADDR, &msta->wcid.flags);
-	else
-		clear_bit(MT_WCID_FLAG_4ADDR, &msta->wcid.flags);
+	mutex_lock(&dev->mt76.mutex);
+	for_each_set_bit(link_id, &valid_links, IEEE80211_MLD_MAX_NUM_LINKS) {
+		struct mt7996_bss_conf *mconf =
+			mconf_dereference_protected(mvif, link_id);
+		struct mt7996_link_sta *mlink =
+			mlink_dereference_protected(msta, link_id);
 
-	if (!msta->wcid.sta)
-		return;
+		if (!mconf || !mlink)
+			continue;
 
-	mt7996_mcu_wtbl_update_hdr_trans(dev, vif, sta);
+		if (enabled)
+			set_bit(MT_WCID_FLAG_4ADDR, &mlink->wcid.flags);
+		else
+			clear_bit(MT_WCID_FLAG_4ADDR, &mlink->wcid.flags);
+
+		mt7996_mcu_wtbl_update_hdr_trans(dev, vif, mconf, mlink);
+	}
+	mutex_unlock(&dev->mt76.mutex);
 }
 
 static void mt7996_sta_set_decap_offload(struct ieee80211_hw *hw,
@@ -1289,17 +2044,29 @@ static void mt7996_sta_set_decap_offload(struct ieee80211_hw *hw,
 					 bool enabled)
 {
 	struct mt7996_dev *dev = mt7996_hw_dev(hw);
+	struct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;
 	struct mt7996_sta *msta = (struct mt7996_sta *)sta->drv_priv;
+	unsigned long valid_links = sta->valid_links ?: BIT(0);
+	unsigned int link_id;
 
-	if (enabled)
-		set_bit(MT_WCID_FLAG_HDR_TRANS, &msta->wcid.flags);
-	else
-		clear_bit(MT_WCID_FLAG_HDR_TRANS, &msta->wcid.flags);
+	mutex_lock(&dev->mt76.mutex);
+	for_each_set_bit(link_id, &valid_links, IEEE80211_MLD_MAX_NUM_LINKS) {
+		struct mt7996_bss_conf *mconf =
+			mconf_dereference_protected(mvif, link_id);
+		struct mt7996_link_sta *mlink =
+			mlink_dereference_protected(msta, link_id);
 
-	if (!msta->wcid.sta)
-		return;
+		if (!mconf || !mlink)
+			continue;
 
-	mt7996_mcu_wtbl_update_hdr_trans(dev, vif, sta);
+		if (enabled)
+			set_bit(MT_WCID_FLAG_HDR_TRANS, &mlink->wcid.flags);
+		else
+			clear_bit(MT_WCID_FLAG_HDR_TRANS, &mlink->wcid.flags);
+
+		mt7996_mcu_wtbl_update_hdr_trans(dev, vif, mconf, mlink);
+	}
+	mutex_unlock(&dev->mt76.mutex);
 }
 
 static const char mt7996_gstrings_stats[][ETH_GSTRING_LEN] = {
@@ -1431,11 +2198,16 @@ static void mt7996_ethtool_worker(void *wi_data, struct ieee80211_sta *sta)
 {
 	struct mt76_ethtool_worker_info *wi = wi_data;
 	struct mt7996_sta *msta = (struct mt7996_sta *)sta->drv_priv;
+	struct mt7996_link_sta *mlink;
+	struct mt7996_bss_conf *mconf;
+
+	mlink = mlink_dereference_protected(msta, msta->pri_link);
+	mconf = mconf_dereference_protected(msta->vif, msta->pri_link);
 
-	if (msta->vif->deflink.mt76.idx != wi->idx)
+	if (mconf->mt76.idx != wi->idx)
 		return;
 
-	mt76_ethtool_worker(wi, &msta->wcid.stats, true);
+	mt76_ethtool_worker(wi, &mlink->wcid.stats, true);
 }
 
 static
@@ -1444,12 +2216,12 @@ void mt7996_get_et_stats(struct ieee80211_hw *hw,
 			 struct ethtool_stats *stats, u64 *data)
 {
 	struct mt7996_dev *dev = mt7996_hw_dev(hw);
+	struct mt7996_phy *phy = mt7996_hw_phy(hw);
 	struct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;
-	struct mt7996_phy *phy = mt7996_vif_link_phy(&mvif->deflink);
+	struct mt7996_bss_conf *mconf;
 	struct mt76_mib_stats *mib = &phy->mib;
 	struct mt76_ethtool_worker_info wi = {
 		.data = data,
-		.idx = mvif->deflink.mt76.idx,
 	};
 	/* See mt7996_ampdu_stat_read_phy, etc */
 	int i, ei = 0;
@@ -1458,6 +2230,8 @@ void mt7996_get_et_stats(struct ieee80211_hw *hw,
 		return;
 
 	mutex_lock(&dev->mt76.mutex);
+	mconf = mconf_dereference_protected(mvif, mvif->master_link_id);
+	wi.idx = mconf->mt76.idx,
 
 	mt7996_mac_update_stats(phy);
 
@@ -1539,28 +2313,79 @@ mt7996_twt_teardown_request(struct ieee80211_hw *hw,
 			    u8 flowid)
 {
 	struct mt7996_sta *msta = (struct mt7996_sta *)sta->drv_priv;
+	struct mt7996_link_sta *mlink;
 	struct mt7996_dev *dev = mt7996_hw_dev(hw);
 
 	mutex_lock(&dev->mt76.mutex);
-	mt7996_mac_twt_teardown_flow(dev, msta, flowid);
+	mlink = mlink_dereference_protected(msta, 0);
+	mt7996_mac_twt_teardown_flow(dev, mlink, flowid);
 	mutex_unlock(&dev->mt76.mutex);
 }
 
+static void
+mt7996_background_radar_handle_7975_ifem(struct ieee80211_hw *hw,
+					 struct cfg80211_chan_def *user_chandef,
+					 struct cfg80211_chan_def *fw_chandef)
+{
+	struct mt7996_dev *dev = mt7996_hw_dev(hw);
+	struct cfg80211_chan_def *c = user_chandef;
+	struct ieee80211_channel *first_chan;
+	bool is_ifem_adie, expand = false;
+
+	switch (mt76_chip(&dev->mt76)) {
+	case MT7996_DEVICE_ID:
+		is_ifem_adie = dev->var.fem == MT7996_FEM_INT &&
+			       dev->var.type != MT7996_VAR_TYPE_233;
+		break;
+	case MT7992_DEVICE_ID:
+		is_ifem_adie = dev->var.type == MT7992_VAR_TYPE_44 &&
+			       dev->var.fem != MT7996_FEM_EXT;
+		break;
+	default:
+		return;
+	}
+
+	if (!user_chandef || !is_ifem_adie)
+		goto out;
+
+	if (user_chandef->width == NL80211_CHAN_WIDTH_160) {
+		first_chan = ieee80211_get_channel(hw->wiphy, user_chandef->center_freq1 - 70);
+		if (dev->bg_nxt_freq)
+			goto out;
+
+		if (first_chan->flags & IEEE80211_CHAN_RADAR)
+			dev->bg_nxt_freq = first_chan->center_freq;
+		else
+			c = fw_chandef;
+
+		c->chan = ieee80211_get_channel(hw->wiphy, first_chan->center_freq + 80);
+	} else {
+		if (!dev->bg_nxt_freq)
+			goto out;
+
+		c->chan = ieee80211_get_channel(hw->wiphy, dev->bg_nxt_freq);
+		dev->bg_nxt_freq = 0;
+		expand = true;
+	}
+	c->width = NL80211_CHAN_WIDTH_80;
+	c->center_freq1 = c->chan->center_freq + 30;
+
+	if (c == user_chandef)
+		cfg80211_background_radar_update_channel(hw->wiphy, c, expand);
+	return;
+out:
+	dev->bg_nxt_freq = 0;
+}
+
 static int
 mt7996_set_radar_background(struct ieee80211_hw *hw,
 			    struct cfg80211_chan_def *chandef)
 {
 	struct mt7996_dev *dev = mt7996_hw_dev(hw);
-	struct mt7996_phy *phy;
+	struct mt7996_phy *phy = mt7996_band_phy(dev, NL80211_BAND_5GHZ);
 	int ret = -EINVAL;
 	bool running;
-
-	if (chandef)
-		phy = mt7996_band_phy(dev, chandef->chan->band);
-	else
-		phy = dev->rdd2_phy;
-	if (!phy)
-	    return -EINVAL;
+	struct cfg80211_chan_def ifem_chandef = {};
 
 	mutex_lock(&dev->mt76.mutex);
 
@@ -1573,13 +2398,14 @@ mt7996_set_radar_background(struct ieee80211_hw *hw,
 		goto out;
 	}
 
+	mt7996_background_radar_handle_7975_ifem(hw, chandef, &ifem_chandef);
+
 	/* rdd2 already configured on a radar channel */
 	running = dev->rdd2_phy &&
 		  cfg80211_chandef_valid(&dev->rdd2_chandef) &&
 		  !!(dev->rdd2_chandef.chan->flags & IEEE80211_CHAN_RADAR);
 
-	if (!chandef || running ||
-	    !(chandef->chan->flags & IEEE80211_CHAN_RADAR)) {
+	if (!chandef || running) {
 		ret = mt7996_mcu_rdd_background_enable(phy, NULL);
 		if (ret)
 			goto out;
@@ -1588,7 +2414,9 @@ mt7996_set_radar_background(struct ieee80211_hw *hw,
 			goto update_phy;
 	}
 
-	ret = mt7996_mcu_rdd_background_enable(phy, chandef);
+	ret = mt7996_mcu_rdd_background_enable(phy,
+					       ifem_chandef.chan ?
+					       &ifem_chandef : chandef);
 	if (ret)
 		goto out;
 
@@ -1612,32 +2440,54 @@ mt7996_net_fill_forward_path(struct ieee80211_hw *hw,
 {
 	struct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;
 	struct mt7996_sta *msta = (struct mt7996_sta *)sta->drv_priv;
-	struct mt7996_vif_link *mlink = &mvif->deflink;
 	struct mt7996_dev *dev = mt7996_hw_dev(hw);
 	struct mtk_wed_device *wed = &dev->mt76.mmio.wed;
-	struct mt7996_phy *phy;
+	struct mt7996_bss_conf *mconf;
+	struct mt7996_link_sta *mlink;
+	u8 link_id;
 
-	phy = mt7996_vif_link_phy(mlink);
-	if (!phy)
-		return -ENODEV;
+	link_id = msta->pri_link;
+	mconf = rcu_dereference(mvif->link[link_id]);
+	mlink = rcu_dereference(msta->link[link_id]);
+
+	if (!mlink || !mconf || mlink->wcid.idx > MT7996_WTBL_STA)
+		return -EIO;
+
+	if (!test_bit((mvif->qos_map[dscp] + AMPDU_ADDBA_SUCC_SHFT),
+	    &mlink->wcid.ampdu_state))
+		return -EAGAIN;
 
-	if (phy != &dev->phy && phy->mt76->band_idx == MT_BAND2)
-		wed = &dev->mt76.mmio.wed_hif2;
+	if (dev->hif2) {
+		switch (dev->option_type) {
+		case 2:
+			/* eagle + 7988d */
+			if (mlink->wcid.phy_idx == MT_BAND1)
+				wed = &dev->mt76.mmio.wed_hif2;
+			break;
+		default:
+			if ((is_mt7996(&dev->mt76) && mlink->wcid.phy_idx == MT_BAND2) ||
+			    (is_mt7992(&dev->mt76) && mlink->wcid.phy_idx == MT_BAND1))
+				wed = &dev->mt76.mmio.wed_hif2;
+			break;
+		}
+	}
 
 	if (!mtk_wed_device_active(wed))
 		return -ENODEV;
 
-	if (!msta->wcid.sta || msta->wcid.idx > MT7996_WTBL_STA)
-		return -EIO;
-
 	path->type = DEV_PATH_MTK_WDMA;
 	path->dev = ctx->dev;
 	path->mtk_wdma.wdma_idx = wed->wdma_idx;
-	path->mtk_wdma.bss = mvif->deflink.mt76.idx;
+	path->mtk_wdma.bss = mconf->mt76.idx;
 	path->mtk_wdma.queue = 0;
-	path->mtk_wdma.wcid = msta->wcid.idx;
+	path->mtk_wdma.wcid = mlink->wcid.idx;
+
+	if (ieee80211_hw_check(hw, SUPPORTS_AMSDU_IN_AMPDU) &&
+	    mtk_wed_is_amsdu_supported(wed))
+		path->mtk_wdma.amsdu = mlink->wcid.amsdu;
+	else
+		path->mtk_wdma.amsdu = 0;
 
-	path->mtk_wdma.amsdu = mtk_wed_is_amsdu_supported(wed);
 	ctx->dev = NULL;
 
 	return 0;
@@ -1645,13 +2495,410 @@ mt7996_net_fill_forward_path(struct ieee80211_hw *hw,
 
 #endif
 
+void mt7996_scan_complete(struct mt7996_phy *phy, bool aborted)
+{
+	struct mt7996_vif *mvif = (struct mt7996_vif *)phy->scan_vif->drv_priv;
+	struct cfg80211_scan_info info = {
+		.aborted = aborted,
+	};
+
+	ieee80211_scan_completed(phy->mt76->hw, &info);
+	phy->scan_chan = NULL;
+	phy->scan_req = NULL;
+	phy->scan_vif = NULL;
+	clear_bit(MT76_SCANNING, &phy->mt76->state);
+}
+
+static int
+mt7996_hw_scan(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
+	       struct ieee80211_scan_request *hw_req)
+{
+	struct cfg80211_scan_request *req = &hw_req->req;
+	struct mt7996_dev *dev = mt7996_hw_dev(hw);
+	struct mt7996_phy *phy = mt7996_band_phy(dev, req->channels[0]->band);
+	struct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;
+	int ret;
+
+	mutex_lock(&phy->dev->mt76.mutex);
+	if (WARN_ON(phy->scan_req || phy->scan_chan)) {
+		mutex_unlock(&phy->dev->mt76.mutex);
+		return -EBUSY;
+	}
+
+	phy->scan_req = req;
+	phy->scan_vif = vif;
+	phy->scan_chan_idx = 0;
+
+	if (vif->type == NL80211_IFTYPE_STATION && !ieee80211_vif_is_mld(vif) &&
+	    (phy->mt76 != mvif->deflink.phy->mt76)) {
+		// phy->mt76->main_phy = hw->priv;
+		mt7996_remove_bss_conf(vif, &vif->bss_conf, &mvif->deflink);
+
+		ret = mt7996_add_bss_conf(phy, vif, &vif->bss_conf);
+		if (ret) {
+			mutex_unlock(&phy->dev->mt76.mutex);
+			return ret;
+		}
+	}
+
+	set_bit(MT76_SCANNING, &phy->mt76->state);
+	mutex_unlock(&phy->dev->mt76.mutex);
+
+	ieee80211_queue_delayed_work(phy->mt76->hw, &phy->scan_work, 0);
+
+	return 0;
+}
+
+static void
+mt7996_cancel_hw_scan(struct ieee80211_hw *hw, struct ieee80211_vif *vif)
+{
+	// struct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;
+	struct mt7996_dev *dev = mt7996_hw_dev(hw);
+	int band;
+
+	for (band = 0; band < NUM_NL80211_BANDS; band++) {
+		struct mt7996_phy *phy;
+
+		if (!hw->wiphy->bands[band])
+			continue;
+
+		phy = mt7996_band_phy(dev, band);
+		if (!test_bit(MT76_SCANNING, &phy->mt76->state))
+			continue;
+
+		cancel_delayed_work_sync(&phy->scan_work);
+
+		mutex_lock(&phy->dev->mt76.mutex);
+		mt7996_scan_complete(phy, true);
+		// if (vif->type == NL80211_IFTYPE_STATION && !ieee80211_vif_is_mld(vif) &&
+		//     (phy->mt76 != mvif->deflink.phy->mt76))
+		// 	phy->mt76->main_phy = NULL;
+		mutex_unlock(&phy->dev->mt76.mutex);
+	}
+}
+
+static int
+mt7996_add_chanctx(struct ieee80211_hw *hw, struct ieee80211_chanctx_conf *conf)
+{
+	struct mt7996_dev *dev = mt7996_hw_dev(hw);
+	struct mt7996_phy *phy = mt7996_band_phy(dev, conf->def.chan->band);
+	struct mt7996_chanctx *ctx = mt7996_chanctx_get(conf);
+	int ret;
+
+	wiphy_info(hw->wiphy, "%s: add %u\n", __func__, conf->def.chan->hw_value);
+	mutex_lock(&phy->dev->mt76.mutex);
+
+	if (ctx->assigned) {
+		mutex_unlock(&phy->dev->mt76.mutex);
+		return -ENOSPC;
+	}
+
+	ctx->assigned = true;
+	ctx->chandef = conf->def;
+	ctx->phy = phy;
+	if (phy->chanctx) {
+		mutex_unlock(&phy->dev->mt76.mutex);
+		return 0;
+	}
+
+	phy->chanctx = ctx;
+	phy->mt76->radar_enabled = conf->radar_enabled;
+	mutex_unlock(&phy->dev->mt76.mutex);
+
+	if (!mt76_testmode_enabled(phy->mt76) && !phy->mt76->test.bf_en) {
+		ret = mt7996_mcu_edcca_enable(phy, true);
+		if (ret)
+			return ret;
+	}
+
+	ret = mt7996_mcu_set_pp_en(phy, PP_USR_MODE, ctx->chandef.punctured);
+	if (ret)
+		return ret;
+
+	return mt7996_set_channel(phy, &ctx->chandef);
+}
+
+static void
+mt7996_remove_chanctx(struct ieee80211_hw *hw, struct ieee80211_chanctx_conf *conf)
+{
+	struct mt7996_chanctx *ctx = mt7996_chanctx_get(conf);
+	struct mt7996_phy *phy = ctx->phy;
+
+	wiphy_info(hw->wiphy, "%s: remove %u\n", __func__, conf->def.chan->hw_value);
+	cancel_delayed_work_sync(&phy->scan_work);
+	cancel_delayed_work_sync(&phy->mt76->mac_work);
+
+	mutex_lock(&phy->dev->mt76.mutex);
+	ctx->assigned = false;
+	if (ctx == phy->chanctx) {
+		phy->chanctx = NULL;
+		phy->mt76->radar_enabled = false;
+	}
+	mutex_unlock(&phy->dev->mt76.mutex);
+}
+
+static void
+mt7996_change_chanctx(struct ieee80211_hw *hw, struct ieee80211_chanctx_conf *conf,
+		      u32 changed)
+{
+	struct mt7996_chanctx *ctx = mt7996_chanctx_get(conf);
+	struct mt7996_phy *phy = ctx->phy;
+
+	wiphy_info(hw->wiphy, "%s: change %u, 0x%x\n", __func__, conf->def.chan->hw_value, changed);
+	if (changed & IEEE80211_CHANCTX_CHANGE_WIDTH ||
+	    changed & IEEE80211_CHANCTX_CHANGE_RADAR) {
+		ctx->chandef = conf->def;
+		phy->mt76->radar_enabled = conf->radar_enabled;
+
+		mt7996_set_channel(phy, &ctx->chandef);
+	}
+}
+
+static int
+mt7996_assign_vif_chanctx(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
+			  struct ieee80211_bss_conf *link_conf,
+			  struct ieee80211_chanctx_conf *conf)
+{
+	struct mt7996_chanctx *ctx = mt7996_chanctx_get(conf);
+	struct mt7996_phy *phy = ctx->phy;
+	struct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;
+	struct mt7996_bss_conf *mconf;
+	u8 link_id = link_conf->link_id;
+	int ret;
+
+	wiphy_info(hw->wiphy, "Assign VIF (addr: %pM, type: %d, link_id: %d) to channel context: %d MHz\n",
+		    vif->addr, vif->type, link_conf->link_id,
+		    conf->def.chan->center_freq);
+
+	mutex_lock(&phy->dev->mt76.mutex);
+
+	mconf = mconf_dereference_protected(mvif, link_id);
+
+	/* Remove bss conf when change non-MLO interface to MLO interface */
+	if (ieee80211_vif_is_mld(vif) && mconf == &mvif->deflink)
+		mt7996_remove_bss_conf(vif, link_conf, mconf);
+	else if (mconf && phy != mconf->phy)
+		dev_err(phy->dev->mt76.dev,
+			"%s: error: change link[%d] from phy%d to phy%d",
+			__func__, link_id, mconf->phy->mt76->band_idx,
+			phy->mt76->band_idx);
+
+	ret = mt7996_add_bss_conf(phy, vif, link_conf);
+	if (ret) {
+		mutex_unlock(&phy->dev->mt76.mutex);
+		return ret;
+	}
+
+	ctx->nbss_assigned++;
+	mvif->band_to_link[phy->mt76->band_idx] = link_id;
+
+	if (mt7996_hw_phy(hw) == phy)
+		mvif->master_link_id = link_id;
+
+	mutex_unlock(&phy->dev->mt76.mutex);
+
+	return 0;
+}
+
+static void
+mt7996_unassign_vif_chanctx(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
+			    struct ieee80211_bss_conf *link_conf,
+			    struct ieee80211_chanctx_conf *conf)
+{
+	struct mt7996_chanctx *ctx = mt7996_chanctx_get(conf);
+	struct mt7996_phy *phy = ctx->phy;
+
+	wiphy_info(hw->wiphy, "Remove VIF (addr: %pM, type: %d, link_id: %d) from channel context: %d MHz\n",
+		   vif->addr, vif->type, link_conf->link_id,
+		   conf->def.chan->center_freq);
+	cancel_delayed_work_sync(&phy->scan_work);
+
+	mutex_lock(&phy->dev->mt76.mutex);
+
+	if (test_bit(MT76_SCANNING, &phy->mt76->state))
+		mt7996_scan_complete(phy, true);
+
+	ctx->nbss_assigned--;
+
+	mutex_unlock(&phy->dev->mt76.mutex);
+}
+
+static int
+mt7996_switch_vif_chanctx(struct ieee80211_hw *hw,
+			  struct ieee80211_vif_chanctx_switch *vifs,
+			  int n_vifs,
+			  enum ieee80211_chanctx_switch_mode mode)
+{
+	struct mt7996_chanctx *old_ctx = mt7996_chanctx_get(vifs->old_ctx);
+	struct mt7996_chanctx *new_ctx = mt7996_chanctx_get(vifs->new_ctx);
+	struct mt7996_phy *phy = old_ctx->phy;
+
+	wiphy_info(hw->wiphy, "%s: old=%d, new=%d\n", __func__, vifs->old_ctx->def.chan->hw_value, vifs->new_ctx->def.chan->hw_value);
+
+	if (new_ctx->nbss_assigned && phy->chanctx == new_ctx) {
+		new_ctx->nbss_assigned += n_vifs;
+		return 0;
+	}
+
+	if (WARN_ON(old_ctx != phy->chanctx))
+		return -EINVAL;
+
+	mutex_lock(&phy->dev->mt76.mutex);
+
+	phy->chanctx = new_ctx;
+	phy->mt76->radar_enabled = vifs->new_ctx->radar_enabled;
+	new_ctx->assigned = true;
+	new_ctx->chandef = vifs->new_ctx->def;
+	new_ctx->phy = phy;
+	new_ctx->nbss_assigned += n_vifs;
+
+	mutex_unlock(&phy->dev->mt76.mutex);
+
+	return mt7996_set_channel(phy, &new_ctx->chandef);
+}
+
+static int
+mt7996_change_vif_links(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
+			u16 old_links, u16 new_links,
+			struct ieee80211_bss_conf *old[IEEE80211_MLD_MAX_NUM_LINKS])
+{
+	struct mt7996_dev *dev = mt7996_hw_dev(hw);
+	struct mt7996_phy *phy = mt7996_hw_phy(hw);
+	struct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;
+	unsigned long rem = old_links & ~new_links;
+	unsigned int link_id;
+	int ret = 0;
+
+	mlo_dbg(phy, "old=%u, new=%u\n", old_links, new_links);
+	if (old_links == new_links)
+		return 0;
+
+	mutex_lock(&dev->mt76.mutex);
+
+	/* remove first */
+	for_each_set_bit(link_id, &rem, IEEE80211_MLD_MAX_NUM_LINKS) {
+		struct mt7996_bss_conf *mconf =
+			mconf_dereference_protected(mvif, link_id);
+
+		if (!mconf)
+			continue;
+
+		mt7996_remove_bss_conf(vif, old[link_id], mconf);
+	}
+
+	if (!old_links) {
+		struct mt7996_bss_conf *mconf =
+			mconf_dereference_protected(mvif, 0);
+
+		if (ieee80211_vif_is_mld(vif) && mconf == &mvif->deflink)
+			mt7996_remove_bss_conf(vif, &vif->bss_conf, mconf);
+
+		mvif->group_mld_id = get_own_mld_idx(dev->mld_id_mask, true);
+		dev->mld_id_mask |= BIT_ULL(mvif->group_mld_id);
+
+		mvif->mld_remap_id = get_mld_remap_idx(dev->mld_remap_id_mask);
+		dev->mld_remap_id_mask |= BIT_ULL(mvif->mld_remap_id);
+	}
+
+	/* fallback to non-MLO interface */
+	if (!new_links) {
+		ret = mt7996_add_bss_conf(phy, vif, &vif->bss_conf);
+		dev->mld_id_mask &= ~BIT_ULL(mvif->group_mld_id);
+		dev->mld_remap_id_mask &= ~BIT_ULL(mvif->mld_remap_id);
+	}
+
+	mutex_unlock(&dev->mt76.mutex);
+
+	return ret;
+}
+
+static int
+mt7996_change_sta_links(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
+			struct ieee80211_sta *sta, u16 old_links, u16 new_links)
+{
+	struct mt7996_dev *dev = mt7996_hw_dev(hw);
+	unsigned long add = new_links & ~old_links;
+	unsigned long rem = old_links & ~new_links;
+	int ret = 0;
+
+	mlo_dbg(mt7996_hw_phy(hw), "old=%u, new=%u\n", old_links, new_links);
+	mutex_lock(&dev->mt76.mutex);
+
+	if (rem)
+		mt7996_mac_sta_remove_links(dev, vif, sta, rem);
+
+	ret = mt7996_mac_sta_add_links(dev, vif, sta, add, false);
+	if (ret)
+		goto remove;
+
+	goto out;
+remove:
+	mt7996_mac_sta_remove_links(dev, vif, sta, add);
+out:
+	mutex_unlock(&dev->mt76.mutex);
+	return ret;
+}
+
+static void
+mt7996_event_callback(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
+		      const struct ieee80211_event *event)
+{
+	struct mt7996_dev *dev = mt7996_hw_dev(hw);
+	struct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;
+	int i;
+
+	switch (event->type) {
+	case MLME_EVENT:
+		if (event->u.mlme.data == ASSOC_EVENT &&
+		    event->u.mlme.status == MLME_SUCCESS) {
+			struct ieee80211_bss_conf *conf;
+			struct mt7996_bss_conf *mconf;
+			struct mt7996_phy *phy;
+			unsigned long cur, valid_links = vif->valid_links ?: BIT(0);
+			unsigned int link_id;
+			int next_time = INT_MAX;
+
+			mutex_lock(&dev->mt76.mutex);
+			cur = jiffies;
+			for_each_set_bit(link_id, &valid_links, IEEE80211_MLD_MAX_NUM_LINKS) {
+				conf = link_conf_dereference_protected(vif, link_id);
+				mconf = mconf_dereference_protected(mvif, link_id);
+
+				if (!conf || !mconf)
+					continue;
+
+				phy = mconf->phy;
+				mvif->beacon_received_time[phy->mt76->band_idx] = cur;
+				next_time = min(next_time,
+						MT7996_MAX_BEACON_LOSS *
+						conf->beacon_int);
+			}
+
+			ieee80211_queue_delayed_work(hw, &mvif->beacon_mon_work,
+						     msecs_to_jiffies(next_time));
+			mutex_unlock(&dev->mt76.mutex);
+			break;
+		}
+
+		mutex_lock(&dev->mt76.mutex);
+		memset(mvif->probe_send_count, 0, sizeof(mvif->probe_send_count));
+		for (i = 0; i < __MT_MAX_BAND; i++)
+			mvif->probe[i] = NULL;
+		mvif->lost_links = 0;
+		mutex_unlock(&dev->mt76.mutex);
+
+		cancel_delayed_work(&mvif->beacon_mon_work);
+		break;
+	default:
+		break;
+	}
+}
+
 const struct ieee80211_ops mt7996_ops = {
-	.add_chanctx = mt76_add_chanctx,
-	.remove_chanctx = mt76_remove_chanctx,
-	.change_chanctx = mt76_change_chanctx,
-	.assign_vif_chanctx = mt76_assign_vif_chanctx,
-	.unassign_vif_chanctx = mt76_unassign_vif_chanctx,
-	.switch_vif_chanctx = mt76_switch_vif_chanctx,
+	.add_chanctx = ieee80211_emulate_add_chanctx,
+	.remove_chanctx = ieee80211_emulate_remove_chanctx,
+	.change_chanctx = ieee80211_emulate_change_chanctx,
+	.switch_vif_chanctx = ieee80211_emulate_switch_vif_chanctx,
 	.tx = mt7996_tx,
 	.start = mt7996_start,
 	.stop = mt7996_stop,
@@ -1660,21 +2907,21 @@ const struct ieee80211_ops mt7996_ops = {
 	.config = mt7996_config,
 	.conf_tx = mt7996_conf_tx,
 	.configure_filter = mt7996_configure_filter,
-	.bss_info_changed = mt7996_bss_info_changed,
+	.vif_cfg_changed = mt7996_vif_cfg_changed,
+	.link_info_changed = mt7996_link_info_changed,
 	.sta_state = mt76_sta_state,
-	.sta_pre_rcu_remove = mt76_sta_pre_rcu_remove,
+	.sta_pre_rcu_remove = mt7996_sta_pre_rcu_remove,
 	.link_sta_rc_update = mt7996_link_sta_rc_update,
 	.set_key = mt7996_set_key,
 	.ampdu_action = mt7996_ampdu_action,
 	.set_rts_threshold = mt7996_set_rts_threshold,
 	.wake_tx_queue = mt76_wake_tx_queue,
-	.hw_scan = mt76_hw_scan,
-	.cancel_hw_scan = mt76_cancel_hw_scan,
-	.remain_on_channel = mt76_remain_on_channel,
-	.cancel_remain_on_channel = mt76_cancel_remain_on_channel,
+	.hw_scan = mt7996_hw_scan,
+	.cancel_hw_scan = mt7996_cancel_hw_scan,
 	.release_buffered_frames = mt76_release_buffered_frames,
 	.get_txpower = mt7996_get_txpower,
 	.channel_switch_beacon = mt7996_channel_switch_beacon,
+	.post_channel_switch = mt7996_post_channel_switch,
 	.get_stats = mt7996_get_stats,
 	.get_et_sset_count = mt7996_get_et_sset_count,
 	.get_et_stats = mt7996_get_et_stats,
@@ -1688,16 +2935,31 @@ const struct ieee80211_ops mt7996_ops = {
 	.set_bitrate_mask = mt7996_set_bitrate_mask,
 	.set_coverage_class = mt7996_set_coverage_class,
 	.sta_statistics = mt7996_sta_statistics,
+	.sta_link_statistics = mt7996_sta_link_statistics,
 	.sta_set_4addr = mt7996_sta_set_4addr,
 	.sta_set_decap_offload = mt7996_sta_set_decap_offload,
 	.add_twt_setup = mt7996_mac_add_twt_setup,
 	.twt_teardown_request = mt7996_twt_teardown_request,
+	CFG80211_TESTMODE_CMD(mt76_testmode_cmd)
+	CFG80211_TESTMODE_DUMP(mt76_testmode_dump)
 #ifdef CONFIG_MAC80211_DEBUGFS
 	.sta_add_debugfs = mt7996_sta_add_debugfs,
+	.link_sta_add_debugfs = mt7996_link_sta_add_debugfs,
+	// .link_add_debugfs = mt7996_link_add_debugfs,
+	.vif_add_debugfs = mt7996_vif_add_debugfs,
 #endif
 	.set_radar_background = mt7996_set_radar_background,
 #ifdef CONFIG_NET_MEDIATEK_SOC_WED
 	.net_fill_forward_path = mt7996_net_fill_forward_path,
 	.net_setup_tc = mt76_wed_net_setup_tc,
 #endif
+	.event_callback = mt7996_event_callback,
+	.add_chanctx = mt7996_add_chanctx,
+	.remove_chanctx = mt7996_remove_chanctx,
+	.change_chanctx = mt7996_change_chanctx,
+	.assign_vif_chanctx = mt7996_assign_vif_chanctx,
+	.unassign_vif_chanctx = mt7996_unassign_vif_chanctx,
+	.switch_vif_chanctx = mt7996_switch_vif_chanctx,
+	.change_vif_links = mt7996_change_vif_links,
+	.change_sta_links = mt7996_change_sta_links,
 };
diff --git a/mt7996/mcu.c b/mt7996/mcu.c
index fe731f85..3dac45cb 100644
--- a/mt7996/mcu.c
+++ b/mt7996/mcu.c
@@ -9,6 +9,7 @@
 #include "mcu.h"
 #include "mac.h"
 #include "eeprom.h"
+#include "mt7996_trace.h"
 
 #define fw_name(_dev, name, ...)	({			\
 	char *_fw;						\
@@ -18,6 +19,9 @@
 		case MT7992_VAR_TYPE_23:			\
 			_fw = MT7992_##name##_23;		\
 			break;					\
+		case MT7992_VAR_TYPE_24:			\
+			_fw = MT7992_##name##_24;		\
+			break;					\
 		default:					\
 			_fw = MT7992_##name;			\
 		}						\
@@ -118,13 +122,13 @@ mt7996_mcu_get_sta_nss(u16 mcs_map)
 }
 
 static void
-mt7996_mcu_set_sta_he_mcs(struct ieee80211_sta *sta, __le16 *he_mcs,
-			  u16 mcs_map)
+mt7996_mcu_set_sta_he_mcs(struct ieee80211_link_sta *link_sta,
+			  struct mt7996_bss_conf *mconf,
+			  __le16 *he_mcs, u16 mcs_map)
 {
-	struct mt7996_sta *msta = (struct mt7996_sta *)sta->drv_priv;
-	enum nl80211_band band = msta->vif->deflink.phy->mt76->chandef.chan->band;
-	const u16 *mask = msta->vif->deflink.bitrate_mask.control[band].he_mcs;
-	int nss, max_nss = sta->deflink.rx_nss > 3 ? 4 : sta->deflink.rx_nss;
+	enum nl80211_band band = mconf->phy->mt76->chandef.chan->band;
+	const u16 *mask = mconf->bitrate_mask.control[band].he_mcs;
+	int nss, max_nss = link_sta->rx_nss > 3 ? 4 : link_sta->rx_nss;
 
 	for (nss = 0; nss < max_nss; nss++) {
 		int mcs;
@@ -167,11 +171,11 @@ mt7996_mcu_set_sta_he_mcs(struct ieee80211_sta *sta, __le16 *he_mcs,
 }
 
 static void
-mt7996_mcu_set_sta_vht_mcs(struct ieee80211_sta *sta, __le16 *vht_mcs,
-			   const u16 *mask)
+mt7996_mcu_set_sta_vht_mcs(struct ieee80211_link_sta *link_sta,
+			   __le16 *vht_mcs, const u16 *mask)
 {
-	u16 mcs, mcs_map = le16_to_cpu(sta->deflink.vht_cap.vht_mcs.rx_mcs_map);
-	int nss, max_nss = sta->deflink.rx_nss > 3 ? 4 : sta->deflink.rx_nss;
+	u16 mcs, mcs_map = le16_to_cpu(link_sta->vht_cap.vht_mcs.rx_mcs_map);
+	int nss, max_nss = link_sta->rx_nss > 3 ? 4 : link_sta->rx_nss;
 
 	for (nss = 0; nss < max_nss; nss++, mcs_map >>= 2) {
 		switch (mcs_map & 0x3) {
@@ -193,13 +197,13 @@ mt7996_mcu_set_sta_vht_mcs(struct ieee80211_sta *sta, __le16 *vht_mcs,
 }
 
 static void
-mt7996_mcu_set_sta_ht_mcs(struct ieee80211_sta *sta, u8 *ht_mcs,
+mt7996_mcu_set_sta_ht_mcs(struct ieee80211_link_sta *link_sta, u8 *ht_mcs,
 			  const u8 *mask)
 {
-	int nss, max_nss = sta->deflink.rx_nss > 3 ? 4 : sta->deflink.rx_nss;
+	int nss, max_nss = link_sta->rx_nss > 3 ? 4 : link_sta->rx_nss;
 
 	for (nss = 0; nss < max_nss; nss++)
-		ht_mcs[nss] = sta->deflink.ht_cap.mcs.rx_mask[nss] & mask[nss];
+		ht_mcs[nss] = link_sta->ht_cap.mcs.rx_mask[nss] & mask[nss];
 }
 
 static int
@@ -252,6 +256,14 @@ mt7996_mcu_send_message(struct mt76_dev *mdev, struct sk_buff *skb,
 	u32 val;
 	u8 seq;
 
+	if (dev->recovery.l1_reset_last != dev->recovery.l1_reset) {
+		dev_info(dev->mt76.dev,"\n%s L1 SER recovery overlap, drop message %08x.",
+			 wiphy_name(dev->mt76.hw->wiphy), cmd);
+
+		dev_kfree_skb(skb);
+		return -EPERM;
+	}
+
 	mdev->mcu.timeout = 20 * HZ;
 
 	seq = ++dev->mt76.mcu.msg_seq & 0xf;
@@ -298,6 +310,9 @@ mt7996_mcu_send_message(struct mt76_dev *mdev, struct sk_buff *skb,
 		else if (cmd & __MCU_CMD_FIELD_WM)
 			uni_txd->s2d_index = MCU_S2D_H2N;
 
+		trace_mt7996_mcu_cmd(dev, 1, uni_txd->cid, 0,
+				    skb->data, skb->len);
+
 		goto exit;
 	}
 
@@ -325,7 +340,13 @@ mt7996_mcu_send_message(struct mt76_dev *mdev, struct sk_buff *skb,
 	else
 		mcu_txd->s2d_index = MCU_S2D_H2N;
 
+	trace_mt7996_mcu_cmd(dev, 0, mcu_txd->cid, mcu_txd->ext_cid,
+			    skb->data, skb->len);
 exit:
+#ifdef CONFIG_MTK_DEBUG
+	if (dev->dbg.dump_mcu_pkt)
+		mt7996_packet_log_to_host(dev, skb->data, skb->len, PKT_BIN_DEBUG_MCU, 0);
+#endif
 	if (wait_seq)
 		*wait_seq = seq;
 
@@ -350,10 +371,21 @@ int mt7996_mcu_wa_cmd(struct mt7996_dev *dev, int cmd, u32 a1, u32 a2, u32 a3)
 static void
 mt7996_mcu_csa_finish(void *priv, u8 *mac, struct ieee80211_vif *vif)
 {
-	if (!vif->bss_conf.csa_active || vif->type == NL80211_IFTYPE_STATION)
+	struct mt76_phy *mphy = (struct mt76_phy *)priv;
+	struct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;
+	struct ieee80211_bss_conf *link_conf;
+	int link_id, band_idx = mphy->band_idx;
+
+	link_id = mvif->band_to_link[band_idx];
+	if (link_id == IEEE80211_LINK_UNSPECIFIED)
+		return;
+
+	link_conf = rcu_dereference(vif->link_conf[link_id]);
+
+	if (!link_conf || !link_conf->csa_active || vif->type == NL80211_IFTYPE_STATION)
 		return;
 
-	ieee80211_csa_finish(vif, 0);
+	ieee80211_csa_finish(vif, link_id);
 }
 
 static void
@@ -378,11 +410,12 @@ mt7996_mcu_rx_radar_detected(struct mt7996_dev *dev, struct sk_buff *skb)
 	if (!mphy)
 		return;
 
-	if (r->band_idx == MT_RX_SEL2)
+	if (r->band_idx == MT_RX_SEL2) {
+		dev->bg_nxt_freq = 0;
 		cfg80211_background_radar_event(mphy->hw->wiphy,
 						&dev->rdd2_chandef,
 						GFP_ATOMIC);
-	else
+	} else
 		ieee80211_radar_detected(mphy->hw, NULL);
 	dev->hw_pattern++;
 }
@@ -391,6 +424,7 @@ static void
 mt7996_mcu_rx_log_message(struct mt7996_dev *dev, struct sk_buff *skb)
 {
 #define UNI_EVENT_FW_LOG_FORMAT 0
+#define UNI_EVENT_FW_LOG_MEMORY	1
 	struct mt7996_mcu_rxd *rxd = (struct mt7996_mcu_rxd *)skb->data;
 	const char *data = (char *)&rxd[1] + 4, *type;
 	struct tlv *tlv = (struct tlv *)data;
@@ -402,7 +436,8 @@ mt7996_mcu_rx_log_message(struct mt7996_dev *dev, struct sk_buff *skb)
 		goto out;
 	}
 
-	if (le16_to_cpu(tlv->tag) != UNI_EVENT_FW_LOG_FORMAT)
+	if (le16_to_cpu(tlv->tag) != UNI_EVENT_FW_LOG_FORMAT &&
+	    le16_to_cpu(tlv->tag) != UNI_EVENT_FW_LOG_MEMORY)
 		return;
 
 	data += sizeof(*tlv) + 4;
@@ -430,10 +465,21 @@ out:
 static void
 mt7996_mcu_cca_finish(void *priv, u8 *mac, struct ieee80211_vif *vif)
 {
-	if (!vif->bss_conf.color_change_active || vif->type == NL80211_IFTYPE_STATION)
+	struct mt76_phy *mphy = (struct mt76_phy *)priv;
+	struct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;
+	struct ieee80211_bss_conf *link_conf;
+	u8 link_id;
+
+	link_id = mvif->band_to_link[mphy->band_idx];
+	if (link_id == IEEE80211_LINK_UNSPECIFIED)
 		return;
 
-	ieee80211_color_change_finish(vif, 0);
+	link_conf = rcu_dereference(vif->link_conf[link_id]);
+	if (!link_conf || !link_conf->color_change_active ||
+	    vif->type == NL80211_IFTYPE_STATION)
+		return;
+
+	ieee80211_color_change_finish(vif, link_id);
 }
 
 static void
@@ -464,12 +510,12 @@ mt7996_mcu_ie_countdown(struct mt7996_dev *dev, struct sk_buff *skb)
 		case UNI_EVENT_IE_COUNTDOWN_CSA:
 			ieee80211_iterate_active_interfaces_atomic(mphy->hw,
 					IEEE80211_IFACE_ITER_RESUME_ALL,
-					mt7996_mcu_csa_finish, mphy->hw);
+					mt7996_mcu_csa_finish, mphy);
 			break;
 		case UNI_EVENT_IE_COUNTDOWN_BCC:
 			ieee80211_iterate_active_interfaces_atomic(mphy->hw,
 					IEEE80211_IFACE_ITER_RESUME_ALL,
-					mt7996_mcu_cca_finish, mphy->hw);
+					mt7996_mcu_cca_finish, mphy);
 			break;
 		}
 
@@ -515,6 +561,30 @@ mt7996_mcu_update_tx_gi(struct rate_info *rate, struct all_sta_trx_rate *mcu_rat
 	return 0;
 }
 
+static inline void __mt7996_stat_to_netdev(struct mt76_phy *mphy,
+					   struct mt76_wcid *wcid,
+					   u32 tx_bytes, u32 rx_bytes,
+					   u32 tx_packets, u32 rx_packets)
+{
+	struct mt7996_link_sta *mlink;
+	struct ieee80211_vif *vif;
+	struct wireless_dev *wdev;
+
+	if (wiphy_ext_feature_isset(mphy->hw->wiphy,
+				    NL80211_EXT_FEATURE_STAS_COUNT)) {
+		mlink = container_of(wcid, struct mt7996_link_sta, wcid);
+		vif = container_of((void *)mlink->sta->vif, struct ieee80211_vif,
+				   drv_priv);
+		wdev = ieee80211_vif_to_wdev(vif);
+
+		if (vif->type == NL80211_IFTYPE_MONITOR)
+			return;
+
+		dev_sw_netstats_tx_add(wdev->netdev, tx_packets, tx_bytes);
+		__dev_sw_netstats_rx_add(wdev->netdev, rx_packets, rx_bytes);
+	}
+}
+
 static void
 mt7996_mcu_rx_all_sta_info_event(struct mt7996_dev *dev, struct sk_buff *skb)
 {
@@ -529,6 +599,9 @@ mt7996_mcu_rx_all_sta_info_event(struct mt7996_dev *dev, struct sk_buff *skb)
 		u8 ac;
 		u16 wlan_idx;
 		struct mt76_wcid *wcid;
+		struct mt76_phy *mphy;
+		struct ieee80211_sta *sta;
+		u32 tx_bytes, rx_bytes, tx_airtime, rx_airtime, tx_packets, rx_packets;
 
 		switch (le16_to_cpu(res->tag)) {
 		case UNI_ALL_STA_TXRX_RATE:
@@ -548,11 +621,19 @@ mt7996_mcu_rx_all_sta_info_event(struct mt7996_dev *dev, struct sk_buff *skb)
 			if (!wcid)
 				break;
 
-			for (ac = 0; ac < IEEE80211_NUM_ACS; ac++) {
-				wcid->stats.tx_bytes +=
-					le32_to_cpu(res->adm_stat[i].tx_bytes[ac]);
-				wcid->stats.rx_bytes +=
-					le32_to_cpu(res->adm_stat[i].rx_bytes[ac]);
+			mphy = mt76_dev_phy(&dev->mt76, wcid->phy_idx);
+			for (ac = IEEE80211_AC_VO; ac < IEEE80211_NUM_ACS; ac++) {
+				tx_bytes = le32_to_cpu(res->adm_stat[i].tx_bytes[ac]);
+				rx_bytes = le32_to_cpu(res->adm_stat[i].rx_bytes[ac]);
+
+				wcid->stats.tx_bytes += tx_bytes;
+				wcid->stats.rx_bytes += rx_bytes;
+
+				__mt7996_stat_to_netdev(mphy, wcid,
+							tx_bytes, rx_bytes, 0, 0);
+
+				ieee80211_tpt_led_trig_tx(mphy->hw, tx_bytes);
+				ieee80211_tpt_led_trig_rx(mphy->hw, rx_bytes);
 			}
 			break;
 		case UNI_ALL_STA_TXRX_MSDU_COUNT:
@@ -562,14 +643,297 @@ mt7996_mcu_rx_all_sta_info_event(struct mt7996_dev *dev, struct sk_buff *skb)
 			if (!wcid)
 				break;
 
-			wcid->stats.tx_packets +=
-				le32_to_cpu(res->msdu_cnt[i].tx_msdu_cnt);
-			wcid->stats.rx_packets +=
-				le32_to_cpu(res->msdu_cnt[i].rx_msdu_cnt);
+			mphy = mt76_dev_phy(&dev->mt76, wcid->phy_idx);
+
+			tx_packets = le32_to_cpu(res->msdu_cnt[i].tx_msdu_cnt);
+			rx_packets = le32_to_cpu(res->msdu_cnt[i].rx_msdu_cnt);
+
+			wcid->stats.tx_packets += tx_packets;
+			wcid->stats.rx_packets += rx_packets;
+
+			if (mtk_wed_device_active(&dev->mt76.mmio.wed)) {
+				__mt7996_stat_to_netdev(mphy, wcid, 0, 0,
+							tx_packets, rx_packets);
+			}
+			break;
+		case UNI_ALL_STA_TXRX_AIRTIME:
+			wlan_idx = le16_to_cpu(res->airtime[i].wlan_idx);
+			wcid = rcu_dereference(dev->mt76.wcid[wlan_idx]);
+			sta = wcid_to_sta(wcid);
+			if (!sta)
+				continue;
+
+			for (ac = IEEE80211_AC_VO; ac < IEEE80211_NUM_ACS; ++ac) {
+				u8 lmac_ac = mt76_connac_lmac_mapping(ac);
+				tx_airtime = le32_to_cpu(res->airtime[i].tx[lmac_ac]);
+				rx_airtime = le32_to_cpu(res->airtime[i].rx[lmac_ac]);
+
+				wcid->stats.tx_airtime += tx_airtime;
+				wcid->stats.rx_airtime += rx_airtime;
+				ieee80211_sta_register_airtime(sta, mt76_ac_to_tid(ac),
+				                               tx_airtime, rx_airtime);
+			}
+			break;
+		default:
+			break;
+		}
+	}
+}
+
+static int
+csi_integrate_segment_data(struct mt7996_phy *phy, struct csi_data *csi)
+{
+	struct csi_data *csi_temp = NULL;
+
+	if (csi->segment_num == 0 && csi->remain_last == 0)
+		return CSI_CHAIN_COMPLETE;
+	else if (csi->segment_num == 0 && csi->remain_last == 1) {
+		memcpy(&phy->csi.buffered_csi,
+		       csi, sizeof(struct csi_data));
+
+		return CSI_CHAIN_SEGMENT_FIRST;
+	} else if (csi->segment_num != 0) {
+		csi_temp = &phy->csi.buffered_csi;
+		if (csi->chain_info != csi_temp->chain_info ||
+		csi->segment_num != (csi_temp->segment_num + 1))
+			return CSI_CHAIN_SEGMENT_ERR;
+
+		memcpy(&csi_temp->data_i[csi_temp->data_num],
+		       csi->data_i, csi->data_num * sizeof(s16));
+
+		memcpy(&csi_temp->data_q[csi_temp->data_num],
+		       csi->data_q, csi->data_num * sizeof(s16));
+
+		csi_temp->data_num += csi->data_num;
+		csi_temp->segment_num = csi->segment_num;
+		csi_temp->remain_last = csi->remain_last;
+
+		if (csi->remain_last == 0)
+			return CSI_CHAIN_SEGMENT_LAST;
+		else if (csi->remain_last == 1)
+			return CSI_CHAIN_SEGMENT_MIDDLE;
+	}
+
+	return CSI_CHAIN_ERR;
+}
+
+static int
+mt7996_mcu_csi_report_data(struct mt7996_phy *phy, u8 *tlv_buf, u32 len)
+{
+	int ret, i;
+	struct csi_data *current_csi;
+	struct csi_data *target_csi;
+	struct csi_tlv *tlv_data;
+	u8 *buf_tmp;
+	u32 rx_info, tx_rx_idx;
+	u32 buf_len_last, offset;
+
+	buf_tmp = tlv_buf;
+	buf_len_last = len;
+	offset = sizeof(((struct csi_tlv *)0)->basic);
+
+	current_csi = kzalloc(sizeof(*current_csi), GFP_KERNEL);
+	if (!current_csi)
+		return -ENOMEM;
+
+	while (buf_len_last >= offset) {
+		u32 tag, len;
+		s16 *data_tmp = NULL;
+
+		tlv_data = (struct csi_tlv *)buf_tmp;
+		tag = le32_to_cpu(tlv_data->basic.tag);
+		len = le32_to_cpu(tlv_data->basic.len);
+
+		switch (tag) {
+		case CSI_EVENT_FW_VER:
+			current_csi->fw_ver = le32_to_cpu(tlv_data->info);
+			break;
+		case CSI_EVENT_CBW:
+			current_csi->ch_bw = le32_to_cpu(tlv_data->info);
+			break;
+		case CSI_EVENT_RSSI:
+			current_csi->rssi = le32_to_cpu(tlv_data->info);
+			break;
+		case CSI_EVENT_SNR:
+			current_csi->snr = le32_to_cpu(tlv_data->info);
+			break;
+		case CSI_EVENT_BAND:
+			current_csi->band = le32_to_cpu(tlv_data->info);
+
+			if (current_csi->band != phy->mt76->band_idx) {
+				kfree(current_csi);
+				return -EINVAL;
+			}
+
+			break;
+		case CSI_EVENT_CSI_NUM:
+			current_csi->data_num = le32_to_cpu(tlv_data->info);
+
+			if (current_csi->data_num > CSI_BW80_DATA_COUNT) {
+				kfree(current_csi);
+				return -EINVAL;
+			}
+
+			break;
+		case CSI_EVENT_CSI_I_DATA:
+			if (len != sizeof(s16) * current_csi->data_num) {
+				kfree(current_csi);
+				return -EINVAL;
+			}
+
+			data_tmp = tlv_data->data;
+			for (i = 0; i < current_csi->data_num; i++)
+				current_csi->data_i[i] = le16_to_cpu(*(data_tmp + i));
+			break;
+		case CSI_EVENT_CSI_Q_DATA:
+			if (len != sizeof(s16) * current_csi->data_num) {
+				kfree(current_csi);
+				return -EINVAL;
+			}
+
+			data_tmp = tlv_data->data;
+			for (i = 0; i < current_csi->data_num; i++)
+				current_csi->data_q[i] = le16_to_cpu(*(data_tmp + i));
+			break;
+		case CSI_EVENT_DBW:
+			current_csi->data_bw = le32_to_cpu(tlv_data->info);
+			break;
+		case CSI_EVENT_CH_IDX:
+			current_csi->pri_ch_idx = le32_to_cpu(tlv_data->info);
+			break;
+		case CSI_EVENT_TA:
+			memcpy(current_csi->ta, tlv_data->mac, ETH_ALEN);
+			break;
+		case CSI_EVENT_EXTRA_INFO:
+			current_csi->ext_info = le32_to_cpu(tlv_data->info);
+			break;
+		case CSI_EVENT_RX_MODE:
+			rx_info = le32_to_cpu(tlv_data->info);
+			current_csi->rx_mode = u32_get_bits(rx_info, GENMASK(15, 0));
+			current_csi->rx_rate = u32_get_bits(rx_info, GENMASK(31, 16));
+			break;
+		case CSI_EVENT_H_IDX:
+			current_csi->chain_info = le32_to_cpu(tlv_data->info);
+			break;
+		case CSI_EVENT_TX_RX_IDX:
+			tx_rx_idx = le32_to_cpu(tlv_data->info);
+			current_csi->tx_idx = u32_get_bits(tx_rx_idx, GENMASK(31, 16));
+			current_csi->rx_idx = u32_get_bits(tx_rx_idx, GENMASK(15, 0));
+			break;
+		case CSI_EVENT_TS:
+			current_csi->ts = le32_to_cpu(tlv_data->info);
+
+			if (phy->csi.interval &&
+				current_csi->ts < phy->csi.last_record + phy->csi.interval) {
+				kfree(current_csi);
+				return 0;
+			}
+
+			break;
+		case CSI_EVENT_PKT_SN:
+			current_csi->pkt_sn = le32_to_cpu(tlv_data->info);
+			break;
+		case CSI_EVENT_BW_SEG:
+			current_csi->segment_num = le32_to_cpu(tlv_data->info);
+			break;
+		case CSI_EVENT_REMAIN_LAST:
+			current_csi->remain_last = le32_to_cpu(tlv_data->info);
+			break;
+		case CSI_EVENT_TR_STREAM:
+			current_csi->tr_stream = le32_to_cpu(tlv_data->info);
+			break;
+		default:
+			break;
+		};
+
+		buf_len_last -= (offset + len);
+
+		if (buf_len_last >= offset)
+			buf_tmp += (offset + len);
+	}
+
+	/* integret the bw80 segment */
+	if (current_csi->ch_bw >= CSI_BW80) {
+		ret = csi_integrate_segment_data(phy, current_csi);
+
+		switch (ret) {
+		case CSI_CHAIN_ERR:
+		case CSI_CHAIN_SEGMENT_ERR:
+			kfree(current_csi);
+			return -EINVAL;
+			break;
+		case CSI_CHAIN_SEGMENT_FIRST:
+		case CSI_CHAIN_SEGMENT_MIDDLE:
+			kfree(current_csi);
+			return 0;
+			break;
+		case CSI_CHAIN_COMPLETE:
+			target_csi = current_csi;
+			break;
+		case CSI_CHAIN_SEGMENT_LAST:
+			target_csi = current_csi;
+			memcpy(target_csi, &phy->csi.buffered_csi, sizeof(struct csi_data));
+			memset(&phy->csi.buffered_csi, 0, sizeof(struct csi_data));
 			break;
 		default:
 			break;
 		}
+	} else {
+		target_csi = current_csi;
+	}
+
+	/* put the csi data into list */
+	INIT_LIST_HEAD(&target_csi->node);
+	spin_lock_bh(&phy->csi.lock);
+
+	if (!phy->csi.enable) {
+		kfree(target_csi);
+		goto out;
+	}
+
+	list_add_tail(&target_csi->node, &phy->csi.list);
+	phy->csi.count++;
+
+	if (phy->csi.count > CSI_MAX_BUF_NUM) {
+		struct csi_data *old;
+
+		old = list_first_entry(&phy->csi.list,
+				       struct csi_data, node);
+
+		list_del(&old->node);
+		kfree(old);
+		phy->csi.count--;
+	}
+
+	if (target_csi->chain_info & BIT(15)) /* last chain */
+		phy->csi.last_record = target_csi->ts;
+
+out:
+	spin_unlock_bh(&phy->csi.lock);
+	return 0;
+}
+
+void
+mt7996_mcu_csi_report_event(struct mt7996_dev *dev, struct sk_buff *skb)
+{
+	struct mt7996_mcu_csi_event *event;
+	struct mt76_phy *mphy;
+	struct mt7996_phy *phy;
+
+	event = (struct mt7996_mcu_csi_event *)skb->data;
+
+	mphy = dev->mt76.phys[event->band_idx];
+	if (!mphy)
+		return;
+
+	phy = mphy->priv;
+
+	switch (le16_to_cpu(event->tag)) {
+	case UNI_EVENT_CSI_DATA:
+		mt7996_mcu_csi_report_data(phy, event->tlv_buf, le16_to_cpu(event->len) - 4);
+		break;
+	default:
+		break;
 	}
 }
 
@@ -600,6 +964,82 @@ mt7996_mcu_rx_thermal_notify(struct mt7996_dev *dev, struct sk_buff *skb)
 	phy->throttle_state = n->duty_percent;
 }
 
+void mt7996_mcu_wmm_pbc_work(struct work_struct *work)
+{
+#define WMM_PBC_QUEUE_NUM	5
+#define WMM_PBC_BSS_ALL		0xff
+#define WMM_PBC_WLAN_IDX_ALL	0xffff
+#define WMM_PBC_BOUND_DEFAULT	0xffff
+#define WMM_PBC_LOW_BOUND_VO	1900
+#define WMM_PBC_LOW_BOUND_VI	1900
+#define WMM_PBC_LOW_BOUND_BE	1500
+#define WMM_PBC_LOW_BOUND_BK	900
+#define WMM_PBC_LOW_BOUND_MGMT	32
+	struct mt7996_dev *dev = container_of(work, struct mt7996_dev, wmm_pbc_work);
+	struct {
+		u8 bss_idx;
+		u8 queue_num;
+		__le16 wlan_idx;
+		u8 band_idx;
+		u8 __rsv[3];
+		struct {
+			__le16 low;
+			__le16 up;
+		} __packed bound[WMM_PBC_QUEUE_NUM];
+	} __packed req = {
+		.bss_idx = WMM_PBC_BSS_ALL,
+		.queue_num = WMM_PBC_QUEUE_NUM,
+		.wlan_idx = cpu_to_le16(WMM_PBC_WLAN_IDX_ALL),
+		.band_idx = dev->mphy.band_idx,
+	};
+	int i, ret;
+
+#define pbc_acq_low_bound_config(_ac, _bound)								\
+	req.bound[mt76_connac_lmac_mapping(_ac)].low = dev->wmm_pbc_enable ? cpu_to_le16(_bound) : 0
+	pbc_acq_low_bound_config(IEEE80211_AC_VO, WMM_PBC_LOW_BOUND_VO);
+	pbc_acq_low_bound_config(IEEE80211_AC_VI, WMM_PBC_LOW_BOUND_VI);
+	pbc_acq_low_bound_config(IEEE80211_AC_BE, WMM_PBC_LOW_BOUND_BE);
+	pbc_acq_low_bound_config(IEEE80211_AC_BK, WMM_PBC_LOW_BOUND_BK);
+	req.bound[4].low = dev->wmm_pbc_enable
+	                   ? cpu_to_le16(WMM_PBC_LOW_BOUND_MGMT) : 0;
+
+	for (i = 0; i < WMM_PBC_QUEUE_NUM; ++i)
+		req.bound[i].up = cpu_to_le16(WMM_PBC_BOUND_DEFAULT);
+
+	ret = mt76_mcu_send_msg(&dev->mt76, MCU_WA_EXT_CMD(PKT_BUDGET_CTRL),
+	                        &req, sizeof(req), true);
+	if (ret)
+		dev_err(dev->mt76.dev, "Failed to configure WMM PBC.\n");
+}
+
+static void
+mt7996_mcu_rx_bss_acq_pkt_cnt(struct mt7996_dev *dev, struct sk_buff *skb)
+{
+	struct mt7996_mcu_bss_acq_pkt_cnt_event *event = (struct mt7996_mcu_bss_acq_pkt_cnt_event *)skb->data;
+	u32 bitmap = le32_to_cpu(event->bss_bitmap);
+	u64 sum[IEEE80211_NUM_ACS] = {0};
+	u8 ac_cnt = 0;
+	int i, j;
+
+	for (i = 0; (i < BSS_ACQ_PKT_CNT_BSS_NUM) && (bitmap & (1 << i)); ++i) {
+		for (j = IEEE80211_AC_VO; j < IEEE80211_NUM_ACS; ++j)
+			sum[j] += le32_to_cpu(event->bss[i].cnt[mt76_connac_lmac_mapping(j)]);
+	}
+
+	for (i = IEEE80211_AC_VO; i < IEEE80211_NUM_ACS; ++i) {
+		if (sum[i] > WMM_PKT_THRESHOLD)
+			++ac_cnt;
+	}
+
+	if (ac_cnt > 1 && !dev->wmm_pbc_enable) {
+		dev->wmm_pbc_enable = true;
+		queue_work(dev->mt76.wq, &dev->wmm_pbc_work);
+	} else if (ac_cnt <= 1 && dev->wmm_pbc_enable) {
+		dev->wmm_pbc_enable = false;
+		queue_work(dev->mt76.wq, &dev->wmm_pbc_work);
+	}
+}
+
 static void
 mt7996_mcu_rx_ext_event(struct mt7996_dev *dev, struct sk_buff *skb)
 {
@@ -609,6 +1049,8 @@ mt7996_mcu_rx_ext_event(struct mt7996_dev *dev, struct sk_buff *skb)
 	case MCU_EXT_EVENT_FW_LOG_2_HOST:
 		mt7996_mcu_rx_log_message(dev, skb);
 		break;
+	case MCU_EXT_EVENT_BSS_ACQ_PKT_CNT:
+		mt7996_mcu_rx_bss_acq_pkt_cnt(dev, skb);
 	default:
 		break;
 	}
@@ -701,6 +1143,10 @@ mt7996_mcu_uni_rx_unsolicited_event(struct mt7996_dev *dev, struct sk_buff *skb)
 {
 	struct mt7996_mcu_rxd *rxd = (struct mt7996_mcu_rxd *)skb->data;
 
+#ifdef CONFIG_MTK_DEBUG
+	if (dev->dbg.dump_mcu_event)
+		mt7996_packet_log_to_host(dev, skb->data, skb->len, PKT_BIN_DEBUG_MCU_EVENT, 0);
+#endif
 	switch (rxd->eid) {
 	case MCU_UNI_EVENT_FW_LOG_2_HOST:
 		mt7996_mcu_rx_log_message(dev, skb);
@@ -717,6 +1163,29 @@ mt7996_mcu_uni_rx_unsolicited_event(struct mt7996_dev *dev, struct sk_buff *skb)
 	case MCU_UNI_EVENT_WED_RRO:
 		mt7996_mcu_wed_rro_event(dev, skb);
 		break;
+#ifdef CONFIG_MTK_DEBUG
+	case MCU_UNI_EVENT_SR:
+		mt7996_mcu_rx_sr_event(dev, skb);
+		break;
+#endif
+	case MCU_UNI_EVENT_THERMAL:
+		mt7996_mcu_rx_thermal_notify(dev, skb);
+		break;
+#ifdef CONFIG_NL80211_TESTMODE
+	case MCU_UNI_EVENT_TESTMODE_CTRL:
+		mt7996_tm_rf_test_event(dev, skb);
+		break;
+#endif
+#if defined CONFIG_NL80211_TESTMODE || defined CONFIG_MTK_DEBUG
+	case MCU_UNI_EVENT_BF:
+		mt7996_mcu_rx_bf_event(dev, skb);
+		break;
+#endif
+#ifdef CONFIG_MTK_VENDOR
+	case MCU_UNI_EVENT_CSI_REPORT:
+		mt7996_mcu_csi_report_event(dev, skb);
+		break;
+#endif
 	default:
 		break;
 	}
@@ -727,6 +1196,8 @@ void mt7996_mcu_rx_event(struct mt7996_dev *dev, struct sk_buff *skb)
 {
 	struct mt7996_mcu_rxd *rxd = (struct mt7996_mcu_rxd *)skb->data;
 
+	trace_mt7996_mcu_event(dev, rxd->option & MCU_UNI_CMD_UNSOLICITED_EVENT,
+			      rxd->eid, rxd->ext_eid, skb->data, skb->len);
 	if (rxd->option & MCU_UNI_CMD_UNSOLICITED_EVENT) {
 		mt7996_mcu_uni_rx_unsolicited_event(dev, skb);
 		return;
@@ -782,7 +1253,7 @@ mt7996_mcu_bss_rfch_tlv(struct sk_buff *skb, struct mt7996_phy *phy)
 }
 
 static void
-mt7996_mcu_bss_ra_tlv(struct sk_buff *skb, struct mt7996_phy *phy)
+mt7996_mcu_bss_ra_tlv(struct sk_buff *skb)
 {
 	struct bss_ra_tlv *ra;
 	struct tlv *tlv;
@@ -794,8 +1265,7 @@ mt7996_mcu_bss_ra_tlv(struct sk_buff *skb, struct mt7996_phy *phy)
 }
 
 static void
-mt7996_mcu_bss_he_tlv(struct sk_buff *skb, struct ieee80211_vif *vif,
-		      struct ieee80211_bss_conf *link_conf,
+mt7996_mcu_bss_he_tlv(struct sk_buff *skb, struct ieee80211_bss_conf *conf,
 		      struct mt7996_phy *phy)
 {
 #define DEFAULT_HE_PE_DURATION		4
@@ -804,16 +1274,16 @@ mt7996_mcu_bss_he_tlv(struct sk_buff *skb, struct ieee80211_vif *vif,
 	struct bss_info_uni_he *he;
 	struct tlv *tlv;
 
-	cap = mt76_connac_get_he_phy_cap(phy->mt76, vif);
+	cap = mt76_connac_get_he_phy_cap(phy->mt76, conf->vif);
 
 	tlv = mt7996_mcu_add_uni_tlv(skb, UNI_BSS_INFO_HE_BASIC, sizeof(*he));
 
 	he = (struct bss_info_uni_he *)tlv;
-	he->he_pe_duration = link_conf->htc_trig_based_pkt_ext;
+	he->he_pe_duration = conf->htc_trig_based_pkt_ext;
 	if (!he->he_pe_duration)
 		he->he_pe_duration = DEFAULT_HE_PE_DURATION;
 
-	he->he_rts_thres = cpu_to_le16(link_conf->frame_time_rts_th);
+	he->he_rts_thres = cpu_to_le16(conf->frame_time_rts_th);
 	if (!he->he_rts_thres)
 		he->he_rts_thres = cpu_to_le16(DEFAULT_HE_DURATION_RTS_THRES);
 
@@ -823,13 +1293,13 @@ mt7996_mcu_bss_he_tlv(struct sk_buff *skb, struct ieee80211_vif *vif,
 }
 
 static void
-mt7996_mcu_bss_mbssid_tlv(struct sk_buff *skb, struct ieee80211_bss_conf *link_conf,
-			  bool enable)
+mt7996_mcu_bss_mbssid_tlv(struct sk_buff *skb, struct ieee80211_bss_conf *conf,
+			  struct mt7996_phy *phy, int enable)
 {
 	struct bss_info_uni_mbssid *mbssid;
 	struct tlv *tlv;
 
-	if (!link_conf->bssid_indicator && enable)
+	if (!conf->bssid_indicator && enable)
 		return;
 
 	tlv = mt7996_mcu_add_uni_tlv(skb, UNI_BSS_INFO_11V_MBSSID, sizeof(*mbssid));
@@ -837,22 +1307,21 @@ mt7996_mcu_bss_mbssid_tlv(struct sk_buff *skb, struct ieee80211_bss_conf *link_c
 	mbssid = (struct bss_info_uni_mbssid *)tlv;
 
 	if (enable) {
-		mbssid->max_indicator = link_conf->bssid_indicator;
-		mbssid->mbss_idx = link_conf->bssid_index;
+		mbssid->max_indicator = conf->bssid_indicator;
+		mbssid->mbss_idx = conf->bssid_index;
 		mbssid->tx_bss_omac_idx = 0;
 	}
 }
 
 static void
-mt7996_mcu_bss_bmc_tlv(struct sk_buff *skb, struct mt76_vif_link *mlink,
+mt7996_mcu_bss_bmc_tlv(struct sk_buff *skb, struct mt7996_bss_conf *mconf,
 		       struct mt7996_phy *phy)
 {
 	struct bss_rate_tlv *bmc;
 	struct cfg80211_chan_def *chandef = &phy->mt76->chandef;
 	enum nl80211_band band = chandef->chan->band;
 	struct tlv *tlv;
-	u8 idx = mlink->mcast_rates_idx ?
-		 mlink->mcast_rates_idx : mlink->basic_rates_idx;
+	u8 idx = mconf->mt76.mcast_rates_idx ?: mconf->mt76.basic_rates_idx;
 
 	tlv = mt7996_mcu_add_uni_tlv(skb, UNI_BSS_INFO_RATE, sizeof(*bmc));
 
@@ -876,21 +1345,32 @@ mt7996_mcu_bss_txcmd_tlv(struct sk_buff *skb, bool en)
 }
 
 static void
-mt7996_mcu_bss_mld_tlv(struct sk_buff *skb, struct mt76_vif_link *mlink)
+mt7996_mcu_bss_mld_tlv(struct sk_buff *skb, struct ieee80211_vif *vif,
+		       struct mt7996_bss_conf *mconf)
 {
+	struct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;
 	struct bss_mld_tlv *mld;
 	struct tlv *tlv;
 
 	tlv = mt7996_mcu_add_uni_tlv(skb, UNI_BSS_INFO_MLD, sizeof(*mld));
-
 	mld = (struct bss_mld_tlv *)tlv;
-	mld->group_mld_id = 0xff;
-	mld->own_mld_id = mlink->idx;
-	mld->remap_idx = 0xff;
+
+	if (ieee80211_vif_is_mld(vif)) {
+		mld->group_mld_id = mvif->group_mld_id;
+		mld->remap_idx = mvif->mld_remap_id;
+		memcpy(mld->mac_addr, vif->addr, ETH_ALEN);
+	} else {
+		mld->group_mld_id = 0xff;
+		mld->remap_idx = 0xff;
+	}
+
+	mld->own_mld_id = mconf->own_mld_id;
+	pr_info("%s: group_mld_id=%d own_mld_id=%d remap_idx=%d mld->addr[%pM]\n",
+		__func__, mld->group_mld_id,  mld->own_mld_id, mld->remap_idx, mld->mac_addr);
 }
 
 static void
-mt7996_mcu_bss_sec_tlv(struct sk_buff *skb, struct mt76_vif_link *mlink)
+mt7996_mcu_bss_sec_tlv(struct sk_buff *skb, struct mt7996_bss_conf *mconf)
 {
 	struct bss_sec_tlv *sec;
 	struct tlv *tlv;
@@ -898,15 +1378,17 @@ mt7996_mcu_bss_sec_tlv(struct sk_buff *skb, struct mt76_vif_link *mlink)
 	tlv = mt7996_mcu_add_uni_tlv(skb, UNI_BSS_INFO_SEC, sizeof(*sec));
 
 	sec = (struct bss_sec_tlv *)tlv;
-	sec->cipher = mlink->cipher;
+	sec->cipher = mconf->mt76.cipher;
 }
 
 static int
-mt7996_mcu_muar_config(struct mt7996_dev *dev, struct mt76_vif_link *mlink,
-		       const u8 *addr, bool bssid, bool enable)
+mt7996_mcu_muar_config(struct mt7996_phy *phy, struct ieee80211_bss_conf *conf,
+		       struct mt7996_bss_conf *mconf, bool bssid, bool enable)
 {
 #define UNI_MUAR_ENTRY 2
-	u32 idx = mlink->omac_idx - REPEATER_BSSID_START;
+	struct mt7996_dev *dev = phy->dev;
+	u32 idx = mconf->mt76.omac_idx - REPEATER_BSSID_START;
+	const u8 *addr = bssid ? conf->bssid : conf->vif->addr;
 	struct {
 		struct {
 			u8 band;
@@ -923,7 +1405,7 @@ mt7996_mcu_muar_config(struct mt7996_dev *dev, struct mt76_vif_link *mlink,
 		u8 addr[ETH_ALEN];
 		u8 __rsv[2];
 	} __packed req = {
-		.hdr.band = mlink->band_idx,
+		.hdr.band = phy->mt76->band_idx,
 		.tag = cpu_to_le16(UNI_MUAR_ENTRY),
 		.len = cpu_to_le16(sizeof(req) - sizeof(req.hdr)),
 		.smesh = false,
@@ -965,18 +1447,16 @@ mt7996_mcu_bss_ifs_timing_tlv(struct sk_buff *skb, struct mt7996_phy *phy)
 }
 
 static int
-mt7996_mcu_bss_basic_tlv(struct sk_buff *skb,
-			 struct ieee80211_vif *vif,
-			 struct ieee80211_bss_conf *link_conf,
-			 struct mt76_vif_link *mvif,
-			 struct mt76_phy *phy, u16 wlan_idx,
-			 bool enable)
+mt7996_mcu_bss_basic_tlv(struct sk_buff *skb, struct ieee80211_bss_conf *conf,
+			 struct mt7996_bss_conf *mconf, struct ieee80211_sta *sta,
+			 u16 wlan_idx, bool enable)
 {
+	struct mt76_phy *phy = mconf->phy->mt76;
+	struct ieee80211_vif *vif = conf->vif;
 	struct cfg80211_chan_def *chandef = &phy->chandef;
 	struct mt76_connac_bss_basic_tlv *bss;
 	u32 type = CONNECTION_INFRA_AP;
 	u16 sta_wlan_idx = wlan_idx;
-	struct ieee80211_sta *sta;
 	struct tlv *tlv;
 	int idx;
 
@@ -988,13 +1468,16 @@ mt7996_mcu_bss_basic_tlv(struct sk_buff *skb,
 	case NL80211_IFTYPE_STATION:
 		if (enable) {
 			rcu_read_lock();
-			sta = ieee80211_find_sta(vif, vif->bss_conf.bssid);
+			if (!sta)
+				sta = ieee80211_find_sta(vif, conf->bssid);
 			/* TODO: enable BSS_INFO_UAPSD & BSS_INFO_PM */
 			if (sta) {
-				struct mt76_wcid *wcid;
+				struct mt7996_sta *msta = (struct mt7996_sta *)sta->drv_priv;
+				struct mt7996_link_sta *mlink;
 
-				wcid = (struct mt76_wcid *)sta->drv_priv;
-				sta_wlan_idx = wcid->idx;
+				mlink = rcu_dereference(msta->link[conf->link_id]);
+				if (mlink)
+					sta_wlan_idx = mlink->wcid.idx;
 			}
 			rcu_read_unlock();
 		}
@@ -1011,38 +1494,46 @@ mt7996_mcu_bss_basic_tlv(struct sk_buff *skb,
 	tlv = mt7996_mcu_add_uni_tlv(skb, UNI_BSS_INFO_BASIC, sizeof(*bss));
 
 	bss = (struct mt76_connac_bss_basic_tlv *)tlv;
-	bss->bcn_interval = cpu_to_le16(link_conf->beacon_int);
-	bss->dtim_period = link_conf->dtim_period;
 	bss->bmc_tx_wlan_idx = cpu_to_le16(wlan_idx);
 	bss->sta_idx = cpu_to_le16(sta_wlan_idx);
 	bss->conn_type = cpu_to_le32(type);
-	bss->omac_idx = mvif->omac_idx;
-	bss->band_idx = mvif->band_idx;
-	bss->wmm_idx = mvif->wmm_idx;
+	bss->omac_idx = mconf->mt76.omac_idx;
+	bss->band_idx = mconf->mt76.band_idx;
+	bss->wmm_idx = mconf->mt76.wmm_idx;
 	bss->conn_state = !enable;
 	bss->active = enable;
 
-	idx = mvif->omac_idx > EXT_BSSID_START ? HW_BSSID_0 : mvif->omac_idx;
+	idx = mconf->mt76.omac_idx > EXT_BSSID_START ? HW_BSSID_0 :
+						       mconf->mt76.omac_idx;
 	bss->hw_bss_idx = idx;
 
 	if (vif->type == NL80211_IFTYPE_MONITOR) {
-		memcpy(bss->bssid, phy->macaddr, ETH_ALEN);
+		struct mt76_testmode_data *td = &phy->test;
+
+		if (!td->bf_en)
+			memcpy(bss->bssid, phy->macaddr, ETH_ALEN);
+		else
+			memcpy(bss->bssid, td->addr[2], ETH_ALEN);
 		return 0;
 	}
 
-	memcpy(bss->bssid, link_conf->bssid, ETH_ALEN);
-	bss->bcn_interval = cpu_to_le16(link_conf->beacon_int);
-	bss->dtim_period = vif->bss_conf.dtim_period;
+	memcpy(bss->bssid, conf->bssid, ETH_ALEN);
+
+	mlo_dbg(mconf->phy, "omac_idx=%d band_idx=%d wmm_idx=%d bss->bssid=%pM enable=%d\n",
+		bss->omac_idx, bss->band_idx, bss->wmm_idx, bss->bssid, enable);
+
+	bss->bcn_interval = cpu_to_le16(conf->beacon_int);
+	bss->dtim_period = conf->dtim_period;
 	bss->phymode = mt76_connac_get_phy_mode(phy, vif,
 						chandef->chan->band, NULL);
-	bss->phymode_ext = mt76_connac_get_phy_mode_ext(phy, &vif->bss_conf,
+	bss->phymode_ext = mt76_connac_get_phy_mode_ext(phy, conf,
 							chandef->chan->band);
 
 	return 0;
 }
 
 static struct sk_buff *
-__mt7996_mcu_alloc_bss_req(struct mt76_dev *dev, struct mt76_vif_link *mvif, int len)
+__mt7996_mcu_alloc_bss_req(struct mt76_dev *dev, struct mt76_vif *mvif, int len)
 {
 	struct bss_req_hdr hdr = {
 		.bss_idx = mvif->idx,
@@ -1058,60 +1549,59 @@ __mt7996_mcu_alloc_bss_req(struct mt76_dev *dev, struct mt76_vif_link *mvif, int
 	return skb;
 }
 
-int mt7996_mcu_add_bss_info(struct mt7996_phy *phy, struct ieee80211_vif *vif,
-			    struct ieee80211_bss_conf *link_conf,
-			    struct mt76_vif_link *mlink, int enable)
+int mt7996_mcu_add_bss_info(struct mt7996_phy *phy,
+			    struct ieee80211_bss_conf *conf,
+			    struct mt7996_bss_conf *mconf,
+			    struct mt7996_link_sta *mlink, int enable)
 {
+	struct ieee80211_vif *vif = conf->vif;
 	struct mt7996_dev *dev = phy->dev;
 	struct sk_buff *skb;
 
-	if (mlink->omac_idx >= REPEATER_BSSID_START) {
-		mt7996_mcu_muar_config(dev, mlink, link_conf->addr, false, enable);
-		mt7996_mcu_muar_config(dev, mlink, link_conf->bssid, true, enable);
+	if (mconf->mt76.omac_idx >= REPEATER_BSSID_START) {
+		mt7996_mcu_muar_config(phy, conf, mconf, false, enable);
+		mt7996_mcu_muar_config(phy, conf, mconf, true, enable);
 	}
 
-	skb = __mt7996_mcu_alloc_bss_req(&dev->mt76, mlink,
+	skb = __mt7996_mcu_alloc_bss_req(&dev->mt76, &mconf->mt76,
 					 MT7996_BSS_UPDATE_MAX_SIZE);
 	if (IS_ERR(skb))
 		return PTR_ERR(skb);
 
 	/* bss_basic must be first */
-	mt7996_mcu_bss_basic_tlv(skb, vif, link_conf, mlink, phy->mt76,
-				 mlink->wcid->idx, enable);
-	mt7996_mcu_bss_sec_tlv(skb, mlink);
+	mt7996_mcu_bss_basic_tlv(skb, conf, mconf, NULL, mlink->wcid.idx, enable);
+	mt7996_mcu_bss_sec_tlv(skb, mconf);
 
 	if (vif->type == NL80211_IFTYPE_MONITOR)
 		goto out;
 
 	if (enable) {
 		mt7996_mcu_bss_rfch_tlv(skb, phy);
-		mt7996_mcu_bss_bmc_tlv(skb, mlink, phy);
-		mt7996_mcu_bss_ra_tlv(skb, phy);
+		mt7996_mcu_bss_bmc_tlv(skb, mconf, phy);
+		mt7996_mcu_bss_ra_tlv(skb);
 		mt7996_mcu_bss_txcmd_tlv(skb, true);
 		mt7996_mcu_bss_ifs_timing_tlv(skb, phy);
 
-		if (vif->bss_conf.he_support)
-			mt7996_mcu_bss_he_tlv(skb, vif, link_conf, phy);
+		if (conf->he_support)
+			mt7996_mcu_bss_he_tlv(skb, conf, phy);
 
 		/* this tag is necessary no matter if the vif is MLD */
-		mt7996_mcu_bss_mld_tlv(skb, mlink);
+		mt7996_mcu_bss_mld_tlv(skb, vif, mconf);
 	}
 
-	mt7996_mcu_bss_mbssid_tlv(skb, link_conf, enable);
+	mt7996_mcu_bss_mbssid_tlv(skb, conf, phy, enable);
 
 out:
 	return mt76_mcu_skb_send_msg(&dev->mt76, skb,
 				     MCU_WMWA_UNI_CMD(BSS_INFO_UPDATE), true);
 }
 
-int mt7996_mcu_set_timing(struct mt7996_phy *phy, struct ieee80211_vif *vif,
-			  struct ieee80211_bss_conf *link_conf)
+int mt7996_mcu_set_timing(struct mt7996_phy *phy, struct mt7996_bss_conf *mconf)
 {
 	struct mt7996_dev *dev = phy->dev;
-	struct mt76_vif_link *mlink = mt76_vif_conf_link(&dev->mt76, vif, link_conf);
 	struct sk_buff *skb;
 
-	skb = __mt7996_mcu_alloc_bss_req(&dev->mt76, mlink,
+	skb = __mt7996_mcu_alloc_bss_req(&dev->mt76, &mconf->mt76,
 					 MT7996_BSS_UPDATE_MAX_SIZE);
 	if (IS_ERR(skb))
 		return PTR_ERR(skb);
@@ -1123,11 +1613,10 @@ int mt7996_mcu_set_timing(struct mt7996_phy *phy, struct ieee80211_vif *vif,
 }
 
 static int
-mt7996_mcu_sta_ba(struct mt7996_dev *dev, struct mt76_vif_link *mvif,
+mt7996_mcu_sta_ba(struct mt7996_dev *dev, struct mt76_vif *mvif,
 		  struct ieee80211_ampdu_params *params,
-		  bool enable, bool tx)
+		  struct mt76_wcid *wcid, bool enable, bool tx)
 {
-	struct mt76_wcid *wcid = (struct mt76_wcid *)params->sta->drv_priv;
 	struct sta_rec_ba_uni *ba;
 	struct sk_buff *skb;
 	struct tlv *tlv;
@@ -1152,40 +1641,164 @@ mt7996_mcu_sta_ba(struct mt7996_dev *dev, struct mt76_vif_link *mvif,
 				     MCU_WMWA_UNI_CMD(STA_REC_UPDATE), true);
 }
 
+static int
+mt7996_mcu_sta_tx_cap(struct mt7996_dev *dev, struct mt76_vif *mvif,
+		      struct mt76_wcid *wcid)
+{
+	struct sta_rec_tx_cap *tx_cap;
+	struct sk_buff *skb;
+	struct tlv *tlv;
+
+	skb = __mt76_connac_mcu_alloc_sta_req(&dev->mt76, mvif, wcid,
+					      MT7996_STA_UPDATE_MAX_SIZE);
+	if (IS_ERR(skb))
+		return PTR_ERR(skb);
+
+	tlv = mt76_connac_mcu_add_tlv(skb, STA_REC_TX_CAP, sizeof(*tx_cap));
+
+	tx_cap = (struct sta_rec_tx_cap *)tlv;
+	tx_cap->ampdu_limit_en = true;
+
+	dev_info(dev->mt76.dev, "%s: limit wcid %d ampdu to 512\n", __func__, wcid->idx);
+
+	return mt76_mcu_skb_send_msg(&dev->mt76, skb,
+				     MCU_WMWA_UNI_CMD(STA_REC_UPDATE), true);
+}
+
+static bool mt7996_check_limit_ampdu_en(struct ieee80211_ampdu_params *params) {
+	struct ieee80211_sta *sta = params->sta;
+	struct mt7996_sta *msta = (struct mt7996_sta *)sta->drv_priv;
+	unsigned long valid_links = sta->valid_links ?: BIT(0);
+	unsigned int link_id;
+	bool BW320 = false, BW160 = false;
+
+	if (params->buf_size < 1024)
+		return false;
+
+	for_each_set_bit(link_id, &valid_links, IEEE80211_MLD_MAX_NUM_LINKS) {
+		struct ieee80211_link_sta __rcu *link =
+			link_sta_dereference_protected(sta, link_id);
+		struct mt7996_bss_conf *mconf =
+			mconf_dereference_protected(msta->vif, link_id);
+		struct mt76_phy *phy = mconf->phy->mt76;
+		struct ieee80211_eht_mcs_nss_supp_bw *ss = NULL;
+		u8 sta_bw, ap_nss, sta_nss;
+
+		switch (phy->chandef.width) {
+		case NL80211_CHAN_WIDTH_160:
+			if (link->bandwidth >= IEEE80211_STA_RX_BW_160) {
+				ss = &link->eht_cap.eht_mcs_nss_supp.bw._160;
+				sta_bw = NL80211_CHAN_WIDTH_160;
+			}
+			break;
+		case NL80211_CHAN_WIDTH_320:
+			if (link->bandwidth == IEEE80211_STA_RX_BW_320) {
+				ss = &link->eht_cap.eht_mcs_nss_supp.bw._320;
+				sta_bw = NL80211_CHAN_WIDTH_320;
+			}
+			break;
+		default:
+			break;
+		}
+
+		if (!ss)
+			continue;
+
+		ap_nss = hweight8(phy->antenna_mask);
+		sta_nss = max(u8_get_bits(ss->rx_tx_mcs11_max_nss, IEEE80211_EHT_MCS_NSS_RX),
+			      u8_get_bits(ss->rx_tx_mcs13_max_nss, IEEE80211_EHT_MCS_NSS_RX));
+
+		if (min(ap_nss, sta_nss) <= 2)
+			continue;
+
+		if (sta_bw == NL80211_CHAN_WIDTH_160)
+			BW160 = true;
+		else if (sta_bw == NL80211_CHAN_WIDTH_320)
+			BW320 = true;
+	}
+
+	return BW320 && BW160;
+}
+
 /** starec & wtbl **/
 int mt7996_mcu_add_tx_ba(struct mt7996_dev *dev,
 			 struct ieee80211_ampdu_params *params,
 			 bool enable)
 {
-	struct mt7996_sta *msta = (struct mt7996_sta *)params->sta->drv_priv;
-	struct mt7996_vif *mvif = msta->vif;
+	struct ieee80211_sta *sta = params->sta;
+	struct mt7996_sta *msta = (struct mt7996_sta *)sta->drv_priv;
+	unsigned long valid_links = sta->valid_links ?: BIT(0);
+	unsigned int link_id;
+	bool limit_ampdu_en = mt7996_check_limit_ampdu_en(params);
+
+	for_each_set_bit(link_id, &valid_links, IEEE80211_MLD_MAX_NUM_LINKS) {
+		struct mt7996_link_sta *mlink =
+			mlink_dereference_protected(msta, link_id);
+		struct mt7996_bss_conf *mconf =
+			mconf_dereference_protected(msta->vif, link_id);
+		int ret;
+
+		if (!mlink || !mconf)
+			continue;
+
+		if (enable && !params->amsdu)
+			mlink->wcid.amsdu = false;
+
+		ret = mt7996_mcu_sta_ba(dev, &mconf->mt76, params,
+					&mlink->wcid, enable, true);
+		if (ret)
+			return ret;
 
-	if (enable && !params->amsdu)
-		msta->wcid.amsdu = false;
+		if (limit_ampdu_en) {
+			ret = mt7996_mcu_sta_tx_cap(dev, &mconf->mt76, &mlink->wcid);
+			if (ret)
+				return ret;
+		}
+	}
 
-	return mt7996_mcu_sta_ba(dev, &mvif->deflink.mt76, params, enable, true);
+	return 0;
 }
 
 int mt7996_mcu_add_rx_ba(struct mt7996_dev *dev,
 			 struct ieee80211_ampdu_params *params,
 			 bool enable)
 {
-	struct mt7996_sta *msta = (struct mt7996_sta *)params->sta->drv_priv;
-	struct mt7996_vif *mvif = msta->vif;
+	struct ieee80211_sta *sta = params->sta;
+	struct mt7996_sta *msta = (struct mt7996_sta *)sta->drv_priv;
+	unsigned long valid_links = sta->valid_links ?: BIT(0);
+	unsigned int link_id;
+
+	for_each_set_bit(link_id, &valid_links, IEEE80211_MLD_MAX_NUM_LINKS) {
+		struct mt7996_link_sta *mlink =
+			mlink_dereference_protected(msta, link_id);
+		struct mt7996_bss_conf *mconf =
+			mconf_dereference_protected(msta->vif, link_id);
+		int ret;
+
+		if (!mlink || !mconf)
+			continue;
+
+		ret = mt7996_mcu_sta_ba(dev, &mconf->mt76, params, &mlink->wcid,
+					enable, false);
+		if (ret)
+			return ret;
+	}
 
-	return mt7996_mcu_sta_ba(dev, &mvif->deflink.mt76, params, enable, false);
+	return 0;
 }
 
 static void
-mt7996_mcu_sta_he_tlv(struct sk_buff *skb, struct ieee80211_sta *sta)
+mt7996_mcu_sta_he_tlv(struct sk_buff *skb, struct ieee80211_bss_conf *conf,
+		      struct mt7996_bss_conf *mconf,
+		      struct ieee80211_link_sta *link_sta)
 {
-	struct ieee80211_he_cap_elem *elem = &sta->deflink.he_cap.he_cap_elem;
+	struct ieee80211_he_cap_elem *elem = &link_sta->he_cap.he_cap_elem;
 	struct ieee80211_he_mcs_nss_supp mcs_map;
 	struct sta_rec_he_v2 *he;
 	struct tlv *tlv;
 	int i = 0;
 
-	if (!sta->deflink.he_cap.has_he)
+	if (!link_sta->he_cap.has_he)
 		return;
 
 	tlv = mt76_connac_mcu_add_tlv(skb, STA_REC_HE_V2, sizeof(*he));
@@ -1197,21 +1810,26 @@ mt7996_mcu_sta_he_tlv(struct sk_buff *skb, struct ieee80211_sta *sta)
 		he->he_phy_cap[i] = elem->phy_cap_info[i];
 	}
 
-	mcs_map = sta->deflink.he_cap.he_mcs_nss_supp;
-	switch (sta->deflink.bandwidth) {
+	if (conf->vif->type == NL80211_IFTYPE_AP &&
+	    (elem->phy_cap_info[1] & IEEE80211_HE_PHY_CAP1_LDPC_CODING_IN_PAYLOAD))
+		u8p_replace_bits(&he->he_phy_cap[1], conf->he_ldpc,
+				 IEEE80211_HE_PHY_CAP1_LDPC_CODING_IN_PAYLOAD);
+
+	mcs_map = link_sta->he_cap.he_mcs_nss_supp;
+	switch (link_sta->bandwidth) {
 	case IEEE80211_STA_RX_BW_160:
 		if (elem->phy_cap_info[0] &
 		    IEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_80PLUS80_MHZ_IN_5G)
-			mt7996_mcu_set_sta_he_mcs(sta,
+			mt7996_mcu_set_sta_he_mcs(link_sta, mconf,
 						  &he->max_nss_mcs[CMD_HE_MCS_BW8080],
 						  le16_to_cpu(mcs_map.rx_mcs_80p80));
 
-		mt7996_mcu_set_sta_he_mcs(sta,
+		mt7996_mcu_set_sta_he_mcs(link_sta, mconf,
 					  &he->max_nss_mcs[CMD_HE_MCS_BW160],
 					  le16_to_cpu(mcs_map.rx_mcs_160));
 		fallthrough;
 	default:
-		mt7996_mcu_set_sta_he_mcs(sta,
+		mt7996_mcu_set_sta_he_mcs(link_sta, mconf,
 					  &he->max_nss_mcs[CMD_HE_MCS_BW80],
 					  le16_to_cpu(mcs_map.rx_mcs_80));
 		break;
@@ -1221,24 +1839,25 @@ mt7996_mcu_sta_he_tlv(struct sk_buff *skb, struct ieee80211_sta *sta)
 }
 
 static void
-mt7996_mcu_sta_he_6g_tlv(struct sk_buff *skb, struct ieee80211_sta *sta)
+mt7996_mcu_sta_he_6g_tlv(struct sk_buff *skb,
+			 struct ieee80211_link_sta *link_sta)
 {
 	struct sta_rec_he_6g_capa *he_6g;
 	struct tlv *tlv;
 
-	if (!sta->deflink.he_6ghz_capa.capa)
+	if (!link_sta->he_6ghz_capa.capa)
 		return;
 
 	tlv = mt76_connac_mcu_add_tlv(skb, STA_REC_HE_6G, sizeof(*he_6g));
 
 	he_6g = (struct sta_rec_he_6g_capa *)tlv;
-	he_6g->capa = sta->deflink.he_6ghz_capa.capa;
+	he_6g->capa = link_sta->he_6ghz_capa.capa;
 }
 
 static void
-mt7996_mcu_sta_eht_tlv(struct sk_buff *skb, struct ieee80211_sta *sta)
+mt7996_mcu_sta_eht_tlv(struct sk_buff *skb, struct ieee80211_link_sta *link_sta)
 {
-	struct mt7996_sta *msta = (struct mt7996_sta *)sta->drv_priv;
+	struct mt7996_sta *msta = (struct mt7996_sta *)link_sta->sta->drv_priv;
 	struct ieee80211_vif *vif = container_of((void *)msta->vif,
 						 struct ieee80211_vif, drv_priv);
 	struct ieee80211_eht_mcs_nss_supp *mcs_map;
@@ -1246,11 +1865,11 @@ mt7996_mcu_sta_eht_tlv(struct sk_buff *skb, struct ieee80211_sta *sta)
 	struct sta_rec_eht *eht;
 	struct tlv *tlv;
 
-	if (!sta->deflink.eht_cap.has_eht)
+	if (!link_sta->eht_cap.has_eht)
 		return;
 
-	mcs_map = &sta->deflink.eht_cap.eht_mcs_nss_supp;
-	elem = &sta->deflink.eht_cap.eht_cap_elem;
+	mcs_map = &link_sta->eht_cap.eht_mcs_nss_supp;
+	elem = &link_sta->eht_cap.eht_cap_elem;
 
 	tlv = mt76_connac_mcu_add_tlv(skb, STA_REC_EHT, sizeof(*eht));
 
@@ -1261,7 +1880,7 @@ mt7996_mcu_sta_eht_tlv(struct sk_buff *skb, struct ieee80211_sta *sta)
 	eht->phy_cap_ext = cpu_to_le64(elem->phy_cap_info[8]);
 
 	if (vif->type != NL80211_IFTYPE_STATION &&
-	    (sta->deflink.he_cap.he_cap_elem.phy_cap_info[0] &
+	    (link_sta->he_cap.he_cap_elem.phy_cap_info[0] &
 	     (IEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_40MHZ_IN_2G |
 	      IEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_40MHZ_80MHZ_IN_5G |
 	      IEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_160MHZ_IN_5G |
@@ -1277,47 +1896,55 @@ mt7996_mcu_sta_eht_tlv(struct sk_buff *skb, struct ieee80211_sta *sta)
 }
 
 static void
-mt7996_mcu_sta_ht_tlv(struct sk_buff *skb, struct ieee80211_sta *sta)
+mt7996_mcu_sta_ht_tlv(struct sk_buff *skb, struct ieee80211_link_sta *link_sta)
 {
 	struct sta_rec_ht_uni *ht;
 	struct tlv *tlv;
 
-	if (!sta->deflink.ht_cap.ht_supported)
+	if (!link_sta->ht_cap.ht_supported)
 		return;
 
 	tlv = mt76_connac_mcu_add_tlv(skb, STA_REC_HT, sizeof(*ht));
 
 	ht = (struct sta_rec_ht_uni *)tlv;
-	ht->ht_cap = cpu_to_le16(sta->deflink.ht_cap.cap);
-	ht->ampdu_param = u8_encode_bits(sta->deflink.ht_cap.ampdu_factor,
+	ht->ht_cap = cpu_to_le16(link_sta->ht_cap.cap);
+	ht->ampdu_param = u8_encode_bits(link_sta->ht_cap.ampdu_factor,
 					 IEEE80211_HT_AMPDU_PARM_FACTOR) |
-			  u8_encode_bits(sta->deflink.ht_cap.ampdu_density,
+			  u8_encode_bits(link_sta->ht_cap.ampdu_density,
 					 IEEE80211_HT_AMPDU_PARM_DENSITY);
 }
 
 static void
-mt7996_mcu_sta_vht_tlv(struct sk_buff *skb, struct ieee80211_sta *sta)
+mt7996_mcu_sta_vht_tlv(struct sk_buff *skb, struct ieee80211_link_sta *link_sta)
 {
 	struct sta_rec_vht *vht;
 	struct tlv *tlv;
+#ifdef CONFIG_MTK_VENDOR
+	struct mt7996_sta *msta = (struct mt7996_sta *)link_sta->sta->drv_priv;
+	struct mt7996_phy *phy = (struct mt7996_phy *)msta->vif->deflink.phy;
+#endif
 
 	/* For 6G band, this tlv is necessary to let hw work normally */
-	if (!sta->deflink.he_6ghz_capa.capa && !sta->deflink.vht_cap.vht_supported)
+	if (!link_sta->he_6ghz_capa.capa && !link_sta->vht_cap.vht_supported)
 		return;
 
 	tlv = mt76_connac_mcu_add_tlv(skb, STA_REC_VHT, sizeof(*vht));
 
 	vht = (struct sta_rec_vht *)tlv;
-	vht->vht_cap = cpu_to_le32(sta->deflink.vht_cap.cap);
-	vht->vht_rx_mcs_map = sta->deflink.vht_cap.vht_mcs.rx_mcs_map;
-	vht->vht_tx_mcs_map = sta->deflink.vht_cap.vht_mcs.tx_mcs_map;
+	vht->vht_cap = cpu_to_le32(link_sta->vht_cap.cap);
+	vht->vht_rx_mcs_map = link_sta->vht_cap.vht_mcs.rx_mcs_map;
+	vht->vht_tx_mcs_map = link_sta->vht_cap.vht_mcs.tx_mcs_map;
+#ifdef CONFIG_MTK_VENDOR
+	vht->rts_bw_sig = phy->rts_bw_sig;
+#endif
 }
 
 static void
 mt7996_mcu_sta_amsdu_tlv(struct mt7996_dev *dev, struct sk_buff *skb,
-			 struct ieee80211_vif *vif, struct ieee80211_sta *sta)
+			 struct ieee80211_vif *vif,
+			 struct ieee80211_link_sta *link_sta,
+			 struct mt7996_link_sta *mlink)
 {
-	struct mt7996_sta *msta = (struct mt7996_sta *)sta->drv_priv;
 	struct sta_rec_amsdu *amsdu;
 	struct tlv *tlv;
 
@@ -1326,18 +1953,20 @@ mt7996_mcu_sta_amsdu_tlv(struct mt7996_dev *dev, struct sk_buff *skb,
 	    vif->type != NL80211_IFTYPE_AP)
 		return;
 
-	if (!sta->deflink.agg.max_amsdu_len)
+	if (!link_sta->agg.max_amsdu_len)
 		return;
 
 	tlv = mt76_connac_mcu_add_tlv(skb, STA_REC_HW_AMSDU, sizeof(*amsdu));
 	amsdu = (struct sta_rec_amsdu *)tlv;
 	amsdu->max_amsdu_num = 8;
 	amsdu->amsdu_en = true;
-	msta->wcid.amsdu = true;
+	mlink->wcid.amsdu = true;
 
-	switch (sta->deflink.agg.max_amsdu_len) {
+	switch (link_sta->agg.max_amsdu_len) {
 	case IEEE80211_MAX_MPDU_LEN_VHT_11454:
 		amsdu->max_mpdu_size =
+			(mlink->wcid.phy_idx == MT_BAND0 && !link_sta->sta->mlo) ?
+			IEEE80211_VHT_CAP_MAX_MPDU_LENGTH_7991:
 			IEEE80211_VHT_CAP_MAX_MPDU_LENGTH_11454;
 		return;
 	case IEEE80211_MAX_MPDU_LEN_HT_7935:
@@ -1352,30 +1981,36 @@ mt7996_mcu_sta_amsdu_tlv(struct mt7996_dev *dev, struct sk_buff *skb,
 
 static void
 mt7996_mcu_sta_muru_tlv(struct mt7996_dev *dev, struct sk_buff *skb,
-			struct ieee80211_vif *vif, struct ieee80211_sta *sta)
+			struct ieee80211_bss_conf *conf,
+			struct mt7996_bss_conf *mconf,
+			struct ieee80211_link_sta *link_sta)
 {
-	struct ieee80211_he_cap_elem *elem = &sta->deflink.he_cap.he_cap_elem;
+	struct mt7996_phy *phy = mconf->phy;
+	struct ieee80211_he_cap_elem *elem = &link_sta->he_cap.he_cap_elem;
 	struct sta_rec_muru *muru;
 	struct tlv *tlv;
 
-	if (vif->type != NL80211_IFTYPE_STATION &&
-	    vif->type != NL80211_IFTYPE_AP)
+	if (conf->vif->type != NL80211_IFTYPE_STATION &&
+	    conf->vif->type != NL80211_IFTYPE_AP)
 		return;
 
 	tlv = mt76_connac_mcu_add_tlv(skb, STA_REC_MURU, sizeof(*muru));
 
 	muru = (struct sta_rec_muru *)tlv;
-	muru->cfg.mimo_dl_en = vif->bss_conf.eht_mu_beamformer ||
-			       vif->bss_conf.he_mu_beamformer ||
-			       vif->bss_conf.vht_mu_beamformer ||
-			       vif->bss_conf.vht_mu_beamformee;
-	muru->cfg.ofdma_dl_en = true;
-
-	if (sta->deflink.vht_cap.vht_supported)
+	muru->cfg.mimo_dl_en = (conf->eht_mu_beamformer ||
+				conf->he_mu_beamformer ||
+				conf->vht_mu_beamformer ||
+				conf->vht_mu_beamformee) &&
+			       !!(phy->muru_onoff & MUMIMO_DL);
+	muru->cfg.mimo_ul_en = !!(phy->muru_onoff & MUMIMO_UL);
+	muru->cfg.ofdma_dl_en = !!(phy->muru_onoff & OFDMA_DL);
+	muru->cfg.ofdma_ul_en = !!(phy->muru_onoff & OFDMA_UL);
+
+	if (link_sta->vht_cap.vht_supported)
 		muru->mimo_dl.vht_mu_bfee =
-			!!(sta->deflink.vht_cap.cap & IEEE80211_VHT_CAP_MU_BEAMFORMEE_CAPABLE);
+			!!(link_sta->vht_cap.cap & IEEE80211_VHT_CAP_MU_BEAMFORMEE_CAPABLE);
 
-	if (!sta->deflink.he_cap.has_he)
+	if (!link_sta->he_cap.has_he)
 		return;
 
 	muru->mimo_dl.partial_bw_dl_mimo =
@@ -1406,49 +2041,50 @@ mt7996_mcu_sta_muru_tlv(struct mt7996_dev *dev, struct sk_buff *skb,
 }
 
 static inline bool
-mt7996_is_ebf_supported(struct mt7996_phy *phy, struct ieee80211_vif *vif,
-			struct ieee80211_sta *sta, bool bfee)
+mt7996_is_ebf_supported(struct mt7996_phy *phy, struct ieee80211_bss_conf *conf,
+			struct mt7996_bss_conf *mconf,
+			struct ieee80211_link_sta *link_sta, bool bfee)
 {
 	int sts = hweight16(phy->mt76->chainmask);
 
-	if (vif->type != NL80211_IFTYPE_STATION &&
-	    vif->type != NL80211_IFTYPE_AP)
+	if (conf->vif->type != NL80211_IFTYPE_STATION &&
+	    conf->vif->type != NL80211_IFTYPE_AP)
 		return false;
 
 	if (!bfee && sts < 2)
 		return false;
 
-	if (sta->deflink.eht_cap.has_eht) {
-		struct ieee80211_sta_eht_cap *pc = &sta->deflink.eht_cap;
+	if (link_sta->eht_cap.has_eht) {
+		struct ieee80211_sta_eht_cap *pc = &link_sta->eht_cap;
 		struct ieee80211_eht_cap_elem_fixed *pe = &pc->eht_cap_elem;
 
 		if (bfee)
-			return vif->bss_conf.eht_su_beamformee &&
+			return conf->eht_su_beamformee &&
 			       EHT_PHY(CAP0_SU_BEAMFORMER, pe->phy_cap_info[0]);
 		else
-			return vif->bss_conf.eht_su_beamformer &&
+			return conf->eht_su_beamformer &&
 			       EHT_PHY(CAP0_SU_BEAMFORMEE, pe->phy_cap_info[0]);
 	}
 
-	if (sta->deflink.he_cap.has_he) {
-		struct ieee80211_he_cap_elem *pe = &sta->deflink.he_cap.he_cap_elem;
+	if (link_sta->he_cap.has_he) {
+		struct ieee80211_he_cap_elem *pe = &link_sta->he_cap.he_cap_elem;
 
 		if (bfee)
-			return vif->bss_conf.he_su_beamformee &&
+			return conf->he_su_beamformee &&
 			       HE_PHY(CAP3_SU_BEAMFORMER, pe->phy_cap_info[3]);
 		else
-			return vif->bss_conf.he_su_beamformer &&
+			return conf->he_su_beamformer &&
 			       HE_PHY(CAP4_SU_BEAMFORMEE, pe->phy_cap_info[4]);
 	}
 
-	if (sta->deflink.vht_cap.vht_supported) {
-		u32 cap = sta->deflink.vht_cap.cap;
+	if (link_sta->vht_cap.vht_supported) {
+		u32 cap = link_sta->vht_cap.cap;
 
 		if (bfee)
-			return vif->bss_conf.vht_su_beamformee &&
+			return conf->vht_su_beamformee &&
 			       (cap & IEEE80211_VHT_CAP_SU_BEAMFORMER_CAPABLE);
 		else
-			return vif->bss_conf.vht_su_beamformer &&
+			return conf->vht_su_beamformer &&
 			       (cap & IEEE80211_VHT_CAP_SU_BEAMFORMEE_CAPABLE);
 	}
 
@@ -1469,10 +2105,10 @@ mt7996_mcu_sta_sounding_rate(struct sta_rec_bf *bf, struct mt7996_phy *phy)
 }
 
 static void
-mt7996_mcu_sta_bfer_ht(struct ieee80211_sta *sta, struct mt7996_phy *phy,
-		       struct sta_rec_bf *bf, bool explicit)
+mt7996_mcu_sta_bfer_ht(struct ieee80211_link_sta *link_sta,
+		       struct mt7996_phy *phy, struct sta_rec_bf *bf, bool explicit)
 {
-	struct ieee80211_mcs_info *mcs = &sta->deflink.ht_cap.mcs;
+	struct ieee80211_mcs_info *mcs = &link_sta->ht_cap.mcs;
 	u8 n = 0;
 
 	bf->tx_mode = MT_PHY_TYPE_HT;
@@ -1495,10 +2131,11 @@ mt7996_mcu_sta_bfer_ht(struct ieee80211_sta *sta, struct mt7996_phy *phy,
 }
 
 static void
-mt7996_mcu_sta_bfer_vht(struct ieee80211_sta *sta, struct mt7996_phy *phy,
-			struct sta_rec_bf *bf, bool explicit)
+mt7996_mcu_sta_bfer_vht(struct ieee80211_link_sta *link_sta,
+			struct mt7996_phy *phy, struct sta_rec_bf *bf,
+			bool explicit)
 {
-	struct ieee80211_sta_vht_cap *pc = &sta->deflink.vht_cap;
+	struct ieee80211_sta_vht_cap *pc = &link_sta->vht_cap;
 	struct ieee80211_sta_vht_cap *vc = &phy->mt76->sband_5g.sband.vht_cap;
 	u16 mcs_map = le16_to_cpu(pc->vht_mcs.rx_mcs_map);
 	u8 nss_mcs = mt7996_mcu_get_sta_nss(mcs_map);
@@ -1519,24 +2156,24 @@ mt7996_mcu_sta_bfer_vht(struct ieee80211_sta *sta, struct mt7996_phy *phy,
 		bf->ncol = min_t(u8, nss_mcs, bf->nrow);
 		bf->ibf_ncol = min_t(u8, MT7996_IBF_MAX_NC, bf->ncol);
 
-		if (sta->deflink.bandwidth == IEEE80211_STA_RX_BW_160)
+		if (link_sta->bandwidth == IEEE80211_STA_RX_BW_160)
 			bf->nrow = 1;
 	} else {
 		bf->nrow = tx_ant;
 		bf->ncol = min_t(u8, nss_mcs, bf->nrow);
 		bf->ibf_ncol = min_t(u8, MT7996_IBF_MAX_NC, nss_mcs);
 
-		if (sta->deflink.bandwidth == IEEE80211_STA_RX_BW_160)
+		if (link_sta->bandwidth == IEEE80211_STA_RX_BW_160)
 			bf->ibf_nrow = 1;
 	}
 }
 
 static void
-mt7996_mcu_sta_bfer_he(struct ieee80211_sta *sta, struct ieee80211_vif *vif,
-		       struct mt7996_phy *phy, struct sta_rec_bf *bf,
-		       bool explicit)
+mt7996_mcu_sta_bfer_he(struct ieee80211_link_sta *link_sta,
+		       struct ieee80211_vif *vif, struct mt7996_phy *phy,
+		       struct sta_rec_bf *bf, bool explicit)
 {
-	struct ieee80211_sta_he_cap *pc = &sta->deflink.he_cap;
+	struct ieee80211_sta_he_cap *pc = &link_sta->he_cap;
 	struct ieee80211_he_cap_elem *pe = &pc->he_cap_elem;
 	const struct ieee80211_sta_he_cap *vc =
 		mt76_connac_get_he_phy_cap(phy->mt76, vif);
@@ -1545,9 +2182,6 @@ mt7996_mcu_sta_bfer_he(struct ieee80211_sta *sta, struct ieee80211_vif *vif,
 	u8 nss_mcs = mt7996_mcu_get_sta_nss(mcs_map);
 	u8 snd_dim, sts;
 
-	if (!vc)
-		return;
-
 	bf->tx_mode = MT_PHY_TYPE_HE_SU;
 
 	mt7996_mcu_sta_sounding_rate(bf, phy);
@@ -1565,7 +2199,7 @@ mt7996_mcu_sta_bfer_he(struct ieee80211_sta *sta, struct ieee80211_vif *vif,
 	bf->ibf_ncol = explicit ? min_t(u8, MT7996_IBF_MAX_NC, bf->ncol) :
 				  min_t(u8, MT7996_IBF_MAX_NC, nss_mcs);
 
-	if (sta->deflink.bandwidth != IEEE80211_STA_RX_BW_160)
+	if (link_sta->bandwidth != IEEE80211_STA_RX_BW_160)
 		return;
 
 	/* go over for 160MHz and 80p80 */
@@ -1597,11 +2231,11 @@ mt7996_mcu_sta_bfer_he(struct ieee80211_sta *sta, struct ieee80211_vif *vif,
 }
 
 static void
-mt7996_mcu_sta_bfer_eht(struct ieee80211_sta *sta, struct ieee80211_vif *vif,
-			struct mt7996_phy *phy, struct sta_rec_bf *bf,
-			bool explicit)
+mt7996_mcu_sta_bfer_eht(struct ieee80211_link_sta *link_sta,
+			struct ieee80211_vif *vif, struct mt7996_phy *phy,
+			struct sta_rec_bf *bf, bool explicit)
 {
-	struct ieee80211_sta_eht_cap *pc = &sta->deflink.eht_cap;
+	struct ieee80211_sta_eht_cap *pc = &link_sta->eht_cap;
 	struct ieee80211_eht_cap_elem_fixed *pe = &pc->eht_cap_elem;
 	struct ieee80211_eht_mcs_nss_supp *eht_nss = &pc->eht_mcs_nss_supp;
 	const struct ieee80211_sta_eht_cap *vc =
@@ -1625,10 +2259,10 @@ mt7996_mcu_sta_bfer_eht(struct ieee80211_sta *sta, struct ieee80211_vif *vif,
 	bf->ibf_ncol = explicit ? min_t(u8, MT7996_IBF_MAX_NC, bf->ncol) :
 				  min_t(u8, MT7996_IBF_MAX_NC, nss_mcs);
 
-	if (sta->deflink.bandwidth < IEEE80211_STA_RX_BW_160)
+	if (link_sta->bandwidth < IEEE80211_STA_RX_BW_160)
 		return;
 
-	switch (sta->deflink.bandwidth) {
+	switch (link_sta->bandwidth) {
 	case IEEE80211_STA_RX_BW_160:
 		snd_dim = EHT_PHY(CAP2_SOUNDING_DIM_160MHZ_MASK, ve->phy_cap_info[2]);
 		sts = EHT_PHY(CAP1_BEAMFORMEE_SS_160MHZ_MASK, pe->phy_cap_info[1]);
@@ -1656,13 +2290,13 @@ mt7996_mcu_sta_bfer_eht(struct ieee80211_sta *sta, struct ieee80211_vif *vif,
 
 static void
 mt7996_mcu_sta_bfer_tlv(struct mt7996_dev *dev, struct sk_buff *skb,
-			struct ieee80211_vif *vif, struct ieee80211_sta *sta)
+			struct ieee80211_bss_conf *conf, struct mt7996_bss_conf *mconf,
+			struct ieee80211_link_sta *link_sta)
 {
 #define EBF_MODE	BIT(0)
 #define IBF_MODE	BIT(1)
 #define BF_MAT_ORDER	4
-	struct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;
-	struct mt7996_phy *phy = mvif->deflink.phy;
+	struct mt7996_phy *phy = mconf->phy;
 	int tx_ant = hweight16(phy->mt76->chainmask) - 1;
 	struct sta_rec_bf *bf;
 	struct tlv *tlv;
@@ -1674,10 +2308,10 @@ mt7996_mcu_sta_bfer_tlv(struct mt7996_dev *dev, struct sk_buff *skb,
 	};
 	bool ebf;
 
-	if (!(sta->deflink.ht_cap.ht_supported || sta->deflink.he_cap.has_he))
+	if (!(link_sta->ht_cap.ht_supported || link_sta->he_cap.has_he))
 		return;
 
-	ebf = mt7996_is_ebf_supported(phy, vif, sta, false);
+	ebf = mt7996_is_ebf_supported(phy, conf, mconf, link_sta, false);
 	if (!ebf && !dev->ibf)
 		return;
 
@@ -1688,28 +2322,28 @@ mt7996_mcu_sta_bfer_tlv(struct mt7996_dev *dev, struct sk_buff *skb,
 	 * vht: support eBF and iBF
 	 * ht: iBF only, since mac80211 lacks of eBF support
 	 */
-	if (sta->deflink.eht_cap.has_eht)
-		mt7996_mcu_sta_bfer_eht(sta, vif, phy, bf, ebf);
-	else if (sta->deflink.he_cap.has_he)
-		mt7996_mcu_sta_bfer_he(sta, vif, phy, bf, ebf);
-	else if (sta->deflink.vht_cap.vht_supported)
-		mt7996_mcu_sta_bfer_vht(sta, phy, bf, ebf);
-	else if (sta->deflink.ht_cap.ht_supported)
-		mt7996_mcu_sta_bfer_ht(sta, phy, bf, ebf);
+	if (link_sta->eht_cap.has_eht)
+		mt7996_mcu_sta_bfer_eht(link_sta, conf->vif, phy, bf, ebf);
+	else if (link_sta->he_cap.has_he)
+		mt7996_mcu_sta_bfer_he(link_sta, conf->vif, phy, bf, ebf);
+	else if (link_sta->vht_cap.vht_supported)
+		mt7996_mcu_sta_bfer_vht(link_sta, phy, bf, ebf);
+	else if (link_sta->ht_cap.ht_supported)
+		mt7996_mcu_sta_bfer_ht(link_sta, phy, bf, ebf);
 	else
 		return;
 
 	bf->bf_cap = ebf ? EBF_MODE : (dev->ibf ? IBF_MODE : 0);
 	if (is_mt7992(&dev->mt76) && tx_ant == 4)
 		bf->bf_cap |= IBF_MODE;
-	bf->bw = sta->deflink.bandwidth;
-	bf->ibf_dbw = sta->deflink.bandwidth;
+	bf->bw = link_sta->bandwidth;
+	bf->ibf_dbw = link_sta->bandwidth;
 	bf->ibf_nrow = tx_ant;
 
-	if (sta->deflink.eht_cap.has_eht || sta->deflink.he_cap.has_he)
+	if (link_sta->eht_cap.has_eht || link_sta->he_cap.has_he)
 		bf->ibf_timeout = is_mt7996(&dev->mt76) ? MT7996_IBF_TIMEOUT :
 							  MT7992_IBF_TIMEOUT;
-	else if (!ebf && sta->deflink.bandwidth <= IEEE80211_STA_RX_BW_40 && !bf->ncol)
+	else if (!ebf && link_sta->bandwidth <= IEEE80211_STA_RX_BW_40 && !bf->ncol)
 		bf->ibf_timeout = MT7996_IBF_TIMEOUT_LEGACY;
 	else
 		bf->ibf_timeout = MT7996_IBF_TIMEOUT;
@@ -1723,7 +2357,7 @@ mt7996_mcu_sta_bfer_tlv(struct mt7996_dev *dev, struct sk_buff *skb,
 				      matrix[bf->nrow][bf->ncol] : 0;
 	}
 
-	switch (sta->deflink.bandwidth) {
+	switch (link_sta->bandwidth) {
 	case IEEE80211_STA_RX_BW_160:
 	case IEEE80211_STA_RX_BW_80:
 		bf->mem_total = bf->mem_20m * 2;
@@ -1739,31 +2373,32 @@ mt7996_mcu_sta_bfer_tlv(struct mt7996_dev *dev, struct sk_buff *skb,
 
 static void
 mt7996_mcu_sta_bfee_tlv(struct mt7996_dev *dev, struct sk_buff *skb,
-			struct ieee80211_vif *vif, struct ieee80211_sta *sta)
+			struct ieee80211_bss_conf *conf,
+			struct mt7996_bss_conf *mconf,
+			struct ieee80211_link_sta *link_sta)
 {
-	struct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;
-	struct mt7996_phy *phy = mvif->deflink.phy;
+	struct mt7996_phy *phy = mconf->phy;
 	int tx_ant = hweight8(phy->mt76->antenna_mask) - 1;
 	struct sta_rec_bfee *bfee;
 	struct tlv *tlv;
 	u8 nrow = 0;
 
-	if (!(sta->deflink.vht_cap.vht_supported || sta->deflink.he_cap.has_he))
+	if (!(link_sta->vht_cap.vht_supported || link_sta->he_cap.has_he))
 		return;
 
-	if (!mt7996_is_ebf_supported(phy, vif, sta, true))
+	if (!mt7996_is_ebf_supported(phy, conf, mconf, link_sta, true))
 		return;
 
 	tlv = mt76_connac_mcu_add_tlv(skb, STA_REC_BFEE, sizeof(*bfee));
 	bfee = (struct sta_rec_bfee *)tlv;
 
-	if (sta->deflink.he_cap.has_he) {
-		struct ieee80211_he_cap_elem *pe = &sta->deflink.he_cap.he_cap_elem;
+	if (link_sta->he_cap.has_he) {
+		struct ieee80211_he_cap_elem *pe = &link_sta->he_cap.he_cap_elem;
 
 		nrow = HE_PHY(CAP5_BEAMFORMEE_NUM_SND_DIM_UNDER_80MHZ_MASK,
 			      pe->phy_cap_info[5]);
-	} else if (sta->deflink.vht_cap.vht_supported) {
-		struct ieee80211_sta_vht_cap *pc = &sta->deflink.vht_cap;
+	} else if (link_sta->vht_cap.vht_supported) {
+		struct ieee80211_sta_vht_cap *pc = &link_sta->vht_cap;
 
 		nrow = FIELD_GET(IEEE80211_VHT_CAP_SOUNDING_DIMENSIONS_MASK,
 				 pc->cap);
@@ -1799,23 +2434,25 @@ mt7996_mcu_sta_hdrt_tlv(struct mt7996_dev *dev, struct sk_buff *skb)
 
 static void
 mt7996_mcu_sta_hdr_trans_tlv(struct mt7996_dev *dev, struct sk_buff *skb,
-			     struct ieee80211_vif *vif, struct mt76_wcid *wcid)
+			     struct ieee80211_vif *vif,
+			     struct mt7996_link_sta *mlink)
 {
 	struct sta_rec_hdr_trans *hdr_trans;
+	struct mt76_wcid *wcid = &mlink->wcid;
 	struct tlv *tlv;
 
 	tlv = mt76_connac_mcu_add_tlv(skb, STA_REC_HDR_TRANS, sizeof(*hdr_trans));
 	hdr_trans = (struct sta_rec_hdr_trans *)tlv;
 	hdr_trans->dis_rx_hdr_tran = true;
 
+	if (!wcid->sta)
+		return;
+
 	if (vif->type == NL80211_IFTYPE_STATION)
 		hdr_trans->to_ds = true;
 	else
 		hdr_trans->from_ds = true;
 
-	if (!wcid)
-		return;
-
 	hdr_trans->dis_rx_hdr_tran = !test_bit(MT_WCID_FLAG_HDR_TRANS, &wcid->flags);
 	if (test_bit(MT_WCID_FLAG_4ADDR, &wcid->flags)) {
 		hdr_trans->to_ds = true;
@@ -1870,18 +2507,19 @@ int mt7996_mcu_set_fixed_rate_ctrl(struct mt7996_dev *dev,
 				     MCU_WM_UNI_CMD(RA), true);
 }
 
-int mt7996_mcu_set_fixed_field(struct mt7996_dev *dev, struct ieee80211_vif *vif,
-			       struct ieee80211_sta *sta, void *data, u32 field)
+int mt7996_mcu_set_fixed_field(struct mt7996_dev *dev,
+			       struct mt7996_bss_conf *mconf,
+			       struct ieee80211_link_sta *link_sta,
+			       struct mt7996_link_sta *mlink, void *data,
+			       u32 field)
 {
-	struct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;
-	struct mt7996_sta *msta = (struct mt7996_sta *)sta->drv_priv;
 	struct sta_phy_uni *phy = data;
 	struct sta_rec_ra_fixed_uni *ra;
 	struct sk_buff *skb;
 	struct tlv *tlv;
 
-	skb = __mt76_connac_mcu_alloc_sta_req(&dev->mt76, &mvif->deflink.mt76,
-					      &msta->wcid,
+	skb = __mt76_connac_mcu_alloc_sta_req(&dev->mt76, &mconf->mt76,
+					      &mlink->wcid,
 					      MT7996_STA_UPDATE_MAX_SIZE);
 	if (IS_ERR(skb))
 		return PTR_ERR(skb);
@@ -1900,7 +2538,7 @@ int mt7996_mcu_set_fixed_field(struct mt7996_dev *dev, struct ieee80211_vif *vif
 			ra->phy = *phy;
 		break;
 	case RATE_PARAM_MMPS_UPDATE:
-		ra->mmps_mode = mt7996_mcu_get_mmps_mode(sta->deflink.smps_mode);
+		ra->mmps_mode = mt7996_mcu_get_mmps_mode(link_sta->smps_mode);
 		break;
 	default:
 		break;
@@ -1912,12 +2550,14 @@ int mt7996_mcu_set_fixed_field(struct mt7996_dev *dev, struct ieee80211_vif *vif
 }
 
 static int
-mt7996_mcu_add_rate_ctrl_fixed(struct mt7996_dev *dev, struct ieee80211_vif *vif,
-			       struct ieee80211_sta *sta)
-{
-	struct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;
-	struct cfg80211_chan_def *chandef = &mvif->deflink.phy->mt76->chandef;
-	struct cfg80211_bitrate_mask *mask = &mvif->deflink.bitrate_mask;
+mt7996_mcu_add_rate_ctrl_fixed(struct mt7996_dev *dev,
+			       struct ieee80211_bss_conf *conf,
+			       struct mt7996_bss_conf *mconf,
+			       struct ieee80211_link_sta *link_sta,
+			       struct mt7996_link_sta *mlink)
+{
+	struct cfg80211_chan_def *chandef = &mconf->phy->mt76->chandef;
+	struct cfg80211_bitrate_mask *mask = &mconf->bitrate_mask;
 	enum nl80211_band band = chandef->chan->band;
 	struct sta_phy_uni phy = {};
 	int ret, nrates = 0;
@@ -1938,11 +2578,11 @@ mt7996_mcu_add_rate_ctrl_fixed(struct mt7996_dev *dev, struct ieee80211_vif *vif
 		}								\
 	} while (0)
 
-	if (sta->deflink.he_cap.has_he) {
+	if (link_sta->he_cap.has_he) {
 		__sta_phy_bitrate_mask_check(he_mcs, he_gi, 0, 1);
-	} else if (sta->deflink.vht_cap.vht_supported) {
+	} else if (link_sta->vht_cap.vht_supported) {
 		__sta_phy_bitrate_mask_check(vht_mcs, gi, 0, 0);
-	} else if (sta->deflink.ht_cap.ht_supported) {
+	} else if (link_sta->ht_cap.ht_supported) {
 		__sta_phy_bitrate_mask_check(ht_mcs, gi, 1, 0);
 	} else {
 		nrates = hweight32(mask->control[band].legacy);
@@ -1959,8 +2599,8 @@ mt7996_mcu_add_rate_ctrl_fixed(struct mt7996_dev *dev, struct ieee80211_vif *vif
 
 	/* fixed single rate */
 	if (nrates == 1) {
-		ret = mt7996_mcu_set_fixed_field(dev, vif, sta, &phy,
-						 RATE_PARAM_FIXED_MCS);
+		ret = mt7996_mcu_set_fixed_field(dev, mconf, link_sta, mlink,
+						 &phy, RATE_PARAM_FIXED_MCS);
 		if (ret)
 			return ret;
 	}
@@ -1968,29 +2608,28 @@ mt7996_mcu_add_rate_ctrl_fixed(struct mt7996_dev *dev, struct ieee80211_vif *vif
 	/* fixed GI */
 	if (mask->control[band].gi != NL80211_TXRATE_DEFAULT_GI ||
 	    mask->control[band].he_gi != GENMASK(7, 0)) {
-		struct mt7996_sta *msta = (struct mt7996_sta *)sta->drv_priv;
 		u32 addr;
 
 		/* firmware updates only TXCMD but doesn't take WTBL into
 		 * account, so driver should update here to reflect the
 		 * actual txrate hardware sends out.
 		 */
-		addr = mt7996_mac_wtbl_lmac_addr(dev, msta->wcid.idx, 7);
-		if (sta->deflink.he_cap.has_he)
+		addr = mt7996_mac_wtbl_lmac_addr(dev, mlink->wcid.idx, 7);
+		if (link_sta->he_cap.has_he)
 			mt76_rmw_field(dev, addr, GENMASK(31, 24), phy.sgi);
 		else
 			mt76_rmw_field(dev, addr, GENMASK(15, 12), phy.sgi);
 
-		ret = mt7996_mcu_set_fixed_field(dev, vif, sta, &phy,
-						 RATE_PARAM_FIXED_GI);
+		ret = mt7996_mcu_set_fixed_field(dev, mconf, link_sta, mlink,
+						 &phy, RATE_PARAM_FIXED_GI);
 		if (ret)
 			return ret;
 	}
 
 	/* fixed HE_LTF */
 	if (mask->control[band].he_ltf != GENMASK(7, 0)) {
-		ret = mt7996_mcu_set_fixed_field(dev, vif, sta, &phy,
-						 RATE_PARAM_FIXED_HE_LTF);
+		ret = mt7996_mcu_set_fixed_field(dev, mconf, link_sta, mlink,
+						 &phy, RATE_PARAM_FIXED_HE_LTF);
 		if (ret)
 			return ret;
 	}
@@ -2000,30 +2639,31 @@ mt7996_mcu_add_rate_ctrl_fixed(struct mt7996_dev *dev, struct ieee80211_vif *vif
 
 static void
 mt7996_mcu_sta_rate_ctrl_tlv(struct sk_buff *skb, struct mt7996_dev *dev,
-			     struct ieee80211_vif *vif, struct ieee80211_sta *sta)
+			     struct ieee80211_bss_conf *conf,
+			     struct mt7996_bss_conf *mconf,
+			     struct ieee80211_link_sta *link_sta)
 {
 #define INIT_RCPI 180
-	struct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;
-	struct mt76_phy *mphy = mvif->deflink.phy->mt76;
+	struct mt76_phy *mphy = mconf->phy->mt76;
 	struct cfg80211_chan_def *chandef = &mphy->chandef;
-	struct cfg80211_bitrate_mask *mask = &mvif->deflink.bitrate_mask;
+	struct cfg80211_bitrate_mask *mask = &mconf->bitrate_mask;
 	enum nl80211_band band = chandef->chan->band;
 	struct sta_rec_ra_uni *ra;
 	struct tlv *tlv;
-	u32 supp_rate = sta->deflink.supp_rates[band];
-	u32 cap = sta->wme ? STA_CAP_WMM : 0;
+	u32 supp_rate = link_sta->supp_rates[band];
+	u32 cap = link_sta->sta->wme ? STA_CAP_WMM : 0;
 
 	tlv = mt76_connac_mcu_add_tlv(skb, STA_REC_RA, sizeof(*ra));
 	ra = (struct sta_rec_ra_uni *)tlv;
 
 	ra->valid = true;
 	ra->auto_rate = true;
-	ra->phy_mode = mt76_connac_get_phy_mode(mphy, vif, band, &sta->deflink);
+	ra->phy_mode = mt76_connac_get_phy_mode(mphy, conf->vif, band, link_sta);
 	ra->channel = chandef->chan->hw_value;
-	ra->bw = (sta->deflink.bandwidth == IEEE80211_STA_RX_BW_320) ?
-		 CMD_CBW_320MHZ : sta->deflink.bandwidth;
+	ra->bw = (link_sta->bandwidth == IEEE80211_STA_RX_BW_320) ?
+		 CMD_CBW_320MHZ : link_sta->bandwidth;
 	ra->phy.bw = ra->bw;
-	ra->mmps_mode = mt7996_mcu_get_mmps_mode(sta->deflink.smps_mode);
+	ra->mmps_mode = mt7996_mcu_get_mmps_mode(link_sta->smps_mode);
 
 	if (supp_rate) {
 		supp_rate &= mask->control[band].legacy;
@@ -2043,60 +2683,60 @@ mt7996_mcu_sta_rate_ctrl_tlv(struct sk_buff *skb, struct mt7996_dev *dev,
 		}
 	}
 
-	if (sta->deflink.ht_cap.ht_supported) {
+	if (link_sta->ht_cap.ht_supported) {
 		ra->supp_mode |= MODE_HT;
-		ra->af = sta->deflink.ht_cap.ampdu_factor;
-		ra->ht_gf = !!(sta->deflink.ht_cap.cap & IEEE80211_HT_CAP_GRN_FLD);
+		ra->af = link_sta->ht_cap.ampdu_factor;
+		ra->ht_gf = !!(link_sta->ht_cap.cap & IEEE80211_HT_CAP_GRN_FLD);
 
 		cap |= STA_CAP_HT;
-		if (sta->deflink.ht_cap.cap & IEEE80211_HT_CAP_SGI_20)
+		if (link_sta->ht_cap.cap & IEEE80211_HT_CAP_SGI_20)
 			cap |= STA_CAP_SGI_20;
-		if (sta->deflink.ht_cap.cap & IEEE80211_HT_CAP_SGI_40)
+		if (link_sta->ht_cap.cap & IEEE80211_HT_CAP_SGI_40)
 			cap |= STA_CAP_SGI_40;
-		if (sta->deflink.ht_cap.cap & IEEE80211_HT_CAP_TX_STBC)
+		if (link_sta->ht_cap.cap & IEEE80211_HT_CAP_TX_STBC)
 			cap |= STA_CAP_TX_STBC;
-		if (sta->deflink.ht_cap.cap & IEEE80211_HT_CAP_RX_STBC)
+		if (link_sta->ht_cap.cap & IEEE80211_HT_CAP_RX_STBC)
 			cap |= STA_CAP_RX_STBC;
-		if (vif->bss_conf.ht_ldpc &&
-		    (sta->deflink.ht_cap.cap & IEEE80211_HT_CAP_LDPC_CODING))
+		if (conf->ht_ldpc &&
+		    (link_sta->ht_cap.cap & IEEE80211_HT_CAP_LDPC_CODING))
 			cap |= STA_CAP_LDPC;
 
-		mt7996_mcu_set_sta_ht_mcs(sta, ra->ht_mcs,
+		mt7996_mcu_set_sta_ht_mcs(link_sta, ra->ht_mcs,
 					  mask->control[band].ht_mcs);
 		ra->supp_ht_mcs = *(__le32 *)ra->ht_mcs;
 	}
 
-	if (sta->deflink.vht_cap.vht_supported) {
+	if (link_sta->vht_cap.vht_supported) {
 		u8 af;
 
 		ra->supp_mode |= MODE_VHT;
 		af = FIELD_GET(IEEE80211_VHT_CAP_MAX_A_MPDU_LENGTH_EXPONENT_MASK,
-			       sta->deflink.vht_cap.cap);
+			       link_sta->vht_cap.cap);
 		ra->af = max_t(u8, ra->af, af);
 
 		cap |= STA_CAP_VHT;
-		if (sta->deflink.vht_cap.cap & IEEE80211_VHT_CAP_SHORT_GI_80)
+		if (link_sta->vht_cap.cap & IEEE80211_VHT_CAP_SHORT_GI_80)
 			cap |= STA_CAP_VHT_SGI_80;
-		if (sta->deflink.vht_cap.cap & IEEE80211_VHT_CAP_SHORT_GI_160)
+		if (link_sta->vht_cap.cap & IEEE80211_VHT_CAP_SHORT_GI_160)
 			cap |= STA_CAP_VHT_SGI_160;
-		if (sta->deflink.vht_cap.cap & IEEE80211_VHT_CAP_TXSTBC)
+		if (link_sta->vht_cap.cap & IEEE80211_VHT_CAP_TXSTBC)
 			cap |= STA_CAP_VHT_TX_STBC;
-		if (sta->deflink.vht_cap.cap & IEEE80211_VHT_CAP_RXSTBC_1)
+		if (link_sta->vht_cap.cap & IEEE80211_VHT_CAP_RXSTBC_1)
 			cap |= STA_CAP_VHT_RX_STBC;
-		if ((vif->type != NL80211_IFTYPE_AP || vif->bss_conf.vht_ldpc) &&
-		    (sta->deflink.vht_cap.cap & IEEE80211_VHT_CAP_RXLDPC))
+		if ((conf->vif->type != NL80211_IFTYPE_AP || conf->vht_ldpc) &&
+		    (link_sta->vht_cap.cap & IEEE80211_VHT_CAP_RXLDPC))
 			cap |= STA_CAP_VHT_LDPC;
 
-		mt7996_mcu_set_sta_vht_mcs(sta, ra->supp_vht_mcs,
+		mt7996_mcu_set_sta_vht_mcs(link_sta, ra->supp_vht_mcs,
 					   mask->control[band].vht_mcs);
 	}
 
-	if (sta->deflink.he_cap.has_he) {
+	if (link_sta->he_cap.has_he) {
 		ra->supp_mode |= MODE_HE;
 		cap |= STA_CAP_HE;
 
-		if (sta->deflink.he_6ghz_capa.capa)
-			ra->af = le16_get_bits(sta->deflink.he_6ghz_capa.capa,
+		if (link_sta->he_6ghz_capa.capa)
+			ra->af = le16_get_bits(link_sta->he_6ghz_capa.capa,
 					       IEEE80211_HE_6GHZ_CAP_MAX_AMPDU_LEN_EXP);
 	}
 	ra->sta_cap = cpu_to_le32(cap);
@@ -2104,16 +2744,17 @@ mt7996_mcu_sta_rate_ctrl_tlv(struct sk_buff *skb, struct mt7996_dev *dev,
 	memset(ra->rx_rcpi, INIT_RCPI, sizeof(ra->rx_rcpi));
 }
 
-int mt7996_mcu_add_rate_ctrl(struct mt7996_dev *dev, struct ieee80211_vif *vif,
-			     struct ieee80211_sta *sta, bool changed)
+int mt7996_mcu_add_rate_ctrl(struct mt7996_dev *dev,
+			     struct ieee80211_bss_conf *conf,
+			     struct mt7996_bss_conf *mconf,
+			     struct ieee80211_link_sta *link_sta,
+			     struct mt7996_link_sta *mlink, bool changed)
 {
-	struct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;
-	struct mt7996_sta *msta = (struct mt7996_sta *)sta->drv_priv;
 	struct sk_buff *skb;
 	int ret;
 
-	skb = __mt76_connac_mcu_alloc_sta_req(&dev->mt76, &mvif->deflink.mt76,
-					      &msta->wcid,
+	skb = __mt76_connac_mcu_alloc_sta_req(&dev->mt76, &mconf->mt76,
+					      &mlink->wcid,
 					      MT7996_STA_UPDATE_MAX_SIZE);
 	if (IS_ERR(skb))
 		return PTR_ERR(skb);
@@ -2123,121 +2764,247 @@ int mt7996_mcu_add_rate_ctrl(struct mt7996_dev *dev, struct ieee80211_vif *vif,
 	 * update sta_rec_he here.
 	 */
 	if (changed)
-		mt7996_mcu_sta_he_tlv(skb, sta);
+		mt7996_mcu_sta_he_tlv(skb, conf, mconf, link_sta);
 
 	/* sta_rec_ra accommodates BW, NSS and only MCS range format
 	 * i.e 0-{7,8,9} for VHT.
 	 */
-	mt7996_mcu_sta_rate_ctrl_tlv(skb, dev, vif, sta);
+	mt7996_mcu_sta_rate_ctrl_tlv(skb, dev, conf, mconf, link_sta);
 
 	ret = mt76_mcu_skb_send_msg(&dev->mt76, skb,
 				    MCU_WMWA_UNI_CMD(STA_REC_UPDATE), true);
 	if (ret)
 		return ret;
 
-	return mt7996_mcu_add_rate_ctrl_fixed(dev, vif, sta);
+	return mt7996_mcu_add_rate_ctrl_fixed(dev, conf, mconf, link_sta, mlink);
 }
 
+#if 0
 static int
-mt7996_mcu_add_group(struct mt7996_dev *dev, struct ieee80211_vif *vif,
-		     struct ieee80211_sta *sta)
+mt7996_mcu_sta_init_vow(struct mt7996_bss_conf *mconf,
+			struct mt7996_link_sta *mlink)
 {
-#define MT_STA_BSS_GROUP		1
-	struct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;
-	struct mt7996_sta *msta;
-	struct {
-		u8 __rsv1[4];
+	struct mt7996_phy *phy = mconf->phy;
+	struct mt7996_vow_sta_ctrl *vow = &mlink->vow;
+	u8 omac_idx = mconf->mt76.omac_idx;
+	int ret;
 
-		__le16 tag;
-		__le16 len;
-		__le16 wlan_idx;
-		u8 __rsv2[2];
-		__le32 action;
-		__le32 val;
-		u8 __rsv3[8];
-	} __packed req = {
-		.tag = cpu_to_le16(UNI_VOW_DRR_CTRL),
-		.len = cpu_to_le16(sizeof(req) - 4),
-		.action = cpu_to_le32(MT_STA_BSS_GROUP),
-		.val = cpu_to_le32(mvif->deflink.mt76.idx % 16),
-	};
+	/* Assignment of STA BSS group index aligns FW.
+	 * Each band has its own BSS group bitmap space.
+	 * 0: BSS 0
+	 * 4..18: BSS 0x11..0x1f
+	 */
+	vow->bss_grp_idx = (omac_idx <= HW_BSSID_MAX)
+	                   ? omac_idx
+	                   : HW_BSSID_MAX + omac_idx - EXT_BSSID_START;
+	vow->paused = false;
+	vow->drr_quantum[IEEE80211_AC_VO] = VOW_DRR_QUANTUM_IDX0;
+	vow->drr_quantum[IEEE80211_AC_VI] = VOW_DRR_QUANTUM_IDX1;
+	vow->drr_quantum[IEEE80211_AC_BE] = VOW_DRR_QUANTUM_IDX2;
+	vow->drr_quantum[IEEE80211_AC_BK] = VOW_DRR_QUANTUM_IDX2;
+
+	ret = mt7996_mcu_set_vow_drr_ctrl(phy, mconf, mlink, VOW_DRR_CTRL_STA_BSS_GROUP);
+	if (ret)
+		return ret;
 
-	msta = sta ? (struct mt7996_sta *)sta->drv_priv : &mvif->deflink.sta;
-	req.wlan_idx = cpu_to_le16(msta->wcid.idx);
+	ret = mt7996_mcu_set_vow_drr_ctrl(phy, mconf, mlink, VOW_DRR_CTRL_STA_PAUSE);
+	if (ret)
+		return ret;
 
-	return mt76_mcu_send_msg(&dev->mt76, MCU_WM_UNI_CMD(VOW), &req,
-				 sizeof(req), true);
+	return mt7996_mcu_set_vow_drr_ctrl(phy, mconf, mlink, VOW_DRR_CTRL_STA_ALL);
 }
+#endif
 
-int mt7996_mcu_add_sta(struct mt7996_dev *dev, struct ieee80211_vif *vif,
-		       struct mt76_vif_link *mlink,
-		       struct ieee80211_sta *sta, int conn_state, bool newly)
+int mt7996_mcu_add_sta(struct mt7996_dev *dev, struct ieee80211_bss_conf *conf,
+		       struct mt7996_bss_conf *mconf,
+		       struct ieee80211_link_sta *link_sta,
+		       struct mt7996_link_sta *mlink, bool enable, bool newly)
 {
-	struct ieee80211_link_sta *link_sta = NULL;
-	struct mt76_wcid *wcid = mlink->wcid;
+	struct ieee80211_vif *vif = conf->vif;
 	struct sk_buff *skb;
-	int ret;
-
-	if (sta) {
-		struct mt7996_sta *msta = (struct mt7996_sta *)sta->drv_priv;
-
-		wcid = &msta->wcid;
-		link_sta = &sta->deflink;
-	}
+	int conn_state;
+	// int ret;
 
-	skb = __mt76_connac_mcu_alloc_sta_req(&dev->mt76, mlink, wcid,
+	skb = __mt76_connac_mcu_alloc_sta_req(&dev->mt76, &mconf->mt76,
+					      &mlink->wcid,
 					      MT7996_STA_UPDATE_MAX_SIZE);
 	if (IS_ERR(skb))
 		return PTR_ERR(skb);
 
 	/* starec basic */
-	mt76_connac_mcu_sta_basic_tlv(&dev->mt76, skb, &vif->bss_conf, link_sta,
+	conn_state = enable ? CONN_STATE_PORT_SECURE : CONN_STATE_DISCONNECT;
+	mt76_connac_mcu_sta_basic_tlv(&dev->mt76, skb, conf, link_sta,
 				      conn_state, newly);
+	mlo_dbg(mconf->phy, "link=%u, newly=%d, conn_state=%d\n",
+		mlink->wcid.link_id, newly, conn_state);
 
-	if (conn_state == CONN_STATE_DISCONNECT)
+	if (!enable)
 		goto out;
 
 	/* starec hdr trans */
-	mt7996_mcu_sta_hdr_trans_tlv(dev, skb, vif, wcid);
+	mt7996_mcu_sta_hdr_trans_tlv(dev, skb, vif, mlink);
 	/* starec tx proc */
 	mt7996_mcu_sta_tx_proc_tlv(skb);
 
 	/* tag order is in accordance with firmware dependency. */
-	if (sta) {
+	if (link_sta) {
 		/* starec hdrt mode */
 		mt7996_mcu_sta_hdrt_tlv(dev, skb);
 		/* starec bfer */
-		mt7996_mcu_sta_bfer_tlv(dev, skb, vif, sta);
+		mt7996_mcu_sta_bfer_tlv(dev, skb, conf, mconf, link_sta);
 		/* starec ht */
-		mt7996_mcu_sta_ht_tlv(skb, sta);
+		mt7996_mcu_sta_ht_tlv(skb, link_sta);
 		/* starec vht */
-		mt7996_mcu_sta_vht_tlv(skb, sta);
+		mt7996_mcu_sta_vht_tlv(skb, link_sta);
 		/* starec uapsd */
-		mt76_connac_mcu_sta_uapsd(skb, vif, sta);
+		mt76_connac_mcu_sta_uapsd(skb, vif, link_sta->sta);
 		/* starec amsdu */
-		mt7996_mcu_sta_amsdu_tlv(dev, skb, vif, sta);
+		mt7996_mcu_sta_amsdu_tlv(dev, skb, vif, link_sta, mlink);
 		/* starec he */
-		mt7996_mcu_sta_he_tlv(skb, sta);
+		mt7996_mcu_sta_he_tlv(skb, conf, mconf, link_sta);
 		/* starec he 6g*/
-		mt7996_mcu_sta_he_6g_tlv(skb, sta);
+		mt7996_mcu_sta_he_6g_tlv(skb, link_sta);
 		/* starec eht */
-		mt7996_mcu_sta_eht_tlv(skb, sta);
+		mt7996_mcu_sta_eht_tlv(skb, link_sta);
 		/* starec muru */
-		mt7996_mcu_sta_muru_tlv(dev, skb, vif, sta);
+		mt7996_mcu_sta_muru_tlv(dev, skb, conf, mconf, link_sta);
 		/* starec bfee */
-		mt7996_mcu_sta_bfee_tlv(dev, skb, vif, sta);
+		mt7996_mcu_sta_bfee_tlv(dev, skb, conf, mconf, link_sta);
 	}
 
-	ret = mt7996_mcu_add_group(dev, vif, sta);
+#if 0
+	ret = mt7996_mcu_sta_init_vow(mconf, mlink);
 	if (ret) {
 		dev_kfree_skb(skb);
 		return ret;
 	}
+#endif
 out:
 	return mt76_mcu_skb_send_msg(&dev->mt76, skb,
 				     MCU_WMWA_UNI_CMD(STA_REC_UPDATE), true);
 }
 
+static void
+mt7996_mcu_sta_mld_setup_tlv(struct mt7996_dev *dev, struct sk_buff *skb,
+			     struct ieee80211_sta *sta)
+{
+	struct mt7996_sta *msta = (struct mt7996_sta *)sta->drv_priv;
+	struct sta_rec_mld_setup *mld_setup;
+	struct mld_setup_link *mld_setup_link;
+	struct mt7996_link_sta *mlink;
+	struct mt7996_bss_conf *mconf;
+	struct tlv *tlv;
+	unsigned long valid_links = sta->valid_links;
+	unsigned int link_id;
+
+	mlink = mlink_dereference_protected(msta, msta->pri_link);
+	if (!mlink)
+		return;
+
+	tlv = mt76_connac_mcu_add_tlv(skb, STA_REC_MLD,
+				      sizeof(*mld_setup) +
+				      sizeof(struct mld_setup_link) *
+					     hweight16(sta->valid_links));
+
+	mld_setup = (struct sta_rec_mld_setup *)tlv;
+	memcpy(mld_setup->mld_addr, sta->addr, ETH_ALEN);
+	mld_setup->setup_wcid = cpu_to_le16(mlink->wcid.idx);
+	mld_setup->primary_id = cpu_to_le16(mlink->wcid.idx);
+	if (msta->sec_link != msta->pri_link) {
+		mlink = mlink_dereference_protected(msta, msta->sec_link);
+		if (!mlink)
+			return;
+	}
+	mld_setup->seconed_id = cpu_to_le16(mlink->wcid.idx);
+	mld_setup->link_num = hweight16(sta->valid_links);
+
+	mld_setup_link = (struct mld_setup_link *)mld_setup->link_info;
+	mlo_dbg(mt7996_hw_phy(mlink->sta->vif->hw), "pri_link(%u) primary_id(%d) seconed_id(%d) wcid(%d), link_num(%d), mld_addr[%pM]\n",
+		msta->pri_link, mld_setup->primary_id, mld_setup->seconed_id, mld_setup->setup_wcid, mld_setup->link_num, mld_setup->mld_addr);
+	for_each_set_bit(link_id, &valid_links, IEEE80211_MLD_MAX_NUM_LINKS) {
+		mlink = mlink_dereference_protected(msta, link_id);
+		mconf = mconf_dereference_protected(msta->vif, link_id);
+
+		mld_setup_link->wcid = cpu_to_le16(mlink->wcid.idx);
+		mld_setup_link->bss_idx = mconf->mt76.idx;
+		mlo_dbg(mt7996_hw_phy(mlink->sta->vif->hw), "link_id(%d) wcid(%d) bss_idx(%d)\n",
+		link_id, mld_setup_link->wcid, mld_setup_link->bss_idx);
+		mld_setup_link++;
+	}
+}
+
+static void
+mt7996_mcu_sta_eht_mld_tlv(struct mt7996_dev *dev, struct sk_buff *skb,
+			   struct ieee80211_sta *sta)
+{
+	struct sta_rec_eht_mld *eht_mld;
+	struct tlv *tlv;
+	int i;
+
+	tlv = mt76_connac_mcu_add_tlv(skb, STA_REC_EHT_MLD, sizeof(*eht_mld));
+	eht_mld = (struct sta_rec_eht_mld *)tlv;
+
+	for (i = 0; i < ARRAY_SIZE(eht_mld->str_cap); i++)
+		eht_mld->str_cap[i] = 0x7;
+	/* TODO:
+	eht_mld->nsep = ;
+	eht_mld->eml_cap = cpu_to_le16()
+	*/
+}
+
+int mt7996_mcu_add_mld_sta(struct mt7996_dev *dev, struct ieee80211_vif *vif,
+			   struct ieee80211_sta *sta, unsigned long add)
+{
+	struct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;
+	struct mt7996_sta *msta = (struct mt7996_sta *)sta->drv_priv;
+	unsigned int link_id;
+
+	if (!sta->mlo)
+		return 0;
+
+	for_each_set_bit(link_id, &add, IEEE80211_MLD_MAX_NUM_LINKS) {
+		struct mt7996_bss_conf *mconf =
+			mconf_dereference_protected(mvif, link_id);
+		struct mt7996_link_sta *mlink =
+			mlink_dereference_protected(msta, link_id);
+		struct sk_buff *skb;
+		int ret;
+
+		skb = __mt76_connac_mcu_alloc_sta_req(&dev->mt76, &mconf->mt76,
+						      &mlink->wcid,
+						      MT7996_STA_UPDATE_MAX_SIZE);
+		if (IS_ERR(skb))
+			return PTR_ERR(skb);
+		/* starec mld setup */
+		mt7996_mcu_sta_mld_setup_tlv(dev, skb, sta);
+		/* starec eht mld */
+		mt7996_mcu_sta_eht_mld_tlv(dev, skb, sta);
+		ret = mt76_mcu_skb_send_msg(&dev->mt76, skb,
+					    MCU_WMWA_UNI_CMD(STA_REC_UPDATE), true);
+		if (ret)
+			return ret;
+	}
+	return 0;
+}
+int mt7996_mcu_teardown_mld_sta(struct mt7996_dev *dev,
+				struct mt7996_bss_conf *mconf,
+				struct mt7996_link_sta *mlink)
+{
+	struct sk_buff *skb;
+
+	skb = __mt76_connac_mcu_alloc_sta_req(&dev->mt76,
+					      &mconf->mt76,
+					      &mlink->wcid,
+					      MT7996_STA_UPDATE_MAX_SIZE);
+	if (IS_ERR(skb))
+		return PTR_ERR(skb);
+
+	mt76_connac_mcu_add_tlv(skb, STA_REC_MLD_OFF, sizeof(struct tlv));
+
+	return mt76_mcu_skb_send_msg(&dev->mt76, skb,
+				     MCU_WMWA_UNI_CMD(STA_REC_UPDATE), true);
+}
+
 static int
 mt7996_mcu_sta_key_tlv(struct mt76_wcid *wcid,
 		       struct sk_buff *skb,
@@ -2283,16 +3050,15 @@ mt7996_mcu_sta_key_tlv(struct mt76_wcid *wcid,
 	return 0;
 }
 
-int mt7996_mcu_add_key(struct mt76_dev *dev, struct ieee80211_vif *vif,
+int mt7996_mcu_add_key(struct mt76_dev *dev, struct mt7996_bss_conf *mconf,
 		       struct ieee80211_key_conf *key, int mcu_cmd,
 		       struct mt76_wcid *wcid, enum set_key_cmd cmd)
 {
-	struct mt76_vif_link *mvif = (struct mt76_vif_link *)vif->drv_priv;
 	struct sk_buff *skb;
 	int ret;
 
-	skb = __mt76_connac_mcu_alloc_sta_req(dev, mvif, wcid,
-					      MT7996_STA_UPDATE_MAX_SIZE);
+	skb = __mt76_connac_mcu_alloc_sta_req(dev, (struct mt76_vif *)mconf,
+					      wcid, MT7996_STA_UPDATE_MAX_SIZE);
 	if (IS_ERR(skb))
 		return PTR_ERR(skb);
 
@@ -2303,17 +3069,18 @@ int mt7996_mcu_add_key(struct mt76_dev *dev, struct ieee80211_vif *vif,
 	return mt76_mcu_skb_send_msg(dev, skb, mcu_cmd, true);
 }
 
-static int mt7996_mcu_get_pn(struct mt7996_dev *dev, struct ieee80211_vif *vif,
-			     u8 *pn)
+static int mt7996_mcu_get_pn(struct mt7996_dev *dev,
+			     struct ieee80211_bss_conf *conf,
+			     struct mt7996_bss_conf *mconf,
+			     struct mt7996_link_sta *mlink, u8 *pn)
 {
 #define TSC_TYPE_BIGTK_PN 2
-	struct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;
 	struct sta_rec_pn_info *pn_info;
 	struct sk_buff *skb, *rskb;
 	struct tlv *tlv;
 	int ret;
 
-	skb = mt76_connac_mcu_alloc_sta_req(&dev->mt76, &mvif->deflink.mt76, &mvif->deflink.sta.wcid);
+	skb = mt76_connac_mcu_alloc_sta_req(&dev->mt76, &mconf->mt76, &mlink->wcid);
 	if (IS_ERR(skb))
 		return PTR_ERR(skb);
 
@@ -2337,10 +3104,12 @@ static int mt7996_mcu_get_pn(struct mt7996_dev *dev, struct ieee80211_vif *vif,
 	return 0;
 }
 
-int mt7996_mcu_bcn_prot_enable(struct mt7996_dev *dev, struct ieee80211_vif *vif,
+int mt7996_mcu_bcn_prot_enable(struct mt7996_dev *dev,
+			       struct ieee80211_bss_conf *conf,
+			       struct mt7996_bss_conf *mconf,
+			       struct mt7996_link_sta *mlink,
 			       struct ieee80211_key_conf *key)
 {
-	struct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;
 	struct mt7996_mcu_bcn_prot_tlv *bcn_prot;
 	struct sk_buff *skb;
 	struct tlv *tlv;
@@ -2349,7 +3118,7 @@ int mt7996_mcu_bcn_prot_enable(struct mt7996_dev *dev, struct ieee80211_vif *vif
 		  sizeof(struct mt7996_mcu_bcn_prot_tlv);
 	int ret;
 
-	skb = __mt7996_mcu_alloc_bss_req(&dev->mt76, &mvif->deflink.mt76, len);
+	skb = __mt7996_mcu_alloc_bss_req(&dev->mt76, &mconf->mt76, len);
 	if (IS_ERR(skb))
 		return PTR_ERR(skb);
 
@@ -2357,7 +3126,7 @@ int mt7996_mcu_bcn_prot_enable(struct mt7996_dev *dev, struct ieee80211_vif *vif
 
 	bcn_prot = (struct mt7996_mcu_bcn_prot_tlv *)tlv;
 
-	ret = mt7996_mcu_get_pn(dev, vif, pn);
+	ret = mt7996_mcu_get_pn(dev, conf, mconf, mlink, pn);
 	if (ret) {
 		dev_kfree_skb(skb);
 		return ret;
@@ -2389,10 +3158,9 @@ int mt7996_mcu_bcn_prot_enable(struct mt7996_dev *dev, struct ieee80211_vif *vif
 	return mt76_mcu_skb_send_msg(&dev->mt76, skb,
 				     MCU_WMWA_UNI_CMD(BSS_INFO_UPDATE), true);
 }
-
-int mt7996_mcu_add_dev_info(struct mt7996_phy *phy, struct ieee80211_vif *vif,
-			    struct ieee80211_bss_conf *link_conf,
-			    struct mt76_vif_link *mlink, bool enable)
+int mt7996_mcu_add_dev_info(struct mt7996_phy *phy,
+			    struct ieee80211_bss_conf *conf,
+			    struct mt7996_bss_conf *mconf, bool enable)
 {
 	struct mt7996_dev *dev = phy->dev;
 	struct {
@@ -2410,8 +3178,8 @@ int mt7996_mcu_add_dev_info(struct mt7996_phy *phy, struct ieee80211_vif *vif,
 		} __packed tlv;
 	} data = {
 		.hdr = {
-			.omac_idx = mlink->omac_idx,
-			.band_idx = mlink->band_idx,
+			.omac_idx = mconf->mt76.omac_idx,
+			.band_idx = mconf->mt76.band_idx,
 		},
 		.tlv = {
 			.tag = cpu_to_le16(DEV_INFO_ACTIVE),
@@ -2420,18 +3188,20 @@ int mt7996_mcu_add_dev_info(struct mt7996_phy *phy, struct ieee80211_vif *vif,
 		},
 	};
 
-	if (mlink->omac_idx >= REPEATER_BSSID_START)
-		return mt7996_mcu_muar_config(dev, mlink, link_conf->addr, false, enable);
+	if (mconf->mt76.omac_idx >= REPEATER_BSSID_START)
+		return mt7996_mcu_muar_config(phy, conf, mconf, false, enable);
 
-	memcpy(data.tlv.omac_addr, link_conf->addr, ETH_ALEN);
+	memcpy(data.tlv.omac_addr, conf->addr, ETH_ALEN);
+	mlo_dbg(phy, "omac=%u, band=%u, addr=%pM, en=%d\n",
+		data.hdr.omac_idx,data.hdr.band_idx, data.tlv.omac_addr, enable);
 	return mt76_mcu_send_msg(&dev->mt76, MCU_WMWA_UNI_CMD(DEV_INFO_UPDATE),
 				 &data, sizeof(data), true);
 }
 
 static void
-mt7996_mcu_beacon_cntdwn(struct sk_buff *rskb, struct sk_buff *skb,
-			 struct ieee80211_mutable_offsets *offs,
-			 bool csa)
+mt7996_mcu_beacon_cntdwn(struct ieee80211_bss_conf *conf, struct sk_buff *rskb,
+			 struct sk_buff *skb,
+			 struct ieee80211_mutable_offsets *offs)
 {
 	struct bss_bcn_cntdwn_tlv *info;
 	struct tlv *tlv;
@@ -2440,7 +3210,7 @@ mt7996_mcu_beacon_cntdwn(struct sk_buff *rskb, struct sk_buff *skb,
 	if (!offs->cntdwn_counter_offs[0])
 		return;
 
-	tag = csa ? UNI_BSS_INFO_BCN_CSA : UNI_BSS_INFO_BCN_BCC;
+	tag = conf->csa_active ? UNI_BSS_INFO_BCN_CSA : UNI_BSS_INFO_BCN_BCC;
 
 	tlv = mt7996_mcu_add_uni_tlv(rskb, tag, sizeof(*info));
 
@@ -2450,6 +3220,7 @@ mt7996_mcu_beacon_cntdwn(struct sk_buff *rskb, struct sk_buff *skb,
 
 static void
 mt7996_mcu_beacon_mbss(struct sk_buff *rskb, struct sk_buff *skb,
+		       struct ieee80211_bss_conf *conf,
 		       struct bss_bcn_content_tlv *bcn,
 		       struct ieee80211_mutable_offsets *offs)
 {
@@ -2457,6 +3228,9 @@ mt7996_mcu_beacon_mbss(struct sk_buff *rskb, struct sk_buff *skb,
 	const struct element *elem;
 	struct tlv *tlv;
 
+	if (!conf->bssid_indicator)
+		return;
+
 	tlv = mt7996_mcu_add_uni_tlv(rskb, UNI_BSS_INFO_BCN_MBSSID, sizeof(*mbss));
 
 	mbss = (struct bss_bcn_mbss_tlv *)tlv;
@@ -2499,8 +3273,7 @@ mt7996_mcu_beacon_mbss(struct sk_buff *rskb, struct sk_buff *skb,
 }
 
 static void
-mt7996_mcu_beacon_cont(struct mt7996_dev *dev,
-		       struct ieee80211_bss_conf *link_conf,
+mt7996_mcu_beacon_cont(struct mt7996_dev *dev, struct ieee80211_bss_conf *conf,
 		       struct sk_buff *rskb, struct sk_buff *skb,
 		       struct bss_bcn_content_tlv *bcn,
 		       struct ieee80211_mutable_offsets *offs)
@@ -2514,9 +3287,9 @@ mt7996_mcu_beacon_cont(struct mt7996_dev *dev,
 	if (offs->cntdwn_counter_offs[0]) {
 		u16 offset = offs->cntdwn_counter_offs[0];
 
-		if (link_conf->csa_active)
+		if (conf->csa_active)
 			bcn->csa_ie_pos = cpu_to_le16(offset - 4);
-		if (link_conf->color_change_active)
+		if (conf->color_change_active)
 			bcn->bcc_ie_pos = cpu_to_le16(offset - 3);
 	}
 
@@ -2525,13 +3298,19 @@ mt7996_mcu_beacon_cont(struct mt7996_dev *dev,
 			      BSS_CHANGED_BEACON);
 
 	memcpy(buf + MT_TXD_SIZE, skb->data, skb->len);
+
+	if (dev->dbg.dump_txd)
+		mt7996_packet_log_to_host(dev, (__le32 *)buf, MT_TXD_SIZE, PKT_BIN_DEBUG_TXD, 0);
+	if (dev->dbg.dump_tx_pkt)
+		mt7996_packet_log_to_host(dev, skb->data, skb->len, PKT_BIN_DEBUG_TX, 0);
 }
 
-int mt7996_mcu_add_beacon(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
-			  struct ieee80211_bss_conf *link_conf)
+int mt7996_mcu_add_beacon(struct ieee80211_hw *hw,
+			  struct ieee80211_bss_conf *conf,
+			  struct mt7996_bss_conf *mconf, int en)
 {
 	struct mt7996_dev *dev = mt7996_hw_dev(hw);
-	struct mt76_vif_link *mlink = mt76_vif_conf_link(&dev->mt76, vif, link_conf);
+	struct mt7996_phy *phy = mconf->phy;
 	struct ieee80211_mutable_offsets offs;
 	struct ieee80211_tx_info *info;
 	struct sk_buff *skb, *rskb;
@@ -2539,19 +3318,16 @@ int mt7996_mcu_add_beacon(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 	struct bss_bcn_content_tlv *bcn;
 	int len, extra_len = 0;
 
-	if (link_conf->nontransmitted)
+	if (conf->nontransmitted)
 		return 0;
 
-	if (!mlink)
-		return -EINVAL;
-
-	rskb = __mt7996_mcu_alloc_bss_req(&dev->mt76, mlink,
+	rskb = __mt7996_mcu_alloc_bss_req(&dev->mt76, &mconf->mt76,
 					  MT7996_MAX_BSS_OFFLOAD_SIZE);
 	if (IS_ERR(rskb))
 		return PTR_ERR(rskb);
 
-	skb = ieee80211_beacon_get_template(hw, vif, &offs, link_conf->link_id);
-	if (link_conf->enable_beacon && !skb) {
+	skb = ieee80211_beacon_get_template(hw, conf->vif, &offs, conf->link_id);
+	if (en && !skb) {
 		dev_kfree_skb(rskb);
 		return -EINVAL;
 	}
@@ -2570,62 +3346,55 @@ int mt7996_mcu_add_beacon(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 	len = ALIGN(sizeof(*bcn) + MT_TXD_SIZE + extra_len, 4);
 	tlv = mt7996_mcu_add_uni_tlv(rskb, UNI_BSS_INFO_BCN_CONTENT, len);
 	bcn = (struct bss_bcn_content_tlv *)tlv;
-	bcn->enable = link_conf->enable_beacon;
-	if (!bcn->enable)
+	bcn->enable = en;
+	if (!en)
 		goto out;
 
 	info = IEEE80211_SKB_CB(skb);
-	info->hw_queue |= FIELD_PREP(MT_TX_HW_QUEUE_PHY, mlink->band_idx);
+	info->hw_queue |= FIELD_PREP(MT_TX_HW_QUEUE_PHY, phy->mt76->band_idx);
 
-	mt7996_mcu_beacon_cont(dev, link_conf, rskb, skb, bcn, &offs);
-	if (link_conf->bssid_indicator)
-		mt7996_mcu_beacon_mbss(rskb, skb, bcn, &offs);
-	mt7996_mcu_beacon_cntdwn(rskb, skb, &offs, link_conf->csa_active);
+	mt7996_mcu_beacon_cont(dev, conf, rskb, skb, bcn, &offs);
+	mt7996_mcu_beacon_mbss(rskb, skb, conf, bcn, &offs);
+	mt7996_mcu_beacon_cntdwn(conf, rskb, skb, &offs);
 out:
 	dev_kfree_skb(skb);
-	return mt76_mcu_skb_send_msg(&dev->mt76, rskb,
+	return mt76_mcu_skb_send_msg(&phy->dev->mt76, rskb,
 				     MCU_WMWA_UNI_CMD(BSS_INFO_UPDATE), true);
 }
 
 int mt7996_mcu_beacon_inband_discov(struct mt7996_dev *dev,
-				    struct ieee80211_vif *vif, u32 changed)
+				    struct ieee80211_bss_conf *conf,
+				    struct mt7996_bss_conf *mconf, u32 changed)
 {
 #define OFFLOAD_TX_MODE_SU	BIT(0)
 #define OFFLOAD_TX_MODE_MU	BIT(1)
+	struct ieee80211_vif *vif = conf->vif;
 	struct ieee80211_hw *hw = mt76_hw(dev);
-	struct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;
-	struct mt7996_phy *phy = mt7996_vif_link_phy(&mvif->deflink);
+	struct mt7996_phy *phy = mconf->phy;
+	struct cfg80211_chan_def *chandef = &mconf->phy->mt76->chandef;
+	enum nl80211_band band = chandef->chan->band;
 	struct mt76_wcid *wcid = &dev->mt76.global_wcid;
 	struct bss_inband_discovery_tlv *discov;
 	struct ieee80211_tx_info *info;
 	struct sk_buff *rskb, *skb = NULL;
-	struct cfg80211_chan_def *chandef;
-	enum nl80211_band band;
 	struct tlv *tlv;
 	u8 *buf, interval;
 	int len;
 
-	if (!phy)
-		return -EINVAL;
-
-	chandef = &phy->mt76->chandef;
-	band = chandef->chan->band;
-
-	if (vif->bss_conf.nontransmitted)
+	if (conf->nontransmitted)
 		return 0;
 
-	rskb = __mt7996_mcu_alloc_bss_req(&dev->mt76, &mvif->deflink.mt76,
+	rskb = __mt7996_mcu_alloc_bss_req(&dev->mt76, &mconf->mt76,
 					  MT7996_MAX_BSS_OFFLOAD_SIZE);
 	if (IS_ERR(rskb))
 		return PTR_ERR(rskb);
 
-	if (changed & BSS_CHANGED_FILS_DISCOVERY &&
-	    vif->bss_conf.fils_discovery.max_interval) {
-		interval = vif->bss_conf.fils_discovery.max_interval;
+	if (changed & BSS_CHANGED_FILS_DISCOVERY) {
+		interval = conf->fils_discovery.max_interval;
 		skb = ieee80211_get_fils_discovery_tmpl(hw, vif);
 	} else if (changed & BSS_CHANGED_UNSOL_BCAST_PROBE_RESP &&
-		   vif->bss_conf.unsol_bcast_probe_resp_interval) {
-		interval = vif->bss_conf.unsol_bcast_probe_resp_interval;
+		   conf->unsol_bcast_probe_resp_interval) {
+		interval = conf->unsol_bcast_probe_resp_interval;
 		skb = ieee80211_get_unsol_bcast_probe_resp_tmpl(hw, vif);
 	}
 
@@ -2655,7 +3424,7 @@ int mt7996_mcu_beacon_inband_discov(struct mt7996_dev *dev,
 	discov->tx_type = !!(changed & BSS_CHANGED_FILS_DISCOVERY);
 	discov->tx_interval = interval;
 	discov->prob_rsp_len = cpu_to_le16(MT_TXD_SIZE + skb->len);
-	discov->enable = true;
+	discov->enable = !!(interval);
 	discov->wcid = cpu_to_le16(MT7996_WTBL_RESERVED);
 
 	buf = (u8 *)tlv + sizeof(*discov);
@@ -2733,6 +3502,8 @@ static int mt7996_load_patch(struct mt7996_dev *dev)
 
 	dev_info(dev->mt76.dev, "HW/SW Version: 0x%x, Build Time: %.16s\n",
 		 be32_to_cpu(hdr->hw_sw_ver), hdr->build_date);
+	memcpy(dev->patch_build_date, hdr->build_date,
+	       sizeof(dev->patch_build_date));
 
 	for (i = 0; i < be32_to_cpu(hdr->desc.n_region); i++) {
 		struct mt7996_patch_sec *sec;
@@ -2859,6 +3630,9 @@ static int __mt7996_load_ram(struct mt7996_dev *dev, const char *fw_type,
 	}
 
 	hdr = (const void *)(fw->data + fw->size - sizeof(*hdr));
+	memcpy(dev->ram_build_date[ram_type],
+	       hdr->build_date,
+	       sizeof(dev->ram_build_date[ram_type]));
 	dev_info(dev->mt76.dev, "%s Firmware Version: %.10s, Build Time: %.15s\n",
 		 fw_type, hdr->fw_ver, hdr->build_date);
 
@@ -2882,8 +3656,12 @@ static int mt7996_load_ram(struct mt7996_dev *dev)
 {
 	int ret;
 
-	ret = __mt7996_load_ram(dev, "WM", fw_name(dev, FIRMWARE_WM),
-				MT7996_RAM_TYPE_WM);
+	if (dev->testmode_enable)
+		ret = __mt7996_load_ram(dev, "WM_TM", fw_name(dev, FIRMWARE_WM_TM),
+					MT7996_RAM_TYPE_WM_TM);
+	else
+		ret = __mt7996_load_ram(dev, "WM", fw_name(dev, FIRMWARE_WM),
+					MT7996_RAM_TYPE_WM);
 	if (ret)
 		return ret;
 
@@ -3010,6 +3788,36 @@ int mt7996_mcu_fw_dbg_ctrl(struct mt7996_dev *dev, u32 module, u8 level)
 				 sizeof(data), false);
 }
 
+int mt7996_mcu_fw_time_sync(struct mt76_dev *dev)
+{
+	struct {
+		u8 _rsv[4];
+
+		__le16 tag;
+		__le16 len;
+		__le32 sec;
+		__le32 usec;
+	} data = {
+		.tag = cpu_to_le16(UNI_WSYS_CONFIG_FW_TIME_SYNC),
+		.len = cpu_to_le16(sizeof(data) - 4),
+	};
+	struct timespec64 ts;
+	struct tm tm;
+
+	ktime_get_real_ts64(&ts);
+	data.sec = cpu_to_le32((u32)ts.tv_sec);
+	data.usec = cpu_to_le32((u32)(ts.tv_nsec / 1000));
+
+	/* Dump synchronized time for ConsysPlanet to parse. */
+	time64_to_tm(ts.tv_sec, 0, &tm);
+	dev_info(dev->dev, "%ld-%02d-%02d %02d:%02d:%02d.%ld UTC\n",
+	        tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
+	        tm.tm_hour, tm.tm_min, tm.tm_sec, ts.tv_nsec / 1000);
+
+	return mt76_mcu_send_msg(dev, MCU_WM_UNI_CMD(WSYS_CONFIG), &data,
+	                         sizeof(data), true);
+}
+
 static int mt7996_mcu_set_mwds(struct mt7996_dev *dev, bool enabled)
 {
 	struct {
@@ -3088,11 +3896,11 @@ int mt7996_mcu_init_firmware(struct mt7996_dev *dev)
 		return ret;
 
 	set_bit(MT76_STATE_MCU_RUNNING, &dev->mphy.state);
-	ret = mt7996_mcu_fw_log_2_host(dev, MCU_FW_LOG_WM, 0);
+	ret = mt7996_mcu_fw_log_2_host(dev, MCU_FW_LOG_WM, 1);
 	if (ret)
 		return ret;
 
-	ret = mt7996_mcu_fw_log_2_host(dev, MCU_FW_LOG_WA, 0);
+	ret = mt7996_mcu_fw_log_2_host(dev, MCU_FW_LOG_WA, 1);
 	if (ret)
 		return ret;
 
@@ -3104,13 +3912,14 @@ int mt7996_mcu_init_firmware(struct mt7996_dev *dev)
 	if (ret)
 		return ret;
 
-	return mt7996_mcu_wa_cmd(dev, MCU_WA_PARAM_CMD(SET),
-				 MCU_WA_PARAM_RED, 0, 0);
+	return mt7996_mcu_red_config(dev,
+			mtk_wed_device_active(&dev->mt76.mmio.wed));
 }
 
 int mt7996_mcu_init(struct mt7996_dev *dev)
 {
 	static const struct mt76_mcu_ops mt7996_mcu_ops = {
+		.max_retry = 3,
 		.headroom = sizeof(struct mt76_connac2_mcu_txd), /* reuse */
 		.mcu_skb_send_msg = mt7996_mcu_send_message,
 		.mcu_parse_response = mt7996_mcu_parse_response,
@@ -3137,6 +3946,83 @@ out:
 	skb_queue_purge(&dev->mt76.mcu.res_q);
 }
 
+static int mt7996_mcu_wa_red_config(struct mt7996_dev *dev)
+{
+#define RED_TOKEN_SRC_CNT	4
+#define RED_TOKEN_CONFIG	2
+	struct {
+		__le32 arg0;
+		__le32 arg1;
+		__le32 arg2;
+
+		u8 mode;
+		u8 version;
+		u8 _rsv[4];
+		__le16 len;
+
+		__le16 tcp_offset;
+		__le16 priority_offset;
+		__le16 token_per_src[RED_TOKEN_SRC_CNT];
+		__le16 token_thr_per_src[RED_TOKEN_SRC_CNT];
+
+		u8 _rsv2[604];
+	} __packed req = {
+		.arg0 = cpu_to_le32(MCU_WA_PARAM_RED_CONFIG),
+
+		.mode = RED_TOKEN_CONFIG,
+		.len = cpu_to_le16(sizeof(req) - sizeof(__le32) * 3),
+
+		.tcp_offset = cpu_to_le16(200),
+		.priority_offset = cpu_to_le16(255),
+	};
+	u8 i;
+
+	for (i = 0; i < RED_TOKEN_SRC_CNT; i++) {
+		req.token_per_src[i] = cpu_to_le16(MT7996_TOKEN_SIZE);
+		req.token_thr_per_src[i] = cpu_to_le16(MT7996_TOKEN_SIZE);
+	}
+
+	if (!mtk_wed_device_active(&dev->mt76.mmio.wed))
+		req.token_per_src[RED_TOKEN_SRC_CNT - 1] =
+			cpu_to_le16(MT7996_SW_TOKEN_SIZE);
+
+	return mt76_mcu_send_msg(&dev->mt76, MCU_WA_PARAM_CMD(SET),
+				 &req, sizeof(req), false);
+}
+
+int mt7996_mcu_red_config(struct mt7996_dev *dev, bool enable)
+{
+#define RED_DISABLE		0
+#define RED_BY_WA_ENABLE	2
+	struct {
+		u8 __rsv1[4];
+
+		__le16 tag;
+		__le16 len;
+		u8 enable;
+		u8 __rsv2[3];
+	} __packed req = {
+		.tag = cpu_to_le16(UNI_VOW_RED_ENABLE),
+		.len = cpu_to_le16(sizeof(req) - 4),
+		.enable = enable ? RED_BY_WA_ENABLE : RED_DISABLE,
+	};
+	int ret;
+
+	ret = mt76_mcu_send_msg(&dev->mt76, MCU_WM_UNI_CMD(VOW), &req,
+				 sizeof(req), true);
+
+	if (ret)
+		return ret;
+
+	ret = mt7996_mcu_wa_cmd(dev, MCU_WA_PARAM_CMD(SET),
+				MCU_WA_PARAM_RED_EN, enable, 0);
+
+	if (ret || !enable)
+		return ret;
+
+	return mt7996_mcu_wa_red_config(dev);
+}
+
 int mt7996_mcu_set_hdr_trans(struct mt7996_dev *dev, bool hdr_trans)
 {
 	struct {
@@ -3173,8 +4059,7 @@ int mt7996_mcu_set_hdr_trans(struct mt7996_dev *dev, bool hdr_trans)
 				     MCU_WM_UNI_CMD(RX_HDR_TRANS), true);
 }
 
-int mt7996_mcu_set_tx(struct mt7996_dev *dev, struct ieee80211_vif *vif,
-		      struct ieee80211_bss_conf *link_conf)
+int mt7996_mcu_set_tx(struct mt7996_dev *dev, struct mt7996_bss_conf *mconf)
 {
 #define MCU_EDCA_AC_PARAM	0
 #define WMM_AIFS_SET		BIT(0)
@@ -3183,12 +4068,11 @@ int mt7996_mcu_set_tx(struct mt7996_dev *dev, struct ieee80211_vif *vif,
 #define WMM_TXOP_SET		BIT(3)
 #define WMM_PARAM_SET		(WMM_AIFS_SET | WMM_CW_MIN_SET | \
 				 WMM_CW_MAX_SET | WMM_TXOP_SET)
-	struct mt7996_vif_link *link = mt7996_vif_conf_link(dev, vif, link_conf);
 	struct {
 		u8 bss_idx;
 		u8 __rsv[3];
 	} __packed hdr = {
-		.bss_idx = link->mt76.idx,
+		.bss_idx = mconf->mt76.idx,
 	};
 	struct sk_buff *skb;
 	int len = sizeof(hdr) + IEEE80211_NUM_ACS * sizeof(struct edca);
@@ -3201,7 +4085,7 @@ int mt7996_mcu_set_tx(struct mt7996_dev *dev, struct ieee80211_vif *vif,
 	skb_put_data(skb, &hdr, sizeof(hdr));
 
 	for (ac = 0; ac < IEEE80211_NUM_ACS; ac++) {
-		struct ieee80211_tx_queue_params *q = &link->queue_params[ac];
+		struct ieee80211_tx_queue_params *q = &mconf->queue_params[ac];
 		struct edca *e;
 		struct tlv *tlv;
 
@@ -3493,7 +4377,8 @@ int mt7996_mcu_set_chan_info(struct mt7996_phy *phy, u16 tag)
 	if (phy->mt76->hw->conf.flags & IEEE80211_CONF_MONITOR)
 		req.switch_reason = CH_SWITCH_NORMAL;
 	else if (phy->mt76->offchannel ||
-		 phy->mt76->hw->conf.flags & IEEE80211_CONF_IDLE)
+		 phy->mt76->hw->conf.flags & IEEE80211_CONF_IDLE ||
+		 phy->scan_chan)
 		req.switch_reason = CH_SWITCH_SCAN_BYPASS_DPD;
 	else if (!cfg80211_reg_can_beacon(phy->mt76->hw->wiphy, chandef,
 					  NL80211_IFTYPE_AP))
@@ -3514,7 +4399,151 @@ int mt7996_mcu_set_chan_info(struct mt7996_phy *phy, u16 tag)
 				 &req, sizeof(req), true);
 }
 
-static int mt7996_mcu_set_eeprom_flash(struct mt7996_dev *dev)
+static int mt7996_mcu_set_cal_free_data(struct mt7996_dev *dev)
+{
+#define MT_EE_CAL_FREE_MAX_SIZE		30
+#define MT_EE_7977BN_OFFSET		(0x1200 - 0x500)
+#define MT_EE_END_OFFSET		0xffff
+	enum adie_type {
+		ADIE_7975,
+		ADIE_7976,
+		ADIE_7977,
+		ADIE_7978,
+		ADIE_7979,
+	};
+	static const u16 adie_offs_list[][MT_EE_CAL_FREE_MAX_SIZE] = {
+		[ADIE_7975] = {0x5cd, 0x5cf, 0x5d1, 0x5d3, 0x6c0, 0x6c1, 0x6c2, 0x6c3,
+			       0x7a1, 0x7a6, 0x7a8, 0x7aa, -1},
+		[ADIE_7976] = {0x4c, 0x4d, 0x4e, 0x4f, 0x50, 0x51, 0x53, 0x55, 0x57, 0x59,
+			       0x70, 0x71, 0x790, 0x791, 0x794, 0x795, 0x7a6, 0x7a8, 0x7aa, -1},
+		[ADIE_7977] = {0x4c, 0x4d, 0x4e, 0x4f, 0x50, 0x51, 0x53, 0x55, 0x57, 0x59,
+			       0x69, 0x6a, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, -1},
+		[ADIE_7978] = {0x91, 0x95, 0x100, 0x102, 0x104, 0x106, 0x107,
+			       0x108, 0x109, 0x10a, 0x10b, 0x10c, 0x10e, 0x110, -1},
+		[ADIE_7979] = {0x4c, 0x4d, 0x4e, 0x4f, 0x50, 0x51, 0x53, 0x55, 0x57, 0x59,
+			       0x69, 0x6a, 0x7a, 0x7b, 0x7c, 0x7e, 0x80, -1},
+	};
+	static const u16 eep_offs_list[][MT_EE_CAL_FREE_MAX_SIZE] = {
+		[ADIE_7975] = {0x451, 0x453, 0x455, 0x457, 0x44c, 0x44d, 0x44e, 0x44f,
+			       0xba1, 0xba6, 0xba8, 0xbaa, -1},
+		[ADIE_7976] = {0x44c, 0x44d, 0x44e, 0x44f, 0x450,
+			       0x451, 0x453, 0x455, 0x457, 0x459,
+			       0x470, 0x471, 0xb90, 0xb91, 0xb94, 0xb95,
+			       0xba6, 0xba8, 0xbaa, -1},
+		[ADIE_7977] = {0x124c, 0x124d, 0x124e, 0x124f, 0x1250,
+			       0x1251, 0x1253, 0x1255, 0x1257, 0x1259,
+			       0x1269, 0x126a, 0x127a, 0x127b, 0x127c, 0x127d, 0x127e, -1},
+		[ADIE_7978] = {0xb91, 0xb95, 0x480, 0x482, 0x484, 0x486, 0x487, 0x488, 0x489,
+			       0x48a, 0x48b, 0x48c, 0x48e, 0x490, -1},
+		[ADIE_7979] = {0x124c, 0x124d, 0x124e, 0x124f, 0x1250, 0x1251,
+			       0x1253, 0x1255, 0x1257, 0x1259, 0x1269, 0x126a,
+			       0x127a, 0x127b, 0x127c, 0x127e, 0x1280, -1},
+	};
+	static const u16 adie_base_7996[] = {
+		0x400, 0x1e00, 0x1200
+	};
+	static const u16 adie_base_7992[] = {
+		0x400, 0x1200, 0x0
+	};
+	static const u16 *adie_offs[__MT_MAX_BAND];
+	static const u16 *eep_offs[__MT_MAX_BAND];
+	static const u16 *adie_base;
+	int adie_id, band, i, ret;
+
+	switch (mt76_chip(&dev->mt76)) {
+	case MT7996_DEVICE_ID:
+		adie_base = adie_base_7996;
+		/* adie 0 */
+		if (dev->var.fem == MT7996_FEM_INT && dev->var.type != MT7996_VAR_TYPE_233)
+			adie_id = ADIE_7975;
+		else
+			adie_id = ADIE_7976;
+		adie_offs[0] = adie_offs_list[adie_id];
+		eep_offs[0] = eep_offs_list[adie_id];
+
+		/* adie 1 */
+		if (dev->var.type == MT7996_VAR_TYPE_444) {
+			adie_offs[1] = adie_offs_list[ADIE_7977];
+			eep_offs[1] = eep_offs_list[ADIE_7977];
+		}
+
+		/* adie 2 */
+		adie_offs[2] = adie_offs_list[ADIE_7977];
+		eep_offs[2] = eep_offs_list[ADIE_7977];
+		break;
+	case MT7992_DEVICE_ID:
+		adie_base = adie_base_7992;
+		/* adie 0 */
+		if (dev->var.type == MT7992_VAR_TYPE_44 &&
+		    dev->var.fem != MT7996_FEM_EXT)
+			adie_id = ADIE_7975;
+		else if (dev->var.type == MT7992_VAR_TYPE_24)
+			adie_id = ADIE_7978;
+		else
+			adie_id = ADIE_7976;
+		adie_offs[0] = adie_offs_list[adie_id];
+		eep_offs[0] = eep_offs_list[adie_id];
+
+		/* adie 1 */
+		if (dev->var.type == MT7992_VAR_TYPE_44 &&
+		    dev->var.fem != MT7996_FEM_INT)
+			adie_id = ADIE_7977;
+		else if (dev->var.type != MT7992_VAR_TYPE_23)
+			adie_id = ADIE_7979;
+		else
+			break;
+		adie_offs[1] = adie_offs_list[adie_id];
+		eep_offs[1] = eep_offs_list[adie_id];
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	for (band = 0; band < __MT_MAX_BAND; band++) {
+		struct {
+			/* fixed field */
+			u8 __rsv[4];
+
+			__le16 tag;
+			__le16 len;
+			__le16 adie_offset;
+			__le16 eep_offset;
+			__le16 count;
+			u8 rsv[2];
+		} __packed req = {
+			.tag = cpu_to_le16(UNI_EFUSE_PATCH),
+			.len = cpu_to_le16(sizeof(req) - 4),
+			.count = cpu_to_le16(1),
+		};
+		u16 adie_offset, eep_offset;
+
+		if (!adie_offs[band])
+			continue;
+
+		for (i = 0; i < MT_EE_CAL_FREE_MAX_SIZE; i++) {
+			adie_offset = adie_offs[band][i] + adie_base[band];
+			eep_offset = eep_offs[band][i];
+
+			if (adie_offs[band][i] == MT_EE_END_OFFSET)
+				break;
+
+			if (is_mt7996(&dev->mt76) && dev->var.type == MT7996_VAR_TYPE_444 &&
+			    band == MT_BAND1)
+				eep_offset -= MT_EE_7977BN_OFFSET;
+
+			req.eep_offset = cpu_to_le16(eep_offset);
+			req.adie_offset = cpu_to_le16(adie_offset);
+			ret = mt76_mcu_send_msg(&dev->mt76, MCU_WM_UNI_CMD(EFUSE_CTRL),
+						&req, sizeof(req), true);
+			if (ret)
+				return ret;
+		}
+	}
+
+	return 0;
+}
+
+int mt7996_mcu_set_eeprom_flash(struct mt7996_dev *dev)
 {
 #define MAX_PAGE_IDX_MASK	GENMASK(7, 5)
 #define PAGE_IDX_MASK		GENMASK(4, 2)
@@ -3567,25 +4596,22 @@ int mt7996_mcu_set_eeprom(struct mt7996_dev *dev)
 		.buffer_mode = EE_MODE_EFUSE,
 		.format = EE_FORMAT_WHOLE
 	};
+	int ret;
 
 	if (dev->flash_mode)
-		return mt7996_mcu_set_eeprom_flash(dev);
+		ret = mt7996_mcu_set_eeprom_flash(dev);
+	else
+		ret = mt76_mcu_send_msg(&dev->mt76, MCU_WM_UNI_CMD(EFUSE_CTRL),
+					&req, sizeof(req), true);
+	if (ret)
+		return ret;
 
-	return mt76_mcu_send_msg(&dev->mt76, MCU_WM_UNI_CMD(EFUSE_CTRL),
-				 &req, sizeof(req), true);
+	return mt7996_mcu_set_cal_free_data(dev);
 }
 
 int mt7996_mcu_get_eeprom(struct mt7996_dev *dev, u32 offset, u8 *buf, u32 buf_len)
 {
-	struct {
-		u8 _rsv[4];
-
-		__le16 tag;
-		__le16 len;
-		__le32 addr;
-		__le32 valid;
-		u8 data[16];
-	} __packed req = {
+	struct mt7996_mcu_eeprom_info req = {
 		.tag = cpu_to_le16(UNI_EFUSE_ACCESS),
 		.len = cpu_to_le16(sizeof(req) - 4),
 		.addr = cpu_to_le32(round_down(offset,
@@ -3607,6 +4633,7 @@ int mt7996_mcu_get_eeprom(struct mt7996_dev *dev, u32 offset, u8 *buf, u32 buf_l
 
 		if (!buf)
 			buf = (u8 *)dev->mt76.eeprom.data + addr;
+
 		if (!buf_len || buf_len > MT7996_EEPROM_BLOCK_SIZE)
 			buf_len = MT7996_EEPROM_BLOCK_SIZE;
 
@@ -3651,55 +4678,241 @@ int mt7996_mcu_get_eeprom_free_block(struct mt7996_dev *dev, u8 *block_num)
 	return 0;
 }
 
-int mt7996_mcu_get_chip_config(struct mt7996_dev *dev, u32 *cap)
+static int mt7996_mcu_set_pre_cal(struct mt7996_dev *dev, u32 idx,
+				  u8 *cal, u32 len, u32 cal_id)
 {
-#define NIC_CAP	3
-#define UNI_EVENT_CHIP_CONFIG_EFUSE_VERSION	0x21
+#define PRECAL_CMD_PRE_CAL_RESULT	0x0
 	struct {
-		u8 _rsv[4];
+		/* fixed field */
+		u8 action;
+		u8 dest;
+		u8 attribute;
+		u8 tag_num;
 
 		__le16 tag;
 		__le16 len;
-	} __packed req = {
-		.tag = cpu_to_le16(NIC_CAP),
-		.len = cpu_to_le16(sizeof(req) - 4),
+
+		__le32 cal_id;
+		s8 precal;
+		u8 band;
+		u8 rsv[2];
+		__le32 idx;
+		__le32 cal_len;
+	} req = {
+		.tag = cpu_to_le16(PRECAL_CMD_PRE_CAL_RESULT),
+		.len = cpu_to_le16(sizeof(req) - 4 + len),
+		.cal_id = cpu_to_le32(cal_id),
+		.idx = cpu_to_le32(idx),
+		.cal_len = cpu_to_le32(len),
 	};
 	struct sk_buff *skb;
-	u8 *buf;
-	int ret;
 
-	ret = mt76_mcu_send_and_get_msg(&dev->mt76,
-					MCU_WM_UNI_CMD_QUERY(CHIP_CONFIG), &req,
-					sizeof(req), true, &skb);
-	if (ret)
-		return ret;
+	if (!len)
+		return 0;
 
-	/* fixed field */
-	skb_pull(skb, 4);
+	skb = mt76_mcu_msg_alloc(&dev->mt76, NULL, sizeof(req) + len);
+	if (!skb)
+		return -ENOMEM;
 
-	buf = skb->data;
-	while (buf - skb->data < skb->len) {
-		struct tlv *tlv = (struct tlv *)buf;
+	skb_put_data(skb, &req, sizeof(req));
+	skb_put_data(skb, cal, len);
 
-		switch (le16_to_cpu(tlv->tag)) {
-		case UNI_EVENT_CHIP_CONFIG_EFUSE_VERSION:
-			*cap = le32_to_cpu(*(__le32 *)(buf + sizeof(*tlv)));
-			break;
-		default:
-			break;
-		}
+	return mt76_mcu_skb_send_msg(&dev->mt76, skb, MCU_WM_UNI_CMD(PRECAL_RESULT), false);
+}
 
-		buf += le16_to_cpu(tlv->len);
+int mt7996_mcu_apply_group_cal(struct mt7996_dev *dev)
+{
+	u8 *cal = dev->cal, *eeprom = dev->mt76.eeprom.data;
+	u32 idx = 0, total_idx = MT_EE_CAL_GROUP_SIZE / MT_EE_CAL_UNIT;
+	u32 offs = MT_EE_DO_PRE_CAL;
+	int ret = 0;
+
+	if (!(eeprom[offs] & MT_EE_WIFI_CAL_GROUP))
+		return 0;
+
+	for (idx = 0; idx < total_idx; idx++, cal += MT_EE_CAL_UNIT) {
+		ret = mt7996_mcu_set_pre_cal(dev, idx, cal, MT_EE_CAL_UNIT, RF_PRE_CAL);
+		if (ret)
+			goto out;
 	}
 
-	dev_kfree_skb(skb);
+	ret = mt7996_mcu_set_pre_cal(dev, total_idx, cal,
+				     MT_EE_CAL_GROUP_SIZE % MT_EE_CAL_UNIT, RF_PRE_CAL);
 
-	return 0;
+out:
+	return ret;
 }
 
-int mt7996_mcu_get_chan_mib_info(struct mt7996_phy *phy, bool chan_switch)
+int mt7996_mcu_apply_tx_dpd(struct mt7996_phy *phy)
 {
-	enum {
+	struct mt7996_dev *dev = phy->dev;
+	struct mt76_phy *mphy = phy->mt76;
+	struct cfg80211_chan_def *chandef = &phy->mt76->chandef;
+	enum nl80211_band band = chandef->chan->band;
+	enum nl80211_chan_width bw = chandef->width;
+	const struct ieee80211_channel *chan_list;
+	u32 cal_id, chan_list_size, base_offset = 0, offs = MT_EE_DO_PRE_CAL;
+	u32 per_chan_size = DPD_PER_CH_BW20_SIZE;
+	u16 channel = ieee80211_frequency_to_channel(chandef->center_freq1);
+	u8 dpd_mask, *cal = dev->cal, *eeprom = dev->mt76.eeprom.data;
+	int idx, i, ret;
+	bool has_skip_ch = (band == NL80211_BAND_5GHZ);
+
+	switch (band) {
+	case NL80211_BAND_2GHZ:
+		dpd_mask = MT_EE_WIFI_CAL_DPD_2G;
+		/* channel 14 don't need DPD cal */
+		if (channel >= 1 && channel <= 4)
+			channel = 3;
+		else if (channel >= 5 && channel <= 9)
+			channel = 7;
+		else if (channel >= 10 && channel <= 13)
+			channel = 11;
+		else
+			return 0;
+		cal_id = RF_DPD_FLAT_CAL;
+		chan_list = dpd_2g_ch_list_bw20;
+		chan_list_size = DPD_CH_NUM(BW20_2G);
+		break;
+	case NL80211_BAND_5GHZ:
+		dpd_mask = MT_EE_WIFI_CAL_DPD_5G;
+		cal_id = RF_DPD_FLAT_5G_CAL;
+		chan_list = mphy->sband_5g.sband.channels;
+		chan_list_size = mphy->sband_5g.sband.n_channels;
+		base_offset += MT_EE_CAL_DPD_SIZE_2G;
+		if (bw == NL80211_CHAN_WIDTH_160) {
+			base_offset += DPD_CH_NUM(BW20_5G) * DPD_PER_CH_BW20_SIZE +
+				       DPD_CH_NUM(BW80_5G) * DPD_PER_CH_GT_BW20_SIZE;
+			per_chan_size = DPD_PER_CH_GT_BW20_SIZE;
+			cal_id = RF_DPD_FLAT_5G_MEM_CAL;
+			chan_list = dpd_5g_ch_list_bw160;
+			chan_list_size = DPD_CH_NUM(BW160_5G);
+			has_skip_ch = false;
+		} else if (is_mt7992(&dev->mt76) && bw == NL80211_CHAN_WIDTH_80) {
+			base_offset += DPD_CH_NUM(BW20_5G) * DPD_PER_CH_BW20_SIZE;
+			per_chan_size = DPD_PER_CH_GT_BW20_SIZE;
+			cal_id = RF_DPD_FLAT_5G_MEM_CAL;
+			chan_list = dpd_5g_ch_list_bw80;
+			chan_list_size = DPD_CH_NUM(BW80_5G);
+			has_skip_ch = false;
+		} else if (bw > NL80211_CHAN_WIDTH_20) {
+			/* apply (center channel - 2)'s dpd cal data for bw 40/80 channels */
+			channel -= 2;
+		}
+		if (channel >= dpd_5g_skip_ch_list[0].hw_value &&
+		    channel <= dpd_5g_skip_ch_list[DPD_CH_NUM(BW20_5G_SKIP) - 1].hw_value)
+			return 0;
+		break;
+	case NL80211_BAND_6GHZ:
+		dpd_mask = MT_EE_WIFI_CAL_DPD_6G;
+		cal_id = RF_DPD_FLAT_6G_CAL;
+		chan_list = mphy->sband_6g.sband.channels;
+		chan_list_size = mphy->sband_6g.sband.n_channels;
+		base_offset += MT_EE_CAL_DPD_SIZE_2G + MT_EE_CAL_DPD_SIZE_5G;
+		if (bw == NL80211_CHAN_WIDTH_160) {
+			base_offset += mphy->sband_6g.sband.n_channels * DPD_PER_CH_BW20_SIZE;
+			per_chan_size = DPD_PER_CH_GT_BW20_SIZE;
+			cal_id = RF_DPD_FLAT_6G_MEM_CAL;
+			chan_list = dpd_6g_ch_list_bw160;
+			chan_list_size = DPD_CH_NUM(BW160_6G);
+		} else if (is_mt7996(&dev->mt76) && bw == NL80211_CHAN_WIDTH_320) {
+			base_offset += mphy->sband_6g.sband.n_channels * DPD_PER_CH_BW20_SIZE +
+				       DPD_CH_NUM(BW80_6G) * DPD_PER_CH_GT_BW20_SIZE +
+				       DPD_CH_NUM(BW160_6G) * DPD_PER_CH_GT_BW20_SIZE;
+			per_chan_size = DPD_PER_CH_GT_BW20_SIZE;
+			cal_id = RF_DPD_FLAT_6G_MEM_CAL;
+			chan_list = dpd_6g_ch_list_bw320;
+			chan_list_size = DPD_CH_NUM(BW320_6G);
+		} else if (is_mt7992(&dev->mt76) && bw == NL80211_CHAN_WIDTH_80) {
+			base_offset += mphy->sband_6g.sband.n_channels * DPD_PER_CH_BW20_SIZE;
+			per_chan_size = DPD_PER_CH_GT_BW20_SIZE;
+			cal_id = RF_DPD_FLAT_6G_MEM_CAL;
+			chan_list = dpd_6g_ch_list_bw80;
+			chan_list_size = DPD_CH_NUM(BW80_6G);
+		} else if (bw > NL80211_CHAN_WIDTH_20) {
+			/* apply (center channel - 2)'s dpd cal data for bw 40/80 channels */
+			channel -= 2;
+		}
+		break;
+	default:
+		dpd_mask = 0;
+		break;
+	}
+
+	if (!(eeprom[offs] & dpd_mask))
+		return 0;
+
+	for (idx = 0; idx < chan_list_size; idx++)
+		if (channel == chan_list[idx].hw_value)
+			break;
+	if (idx == chan_list_size)
+		return -EINVAL;
+
+	if (has_skip_ch && channel > dpd_5g_skip_ch_list[DPD_CH_NUM(BW20_5G_SKIP) - 1].hw_value)
+		idx -= DPD_CH_NUM(BW20_5G_SKIP);
+
+	cal += MT_EE_CAL_GROUP_SIZE + base_offset + idx * per_chan_size;
+
+	for (i = 0; i < per_chan_size / MT_EE_CAL_UNIT; i++) {
+		ret = mt7996_mcu_set_pre_cal(dev, i, cal, MT_EE_CAL_UNIT, cal_id);
+		if (ret)
+			return ret;
+
+		cal += MT_EE_CAL_UNIT;
+	}
+
+	return ret;
+}
+
+int mt7996_mcu_get_chip_config(struct mt7996_dev *dev, u32 *cap)
+{
+#define NIC_CAP	3
+#define UNI_EVENT_CHIP_CONFIG_EFUSE_VERSION	0x21
+	struct {
+		u8 _rsv[4];
+
+		__le16 tag;
+		__le16 len;
+	} __packed req = {
+		.tag = cpu_to_le16(NIC_CAP),
+		.len = cpu_to_le16(sizeof(req) - 4),
+	};
+	struct sk_buff *skb;
+	u8 *buf;
+	int ret;
+
+	ret = mt76_mcu_send_and_get_msg(&dev->mt76,
+					MCU_WM_UNI_CMD_QUERY(CHIP_CONFIG), &req,
+					sizeof(req), true, &skb);
+	if (ret)
+		return ret;
+
+	/* fixed field */
+	skb_pull(skb, 4);
+
+	buf = skb->data;
+	while (buf - skb->data < skb->len) {
+		struct tlv *tlv = (struct tlv *)buf;
+
+		switch (le16_to_cpu(tlv->tag)) {
+		case UNI_EVENT_CHIP_CONFIG_EFUSE_VERSION:
+			*cap = le32_to_cpu(*(__le32 *)(buf + sizeof(*tlv)));
+			break;
+		default:
+			break;
+		}
+
+		buf += le16_to_cpu(tlv->len);
+	}
+
+	dev_kfree_skb(skb);
+
+	return 0;
+}
+
+int mt7996_mcu_get_chan_mib_info(struct mt7996_phy *phy, bool chan_switch)
+{
+	enum {
 		IDX_TX_TIME,
 		IDX_RX_TIME,
 		IDX_OBSS_AIRTIME,
@@ -3919,6 +5132,8 @@ int mt7996_mcu_set_ser(struct mt7996_dev *dev, u8 action, u8 val, u8 band)
 	};
 
 	switch (action) {
+	case UNI_CMD_SER_QUERY:
+		break;
 	case UNI_CMD_SER_SET:
 		req.set.mask = cpu_to_le32(val);
 		break;
@@ -3937,7 +5152,6 @@ int mt7996_mcu_set_ser(struct mt7996_dev *dev, u8 action, u8 val, u8 band)
 int mt7996_mcu_set_txbf(struct mt7996_dev *dev, u8 action)
 {
 #define MT7996_BF_MAX_SIZE	sizeof(union bf_tag_tlv)
-#define BF_PROCESSING	4
 	struct uni_header hdr;
 	struct sk_buff *skb;
 	struct tlv *tlv;
@@ -4064,12 +5278,12 @@ mt7996_mcu_set_obss_spr_pd(struct mt7996_phy *phy,
 }
 
 static int
-mt7996_mcu_set_obss_spr_siga(struct mt7996_phy *phy, struct ieee80211_vif *vif,
+mt7996_mcu_set_obss_spr_siga(struct mt7996_phy *phy,
+			     struct mt7996_bss_conf *mconf,
 			     struct ieee80211_he_obss_pd *he_obss_pd)
 {
-	struct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;
 	struct mt7996_dev *dev = phy->dev;
-	u8 omac = mvif->deflink.mt76.omac_idx;
+	u8 omac = mconf->mt76.omac_idx;
 	struct {
 		u8 band_idx;
 		u8 __rsv[3];
@@ -4141,7 +5355,8 @@ mt7996_mcu_set_obss_spr_bitmap(struct mt7996_phy *phy,
 				 sizeof(req), true);
 }
 
-int mt7996_mcu_add_obss_spr(struct mt7996_phy *phy, struct ieee80211_vif *vif,
+int mt7996_mcu_add_obss_spr(struct mt7996_phy *phy,
+			    struct mt7996_bss_conf *mconf,
 			    struct ieee80211_he_obss_pd *he_obss_pd)
 {
 	int ret;
@@ -4175,7 +5390,7 @@ int mt7996_mcu_add_obss_spr(struct mt7996_phy *phy, struct ieee80211_vif *vif,
 		return ret;
 
 	/* Set SR prohibit */
-	ret = mt7996_mcu_set_obss_spr_siga(phy, vif, he_obss_pd);
+	ret = mt7996_mcu_set_obss_spr_siga(phy, mconf, he_obss_pd);
 	if (ret)
 		return ret;
 
@@ -4184,7 +5399,7 @@ int mt7996_mcu_add_obss_spr(struct mt7996_phy *phy, struct ieee80211_vif *vif,
 }
 
 int mt7996_mcu_update_bss_color(struct mt7996_dev *dev,
-				struct mt76_vif_link *mlink,
+				struct mt7996_bss_conf *mconf,
 				struct cfg80211_he_bss_color *he_bss_color)
 {
 	int len = sizeof(struct bss_req_hdr) + sizeof(struct bss_color_tlv);
@@ -4192,7 +5407,7 @@ int mt7996_mcu_update_bss_color(struct mt7996_dev *dev,
 	struct sk_buff *skb;
 	struct tlv *tlv;
 
-	skb = __mt7996_mcu_alloc_bss_req(&dev->mt76, mlink, len);
+	skb = __mt7996_mcu_alloc_bss_req(&dev->mt76, &mconf->mt76, len);
 	if (IS_ERR(skb))
 		return PTR_ERR(skb);
 
@@ -4211,7 +5426,7 @@ int mt7996_mcu_update_bss_color(struct mt7996_dev *dev,
 #define TWT_AGRT_PROTECT	BIT(2)
 
 int mt7996_mcu_twt_agrt_update(struct mt7996_dev *dev,
-			       struct mt7996_vif *mvif,
+			       struct mt7996_bss_conf *mconf,
 			       struct mt7996_twt_flow *flow,
 			       int cmd)
 {
@@ -4242,12 +5457,12 @@ int mt7996_mcu_twt_agrt_update(struct mt7996_dev *dev,
 		.len = cpu_to_le16(sizeof(req) - 4),
 		.tbl_idx = flow->table_id,
 		.cmd = cmd,
-		.own_mac_idx = mvif->deflink.mt76.omac_idx,
+		.own_mac_idx = mconf->mt76.omac_idx,
 		.flowid = flow->id,
 		.peer_id = cpu_to_le16(flow->wcid),
 		.duration = flow->duration,
-		.bss = mvif->deflink.mt76.idx,
-		.bss_idx = mvif->deflink.mt76.idx,
+		.bss = mconf->mt76.idx,
+		.bss_idx = mconf->mt76.idx,
 		.start_tsf = cpu_to_le64(flow->tsf),
 		.mantissa = flow->mantissa,
 		.exponent = flow->exp,
@@ -4287,7 +5502,7 @@ int mt7996_mcu_set_rts_thresh(struct mt7996_phy *phy, u32 val)
 				 &req, sizeof(req), true);
 }
 
-int mt7996_mcu_set_radio_en(struct mt7996_phy *phy, bool enable)
+int mt7996_mcu_set_band_confg(struct mt7996_phy *phy, u16 option, bool enable)
 {
 	struct {
 		u8 band_idx;
@@ -4295,11 +5510,11 @@ int mt7996_mcu_set_radio_en(struct mt7996_phy *phy, bool enable)
 
 		__le16 tag;
 		__le16 len;
-		u8 enable;
+		bool enable;
 		u8 _rsv2[3];
 	} __packed req = {
 		.band_idx = phy->mt76->band_idx,
-		.tag = cpu_to_le16(UNI_BAND_CONFIG_RADIO_ENABLE),
+		.tag = cpu_to_le16(option),
 		.len = cpu_to_le16(sizeof(req) - 4),
 		.enable = enable,
 	};
@@ -4308,21 +5523,31 @@ int mt7996_mcu_set_radio_en(struct mt7996_phy *phy, bool enable)
 				 &req, sizeof(req), true);
 }
 
-int mt7996_mcu_rdd_cmd(struct mt7996_dev *dev, int cmd, u8 index,
-		       u8 rx_sel, u8 val)
+int mt7996_mcu_set_radio_en(struct mt7996_phy *phy, bool enable)
 {
 	struct {
-		u8 _rsv[4];
+		u8 band_idx;
+		u8 _rsv[3];
 
 		__le16 tag;
 		__le16 len;
-
-		u8 ctrl;
-		u8 rdd_idx;
-		u8 rdd_rx_sel;
-		u8 val;
-		u8 rsv[4];
+		u8 enable;
+		u8 _rsv2[3];
 	} __packed req = {
+		.band_idx = phy->mt76->band_idx,
+		.tag = cpu_to_le16(UNI_BAND_CONFIG_RADIO_ENABLE),
+		.len = cpu_to_le16(sizeof(req) - 4),
+		.enable = enable,
+	};
+
+	return mt76_mcu_send_msg(&phy->dev->mt76, MCU_WM_UNI_CMD(BAND_CONFIG),
+				 &req, sizeof(req), true);
+}
+
+int mt7996_mcu_rdd_cmd(struct mt7996_dev *dev, int cmd, u8 index,
+		       u8 rx_sel, u8 val)
+{
+	struct mt7996_rdd_ctrl req = {
 		.tag = cpu_to_le16(UNI_RDD_CTRL_PARM),
 		.len = cpu_to_le16(sizeof(req) - 4),
 		.ctrl = cmd,
@@ -4335,24 +5560,52 @@ int mt7996_mcu_rdd_cmd(struct mt7996_dev *dev, int cmd, u8 index,
 				 &req, sizeof(req), true);
 }
 
+int mt7996_mcu_rdd_background_disable_timer(struct mt7996_dev *dev, bool disable_timer)
+{
+	struct mt7996_rdd_ctrl req = {
+		.tag = cpu_to_le16(UNI_RDD_CTRL_PARM),
+		.len = cpu_to_le16(sizeof(req) - 4),
+		.ctrl = RDD_DISABLE_ZW_TIMER,
+		.rdd_idx = MT_RX_SEL2,
+		.disable_timer = disable_timer,
+	};
+
+	if (!is_mt7996(&dev->mt76) ||
+	    (mt76_get_field(dev, MT_PAD_GPIO, MT_PAD_GPIO_ADIE_COMB) % 2))
+		return 0;
+
+	switch (dev->mt76.region) {
+	case NL80211_DFS_ETSI:
+		req.val = 0;
+		break;
+	case NL80211_DFS_JP:
+		req.val = 2;
+		break;
+	case NL80211_DFS_FCC:
+	default:
+		req.val = 1;
+		break;
+	}
+
+	return mt76_mcu_send_msg(&dev->mt76, MCU_WM_UNI_CMD(RDD_CTRL),
+				 &req, sizeof(req), true);
+}
+
 int mt7996_mcu_wtbl_update_hdr_trans(struct mt7996_dev *dev,
 				     struct ieee80211_vif *vif,
-				     struct ieee80211_sta *sta)
+				     struct mt7996_bss_conf *mconf,
+				     struct mt7996_link_sta *mlink)
 {
-	struct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;
-	struct mt7996_sta *msta;
 	struct sk_buff *skb;
 
-	msta = sta ? (struct mt7996_sta *)sta->drv_priv : &mvif->deflink.sta;
-
-	skb = __mt76_connac_mcu_alloc_sta_req(&dev->mt76, &mvif->deflink.mt76,
-					      &msta->wcid,
+	skb = __mt76_connac_mcu_alloc_sta_req(&dev->mt76, &mconf->mt76,
+					      &mlink->wcid,
 					      MT7996_STA_UPDATE_MAX_SIZE);
 	if (IS_ERR(skb))
 		return PTR_ERR(skb);
 
 	/* starec hdr trans */
-	mt7996_mcu_sta_hdr_trans_tlv(dev, skb, vif, &msta->wcid);
+	mt7996_mcu_sta_hdr_trans_tlv(dev, skb, vif, mlink);
 	return mt76_mcu_skb_send_msg(&dev->mt76, skb,
 				     MCU_WMWA_UNI_CMD(STA_REC_UPDATE), true);
 }
@@ -4494,9 +5747,135 @@ int mt7996_mcu_set_rro(struct mt7996_dev *dev, u16 tag, u16 val)
 				 sizeof(req), true);
 }
 
-int mt7996_mcu_get_all_sta_info(struct mt7996_phy *phy, u16 tag)
+int mt7996_mcu_get_per_sta_info(struct mt76_dev *dev, u16 tag,
+	                        u16 sta_num, u16 *sta_list)
+{
+#define PER_STA_INFO_MAX_NUM	90
+	struct mt7996_mcu_per_sta_info_event *res;
+	struct mt76_wcid *wcid;
+	struct sk_buff *skb;
+	u16 wlan_idx;
+	int i, ret;
+	struct {
+		u8 __rsv1;
+		u8 unsolicit;
+		u8 __rsv2[2];
+
+		__le16 tag;
+		__le16 len;
+		__le16 sta_num;
+		u8 __rsv3[2];
+		__le16 sta_list[PER_STA_INFO_MAX_NUM];
+	} __packed req = {
+		.unsolicit = 0,
+		.tag = cpu_to_le16(tag),
+		.len = cpu_to_le16(sizeof(req) - 4),
+		.sta_num = cpu_to_le16(sta_num)
+	};
+
+	if (sta_num > PER_STA_INFO_MAX_NUM)
+		return -EINVAL;
+
+	for (i = 0; i < sta_num; ++i)
+		req.sta_list[i] = cpu_to_le16(sta_list[i]);
+
+	ret = mt76_mcu_send_and_get_msg(dev, MCU_WM_UNI_CMD(PER_STA_INFO),
+	                                &req, sizeof(req), true, &skb);
+	if (ret)
+		return ret;
+
+	res = (struct mt7996_mcu_per_sta_info_event *)skb->data;
+	if (le16_to_cpu(res->tag) != tag) {
+		ret = -EINVAL;
+		goto out;
+	}
+
+	rcu_read_lock();
+	switch (tag) {
+	case UNI_PER_STA_RSSI:
+		for (i = 0; i < sta_num; ++i) {
+			struct mt7996_link_sta *mlink;
+			struct mt76_phy *phy;
+			s8 rssi[4];
+			u8 *rcpi;
+
+			wlan_idx = le16_to_cpu(res->rssi[i].wlan_idx);
+			wcid = rcu_dereference(dev->wcid[wlan_idx]);
+			if (wcid) {
+				rcpi = res->rssi[i].rcpi;
+				rssi[0] = to_rssi(MT_PRXV_RCPI0, rcpi[0]);
+				rssi[1] = to_rssi(MT_PRXV_RCPI0, rcpi[1]);
+				rssi[2] = to_rssi(MT_PRXV_RCPI0, rcpi[2]);
+				rssi[3] = to_rssi(MT_PRXV_RCPI0, rcpi[3]);
+
+				mlink = container_of(wcid, struct mt7996_link_sta, wcid);
+				phy = dev->phys[wcid->phy_idx];
+				mlink->ack_signal = mt76_rx_signal(phy->antenna_mask, rssi);
+				ewma_avg_signal_add(&mlink->avg_ack_signal, -mlink->ack_signal);
+			}
+		}
+		break;
+	default:
+		ret = -EINVAL;
+		dev_err(dev->dev, "Unknown UNI_PER_STA_INFO_TAG: %d\n", tag);
+	}
+	rcu_read_unlock();
+out:
+	dev_kfree_skb(skb);
+	return ret;
+}
+
+int mt7996_mcu_get_rssi(struct mt76_dev *dev)
+{
+	u16 sta_list[PER_STA_INFO_MAX_NUM];
+	LIST_HEAD(sta_poll_list);
+	struct mt7996_link_sta *mlink;
+	int i, ret;
+	bool empty = false;
+
+	spin_lock_bh(&dev->sta_poll_lock);
+	list_splice_init(&dev->sta_poll_list, &sta_poll_list);
+	spin_unlock_bh(&dev->sta_poll_lock);
+
+	while (!empty) {
+		for (i = 0; i < PER_STA_INFO_MAX_NUM; ++i) {
+			spin_lock_bh(&dev->sta_poll_lock);
+			if (list_empty(&sta_poll_list)) {
+				spin_unlock_bh(&dev->sta_poll_lock);
+
+				if (i == 0)
+					return 0;
+
+				empty = true;
+				break;
+			}
+			mlink = list_first_entry(&sta_poll_list,
+			                        struct mt7996_link_sta,
+			                        wcid.poll_list);
+			list_del_init(&mlink->wcid.poll_list);
+			spin_unlock_bh(&dev->sta_poll_lock);
+
+			sta_list[i] = mlink->wcid.idx;
+		}
+
+		ret = mt7996_mcu_get_per_sta_info(dev, UNI_PER_STA_RSSI,
+		                                  i, sta_list);
+		if (ret) {
+			/* Add STAs, whose RSSI has not been updated,
+			 * back to polling list.
+			 */
+			spin_lock_bh(&dev->sta_poll_lock);
+			list_splice(&sta_poll_list, &dev->sta_poll_list);
+			spin_unlock_bh(&dev->sta_poll_lock);
+			break;
+		}
+	}
+
+	return ret;
+}
+
+int mt7996_mcu_get_all_sta_info(struct mt76_dev *dev, u16 tag)
 {
-	struct mt7996_dev *dev = phy->dev;
 	struct {
 		u8 _rsv[4];
 
@@ -4507,7 +5886,7 @@ int mt7996_mcu_get_all_sta_info(struct mt7996_phy *phy, u16 tag)
 		.len = cpu_to_le16(sizeof(req) - 4),
 	};
 
-	return mt76_mcu_send_msg(&dev->mt76, MCU_WM_UNI_CMD(ALL_STA_INFO),
+	return mt76_mcu_send_msg(dev, MCU_WM_UNI_CMD(ALL_STA_INFO),
 				 &req, sizeof(req), false);
 }
 
@@ -4546,16 +5925,39 @@ int mt7996_mcu_set_sniffer_mode(struct mt7996_phy *phy, bool enabled)
 		.len = cpu_to_le16(sizeof(req) - 4),
 		.enable = enabled,
 	};
-
 	return mt76_mcu_send_msg(&dev->mt76, MCU_WM_UNI_CMD(SNIFFER), &req,
 				 sizeof(req), true);
 }
 
-int mt7996_mcu_set_txpower_sku(struct mt7996_phy *phy)
+static void
+mt7996_update_max_txpower_cur(struct mt7996_phy *phy, int tx_power)
+{
+	struct mt76_phy *mphy = phy->mt76;
+	struct ieee80211_channel *chan = mphy->main_chan;
+	int e2p_power_limit = 0;
+
+	if (chan == NULL) {
+		mphy->txpower_cur = tx_power;
+		return;
+	}
+
+	e2p_power_limit = mt7996_eeprom_get_target_power(phy->dev, chan);
+	e2p_power_limit += mt7996_eeprom_get_power_delta(phy->dev, chan->band);
+
+	if (phy->sku_limit_en)
+		mphy->txpower_cur = min_t(int, e2p_power_limit, tx_power);
+	else
+		mphy->txpower_cur = e2p_power_limit;
+}
+
+int mt7996_mcu_set_txpower_sku(struct mt7996_phy *phy,
+			       struct ieee80211_bss_conf *conf)
 {
 #define TX_POWER_LIMIT_TABLE_RATE	0
+#define TX_POWER_LIMIT_TABLE_PATH	1
 	struct mt7996_dev *dev = phy->dev;
 	struct mt76_phy *mphy = phy->mt76;
+	struct ieee80211_hw *hw = mphy->hw;
 	struct tx_power_limit_table_ctrl {
 		u8 __rsv1[4];
 
@@ -4572,13 +5974,22 @@ int mt7996_mcu_set_txpower_sku(struct mt7996_phy *phy)
 		.band_idx = phy->mt76->band_idx,
 	};
 	struct mt76_power_limits la = {};
+	struct mt76_power_path_limits la_path = {};
 	struct sk_buff *skb;
-	int i, tx_power;
+	int i, ret, txpower_limit;
+
+	if (hw->conf.power_level == INT_MIN)
+		hw->conf.power_level = 127;
+	txpower_limit = mt7996_get_power_bound(phy, conf->txpower);
 
-	tx_power = mt7996_get_power_bound(phy, phy->txpower);
-	tx_power = mt76_get_rate_power_limits(mphy, mphy->chandef.chan,
-					      &la, tx_power);
-	mphy->txpower_cur = tx_power;
+	if (phy->sku_limit_en) {
+		txpower_limit = mt76_get_rate_power_limits(mphy, mphy->chandef.chan,
+							   &la, &la_path, txpower_limit);
+		mt7996_update_max_txpower_cur(phy, txpower_limit);
+	} else {
+		mt7996_update_max_txpower_cur(phy, txpower_limit);
+		return 0;
+	}
 
 	skb = mt76_mcu_msg_alloc(&dev->mt76, NULL,
 				 sizeof(req) + MT7996_SKU_PATH_NUM);
@@ -4608,6 +6019,34 @@ int mt7996_mcu_set_txpower_sku(struct mt7996_phy *phy)
 	/* padding */
 	skb_put_zero(skb, MT7996_SKU_PATH_NUM - MT7996_SKU_RATE_NUM);
 
+	ret = mt76_mcu_skb_send_msg(&dev->mt76, skb,
+				    MCU_WM_UNI_CMD(TXPOWER), true);
+	if (ret)
+		return ret;
+
+	/* only set per-path power table when it's configured */
+	if (!phy->sku_path_en)
+		return 0;
+
+	skb = mt76_mcu_msg_alloc(&dev->mt76, NULL,
+				 sizeof(req) + MT7996_SKU_PATH_NUM);
+	if (!skb)
+		return -ENOMEM;
+	req.power_limit_type = TX_POWER_LIMIT_TABLE_PATH;
+
+	skb_put_data(skb, &req, sizeof(req));
+	skb_put_data(skb, &la_path.cck, sizeof(la_path.cck));
+	skb_put_data(skb, &la_path.ofdm, sizeof(la_path.ofdm));
+	skb_put_data(skb, &la_path.ofdm_bf, sizeof(la_path.ofdm_bf));
+
+	for (i = 0; i < 32; i++) {
+		bool bf = i % 2;
+		u8 idx = i / 2;
+		s8 *buf = bf ? la_path.ru_bf[idx] : la_path.ru[idx];
+
+		skb_put_data(skb, buf, sizeof(la_path.ru[0]));
+	}
+
 	return mt76_mcu_skb_send_msg(&dev->mt76, skb,
 				     MCU_WM_UNI_CMD(TXPOWER), true);
 }
@@ -4624,3 +6063,664 @@ int mt7996_mcu_cp_support(struct mt7996_dev *dev, u8 mode)
 	return mt76_mcu_send_msg(&dev->mt76, MCU_WA_EXT_CMD(CP_SUPPORT),
 				 &cp_mode, sizeof(cp_mode), true);
 }
+
+int mt7996_mcu_set_pp_en(struct mt7996_phy *phy, u8 mode, u16 bitmap)
+{
+	struct mt7996_dev *dev = phy->dev;
+	bool pp_auto = (mode == PP_FW_MODE);
+	struct {
+		u8 _rsv1[4];
+
+		__le16 tag;
+		__le16 len;
+		u8 mgmt_mode;
+		u8 band_idx;
+		u8 force_bitmap_ctrl;
+		u8 auto_mode;
+		__le16 bitmap;
+		u8 _rsv2[2];
+	} __packed req = {
+		.tag = cpu_to_le16(UNI_CMD_PP_EN_CTRL),
+		.len = cpu_to_le16(sizeof(req) - 4),
+
+		.mgmt_mode = !pp_auto,
+		.band_idx = phy->mt76->band_idx,
+		.force_bitmap_ctrl = (mode == PP_USR_MODE) ? 2 : 0,
+		.auto_mode = pp_auto,
+		.bitmap = cpu_to_le16(bitmap),
+	};
+
+	if (phy->chanctx->chandef.chan->band == NL80211_BAND_2GHZ ||
+	    mode > PP_USR_MODE)
+		return 0;
+
+	if (bitmap && phy->punct_bitmap == bitmap)
+		return 0;
+
+	phy->punct_bitmap = bitmap;
+	phy->pp_mode = mode;
+
+	return mt76_mcu_send_msg(&dev->mt76, MCU_WM_UNI_CMD(PP),
+				 &req, sizeof(req), false);
+}
+
+int mt7996_mcu_set_tx_power_ctrl(struct mt7996_phy *phy, u8 power_ctrl_id, u8 data)
+{
+	struct mt7996_dev *dev = phy->dev;
+	struct tx_power_ctrl req = {
+		.tag = cpu_to_le16(power_ctrl_id),
+		.len = cpu_to_le16(sizeof(req) - 4),
+		.power_ctrl_id = power_ctrl_id,
+		.band_idx = phy->mt76->band_idx,
+	};
+
+	switch (power_ctrl_id) {
+	case UNI_TXPOWER_SKU_POWER_LIMIT_CTRL:
+		req.sku_enable = !!data;
+		break;
+	case UNI_TXPOWER_PERCENTAGE_CTRL:
+		req.percentage_ctrl_enable = !!data;
+		break;
+	case UNI_TXPOWER_PERCENTAGE_DROP_CTRL:
+		req.power_drop_level = data;
+		break;
+	case UNI_TXPOWER_BACKOFF_POWER_LIMIT_CTRL:
+		req.bf_backoff_enable = !!data;
+		break;
+	case UNI_TXPOWER_ATE_MODE_CTRL:
+		req.ate_mode_enable = !!data;
+		break;
+	default:
+		req.sku_enable = !!data;
+	}
+
+	return mt76_mcu_send_msg(&dev->mt76, MCU_WM_UNI_CMD(TXPOWER),
+				 &req, sizeof(req), false);
+}
+
+int mt7996_mcu_set_scs_stats(struct mt7996_phy *phy)
+{
+	struct mt7996_scs_ctrl ctrl = phy->scs_ctrl;
+	struct {
+		u8 band_idx;
+		u8 _rsv[3];
+
+		__le16 tag;
+		__le16 len;
+
+		u8 _rsv2[6];
+		s8 min_rssi;
+		u8 _rsv3;
+	} __packed req = {
+		.band_idx = phy->mt76->band_idx,
+		.tag = cpu_to_le16(UNI_CMD_SCS_SEND_DATA),
+		.len = cpu_to_le16(sizeof(req) - 4),
+
+		.min_rssi = ctrl.sta_min_rssi,
+	};
+
+	return mt76_mcu_send_msg(&phy->dev->mt76, MCU_WM_UNI_CMD(SCS),
+				 &req, sizeof(req), false);
+}
+
+void mt7996_sta_rssi_work(void *data, struct ieee80211_sta *sta)
+{
+	struct mt7996_sta *msta = (struct mt7996_sta *)sta->drv_priv;
+	struct mt7996_link_sta *mlink;
+	struct mt7996_phy *poll_phy = (struct mt7996_phy *) data;
+
+	mutex_lock(&poll_phy->dev->mt76.mutex);
+	mlink = mlink_dereference_protected(msta, 0);
+	if (!mlink)
+		goto out;
+
+	if (poll_phy->scs_ctrl.sta_min_rssi > mlink->ack_signal)
+		poll_phy->scs_ctrl.sta_min_rssi = mlink->ack_signal;
+out:
+	mutex_unlock(&poll_phy->dev->mt76.mutex);
+}
+
+void mt7996_mcu_scs_sta_poll(struct work_struct *work)
+{
+	struct mt7996_dev *dev = container_of(work, struct mt7996_dev,
+				 scs_work.work);
+	bool scs_enable_flag = false;
+	u8 i;
+
+	for (i = 0; i < __MT_MAX_BAND; i++) {
+		struct mt7996_phy *phy;
+
+		switch (i) {
+		case MT_BAND0:
+			phy = dev->mphy.priv;
+			break;
+		case MT_BAND1:
+			phy = mt7996_phy2(dev);
+			break;
+		case MT_BAND2:
+			phy = mt7996_phy3(dev);
+			break;
+		default:
+			phy = NULL;
+			break;
+		}
+
+		if (!phy || !test_bit(MT76_STATE_RUNNING, &phy->mt76->state) ||
+		    !phy->scs_ctrl.scs_enable)
+			continue;
+
+		ieee80211_iterate_stations_atomic(phy->mt76->hw,
+						  mt7996_sta_rssi_work, phy);
+
+		scs_enable_flag = true;
+		if (mt7996_mcu_set_scs_stats(phy))
+			dev_err(dev->mt76.dev, "Failed to send scs mcu cmd\n");
+		phy->scs_ctrl.sta_min_rssi = 0;
+	}
+
+	if (scs_enable_flag)
+		ieee80211_queue_delayed_work(mt76_hw(dev), &dev->scs_work, HZ);
+}
+
+
+int mt7996_mcu_set_scs(struct mt7996_phy *phy, u8 enable)
+{
+	struct mt7996_dev *dev = phy->dev;
+	struct {
+		u8 band_idx;
+		u8 _rsv[3];
+
+		__le16 tag;
+		__le16 len;
+
+		u8 scs_enable;
+		u8 _rsv2[3];
+	} __packed req = {
+		.band_idx = phy->mt76->band_idx,
+		.tag = cpu_to_le16(UNI_CMD_SCS_ENABLE),
+		.len = cpu_to_le16(sizeof(req) - 4),
+		.scs_enable = enable,
+	};
+
+	phy->scs_ctrl.scs_enable = enable;
+
+	if (enable == SCS_ENABLE)
+		ieee80211_queue_delayed_work(mt76_hw(dev), &dev->scs_work, HZ);
+
+	return mt76_mcu_send_msg(&phy->dev->mt76, MCU_WM_UNI_CMD(SCS),
+				 &req, sizeof(req), false);
+}
+
+int mt7996_mcu_set_vow_drr_ctrl(struct mt7996_phy *phy,
+				struct mt7996_bss_conf *mconf,
+				struct mt7996_link_sta *mlink,
+				enum vow_drr_ctrl_id id)
+{
+	struct mt7996_vow_sta_ctrl *vow = mlink ? &mlink->vow : NULL;
+	u32 val = 0;
+	struct {
+		u8 __rsv1[4];
+
+		__le16 tag;
+		__le16 len;
+		__le16 wlan_idx;
+		u8 band_idx;
+		u8 wmm_idx;
+		__le32 ctrl_id;
+
+		union {
+			__le32 val;
+			u8 drr_quantum[VOW_DRR_QUANTUM_NUM];
+		};
+
+		u8 __rsv2[3];
+		u8 omac_idx;
+	} __packed req = {
+		.tag = cpu_to_le16(UNI_VOW_DRR_CTRL),
+		.len = cpu_to_le16(sizeof(req) - 4),
+		.wlan_idx = cpu_to_le16(mlink ? mlink->wcid.idx : 0),
+		.band_idx = phy->mt76->band_idx,
+		.wmm_idx = mlink ? mconf->mt76.wmm_idx : 0,
+		.ctrl_id = cpu_to_le32(id),
+		.omac_idx = mlink ? mconf->mt76.omac_idx : 0
+	};
+
+	switch (id) {
+	case VOW_DRR_CTRL_STA_ALL:
+		val |= FIELD_PREP(MT7996_DRR_STA_BSS_GRP_MASK, vow->bss_grp_idx);
+		val |= FIELD_PREP(MT7996_DRR_STA_AC0_QNTM_MASK, vow->drr_quantum[IEEE80211_AC_BK]);
+		val |= FIELD_PREP(MT7996_DRR_STA_AC1_QNTM_MASK, vow->drr_quantum[IEEE80211_AC_BE]);
+		val |= FIELD_PREP(MT7996_DRR_STA_AC2_QNTM_MASK, vow->drr_quantum[IEEE80211_AC_VI]);
+		val |= FIELD_PREP(MT7996_DRR_STA_AC3_QNTM_MASK, vow->drr_quantum[IEEE80211_AC_VO]);
+		req.val = cpu_to_le32(val);
+		break;
+	case VOW_DRR_CTRL_STA_BSS_GROUP:
+		req.val = cpu_to_le32(vow->bss_grp_idx);
+		break;
+	case VOW_DRR_CTRL_AIRTIME_DEFICIT_BOUND:
+		req.val = cpu_to_le32(phy->dev->vow.max_deficit);
+		break;
+	case VOW_DRR_CTRL_AIRTIME_QUANTUM_ALL:
+		memcpy(req.drr_quantum, phy->dev->vow.drr_quantum, VOW_DRR_QUANTUM_NUM);
+		break;
+	case VOW_DRR_CTRL_STA_PAUSE:
+		req.val = cpu_to_le32(vow->paused);
+		break;
+	default:
+		dev_err(phy->dev->mt76.dev, "Unknown VoW DRR Control ID: %u\n", id);
+		return -EINVAL;
+	}
+
+	return mt76_mcu_send_msg(&phy->dev->mt76, MCU_WM_UNI_CMD(VOW),
+	                         &req, sizeof(req), true);
+}
+
+int mt7996_mcu_set_vow_feature_ctrl(struct mt7996_phy *phy)
+{
+	struct mt7996_vow_ctrl *vow = &phy->dev->vow;
+	struct {
+		u8 __rsv1[4];
+
+		__le16 tag;
+		__le16 len;
+
+		/* DW0 */
+		__le16 apply_bwc_enable_per_grp;
+		__le16 apply_bwc_refill_period		: 1;
+		__le16 __rsv2				: 3;
+		__le16 apply_band1_search_rule		: 1;
+		__le16 apply_band0_search_rule		: 1;
+		__le16 __rsv3				: 3;
+		__le16 apply_watf_enable		: 1;
+		__le16 __rsv4				: 2;
+		__le16 apply_grp_no_change_in_txop	: 1;
+		__le16 apply_atf_enable			: 1;
+		__le16 apply_bwc_token_refill_enable	: 1;
+		__le16 apply_bwc_enable			: 1;
+
+		/* DW1 */
+		__le16 apply_bwc_check_time_token_per_grp;
+		__le16 __rsv5;
+
+		/* DW2 */
+		__le16 apply_bwc_check_len_token_per_grp;
+		__le16 __rsv6;
+
+		/* DW3 */
+		u8 band_idx;
+		u8 __rsv7[3];
+
+		/* DW4 */
+		__le32 __rsv8;
+
+		/* DW5 */
+		__le16 bwc_enable_per_grp;
+		__le16 bwc_refill_period	: 3;
+		__le16 __rsv9			: 1;
+		__le16 band1_search_rule	: 1;
+		__le16 band0_search_rule	: 1;
+		__le16 __rsv10			: 3;
+		__le16 watf_enable		: 1;
+		__le16 __rsv11			: 2;
+		__le16 grp_no_change_in_txop	: 1;
+		__le16 atf_enable		: 1;
+		__le16 bwc_token_refill_enable	: 1;
+		__le16 bwc_enable		: 1;
+
+		/* DW6 */
+		__le16 bwc_check_time_token_per_grp;
+		__le16 __rsv12;
+
+		/* DW7 */
+		__le16 bwc_check_len_token_per_grp;
+		__le16 __rsv13;
+
+		/* DW8 */
+		__le32 apply_atf_rts_sta_lock		: 1;
+		__le32 atf_rts_sta_lock			: 1;
+		__le32 apply_atf_keep_quantum		: 1;
+		__le32 atf_keep_quantum			: 1;
+		__le32 apply_tx_cnt_mode_ctrl		: 1;
+		__le32 tx_cnt_mode_ctrl			: 4;
+		__le32 apply_tx_measure_mode_enable	: 1;
+		__le32 tx_measure_mode_enable		: 1;
+		__le32 apply_backoff_ctrl		: 1;
+		__le32 backoff_bound_enable		: 1;
+		__le32 backoff_bound			: 5;
+		__le32 apply_atf_rts_fail_charge	: 1;
+		__le32 atf_rts_fail_charge		: 1;
+		__le32 apply_zero_eifs			: 1;
+		__le32 zero_eifs			: 1;
+		__le32 apply_rx_rifs_enable		: 1;
+		__le32 rx_rifs_enable			: 1;
+		__le32 apply_vow_ctrl			: 1;
+		__le32 vow_ctrl_val			: 1;
+		__le32 vow_ctrl_bit			: 5;
+		__le32 __rsv14				: 1;
+
+		/* DW9 */
+		__le32 apply_spl_sta_num	: 1;
+		__le32 spl_sta_num		: 3;
+		__le32 dbg_lvl			: 2;
+		__le32 apply_atf_sch_ctrl	: 1;
+		__le32 atf_sch_type		: 2;
+		__le32 atf_sch_policy		: 2;
+		__le32 __rsv15			: 21;
+	} __packed req = {
+		.tag = cpu_to_le16(UNI_VOW_FEATURE_CTRL),
+		.len = cpu_to_le16(sizeof(req) - 4),
+		/* DW0 */
+		.apply_bwc_enable_per_grp = cpu_to_le16(0xffff),
+		.apply_bwc_refill_period = true,
+		.apply_band1_search_rule = true,
+		.apply_band0_search_rule = true,
+		.apply_watf_enable = true,
+		.apply_grp_no_change_in_txop = true,
+		.apply_atf_enable = true,
+		.apply_bwc_token_refill_enable = true,
+		.apply_bwc_enable = true,
+		/* DW1 */
+		.apply_bwc_check_time_token_per_grp = cpu_to_le16(0xffff),
+		/* DW2 */
+		.apply_bwc_check_len_token_per_grp = cpu_to_le16(0xffff),
+		/* DW3 */
+		.band_idx = phy->mt76->band_idx,
+		/* DW5 */
+		.bwc_enable_per_grp = cpu_to_le16(0xffff),
+		.bwc_refill_period = VOW_REFILL_PERIOD_32US,
+		.band1_search_rule = VOW_SEARCH_WMM_FIRST,
+		.band0_search_rule = VOW_SEARCH_WMM_FIRST,
+		.watf_enable = vow->watf_enable,
+		.grp_no_change_in_txop = true,
+		.atf_enable = vow->atf_enable,
+		.bwc_token_refill_enable = true,
+		.bwc_enable = false,
+		/* DW6 */
+		.bwc_check_time_token_per_grp = cpu_to_le16(0x0),
+		/* DW7 */
+		.bwc_check_len_token_per_grp = cpu_to_le16(0x0),
+		/* DW8 */
+		.apply_atf_rts_sta_lock = false,
+		.apply_atf_keep_quantum = true,
+		.atf_keep_quantum = true,
+		.apply_tx_cnt_mode_ctrl = false,
+		.apply_tx_measure_mode_enable = false,
+		.apply_backoff_ctrl = false,
+		.apply_atf_rts_fail_charge = false,
+		.apply_zero_eifs = false,
+		.apply_rx_rifs_enable = false,
+		.apply_vow_ctrl = true,
+		.vow_ctrl_val = true,
+		/* Reset DRR table when SER occurs. */
+		.vow_ctrl_bit = 26,
+		/* DW9 */
+		.apply_spl_sta_num = false,
+		.dbg_lvl = 0,
+		.apply_atf_sch_ctrl = true,
+		.atf_sch_type = vow->sch_type,
+		.atf_sch_policy = vow->sch_policy
+	};
+
+	return mt76_mcu_send_msg(&phy->dev->mt76, MCU_WM_UNI_CMD(VOW),
+	                         &req, sizeof(req), true);
+}
+
+#ifdef CONFIG_MTK_VENDOR
+void mt7996_set_wireless_vif(void *data, u8 *mac, struct ieee80211_vif *vif)
+{
+	u8 mode, val, band_idx;
+	struct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;
+	struct mt7996_phy *phy;
+	struct mt76_phy *mphy;
+
+	mode = FIELD_GET(RATE_CFG_MODE, *((u32 *)data));
+	val = FIELD_GET(RATE_CFG_VAL, *((u32 *)data));
+	band_idx = FIELD_GET(RATE_CFG_BAND_IDX, *((u32 *)data));
+
+	if (!mt7996_band_valid(mvif->dev, band_idx))
+		goto error;
+
+	mphy = mvif->dev->mt76.phys[band_idx];
+	if (!mphy)
+		goto error;
+
+	phy = (struct mt7996_phy *)mphy->priv;
+
+	switch (mode) {
+	case RATE_PARAM_FIXED_OFDMA:
+		if (val == 3)
+			phy->muru_onoff |= OFDMA_DL;
+		else
+			phy->muru_onoff |= val;
+		break;
+	case RATE_PARAM_FIXED_MIMO:
+		if (val == 0)
+			phy->muru_onoff |= MUMIMO_DL_CERT | MUMIMO_DL;
+		else
+			phy->muru_onoff |= MUMIMO_UL;
+		break;
+	case RATE_PARAM_AUTO_MU:
+		phy->muru_onoff = val & GENMASK(3, 0);
+		break;
+	}
+
+	return;
+error:
+	dev_err(mvif->dev->mt76.dev, "Invalid band_idx to config\n");
+	return;
+}
+
+void mt7996_set_beacon_vif(void *data, u8 *mac, struct ieee80211_vif *vif)
+{
+	struct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;
+	struct ieee80211_hw *hw = mvif->deflink.phy->mt76->hw;
+	u8 val = *((u8 *)data);
+
+	vif->bss_conf.enable_beacon = val;
+
+	mt7996_mcu_add_beacon(hw, &vif->bss_conf, &mvif->deflink, val);
+}
+
+static int mt7996_mcu_set_csi_enable(struct mt7996_phy *phy, u16 tag)
+{
+	struct {
+		u8 band;
+		u8 rsv1[3];
+
+		__le16 tag;
+		__le16 len;
+	} __packed req = {
+		.band = phy->mt76->band_idx,
+		.tag = cpu_to_le16(tag),
+		.len = cpu_to_le16(sizeof(req) - 4),
+	};
+
+	return mt76_mcu_send_msg(&phy->dev->mt76, MCU_WM_UNI_CMD(CSI_CTRL), &req,
+				sizeof(req), false);
+}
+
+static int mt7996_mcu_set_csi_frame_type(struct mt7996_phy *phy, u16 tag, u8 type_idx, u32 type)
+{
+	struct {
+		u8 band;
+		u8 rsv1[3];
+
+		__le16 tag;
+		__le16 len;
+		u8 frame_type_idx;
+		u8 frame_type;
+		u8 rsv2[2];
+	} __packed req = {
+		.band = phy->mt76->band_idx,
+		.tag = cpu_to_le16(tag),
+		.len = cpu_to_le16(sizeof(req) - 4),
+		.frame_type_idx = type_idx,
+		.frame_type = type,
+	};
+
+	return mt76_mcu_send_msg(&phy->dev->mt76, MCU_WM_UNI_CMD(CSI_CTRL), &req,
+				sizeof(req), false);
+}
+
+static int mt7996_mcu_set_csi_chain_filter(struct mt7996_phy *phy, u16 tag, u8 func, u32 value)
+{
+	struct {
+		u8 band;
+		u8 rsv1[3];
+
+		__le16 tag;
+		__le16 len;
+		u8 function;
+		u8 chain_value;
+		u8 rsv2[2];
+	} __packed req = {
+		.band = phy->mt76->band_idx,
+		.tag = cpu_to_le16(tag),
+		.len = cpu_to_le16(sizeof(req) - 4),
+		.function = func,
+		.chain_value = value,
+	};
+
+	return mt76_mcu_send_msg(&phy->dev->mt76, MCU_WM_UNI_CMD(CSI_CTRL), &req,
+				sizeof(req), false);
+}
+
+static int mt7996_mcu_set_csi_sta_filter(struct mt7996_phy *phy, u16 tag, u32 op, u8 *sta_mac)
+{
+	struct {
+		u8 band;
+		u8 rsv1[3];
+
+		__le16 tag;
+		__le16 len;
+		u8 operation;
+		u8 rsv2[1];
+		u8 mac[6];
+	} __packed req = {
+		.band = phy->mt76->band_idx,
+		.tag = cpu_to_le16(tag),
+		.len = cpu_to_le16(sizeof(req) - 4),
+		.operation = op,
+	};
+
+	memcpy(req.mac, sta_mac, ETH_ALEN);
+
+	return mt76_mcu_send_msg(&phy->dev->mt76, MCU_WM_UNI_CMD(CSI_CTRL), &req,
+				sizeof(req), false);
+}
+
+static int mt7996_mcu_set_csi_active_mode(struct mt7996_phy *phy, u16 tag,
+					  u32 interval, u8 frame_idx, u8 subframe_idx, u32 bitmap)
+{
+	struct {
+		u8 band;
+		u8 rsv1[3];
+
+		__le16 tag;
+		__le16 len;
+		__le16 interval; /* uint: ms */
+		u8 frame_type_idx;
+		u8 subframe_type_idx;
+		__le32 bitmap; /* sta wcid bitmap */
+		u8 rsv2[4];
+	} __packed req = {
+		.band = phy->mt76->band_idx,
+		.tag = cpu_to_le16(tag),
+		.len = cpu_to_le16(sizeof(req) - 4),
+		.interval = cpu_to_le16(interval),
+		.frame_type_idx = frame_idx,
+		.subframe_type_idx = subframe_idx,
+		.bitmap = cpu_to_le32(bitmap),
+	};
+
+	return mt76_mcu_send_msg(&phy->dev->mt76, MCU_WM_UNI_CMD(CSI_CTRL), &req,
+				sizeof(req), false);
+}
+
+void mt7996_csi_wcid_bitmap_update(void *data, struct ieee80211_sta *sta)
+{
+	struct mt7996_sta *msta = (struct mt7996_sta *)sta->drv_priv;
+	struct mt7996_phy *phy = msta->vif->deflink.phy;
+	struct csi_bitmap_info_update *sta_info = (struct csi_bitmap_info_update *)data;
+	u16 wcid = 0;
+
+#define CSI_ACTIVE_MODE_ADD 1
+#define CSI_ACTIVE_MODE_REMOVE 0
+
+	if (!memcmp(sta_info->addr, sta->addr, ETH_ALEN)) {
+		wcid = msta->deflink.wcid.idx;
+
+		/* active mode: only support station with wcid less than 32 */
+		if (wcid > 32)
+			return;
+
+		if (sta_info->action == CSI_ACTIVE_MODE_ADD)
+			phy->csi.active_bitmap |= BIT(wcid);
+		else if (sta_info->action == CSI_ACTIVE_MODE_REMOVE)
+			phy->csi.active_bitmap &= ~(BIT(wcid));
+	}
+}
+
+int mt7996_mcu_set_csi(struct mt7996_phy *phy, u8 mode,
+			u8 cfg, u8 v1, u32 v2, u8 *mac_addr)
+{
+	switch (mode) {
+	case CSI_CONTROL_MODE_STOP:
+		return mt7996_mcu_set_csi_enable(phy, UNI_CMD_CSI_STOP);
+	case CSI_CONTROL_MODE_START:
+		return mt7996_mcu_set_csi_enable(phy, UNI_CMD_CSI_START);
+	case CSI_CONTROL_MODE_SET:
+		switch (cfg) {
+		case CSI_CONFIG_FRAME_TYPE:
+			if (v2 > 255)
+				return -EINVAL;
+
+			return mt7996_mcu_set_csi_frame_type(phy,
+					UNI_CMD_CSI_SET_FRAME_TYPE, v1, v2);
+		case CSI_CONFIG_CHAIN_FILTER:
+			if (v2 > 255)
+				return -EINVAL;
+
+			return mt7996_mcu_set_csi_chain_filter(phy,
+					UNI_CMD_CSI_SET_CHAIN_FILTER, v1, v2);
+		case CSI_CONFIG_STA_FILTER:
+			if (!is_valid_ether_addr(mac_addr))
+				return -EINVAL;
+
+			if (v2 > 255)
+				return -EINVAL;
+
+			return mt7996_mcu_set_csi_sta_filter(phy,
+					UNI_CMD_CSI_SET_STA_FILTER, v2, mac_addr);
+		case CSI_CONFIG_ACTIVE_MODE:
+			if (is_valid_ether_addr(mac_addr)) {
+				struct csi_bitmap_info_update sta_info;
+
+				if (v2 > 255)
+					return -EINVAL;
+
+				memcpy(sta_info.addr, mac_addr, ETH_ALEN);
+				sta_info.action = v2;
+
+				ieee80211_iterate_stations_atomic(phy->mt76->hw,
+								mt7996_csi_wcid_bitmap_update, &sta_info);
+				return 0;
+			} else {
+				u8 frame_type = v1 & 0x3;
+				u8 frame_subtype = (v1 & 0x3c) >> 2;
+
+					/* active mode: max interval is 3000ms */
+					if (v2 > 3000)
+						return -EINVAL;
+
+				return mt7996_mcu_set_csi_active_mode(phy, UNI_CMD_CSI_SET_ACTIVE_MODE,
+						v2, frame_type, frame_subtype, phy->csi.active_bitmap);
+			}
+		default:
+			return -EINVAL;
+		}
+	default:
+		return -EINVAL;
+	}
+}
+#endif
diff --git a/mt7996/mcu.h b/mt7996/mcu.h
index 324e0dd1..4650a88b 100644
--- a/mt7996/mcu.h
+++ b/mt7996/mcu.h
@@ -119,6 +119,20 @@ struct mt7996_mcu_rdd_report {
 	} hw_pulse[32];
 } __packed;
 
+struct mt7996_rdd_ctrl {
+	u8 _rsv[4];
+
+	__le16 tag;
+	__le16 len;
+
+	u8 ctrl;
+	u8 rdd_idx;
+	u8 rdd_rx_sel;
+	u8 val;
+	u8 disable_timer;
+	u8 rsv[3];
+} __packed;
+
 struct mt7996_mcu_background_chain_ctrl {
 	u8 _rsv[4];
 
@@ -157,6 +171,16 @@ struct mt7996_mcu_eeprom {
 	__le16 buf_len;
 } __packed;
 
+struct mt7996_mcu_eeprom_info {
+	u8 _rsv[4];
+
+	__le16 tag;
+	__le16 len;
+	__le32 addr;
+	__le32 valid;
+	u8 data[MT7996_EEPROM_BLOCK_SIZE];
+} __packed;
+
 struct mt7996_mcu_phy_rx_info {
 	u8 category;
 	u8 rate;
@@ -175,6 +199,23 @@ struct mt7996_mcu_mib {
 	__le64 data;
 } __packed;
 
+struct per_sta_rssi {
+	__le16 wlan_idx;
+	u8 __rsv[2];
+	u8 rcpi[4];
+} __packed;
+
+struct mt7996_mcu_per_sta_info_event {
+	u8 __rsv[4];
+
+	__le16 tag;
+	__le16 len;
+
+	union {
+		struct per_sta_rssi rssi[0];
+	};
+} __packed;
+
 struct all_sta_trx_rate {
 	__le16 wlan_idx;
 	u8 __rsv1[2];
@@ -220,6 +261,13 @@ struct mt7996_mcu_all_sta_info_event {
 			__le32 tx_msdu_cnt;
 			__le32 rx_msdu_cnt;
 		} __packed, msdu_cnt);
+
+		DECLARE_FLEX_ARRAY(struct {
+			__le16 wlan_idx;
+			u8 rsv[2];
+			__le32 tx[IEEE80211_NUM_ACS];
+			__le32 rx[IEEE80211_NUM_ACS];
+		} __packed, airtime);
 	} __packed;
 } __packed;
 
@@ -249,7 +297,9 @@ struct mt7996_mcu_wed_rro_ba_delete_event {
 	__le16 len;
 
 	__le16 session_id;
-	u8 __rsv2[2];
+	__le16 mld_id;
+	u8 tid;
+	u8 __rsv[3];
 } __packed;
 
 enum  {
@@ -301,7 +351,8 @@ enum {
 	MCU_FW_LOG_WM,
 	MCU_FW_LOG_WA,
 	MCU_FW_LOG_TO_HOST,
-	MCU_FW_LOG_RELAY = 16
+	MCU_FW_LOG_RELAY = 16,
+	MCU_FW_LOG_RELAY_IDX = 40
 };
 
 enum {
@@ -319,11 +370,27 @@ enum {
 	MCU_WA_PARAM_CMD_DEBUG,
 };
 
+#define BSS_ACQ_PKT_CNT_BSS_NUM		24
+#define BSS_ACQ_PKT_CNT_BSS_BITMAP_ALL	0x00ffffff
+#define BSS_ACQ_PKT_CNT_READ_CLR	BIT(31)
+#define WMM_PKT_THRESHOLD		100
+
+struct mt7996_mcu_bss_acq_pkt_cnt_event {
+	struct mt7996_mcu_rxd rxd;
+
+	__le32 bss_bitmap;
+	struct {
+		__le32 cnt[IEEE80211_NUM_ACS];
+	} __packed bss[BSS_ACQ_PKT_CNT_BSS_NUM];
+} __packed;
+
 enum {
 	MCU_WA_PARAM_PDMA_RX = 0x04,
 	MCU_WA_PARAM_CPU_UTIL = 0x0b,
-	MCU_WA_PARAM_RED = 0x0e,
+	MCU_WA_PARAM_RED_EN = 0x0e,
+	MCU_WA_PARAM_BSS_ACQ_PKT_CNT = 0x12,
 	MCU_WA_PARAM_HW_PATH_HIF_VER = 0x2f,
+	MCU_WA_PARAM_RED_CONFIG = 0x40,
 };
 
 enum mcu_mmps_mode {
@@ -506,6 +573,13 @@ struct sta_rec_ba_uni {
 	u8 __rsv[3];
 } __packed;
 
+struct sta_rec_tx_cap {
+	__le16 tag;
+	__le16 len;
+	u8 ampdu_limit_en;
+	u8 rsv[3];
+} __packed;
+
 struct sta_rec_eht {
 	__le16 tag;
 	__le16 len;
@@ -625,6 +699,35 @@ struct sta_rec_hdr_trans {
 	u8 mesh;
 } __packed;
 
+struct sta_rec_mld_setup {
+	__le16 tag;
+	__le16 len;
+	u8 mld_addr[ETH_ALEN];
+	__le16 primary_id;
+	__le16 seconed_id;
+	__le16 setup_wcid;
+	u8 link_num;
+	u8 info;
+	u8 __rsv[2];
+	u8 link_info[];
+} __packed;
+
+struct mld_setup_link {
+	__le16 wcid;
+	u8 bss_idx;
+	u8 __rsv[1];
+} __packed;
+
+struct sta_rec_eht_mld {
+	__le16 tag;
+	__le16 len;
+	u8 nsep;
+	u8 __rsv1[2];
+	u8 str_cap[__MT_MAX_BAND];
+	__le16 eml_cap;
+	u8 __rsv2[4];
+} __packed;
+
 struct hdr_trans_en {
 	__le16 tag;
 	__le16 len;
@@ -675,6 +778,22 @@ struct bf_sounding_on {
 	__le32 snd_period;
 } __packed;
 
+enum sounding_mode {
+	SU_SOUNDING,
+	MU_SOUNDING,
+	SU_PERIODIC_SOUNDING,
+	MU_PERIODIC_SOUNDING,
+	BF_PROCESSING,
+	TXCMD_NONTB_SU_SOUNDING,
+	TXCMD_VHT_MU_SOUNDING,
+	TXCMD_TB_PER_BRP_SOUNDING,
+	TXCMD_TB_SOUNDING,
+
+	/* keep last */
+	NUM_SOUNDING_MODE,
+	SOUNDING_MODE_MAX = NUM_SOUNDING_MODE - 1,
+};
+
 struct bf_hw_en_status_update {
 	__le16 tag;
 	__le16 len;
@@ -700,6 +819,25 @@ union bf_tag_tlv {
 	struct bf_mod_en_ctrl bf_mod_en;
 };
 
+enum {
+	BF_SOUNDING_OFF = 0,
+	BF_SOUNDING_ON = 1,
+	BF_DATA_PACKET_APPLY = 2,
+	BF_PFMU_TAG_READ = 5,
+	BF_PFMU_TAG_WRITE = 6,
+	BF_STA_REC_READ = 11,
+	BF_PHASE_CALIBRATION = 12,
+	BF_IBF_PHASE_COMP = 13,
+	BF_PROFILE_WRITE_20M_ALL = 15,
+	BF_HW_EN_UPDATE = 17,
+	BF_MOD_EN_CTRL = 20,
+	BF_FBRPT_DBG_INFO_READ = 23,
+	BF_TXSND_INFO = 24,
+	BF_CMD_TXCMD = 27,
+	BF_CFG_PHY = 28,
+	BF_PROFILE_WRITE_20M_ALL_5X5 = 30,
+};
+
 struct ra_rate {
 	__le16 wlan_idx;
 	u8 mode;
@@ -744,13 +882,23 @@ enum {
 	RATE_PARAM_FIXED_MCS,
 	RATE_PARAM_FIXED_GI = 11,
 	RATE_PARAM_AUTO = 20,
+#ifdef CONFIG_MTK_VENDOR
+	RATE_PARAM_FIXED_MIMO = 30,
+	RATE_PARAM_FIXED_OFDMA = 31,
+	RATE_PARAM_AUTO_MU = 32,
+#endif
 };
 
-enum {
-	BF_SOUNDING_ON = 1,
-	BF_HW_EN_UPDATE = 17,
-	BF_MOD_EN_CTRL = 20,
-};
+#define RATE_CFG_BAND_IDX	GENMASK(17, 16)
+#define RATE_CFG_MODE	GENMASK(15, 8)
+#define RATE_CFG_VAL	GENMASK(7, 0)
+
+/* MURU */
+#define OFDMA_DL                       BIT(0)
+#define OFDMA_UL                       BIT(1)
+#define MUMIMO_DL                      BIT(2)
+#define MUMIMO_UL                      BIT(3)
+#define MUMIMO_DL_CERT                 BIT(4)
 
 enum {
 	CMD_BAND_NONE,
@@ -798,6 +946,7 @@ enum {
 					 sizeof(struct sta_rec_eht) +		\
 					 sizeof(struct sta_rec_hdrt) +		\
 					 sizeof(struct sta_rec_hdr_trans) +	\
+					 sizeof(struct sta_rec_tx_cap) +	\
 					 sizeof(struct tlv))
 
 #define MT7996_MAX_BEACON_SIZE		1338
@@ -823,12 +972,18 @@ mt7996_get_power_bound(struct mt7996_phy *phy, s8 txpower)
 
 enum {
 	UNI_BAND_CONFIG_RADIO_ENABLE,
+	UNI_BAND_CONFIG_EDCCA_ENABLE = 0x05,
+	UNI_BAND_CONFIG_EDCCA_THRESHOLD = 0x06,
 	UNI_BAND_CONFIG_RTS_THRESHOLD = 0x08,
+	UNI_BAND_CONFIG_RTS_SIGTA_EN = 0x09,
+	UNI_BAND_CONFIG_DIS_SECCH_CCA_DET = 0x0a,
 };
 
 enum {
 	UNI_WSYS_CONFIG_FW_LOG_CTRL,
 	UNI_WSYS_CONFIG_FW_DBG_CTRL,
+	UNI_CMD_CERT_CFG = 6,
+	UNI_WSYS_CONFIG_FW_TIME_SYNC, /* UNI_CMD_FW_TIME_SYNC in FW */
 };
 
 enum {
@@ -841,12 +996,15 @@ enum {
 	UNI_EFUSE_BUFFER_MODE,
 	UNI_EFUSE_FREE_BLOCK,
 	UNI_EFUSE_BUFFER_RD,
+	UNI_EFUSE_PATCH,
 };
 
 enum {
 	UNI_VOW_DRR_CTRL,
+	UNI_VOW_FEATURE_CTRL,
 	UNI_VOW_RX_AT_AIRTIME_EN = 0x0b,
 	UNI_VOW_RX_AT_AIRTIME_CLR_EN = 0x0e,
+	UNI_VOW_RED_ENABLE = 0x18,
 };
 
 enum {
@@ -872,6 +1030,14 @@ enum {
 	UNI_RRO_SET_FLUSH_TIMEOUT
 };
 
+enum {
+	UNI_MEC_READ_INFO = 0,
+	UNI_MEC_AMSDU_ALGO_EN_STA,
+	UNI_MEC_AMSDU_PARA_STA,
+	UNI_MEC_AMSDU_ALGO_THRESHOLD,
+	UNI_MEC_IFAC_SPEED,
+};
+
 enum{
 	UNI_CMD_SR_ENABLE = 0x1,
 	UNI_CMD_SR_ENABLE_SD,
@@ -889,8 +1055,33 @@ enum {
 	UNI_CMD_THERMAL_PROTECT_DUTY_CONFIG,
 };
 
+struct tx_power_ctrl {
+	u8 _rsv[4];
+
+	__le16 tag;
+	__le16 len;
+
+	u8 power_ctrl_id;
+	union {
+		bool sku_enable;
+		bool ate_mode_enable;
+		bool percentage_ctrl_enable;
+		bool bf_backoff_enable;
+		u8 show_info_category;
+		u8 power_drop_level;
+	};
+	u8 band_idx;
+	u8 rsv[1];
+} __packed;
+
 enum {
+	UNI_TXPOWER_SKU_POWER_LIMIT_CTRL = 0,
+	UNI_TXPOWER_PERCENTAGE_CTRL = 1,
+	UNI_TXPOWER_PERCENTAGE_DROP_CTRL = 2,
+	UNI_TXPOWER_BACKOFF_POWER_LIMIT_CTRL = 3,
 	UNI_TXPOWER_POWER_LIMIT_TABLE_CTRL = 4,
+	UNI_TXPOWER_ATE_MODE_CTRL = 6,
+	UNI_TXPOWER_SHOW_INFO = 7,
 };
 
 enum {
@@ -910,7 +1101,11 @@ enum {
 	UNI_CMD_SER_SET_RECOVER_L4_MDP,
 	UNI_CMD_SER_SET_RECOVER_FROM_ETH,
 	UNI_CMD_SER_SET_RECOVER_FULL = 8,
+	/* fw assert */
 	UNI_CMD_SER_SET_SYSTEM_ASSERT,
+	/* coredump */
+	UNI_CMD_SER_FW_COREDUMP_WA,
+	UNI_CMD_SER_FW_COREDUMP_WM,
 	/*hw bit detect only*/
 	UNI_CMD_SER_SET_HW_BIT_DETECT_ONLY,
 	/* action */
@@ -926,6 +1121,42 @@ enum {
 	MT7996_SEC_MODE_MAX,
 };
 
+enum {
+	UNI_CMD_PP_EN_CTRL,
+};
+
+enum pp_mode {
+	PP_DISABLE = 0,
+	PP_FW_MODE,
+	PP_USR_MODE,
+};
+
+enum {
+	UNI_CMD_SCS_SEND_DATA,
+	UNI_CMD_SCS_SET_PD_THR_RANGE = 2,
+	UNI_CMD_SCS_ENABLE,
+};
+
+enum {
+	UNI_CMD_MLO_AGC_TX = 4,
+	UNI_CMD_MLO_AGC_TRIG = 5,
+};
+
+struct mt7996_mlo_agc_set {
+	u8 rsv[4];
+
+	__le16 tag;
+	__le16 len;
+
+	u8 mld_id;
+	u8 link_id;
+	u8 ac;
+	u8 disp_pol;
+	u8 ratio;
+	u8 order;
+	__le16 mgf;
+} __packed;
+
 #define MT7996_PATCH_SEC		GENMASK(31, 24)
 #define MT7996_PATCH_SCRAMBLE_KEY	GENMASK(15, 8)
 #define MT7996_PATCH_AES_KEY		GENMASK(7, 0)
@@ -954,4 +1185,109 @@ struct fixed_rate_table_ctrl {
 	u8 _rsv2;
 } __packed;
 
+#ifdef CONFIG_MTK_VENDOR
+struct mt7996_mcu_csi_event {
+	struct mt7996_mcu_rxd rxd;
+
+	u8 band_idx;
+	u8 _rsv[3];
+
+	__le16 tag;
+	__le16 len;
+	u8 tlv_buf[0];
+};
+
+enum UNI_EVENT_CSI_TAG_T {
+	UNI_EVENT_CSI_DATA = 0,
+	UNI_EVENT_CSI_MAX_NUM
+};
+
+struct csi_tlv {
+	struct {
+		__le32 tag;
+		__le32 len;
+	} basic;
+	union {
+		u8 mac[ETH_ALEN];
+		__le32 info;
+		s16 data[0];
+	};
+} __packed;
+
+struct csi_bitmap_info_update {
+	u8 action;
+	u8 addr[ETH_ALEN];
+};
+
+#define CSI_MAX_BUF_NUM	3000
+
+enum CSI_EVENT_TLV_TAG {
+	CSI_EVENT_FW_VER,
+	CSI_EVENT_CBW,
+	CSI_EVENT_RSSI,
+	CSI_EVENT_SNR,
+	CSI_EVENT_BAND,
+	CSI_EVENT_CSI_NUM,
+	CSI_EVENT_CSI_I_DATA,
+	CSI_EVENT_CSI_Q_DATA,
+	CSI_EVENT_DBW,
+	CSI_EVENT_CH_IDX,
+	CSI_EVENT_TA,
+	CSI_EVENT_EXTRA_INFO,
+	CSI_EVENT_RX_MODE,
+	CSI_EVENT_RSVD1,
+	CSI_EVENT_RSVD2,
+	CSI_EVENT_RSVD3,
+	CSI_EVENT_RSVD4,
+	CSI_EVENT_H_IDX,
+	CSI_EVENT_TX_RX_IDX,
+	CSI_EVENT_TS,
+	CSI_EVENT_PKT_SN,
+	CSI_EVENT_BW_SEG,
+	CSI_EVENT_REMAIN_LAST,
+	CSI_EVENT_TR_STREAM,
+	CSI_EVENT_TLV_TAG_NUM,
+};
+
+enum CSI_CHAIN_TYPE {
+	CSI_CHAIN_ERR,
+	CSI_CHAIN_COMPLETE,
+	CSI_CHAIN_SEGMENT_FIRST,
+	CSI_CHAIN_SEGMENT_MIDDLE,
+	CSI_CHAIN_SEGMENT_LAST,
+	CSI_CHAIN_SEGMENT_ERR,
+};
+
+enum CSI_CONTROL_MODE_T {
+	CSI_CONTROL_MODE_STOP,
+	CSI_CONTROL_MODE_START,
+	CSI_CONTROL_MODE_SET,
+	CSI_CONTROL_MODE_NUM
+};
+
+enum CSI_CONFIG_ITEM_T {
+	CSI_CONFIG_RSVD1,
+	CSI_CONFIG_WF,
+	CSI_CONFIG_RSVD2,
+	CSI_CONFIG_FRAME_TYPE,
+	CSI_CONFIG_TX_PATH,
+	CSI_CONFIG_OUTPUT_FORMAT,
+	CSI_CONFIG_INFO,
+	CSI_CONFIG_CHAIN_FILTER,
+	CSI_CONFIG_STA_FILTER,
+	CSI_CONFIG_ACTIVE_MODE,
+	CSI_CONFIG_ITEM_NUM
+};
+
+/* CSI config Tag */
+enum UNI_CMD_CSI_TAG_T {
+	UNI_CMD_CSI_STOP = 0,
+	UNI_CMD_CSI_START = 1,
+	UNI_CMD_CSI_SET_FRAME_TYPE = 2,
+	UNI_CMD_CSI_SET_CHAIN_FILTER = 3,
+	UNI_CMD_CSI_SET_STA_FILTER = 4,
+	UNI_CMD_CSI_SET_ACTIVE_MODE = 5,
+};
+#endif
+
 #endif
diff --git a/mt7996/mmio.c b/mt7996/mmio.c
index a1fb0243..a994563e 100644
--- a/mt7996/mmio.c
+++ b/mt7996/mmio.c
@@ -14,7 +14,7 @@
 #include "../trace.h"
 #include "../dma.h"
 
-static bool wed_enable;
+static bool wed_enable = true;
 module_param(wed_enable, bool, 0644);
 
 static const struct __base mt7996_reg_base[] = {
@@ -312,7 +312,8 @@ int mt7996_mmio_wed_init(struct mt7996_dev *dev, void *pdev_ptr,
 
 	dev->has_rro = true;
 
-	hif1_ofs = MT_WFDMA0_PCIE1(0) - MT_WFDMA0(0);
+	if (dev->hif2)
+		hif1_ofs = MT_WFDMA0_PCIE1(0) - MT_WFDMA0(0);
 
 	if (hif2)
 		wed = &dev->mt76.mmio.wed_hif2;
@@ -334,10 +335,16 @@ int mt7996_mmio_wed_init(struct mt7996_dev *dev, void *pdev_ptr,
 					     MT_TXQ_RING_BASE(0) +
 					     MT7996_TXQ_BAND2 * MT_RING_SIZE;
 		if (dev->has_rro) {
+			u8 rxq_id = is_mt7996(&dev->mt76) ?
+				    MT7996_RXQ_TXFREE2 : MT7996_RXQ_MCU_WA_EXT;
+
 			wed->wlan.wpdma_txfree = wed->wlan.phy_base + hif1_ofs +
 						 MT_RXQ_RING_BASE(0) +
-						 MT7996_RXQ_TXFREE2 * MT_RING_SIZE;
-			wed->wlan.txfree_tbit = ffs(MT_INT_RX_TXFREE_EXT) - 1;
+						 rxq_id * MT_RING_SIZE;
+			if (is_mt7996(&dev->mt76))
+				wed->wlan.txfree_tbit = ffs(MT_INT_RX_TXFREE_EXT) - 1;
+			else
+				wed->wlan.txfree_tbit = ffs(MT_INT_RX_TXFREE_BAND1_EXT) - 1;
 		} else {
 			wed->wlan.wpdma_txfree = wed->wlan.phy_base + hif1_ofs +
 						 MT_RXQ_RING_BASE(0) +
@@ -346,9 +353,9 @@ int mt7996_mmio_wed_init(struct mt7996_dev *dev, void *pdev_ptr,
 		}
 
 		wed->wlan.wpdma_rx_glo = wed->wlan.phy_base + hif1_ofs + MT_WFDMA0_GLO_CFG;
-		wed->wlan.wpdma_rx = wed->wlan.phy_base + hif1_ofs +
-				     MT_RXQ_RING_BASE(MT7996_RXQ_BAND0) +
-				     MT7996_RXQ_BAND0 * MT_RING_SIZE;
+		wed->wlan.wpdma_rx[0] = wed->wlan.phy_base + hif1_ofs +
+				     MT_RXQ_RING_BASE(MT7996_RXQ_BAND2) +
+				     MT7996_RXQ_BAND2 * MT_RING_SIZE;
 
 		wed->wlan.id = MT7996_DEVICE_ID_2;
 		wed->wlan.tx_tbit[0] = ffs(MT_INT_TX_DONE_BAND2) - 1;
@@ -361,16 +368,26 @@ int mt7996_mmio_wed_init(struct mt7996_dev *dev, void *pdev_ptr,
 
 		wed->wlan.wpdma_rx_glo = wed->wlan.phy_base + MT_WFDMA0_GLO_CFG;
 
-		wed->wlan.wpdma_rx = wed->wlan.phy_base +
+		wed->wlan.wpdma_rx[0] = wed->wlan.phy_base +
 				     MT_RXQ_RING_BASE(MT7996_RXQ_BAND0) +
 				     MT7996_RXQ_BAND0 * MT_RING_SIZE;
 
 		wed->wlan.wpdma_rx_rro[0] = wed->wlan.phy_base +
 					    MT_RXQ_RING_BASE(MT7996_RXQ_RRO_BAND0) +
 					    MT7996_RXQ_RRO_BAND0 * MT_RING_SIZE;
-		wed->wlan.wpdma_rx_rro[1] = wed->wlan.phy_base + hif1_ofs +
-					    MT_RXQ_RING_BASE(MT7996_RXQ_RRO_BAND2) +
-					    MT7996_RXQ_RRO_BAND2 * MT_RING_SIZE;
+		if (is_mt7996(&dev->mt76)) {
+			wed->wlan.wpdma_rx_rro[1] = wed->wlan.phy_base + hif1_ofs +
+						    MT_RXQ_RING_BASE(MT7996_RXQ_RRO_BAND2) +
+						    MT7996_RXQ_RRO_BAND2 * MT_RING_SIZE;
+		} else {
+			wed->wlan.wpdma_rx_rro[1] = wed->wlan.phy_base + hif1_ofs +
+						    MT_RXQ_RING_BASE(MT7996_RXQ_RRO_BAND1) +
+						    MT7996_RXQ_RRO_BAND1 * MT_RING_SIZE;
+			wed->wlan.wpdma_rx[1] = wed->wlan.phy_base + hif1_ofs +
+						MT_RXQ_RING_BASE(MT7996_RXQ_BAND1) +
+						MT7996_RXQ_BAND1 * MT_RING_SIZE;
+		}
+
 		wed->wlan.wpdma_rx_pg = wed->wlan.phy_base +
 					MT_RXQ_RING_BASE(MT7996_RXQ_MSDU_PG_BAND0) +
 					MT7996_RXQ_MSDU_PG_BAND0 * MT_RING_SIZE;
@@ -380,10 +397,14 @@ int mt7996_mmio_wed_init(struct mt7996_dev *dev, void *pdev_ptr,
 		wed->wlan.rx_size = SKB_WITH_OVERHEAD(MT_RX_BUF_SIZE);
 
 		wed->wlan.rx_tbit[0] = ffs(MT_INT_RX_DONE_BAND0) - 1;
-		wed->wlan.rx_tbit[1] = ffs(MT_INT_RX_DONE_BAND2) - 1;
-
 		wed->wlan.rro_rx_tbit[0] = ffs(MT_INT_RX_DONE_RRO_BAND0) - 1;
-		wed->wlan.rro_rx_tbit[1] = ffs(MT_INT_RX_DONE_RRO_BAND2) - 1;
+		if (is_mt7996(&dev->mt76)) {
+			wed->wlan.rx_tbit[1] = ffs(MT_INT_RX_DONE_BAND2) - 1;
+			wed->wlan.rro_rx_tbit[1] = ffs(MT_INT_RX_DONE_RRO_BAND2) - 1;
+		} else {
+			wed->wlan.rx_tbit[1] = ffs(MT_INT_RX_DONE_BAND1) - 1;
+			wed->wlan.rro_rx_tbit[1] = ffs(MT_INT_RX_DONE_RRO_BAND1) - 1;
+		}
 
 		wed->wlan.rx_pg_tbit[0] = ffs(MT_INT_RX_DONE_MSDU_PG_BAND0) - 1;
 		wed->wlan.rx_pg_tbit[1] = ffs(MT_INT_RX_DONE_MSDU_PG_BAND1) - 1;
@@ -391,20 +412,28 @@ int mt7996_mmio_wed_init(struct mt7996_dev *dev, void *pdev_ptr,
 
 		wed->wlan.tx_tbit[0] = ffs(MT_INT_TX_DONE_BAND0) - 1;
 		wed->wlan.tx_tbit[1] = ffs(MT_INT_TX_DONE_BAND1) - 1;
-		if (dev->has_rro) {
-			wed->wlan.wpdma_txfree = wed->wlan.phy_base + MT_RXQ_RING_BASE(0) +
-						 MT7996_RXQ_TXFREE0 * MT_RING_SIZE;
-			wed->wlan.txfree_tbit = ffs(MT_INT_RX_TXFREE_MAIN) - 1;
+		if (is_mt7996(&dev->mt76)) {
+			if (dev->has_rro) {
+				wed->wlan.wpdma_txfree = wed->wlan.phy_base + MT_RXQ_RING_BASE(0) +
+							 MT7996_RXQ_TXFREE0 * MT_RING_SIZE;
+				wed->wlan.txfree_tbit = ffs(MT_INT_RX_TXFREE_MAIN) - 1;
+			} else {
+				wed->wlan.txfree_tbit = ffs(MT_INT_RX_DONE_WA_MAIN) - 1;
+				wed->wlan.wpdma_txfree = wed->wlan.phy_base + MT_RXQ_RING_BASE(0) +
+							 MT7996_RXQ_MCU_WA_MAIN * MT_RING_SIZE;
+			}
 		} else {
 			wed->wlan.txfree_tbit = ffs(MT_INT_RX_DONE_WA_MAIN) - 1;
 			wed->wlan.wpdma_txfree = wed->wlan.phy_base + MT_RXQ_RING_BASE(0) +
-						  MT7996_RXQ_MCU_WA_MAIN * MT_RING_SIZE;
+						 MT7996_RXQ_MCU_WA_MAIN * MT_RING_SIZE;
 		}
 		dev->mt76.rx_token_size = MT7996_TOKEN_SIZE + wed->wlan.rx_npkt;
+		if(dev->hif2 && is_mt7992(&dev->mt76))
+			wed->wlan.id = 0x7992;
 	}
 
-	wed->wlan.nbuf = MT7996_HW_TOKEN_SIZE;
-	wed->wlan.token_start = MT7996_TOKEN_SIZE - wed->wlan.nbuf;
+	wed->wlan.nbuf = MT7996_TOKEN_SIZE;
+	wed->wlan.token_start = 0;
 
 	wed->wlan.amsdu_max_subframes = 8;
 	wed->wlan.amsdu_max_len = 1536;
@@ -428,6 +457,8 @@ int mt7996_mmio_wed_init(struct mt7996_dev *dev, void *pdev_ptr,
 	*irq = wed->irq;
 	dev->mt76.dma_dev = wed->dev;
 
+	dev->mt76.token_size = MT7996_SW_TOKEN_SIZE;
+
 	return 1;
 #else
 	return 0;
@@ -495,10 +526,9 @@ void mt7996_dual_hif_set_irq_mask(struct mt7996_dev *dev, bool write_reg,
 		if (mtk_wed_device_active(&mdev->mmio.wed)) {
 			mtk_wed_device_irq_set_mask(&mdev->mmio.wed,
 						    mdev->mmio.irqmask);
-			if (mtk_wed_device_active(&mdev->mmio.wed_hif2)) {
+			if (mtk_wed_device_active(&mdev->mmio.wed_hif2))
 				mtk_wed_device_irq_set_mask(&mdev->mmio.wed_hif2,
 							    mdev->mmio.irqmask);
-			}
 		} else {
 			mt76_wr(dev, MT_INT_MASK_CSR, mdev->mmio.irqmask);
 			mt76_wr(dev, MT_INT1_MASK_CSR, mdev->mmio.irqmask);
@@ -530,12 +560,18 @@ static void mt7996_irq_tasklet(struct tasklet_struct *t)
 					       dev->mt76.mmio.irqmask);
 		if (intr1 & MT_INT_RX_TXFREE_EXT)
 			napi_schedule(&dev->mt76.napi[MT_RXQ_TXFREE_BAND2]);
+
+		if (intr1 & MT_INT_RX_DONE_BAND2_EXT)
+			napi_schedule(&dev->mt76.napi[MT_RXQ_BAND2]);
+
+		if (is_mt7992(&dev->mt76) && (intr1 & MT_INT_RX_TXFREE_BAND1_EXT))
+			napi_schedule(&dev->mt76.napi[MT_RXQ_BAND1_WA]);
 	}
 
 	if (mtk_wed_device_active(wed)) {
 		mtk_wed_device_irq_set_mask(wed, 0);
 		intr = mtk_wed_device_irq_get(wed, dev->mt76.mmio.irqmask);
-		intr |= (intr1 & ~MT_INT_RX_TXFREE_EXT);
+		intr |= (intr1 & ~MT_INT_TX_RX_DONE_EXT);
 	} else {
 		mt76_wr(dev, MT_INT_MASK_CSR, 0);
 		if (dev->hif2)
@@ -608,7 +644,6 @@ struct mt7996_dev *mt7996_mmio_probe(struct device *pdev,
 	static const struct mt76_driver_ops drv_ops = {
 		/* txwi_size = txd size + txp size */
 		.txwi_size = MT_TXD_SIZE + sizeof(struct mt76_connac_fw_txp),
-		.link_data_size = sizeof(struct mt7996_vif_link),
 		.drv_flags = MT_DRV_TXWI_NO_FREE |
 			     MT_DRV_AMSDU_OFFLOAD |
 			     MT_DRV_HW_MGMT_TXQ,
@@ -625,9 +660,7 @@ struct mt7996_dev *mt7996_mmio_probe(struct device *pdev,
 		.sta_event = mt7996_mac_sta_event,
 		.sta_remove = mt7996_mac_sta_remove,
 		.update_survey = mt7996_update_channel,
-		.set_channel = mt7996_set_channel,
-		.vif_link_add = mt7996_vif_link_add,
-		.vif_link_remove = mt7996_vif_link_remove,
+		// .set_channel = mt7996_set_channel,
 	};
 	struct mt7996_dev *dev;
 	struct mt76_dev *mdev;
diff --git a/mt7996/mt7996.h b/mt7996/mt7996.h
index ba2576aa..27328602 100644
--- a/mt7996/mt7996.h
+++ b/mt7996/mt7996.h
@@ -8,6 +8,7 @@
 
 #include <linux/interrupt.h>
 #include <linux/ktime.h>
+#include <linux/pci.h>
 #include "../mt76_connac.h"
 #include "regs.h"
 
@@ -38,38 +39,51 @@
 #define MT7996_FIRMWARE_WA		"mediatek/mt7996/mt7996_wa.bin"
 #define MT7996_FIRMWARE_WM		"mediatek/mt7996/mt7996_wm.bin"
 #define MT7996_FIRMWARE_DSP		"mediatek/mt7996/mt7996_dsp.bin"
+#define MT7996_FIRMWARE_WM_TM		"mediatek/mt7996/mt7996_wm_tm.bin"
 #define MT7996_ROM_PATCH		"mediatek/mt7996/mt7996_rom_patch.bin"
 
 #define MT7996_FIRMWARE_WA_233		"mediatek/mt7996/mt7996_wa_233.bin"
 #define MT7996_FIRMWARE_WM_233		"mediatek/mt7996/mt7996_wm_233.bin"
 #define MT7996_FIRMWARE_DSP_233		MT7996_FIRMWARE_DSP
+#define MT7996_FIRMWARE_WM_TM_233	"mediatek/mt7996/mt7996_wm_tm_233.bin"
 #define MT7996_ROM_PATCH_233		"mediatek/mt7996/mt7996_rom_patch_233.bin"
 
 #define MT7992_FIRMWARE_WA		"mediatek/mt7996/mt7992_wa.bin"
 #define MT7992_FIRMWARE_WM		"mediatek/mt7996/mt7992_wm.bin"
 #define MT7992_FIRMWARE_DSP		"mediatek/mt7996/mt7992_dsp.bin"
+#define MT7992_FIRMWARE_WM_TM		"mediatek/mt7996/mt7992_wm_tm.bin"
 #define MT7992_ROM_PATCH		"mediatek/mt7996/mt7992_rom_patch.bin"
 
 #define MT7992_FIRMWARE_WA_23		"mediatek/mt7996/mt7992_wa_23.bin"
 #define MT7992_FIRMWARE_WM_23		"mediatek/mt7996/mt7992_wm_23.bin"
 #define MT7992_FIRMWARE_DSP_23		"mediatek/mt7996/mt7992_dsp_23.bin"
+#define MT7992_FIRMWARE_WM_TM_23	"mediatek/mt7996/mt7992_wm_tm_23.bin"
 #define MT7992_ROM_PATCH_23		"mediatek/mt7996/mt7992_rom_patch_23.bin"
 
+#define MT7992_FIRMWARE_WA_24		"mediatek/mt7996/mt7992_wa_24.bin"
+#define MT7992_FIRMWARE_WM_24		"mediatek/mt7996/mt7992_wm_24.bin"
+#define MT7992_FIRMWARE_DSP_24		"mediatek/mt7996/mt7992_dsp_24.bin"
+#define MT7992_FIRMWARE_WM_TM_24	"mediatek/mt7996/mt7992_wm_tm_24.bin"
+#define MT7992_ROM_PATCH_24		"mediatek/mt7996/mt7992_rom_patch_24.bin"
+
 #define MT7996_EEPROM_DEFAULT		"mediatek/mt7996/mt7996_eeprom.bin"
 #define MT7996_EEPROM_DEFAULT_INT	"mediatek/mt7996/mt7996_eeprom_2i5i6i.bin"
 #define MT7996_EEPROM_DEFAULT_233	"mediatek/mt7996/mt7996_eeprom_233.bin"
 #define MT7996_EEPROM_DEFAULT_233_INT	"mediatek/mt7996/mt7996_eeprom_233_2i5i6i.bin"
+#define MT7996_EEPROM_DEFAULT_404	"mediatek/mt7996/mt7996_eeprom_dual_404.bin"
 
 #define MT7992_EEPROM_DEFAULT		"mediatek/mt7996/mt7992_eeprom.bin"
 #define MT7992_EEPROM_DEFAULT_INT	"mediatek/mt7996/mt7992_eeprom_2i5i.bin"
 #define MT7992_EEPROM_DEFAULT_MIX	"mediatek/mt7996/mt7992_eeprom_2i5e.bin"
 #define MT7992_EEPROM_DEFAULT_23	"mediatek/mt7996/mt7992_eeprom_23.bin"
 #define MT7992_EEPROM_DEFAULT_23_INT	"mediatek/mt7996/mt7992_eeprom_23_2i5i.bin"
+#define MT7992_EEPROM_DEFAULT_24	"mediatek/mt7996/mt7992_eeprom_24_2i5i.bin"
 
 #define MT7996_EEPROM_SIZE		7680
 #define MT7996_EEPROM_BLOCK_SIZE	16
 #define MT7996_TOKEN_SIZE		16384
 #define MT7996_HW_TOKEN_SIZE		8192
+#define MT7996_SW_TOKEN_SIZE		15360
 
 #define MT7996_CFEND_RATE_DEFAULT	0x49	/* OFDM 24M */
 #define MT7996_CFEND_RATE_11B		0x03	/* 11B LP, 11M */
@@ -99,6 +113,9 @@
 #define MT7996_CRIT_TEMP		110
 #define MT7996_MAX_TEMP			120
 
+#define MT7996_BUILD_TIME_LEN		24
+
+#define MT7996_RRO_MSDU_PG_HASH_SIZE	127
 #define MT7996_RRO_MAX_SESSION		1024
 #define MT7996_RRO_WINDOW_MAX_LEN	1024
 #define MT7996_RRO_ADDR_ELEM_LEN	128
@@ -115,6 +132,22 @@
 #define MT7996_RX_MSDU_PAGE_SIZE	(128 + \
 					 SKB_DATA_ALIGN(sizeof(struct skb_shared_info)))
 
+#define MT7996_DRR_STA_BSS_GRP_MASK	GENMASK(5, 0)
+#define MT7996_DRR_STA_AC0_QNTM_MASK	GENMASK(10, 8)
+#define MT7996_DRR_STA_AC1_QNTM_MASK	GENMASK(14, 12)
+#define MT7996_DRR_STA_AC2_QNTM_MASK	GENMASK(18, 16)
+#define MT7996_DRR_STA_AC3_QNTM_MASK	GENMASK(22, 20)
+
+/* RRO 3.1 */
+#define MT7996_RRO_MSDU_PG_CR_CNT 8
+#define MT7996_RRO_MSDU_PG_SIZE_PER_CR 0x10000
+
+#define to_rssi(field, rcpi)	((FIELD_GET(field, rcpi) - 220) / 2)
+
+#define MT7996_MAX_BEACON_LOSS		20
+#define MT7996_MAX_PROBE_TIMEOUT	500
+#define MT7996_MAX_PROBE_TRIES		2
+
 struct mt7996_vif;
 struct mt7996_sta;
 struct mt7996_dfs_pulse;
@@ -122,18 +155,22 @@ struct mt7996_dfs_pattern;
 
 enum mt7996_ram_type {
 	MT7996_RAM_TYPE_WM,
+	MT7996_RAM_TYPE_WM_TM = MT7996_RAM_TYPE_WM,
 	MT7996_RAM_TYPE_WA,
 	MT7996_RAM_TYPE_DSP,
+	__MT7996_RAM_TYPE_MAX,
 };
 
 enum mt7996_var_type {
 	MT7996_VAR_TYPE_444,
 	MT7996_VAR_TYPE_233,
+	MT7996_VAR_TYPE_404,
 };
 
 enum mt7992_var_type {
 	MT7992_VAR_TYPE_44,
 	MT7992_VAR_TYPE_23,
+	MT7992_VAR_TYPE_24,
 };
 
 enum mt7996_fem_type {
@@ -142,6 +179,14 @@ enum mt7996_fem_type {
 	MT7996_FEM_MIX,
 };
 
+enum mt7996_coredump_state {
+	MT7996_COREDUMP_IDLE = 0,
+	MT7996_COREDUMP_MANUAL_WA,
+	MT7996_COREDUMP_MANUAL_WM,
+	MT7996_COREDUMP_AUTO,
+	__MT7996_COREDUMP_TYPE_MAX,
+};
+
 enum mt7996_txq_id {
 	MT7996_TXQ_FWDL = 16,
 	MT7996_TXQ_MCU_WM,
@@ -161,7 +206,7 @@ enum mt7996_rxq_id {
 	MT7996_RXQ_BAND1 = 5, /* for mt7992 */
 	MT7996_RXQ_BAND2 = 5,
 	MT7996_RXQ_RRO_BAND0 = 8,
-	MT7996_RXQ_RRO_BAND1 = 8,/* unused */
+	MT7996_RXQ_RRO_BAND1 = 9,
 	MT7996_RXQ_RRO_BAND2 = 6,
 	MT7996_RXQ_MSDU_PG_BAND0 = 10,
 	MT7996_RXQ_MSDU_PG_BAND1 = 11,
@@ -190,13 +235,98 @@ struct mt7996_twt_flow {
 
 DECLARE_EWMA(avg_signal, 10, 8)
 
-struct mt7996_sta {
+enum mt7996_dpd_ch_num {
+	DPD_CH_NUM_BW20_2G,
+	DPD_CH_NUM_BW20_5G,
+	DPD_CH_NUM_BW20_5G_SKIP,
+	DPD_CH_NUM_BW80_5G,
+	DPD_CH_NUM_BW160_5G,
+	DPD_CH_NUM_BW20_6G,
+	DPD_CH_NUM_BW80_6G,
+	DPD_CH_NUM_BW160_6G,
+	DPD_CH_NUM_BW320_6G,
+	DPD_CH_NUM_TYPE_MAX,
+};
+
+enum {
+	VOW_SEARCH_AC_FIRST,
+	VOW_SEARCH_WMM_FIRST
+};
+
+enum {
+	VOW_REFILL_PERIOD_1US,
+	VOW_REFILL_PERIOD_2US,
+	VOW_REFILL_PERIOD_4US,
+	VOW_REFILL_PERIOD_8US,
+	VOW_REFILL_PERIOD_16US,
+	VOW_REFILL_PERIOD_32US,
+	VOW_REFILL_PERIOD_64US,
+	VOW_REFILL_PERIOD_128US
+};
+
+/* Default DRR airtime quantum of each level */
+enum {
+	VOW_DRR_QUANTUM_L0 = 6,
+	VOW_DRR_QUANTUM_L1 = 12,
+	VOW_DRR_QUANTUM_L2 = 16,
+	VOW_DRR_QUANTUM_L3 = 20,
+	VOW_DRR_QUANTUM_L4 = 24,
+	VOW_DRR_QUANTUM_L5 = 28,
+	VOW_DRR_QUANTUM_L6 = 32,
+	VOW_DRR_QUANTUM_L7 = 36
+};
+
+enum {
+	VOW_DRR_QUANTUM_IDX0,
+	VOW_DRR_QUANTUM_IDX1,
+	VOW_DRR_QUANTUM_IDX2,
+	VOW_DRR_QUANTUM_IDX3,
+	VOW_DRR_QUANTUM_IDX4,
+	VOW_DRR_QUANTUM_IDX5,
+	VOW_DRR_QUANTUM_IDX6,
+	VOW_DRR_QUANTUM_IDX7,
+	VOW_DRR_QUANTUM_NUM
+};
+
+enum {
+	VOW_SCH_TYPE_FOLLOW_POLICY,
+	VOW_SCH_TYPE_FOLLOW_HW
+};
+
+enum {
+	VOW_SCH_POLICY_SRR, /* Shared Round-Robin */
+	VOW_SCH_POLICY_WRR /* Weighted Round-Robin */
+};
+
+enum vow_drr_ctrl_id {
+	VOW_DRR_CTRL_STA_ALL,
+	VOW_DRR_CTRL_STA_BSS_GROUP,
+	VOW_DRR_CTRL_AIRTIME_DEFICIT_BOUND = 0x10,
+	VOW_DRR_CTRL_AIRTIME_QUANTUM_ALL = 0x28,
+	VOW_DRR_CTRL_STA_PAUSE = 0x30
+};
+
+struct mt7996_vow_ctrl {
+	bool atf_enable;
+	bool watf_enable;
+	u8 drr_quantum[VOW_DRR_QUANTUM_NUM];
+	u8 max_deficit;
+	u8 sch_type;
+	u8 sch_policy;
+};
+
+struct mt7996_vow_sta_ctrl {
+	bool paused;
+	u8 bss_grp_idx;
+	u8 drr_quantum[IEEE80211_NUM_ACS];
+};
+
+struct mt7996_link_sta {
 	struct mt76_wcid wcid; /* must be first */
 
-	struct mt7996_vif *vif;
+	struct mt7996_sta *sta;
 
 	struct list_head rc_list;
-	u32 airtime_ac[8];
 
 	int ack_signal;
 	struct ewma_avg_signal avg_ack_signal;
@@ -209,27 +339,58 @@ struct mt7996_sta {
 		u8 flowid_mask;
 		struct mt7996_twt_flow flow[MT7996_MAX_STA_TWT_AGRT];
 	} twt;
+
+	struct mt7996_vow_sta_ctrl vow;
 };
 
-struct mt7996_vif_link {
-	struct mt76_vif_link mt76; /* must be first */
+struct mt7996_sta {
+	struct mt7996_link_sta deflink;
+	struct mt7996_link_sta __rcu *link[IEEE80211_MLD_MAX_NUM_LINKS];
 
-	struct mt7996_sta sta;
-	struct mt7996_phy *phy;
+	struct mt7996_vif *vif;
+	u8 pri_link;
+	u8 sec_link;
+};
 
+struct mt7996_bss_conf {
+	struct mt76_vif mt76; /* must be first */
+
+	struct mt7996_vif *vif;
+	struct mt7996_phy *phy;
 	struct ieee80211_tx_queue_params queue_params[IEEE80211_NUM_ACS];
 	struct cfg80211_bitrate_mask bitrate_mask;
+
+	u8 link_id;
+	u8 own_mld_id;
 };
 
 struct mt7996_vif {
-	struct mt7996_vif_link deflink; /* must be first */
-	struct mt76_vif_data mt76;
+	struct mt7996_bss_conf deflink;
+	struct mt7996_bss_conf __rcu *link[IEEE80211_MLD_MAX_NUM_LINKS];
+
+	struct mt7996_sta sta;
+	struct mt7996_dev *dev;
+
+	u8 master_link_id;
+	u8 group_mld_id;
+	u8 mld_remap_id;
+
+	u8 band_to_link[__MT_MAX_BAND];
+
+	/* for beacon monitoring */
+	struct delayed_work beacon_mon_work;
+	unsigned long beacon_received_time[__MT_MAX_BAND];
+	u16 lost_links;
+	void *probe[__MT_MAX_BAND];
+	unsigned long probe_send_time[__MT_MAX_BAND];
+	int probe_send_count[__MT_MAX_BAND];
 };
 
 /* crash-dump */
 struct mt7996_crash_data {
 	guid_t guid;
 	struct timespec64 timestamp;
+	bool supported;
 
 	u8 *memdump_buf;
 	size_t memdump_buf_len;
@@ -241,6 +402,18 @@ struct mt7996_hif {
 	struct device *dev;
 	void __iomem *regs;
 	int irq;
+	enum pci_bus_speed speed;
+	enum pcie_link_width width;
+};
+
+struct mt7996_scs_ctrl {
+	u8 scs_enable;
+	s8 sta_min_rssi;
+};
+
+enum {
+	SCS_DISABLE = 0,
+	SCS_ENABLE,
 };
 
 struct mt7996_wed_rro_addr {
@@ -257,12 +430,111 @@ struct mt7996_wed_rro_session_id {
 	u16 id;
 };
 
+struct mt7996_sta_rc_work_data {
+	unsigned int link_id;
+	u32 changed;
+};
+
+#ifdef CONFIG_MTK_VENDOR
+#define MT7996_AIR_MONITOR_MAX_ENTRY	16
+#define MT7996_AIR_MONITOR_MAX_GROUP	(MT7996_AIR_MONITOR_MAX_ENTRY >> 1)
+
+struct mt7996_air_monitor_group {
+	bool enable;
+	bool used[2];
+};
+
+struct mt7996_air_monitor_entry {
+	bool enable;
+
+	u8 group_idx;
+	u8 group_used_idx;
+	u8 muar_idx;
+	u8 addr[ETH_ALEN];
+	u32 last_seen;
+	s8 rssi[4];
+	struct ieee80211_sta *sta;
+};
+
+struct mt7996_air_monitor_ctrl {
+	u8 enable;
+	struct mt7996_air_monitor_group group[MT7996_AIR_MONITOR_MAX_GROUP];
+	struct mt7996_air_monitor_entry entry[MT7996_AIR_MONITOR_MAX_ENTRY];
+};
+
+enum {
+	CSI_BW20,
+	CSI_BW40,
+	CSI_BW80,
+	CSI_BW160,
+	CSI_BW320
+};
+
+#define CSI_BW20_DATA_COUNT	64
+#define CSI_BW40_DATA_COUNT	128
+#define CSI_BW80_DATA_COUNT	256
+#define CSI_BW160_DATA_COUNT	512
+#define CSI_BW320_DATA_COUNT	1024
+
+struct csi_data {
+	u8 fw_ver;
+	u8 ch_bw;
+	u16 data_num;
+	s16 data_i[CSI_BW320_DATA_COUNT];
+	s16 data_q[CSI_BW320_DATA_COUNT];
+	u8 band;
+	s8 rssi;
+	u8 snr;
+	u32 ts;
+	u8 data_bw;
+	u8 pri_ch_idx;
+	u8 ta[ETH_ALEN];
+	u32 ext_info;
+	u16 rx_mode;
+	u16 rx_rate;
+	u32 chain_info;
+	u16 tx_idx;
+	u16 rx_idx;
+	u32 segment_num;
+	u8 remain_last;
+	u16 pkt_sn;
+	u8 tr_stream;
+
+	struct list_head node;
+};
+#endif
+
+struct mt7996_rro_ba_session {
+	u32 ack_sn         :12;
+	u32 win_sz         :3;
+	u32 bn             :1;
+	u32 last_in_sn     :12;
+	u32 bc             :1;
+	u32 bd             :1;
+	u32 sat            :1;
+	u32 cn             :1;
+	u32 within_cnt     :12;
+	u32 to_sel         :3;
+	u32 rsv            :1;
+	u32 last_in_rxtime :12;
+};
+
+struct mt7996_chanctx {
+	struct cfg80211_chan_def chandef;
+	struct mt7996_phy *phy;
+
+	bool assigned;
+	u8 nbss_assigned;
+};
+
 struct mt7996_phy {
 	struct mt76_phy *mt76;
 	struct mt7996_dev *dev;
 
 	struct ieee80211_sband_iftype_data iftype[NUM_NL80211_BANDS][NUM_NL80211_IFTYPES];
 
+	struct ieee80211_vif *monitor_vif;
+
 	struct thermal_cooling_device *cdev;
 	u8 cdev_state;
 	u8 throttle_state;
@@ -286,11 +558,68 @@ struct mt7996_phy {
 
 	struct mt76_mib_stats mib;
 	struct mt76_channel_state state_ts;
+	struct delayed_work ipi_work;
 
 	u16 orig_chainmask;
 
 	bool has_aux_rx;
 	bool counter_reset;
+
+	u8 pp_mode;
+	u16 punct_bitmap;
+
+	/* for hw_scan */
+	struct delayed_work scan_work;
+	struct ieee80211_channel *scan_chan;
+	struct cfg80211_scan_request *scan_req;
+	struct ieee80211_vif *scan_vif;
+	int scan_chan_idx;
+	struct mt7996_chanctx *chanctx;
+
+	struct mt7996_scs_ctrl scs_ctrl;
+	u32 red_drop;
+
+	bool sku_limit_en;
+	bool sku_path_en;
+
+	u8 muru_onoff;
+
+#ifdef CONFIG_NL80211_TESTMODE
+	struct {
+		u32 *reg_backup;
+
+		s32 last_freq_offset;
+		u8 last_rcpi[4];
+		s8 last_rssi[4];
+		s8 last_ib_rssi[4];
+		s8 last_wb_rssi[4];
+		u8 last_snr;
+
+		u8 spe_idx;
+	} test;
+#endif
+#ifdef CONFIG_MTK_VENDOR
+	u8 rts_bw_sig;
+	spinlock_t amnt_lock;
+	struct mt7996_air_monitor_ctrl amnt_ctrl;
+
+	struct {
+		struct list_head list;
+		spinlock_t lock;
+		u32 count;
+		bool enable;
+
+		struct csi_data buffered_csi;
+		u32 active_bitmap;
+		u32 interval;
+		u32 last_record;
+	} csi;
+#endif
+#ifdef CONFIG_MTK_DEBUG
+	bool sr_enable:1;
+	bool enhanced_sr_enable:1;
+	bool thermal_protection_enable:1;
+#endif
 };
 
 struct mt7996_dev {
@@ -319,14 +648,19 @@ struct mt7996_dev {
 	u16 chainmask;
 	u8 chainshift[__MT_MAX_BAND];
 	u32 hif_idx;
+	u64 mld_id_mask;
+	u64 mld_remap_id_mask;
 
 	struct work_struct init_work;
 	struct work_struct rc_work;
 	struct work_struct dump_work;
 	struct work_struct reset_work;
+	struct delayed_work scs_work;
 	wait_queue_head_t reset_wait;
 	struct {
 		u32 state;
+		u32 l1_reset;
+		u32 l1_reset_last;
 		u32 wa_reset_count;
 		u32 wm_reset_count;
 		bool hw_full_reset:1;
@@ -336,11 +670,14 @@ struct mt7996_dev {
 
 	/* protects coredump data */
 	struct mutex dump_mutex;
+	u8 dump_state;
 #ifdef CONFIG_DEV_COREDUMP
 	struct {
-		struct mt7996_crash_data *crash_data;
+		struct mt7996_crash_data *crash_data[__MT7996_RAM_TYPE_MAX];
 	} coredump;
 #endif
+	char patch_build_date[MT7996_BUILD_TIME_LEN];
+	char ram_build_date[__MT7996_RAM_TYPE_MAX][MT7996_BUILD_TIME_LEN];
 
 	struct list_head sta_rc_list;
 	struct list_head twt_list;
@@ -364,20 +701,44 @@ struct mt7996_dev {
 			void *ptr;
 			dma_addr_t phy_addr;
 		} session;
+		struct {
+			void *ptr;
+			dma_addr_t phy_addr;
+		} msdu_pg[MT7996_RRO_MSDU_PG_CR_CNT];
 
 		struct work_struct work;
 		struct list_head poll_list;
 		spinlock_t lock;
+
+		struct list_head pg_addr_cache;
+		struct list_head pg_hash_head[MT7996_RRO_MSDU_PG_HASH_SIZE];
 	} wed_rro;
 
+	bool testmode_enable;
+	bool bin_file_mode;
+	u8 eeprom_mode;
+	u32 bg_nxt_freq;
+
+	u32 option_type;
+
 	bool ibf;
 	u8 fw_debug_wm;
 	u8 fw_debug_wa;
 	u8 fw_debug_bin;
 	u16 fw_debug_seq;
+	bool fw_debug_muru_disable;
+	bool idxlog_enable;
 
 	struct dentry *debugfs_dir;
 	struct rchan *relay_fwlog;
+	struct rchan *relay_idxlog;
+
+	void *cal;
+	u32 cur_prek_offset;
+	struct {
+		const u32 *rev;
+		u8 dpd_ch_num[DPD_CH_NUM_TYPE_MAX];
+	} prek;
 
 	struct {
 		u16 table_mask;
@@ -391,6 +752,45 @@ struct mt7996_dev {
 		u8 type:4;
 		u8 fem:4;
 	} var;
+
+	struct mt7996_vow_ctrl vow;
+
+	bool wmm_pbc_enable;
+	struct work_struct wmm_pbc_work;
+#ifdef CONFIG_MTK_DEBUG
+	u16 wlan_idx;
+	struct {
+		u8 sku_disable;
+		u32 fw_dbg_module;
+		u8 fw_dbg_lv;
+		u32 bcn_total_cnt[__MT_MAX_BAND];
+		u32 sid;
+
+		bool dump_mcu_pkt:1;
+		bool dump_mcu_event:1;
+		bool dump_txd:1;
+		bool dump_tx_pkt:1;
+		bool dump_rx_pkt:1;
+		bool dump_rx_raw:1;
+		u8 dump_ple_txd;
+		u32 token_idx;
+		u32 rxd_read_cnt;
+		u32 txd_read_cnt;
+		u32 fid_idx;
+	} dbg;
+	const struct mt7996_dbg_reg_desc *dbg_reg;
+#endif
+#ifdef CONFIG_MTK_VENDOR
+	bool cert_mode;
+#endif
+
+#if defined CONFIG_NL80211_TESTMODE || defined CONFIG_MTK_DEBUG
+	struct {
+		void *txbf_phase_cal;
+		void *txbf_pfmu_data;
+		void *txbf_pfmu_tag;
+	} test;
+#endif
 };
 
 enum {
@@ -420,8 +820,19 @@ enum mt7996_rdd_cmd {
 	RDD_READ_PULSE,
 	RDD_RESUME_BF,
 	RDD_IRQ_OFF,
+	RDD_DISABLE_ZW_TIMER,
 };
 
+#define RDD_ZW_TIMER_OFF	BIT(31)
+
+static inline struct mt7996_phy *
+mt7996_hw_phy(struct ieee80211_hw *hw)
+{
+	struct mt76_phy *phy = hw->priv;
+
+	return phy->priv;
+}
+
 static inline struct mt7996_dev *
 mt7996_hw_dev(struct ieee80211_hw *hw)
 {
@@ -459,6 +870,9 @@ mt7996_band_valid(struct mt7996_dev *dev, u8 band)
 	if (is_mt7992(&dev->mt76))
 		return band <= MT_BAND1;
 
+	if (dev->var.type == MT7996_VAR_TYPE_404 && band == MT_BAND1)
+		return false;
+
 	return band <= MT_BAND2;
 }
 
@@ -471,7 +885,8 @@ mt7996_has_background_radar(struct mt7996_dev *dev)
 			return false;
 		break;
 	case MT7992_DEVICE_ID:
-		if (dev->var.type == MT7992_VAR_TYPE_23)
+		if (dev->var.type == MT7992_VAR_TYPE_23 ||
+		    dev->var.type == MT7992_VAR_TYPE_24)
 			return false;
 		break;
 	default:
@@ -493,29 +908,65 @@ mt7996_band_phy(struct mt7996_dev *dev, enum nl80211_band band)
 	return mphy->priv;
 }
 
-static inline struct mt7996_vif_link *
-mt7996_vif_link(struct mt7996_dev *dev, struct ieee80211_vif *vif, int link_id)
+static inline struct mt7996_chanctx *
+mt7996_chanctx_get(struct ieee80211_chanctx_conf *ctx)
 {
-	return (struct mt7996_vif_link *)mt76_vif_link(&dev->mt76, vif, link_id);
+	return (struct mt7996_chanctx *)&ctx->drv_priv;
 }
 
-static inline struct mt7996_phy *
-mt7996_vif_link_phy(struct mt7996_vif_link *link)
+static inline struct mt7996_bss_conf *
+mconf_dereference_protected(struct mt7996_vif *mvif, u8 link_id)
 {
-	struct mt76_phy *mphy = mt76_vif_link_phy(&link->mt76);
+	return rcu_dereference_protected(mvif->link[link_id],
+					 lockdep_is_held(&mvif->dev->mt76.mutex));
+}
 
-	if (!mphy)
+static inline struct mt7996_link_sta *
+mlink_dereference_protected(struct mt7996_sta *msta, u8 link_id)
+{
+	return rcu_dereference_protected(msta->link[link_id],
+					 lockdep_is_held(&msta->vif->dev->mt76.mutex));
+}
+
+static inline struct mt7996_link_sta *
+wcid_to_mlink(struct mt76_wcid *wcid)
+{
+	if (!wcid)
 		return NULL;
 
-	return mphy->priv;
+	return container_of(wcid, struct mt7996_link_sta, wcid);
 }
 
-static inline struct mt7996_vif_link *
-mt7996_vif_conf_link(struct mt7996_dev *dev, struct ieee80211_vif *vif,
-		     struct ieee80211_bss_conf *link_conf)
+static inline struct mt76_wcid *
+mt7996_get_link_wcid(struct mt7996_dev *dev, u16 idx, u8 band_idx)
 {
-	return (struct mt7996_vif_link *)mt76_vif_conf_link(&dev->mt76, vif,
-							    link_conf);
+	struct mt7996_link_sta *mlink;
+	struct mt76_wcid *wcid;
+	u8 link_id;
+
+	if (!idx || idx >= ARRAY_SIZE(dev->mt76.wcid))
+		return NULL;
+
+	if (!mt7996_band_valid(dev, band_idx))
+		return NULL;
+
+	wcid = rcu_dereference(dev->mt76.wcid[idx]);
+	if (!wcid)
+		return NULL;
+
+	if (wcid->phy_idx == band_idx)
+		return wcid;
+
+	mlink = wcid_to_mlink(wcid);
+	link_id = mlink->sta->vif->band_to_link[band_idx];
+	if (link_id == IEEE80211_LINK_UNSPECIFIED)
+		return wcid;
+
+	mlink = rcu_dereference(mlink->sta->link[link_id]);
+	if (!mlink)
+		return wcid;
+
+	return &mlink->wcid;
 }
 
 #define mt7996_for_each_phy(dev, phy)					\
@@ -525,21 +976,19 @@ mt7996_vif_conf_link(struct mt7996_dev *dev, struct ieee80211_vif *vif,
 extern const struct ieee80211_ops mt7996_ops;
 extern struct pci_driver mt7996_pci_driver;
 extern struct pci_driver mt7996_hif_driver;
+extern const struct mt76_testmode_ops mt7996_testmode_ops;
 
 struct mt7996_dev *mt7996_mmio_probe(struct device *pdev,
 				     void __iomem *mem_base, u32 device_id);
 void mt7996_wfsys_reset(struct mt7996_dev *dev);
+void mt7996_rro_hw_init(struct mt7996_dev *dev);
 irqreturn_t mt7996_irq_handler(int irq, void *dev_instance);
-u64 __mt7996_get_tsf(struct ieee80211_hw *hw, struct mt7996_vif *mvif);
+u64 __mt7996_get_tsf(struct ieee80211_hw *hw, struct mt7996_bss_conf *mconf);
 int mt7996_register_device(struct mt7996_dev *dev);
 void mt7996_unregister_device(struct mt7996_dev *dev);
-int mt7996_vif_link_add(struct mt76_phy *mphy, struct ieee80211_vif *vif,
-			struct ieee80211_bss_conf *link_conf,
-			struct mt76_vif_link *mlink);
-void mt7996_vif_link_remove(struct mt76_phy *mphy, struct ieee80211_vif *vif,
-			    struct ieee80211_bss_conf *link_conf,
-			    struct mt76_vif_link *mlink);
+const char *mt7996_eeprom_name(struct mt7996_dev *dev);
 int mt7996_eeprom_init(struct mt7996_dev *dev);
+int mt7996_eeprom_check_fw_mode(struct mt7996_dev *dev);
 int mt7996_eeprom_parse_hw_cap(struct mt7996_dev *dev, struct mt7996_phy *phy);
 int mt7996_eeprom_get_target_power(struct mt7996_dev *dev,
 				   struct ieee80211_channel *chan);
@@ -553,23 +1002,30 @@ int mt7996_init_tx_queues(struct mt7996_phy *phy, int idx,
 			  int n_desc, int ring_base, struct mtk_wed_device *wed);
 void mt7996_init_txpower(struct mt7996_phy *phy);
 int mt7996_txbf_init(struct mt7996_dev *dev);
+int mt7996_get_chip_sku(struct mt7996_dev *dev);
 void mt7996_reset(struct mt7996_dev *dev);
+void mt7996_coredump(struct mt7996_dev *dev, u8 state);
 int mt7996_run(struct mt7996_phy *phy);
 int mt7996_mcu_init(struct mt7996_dev *dev);
 int mt7996_mcu_init_firmware(struct mt7996_dev *dev);
 int mt7996_mcu_twt_agrt_update(struct mt7996_dev *dev,
-			       struct mt7996_vif *mvif,
+			       struct mt7996_bss_conf *mconf,
 			       struct mt7996_twt_flow *flow,
 			       int cmd);
-int mt7996_mcu_add_dev_info(struct mt7996_phy *phy, struct ieee80211_vif *vif,
-			    struct ieee80211_bss_conf *link_conf,
-			    struct mt76_vif_link *mlink, bool enable);
-int mt7996_mcu_add_bss_info(struct mt7996_phy *phy, struct ieee80211_vif *vif,
-			    struct ieee80211_bss_conf *link_conf,
-			    struct mt76_vif_link *mlink, int enable);
-int mt7996_mcu_add_sta(struct mt7996_dev *dev, struct ieee80211_vif *vif,
-		       struct mt76_vif_link *mlink,
-		       struct ieee80211_sta *sta, int conn_state, bool newly);
+int mt7996_mcu_add_dev_info(struct mt7996_phy *phy,
+			    struct ieee80211_bss_conf *conf,
+			    struct mt7996_bss_conf *mconf, bool enable);
+int mt7996_mcu_add_bss_info(struct mt7996_phy *phy,
+			    struct ieee80211_bss_conf *conf,
+			    struct mt7996_bss_conf *mconf,
+			    struct mt7996_link_sta *mlink, int enable);
+int mt7996_mcu_add_sta(struct mt7996_dev *dev, struct ieee80211_bss_conf *conf,
+		       struct mt7996_bss_conf *mconf,
+		       struct ieee80211_link_sta *link_sta,
+		       struct mt7996_link_sta *mlink, bool enable, bool newly);
+int mt7996_mcu_teardown_mld_sta(struct mt7996_dev *dev,
+				struct mt7996_bss_conf *mconf,
+				struct mt7996_link_sta *mlink);
 int mt7996_mcu_add_tx_ba(struct mt7996_dev *dev,
 			 struct ieee80211_ampdu_params *params,
 			 bool add);
@@ -577,24 +1033,34 @@ int mt7996_mcu_add_rx_ba(struct mt7996_dev *dev,
 			 struct ieee80211_ampdu_params *params,
 			 bool add);
 int mt7996_mcu_update_bss_color(struct mt7996_dev *dev,
-				struct mt76_vif_link *mlink,
+				struct mt7996_bss_conf *mconf,
 				struct cfg80211_he_bss_color *he_bss_color);
-int mt7996_mcu_add_beacon(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
-			  struct ieee80211_bss_conf *link_conf);
+int mt7996_mcu_add_beacon(struct ieee80211_hw *hw,
+			  struct ieee80211_bss_conf *conf,
+			  struct mt7996_bss_conf *mconf, int en);
 int mt7996_mcu_beacon_inband_discov(struct mt7996_dev *dev,
-				    struct ieee80211_vif *vif, u32 changed);
-int mt7996_mcu_add_obss_spr(struct mt7996_phy *phy, struct ieee80211_vif *vif,
+				    struct ieee80211_bss_conf *conf,
+				    struct mt7996_bss_conf *mconf, u32 changed);
+int mt7996_mcu_add_obss_spr(struct mt7996_phy *phy,
+			    struct mt7996_bss_conf *mconf,
 			    struct ieee80211_he_obss_pd *he_obss_pd);
-int mt7996_mcu_add_rate_ctrl(struct mt7996_dev *dev, struct ieee80211_vif *vif,
-			     struct ieee80211_sta *sta, bool changed);
-int mt7996_set_channel(struct mt76_phy *mphy);
+int mt7996_mcu_add_rate_ctrl(struct mt7996_dev *dev,
+			     struct ieee80211_bss_conf *conf,
+			     struct mt7996_bss_conf *mconf,
+			     struct ieee80211_link_sta *link_sta,
+			     struct mt7996_link_sta *mlink, bool changed);
+int mt7996_mcu_add_mld_sta(struct mt7996_dev *dev, struct ieee80211_vif *vif,
+			   struct ieee80211_sta *sta, unsigned long add);
+int mt7996_set_channel(struct mt7996_phy *phy, struct cfg80211_chan_def *chandef);
 int mt7996_mcu_set_chan_info(struct mt7996_phy *phy, u16 tag);
-int mt7996_mcu_set_tx(struct mt7996_dev *dev, struct ieee80211_vif *vif,
-		      struct ieee80211_bss_conf *link_conf);
+int mt7996_mcu_set_tx(struct mt7996_dev *dev, struct mt7996_bss_conf *mconf);
 int mt7996_mcu_set_fixed_rate_ctrl(struct mt7996_dev *dev,
 				   void *data, u16 version);
-int mt7996_mcu_set_fixed_field(struct mt7996_dev *dev, struct ieee80211_vif *vif,
-			       struct ieee80211_sta *sta, void *data, u32 field);
+int mt7996_mcu_set_fixed_field(struct mt7996_dev *dev,
+			       struct mt7996_bss_conf *mconf,
+			       struct ieee80211_link_sta *link_sta,
+			       struct mt7996_link_sta *mlink, void *data,
+			       u32 field);
 int mt7996_mcu_set_eeprom(struct mt7996_dev *dev);
 int mt7996_mcu_get_eeprom(struct mt7996_dev *dev, u32 offset, u8 *buf, u32 buf_len);
 int mt7996_mcu_get_eeprom_free_block(struct mt7996_dev *dev, u8 *block_num);
@@ -608,15 +1074,17 @@ int mt7996_mcu_set_radar_th(struct mt7996_dev *dev, int index,
 			    const struct mt7996_dfs_pattern *pattern);
 int mt7996_mcu_set_radio_en(struct mt7996_phy *phy, bool enable);
 int mt7996_mcu_set_rts_thresh(struct mt7996_phy *phy, u32 val);
-int mt7996_mcu_set_timing(struct mt7996_phy *phy, struct ieee80211_vif *vif,
-			  struct ieee80211_bss_conf *link_conf);
+int mt7996_mcu_set_timing(struct mt7996_phy *phy, struct mt7996_bss_conf *mconf);
 int mt7996_mcu_get_chan_mib_info(struct mt7996_phy *phy, bool chan_switch);
 int mt7996_mcu_get_temperature(struct mt7996_phy *phy);
 int mt7996_mcu_set_thermal_throttling(struct mt7996_phy *phy, u8 state);
 int mt7996_mcu_set_thermal_protect(struct mt7996_phy *phy, bool enable);
-int mt7996_mcu_set_txpower_sku(struct mt7996_phy *phy);
+int mt7996_mcu_set_txpower_sku(struct mt7996_phy *phy,
+			       struct ieee80211_bss_conf *conf);
 int mt7996_mcu_rdd_cmd(struct mt7996_dev *dev, int cmd, u8 index,
 		       u8 rx_sel, u8 val);
+int mt7996_mcu_rdd_background_disable_timer(struct mt7996_dev *dev,
+					    bool disable_timer);
 int mt7996_mcu_rdd_background_enable(struct mt7996_phy *phy,
 				     struct cfg80211_chan_def *chandef);
 int mt7996_mcu_set_fixed_rate_table(struct mt7996_phy *phy, u8 table_idx,
@@ -625,14 +1093,35 @@ int mt7996_mcu_rf_regval(struct mt7996_dev *dev, u32 regidx, u32 *val, bool set)
 int mt7996_mcu_set_hdr_trans(struct mt7996_dev *dev, bool hdr_trans);
 int mt7996_mcu_set_rro(struct mt7996_dev *dev, u16 tag, u16 val);
 int mt7996_mcu_wa_cmd(struct mt7996_dev *dev, int cmd, u32 a1, u32 a2, u32 a3);
+int mt7996_mcu_red_config(struct mt7996_dev *dev, bool enable);
 int mt7996_mcu_fw_log_2_host(struct mt7996_dev *dev, u8 type, u8 ctrl);
 int mt7996_mcu_fw_dbg_ctrl(struct mt7996_dev *dev, u32 module, u8 level);
+int mt7996_mcu_fw_time_sync(struct mt76_dev *dev);
 int mt7996_mcu_trigger_assert(struct mt7996_dev *dev);
 void mt7996_mcu_rx_event(struct mt7996_dev *dev, struct sk_buff *skb);
 void mt7996_mcu_exit(struct mt7996_dev *dev);
-int mt7996_mcu_get_all_sta_info(struct mt7996_phy *phy, u16 tag);
+int mt7996_mcu_get_per_sta_info(struct mt76_dev *dev, u16 tag,
+	                        u16 sta_num, u16 *sta_list);
+int mt7996_mcu_get_rssi(struct mt76_dev *dev);
+int mt7996_mcu_get_all_sta_info(struct mt76_dev *dev, u16 tag);
 int mt7996_mcu_wed_rro_reset_sessions(struct mt7996_dev *dev, u16 id);
 int mt7996_mcu_set_sniffer_mode(struct mt7996_phy *phy, bool enabled);
+int mt7996_mcu_set_tx_power_ctrl(struct mt7996_phy *phy, u8 power_ctrl_id, u8 data);
+int mt7996_mcu_get_tx_power_info(struct mt7996_phy *phy, u8 category, void *event);
+int mt7996_mcu_apply_group_cal(struct mt7996_dev *dev);
+int mt7996_mcu_apply_tx_dpd(struct mt7996_phy *phy);
+#ifdef CONFIG_NL80211_TESTMODE
+void mt7996_tm_rf_test_event(struct mt7996_dev *dev, struct sk_buff *skb);
+#endif
+int mt7996_mcu_set_scs(struct mt7996_phy *phy, u8 enable);
+void mt7996_mcu_scs_sta_poll(struct work_struct *work);
+int mt7996_mcu_set_band_confg(struct mt7996_phy *phy, u16 option, bool enable);
+int mt7996_mcu_set_vow_drr_ctrl(struct mt7996_phy *phy,
+				struct mt7996_bss_conf *mconf,
+				struct mt7996_link_sta *mlink,
+				enum vow_drr_ctrl_id id);
+int mt7996_mcu_set_vow_feature_ctrl(struct mt7996_phy *phy);
+void mt7996_mcu_wmm_pbc_work(struct work_struct *work);
 
 static inline u8 mt7996_max_interface_num(struct mt7996_dev *dev)
 {
@@ -682,6 +1171,14 @@ static inline u16 mt7996_rx_chainmask(struct mt7996_phy *phy)
 	return tx_chainmask | (BIT(fls(tx_chainmask)) * phy->has_aux_rx);
 }
 
+static inline bool
+mt7996_vow_should_enable(struct mt7996_dev *dev)
+{
+	return !wiphy_ext_feature_isset(mt76_hw(dev)->wiphy,
+	                                NL80211_EXT_FEATURE_AIRTIME_FAIRNESS) ||
+	       mtk_wed_device_active(&dev->mt76.mmio.wed);
+}
+
 void mt7996_mac_init(struct mt7996_dev *dev);
 u32 mt7996_mac_wtbl_lmac_addr(struct mt7996_dev *dev, u16 wcid, u8 dw);
 bool mt7996_mac_wtbl_update(struct mt7996_dev *dev, int idx, u32 mask);
@@ -705,8 +1202,7 @@ void mt7996_mac_dump_work(struct work_struct *work);
 void mt7996_mac_sta_rc_work(struct work_struct *work);
 void mt7996_mac_update_stats(struct mt7996_phy *phy);
 void mt7996_mac_twt_teardown_flow(struct mt7996_dev *dev,
-				  struct mt7996_sta *msta,
-				  u8 flowid);
+				  struct mt7996_link_sta *mlink, u8 flowid);
 void mt7996_mac_add_twt_setup(struct ieee80211_hw *hw,
 			      struct ieee80211_sta *sta,
 			      struct ieee80211_twt_setup *twt);
@@ -719,33 +1215,113 @@ void mt7996_queue_rx_skb(struct mt76_dev *mdev, enum mt76_rxq_id q,
 			 struct sk_buff *skb, u32 *info);
 bool mt7996_rx_check(struct mt76_dev *mdev, void *data, int len);
 void mt7996_stats_work(struct work_struct *work);
+void mt7996_scan_work(struct work_struct *work);
+void mt7996_scan_complete(struct mt7996_phy *phy, bool aborted);
+void mt7996_beacon_mon_work(struct work_struct *work);
 int mt76_dfs_start_rdd(struct mt7996_dev *dev, bool force);
 int mt7996_dfs_init_radar_detector(struct mt7996_phy *phy);
 void mt7996_set_stream_he_eht_caps(struct mt7996_phy *phy);
 void mt7996_set_stream_vht_txbf_caps(struct mt7996_phy *phy);
 void mt7996_update_channel(struct mt76_phy *mphy);
-int mt7996_init_debugfs(struct mt7996_dev *dev);
+int mt7996_init_dev_debugfs(struct mt7996_phy *phy);
+int mt7996_init_band_debugfs(struct mt7996_phy *phy);
 void mt7996_debugfs_rx_fw_monitor(struct mt7996_dev *dev, const void *data, int len);
 bool mt7996_debugfs_rx_log(struct mt7996_dev *dev, const void *data, int len);
-int mt7996_mcu_add_key(struct mt76_dev *dev, struct ieee80211_vif *vif,
+int mt7996_mcu_add_key(struct mt76_dev *dev, struct mt7996_bss_conf *mconf,
 		       struct ieee80211_key_conf *key, int mcu_cmd,
 		       struct mt76_wcid *wcid, enum set_key_cmd cmd);
-int mt7996_mcu_bcn_prot_enable(struct mt7996_dev *dev, struct ieee80211_vif *vif,
+int mt7996_mcu_bcn_prot_enable(struct mt7996_dev *dev,
+			       struct ieee80211_bss_conf *conf,
+			       struct mt7996_bss_conf *mconf,
+			       struct mt7996_link_sta *mlink,
 			       struct ieee80211_key_conf *key);
 int mt7996_mcu_wtbl_update_hdr_trans(struct mt7996_dev *dev,
 				     struct ieee80211_vif *vif,
-				     struct ieee80211_sta *sta);
+				     struct mt7996_bss_conf *mconf,
+				     struct mt7996_link_sta *mlink);
 int mt7996_mcu_cp_support(struct mt7996_dev *dev, u8 mode);
+int mt7996_mcu_set_pp_en(struct mt7996_phy *phy, u8 mode, u16 bitmap);
 #ifdef CONFIG_MAC80211_DEBUGFS
 void mt7996_sta_add_debugfs(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 			    struct ieee80211_sta *sta, struct dentry *dir);
+void mt7996_vif_add_debugfs(struct ieee80211_hw *hw, struct ieee80211_vif *vif);
+void mt7996_link_sta_add_debugfs(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
+				 struct ieee80211_link_sta *link_sta,
+				 struct dentry *dir);
+void mt7996_link_add_debugfs(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
+			     struct ieee80211_bss_conf *link_conf, struct dentry *dir);
 #endif
 int mt7996_mmio_wed_init(struct mt7996_dev *dev, void *pdev_ptr,
 			 bool hif2, int *irq);
 u32 mt7996_wed_init_buf(void *ptr, dma_addr_t phys, int token_id);
 
+#ifdef CONFIG_MTK_VENDOR
+void mt7996_set_wireless_vif(void *data, u8 *mac, struct ieee80211_vif *vif);
+void mt7996_vendor_register(struct mt7996_phy *phy);
+void mt7996_vendor_amnt_fill_rx(struct mt7996_phy *phy, struct sk_buff *skb);
+int mt7996_vendor_amnt_sta_remove(struct mt7996_phy *phy,
+				  struct ieee80211_sta *sta);
+void mt7996_set_wireless_amsdu(struct ieee80211_hw *hw, u8 en);
+void mt7996_mcu_set_mimo(struct mt7996_phy *phy);
+int mt7996_set_muru_cfg(struct mt7996_phy *phy, u8 action, u8 val);
+int mt7996_mcu_set_muru_cfg(struct mt7996_phy *phy, void *data);
+void mt7996_set_beacon_vif(void *data, u8 *mac, struct ieee80211_vif *vif);
+int mt7996_mcu_set_csi(struct mt7996_phy *phy, u8 mode,
+		       u8 cfg, u8 v1, u32 v2, u8 *mac_addr);
+#endif
+
+int mt7996_mcu_edcca_enable(struct mt7996_phy *phy, bool enable);
+int mt7996_mcu_edcca_threshold_ctrl(struct mt7996_phy *phy, u8 *value, bool set);
+
+enum edcca_bw_id {
+	EDCCA_BW_20 = 0,
+	EDCCA_BW_40,
+	EDCCA_BW_80,
+	EDCCA_BW_160,
+	EDCCA_MAX_BW_NUM,
+};
+
 #ifdef CONFIG_MTK_DEBUG
-int mt7996_mtk_init_debugfs(struct mt7996_phy *phy, struct dentry *dir);
+void mt7996_mtk_init_dev_debugfs(struct mt7996_dev *dev, struct dentry *dir);
+void mt7996_mtk_init_band_debugfs(struct mt7996_phy *phy, struct dentry *dir);
+int mt7996_mcu_muru_dbg_info(struct mt7996_dev *dev, u16 item, u8 val);
+int mt7996_mcu_set_sr_enable(struct mt7996_phy *phy, u8 action, u64 val, bool set);
+void mt7996_mcu_rx_sr_event(struct mt7996_dev *dev, struct sk_buff *skb);
+int mt7996_mcu_set_dup_wtbl(struct mt7996_dev *dev);
+int mt7996_mcu_set_txbf_internal(struct mt7996_phy *phy, u8 action, int idx, bool bfer);
+void mt7996_mcu_rx_bf_event(struct mt7996_dev *dev, struct sk_buff *skb);
+int mt7996_mcu_set_muru_fixed_rate_enable(struct mt7996_dev *dev, u8 action, int val);
+int mt7996_mcu_set_muru_fixed_rate_parameter(struct mt7996_dev *dev, u8 action, void *para);
+int mt7996_mcu_set_txbf_snd_info(struct mt7996_phy *phy, void *para);
+int mt7996_mcu_set_muru_cmd(struct mt7996_dev *dev, u16 action, int val);
+int mt7996_mcu_muru_set_prot_frame_thr(struct mt7996_dev *dev, u32 val);
+int mt7996_mcu_set_bypass_smthint(struct mt7996_phy *phy, u8 val);
+int mt7996_mcu_set_rfeature_trig_type(struct mt7996_phy *phy, u8 enable, u8 trig_type);
+void mt7996_mcu_set_ppdu_tx_type(struct mt7996_phy *phy, u8 ppdu_type);
+void mt7996_mcu_set_nusers_ofdma(struct mt7996_phy *phy, u8 type, u8 ofdma_user_cnt);
+void mt7996_mcu_set_cert(struct mt7996_phy *phy, u8 type);
+void mt7996_tm_update_channel(struct mt7996_phy *phy);
+
+int mt7996_mcu_set_vow_drr_dbg(struct mt7996_dev *dev, u32 val);
+int mt7996_mcu_thermal_debug(struct mt7996_dev *dev, u8 mode, u8 action);
+
+#define PKT_BIN_DEBUG_MAGIC	0xc8763123
+enum {
+	PKT_BIN_DEBUG_MCU,
+	PKT_BIN_DEBUG_TXD,
+	PKT_BIN_DEBUG_TX,
+	PKT_BIN_DEBUG_RX,
+	PKT_BIN_DEBUG_RX_RAW,
+	PKT_BIN_DEBUG_MCU_EVENT,
+};
+
+void mt7996_packet_log_to_host(struct mt7996_dev *dev, const void *data, int len, int type, int des_len);
+void mt7996_dump_bmac_rxd_info(struct mt7996_dev *dev, __le32 *rxd);
+void mt7996_dump_bmac_txd_info(struct seq_file *s, struct mt7996_dev *dev,
+			       __le32 *txd, bool is_hif_txd, bool dump_txp);
+int mt7996_mtk_init_dev_debugfs_internal(struct mt7996_phy *phy, struct dentry *dir);
+int mt7996_mtk_init_band_debugfs_internal(struct mt7996_phy *phy, struct dentry *dir);
+int mt7996_mcu_mlo_agc(struct mt7996_dev *dev, const void *data, int len);
 #endif
 
 #ifdef CONFIG_NET_MEDIATEK_SOC_WED
diff --git a/mt7996/mt7996_trace.h b/mt7996/mt7996_trace.h
new file mode 100644
index 00000000..5fa73482
--- /dev/null
+++ b/mt7996/mt7996_trace.h
@@ -0,0 +1,141 @@
+/* SPDX-License-Identifier: ISC */
+/*
+ * Copyright (C) 2022 MediaTek Inc.
+ */
+
+#if !defined(__MT7996_TRACE_H) || defined(TRACE_HEADER_MULTI_READ)
+#define __MT7996_TRACE_H
+
+#include <linux/types.h>
+#include <linux/tracepoint.h>
+#include "mt7996.h"
+
+#undef TRACE_SYSTEM
+#define TRACE_SYSTEM mt7996
+
+#define MAXNAME		32
+#define DEV_ENTRY	__array(char, wiphy_name, 32)
+#define DEV_ASSIGN(_w)	strlcpy(__entry->wiphy_name, wiphy_name(_w), MAXNAME)
+#define DEV_PR_FMT	"%s"
+#define DEV_PR_ARG	__entry->wiphy_name
+
+DECLARE_EVENT_CLASS(mt7996_mcu_debug,
+	TP_PROTO(struct mt7996_dev *dev, bool uni, u8 id, u8 ext_id,
+		 const void *data, size_t len),
+	TP_ARGS(dev, uni, id, ext_id, data, len),
+	TP_STRUCT__entry(
+		__field(bool, uni)
+		__field(u8, id)
+		__field(u8, ext_id)
+		__field(size_t, len)
+		__dynamic_array(u8, data, len)
+	),
+	TP_fast_assign(
+		__entry->uni = uni;
+		__entry->id = id;
+		__entry->ext_id = ext_id;
+		__entry->len = len;
+		memcpy(__get_dynamic_array(data), data, len);
+	),
+	TP_printk(
+		"uni: %d, id: %u, ext_id: %u, len: %zu",
+		__entry->uni,
+		__entry->id,
+		__entry->ext_id,
+		__entry->len
+	)
+);
+
+DEFINE_EVENT(mt7996_mcu_debug, mt7996_mcu_cmd,
+	TP_PROTO(struct mt7996_dev *dev, bool uni, u8 id, u8 ext_id,
+		 const void *data, size_t len),
+	TP_ARGS(dev, uni, id, ext_id, data, len)
+);
+
+DEFINE_EVENT(mt7996_mcu_debug, mt7996_mcu_event,
+	TP_PROTO(struct mt7996_dev *dev, bool uni, u8 id, u8 ext_id,
+		 const void *data, size_t len),
+	TP_ARGS(dev, uni, id, ext_id, data, len)
+);
+
+TRACE_EVENT(mt7996_tx_prepare,
+	TP_PROTO(struct mt7996_dev *dev, struct mt76_wcid *wcid, enum mt76_txq_id qid,
+		 const void *txwi, const void *data, size_t len),
+	TP_ARGS(dev, wcid, qid, txwi, data, len),
+
+	TP_STRUCT__entry(
+		DEV_ENTRY
+		__field(u16, wcid)
+		__field(u8, qid)
+		__array(u8, txwi, MT_TXD_SIZE)
+		__field(size_t, len)
+		__dynamic_array(u8, data, len)
+	),
+
+	TP_fast_assign(
+		DEV_ASSIGN(dev->mt76.phys[wcid->phy_idx]->hw->wiphy);
+		__entry->wcid = wcid->idx;
+		__entry->qid = qid;
+		memcpy(__entry->txwi, txwi, MT_TXD_SIZE);
+		__entry->len = len;
+		memcpy(__get_dynamic_array(data), data, len);
+	),
+
+	TP_printk(
+		DEV_PR_FMT " wcid: %u, qid: %u, len: %zu",
+		DEV_PR_ARG, __entry->wcid, __entry->qid, __entry->len
+	)
+);
+
+TRACE_EVENT(mt7996_fill_rx,
+	TP_PROTO(struct mt7996_phy *phy, const void *data, size_t len),
+	TP_ARGS(phy, data, len),
+
+	TP_STRUCT__entry(
+		DEV_ENTRY
+		__field(size_t, len)
+		__dynamic_array(u8, data, len)
+	),
+
+	TP_fast_assign(
+		DEV_ASSIGN(phy->mt76->hw->wiphy);
+		__entry->len = len;
+		memcpy(__get_dynamic_array(data), data, len);
+	),
+
+	TP_printk(
+		DEV_PR_FMT " len: %zu",
+		DEV_PR_ARG, __entry->len
+	)
+);
+
+TRACE_EVENT(mt7996_fill_rx_done,
+	TP_PROTO(struct mt7996_phy *phy, u16 seqno, u16 hdr_gap),
+	TP_ARGS(phy, seqno, hdr_gap),
+
+	TP_STRUCT__entry(
+		DEV_ENTRY
+		__field(u16, seqno)
+		__field(u16, hdr_gap)
+	),
+
+	TP_fast_assign(
+		DEV_ASSIGN(phy->mt76->hw->wiphy);
+		__entry->seqno = seqno;
+		__entry->hdr_gap = hdr_gap;
+	),
+
+	TP_printk(
+		DEV_PR_FMT " seqno: %u, hdr_gap: %u",
+		DEV_PR_ARG, __entry->seqno, __entry->hdr_gap
+	)
+);
+
+#endif
+
+#undef TRACE_INCLUDE_PATH
+#define TRACE_INCLUDE_PATH ./mt7996
+#undef TRACE_INCLUDE_FILE
+#define TRACE_INCLUDE_FILE mt7996_trace
+
+#include <trace/define_trace.h>
diff --git a/mt7996/mtk_debug.h b/mt7996/mtk_debug.h
new file mode 100644
index 00000000..82990239
--- /dev/null
+++ b/mt7996/mtk_debug.h
@@ -0,0 +1,2951 @@
+#ifndef __MTK_DEBUG_H
+#define __MTK_DEBUG_H
+
+#ifdef CONFIG_MTK_DEBUG
+#define NO_SHIFT_DEFINE 0xFFFFFFFF
+#define BITS(m, n)              (~(BIT(m)-1) & ((BIT(n) - 1) | BIT(n)))
+
+#define GET_FIELD(_field, _reg)	\
+	({	\
+		(((_reg) & (_field##_MASK)) >> (_field##_SHIFT));	\
+	})
+
+#define __DBG_OFFS(id)		(dev->dbg_reg->offs_rev[(id)])
+
+enum dbg_offs_rev {
+	AGG_AALCR2,
+	AGG_AALCR3,
+	AGG_AALCR4,
+	AGG_AALCR5,
+	AGG_AALCR6,
+	AGG_AALCR7,
+	MIB_TDRCR0,
+	MIB_TDRCR1,
+	MIB_TDRCR2,
+	MIB_TDRCR3,
+	MIB_TDRCR4,
+	MIB_RSCR26,
+	MIB_TSCR18,
+	MIB_TRDR0,
+	MIB_TRDR2,
+	MIB_TRDR3,
+	MIB_TRDR4,
+	MIB_TRDR5,
+	MIB_TRDR6,
+	MIB_TRDR7,
+	MIB_TRDR8,
+	MIB_TRDR9,
+	MIB_TRDR10,
+	MIB_TRDR11,
+	MIB_TRDR12,
+	MIB_TRDR13,
+	MIB_TRDR14,
+	MIB_TRDR15,
+	MIB_MSR0,
+	MIB_MSR1,
+	MIB_MSR2,
+	MIB_MCTR5,
+	MIB_MCTR6,
+	__MT_DBG_OFFS_REV_MAX,
+};
+
+static const u32 mt7996_dbg_offs[] = {
+	[AGG_AALCR2]		= 0x128,
+	[AGG_AALCR3]		= 0x12c,
+	[AGG_AALCR4]		= 0x130,
+	[AGG_AALCR5]		= 0x134,
+	[AGG_AALCR6]		= 0x138,
+	[AGG_AALCR7]		= 0x13c,
+	[MIB_TDRCR0]		= 0x728,
+	[MIB_TDRCR1]		= 0x72c,
+	[MIB_TDRCR2]		= 0x730,
+	[MIB_TDRCR3]		= 0x734,
+	[MIB_TDRCR4]		= 0x738,
+	[MIB_RSCR26]		= 0x950,
+	[MIB_TSCR18]		= 0xa1c,
+	[MIB_TRDR0]		= 0xa24,
+	[MIB_TRDR2]		= 0xa2c,
+	[MIB_TRDR3]		= 0xa30,
+	[MIB_TRDR4]		= 0xa34,
+	[MIB_TRDR5]		= 0xa38,
+	[MIB_TRDR6]		= 0xa3c,
+	[MIB_TRDR7]		= 0xa40,
+	[MIB_TRDR8]		= 0xa44,
+	[MIB_TRDR9]		= 0xa48,
+	[MIB_TRDR10]		= 0xa4c,
+	[MIB_TRDR11]		= 0xa50,
+	[MIB_TRDR12]		= 0xa54,
+	[MIB_TRDR13]		= 0xa58,
+	[MIB_TRDR14]		= 0xa5c,
+	[MIB_TRDR15]		= 0xa60,
+	[MIB_MSR0]		= 0xa64,
+	[MIB_MSR1]		= 0xa68,
+	[MIB_MSR2]		= 0xa6c,
+	[MIB_MCTR5]		= 0xa70,
+	[MIB_MCTR6]		= 0xa74,
+};
+
+static const u32 mt7992_dbg_offs[] = {
+	[AGG_AALCR2]		= 0x12c,
+	[AGG_AALCR3]		= 0x130,
+	[AGG_AALCR4]		= 0x134,
+	[AGG_AALCR5]		= 0x138,
+	[AGG_AALCR6]		= 0x13c,
+	[AGG_AALCR7]		= 0x140,
+	[MIB_TDRCR0]		= 0x768,
+	[MIB_TDRCR1]		= 0x76c,
+	[MIB_TDRCR2]		= 0x770,
+	[MIB_TDRCR3]		= 0x774,
+	[MIB_TDRCR4]		= 0x778,
+	[MIB_RSCR26]		= 0x994,
+	[MIB_TSCR18]		= 0xb18,
+	[MIB_TRDR0]		= 0xb20,
+	[MIB_TRDR2]		= 0xb28,
+	[MIB_TRDR3]		= 0xb2c,
+	[MIB_TRDR4]		= 0xb30,
+	[MIB_TRDR5]		= 0xb34,
+	[MIB_TRDR6]		= 0xb38,
+	[MIB_TRDR7]		= 0xb3c,
+	[MIB_TRDR8]		= 0xb40,
+	[MIB_TRDR9]		= 0xb44,
+	[MIB_TRDR10]		= 0xb48,
+	[MIB_TRDR11]		= 0xb4c,
+	[MIB_TRDR12]		= 0xb50,
+	[MIB_TRDR13]		= 0xb54,
+	[MIB_TRDR14]		= 0xb58,
+	[MIB_TRDR15]		= 0xb5c,
+	[MIB_MSR0]		= 0xb60,
+	[MIB_MSR1]		= 0xb64,
+	[MIB_MSR2]		= 0xb68,
+	[MIB_MCTR5]		= 0xb6c,
+	[MIB_MCTR6]		= 0xb70,
+};
+
+/* used to differentiate between generations */
+struct mt7996_dbg_reg_desc {
+	const u32 id;
+	const u32 *offs_rev;
+};
+
+/* AGG */
+#define BN0_WF_AGG_TOP_BASE                                    0x820e2000
+#define BN1_WF_AGG_TOP_BASE                                    0x820f2000
+#define IP1_BN0_WF_AGG_TOP_BASE                                0x830e2000
+
+#define BN0_WF_AGG_TOP_SCR_ADDR                                (BN0_WF_AGG_TOP_BASE + 0x0) // 2000
+#define BN0_WF_AGG_TOP_SCR0_ADDR                               (BN0_WF_AGG_TOP_BASE + 0x4) // 2004
+#define BN0_WF_AGG_TOP_SCR1_ADDR                               (BN0_WF_AGG_TOP_BASE + 0x8) // 2008
+#define BN0_WF_AGG_TOP_BCR_ADDR                                (BN0_WF_AGG_TOP_BASE + 0xc) // 200C
+#define BN0_WF_AGG_TOP_BWCR_ADDR                               (BN0_WF_AGG_TOP_BASE + 0x10) // 2010
+#define BN0_WF_AGG_TOP_ARCR0_ADDR                              (BN0_WF_AGG_TOP_BASE + 0x14) // 2014
+#define BN0_WF_AGG_TOP_ARUCR_ADDR                              (BN0_WF_AGG_TOP_BASE + 0x18) // 2018
+#define BN0_WF_AGG_TOP_ARDCR_ADDR                              (BN0_WF_AGG_TOP_BASE + 0x1c) // 201C
+#define BN0_WF_AGG_TOP_AALCR0_ADDR                             (BN0_WF_AGG_TOP_BASE + 0x20) // 2020
+#define BN0_WF_AGG_TOP_AALCR1_ADDR                             (BN0_WF_AGG_TOP_BASE + 0x24) // 2024
+#define BN0_WF_AGG_TOP_PCR0_ADDR                               (BN0_WF_AGG_TOP_BASE + 0x28) // 2028
+#define BN0_WF_AGG_TOP_PCR1_ADDR                               (BN0_WF_AGG_TOP_BASE + 0x2c) // 202C
+#define BN0_WF_AGG_TOP_TTCR0_ADDR                              (BN0_WF_AGG_TOP_BASE + 0x30) // 2030
+#define BN0_WF_AGG_TOP_TTCR1_ADDR                              (BN0_WF_AGG_TOP_BASE + 0x34) // 2034
+#define BN0_WF_AGG_TOP_ACR1_ADDR                               (BN0_WF_AGG_TOP_BASE + 0x38) // 2038
+#define BN0_WF_AGG_TOP_ACR4_ADDR                               (BN0_WF_AGG_TOP_BASE + 0x3c) // 203C
+#define BN0_WF_AGG_TOP_ACR5_ADDR                               (BN0_WF_AGG_TOP_BASE + 0x40) // 2040
+#define BN0_WF_AGG_TOP_ACR6_ADDR                               (BN0_WF_AGG_TOP_BASE + 0x44) // 2044
+#define BN0_WF_AGG_TOP_ACR8_ADDR                               (BN0_WF_AGG_TOP_BASE + 0x4c) // 204C
+#define BN0_WF_AGG_TOP_MRCR_ADDR                               (BN0_WF_AGG_TOP_BASE + 0x50) // 2050
+#define BN0_WF_AGG_TOP_MMPDR_ADDR                              (BN0_WF_AGG_TOP_BASE + 0x54) // 2054
+#define BN0_WF_AGG_TOP_GFPDR_ADDR                              (BN0_WF_AGG_TOP_BASE + 0x58) // 2058
+#define BN0_WF_AGG_TOP_VHTPDR_ADDR                             (BN0_WF_AGG_TOP_BASE + 0x5c) // 205C
+#define BN0_WF_AGG_TOP_HEPDR_ADDR                              (BN0_WF_AGG_TOP_BASE + 0x60) // 2060
+#define BN0_WF_AGG_TOP_CTCR_ADDR                               (BN0_WF_AGG_TOP_BASE + 0x64) // 2064
+#define BN0_WF_AGG_TOP_ATCR3_ADDR                              (BN0_WF_AGG_TOP_BASE + 0x68) // 2068
+#define BN0_WF_AGG_TOP_SRCR_ADDR                               (BN0_WF_AGG_TOP_BASE + 0x6c) // 206C
+#define BN0_WF_AGG_TOP_VBCR_ADDR                               (BN0_WF_AGG_TOP_BASE + 0x70) // 2070
+#define BN0_WF_AGG_TOP_TCR_ADDR                                (BN0_WF_AGG_TOP_BASE + 0x74) // 2074
+#define BN0_WF_AGG_TOP_SRHS_ADDR                               (BN0_WF_AGG_TOP_BASE + 0x78) // 2078
+#define BN0_WF_AGG_TOP_DBRCR0_ADDR                             (BN0_WF_AGG_TOP_BASE + 0x7c) // 207C
+#define BN0_WF_AGG_TOP_DBRCR1_ADDR                             (BN0_WF_AGG_TOP_BASE + 0x80) // 2080
+#define BN0_WF_AGG_TOP_CTETCR_ADDR                             (BN0_WF_AGG_TOP_BASE + 0x84) // 2084
+#define BN0_WF_AGG_TOP_WPDR_ADDR                               (BN0_WF_AGG_TOP_BASE + 0x88) // 2088
+#define BN0_WF_AGG_TOP_PLRPDR_ADDR                             (BN0_WF_AGG_TOP_BASE + 0x8c) // 208C
+#define BN0_WF_AGG_TOP_CECR_ADDR                               (BN0_WF_AGG_TOP_BASE + 0x90) // 2090
+#define BN0_WF_AGG_TOP_OMRCR0_ADDR                             (BN0_WF_AGG_TOP_BASE + 0x94) // 2094
+#define BN0_WF_AGG_TOP_OMRCR1_ADDR                             (BN0_WF_AGG_TOP_BASE + 0x98) // 2098
+#define BN0_WF_AGG_TOP_OMRCR2_ADDR                             (BN0_WF_AGG_TOP_BASE + 0x9c) // 209C
+#define BN0_WF_AGG_TOP_OMRCR3_ADDR                             (BN0_WF_AGG_TOP_BASE + 0xa0) // 20A0
+#define BN0_WF_AGG_TOP_TMCR_ADDR                               (BN0_WF_AGG_TOP_BASE + 0xa4) // 20A4
+#define BN0_WF_AGG_TOP_TWTCR_ADDR                              (BN0_WF_AGG_TOP_BASE + 0xa8) // 20A8
+#define BN0_WF_AGG_TOP_TWTSTACR_ADDR                           (BN0_WF_AGG_TOP_BASE + 0xac) // 20AC
+#define BN0_WF_AGG_TOP_TWTE0TB_ADDR                            (BN0_WF_AGG_TOP_BASE + 0xb0) // 20B0
+#define BN0_WF_AGG_TOP_TWTE1TB_ADDR                            (BN0_WF_AGG_TOP_BASE + 0xb4) // 20B4
+#define BN0_WF_AGG_TOP_TWTE2TB_ADDR                            (BN0_WF_AGG_TOP_BASE + 0xb8) // 20B8
+#define BN0_WF_AGG_TOP_TWTE3TB_ADDR                            (BN0_WF_AGG_TOP_BASE + 0xbc) // 20BC
+#define BN0_WF_AGG_TOP_TWTE4TB_ADDR                            (BN0_WF_AGG_TOP_BASE + 0xc0) // 20C0
+#define BN0_WF_AGG_TOP_TWTE5TB_ADDR                            (BN0_WF_AGG_TOP_BASE + 0xc4) // 20C4
+#define BN0_WF_AGG_TOP_TWTE6TB_ADDR                            (BN0_WF_AGG_TOP_BASE + 0xc8) // 20C8
+#define BN0_WF_AGG_TOP_TWTE7TB_ADDR                            (BN0_WF_AGG_TOP_BASE + 0xcc) // 20CC
+#define BN0_WF_AGG_TOP_TWTE8TB_ADDR                            (BN0_WF_AGG_TOP_BASE + 0xd0) // 20D0
+#define BN0_WF_AGG_TOP_TWTE9TB_ADDR                            (BN0_WF_AGG_TOP_BASE + 0xd4) // 20D4
+#define BN0_WF_AGG_TOP_TWTEATB_ADDR                            (BN0_WF_AGG_TOP_BASE + 0xd8) // 20D8
+#define BN0_WF_AGG_TOP_TWTEBTB_ADDR                            (BN0_WF_AGG_TOP_BASE + 0xdc) // 20DC
+#define BN0_WF_AGG_TOP_TWTECTB_ADDR                            (BN0_WF_AGG_TOP_BASE + 0xe0) // 20E0
+#define BN0_WF_AGG_TOP_TWTEDTB_ADDR                            (BN0_WF_AGG_TOP_BASE + 0xe4) // 20E4
+#define BN0_WF_AGG_TOP_TWTEETB_ADDR                            (BN0_WF_AGG_TOP_BASE + 0xe8) // 20E8
+#define BN0_WF_AGG_TOP_TWTEFTB_ADDR                            (BN0_WF_AGG_TOP_BASE + 0xec) // 20EC
+#define BN0_WF_AGG_TOP_ATCR0_ADDR                              (BN0_WF_AGG_TOP_BASE + 0x108) // 2108
+#define BN0_WF_AGG_TOP_ATCR1_ADDR                              (BN0_WF_AGG_TOP_BASE + 0x10c) // 210C
+#define BN0_WF_AGG_TOP_TCCR_ADDR                               (BN0_WF_AGG_TOP_BASE + 0x110) // 2110
+#define BN0_WF_AGG_TOP_TFCR_ADDR                               (BN0_WF_AGG_TOP_BASE + 0x114) // 2114
+#define BN0_WF_AGG_TOP_MUCR0_ADDR                              (BN0_WF_AGG_TOP_BASE + 0x118) // 2118
+#define BN0_WF_AGG_TOP_MUCR1_ADDR                              (BN0_WF_AGG_TOP_BASE + 0x11c) // 211C
+#define BN0_WF_AGG_TOP_AALCR2_ADDR                             (BN0_WF_AGG_TOP_BASE + __DBG_OFFS(AGG_AALCR2))
+#define BN0_WF_AGG_TOP_AALCR3_ADDR                             (BN0_WF_AGG_TOP_BASE + __DBG_OFFS(AGG_AALCR3))
+#define BN0_WF_AGG_TOP_AALCR4_ADDR                             (BN0_WF_AGG_TOP_BASE + __DBG_OFFS(AGG_AALCR4))
+#define BN0_WF_AGG_TOP_AALCR5_ADDR                             (BN0_WF_AGG_TOP_BASE + __DBG_OFFS(AGG_AALCR5))
+#define BN0_WF_AGG_TOP_AALCR6_ADDR                             (BN0_WF_AGG_TOP_BASE + __DBG_OFFS(AGG_AALCR6))
+#define BN0_WF_AGG_TOP_AALCR7_ADDR                             (BN0_WF_AGG_TOP_BASE + __DBG_OFFS(AGG_AALCR7))
+#define BN0_WF_AGG_TOP_CSDCR0_ADDR                             (BN0_WF_AGG_TOP_BASE + 0x150) // 2150
+#define BN0_WF_AGG_TOP_CSDCR1_ADDR                             (BN0_WF_AGG_TOP_BASE + 0x154) // 2154
+#define BN0_WF_AGG_TOP_CSDCR2_ADDR                             (BN0_WF_AGG_TOP_BASE + 0x158) // 2158
+#define BN0_WF_AGG_TOP_CSDCR3_ADDR                             (BN0_WF_AGG_TOP_BASE + 0x15c) // 215C
+#define BN0_WF_AGG_TOP_CSDCR4_ADDR                             (BN0_WF_AGG_TOP_BASE + 0x160) // 2160
+#define BN0_WF_AGG_TOP_DYNSCR_ADDR                             (BN0_WF_AGG_TOP_BASE + 0x178) // 2178
+#define BN0_WF_AGG_TOP_DYNSSCR_ADDR                            (BN0_WF_AGG_TOP_BASE + 0x198) // 2198
+#define BN0_WF_AGG_TOP_TCDCNT0_ADDR                            (BN0_WF_AGG_TOP_BASE + 0x2c8) // 22C8
+#define BN0_WF_AGG_TOP_TCDCNT1_ADDR                            (BN0_WF_AGG_TOP_BASE + 0x2cc) // 22CC
+#define BN0_WF_AGG_TOP_TCSR0_ADDR                              (BN0_WF_AGG_TOP_BASE + 0x2d0) // 22D0
+#define BN0_WF_AGG_TOP_TCSR1_ADDR                              (BN0_WF_AGG_TOP_BASE + 0x2d4) // 22D4
+#define BN0_WF_AGG_TOP_TCSR2_ADDR                              (BN0_WF_AGG_TOP_BASE + 0x2d8) // 22D8
+#define BN0_WF_AGG_TOP_DCR_ADDR                                (BN0_WF_AGG_TOP_BASE + 0x2e4) // 22E4
+#define BN0_WF_AGG_TOP_SMDCR_ADDR                              (BN0_WF_AGG_TOP_BASE + 0x2e8) // 22E8
+#define BN0_WF_AGG_TOP_TXCMDSMCR_ADDR                          (BN0_WF_AGG_TOP_BASE + 0x2ec) // 22EC
+#define BN0_WF_AGG_TOP_SMCR0_ADDR                              (BN0_WF_AGG_TOP_BASE + 0x2f0) // 22F0
+#define BN0_WF_AGG_TOP_SMCR1_ADDR                              (BN0_WF_AGG_TOP_BASE + 0x2f4) // 22F4
+#define BN0_WF_AGG_TOP_SMCR2_ADDR                              (BN0_WF_AGG_TOP_BASE + 0x2f8) // 22F8
+#define BN0_WF_AGG_TOP_SMCR3_ADDR                              (BN0_WF_AGG_TOP_BASE + 0x2fc) // 22FC
+
+#define BN0_WF_AGG_TOP_AALCR0_AC01_AGG_LIMIT_ADDR              BN0_WF_AGG_TOP_AALCR0_ADDR
+#define BN0_WF_AGG_TOP_AALCR0_AC01_AGG_LIMIT_MASK              0x03FF0000                // AC01_AGG_LIMIT[25..16]
+#define BN0_WF_AGG_TOP_AALCR0_AC01_AGG_LIMIT_SHFT              16
+#define BN0_WF_AGG_TOP_AALCR0_AC00_AGG_LIMIT_ADDR              BN0_WF_AGG_TOP_AALCR0_ADDR
+#define BN0_WF_AGG_TOP_AALCR0_AC00_AGG_LIMIT_MASK              0x000003FF                // AC00_AGG_LIMIT[9..0]
+#define BN0_WF_AGG_TOP_AALCR0_AC00_AGG_LIMIT_SHFT              0
+
+#define BN0_WF_AGG_TOP_AALCR1_AC03_AGG_LIMIT_ADDR              BN0_WF_AGG_TOP_AALCR1_ADDR
+#define BN0_WF_AGG_TOP_AALCR1_AC03_AGG_LIMIT_MASK              0x03FF0000                // AC03_AGG_LIMIT[25..16]
+#define BN0_WF_AGG_TOP_AALCR1_AC03_AGG_LIMIT_SHFT              16
+#define BN0_WF_AGG_TOP_AALCR1_AC02_AGG_LIMIT_ADDR              BN0_WF_AGG_TOP_AALCR1_ADDR
+#define BN0_WF_AGG_TOP_AALCR1_AC02_AGG_LIMIT_MASK              0x000003FF                // AC02_AGG_LIMIT[9..0]
+#define BN0_WF_AGG_TOP_AALCR1_AC02_AGG_LIMIT_SHFT              0
+
+#define BN0_WF_AGG_TOP_AALCR2_AC11_AGG_LIMIT_ADDR              BN0_WF_AGG_TOP_AALCR2_ADDR
+#define BN0_WF_AGG_TOP_AALCR2_AC11_AGG_LIMIT_MASK              0x03FF0000                // AC11_AGG_LIMIT[25..16]
+#define BN0_WF_AGG_TOP_AALCR2_AC11_AGG_LIMIT_SHFT              16
+#define BN0_WF_AGG_TOP_AALCR2_AC10_AGG_LIMIT_ADDR              BN0_WF_AGG_TOP_AALCR2_ADDR
+#define BN0_WF_AGG_TOP_AALCR2_AC10_AGG_LIMIT_MASK              0x000003FF                // AC10_AGG_LIMIT[9..0]
+#define BN0_WF_AGG_TOP_AALCR2_AC10_AGG_LIMIT_SHFT              0
+
+#define BN0_WF_AGG_TOP_AALCR3_AC13_AGG_LIMIT_ADDR              BN0_WF_AGG_TOP_AALCR3_ADDR
+#define BN0_WF_AGG_TOP_AALCR3_AC13_AGG_LIMIT_MASK              0x03FF0000                // AC13_AGG_LIMIT[25..16]
+#define BN0_WF_AGG_TOP_AALCR3_AC13_AGG_LIMIT_SHFT              16
+#define BN0_WF_AGG_TOP_AALCR3_AC12_AGG_LIMIT_ADDR              BN0_WF_AGG_TOP_AALCR3_ADDR
+#define BN0_WF_AGG_TOP_AALCR3_AC12_AGG_LIMIT_MASK              0x000003FF                // AC12_AGG_LIMIT[9..0]
+#define BN0_WF_AGG_TOP_AALCR3_AC12_AGG_LIMIT_SHFT              0
+
+#define BN0_WF_AGG_TOP_AALCR4_AC21_AGG_LIMIT_ADDR              BN0_WF_AGG_TOP_AALCR4_ADDR
+#define BN0_WF_AGG_TOP_AALCR4_AC21_AGG_LIMIT_MASK              0x03FF0000                // AC21_AGG_LIMIT[25..16]
+#define BN0_WF_AGG_TOP_AALCR4_AC21_AGG_LIMIT_SHFT              16
+#define BN0_WF_AGG_TOP_AALCR4_AC20_AGG_LIMIT_ADDR              BN0_WF_AGG_TOP_AALCR4_ADDR
+#define BN0_WF_AGG_TOP_AALCR4_AC20_AGG_LIMIT_MASK              0x000003FF                // AC20_AGG_LIMIT[9..0]
+#define BN0_WF_AGG_TOP_AALCR4_AC20_AGG_LIMIT_SHFT              0
+
+#define BN0_WF_AGG_TOP_AALCR5_AC23_AGG_LIMIT_ADDR              BN0_WF_AGG_TOP_AALCR5_ADDR
+#define BN0_WF_AGG_TOP_AALCR5_AC23_AGG_LIMIT_MASK              0x03FF0000                // AC23_AGG_LIMIT[25..16]
+#define BN0_WF_AGG_TOP_AALCR5_AC23_AGG_LIMIT_SHFT              16
+#define BN0_WF_AGG_TOP_AALCR5_AC22_AGG_LIMIT_ADDR              BN0_WF_AGG_TOP_AALCR5_ADDR
+#define BN0_WF_AGG_TOP_AALCR5_AC22_AGG_LIMIT_MASK              0x000003FF                // AC22_AGG_LIMIT[9..0]
+#define BN0_WF_AGG_TOP_AALCR5_AC22_AGG_LIMIT_SHFT              0
+
+#define BN0_WF_AGG_TOP_AALCR6_AC31_AGG_LIMIT_ADDR              BN0_WF_AGG_TOP_AALCR6_ADDR
+#define BN0_WF_AGG_TOP_AALCR6_AC31_AGG_LIMIT_MASK              0x03FF0000                // AC31_AGG_LIMIT[25..16]
+#define BN0_WF_AGG_TOP_AALCR6_AC31_AGG_LIMIT_SHFT              16
+#define BN0_WF_AGG_TOP_AALCR6_AC30_AGG_LIMIT_ADDR              BN0_WF_AGG_TOP_AALCR6_ADDR
+#define BN0_WF_AGG_TOP_AALCR6_AC30_AGG_LIMIT_MASK              0x000003FF                // AC30_AGG_LIMIT[9..0]
+#define BN0_WF_AGG_TOP_AALCR6_AC30_AGG_LIMIT_SHFT              0
+#define BN0_WF_AGG_TOP_AALCR7_AC33_AGG_LIMIT_ADDR              BN0_WF_AGG_TOP_AALCR7_ADDR
+#define BN0_WF_AGG_TOP_AALCR7_AC33_AGG_LIMIT_MASK              0x03FF0000                // AC33_AGG_LIMIT[25..16]
+#define BN0_WF_AGG_TOP_AALCR7_AC33_AGG_LIMIT_SHFT              16
+#define BN0_WF_AGG_TOP_AALCR7_AC32_AGG_LIMIT_ADDR              BN0_WF_AGG_TOP_AALCR7_ADDR
+#define BN0_WF_AGG_TOP_AALCR7_AC32_AGG_LIMIT_MASK              0x000003FF                // AC32_AGG_LIMIT[9..0]
+#define BN0_WF_AGG_TOP_AALCR7_AC32_AGG_LIMIT_SHFT              0
+
+/* DMA */
+struct queue_desc {
+	u32 hw_desc_base;
+	u16 ring_size;
+	char *const ring_info;
+};
+
+// HOST DMA
+#define WF_WFDMA_HOST_DMA0_BASE                                0xd4000
+
+#define WF_WFDMA_HOST_DMA0_HOST_INT_STA_ADDR                                   \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x200) /* 4200 */
+#define WF_WFDMA_HOST_DMA0_HOST_INT_ENA_ADDR                                   \
+	(WF_WFDMA_HOST_DMA0_BASE + 0X204) /* 4204 */
+#define WF_WFDMA_HOST_DMA0_WPDMA_GLO_CFG_ADDR                                  \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x208) /* 4208 */
+
+#define WF_WFDMA_HOST_DMA0_WPDMA_GLO_CFG_RX_DMA_BUSY_ADDR                      \
+	WF_WFDMA_HOST_DMA0_WPDMA_GLO_CFG_ADDR
+#define WF_WFDMA_HOST_DMA0_WPDMA_GLO_CFG_RX_DMA_BUSY_MASK                      \
+	0x00000008 /* RX_DMA_BUSY[3] */
+#define WF_WFDMA_HOST_DMA0_WPDMA_GLO_CFG_RX_DMA_BUSY_SHFT 3
+#define WF_WFDMA_HOST_DMA0_WPDMA_GLO_CFG_RX_DMA_EN_ADDR                        \
+	WF_WFDMA_HOST_DMA0_WPDMA_GLO_CFG_ADDR
+#define WF_WFDMA_HOST_DMA0_WPDMA_GLO_CFG_RX_DMA_EN_MASK                        \
+	0x00000004 /* RX_DMA_EN[2] */
+#define WF_WFDMA_HOST_DMA0_WPDMA_GLO_CFG_RX_DMA_EN_SHFT 2
+#define WF_WFDMA_HOST_DMA0_WPDMA_GLO_CFG_TX_DMA_BUSY_ADDR                      \
+	WF_WFDMA_HOST_DMA0_WPDMA_GLO_CFG_ADDR
+#define WF_WFDMA_HOST_DMA0_WPDMA_GLO_CFG_TX_DMA_BUSY_MASK                      \
+	0x00000002 /* TX_DMA_BUSY[1] */
+#define WF_WFDMA_HOST_DMA0_WPDMA_GLO_CFG_TX_DMA_BUSY_SHFT 1
+#define WF_WFDMA_HOST_DMA0_WPDMA_GLO_CFG_TX_DMA_EN_ADDR                        \
+	WF_WFDMA_HOST_DMA0_WPDMA_GLO_CFG_ADDR
+#define WF_WFDMA_HOST_DMA0_WPDMA_GLO_CFG_TX_DMA_EN_MASK                        \
+	0x00000001 /* TX_DMA_EN[0] */
+#define WF_WFDMA_HOST_DMA0_WPDMA_GLO_CFG_TX_DMA_EN_SHFT 0
+
+
+#define WF_WFDMA_HOST_DMA0_WPDMA_TX_RING0_CTRL0_ADDR                           \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x300) /* 4300 */
+#define WF_WFDMA_HOST_DMA0_WPDMA_TX_RING0_CTRL1_ADDR                           \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x304) /* 4304 */
+#define WF_WFDMA_HOST_DMA0_WPDMA_TX_RING0_CTRL2_ADDR                           \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x308) /* 4308 */
+#define WF_WFDMA_HOST_DMA0_WPDMA_TX_RING0_CTRL3_ADDR                           \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x30c) /* 430C */
+#define WF_WFDMA_HOST_DMA0_WPDMA_TX_RING1_CTRL0_ADDR                           \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x310) /* 4310 */
+#define WF_WFDMA_HOST_DMA0_WPDMA_TX_RING1_CTRL1_ADDR                           \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x314) /* 4314 */
+#define WF_WFDMA_HOST_DMA0_WPDMA_TX_RING1_CTRL2_ADDR                           \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x318) /* 4318 */
+#define WF_WFDMA_HOST_DMA0_WPDMA_TX_RING1_CTRL3_ADDR                           \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x31c) /* 431C */
+#define WF_WFDMA_HOST_DMA0_WPDMA_TX_RING2_CTRL0_ADDR                           \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x320) /* 4320 */
+#define WF_WFDMA_HOST_DMA0_WPDMA_TX_RING2_CTRL1_ADDR                           \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x324) /* 4324 */
+#define WF_WFDMA_HOST_DMA0_WPDMA_TX_RING2_CTRL2_ADDR                           \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x328) /* 4328 */
+#define WF_WFDMA_HOST_DMA0_WPDMA_TX_RING2_CTRL3_ADDR                           \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x32c) /* 432C */
+#define WF_WFDMA_HOST_DMA0_WPDMA_TX_RING3_CTRL0_ADDR                           \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x330) /* 4330 */
+#define WF_WFDMA_HOST_DMA0_WPDMA_TX_RING3_CTRL1_ADDR                           \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x334) /* 4334 */
+#define WF_WFDMA_HOST_DMA0_WPDMA_TX_RING3_CTRL2_ADDR                           \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x338) /* 4338 */
+#define WF_WFDMA_HOST_DMA0_WPDMA_TX_RING3_CTRL3_ADDR                           \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x33c) /* 433C */
+#define WF_WFDMA_HOST_DMA0_WPDMA_TX_RING4_CTRL0_ADDR                           \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x340) /* 4340 */
+#define WF_WFDMA_HOST_DMA0_WPDMA_TX_RING4_CTRL1_ADDR                           \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x344) /* 4344 */
+#define WF_WFDMA_HOST_DMA0_WPDMA_TX_RING4_CTRL2_ADDR                           \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x348) /* 4348 */
+#define WF_WFDMA_HOST_DMA0_WPDMA_TX_RING4_CTRL3_ADDR                           \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x34c) /* 434C */
+#define WF_WFDMA_HOST_DMA0_WPDMA_TX_RING5_CTRL0_ADDR                           \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x350) /* 4350 */
+#define WF_WFDMA_HOST_DMA0_WPDMA_TX_RING5_CTRL1_ADDR                           \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x354) /* 4354 */
+#define WF_WFDMA_HOST_DMA0_WPDMA_TX_RING5_CTRL2_ADDR                           \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x358) /* 4358 */
+#define WF_WFDMA_HOST_DMA0_WPDMA_TX_RING5_CTRL3_ADDR                           \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x35c) /* 435C */
+#define WF_WFDMA_HOST_DMA0_WPDMA_TX_RING6_CTRL0_ADDR                           \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x360) /* 4360 */
+#define WF_WFDMA_HOST_DMA0_WPDMA_TX_RING6_CTRL1_ADDR                           \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x364) /* 4364 */
+#define WF_WFDMA_HOST_DMA0_WPDMA_TX_RING6_CTRL2_ADDR                           \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x368) /* 4368 */
+#define WF_WFDMA_HOST_DMA0_WPDMA_TX_RING6_CTRL3_ADDR                           \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x36c) /* 436C */
+#define WF_WFDMA_HOST_DMA0_WPDMA_TX_RING16_CTRL0_ADDR                          \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x400) /* 4400 */
+#define WF_WFDMA_HOST_DMA0_WPDMA_TX_RING16_CTRL1_ADDR                          \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x404) /* 4404 */
+#define WF_WFDMA_HOST_DMA0_WPDMA_TX_RING16_CTRL2_ADDR                          \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x408) /* 4408 */
+#define WF_WFDMA_HOST_DMA0_WPDMA_TX_RING16_CTRL3_ADDR                          \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x40c) /* 440C */
+#define WF_WFDMA_HOST_DMA0_WPDMA_TX_RING17_CTRL0_ADDR                          \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x410) /* 4410 */
+#define WF_WFDMA_HOST_DMA0_WPDMA_TX_RING17_CTRL1_ADDR                          \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x414) /* 4414 */
+#define WF_WFDMA_HOST_DMA0_WPDMA_TX_RING17_CTRL2_ADDR                          \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x418) /* 4418 */
+#define WF_WFDMA_HOST_DMA0_WPDMA_TX_RING17_CTRL3_ADDR                          \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x41c) /* 441C */
+#define WF_WFDMA_HOST_DMA0_WPDMA_TX_RING18_CTRL0_ADDR                          \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x420) /* 4420 */
+#define WF_WFDMA_HOST_DMA0_WPDMA_TX_RING18_CTRL1_ADDR                          \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x424) /* 4424 */
+#define WF_WFDMA_HOST_DMA0_WPDMA_TX_RING18_CTRL2_ADDR                          \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x428) /* 4428 */
+#define WF_WFDMA_HOST_DMA0_WPDMA_TX_RING18_CTRL3_ADDR                          \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x42c) /* 442C */
+#define WF_WFDMA_HOST_DMA0_WPDMA_TX_RING19_CTRL0_ADDR                          \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x430) /* 4430 */
+#define WF_WFDMA_HOST_DMA0_WPDMA_TX_RING19_CTRL1_ADDR                          \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x434) /* 4434 */
+#define WF_WFDMA_HOST_DMA0_WPDMA_TX_RING19_CTRL2_ADDR                          \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x438) /* 4438 */
+#define WF_WFDMA_HOST_DMA0_WPDMA_TX_RING19_CTRL3_ADDR                          \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x43c) /* 443C */
+#define WF_WFDMA_HOST_DMA0_WPDMA_TX_RING20_CTRL0_ADDR                          \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x440) /* 4440 */
+#define WF_WFDMA_HOST_DMA0_WPDMA_TX_RING20_CTRL1_ADDR                          \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x444) /* 4444 */
+#define WF_WFDMA_HOST_DMA0_WPDMA_TX_RING20_CTRL2_ADDR                          \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x448) /* 4448 */
+#define WF_WFDMA_HOST_DMA0_WPDMA_TX_RING20_CTRL3_ADDR                          \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x44c) /* 444C */
+#define WF_WFDMA_HOST_DMA0_WPDMA_TX_RING21_CTRL0_ADDR                          \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x450) /* 4450 */
+#define WF_WFDMA_HOST_DMA0_WPDMA_TX_RING21_CTRL1_ADDR                          \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x454) /* 4454 */
+#define WF_WFDMA_HOST_DMA0_WPDMA_TX_RING21_CTRL2_ADDR                          \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x458) /* 4458 */
+#define WF_WFDMA_HOST_DMA0_WPDMA_TX_RING21_CTRL3_ADDR                          \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x45c) /* 445c */
+#define WF_WFDMA_HOST_DMA0_WPDMA_TX_RING22_CTRL0_ADDR          (WF_WFDMA_HOST_DMA0_BASE + 0x460) // 4460
+#define WF_WFDMA_HOST_DMA0_WPDMA_TX_RING22_CTRL1_ADDR          (WF_WFDMA_HOST_DMA0_BASE + 0x464) // 4464
+#define WF_WFDMA_HOST_DMA0_WPDMA_TX_RING22_CTRL2_ADDR          (WF_WFDMA_HOST_DMA0_BASE + 0x468) // 4468
+#define WF_WFDMA_HOST_DMA0_WPDMA_TX_RING22_CTRL3_ADDR          (WF_WFDMA_HOST_DMA0_BASE + 0x46c) // 446C
+
+#define WF_WFDMA_HOST_DMA0_WPDMA_RX_RING0_CTRL0_ADDR                           \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x500) /* 4500 */
+#define WF_WFDMA_HOST_DMA0_WPDMA_RX_RING0_CTRL1_ADDR                           \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x504) /* 4504 */
+#define WF_WFDMA_HOST_DMA0_WPDMA_RX_RING0_CTRL2_ADDR                           \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x508) /* 4508 */
+#define WF_WFDMA_HOST_DMA0_WPDMA_RX_RING0_CTRL3_ADDR                           \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x50c) /* 450C */
+#define WF_WFDMA_HOST_DMA0_WPDMA_RX_RING1_CTRL0_ADDR                           \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x510) /* 4510 */
+#define WF_WFDMA_HOST_DMA0_WPDMA_RX_RING1_CTRL1_ADDR                           \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x514) /* 4514 */
+#define WF_WFDMA_HOST_DMA0_WPDMA_RX_RING1_CTRL2_ADDR                           \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x518) /* 4518 */
+#define WF_WFDMA_HOST_DMA0_WPDMA_RX_RING1_CTRL3_ADDR                           \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x51c) /* 451C */
+#define WF_WFDMA_HOST_DMA0_WPDMA_RX_RING2_CTRL0_ADDR                           \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x520) /* 4520 */
+#define WF_WFDMA_HOST_DMA0_WPDMA_RX_RING2_CTRL1_ADDR                           \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x524) /* 4524 */
+#define WF_WFDMA_HOST_DMA0_WPDMA_RX_RING2_CTRL2_ADDR                           \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x528) /* 4528 */
+#define WF_WFDMA_HOST_DMA0_WPDMA_RX_RING2_CTRL3_ADDR                           \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x52C) /* 452C */
+#define WF_WFDMA_HOST_DMA0_WPDMA_RX_RING3_CTRL0_ADDR                           \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x530) /* 4530 */
+#define WF_WFDMA_HOST_DMA0_WPDMA_RX_RING3_CTRL1_ADDR                           \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x534) /* 4534 */
+#define WF_WFDMA_HOST_DMA0_WPDMA_RX_RING3_CTRL2_ADDR                           \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x538) /* 4538 */
+#define WF_WFDMA_HOST_DMA0_WPDMA_RX_RING3_CTRL3_ADDR                           \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x53C) /* 453C */
+#define WF_WFDMA_HOST_DMA0_WPDMA_RX_RING4_CTRL0_ADDR                           \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x540) /* 4540 */
+#define WF_WFDMA_HOST_DMA0_WPDMA_RX_RING4_CTRL1_ADDR                           \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x544) /* 4544 */
+#define WF_WFDMA_HOST_DMA0_WPDMA_RX_RING4_CTRL2_ADDR                           \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x548) /* 4548 */
+#define WF_WFDMA_HOST_DMA0_WPDMA_RX_RING4_CTRL3_ADDR                           \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x54c) /* 454C */
+#define WF_WFDMA_HOST_DMA0_WPDMA_RX_RING5_CTRL0_ADDR                           \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x550) /* 4550 */
+#define WF_WFDMA_HOST_DMA0_WPDMA_RX_RING5_CTRL1_ADDR                           \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x554) /* 4554 */
+#define WF_WFDMA_HOST_DMA0_WPDMA_RX_RING5_CTRL2_ADDR                           \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x558) /* 4558 */
+#define WF_WFDMA_HOST_DMA0_WPDMA_RX_RING5_CTRL3_ADDR                           \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x55c) /* 455C */
+#define WF_WFDMA_HOST_DMA0_WPDMA_RX_RING6_CTRL0_ADDR                           \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x560) /* 4560 */
+#define WF_WFDMA_HOST_DMA0_WPDMA_RX_RING6_CTRL1_ADDR                           \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x564) /* 4564 */
+#define WF_WFDMA_HOST_DMA0_WPDMA_RX_RING6_CTRL2_ADDR                           \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x568) /* 4568 */
+#define WF_WFDMA_HOST_DMA0_WPDMA_RX_RING6_CTRL3_ADDR                           \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x56c) /* 456C */
+#define WF_WFDMA_HOST_DMA0_WPDMA_RX_RING7_CTRL0_ADDR                           \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x570) /* 4570 */
+#define WF_WFDMA_HOST_DMA0_WPDMA_RX_RING7_CTRL1_ADDR                           \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x574) /* 4574 */
+#define WF_WFDMA_HOST_DMA0_WPDMA_RX_RING7_CTRL2_ADDR                           \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x578) /* 4578 */
+#define WF_WFDMA_HOST_DMA0_WPDMA_RX_RING7_CTRL3_ADDR                           \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x57c) /* 457C */
+#define WF_WFDMA_HOST_DMA0_WPDMA_RX_RING8_CTRL0_ADDR                           \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x580) /* 4580 */
+#define WF_WFDMA_HOST_DMA0_WPDMA_RX_RING8_CTRL1_ADDR                           \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x584) /* 4584 */
+#define WF_WFDMA_HOST_DMA0_WPDMA_RX_RING8_CTRL2_ADDR                           \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x588) /* 4588 */
+#define WF_WFDMA_HOST_DMA0_WPDMA_RX_RING8_CTRL3_ADDR                           \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x58c) /* 458C */
+#define WF_WFDMA_HOST_DMA0_WPDMA_RX_RING9_CTRL0_ADDR                           \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x590) /* 4590 */
+#define WF_WFDMA_HOST_DMA0_WPDMA_RX_RING9_CTRL1_ADDR                           \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x594) /* 4594 */
+#define WF_WFDMA_HOST_DMA0_WPDMA_RX_RING9_CTRL2_ADDR                           \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x598) /* 4598 */
+#define WF_WFDMA_HOST_DMA0_WPDMA_RX_RING9_CTRL3_ADDR                           \
+	(WF_WFDMA_HOST_DMA0_BASE + 0x59c) /* 459C */
+#define WF_WFDMA_HOST_DMA0_WPDMA_RX_RING10_CTRL0_ADDR          (WF_WFDMA_HOST_DMA0_BASE + 0x5a0) // 45A0
+#define WF_WFDMA_HOST_DMA0_WPDMA_RX_RING10_CTRL1_ADDR          (WF_WFDMA_HOST_DMA0_BASE + 0x5a4) // 45A4
+#define WF_WFDMA_HOST_DMA0_WPDMA_RX_RING10_CTRL2_ADDR          (WF_WFDMA_HOST_DMA0_BASE + 0x5a8) // 45A8
+#define WF_WFDMA_HOST_DMA0_WPDMA_RX_RING10_CTRL3_ADDR          (WF_WFDMA_HOST_DMA0_BASE + 0x5ac) // 45AC
+#define WF_WFDMA_HOST_DMA0_WPDMA_RX_RING11_CTRL0_ADDR          (WF_WFDMA_HOST_DMA0_BASE + 0x5b0) // 45B0
+#define WF_WFDMA_HOST_DMA0_WPDMA_RX_RING11_CTRL1_ADDR          (WF_WFDMA_HOST_DMA0_BASE + 0x5b4) // 45B4
+#define WF_WFDMA_HOST_DMA0_WPDMA_RX_RING11_CTRL2_ADDR          (WF_WFDMA_HOST_DMA0_BASE + 0x5b8) // 45B8
+#define WF_WFDMA_HOST_DMA0_WPDMA_RX_RING11_CTRL3_ADDR          (WF_WFDMA_HOST_DMA0_BASE + 0x5bc) // 45BC
+#define WF_WFDMA_HOST_DMA0_WPDMA_RX_RING12_CTRL0_ADDR          (WF_WFDMA_HOST_DMA0_BASE + 0x5C0) // 45C0
+#define WF_WFDMA_HOST_DMA0_WPDMA_RX_RING12_CTRL1_ADDR          (WF_WFDMA_HOST_DMA0_BASE + 0x5C4) // 45C4
+#define WF_WFDMA_HOST_DMA0_WPDMA_RX_RING12_CTRL2_ADDR          (WF_WFDMA_HOST_DMA0_BASE + 0x5C8) // 45C8
+#define WF_WFDMA_HOST_DMA0_WPDMA_RX_RING12_CTRL3_ADDR          (WF_WFDMA_HOST_DMA0_BASE + 0x5CC) // 45CC
+
+// HOST PCIE1 DMA
+#define WF_WFDMA_HOST_DMA0_PCIE1_BASE				0xd8000
+
+#define WF_WFDMA_HOST_DMA0_PCIE1_HOST_INT_STA_ADDR		(WF_WFDMA_HOST_DMA0_PCIE1_BASE + 0x200) // 8200
+#define WF_WFDMA_HOST_DMA0_PCIE1_HOST_INT_ENA_ADDR		(WF_WFDMA_HOST_DMA0_PCIE1_BASE + 0X204) // 8204
+#define WF_WFDMA_HOST_DMA0_PCIE1_WPDMA_GLO_CFG_ADDR		(WF_WFDMA_HOST_DMA0_PCIE1_BASE + 0x208) // 8208
+
+#define WF_WFDMA_HOST_DMA0_PCIE1_WPDMA_GLO_CFG_PDMA_BT_SIZE_SHFT	4
+#define WF_WFDMA_HOST_DMA0_PCIE1_WPDMA_GLO_CFG_RX_DMA_BUSY_MASK		0x00000008
+#define WF_WFDMA_HOST_DMA0_PCIE1_WPDMA_GLO_CFG_RX_DMA_BUSY_SHFT		3
+#define WF_WFDMA_HOST_DMA0_PCIE1_WPDMA_GLO_CFG_RX_DMA_EN_MASK		0x00000004
+#define WF_WFDMA_HOST_DMA0_PCIE1_WPDMA_GLO_CFG_RX_DMA_EN_SHFT		2
+#define WF_WFDMA_HOST_DMA0_PCIE1_WPDMA_GLO_CFG_TX_DMA_BUSY_MASK		0x00000002
+#define WF_WFDMA_HOST_DMA0_PCIE1_WPDMA_GLO_CFG_TX_DMA_BUSY_SHFT		1
+#define WF_WFDMA_HOST_DMA0_PCIE1_WPDMA_GLO_CFG_TX_DMA_EN_MASK		0x00000001
+#define WF_WFDMA_HOST_DMA0_PCIE1_WPDMA_GLO_CFG_TX_DMA_EN_SHFT		0
+
+#define WF_WFDMA_HOST_DMA0_PCIE1_WPDMA_TX_RING21_CTRL0_ADDR    (WF_WFDMA_HOST_DMA0_PCIE1_BASE + 0x450) // 8450
+#define WF_WFDMA_HOST_DMA0_PCIE1_WPDMA_TX_RING21_CTRL1_ADDR    (WF_WFDMA_HOST_DMA0_PCIE1_BASE + 0x454) // 8454
+#define WF_WFDMA_HOST_DMA0_PCIE1_WPDMA_TX_RING21_CTRL2_ADDR    (WF_WFDMA_HOST_DMA0_PCIE1_BASE + 0x458) // 8458
+#define WF_WFDMA_HOST_DMA0_PCIE1_WPDMA_TX_RING21_CTRL3_ADDR    (WF_WFDMA_HOST_DMA0_PCIE1_BASE + 0x45c) // 845C
+#define WF_WFDMA_HOST_DMA0_PCIE1_WPDMA_TX_RING22_CTRL0_ADDR    (WF_WFDMA_HOST_DMA0_PCIE1_BASE + 0x460) // 8460
+#define WF_WFDMA_HOST_DMA0_PCIE1_WPDMA_TX_RING22_CTRL1_ADDR    (WF_WFDMA_HOST_DMA0_PCIE1_BASE + 0x464) // 8464
+#define WF_WFDMA_HOST_DMA0_PCIE1_WPDMA_TX_RING22_CTRL2_ADDR    (WF_WFDMA_HOST_DMA0_PCIE1_BASE + 0x468) // 8468
+#define WF_WFDMA_HOST_DMA0_PCIE1_WPDMA_TX_RING22_CTRL3_ADDR    (WF_WFDMA_HOST_DMA0_PCIE1_BASE + 0x46c) // 846C
+
+#define WF_WFDMA_HOST_DMA0_PCIE1_WPDMA_RX_RING3_CTRL0_ADDR     (WF_WFDMA_HOST_DMA0_PCIE1_BASE + 0x530) // 8530
+#define WF_WFDMA_HOST_DMA0_PCIE1_WPDMA_RX_RING3_CTRL1_ADDR     (WF_WFDMA_HOST_DMA0_PCIE1_BASE + 0x534) // 8534
+#define WF_WFDMA_HOST_DMA0_PCIE1_WPDMA_RX_RING3_CTRL2_ADDR     (WF_WFDMA_HOST_DMA0_PCIE1_BASE + 0x538) // 8538
+#define WF_WFDMA_HOST_DMA0_PCIE1_WPDMA_RX_RING3_CTRL3_ADDR     (WF_WFDMA_HOST_DMA0_PCIE1_BASE + 0x53C) // 853C
+#define WF_WFDMA_HOST_DMA0_PCIE1_WPDMA_RX_RING5_CTRL0_ADDR     (WF_WFDMA_HOST_DMA0_PCIE1_BASE + 0x550) // 8550
+#define WF_WFDMA_HOST_DMA0_PCIE1_WPDMA_RX_RING5_CTRL1_ADDR     (WF_WFDMA_HOST_DMA0_PCIE1_BASE + 0x554) // 8554
+#define WF_WFDMA_HOST_DMA0_PCIE1_WPDMA_RX_RING5_CTRL2_ADDR     (WF_WFDMA_HOST_DMA0_PCIE1_BASE + 0x558) // 8558
+#define WF_WFDMA_HOST_DMA0_PCIE1_WPDMA_RX_RING5_CTRL3_ADDR     (WF_WFDMA_HOST_DMA0_PCIE1_BASE + 0x55c) // 855C
+#define WF_WFDMA_HOST_DMA0_PCIE1_WPDMA_RX_RING6_CTRL0_ADDR     (WF_WFDMA_HOST_DMA0_PCIE1_BASE + 0x560) // 8560
+#define WF_WFDMA_HOST_DMA0_PCIE1_WPDMA_RX_RING6_CTRL1_ADDR     (WF_WFDMA_HOST_DMA0_PCIE1_BASE + 0x564) // 8564
+#define WF_WFDMA_HOST_DMA0_PCIE1_WPDMA_RX_RING6_CTRL2_ADDR     (WF_WFDMA_HOST_DMA0_PCIE1_BASE + 0x568) // 8568
+#define WF_WFDMA_HOST_DMA0_PCIE1_WPDMA_RX_RING6_CTRL3_ADDR     (WF_WFDMA_HOST_DMA0_PCIE1_BASE + 0x56c) // 856C
+#define WF_WFDMA_HOST_DMA0_PCIE1_WPDMA_RX_RING7_CTRL0_ADDR     (WF_WFDMA_HOST_DMA0_PCIE1_BASE + 0x570) // 8570
+#define WF_WFDMA_HOST_DMA0_PCIE1_WPDMA_RX_RING7_CTRL1_ADDR     (WF_WFDMA_HOST_DMA0_PCIE1_BASE + 0x574) // 8574
+#define WF_WFDMA_HOST_DMA0_PCIE1_WPDMA_RX_RING7_CTRL2_ADDR     (WF_WFDMA_HOST_DMA0_PCIE1_BASE + 0x578) // 8578
+#define WF_WFDMA_HOST_DMA0_PCIE1_WPDMA_RX_RING7_CTRL3_ADDR     (WF_WFDMA_HOST_DMA0_PCIE1_BASE + 0x57c) // 857C
+#define WF_WFDMA_HOST_DMA0_PCIE1_WPDMA_RX_RING9_CTRL0_ADDR     (WF_WFDMA_HOST_DMA0_PCIE1_BASE + 0x590) // 8590
+#define WF_WFDMA_HOST_DMA0_PCIE1_WPDMA_RX_RING9_CTRL1_ADDR     (WF_WFDMA_HOST_DMA0_PCIE1_BASE + 0x594) // 8594
+#define WF_WFDMA_HOST_DMA0_PCIE1_WPDMA_RX_RING9_CTRL2_ADDR     (WF_WFDMA_HOST_DMA0_PCIE1_BASE + 0x598) // 8598
+#define WF_WFDMA_HOST_DMA0_PCIE1_WPDMA_RX_RING9_CTRL3_ADDR     (WF_WFDMA_HOST_DMA0_PCIE1_BASE + 0x59c) // 859C
+
+//MCU DMA
+//#define WF_WFDMA_MCU_DMA0_BASE                                 0x02000
+#define WF_WFDMA_MCU_DMA0_BASE                                 0x54000000
+
+#define WF_WFDMA_MCU_DMA0_HOST_INT_STA_ADDR                    (WF_WFDMA_MCU_DMA0_BASE + 0x200) // 0200
+#define WF_WFDMA_MCU_DMA0_HOST_INT_ENA_ADDR                    (WF_WFDMA_MCU_DMA0_BASE + 0X204) // 0204
+#define WF_WFDMA_MCU_DMA0_WPDMA_GLO_CFG_ADDR                   (WF_WFDMA_MCU_DMA0_BASE + 0x208) // 0208
+
+#define WF_WFDMA_MCU_DMA0_WPDMA_GLO_CFG_RX_DMA_BUSY_ADDR       WF_WFDMA_MCU_DMA0_WPDMA_GLO_CFG_ADDR
+#define WF_WFDMA_MCU_DMA0_WPDMA_GLO_CFG_RX_DMA_BUSY_MASK       0x00000008                // RX_DMA_BUSY[3]
+#define WF_WFDMA_MCU_DMA0_WPDMA_GLO_CFG_RX_DMA_BUSY_SHFT       3
+#define WF_WFDMA_MCU_DMA0_WPDMA_GLO_CFG_RX_DMA_EN_ADDR         WF_WFDMA_MCU_DMA0_WPDMA_GLO_CFG_ADDR
+#define WF_WFDMA_MCU_DMA0_WPDMA_GLO_CFG_RX_DMA_EN_MASK         0x00000004                // RX_DMA_EN[2]
+#define WF_WFDMA_MCU_DMA0_WPDMA_GLO_CFG_RX_DMA_EN_SHFT         2
+#define WF_WFDMA_MCU_DMA0_WPDMA_GLO_CFG_TX_DMA_BUSY_ADDR       WF_WFDMA_MCU_DMA0_WPDMA_GLO_CFG_ADDR
+#define WF_WFDMA_MCU_DMA0_WPDMA_GLO_CFG_TX_DMA_BUSY_MASK       0x00000002                // TX_DMA_BUSY[1]
+#define WF_WFDMA_MCU_DMA0_WPDMA_GLO_CFG_TX_DMA_BUSY_SHFT       1
+#define WF_WFDMA_MCU_DMA0_WPDMA_GLO_CFG_TX_DMA_EN_ADDR         WF_WFDMA_MCU_DMA0_WPDMA_GLO_CFG_ADDR
+#define WF_WFDMA_MCU_DMA0_WPDMA_GLO_CFG_TX_DMA_EN_MASK         0x00000001                // TX_DMA_EN[0]
+#define WF_WFDMA_MCU_DMA0_WPDMA_GLO_CFG_TX_DMA_EN_SHFT         0
+
+#define WF_WFDMA_MCU_DMA0_WPDMA_TX_RING0_CTRL0_ADDR            (WF_WFDMA_MCU_DMA0_BASE + 0x300) // 0300
+#define WF_WFDMA_MCU_DMA0_WPDMA_TX_RING0_CTRL1_ADDR            (WF_WFDMA_MCU_DMA0_BASE + 0x304) // 0304
+#define WF_WFDMA_MCU_DMA0_WPDMA_TX_RING0_CTRL2_ADDR            (WF_WFDMA_MCU_DMA0_BASE + 0x308) // 0308
+#define WF_WFDMA_MCU_DMA0_WPDMA_TX_RING0_CTRL3_ADDR            (WF_WFDMA_MCU_DMA0_BASE + 0x30c) // 030C
+#define WF_WFDMA_MCU_DMA0_WPDMA_TX_RING1_CTRL0_ADDR            (WF_WFDMA_MCU_DMA0_BASE + 0x310) // 0310
+#define WF_WFDMA_MCU_DMA0_WPDMA_TX_RING1_CTRL1_ADDR            (WF_WFDMA_MCU_DMA0_BASE + 0x314) // 0314
+#define WF_WFDMA_MCU_DMA0_WPDMA_TX_RING1_CTRL2_ADDR            (WF_WFDMA_MCU_DMA0_BASE + 0x318) // 0318
+#define WF_WFDMA_MCU_DMA0_WPDMA_TX_RING1_CTRL3_ADDR            (WF_WFDMA_MCU_DMA0_BASE + 0x31c) // 031C
+#define WF_WFDMA_MCU_DMA0_WPDMA_TX_RING2_CTRL0_ADDR            (WF_WFDMA_MCU_DMA0_BASE + 0x320) // 0320
+#define WF_WFDMA_MCU_DMA0_WPDMA_TX_RING2_CTRL1_ADDR            (WF_WFDMA_MCU_DMA0_BASE + 0x324) // 0324
+#define WF_WFDMA_MCU_DMA0_WPDMA_TX_RING2_CTRL2_ADDR            (WF_WFDMA_MCU_DMA0_BASE + 0x328) // 0328
+#define WF_WFDMA_MCU_DMA0_WPDMA_TX_RING2_CTRL3_ADDR            (WF_WFDMA_MCU_DMA0_BASE + 0x32c) // 032C
+#define WF_WFDMA_MCU_DMA0_WPDMA_TX_RING3_CTRL0_ADDR            (WF_WFDMA_MCU_DMA0_BASE + 0x330) // 0330
+#define WF_WFDMA_MCU_DMA0_WPDMA_TX_RING3_CTRL1_ADDR            (WF_WFDMA_MCU_DMA0_BASE + 0x334) // 0334
+#define WF_WFDMA_MCU_DMA0_WPDMA_TX_RING3_CTRL2_ADDR            (WF_WFDMA_MCU_DMA0_BASE + 0x338) // 0338
+#define WF_WFDMA_MCU_DMA0_WPDMA_TX_RING3_CTRL3_ADDR            (WF_WFDMA_MCU_DMA0_BASE + 0x33c) // 033C
+#define WF_WFDMA_MCU_DMA0_WPDMA_TX_RING4_CTRL0_ADDR            (WF_WFDMA_MCU_DMA0_BASE + 0x340) // 0340
+#define WF_WFDMA_MCU_DMA0_WPDMA_TX_RING4_CTRL1_ADDR            (WF_WFDMA_MCU_DMA0_BASE + 0x344) // 0344
+#define WF_WFDMA_MCU_DMA0_WPDMA_TX_RING4_CTRL2_ADDR            (WF_WFDMA_MCU_DMA0_BASE + 0x348) // 0348
+#define WF_WFDMA_MCU_DMA0_WPDMA_TX_RING4_CTRL3_ADDR            (WF_WFDMA_MCU_DMA0_BASE + 0x34c) // 034C
+#define WF_WFDMA_MCU_DMA0_WPDMA_TX_RING5_CTRL0_ADDR            (WF_WFDMA_MCU_DMA0_BASE + 0x350) // 0350
+#define WF_WFDMA_MCU_DMA0_WPDMA_TX_RING5_CTRL1_ADDR            (WF_WFDMA_MCU_DMA0_BASE + 0x354) // 0354
+#define WF_WFDMA_MCU_DMA0_WPDMA_TX_RING5_CTRL2_ADDR            (WF_WFDMA_MCU_DMA0_BASE + 0x358) // 0358
+#define WF_WFDMA_MCU_DMA0_WPDMA_TX_RING5_CTRL3_ADDR            (WF_WFDMA_MCU_DMA0_BASE + 0x35c) // 035C
+#define WF_WFDMA_MCU_DMA0_WPDMA_TX_RING6_CTRL0_ADDR            (WF_WFDMA_MCU_DMA0_BASE + 0x360) // 0360
+#define WF_WFDMA_MCU_DMA0_WPDMA_TX_RING6_CTRL1_ADDR            (WF_WFDMA_MCU_DMA0_BASE + 0x364) // 0364
+#define WF_WFDMA_MCU_DMA0_WPDMA_TX_RING6_CTRL2_ADDR            (WF_WFDMA_MCU_DMA0_BASE + 0x368) // 0368
+#define WF_WFDMA_MCU_DMA0_WPDMA_TX_RING6_CTRL3_ADDR            (WF_WFDMA_MCU_DMA0_BASE + 0x36c) // 036C
+#define WF_WFDMA_MCU_DMA0_WPDMA_TX_RING7_CTRL0_ADDR            (WF_WFDMA_MCU_DMA0_BASE + 0x370) // 0370
+#define WF_WFDMA_MCU_DMA0_WPDMA_TX_RING7_CTRL1_ADDR            (WF_WFDMA_MCU_DMA0_BASE + 0x374) // 0374
+#define WF_WFDMA_MCU_DMA0_WPDMA_TX_RING7_CTRL2_ADDR            (WF_WFDMA_MCU_DMA0_BASE + 0x378) // 0378
+#define WF_WFDMA_MCU_DMA0_WPDMA_TX_RING7_CTRL3_ADDR            (WF_WFDMA_MCU_DMA0_BASE + 0x37c) // 037C
+
+#define WF_WFDMA_MCU_DMA0_WPDMA_RX_RING0_CTRL0_ADDR            (WF_WFDMA_MCU_DMA0_BASE + 0x500) // 0500
+#define WF_WFDMA_MCU_DMA0_WPDMA_RX_RING0_CTRL1_ADDR            (WF_WFDMA_MCU_DMA0_BASE + 0x504) // 0504
+#define WF_WFDMA_MCU_DMA0_WPDMA_RX_RING0_CTRL2_ADDR            (WF_WFDMA_MCU_DMA0_BASE + 0x508) // 0508
+#define WF_WFDMA_MCU_DMA0_WPDMA_RX_RING0_CTRL3_ADDR            (WF_WFDMA_MCU_DMA0_BASE + 0x50c) // 050C
+#define WF_WFDMA_MCU_DMA0_WPDMA_RX_RING1_CTRL0_ADDR            (WF_WFDMA_MCU_DMA0_BASE + 0x510) // 0510
+#define WF_WFDMA_MCU_DMA0_WPDMA_RX_RING1_CTRL1_ADDR            (WF_WFDMA_MCU_DMA0_BASE + 0x514) // 0514
+#define WF_WFDMA_MCU_DMA0_WPDMA_RX_RING1_CTRL2_ADDR            (WF_WFDMA_MCU_DMA0_BASE + 0x518) // 0518
+#define WF_WFDMA_MCU_DMA0_WPDMA_RX_RING1_CTRL3_ADDR            (WF_WFDMA_MCU_DMA0_BASE + 0x51c) // 051C
+#define WF_WFDMA_MCU_DMA0_WPDMA_RX_RING2_CTRL0_ADDR            (WF_WFDMA_MCU_DMA0_BASE + 0x520) // 0520
+#define WF_WFDMA_MCU_DMA0_WPDMA_RX_RING2_CTRL1_ADDR            (WF_WFDMA_MCU_DMA0_BASE + 0x524) // 0524
+#define WF_WFDMA_MCU_DMA0_WPDMA_RX_RING2_CTRL2_ADDR            (WF_WFDMA_MCU_DMA0_BASE + 0x528) // 0528
+#define WF_WFDMA_MCU_DMA0_WPDMA_RX_RING2_CTRL3_ADDR            (WF_WFDMA_MCU_DMA0_BASE + 0x52C) // 052C
+#define WF_WFDMA_MCU_DMA0_WPDMA_RX_RING3_CTRL0_ADDR            (WF_WFDMA_MCU_DMA0_BASE + 0x530) // 0530
+#define WF_WFDMA_MCU_DMA0_WPDMA_RX_RING3_CTRL1_ADDR            (WF_WFDMA_MCU_DMA0_BASE + 0x534) // 0534
+#define WF_WFDMA_MCU_DMA0_WPDMA_RX_RING3_CTRL2_ADDR            (WF_WFDMA_MCU_DMA0_BASE + 0x538) // 0538
+#define WF_WFDMA_MCU_DMA0_WPDMA_RX_RING3_CTRL3_ADDR            (WF_WFDMA_MCU_DMA0_BASE + 0x53C) // 053C
+#define WF_WFDMA_MCU_DMA0_WPDMA_RX_RING4_CTRL0_ADDR            (WF_WFDMA_MCU_DMA0_BASE + 0x540) // 0540
+#define WF_WFDMA_MCU_DMA0_WPDMA_RX_RING4_CTRL1_ADDR            (WF_WFDMA_MCU_DMA0_BASE + 0x544) // 0544
+#define WF_WFDMA_MCU_DMA0_WPDMA_RX_RING4_CTRL2_ADDR            (WF_WFDMA_MCU_DMA0_BASE + 0x548) // 0548
+#define WF_WFDMA_MCU_DMA0_WPDMA_RX_RING4_CTRL3_ADDR            (WF_WFDMA_MCU_DMA0_BASE + 0x54C) // 054C
+#define WF_WFDMA_MCU_DMA0_WPDMA_RX_RING5_CTRL0_ADDR            (WF_WFDMA_MCU_DMA0_BASE + 0x550) // 0550
+#define WF_WFDMA_MCU_DMA0_WPDMA_RX_RING5_CTRL1_ADDR            (WF_WFDMA_MCU_DMA0_BASE + 0x554) // 0554
+#define WF_WFDMA_MCU_DMA0_WPDMA_RX_RING5_CTRL2_ADDR            (WF_WFDMA_MCU_DMA0_BASE + 0x558) // 0558
+#define WF_WFDMA_MCU_DMA0_WPDMA_RX_RING5_CTRL3_ADDR            (WF_WFDMA_MCU_DMA0_BASE + 0x55C) // 055C
+#define WF_WFDMA_MCU_DMA0_WPDMA_RX_RING6_CTRL0_ADDR            (WF_WFDMA_MCU_DMA0_BASE + 0x560) // 0560
+#define WF_WFDMA_MCU_DMA0_WPDMA_RX_RING6_CTRL1_ADDR            (WF_WFDMA_MCU_DMA0_BASE + 0x564) // 0564
+#define WF_WFDMA_MCU_DMA0_WPDMA_RX_RING6_CTRL2_ADDR            (WF_WFDMA_MCU_DMA0_BASE + 0x568) // 0568
+#define WF_WFDMA_MCU_DMA0_WPDMA_RX_RING6_CTRL3_ADDR            (WF_WFDMA_MCU_DMA0_BASE + 0x56c) // 056C
+#define WF_WFDMA_MCU_DMA0_WPDMA_RX_RING7_CTRL0_ADDR            (WF_WFDMA_MCU_DMA0_BASE + 0x570) // 0570
+#define WF_WFDMA_MCU_DMA0_WPDMA_RX_RING7_CTRL1_ADDR            (WF_WFDMA_MCU_DMA0_BASE + 0x574) // 0574
+#define WF_WFDMA_MCU_DMA0_WPDMA_RX_RING7_CTRL2_ADDR            (WF_WFDMA_MCU_DMA0_BASE + 0x578) // 0578
+#define WF_WFDMA_MCU_DMA0_WPDMA_RX_RING7_CTRL3_ADDR            (WF_WFDMA_MCU_DMA0_BASE + 0x57c) // 057C
+#define WF_WFDMA_MCU_DMA0_WPDMA_RX_RING8_CTRL0_ADDR            (WF_WFDMA_MCU_DMA0_BASE + 0x580) // 0580
+#define WF_WFDMA_MCU_DMA0_WPDMA_RX_RING8_CTRL1_ADDR            (WF_WFDMA_MCU_DMA0_BASE + 0x584) // 0584
+#define WF_WFDMA_MCU_DMA0_WPDMA_RX_RING8_CTRL2_ADDR            (WF_WFDMA_MCU_DMA0_BASE + 0x588) // 0588
+#define WF_WFDMA_MCU_DMA0_WPDMA_RX_RING8_CTRL3_ADDR            (WF_WFDMA_MCU_DMA0_BASE + 0x58c) // 058C
+#define WF_WFDMA_MCU_DMA0_WPDMA_RX_RING9_CTRL0_ADDR            (WF_WFDMA_MCU_DMA0_BASE + 0x590) // 0590
+#define WF_WFDMA_MCU_DMA0_WPDMA_RX_RING9_CTRL1_ADDR            (WF_WFDMA_MCU_DMA0_BASE + 0x594) // 0594
+#define WF_WFDMA_MCU_DMA0_WPDMA_RX_RING9_CTRL2_ADDR            (WF_WFDMA_MCU_DMA0_BASE + 0x598) // 0598
+#define WF_WFDMA_MCU_DMA0_WPDMA_RX_RING9_CTRL3_ADDR            (WF_WFDMA_MCU_DMA0_BASE + 0x59c) // 059C
+#define WF_WFDMA_MCU_DMA0_WPDMA_RX_RING10_CTRL0_ADDR           (WF_WFDMA_MCU_DMA0_BASE + 0x5A0) // 05A0
+#define WF_WFDMA_MCU_DMA0_WPDMA_RX_RING10_CTRL1_ADDR           (WF_WFDMA_MCU_DMA0_BASE + 0x5A4) // 05A4
+#define WF_WFDMA_MCU_DMA0_WPDMA_RX_RING10_CTRL2_ADDR           (WF_WFDMA_MCU_DMA0_BASE + 0x5A8) // 05A8
+#define WF_WFDMA_MCU_DMA0_WPDMA_RX_RING10_CTRL3_ADDR           (WF_WFDMA_MCU_DMA0_BASE + 0x5Ac) // 05AC
+
+// MEM DMA
+#define WF_WFDMA_MEM_DMA_BASE                                  0x58000000
+
+#define WF_WFDMA_MEM_DMA_HOST_INT_STA_ADDR                     (WF_WFDMA_MEM_DMA_BASE + 0x200) // 0200
+#define WF_WFDMA_MEM_DMA_HOST_INT_ENA_ADDR                     (WF_WFDMA_MEM_DMA_BASE + 0X204) // 0204
+#define WF_WFDMA_MEM_DMA_WPDMA_GLO_CFG_ADDR                    (WF_WFDMA_MEM_DMA_BASE + 0x208) // 0208
+
+#define WF_WFDMA_MEM_DMA_WPDMA_GLO_CFG_RX_DMA_BUSY_ADDR        WF_WFDMA_MEM_DMA_WPDMA_GLO_CFG_ADDR
+#define WF_WFDMA_MEM_DMA_WPDMA_GLO_CFG_RX_DMA_BUSY_MASK        0x00000008                // RX_DMA_BUSY[3]
+#define WF_WFDMA_MEM_DMA_WPDMA_GLO_CFG_RX_DMA_BUSY_SHFT        3
+#define WF_WFDMA_MEM_DMA_WPDMA_GLO_CFG_RX_DMA_EN_ADDR          WF_WFDMA_MEM_DMA_WPDMA_GLO_CFG_ADDR
+#define WF_WFDMA_MEM_DMA_WPDMA_GLO_CFG_RX_DMA_EN_MASK          0x00000004                // RX_DMA_EN[2]
+#define WF_WFDMA_MEM_DMA_WPDMA_GLO_CFG_RX_DMA_EN_SHFT          2
+#define WF_WFDMA_MEM_DMA_WPDMA_GLO_CFG_TX_DMA_BUSY_ADDR        WF_WFDMA_MEM_DMA_WPDMA_GLO_CFG_ADDR
+#define WF_WFDMA_MEM_DMA_WPDMA_GLO_CFG_TX_DMA_BUSY_MASK        0x00000002                // TX_DMA_BUSY[1]
+#define WF_WFDMA_MEM_DMA_WPDMA_GLO_CFG_TX_DMA_BUSY_SHFT        1
+#define WF_WFDMA_MEM_DMA_WPDMA_GLO_CFG_TX_DMA_EN_ADDR          WF_WFDMA_MEM_DMA_WPDMA_GLO_CFG_ADDR
+#define WF_WFDMA_MEM_DMA_WPDMA_GLO_CFG_TX_DMA_EN_MASK          0x00000001                // TX_DMA_EN[0]
+#define WF_WFDMA_MEM_DMA_WPDMA_GLO_CFG_TX_DMA_EN_SHFT          0
+
+#define WF_WFDMA_MEM_DMA_WPDMA_TX_RING0_CTRL0_ADDR             (WF_WFDMA_MEM_DMA_BASE + 0x300) // 0300
+#define WF_WFDMA_MEM_DMA_WPDMA_TX_RING0_CTRL1_ADDR             (WF_WFDMA_MEM_DMA_BASE + 0x304) // 0304
+#define WF_WFDMA_MEM_DMA_WPDMA_TX_RING0_CTRL2_ADDR             (WF_WFDMA_MEM_DMA_BASE + 0x308) // 0308
+#define WF_WFDMA_MEM_DMA_WPDMA_TX_RING0_CTRL3_ADDR             (WF_WFDMA_MEM_DMA_BASE + 0x30c) // 030C
+#define WF_WFDMA_MEM_DMA_WPDMA_TX_RING1_CTRL0_ADDR             (WF_WFDMA_MEM_DMA_BASE + 0x310) // 0310
+#define WF_WFDMA_MEM_DMA_WPDMA_TX_RING1_CTRL1_ADDR             (WF_WFDMA_MEM_DMA_BASE + 0x314) // 0314
+#define WF_WFDMA_MEM_DMA_WPDMA_TX_RING1_CTRL2_ADDR             (WF_WFDMA_MEM_DMA_BASE + 0x318) // 0318
+#define WF_WFDMA_MEM_DMA_WPDMA_TX_RING1_CTRL3_ADDR             (WF_WFDMA_MEM_DMA_BASE + 0x31c) // 031C
+#define WF_WFDMA_MEM_DMA_WPDMA_TX_RING2_CTRL0_ADDR             (WF_WFDMA_MEM_DMA_BASE + 0x320) // 0320
+#define WF_WFDMA_MEM_DMA_WPDMA_TX_RING2_CTRL1_ADDR             (WF_WFDMA_MEM_DMA_BASE + 0x324) // 0324
+#define WF_WFDMA_MEM_DMA_WPDMA_TX_RING2_CTRL2_ADDR             (WF_WFDMA_MEM_DMA_BASE + 0x328) // 0328
+#define WF_WFDMA_MEM_DMA_WPDMA_TX_RING2_CTRL3_ADDR             (WF_WFDMA_MEM_DMA_BASE + 0x32c) // 032C
+
+#define WF_WFDMA_MEM_DMA_WPDMA_RX_RING0_CTRL0_ADDR             (WF_WFDMA_MEM_DMA_BASE + 0x500) // 0500
+#define WF_WFDMA_MEM_DMA_WPDMA_RX_RING0_CTRL1_ADDR             (WF_WFDMA_MEM_DMA_BASE + 0x504) // 0504
+#define WF_WFDMA_MEM_DMA_WPDMA_RX_RING0_CTRL2_ADDR             (WF_WFDMA_MEM_DMA_BASE + 0x508) // 0508
+#define WF_WFDMA_MEM_DMA_WPDMA_RX_RING0_CTRL3_ADDR             (WF_WFDMA_MEM_DMA_BASE + 0x50c) // 050C
+#define WF_WFDMA_MEM_DMA_WPDMA_RX_RING1_CTRL0_ADDR             (WF_WFDMA_MEM_DMA_BASE + 0x510) // 0510
+#define WF_WFDMA_MEM_DMA_WPDMA_RX_RING1_CTRL1_ADDR             (WF_WFDMA_MEM_DMA_BASE + 0x514) // 0514
+#define WF_WFDMA_MEM_DMA_WPDMA_RX_RING1_CTRL2_ADDR             (WF_WFDMA_MEM_DMA_BASE + 0x518) // 0518
+#define WF_WFDMA_MEM_DMA_WPDMA_RX_RING1_CTRL3_ADDR             (WF_WFDMA_MEM_DMA_BASE + 0x51c) // 051C
+#define WF_WFDMA_MEM_DMA_WPDMA_RX_RING2_CTRL0_ADDR             (WF_WFDMA_MEM_DMA_BASE + 0x520) // 0520
+#define WF_WFDMA_MEM_DMA_WPDMA_RX_RING2_CTRL1_ADDR             (WF_WFDMA_MEM_DMA_BASE + 0x524) // 0524
+#define WF_WFDMA_MEM_DMA_WPDMA_RX_RING2_CTRL2_ADDR             (WF_WFDMA_MEM_DMA_BASE + 0x528) // 0528
+#define WF_WFDMA_MEM_DMA_WPDMA_RX_RING2_CTRL3_ADDR             (WF_WFDMA_MEM_DMA_BASE + 0x52C) // 052C
+
+/* MIB */
+#define WF_UMIB_TOP_BASE                                       0x820cd000
+#define BN0_WF_MIB_TOP_BASE                                    0x820ed000
+#define BN1_WF_MIB_TOP_BASE                                    0x820fd000
+#define IP1_BN0_WF_MIB_TOP_BASE                                0x830ed000
+
+#define WF_UMIB_TOP_B0BROCR_ADDR                               (WF_UMIB_TOP_BASE + 0x484) // D484
+#define WF_UMIB_TOP_B0BRBCR_ADDR                               (WF_UMIB_TOP_BASE + 0x4D4) // D4D4
+#define WF_UMIB_TOP_B0BRDCR_ADDR                               (WF_UMIB_TOP_BASE + 0x524) // D524
+#define WF_UMIB_TOP_B1BROCR_ADDR                               (WF_UMIB_TOP_BASE + 0x5E8) // D5E8
+#define WF_UMIB_TOP_B2BROCR_ADDR                               (WF_UMIB_TOP_BASE + 0x74C) // D74C
+
+#define BN0_WF_MIB_TOP_M0SCR0_ADDR                             (BN0_WF_MIB_TOP_BASE + 0x000) // D000
+#define BN0_WF_MIB_TOP_M0SDR6_ADDR                             (BN0_WF_MIB_TOP_BASE + 0x020) // D020
+#define BN0_WF_MIB_TOP_M0SDR9_ADDR                             (BN0_WF_MIB_TOP_BASE + 0x024) // D024
+#define BN0_WF_MIB_TOP_M0SDR18_ADDR                            (BN0_WF_MIB_TOP_BASE + 0x030) // D030
+#define BN0_WF_MIB_TOP_BTOCR_ADDR                              (BN0_WF_MIB_TOP_BASE + 0x400) // D400
+#define BN0_WF_MIB_TOP_BTBCR_ADDR                              (BN0_WF_MIB_TOP_BASE + 0x450) // D450
+#define BN0_WF_MIB_TOP_BTDCR_ADDR                              (BN0_WF_MIB_TOP_BASE + 0x590) // D590
+#define BN0_WF_MIB_TOP_BTCR_ADDR                               (BN0_WF_MIB_TOP_BASE + 0x5A0) // D5A0
+#define BN0_WF_MIB_TOP_RVSR0_ADDR                              (BN0_WF_MIB_TOP_BASE + __OFFS(MIB_RVSR0))
+
+#define BN0_WF_MIB_TOP_TSCR0_ADDR                              (BN0_WF_MIB_TOP_BASE + 0x6B0) // D6B0
+#define BN0_WF_MIB_TOP_TSCR3_ADDR                              (BN0_WF_MIB_TOP_BASE + 0x6BC) // D6BC
+#define BN0_WF_MIB_TOP_TSCR4_ADDR                              (BN0_WF_MIB_TOP_BASE + 0x6C0) // D6C0
+#define BN0_WF_MIB_TOP_TSCR5_ADDR                              (BN0_WF_MIB_TOP_BASE + 0x6C4) // D6C4
+#define BN0_WF_MIB_TOP_TSCR6_ADDR                              (BN0_WF_MIB_TOP_BASE + 0x6C8) // D6C8
+#define BN0_WF_MIB_TOP_TSCR7_ADDR                              (BN0_WF_MIB_TOP_BASE + 0x6D0) // D6D0
+#define BN0_WF_MIB_TOP_TSCR8_ADDR                              (BN0_WF_MIB_TOP_BASE + 0x6CC) // D6CC
+
+#define BN0_WF_MIB_TOP_TBCR0_ADDR                              (BN0_WF_MIB_TOP_BASE + 0x6EC) // D6EC
+#define BN0_WF_MIB_TOP_TBCR1_ADDR                              (BN0_WF_MIB_TOP_BASE + 0x6F0) // D6F0
+#define BN0_WF_MIB_TOP_TBCR2_ADDR                              (BN0_WF_MIB_TOP_BASE + 0x6F4) // D6F4
+#define BN0_WF_MIB_TOP_TBCR3_ADDR                              (BN0_WF_MIB_TOP_BASE + 0x6F8) // D6F8
+#define BN0_WF_MIB_TOP_TBCR4_ADDR                              (BN0_WF_MIB_TOP_BASE + 0x6FC) // D6FC
+
+#define BN0_WF_MIB_TOP_TDRCR0_ADDR                             (BN0_WF_MIB_TOP_BASE + __DBG_OFFS(MIB_TDRCR0))
+#define BN0_WF_MIB_TOP_TDRCR1_ADDR                             (BN0_WF_MIB_TOP_BASE + __DBG_OFFS(MIB_TDRCR1))
+#define BN0_WF_MIB_TOP_TDRCR2_ADDR                             (BN0_WF_MIB_TOP_BASE + __DBG_OFFS(MIB_TDRCR2))
+#define BN0_WF_MIB_TOP_TDRCR3_ADDR                             (BN0_WF_MIB_TOP_BASE + __DBG_OFFS(MIB_TDRCR3))
+#define BN0_WF_MIB_TOP_TDRCR4_ADDR                             (BN0_WF_MIB_TOP_BASE + __DBG_OFFS(MIB_TDRCR4))
+
+#define BN0_WF_MIB_TOP_BTSCR0_ADDR                             (BN0_WF_MIB_TOP_BASE + 0x5E0) // D5E0
+#define BN0_WF_MIB_TOP_BTSCR1_ADDR                             (BN0_WF_MIB_TOP_BASE + 0x5F0) // D5F0
+#define BN0_WF_MIB_TOP_BTSCR2_ADDR                             (BN0_WF_MIB_TOP_BASE + 0x600) // D600
+#define BN0_WF_MIB_TOP_BTSCR3_ADDR                             (BN0_WF_MIB_TOP_BASE + 0x610) // D610
+#define BN0_WF_MIB_TOP_BTSCR4_ADDR                             (BN0_WF_MIB_TOP_BASE + 0x620) // D620
+#define BN0_WF_MIB_TOP_BTSCR5_ADDR                             (BN0_WF_MIB_TOP_BASE + __OFFS(MIB_BTSCR5))
+#define BN0_WF_MIB_TOP_BTSCR6_ADDR                             (BN0_WF_MIB_TOP_BASE + __OFFS(MIB_BTSCR6))
+
+#define BN0_WF_MIB_TOP_RSCR1_ADDR                              (BN0_WF_MIB_TOP_BASE + __OFFS(MIB_RSCR1))
+#define BN0_WF_MIB_TOP_BSCR2_ADDR                              (BN0_WF_MIB_TOP_BASE + __OFFS(MIB_BSCR2))
+#define BN0_WF_MIB_TOP_TSCR18_ADDR                             (BN0_WF_MIB_TOP_BASE + __DBG_OFFS(MIB_TSCR18))
+
+#define BN0_WF_MIB_TOP_MSR0_ADDR                               (BN0_WF_MIB_TOP_BASE + __DBG_OFFS(MIB_MSR0))
+#define BN0_WF_MIB_TOP_MSR1_ADDR                               (BN0_WF_MIB_TOP_BASE + __DBG_OFFS(MIB_MSR1))
+#define BN0_WF_MIB_TOP_MSR2_ADDR                               (BN0_WF_MIB_TOP_BASE + __DBG_OFFS(MIB_MSR2))
+#define BN0_WF_MIB_TOP_MCTR5_ADDR                              (BN0_WF_MIB_TOP_BASE + __DBG_OFFS(MIB_MCTR5))
+#define BN0_WF_MIB_TOP_MCTR6_ADDR                              (BN0_WF_MIB_TOP_BASE + __DBG_OFFS(MIB_MCTR6))
+
+#define BN0_WF_MIB_TOP_RSCR26_ADDR                             (BN0_WF_MIB_TOP_BASE + __DBG_OFFS(MIB_RSCR26))
+#define BN0_WF_MIB_TOP_RSCR27_ADDR                             (BN0_WF_MIB_TOP_BASE + __OFFS(MIB_RSCR27))
+#define BN0_WF_MIB_TOP_RSCR28_ADDR                             (BN0_WF_MIB_TOP_BASE + __OFFS(MIB_RSCR28))
+#define BN0_WF_MIB_TOP_RSCR31_ADDR                             (BN0_WF_MIB_TOP_BASE + __OFFS(MIB_RSCR31))
+#define BN0_WF_MIB_TOP_RSCR33_ADDR                             (BN0_WF_MIB_TOP_BASE + __OFFS(MIB_RSCR33))
+#define BN0_WF_MIB_TOP_RSCR35_ADDR                             (BN0_WF_MIB_TOP_BASE + __OFFS(MIB_RSCR35))
+#define BN0_WF_MIB_TOP_RSCR36_ADDR                             (BN0_WF_MIB_TOP_BASE + __OFFS(MIB_RSCR36))
+
+#define BN0_WF_MIB_TOP_TSCR3_AMPDU_MPDU_COUNT_MASK             0xFFFFFFFF                // AMPDU_MPDU_COUNT[31..0]
+#define BN0_WF_MIB_TOP_TSCR4_AMPDU_ACKED_COUNT_MASK            0xFFFFFFFF                // AMPDU_ACKED_COUNT[31..0]
+#define BN0_WF_MIB_TOP_M0SDR6_CHANNEL_IDLE_COUNT_MASK          0x0000FFFF                // CHANNEL_IDLE_COUNT[15..0]
+#define BN0_WF_MIB_TOP_M0SDR9_CCA_NAV_TX_TIME_MASK             0x00FFFFFF                // CCA_NAV_TX_TIME[23..0]
+#define BN0_WF_MIB_TOP_RSCR26_RX_MDRDY_COUNT_MASK              0xFFFFFFFF                // RX_MDRDY_COUNT[31..0]
+#define BN0_WF_MIB_TOP_MSR0_CCK_MDRDY_TIME_MASK                0xFFFFFFFF                // CCK_MDRDY_TIME[31..0]
+#define BN0_WF_MIB_TOP_MSR1_OFDM_LG_MIXED_VHT_MDRDY_TIME_MASK  0xFFFFFFFF                // OFDM_LG_MIXED_VHT_MDRDY_TIME[31..0]
+#define BN0_WF_MIB_TOP_MSR2_OFDM_GREEN_MDRDY_TIME_MASK         0xFFFFFFFF                // OFDM_GREEN_MDRDY_TIME[31..0]
+#define BN0_WF_MIB_TOP_MCTR5_P_CCA_TIME_MASK                   0xFFFFFFFF                // P_CCA_TIME[31..0]
+#define BN0_WF_MIB_TOP_MCTR6_S_CCA_TIME_MASK                   0xFFFFFFFF                // S_CCA_TIME[31..0]
+#define BN0_WF_MIB_TOP_M0SDR18_P_ED_TIME_MASK                  0x00FFFFFF                // P_ED_TIME[23..0]
+#define BN0_WF_MIB_TOP_TSCR18_BEACONTXCOUNT_MASK               0xFFFFFFFF                // BEACONTXCOUNT[31..0]
+#define BN0_WF_MIB_TOP_TBCR0_TX_20MHZ_CNT_MASK                 0xFFFFFFFF                // TX_20MHZ_CNT[31..0]
+#define BN0_WF_MIB_TOP_TBCR1_TX_40MHZ_CNT_MASK                 0xFFFFFFFF                // TX_40MHZ_CNT[31..0]
+#define BN0_WF_MIB_TOP_TBCR2_TX_80MHZ_CNT_MASK                 0xFFFFFFFF                // TX_80MHZ_CNT[31..0]
+#define BN0_WF_MIB_TOP_TBCR3_TX_160MHZ_CNT_MASK                0xFFFFFFFF                // TX_160MHZ_CNT[31..0]
+#define BN0_WF_MIB_TOP_TBCR4_TX_320MHZ_CNT_MASK                0xFFFFFFFF                // TX_320MHZ_CNT[31..0]
+#define BN0_WF_MIB_TOP_BSCR2_MUBF_TX_COUNT_MASK                0xFFFFFFFF                // MUBF_TX_COUNT[31..0]
+#define BN0_WF_MIB_TOP_RVSR0_VEC_MISS_COUNT_MASK               0xFFFFFFFF                // VEC_MISS_COUNT[31..0]
+#define BN0_WF_MIB_TOP_RSCR35_DELIMITER_FAIL_COUNT_MASK        0xFFFFFFFF                // DELIMITER_FAIL_COUNT[31..0]
+#define BN0_WF_MIB_TOP_RSCR1_RX_FCS_ERROR_COUNT_MASK           0xFFFFFFFF                // RX_FCS_ERROR_COUNT[31..0]
+#define BN0_WF_MIB_TOP_RSCR33_RX_FIFO_FULL_COUNT_MASK          0xFFFFFFFF                // RX_FIFO_FULL_COUNT[31..0]
+#define BN0_WF_MIB_TOP_RSCR36_RX_LEN_MISMATCH_MASK             0xFFFFFFFF                // RX_LEN_MISMATCH[31..0]
+#define BN0_WF_MIB_TOP_RSCR31_RX_MPDU_COUNT_MASK               0xFFFFFFFF                // RX_MPDU_COUNT[31..0]
+#define BN0_WF_MIB_TOP_BTSCR5_RTSTXCOUNTn_MASK                 0xFFFFFFFF                // RTSTXCOUNTn[31..0]
+#define BN0_WF_MIB_TOP_BTSCR6_RTSRETRYCOUNTn_MASK              0xFFFFFFFF                // RTSRETRYCOUNTn[31..0]
+#define BN0_WF_MIB_TOP_BTSCR0_BAMISSCOUNTn_MASK                0xFFFFFFFF                // BAMISSCOUNTn[31..0]
+#define BN0_WF_MIB_TOP_BTSCR1_ACKFAILCOUNTn_MASK               0xFFFFFFFF                // ACKFAILCOUNTn[31..0]
+#define BN0_WF_MIB_TOP_BTSCR2_FRAMERETRYCOUNTn_MASK            0xFFFFFFFF                // FRAMERETRYCOUNTn[31..0]
+#define BN0_WF_MIB_TOP_BTSCR3_FRAMERETRY2COUNTn_MASK           0xFFFFFFFF                // FRAMERETRY2COUNTn[31..0]
+#define BN0_WF_MIB_TOP_BTSCR4_FRAMERETRY3COUNTn_MASK           0xFFFFFFFF                // FRAMERETRY3COUNTn[31..0]
+#define BN0_WF_MIB_TOP_TRARC0_ADDR                             (BN0_WF_MIB_TOP_BASE + 0x0B0) // D0B0
+#define BN0_WF_MIB_TOP_TRARC1_ADDR                             (BN0_WF_MIB_TOP_BASE + 0x0B4) // D0B4
+#define BN0_WF_MIB_TOP_TRARC2_ADDR                             (BN0_WF_MIB_TOP_BASE + 0x0B8) // D0B8
+#define BN0_WF_MIB_TOP_TRARC3_ADDR                             (BN0_WF_MIB_TOP_BASE + 0x0BC) // D0BC
+#define BN0_WF_MIB_TOP_TRARC4_ADDR                             (BN0_WF_MIB_TOP_BASE + 0x0C0) // D0C0
+#define BN0_WF_MIB_TOP_TRARC5_ADDR                             (BN0_WF_MIB_TOP_BASE + 0x0C4) // D0C4
+#define BN0_WF_MIB_TOP_TRARC6_ADDR                             (BN0_WF_MIB_TOP_BASE + 0x0C8) // D0C8
+#define BN0_WF_MIB_TOP_TRARC7_ADDR                             (BN0_WF_MIB_TOP_BASE + 0x0CC) // D0CC
+
+#define BN0_WF_MIB_TOP_TRDR0_ADDR                              (BN0_WF_MIB_TOP_BASE + __DBG_OFFS(MIB_TRDR0))
+#define BN0_WF_MIB_TOP_TRDR1_ADDR                              (BN0_WF_MIB_TOP_BASE + __OFFS(MIB_TRDR1))
+#define BN0_WF_MIB_TOP_TRDR2_ADDR                              (BN0_WF_MIB_TOP_BASE + __DBG_OFFS(MIB_TRDR2))
+#define BN0_WF_MIB_TOP_TRDR3_ADDR                              (BN0_WF_MIB_TOP_BASE + __DBG_OFFS(MIB_TRDR3))
+#define BN0_WF_MIB_TOP_TRDR4_ADDR                              (BN0_WF_MIB_TOP_BASE + __DBG_OFFS(MIB_TRDR4))
+#define BN0_WF_MIB_TOP_TRDR5_ADDR                              (BN0_WF_MIB_TOP_BASE + __DBG_OFFS(MIB_TRDR5))
+#define BN0_WF_MIB_TOP_TRDR6_ADDR                              (BN0_WF_MIB_TOP_BASE + __DBG_OFFS(MIB_TRDR6))
+#define BN0_WF_MIB_TOP_TRDR7_ADDR                              (BN0_WF_MIB_TOP_BASE + __DBG_OFFS(MIB_TRDR7))
+#define BN0_WF_MIB_TOP_TRDR8_ADDR                              (BN0_WF_MIB_TOP_BASE + __DBG_OFFS(MIB_TRDR8))
+#define BN0_WF_MIB_TOP_TRDR9_ADDR                              (BN0_WF_MIB_TOP_BASE + __DBG_OFFS(MIB_TRDR9))
+#define BN0_WF_MIB_TOP_TRDR10_ADDR                             (BN0_WF_MIB_TOP_BASE + __DBG_OFFS(MIB_TRDR10))
+#define BN0_WF_MIB_TOP_TRDR11_ADDR                             (BN0_WF_MIB_TOP_BASE + __DBG_OFFS(MIB_TRDR11))
+#define BN0_WF_MIB_TOP_TRDR12_ADDR                             (BN0_WF_MIB_TOP_BASE + __DBG_OFFS(MIB_TRDR12))
+#define BN0_WF_MIB_TOP_TRDR13_ADDR                             (BN0_WF_MIB_TOP_BASE + __DBG_OFFS(MIB_TRDR13))
+#define BN0_WF_MIB_TOP_TRDR14_ADDR                             (BN0_WF_MIB_TOP_BASE + __DBG_OFFS(MIB_TRDR14))
+#define BN0_WF_MIB_TOP_TRDR15_ADDR                             (BN0_WF_MIB_TOP_BASE + __DBG_OFFS(MIB_TRDR15))
+
+#define BN0_WF_MIB_TOP_TRARC0_AGG_RANG_SEL_1_ADDR              BN0_WF_MIB_TOP_TRARC0_ADDR
+#define BN0_WF_MIB_TOP_TRARC0_AGG_RANG_SEL_1_MASK              0x03FF0000                // AGG_RANG_SEL_1[25..16]
+#define BN0_WF_MIB_TOP_TRARC0_AGG_RANG_SEL_1_SHFT              16
+#define BN0_WF_MIB_TOP_TRARC0_AGG_RANG_SEL_0_ADDR              BN0_WF_MIB_TOP_TRARC0_ADDR
+#define BN0_WF_MIB_TOP_TRARC0_AGG_RANG_SEL_0_MASK              0x000003FF                // AGG_RANG_SEL_0[9..0]
+#define BN0_WF_MIB_TOP_TRARC0_AGG_RANG_SEL_0_SHFT              0
+
+#define BN0_WF_MIB_TOP_TRARC1_AGG_RANG_SEL_3_ADDR              BN0_WF_MIB_TOP_TRARC1_ADDR
+#define BN0_WF_MIB_TOP_TRARC1_AGG_RANG_SEL_3_MASK              0x03FF0000                // AGG_RANG_SEL_3[25..16]
+#define BN0_WF_MIB_TOP_TRARC1_AGG_RANG_SEL_3_SHFT              16
+#define BN0_WF_MIB_TOP_TRARC1_AGG_RANG_SEL_2_ADDR              BN0_WF_MIB_TOP_TRARC1_ADDR
+#define BN0_WF_MIB_TOP_TRARC1_AGG_RANG_SEL_2_MASK              0x000003FF                // AGG_RANG_SEL_2[9..0]
+#define BN0_WF_MIB_TOP_TRARC1_AGG_RANG_SEL_2_SHFT              0
+
+#define BN0_WF_MIB_TOP_TRARC2_AGG_RANG_SEL_5_ADDR              BN0_WF_MIB_TOP_TRARC2_ADDR
+#define BN0_WF_MIB_TOP_TRARC2_AGG_RANG_SEL_5_MASK              0x03FF0000                // AGG_RANG_SEL_5[25..16]
+#define BN0_WF_MIB_TOP_TRARC2_AGG_RANG_SEL_5_SHFT              16
+#define BN0_WF_MIB_TOP_TRARC2_AGG_RANG_SEL_4_ADDR              BN0_WF_MIB_TOP_TRARC2_ADDR
+#define BN0_WF_MIB_TOP_TRARC2_AGG_RANG_SEL_4_MASK              0x000003FF                // AGG_RANG_SEL_4[9..0]
+#define BN0_WF_MIB_TOP_TRARC2_AGG_RANG_SEL_4_SHFT              0
+
+#define BN0_WF_MIB_TOP_TRARC3_AGG_RANG_SEL_7_ADDR              BN0_WF_MIB_TOP_TRARC3_ADDR
+#define BN0_WF_MIB_TOP_TRARC3_AGG_RANG_SEL_7_MASK              0x03FF0000                // AGG_RANG_SEL_7[25..16]
+#define BN0_WF_MIB_TOP_TRARC3_AGG_RANG_SEL_7_SHFT              16
+#define BN0_WF_MIB_TOP_TRARC3_AGG_RANG_SEL_6_ADDR              BN0_WF_MIB_TOP_TRARC3_ADDR
+#define BN0_WF_MIB_TOP_TRARC3_AGG_RANG_SEL_6_MASK              0x000003FF                // AGG_RANG_SEL_6[9..0]
+#define BN0_WF_MIB_TOP_TRARC3_AGG_RANG_SEL_6_SHFT              0
+
+#define BN0_WF_MIB_TOP_TRARC4_AGG_RANG_SEL_9_ADDR              BN0_WF_MIB_TOP_TRARC4_ADDR
+#define BN0_WF_MIB_TOP_TRARC4_AGG_RANG_SEL_9_MASK              0x03FF0000                // AGG_RANG_SEL_9[25..16]
+#define BN0_WF_MIB_TOP_TRARC4_AGG_RANG_SEL_9_SHFT              16
+#define BN0_WF_MIB_TOP_TRARC4_AGG_RANG_SEL_8_ADDR              BN0_WF_MIB_TOP_TRARC4_ADDR
+#define BN0_WF_MIB_TOP_TRARC4_AGG_RANG_SEL_8_MASK              0x000003FF                // AGG_RANG_SEL_8[9..0]
+#define BN0_WF_MIB_TOP_TRARC4_AGG_RANG_SEL_8_SHFT              0
+
+#define BN0_WF_MIB_TOP_TRARC5_AGG_RANG_SEL_11_ADDR             BN0_WF_MIB_TOP_TRARC5_ADDR
+#define BN0_WF_MIB_TOP_TRARC5_AGG_RANG_SEL_11_MASK             0x03FF0000                // AGG_RANG_SEL_11[25..16]
+#define BN0_WF_MIB_TOP_TRARC5_AGG_RANG_SEL_11_SHFT             16
+#define BN0_WF_MIB_TOP_TRARC5_AGG_RANG_SEL_10_ADDR             BN0_WF_MIB_TOP_TRARC5_ADDR
+#define BN0_WF_MIB_TOP_TRARC5_AGG_RANG_SEL_10_MASK             0x000003FF                // AGG_RANG_SEL_10[9..0]
+#define BN0_WF_MIB_TOP_TRARC5_AGG_RANG_SEL_10_SHFT             0
+
+#define BN0_WF_MIB_TOP_TRARC6_AGG_RANG_SEL_13_ADDR             BN0_WF_MIB_TOP_TRARC6_ADDR
+#define BN0_WF_MIB_TOP_TRARC6_AGG_RANG_SEL_13_MASK             0x03FF0000                // AGG_RANG_SEL_13[25..16]
+#define BN0_WF_MIB_TOP_TRARC6_AGG_RANG_SEL_13_SHFT             16
+#define BN0_WF_MIB_TOP_TRARC6_AGG_RANG_SEL_12_ADDR             BN0_WF_MIB_TOP_TRARC6_ADDR
+#define BN0_WF_MIB_TOP_TRARC6_AGG_RANG_SEL_12_MASK             0x000003FF                // AGG_RANG_SEL_12[9..0]
+#define BN0_WF_MIB_TOP_TRARC6_AGG_RANG_SEL_12_SHFT             0
+
+#define BN0_WF_MIB_TOP_TRARC7_AGG_RANG_SEL_14_ADDR             BN0_WF_MIB_TOP_TRARC7_ADDR
+#define BN0_WF_MIB_TOP_TRARC7_AGG_RANG_SEL_14_MASK             0x000003FF                // AGG_RANG_SEL_14[9..0]
+#define BN0_WF_MIB_TOP_TRARC7_AGG_RANG_SEL_14_SHFT             0
+
+/* RRO TOP */
+#define WF_RRO_TOP_BASE                                        0xA000 /*0x820C2000 */
+#define WF_RRO_TOP_IND_CMD_0_CTRL0_ADDR                        (WF_RRO_TOP_BASE + 0x40) // 2040
+											//
+/* WTBL */
+enum mt7996_wtbl_type {
+	WTBL_TYPE_LMAC, 	/* WTBL in LMAC */
+	WTBL_TYPE_UMAC, 	/* WTBL in UMAC */
+	WTBL_TYPE_KEY,		/* Key Table */
+	MAX_NUM_WTBL_TYPE
+};
+
+struct berse_wtbl_parse {
+	u8 *name;
+	u32 mask;
+	u32 shift;
+	u8 new_line;
+};
+
+enum muar_idx {
+	MUAR_INDEX_OWN_MAC_ADDR_0 = 0,
+	MUAR_INDEX_OWN_MAC_ADDR_1,
+	MUAR_INDEX_OWN_MAC_ADDR_2,
+	MUAR_INDEX_OWN_MAC_ADDR_3,
+	MUAR_INDEX_OWN_MAC_ADDR_4,
+	MUAR_INDEX_OWN_MAC_ADDR_BC_MC = 0xE,
+	MUAR_INDEX_UNMATCHED = 0xF,
+	MUAR_INDEX_OWN_MAC_ADDR_11 = 0x11,
+	MUAR_INDEX_OWN_MAC_ADDR_12,
+	MUAR_INDEX_OWN_MAC_ADDR_13,
+	MUAR_INDEX_OWN_MAC_ADDR_14,
+	MUAR_INDEX_OWN_MAC_ADDR_15,
+	MUAR_INDEX_OWN_MAC_ADDR_16,
+	MUAR_INDEX_OWN_MAC_ADDR_17,
+	MUAR_INDEX_OWN_MAC_ADDR_18,
+	MUAR_INDEX_OWN_MAC_ADDR_19,
+	MUAR_INDEX_OWN_MAC_ADDR_1A,
+	MUAR_INDEX_OWN_MAC_ADDR_1B,
+	MUAR_INDEX_OWN_MAC_ADDR_1C,
+	MUAR_INDEX_OWN_MAC_ADDR_1D,
+	MUAR_INDEX_OWN_MAC_ADDR_1E,
+	MUAR_INDEX_OWN_MAC_ADDR_1F,
+	MUAR_INDEX_OWN_MAC_ADDR_20,
+	MUAR_INDEX_OWN_MAC_ADDR_21,
+	MUAR_INDEX_OWN_MAC_ADDR_22,
+	MUAR_INDEX_OWN_MAC_ADDR_23,
+	MUAR_INDEX_OWN_MAC_ADDR_24,
+	MUAR_INDEX_OWN_MAC_ADDR_25,
+	MUAR_INDEX_OWN_MAC_ADDR_26,
+	MUAR_INDEX_OWN_MAC_ADDR_27,
+	MUAR_INDEX_OWN_MAC_ADDR_28,
+	MUAR_INDEX_OWN_MAC_ADDR_29,
+	MUAR_INDEX_OWN_MAC_ADDR_2A,
+	MUAR_INDEX_OWN_MAC_ADDR_2B,
+	MUAR_INDEX_OWN_MAC_ADDR_2C,
+	MUAR_INDEX_OWN_MAC_ADDR_2D,
+	MUAR_INDEX_OWN_MAC_ADDR_2E,
+	MUAR_INDEX_OWN_MAC_ADDR_2F
+};
+
+enum cipher_suit {
+	IGTK_CIPHER_SUIT_NONE = 0,
+	IGTK_CIPHER_SUIT_BIP,
+	IGTK_CIPHER_SUIT_BIP_256
+};
+
+#define LWTBL_LEN_IN_DW			36
+#define UWTBL_LEN_IN_DW			16
+
+#define MT_DBG_WTBL_BASE		0x820D8000
+
+#define MT_DBG_WTBLON_TOP_BASE		0x820d4000
+#define MT_DBG_WTBLON_TOP_WDUCR_ADDR	(MT_DBG_WTBLON_TOP_BASE + 0x0370) // 4370
+#define MT_DBG_WTBLON_TOP_WDUCR_GROUP	GENMASK(4, 0)
+
+#define MT_DBG_UWTBL_TOP_BASE		0x820c4000
+#define MT_DBG_UWTBL_TOP_WDUCR_ADDR	(MT_DBG_UWTBL_TOP_BASE + 0x0104) // 4104
+#define MT_DBG_UWTBL_TOP_WDUCR_GROUP	GENMASK(5, 0)
+#define MT_DBG_UWTBL_TOP_WDUCR_TARGET	BIT(31)
+
+#define LWTBL_IDX2BASE_ID		GENMASK(14, 8)
+#define LWTBL_IDX2BASE_DW		GENMASK(7, 2)
+#define LWTBL_IDX2BASE(_id, _dw)	(MT_DBG_WTBL_BASE | \
+					FIELD_PREP(LWTBL_IDX2BASE_ID, _id) | \
+					FIELD_PREP(LWTBL_IDX2BASE_DW, _dw))
+
+#define UWTBL_IDX2BASE_ID		GENMASK(12, 6)
+#define UWTBL_IDX2BASE_DW		GENMASK(5, 2)
+#define UWTBL_IDX2BASE(_id, _dw)	(MT_DBG_UWTBL_TOP_BASE | 0x2000 | \
+					FIELD_PREP(UWTBL_IDX2BASE_ID, _id) | \
+					FIELD_PREP(UWTBL_IDX2BASE_DW, _dw))
+
+#define KEYTBL_IDX2BASE_KEY		GENMASK(12, 6)
+#define KEYTBL_IDX2BASE_DW		GENMASK(5, 2)
+#define KEYTBL_IDX2BASE(_key, _dw)	(MT_DBG_UWTBL_TOP_BASE | 0x2000 | \
+					FIELD_PREP(KEYTBL_IDX2BASE_KEY, _key) | \
+					FIELD_PREP(KEYTBL_IDX2BASE_DW, _dw))
+
+// UMAC WTBL
+// DW0
+#define WF_UWTBL_PEER_MLD_ADDRESS_47_32__DW                         0
+#define WF_UWTBL_PEER_MLD_ADDRESS_47_32__ADDR                       0
+#define WF_UWTBL_PEER_MLD_ADDRESS_47_32__MASK                       0x0000ffff // 15- 0
+#define WF_UWTBL_PEER_MLD_ADDRESS_47_32__SHIFT                      0
+#define WF_UWTBL_OWN_MLD_ID_DW                                      0
+#define WF_UWTBL_OWN_MLD_ID_ADDR                                    0
+#define WF_UWTBL_OWN_MLD_ID_MASK                                    0x003f0000 // 21-16
+#define WF_UWTBL_OWN_MLD_ID_SHIFT                                   16
+// DW1
+#define WF_UWTBL_PEER_MLD_ADDRESS_31_0__DW                          1
+#define WF_UWTBL_PEER_MLD_ADDRESS_31_0__ADDR                        4
+#define WF_UWTBL_PEER_MLD_ADDRESS_31_0__MASK                        0xffffffff // 31- 0
+#define WF_UWTBL_PEER_MLD_ADDRESS_31_0__SHIFT                       0
+// DW2
+#define WF_UWTBL_PN_31_0__DW                                        2
+#define WF_UWTBL_PN_31_0__ADDR                                      8
+#define WF_UWTBL_PN_31_0__MASK                                      0xffffffff // 31- 0
+#define WF_UWTBL_PN_31_0__SHIFT                                     0
+// DW3
+#define WF_UWTBL_PN_47_32__DW                                       3
+#define WF_UWTBL_PN_47_32__ADDR                                     12
+#define WF_UWTBL_PN_47_32__MASK                                     0x0000ffff // 15- 0
+#define WF_UWTBL_PN_47_32__SHIFT                                    0
+#define WF_UWTBL_COM_SN_DW                                          3
+#define WF_UWTBL_COM_SN_ADDR                                        12
+#define WF_UWTBL_COM_SN_MASK                                        0x0fff0000 // 27-16
+#define WF_UWTBL_COM_SN_SHIFT                                       16
+// DW4
+#define WF_UWTBL_TID0_SN_DW                                         4
+#define WF_UWTBL_TID0_SN_ADDR                                       16
+#define WF_UWTBL_TID0_SN_MASK                                       0x00000fff // 11- 0
+#define WF_UWTBL_TID0_SN_SHIFT                                      0
+#define WF_UWTBL_RX_BIPN_31_0__DW                                   4
+#define WF_UWTBL_RX_BIPN_31_0__ADDR                                 16
+#define WF_UWTBL_RX_BIPN_31_0__MASK                                 0xffffffff // 31- 0
+#define WF_UWTBL_RX_BIPN_31_0__SHIFT                                0
+#define WF_UWTBL_TID1_SN_DW                                         4
+#define WF_UWTBL_TID1_SN_ADDR                                       16
+#define WF_UWTBL_TID1_SN_MASK                                       0x00fff000 // 23-12
+#define WF_UWTBL_TID1_SN_SHIFT                                      12
+#define WF_UWTBL_TID2_SN_7_0__DW                                    4
+#define WF_UWTBL_TID2_SN_7_0__ADDR                                  16
+#define WF_UWTBL_TID2_SN_7_0__MASK                                  0xff000000 // 31-24
+#define WF_UWTBL_TID2_SN_7_0__SHIFT                                 24
+// DW5
+#define WF_UWTBL_TID2_SN_11_8__DW                                   5
+#define WF_UWTBL_TID2_SN_11_8__ADDR                                 20
+#define WF_UWTBL_TID2_SN_11_8__MASK                                 0x0000000f //  3- 0
+#define WF_UWTBL_TID2_SN_11_8__SHIFT                                0
+#define WF_UWTBL_RX_BIPN_47_32__DW                                  5
+#define WF_UWTBL_RX_BIPN_47_32__ADDR                                20
+#define WF_UWTBL_RX_BIPN_47_32__MASK                                0x0000ffff // 15- 0
+#define WF_UWTBL_RX_BIPN_47_32__SHIFT                               0
+#define WF_UWTBL_TID3_SN_DW                                         5
+#define WF_UWTBL_TID3_SN_ADDR                                       20
+#define WF_UWTBL_TID3_SN_MASK                                       0x0000fff0 // 15- 4
+#define WF_UWTBL_TID3_SN_SHIFT                                      4
+#define WF_UWTBL_TID4_SN_DW                                         5
+#define WF_UWTBL_TID4_SN_ADDR                                       20
+#define WF_UWTBL_TID4_SN_MASK                                       0x0fff0000 // 27-16
+#define WF_UWTBL_TID4_SN_SHIFT                                      16
+#define WF_UWTBL_TID5_SN_3_0__DW                                    5
+#define WF_UWTBL_TID5_SN_3_0__ADDR                                  20
+#define WF_UWTBL_TID5_SN_3_0__MASK                                  0xf0000000 // 31-28
+#define WF_UWTBL_TID5_SN_3_0__SHIFT                                 28
+// DW6
+#define WF_UWTBL_TID5_SN_11_4__DW                                   6
+#define WF_UWTBL_TID5_SN_11_4__ADDR                                 24
+#define WF_UWTBL_TID5_SN_11_4__MASK                                 0x000000ff //  7- 0
+#define WF_UWTBL_TID5_SN_11_4__SHIFT                                0
+#define WF_UWTBL_KEY_LOC2_DW                                        6
+#define WF_UWTBL_KEY_LOC2_ADDR                                      24
+#define WF_UWTBL_KEY_LOC2_MASK                                      0x00001fff // 12- 0
+#define WF_UWTBL_KEY_LOC2_SHIFT                                     0
+#define WF_UWTBL_TID6_SN_DW                                         6
+#define WF_UWTBL_TID6_SN_ADDR                                       24
+#define WF_UWTBL_TID6_SN_MASK                                       0x000fff00 // 19- 8
+#define WF_UWTBL_TID6_SN_SHIFT                                      8
+#define WF_UWTBL_TID7_SN_DW                                         6
+#define WF_UWTBL_TID7_SN_ADDR                                       24
+#define WF_UWTBL_TID7_SN_MASK                                       0xfff00000 // 31-20
+#define WF_UWTBL_TID7_SN_SHIFT                                      20
+// DW7
+#define WF_UWTBL_KEY_LOC0_DW                                        7
+#define WF_UWTBL_KEY_LOC0_ADDR                                      28
+#define WF_UWTBL_KEY_LOC0_MASK                                      0x00001fff // 12- 0
+#define WF_UWTBL_KEY_LOC0_SHIFT                                     0
+#define WF_UWTBL_KEY_LOC1_DW                                        7
+#define WF_UWTBL_KEY_LOC1_ADDR                                      28
+#define WF_UWTBL_KEY_LOC1_MASK                                      0x1fff0000 // 28-16
+#define WF_UWTBL_KEY_LOC1_SHIFT                                     16
+// DW8
+#define WF_UWTBL_AMSDU_CFG_DW                                       8
+#define WF_UWTBL_AMSDU_CFG_ADDR                                     32
+#define WF_UWTBL_AMSDU_CFG_MASK                                     0x00000fff // 11- 0
+#define WF_UWTBL_AMSDU_CFG_SHIFT                                    0
+#define WF_UWTBL_SEC_ADDR_MODE_DW                                   8
+#define WF_UWTBL_SEC_ADDR_MODE_ADDR                                 32
+#define WF_UWTBL_SEC_ADDR_MODE_MASK                                 0x00300000 // 21-20
+#define WF_UWTBL_SEC_ADDR_MODE_SHIFT                                20
+#define WF_UWTBL_WMM_Q_DW                                           8
+#define WF_UWTBL_WMM_Q_ADDR                                         32
+#define WF_UWTBL_WMM_Q_MASK                                         0x06000000 // 26-25
+#define WF_UWTBL_WMM_Q_SHIFT                                        25
+#define WF_UWTBL_QOS_DW                                             8
+#define WF_UWTBL_QOS_ADDR                                           32
+#define WF_UWTBL_QOS_MASK                                           0x08000000 // 27-27
+#define WF_UWTBL_QOS_SHIFT                                          27
+#define WF_UWTBL_HT_DW                                              8
+#define WF_UWTBL_HT_ADDR                                            32
+#define WF_UWTBL_HT_MASK                                            0x10000000 // 28-28
+#define WF_UWTBL_HT_SHIFT                                           28
+#define WF_UWTBL_HDRT_MODE_DW                                       8
+#define WF_UWTBL_HDRT_MODE_ADDR                                     32
+#define WF_UWTBL_HDRT_MODE_MASK                                     0x20000000 // 29-29
+#define WF_UWTBL_HDRT_MODE_SHIFT                                    29
+// DW9
+#define WF_UWTBL_RELATED_IDX0_DW                                    9
+#define WF_UWTBL_RELATED_IDX0_ADDR                                  36
+#define WF_UWTBL_RELATED_IDX0_MASK                                  0x00000fff // 11- 0
+#define WF_UWTBL_RELATED_IDX0_SHIFT                                 0
+#define WF_UWTBL_RELATED_BAND0_DW                                   9
+#define WF_UWTBL_RELATED_BAND0_ADDR                                 36
+#define WF_UWTBL_RELATED_BAND0_MASK                                 0x00003000 // 13-12
+#define WF_UWTBL_RELATED_BAND0_SHIFT                                12
+#define WF_UWTBL_PRIMARY_MLD_BAND_DW                                9
+#define WF_UWTBL_PRIMARY_MLD_BAND_ADDR                              36
+#define WF_UWTBL_PRIMARY_MLD_BAND_MASK                              0x0000c000 // 15-14
+#define WF_UWTBL_PRIMARY_MLD_BAND_SHIFT                             14
+#define WF_UWTBL_RELATED_IDX1_DW                                    9
+#define WF_UWTBL_RELATED_IDX1_ADDR                                  36
+#define WF_UWTBL_RELATED_IDX1_MASK                                  0x0fff0000 // 27-16
+#define WF_UWTBL_RELATED_IDX1_SHIFT                                 16
+#define WF_UWTBL_RELATED_BAND1_DW                                   9
+#define WF_UWTBL_RELATED_BAND1_ADDR                                 36
+#define WF_UWTBL_RELATED_BAND1_MASK                                 0x30000000 // 29-28
+#define WF_UWTBL_RELATED_BAND1_SHIFT                                28
+#define WF_UWTBL_SECONDARY_MLD_BAND_DW                              9
+#define WF_UWTBL_SECONDARY_MLD_BAND_ADDR                            36
+#define WF_UWTBL_SECONDARY_MLD_BAND_MASK                            0xc0000000 // 31-30
+#define WF_UWTBL_SECONDARY_MLD_BAND_SHIFT                           30
+
+/* LMAC WTBL */
+// DW0
+#define WF_LWTBL_PEER_LINK_ADDRESS_47_32__DW                        0
+#define WF_LWTBL_PEER_LINK_ADDRESS_47_32__ADDR                      0
+#define WF_LWTBL_PEER_LINK_ADDRESS_47_32__MASK \
+	0x0000ffff // 15- 0
+#define WF_LWTBL_PEER_LINK_ADDRESS_47_32__SHIFT                     0
+#define WF_LWTBL_MUAR_DW                                            0
+#define WF_LWTBL_MUAR_ADDR                                          0
+#define WF_LWTBL_MUAR_MASK \
+	0x003f0000 // 21-16
+#define WF_LWTBL_MUAR_SHIFT                                         16
+#define WF_LWTBL_RCA1_DW                                            0
+#define WF_LWTBL_RCA1_ADDR                                          0
+#define WF_LWTBL_RCA1_MASK \
+	0x00400000 // 22-22
+#define WF_LWTBL_RCA1_SHIFT                                         22
+#define WF_LWTBL_KID_DW                                             0
+#define WF_LWTBL_KID_ADDR                                           0
+#define WF_LWTBL_KID_MASK \
+	0x01800000 // 24-23
+#define WF_LWTBL_KID_SHIFT                                          23
+#define WF_LWTBL_RCID_DW                                            0
+#define WF_LWTBL_RCID_ADDR                                          0
+#define WF_LWTBL_RCID_MASK \
+	0x02000000 // 25-25
+#define WF_LWTBL_RCID_SHIFT                                         25
+#define WF_LWTBL_BAND_DW                                            0
+#define WF_LWTBL_BAND_ADDR                                          0
+#define WF_LWTBL_BAND_MASK \
+	0x0c000000 // 27-26
+#define WF_LWTBL_BAND_SHIFT                                         26
+#define WF_LWTBL_RV_DW                                              0
+#define WF_LWTBL_RV_ADDR                                            0
+#define WF_LWTBL_RV_MASK \
+	0x10000000 // 28-28
+#define WF_LWTBL_RV_SHIFT                                           28
+#define WF_LWTBL_RCA2_DW                                            0
+#define WF_LWTBL_RCA2_ADDR                                          0
+#define WF_LWTBL_RCA2_MASK \
+	0x20000000 // 29-29
+#define WF_LWTBL_RCA2_SHIFT                                         29
+#define WF_LWTBL_WPI_FLAG_DW                                        0
+#define WF_LWTBL_WPI_FLAG_ADDR                                      0
+#define WF_LWTBL_WPI_FLAG_MASK \
+	0x40000000 // 30-30
+#define WF_LWTBL_WPI_FLAG_SHIFT                                     30
+// DW1
+#define WF_LWTBL_PEER_LINK_ADDRESS_31_0__DW                         1
+#define WF_LWTBL_PEER_LINK_ADDRESS_31_0__ADDR                       4
+#define WF_LWTBL_PEER_LINK_ADDRESS_31_0__MASK \
+	0xffffffff // 31- 0
+#define WF_LWTBL_PEER_LINK_ADDRESS_31_0__SHIFT                      0
+// DW2
+#define WF_LWTBL_AID_DW                                             2
+#define WF_LWTBL_AID_ADDR                                           8
+#define WF_LWTBL_AID_MASK \
+	0x00000fff // 11- 0
+#define WF_LWTBL_AID_SHIFT                                          0
+#define WF_LWTBL_GID_SU_DW                                          2
+#define WF_LWTBL_GID_SU_ADDR                                        8
+#define WF_LWTBL_GID_SU_MASK \
+	0x00001000 // 12-12
+#define WF_LWTBL_GID_SU_SHIFT                                       12
+#define WF_LWTBL_SPP_EN_DW                                          2
+#define WF_LWTBL_SPP_EN_ADDR                                        8
+#define WF_LWTBL_SPP_EN_MASK \
+	0x00002000 // 13-13
+#define WF_LWTBL_SPP_EN_SHIFT                                       13
+#define WF_LWTBL_WPI_EVEN_DW                                        2
+#define WF_LWTBL_WPI_EVEN_ADDR                                      8
+#define WF_LWTBL_WPI_EVEN_MASK \
+	0x00004000 // 14-14
+#define WF_LWTBL_WPI_EVEN_SHIFT                                     14
+#define WF_LWTBL_AAD_OM_DW                                          2
+#define WF_LWTBL_AAD_OM_ADDR                                        8
+#define WF_LWTBL_AAD_OM_MASK \
+	0x00008000 // 15-15
+#define WF_LWTBL_AAD_OM_SHIFT                                       15
+/* kite DW2 field bit 13-14 */
+#define WF_LWTBL_DUAL_PTEC_EN_DW                                    2
+#define WF_LWTBL_DUAL_PTEC_EN_ADDR                                  8
+#define WF_LWTBL_DUAL_PTEC_EN_MASK \
+	0x00002000 // 13-13
+#define WF_LWTBL_DUAL_PTEC_EN_SHIFT                                 13
+#define WF_LWTBL_DUAL_CTS_CAP_DW                                    2
+#define WF_LWTBL_DUAL_CTS_CAP_ADDR                                  8
+#define WF_LWTBL_DUAL_CTS_CAP_MASK \
+	0x00004000 // 14-14
+#define WF_LWTBL_DUAL_CTS_CAP_SHIFT                                 14
+#define WF_LWTBL_CIPHER_SUIT_PGTK_DW                                2
+#define WF_LWTBL_CIPHER_SUIT_PGTK_ADDR                              8
+#define WF_LWTBL_CIPHER_SUIT_PGTK_MASK \
+	0x001f0000 // 20-16
+#define WF_LWTBL_CIPHER_SUIT_PGTK_SHIFT                             16
+#define WF_LWTBL_FD_DW                                              2
+#define WF_LWTBL_FD_ADDR                                            8
+#define WF_LWTBL_FD_MASK \
+	0x00200000 // 21-21
+#define WF_LWTBL_FD_SHIFT                                           21
+#define WF_LWTBL_TD_DW                                              2
+#define WF_LWTBL_TD_ADDR                                            8
+#define WF_LWTBL_TD_MASK \
+	0x00400000 // 22-22
+#define WF_LWTBL_TD_SHIFT                                           22
+#define WF_LWTBL_SW_DW                                              2
+#define WF_LWTBL_SW_ADDR                                            8
+#define WF_LWTBL_SW_MASK \
+	0x00800000 // 23-23
+#define WF_LWTBL_SW_SHIFT                                           23
+#define WF_LWTBL_UL_DW                                              2
+#define WF_LWTBL_UL_ADDR                                            8
+#define WF_LWTBL_UL_MASK \
+	0x01000000 // 24-24
+#define WF_LWTBL_UL_SHIFT                                           24
+#define WF_LWTBL_TX_PS_DW                                           2
+#define WF_LWTBL_TX_PS_ADDR                                         8
+#define WF_LWTBL_TX_PS_MASK \
+	0x02000000 // 25-25
+#define WF_LWTBL_TX_PS_SHIFT                                        25
+#define WF_LWTBL_QOS_DW                                             2
+#define WF_LWTBL_QOS_ADDR                                           8
+#define WF_LWTBL_QOS_MASK \
+	0x04000000 // 26-26
+#define WF_LWTBL_QOS_SHIFT                                          26
+#define WF_LWTBL_HT_DW                                              2
+#define WF_LWTBL_HT_ADDR                                            8
+#define WF_LWTBL_HT_MASK \
+	0x08000000 // 27-27
+#define WF_LWTBL_HT_SHIFT                                           27
+#define WF_LWTBL_VHT_DW                                             2
+#define WF_LWTBL_VHT_ADDR                                           8
+#define WF_LWTBL_VHT_MASK \
+	0x10000000 // 28-28
+#define WF_LWTBL_VHT_SHIFT                                          28
+#define WF_LWTBL_HE_DW                                              2
+#define WF_LWTBL_HE_ADDR                                            8
+#define WF_LWTBL_HE_MASK \
+	0x20000000 // 29-29
+#define WF_LWTBL_HE_SHIFT                                           29
+#define WF_LWTBL_EHT_DW                                             2
+#define WF_LWTBL_EHT_ADDR                                           8
+#define WF_LWTBL_EHT_MASK \
+	0x40000000 // 30-30
+#define WF_LWTBL_EHT_SHIFT                                          30
+#define WF_LWTBL_MESH_DW                                            2
+#define WF_LWTBL_MESH_ADDR                                          8
+#define WF_LWTBL_MESH_MASK \
+	0x80000000 // 31-31
+#define WF_LWTBL_MESH_SHIFT                                         31
+// DW3
+#define WF_LWTBL_WMM_Q_DW                                           3
+#define WF_LWTBL_WMM_Q_ADDR                                         12
+#define WF_LWTBL_WMM_Q_MASK \
+	0x00000003 // 1- 0
+#define WF_LWTBL_WMM_Q_SHIFT                                        0
+#define WF_LWTBL_EHT_SIG_MCS_DW                                     3
+#define WF_LWTBL_EHT_SIG_MCS_ADDR                                   12
+#define WF_LWTBL_EHT_SIG_MCS_MASK \
+	0x0000000c // 3- 2
+#define WF_LWTBL_EHT_SIG_MCS_SHIFT                                  2
+#define WF_LWTBL_HDRT_MODE_DW                                       3
+#define WF_LWTBL_HDRT_MODE_ADDR                                     12
+#define WF_LWTBL_HDRT_MODE_MASK \
+	0x00000010 // 4- 4
+#define WF_LWTBL_HDRT_MODE_SHIFT                                    4
+#define WF_LWTBL_BEAM_CHG_DW                                        3
+#define WF_LWTBL_BEAM_CHG_ADDR                                      12
+#define WF_LWTBL_BEAM_CHG_MASK \
+	0x00000020 // 5- 5
+#define WF_LWTBL_BEAM_CHG_SHIFT                                     5
+#define WF_LWTBL_EHT_LTF_SYM_NUM_OPT_DW                             3
+#define WF_LWTBL_EHT_LTF_SYM_NUM_OPT_ADDR                           12
+#define WF_LWTBL_EHT_LTF_SYM_NUM_OPT_MASK \
+	0x000000c0 // 7- 6
+#define WF_LWTBL_EHT_LTF_SYM_NUM_OPT_SHIFT                          6
+#define WF_LWTBL_PFMU_IDX_DW                                        3
+#define WF_LWTBL_PFMU_IDX_ADDR                                      12
+#define WF_LWTBL_PFMU_IDX_MASK \
+	0x0000ff00 // 15- 8
+#define WF_LWTBL_PFMU_IDX_SHIFT                                     8
+#define WF_LWTBL_ULPF_IDX_DW                                        3
+#define WF_LWTBL_ULPF_IDX_ADDR                                      12
+#define WF_LWTBL_ULPF_IDX_MASK \
+	0x00ff0000 // 23-16
+#define WF_LWTBL_ULPF_IDX_SHIFT                                     16
+#define WF_LWTBL_RIBF_DW                                            3
+#define WF_LWTBL_RIBF_ADDR                                          12
+#define WF_LWTBL_RIBF_MASK \
+	0x01000000 // 24-24
+#define WF_LWTBL_RIBF_SHIFT                                         24
+#define WF_LWTBL_ULPF_DW                                            3
+#define WF_LWTBL_ULPF_ADDR                                          12
+#define WF_LWTBL_ULPF_MASK \
+	0x02000000 // 25-25
+#define WF_LWTBL_ULPF_SHIFT                                         25
+#define WF_LWTBL_BYPASS_TXSMM_DW                                    3
+#define WF_LWTBL_BYPASS_TXSMM_ADDR                                  12
+#define WF_LWTBL_BYPASS_TXSMM_MASK \
+	0x04000000 // 26-26
+#define WF_LWTBL_BYPASS_TXSMM_SHIFT                                 26
+#define WF_LWTBL_TBF_HT_DW                                          3
+#define WF_LWTBL_TBF_HT_ADDR                                        12
+#define WF_LWTBL_TBF_HT_MASK \
+	0x08000000 // 27-27
+#define WF_LWTBL_TBF_HT_SHIFT                                       27
+#define WF_LWTBL_TBF_VHT_DW                                         3
+#define WF_LWTBL_TBF_VHT_ADDR                                       12
+#define WF_LWTBL_TBF_VHT_MASK \
+	0x10000000 // 28-28
+#define WF_LWTBL_TBF_VHT_SHIFT                                      28
+#define WF_LWTBL_TBF_HE_DW                                          3
+#define WF_LWTBL_TBF_HE_ADDR                                        12
+#define WF_LWTBL_TBF_HE_MASK \
+	0x20000000 // 29-29
+#define WF_LWTBL_TBF_HE_SHIFT                                       29
+#define WF_LWTBL_TBF_EHT_DW                                         3
+#define WF_LWTBL_TBF_EHT_ADDR                                       12
+#define WF_LWTBL_TBF_EHT_MASK \
+	0x40000000 // 30-30
+#define WF_LWTBL_TBF_EHT_SHIFT                                      30
+#define WF_LWTBL_IGN_FBK_DW                                         3
+#define WF_LWTBL_IGN_FBK_ADDR                                       12
+#define WF_LWTBL_IGN_FBK_MASK \
+	0x80000000 // 31-31
+#define WF_LWTBL_IGN_FBK_SHIFT                                      31
+// DW4
+#define WF_LWTBL_NEGOTIATED_WINSIZE0_DW                             4
+#define WF_LWTBL_NEGOTIATED_WINSIZE0_ADDR                           16
+#define WF_LWTBL_NEGOTIATED_WINSIZE0_MASK \
+	0x00000007 // 2- 0
+#define WF_LWTBL_NEGOTIATED_WINSIZE0_SHIFT                          0
+#define WF_LWTBL_NEGOTIATED_WINSIZE1_DW                             4
+#define WF_LWTBL_NEGOTIATED_WINSIZE1_ADDR                           16
+#define WF_LWTBL_NEGOTIATED_WINSIZE1_MASK \
+	0x00000038 // 5- 3
+#define WF_LWTBL_NEGOTIATED_WINSIZE1_SHIFT                          3
+#define WF_LWTBL_NEGOTIATED_WINSIZE2_DW                             4
+#define WF_LWTBL_NEGOTIATED_WINSIZE2_ADDR                           16
+#define WF_LWTBL_NEGOTIATED_WINSIZE2_MASK \
+	0x000001c0 // 8- 6
+#define WF_LWTBL_NEGOTIATED_WINSIZE2_SHIFT                          6
+#define WF_LWTBL_NEGOTIATED_WINSIZE3_DW                             4
+#define WF_LWTBL_NEGOTIATED_WINSIZE3_ADDR                           16
+#define WF_LWTBL_NEGOTIATED_WINSIZE3_MASK \
+	0x00000e00 // 11- 9
+#define WF_LWTBL_NEGOTIATED_WINSIZE3_SHIFT                          9
+#define WF_LWTBL_NEGOTIATED_WINSIZE4_DW                             4
+#define WF_LWTBL_NEGOTIATED_WINSIZE4_ADDR                           16
+#define WF_LWTBL_NEGOTIATED_WINSIZE4_MASK \
+	0x00007000 // 14-12
+#define WF_LWTBL_NEGOTIATED_WINSIZE4_SHIFT                          12
+#define WF_LWTBL_NEGOTIATED_WINSIZE5_DW                             4
+#define WF_LWTBL_NEGOTIATED_WINSIZE5_ADDR                           16
+#define WF_LWTBL_NEGOTIATED_WINSIZE5_MASK \
+	0x00038000 // 17-15
+#define WF_LWTBL_NEGOTIATED_WINSIZE5_SHIFT                          15
+#define WF_LWTBL_NEGOTIATED_WINSIZE6_DW                             4
+#define WF_LWTBL_NEGOTIATED_WINSIZE6_ADDR                           16
+#define WF_LWTBL_NEGOTIATED_WINSIZE6_MASK \
+	0x001c0000 // 20-18
+#define WF_LWTBL_NEGOTIATED_WINSIZE6_SHIFT                          18
+#define WF_LWTBL_NEGOTIATED_WINSIZE7_DW                             4
+#define WF_LWTBL_NEGOTIATED_WINSIZE7_ADDR                           16
+#define WF_LWTBL_NEGOTIATED_WINSIZE7_MASK \
+	0x00e00000 // 23-21
+#define WF_LWTBL_NEGOTIATED_WINSIZE7_SHIFT                          21
+#define WF_LWTBL_PE_DW                                              4
+#define WF_LWTBL_PE_ADDR                                            16
+#define WF_LWTBL_PE_MASK \
+	0x03000000 // 25-24
+#define WF_LWTBL_PE_SHIFT                                           24
+#define WF_LWTBL_DIS_RHTR_DW                                        4
+#define WF_LWTBL_DIS_RHTR_ADDR                                      16
+#define WF_LWTBL_DIS_RHTR_MASK \
+	0x04000000 // 26-26
+#define WF_LWTBL_DIS_RHTR_SHIFT                                     26
+#define WF_LWTBL_LDPC_HT_DW                                         4
+#define WF_LWTBL_LDPC_HT_ADDR                                       16
+#define WF_LWTBL_LDPC_HT_MASK \
+	0x08000000 // 27-27
+#define WF_LWTBL_LDPC_HT_SHIFT                                      27
+#define WF_LWTBL_LDPC_VHT_DW                                        4
+#define WF_LWTBL_LDPC_VHT_ADDR                                      16
+#define WF_LWTBL_LDPC_VHT_MASK \
+	0x10000000 // 28-28
+#define WF_LWTBL_LDPC_VHT_SHIFT                                     28
+#define WF_LWTBL_LDPC_HE_DW                                         4
+#define WF_LWTBL_LDPC_HE_ADDR                                       16
+#define WF_LWTBL_LDPC_HE_MASK \
+	0x20000000 // 29-29
+#define WF_LWTBL_LDPC_HE_SHIFT                                      29
+#define WF_LWTBL_LDPC_EHT_DW                                        4
+#define WF_LWTBL_LDPC_EHT_ADDR                                      16
+#define WF_LWTBL_LDPC_EHT_MASK \
+	0x40000000 // 30-30
+#define WF_LWTBL_LDPC_EHT_SHIFT                                     30
+#define WF_LWTBL_BA_MODE_DW                                         4
+#define WF_LWTBL_BA_MODE_ADDR                                       16
+#define WF_LWTBL_BA_MODE_MASK \
+	0x80000000 // 31-31
+#define WF_LWTBL_BA_MODE_SHIFT                                      31
+// DW5
+#define WF_LWTBL_AF_DW                                              5
+#define WF_LWTBL_AF_ADDR                                            20
+#define WF_LWTBL_AF_MASK \
+	0x00000007 // 2- 0
+#define WF_LWTBL_AF_MASK_7992 \
+	0x0000000f // 3- 0
+#define WF_LWTBL_AF_SHIFT                                           0
+#define WF_LWTBL_AF_HE_DW                                           5
+#define WF_LWTBL_AF_HE_ADDR                                         20
+#define WF_LWTBL_AF_HE_MASK \
+	0x00000018 // 4- 3
+#define WF_LWTBL_AF_HE_SHIFT                                        3
+#define WF_LWTBL_RTS_DW                                             5
+#define WF_LWTBL_RTS_ADDR                                           20
+#define WF_LWTBL_RTS_MASK \
+	0x00000020 // 5- 5
+#define WF_LWTBL_RTS_SHIFT                                          5
+#define WF_LWTBL_SMPS_DW                                            5
+#define WF_LWTBL_SMPS_ADDR                                          20
+#define WF_LWTBL_SMPS_MASK \
+	0x00000040 // 6- 6
+#define WF_LWTBL_SMPS_SHIFT                                         6
+#define WF_LWTBL_DYN_BW_DW                                          5
+#define WF_LWTBL_DYN_BW_ADDR                                        20
+#define WF_LWTBL_DYN_BW_MASK \
+	0x00000080 // 7- 7
+#define WF_LWTBL_DYN_BW_SHIFT                                       7
+#define WF_LWTBL_MMSS_DW                                            5
+#define WF_LWTBL_MMSS_ADDR                                          20
+#define WF_LWTBL_MMSS_MASK \
+	0x00000700 // 10- 8
+#define WF_LWTBL_MMSS_SHIFT                                         8
+#define WF_LWTBL_USR_DW                                             5
+#define WF_LWTBL_USR_ADDR                                           20
+#define WF_LWTBL_USR_MASK \
+	0x00000800 // 11-11
+#define WF_LWTBL_USR_SHIFT                                          11
+#define WF_LWTBL_SR_R_DW                                            5
+#define WF_LWTBL_SR_R_ADDR                                          20
+#define WF_LWTBL_SR_R_MASK \
+	0x00007000 // 14-12
+#define WF_LWTBL_SR_R_SHIFT                                         12
+#define WF_LWTBL_SR_ABORT_DW                                        5
+#define WF_LWTBL_SR_ABORT_ADDR                                      20
+#define WF_LWTBL_SR_ABORT_MASK \
+	0x00008000 // 15-15
+#define WF_LWTBL_SR_ABORT_SHIFT                                     15
+#define WF_LWTBL_TX_POWER_OFFSET_DW                                 5
+#define WF_LWTBL_TX_POWER_OFFSET_ADDR                               20
+#define WF_LWTBL_TX_POWER_OFFSET_MASK \
+	0x003f0000 // 21-16
+#define WF_LWTBL_TX_POWER_OFFSET_SHIFT                              16
+#define WF_LWTBL_LTF_EHT_DW                                         5
+#define WF_LWTBL_LTF_EHT_ADDR                                       20
+#define WF_LWTBL_LTF_EHT_MASK \
+	0x00c00000 // 23-22
+#define WF_LWTBL_LTF_EHT_SHIFT                                      22
+#define WF_LWTBL_GI_EHT_DW                                          5
+#define WF_LWTBL_GI_EHT_ADDR                                        20
+#define WF_LWTBL_GI_EHT_MASK \
+	0x03000000 // 25-24
+#define WF_LWTBL_GI_EHT_SHIFT                                       24
+#define WF_LWTBL_DOPPL_DW                                           5
+#define WF_LWTBL_DOPPL_ADDR                                         20
+#define WF_LWTBL_DOPPL_MASK \
+	0x04000000 // 26-26
+#define WF_LWTBL_DOPPL_SHIFT                                        26
+#define WF_LWTBL_TXOP_PS_CAP_DW                                     5
+#define WF_LWTBL_TXOP_PS_CAP_ADDR                                   20
+#define WF_LWTBL_TXOP_PS_CAP_MASK \
+	0x08000000 // 27-27
+#define WF_LWTBL_TXOP_PS_CAP_SHIFT                                  27
+#define WF_LWTBL_DU_I_PSM_DW                                        5
+#define WF_LWTBL_DU_I_PSM_ADDR                                      20
+#define WF_LWTBL_DU_I_PSM_MASK \
+	0x10000000 // 28-28
+#define WF_LWTBL_DU_I_PSM_SHIFT                                     28
+#define WF_LWTBL_I_PSM_DW                                           5
+#define WF_LWTBL_I_PSM_ADDR                                         20
+#define WF_LWTBL_I_PSM_MASK \
+	0x20000000 // 29-29
+#define WF_LWTBL_I_PSM_SHIFT                                        29
+#define WF_LWTBL_PSM_DW                                             5
+#define WF_LWTBL_PSM_ADDR                                           20
+#define WF_LWTBL_PSM_MASK \
+	0x40000000 // 30-30
+#define WF_LWTBL_PSM_SHIFT                                          30
+#define WF_LWTBL_SKIP_TX_DW                                         5
+#define WF_LWTBL_SKIP_TX_ADDR                                       20
+#define WF_LWTBL_SKIP_TX_MASK \
+	0x80000000 // 31-31
+#define WF_LWTBL_SKIP_TX_SHIFT                                      31
+// DW6
+#define WF_LWTBL_CBRN_DW                                            6
+#define WF_LWTBL_CBRN_ADDR                                          24
+#define WF_LWTBL_CBRN_MASK \
+	0x00000007 // 2- 0
+#define WF_LWTBL_CBRN_SHIFT                                         0
+#define WF_LWTBL_DBNSS_EN_DW                                        6
+#define WF_LWTBL_DBNSS_EN_ADDR                                      24
+#define WF_LWTBL_DBNSS_EN_MASK \
+	0x00000008 // 3- 3
+#define WF_LWTBL_DBNSS_EN_SHIFT                                     3
+#define WF_LWTBL_BAF_EN_DW                                          6
+#define WF_LWTBL_BAF_EN_ADDR                                        24
+#define WF_LWTBL_BAF_EN_MASK \
+	0x00000010 // 4- 4
+#define WF_LWTBL_BAF_EN_SHIFT                                       4
+#define WF_LWTBL_RDGBA_DW                                           6
+#define WF_LWTBL_RDGBA_ADDR                                         24
+#define WF_LWTBL_RDGBA_MASK \
+	0x00000020 // 5- 5
+#define WF_LWTBL_RDGBA_SHIFT                                        5
+#define WF_LWTBL_R_DW                                               6
+#define WF_LWTBL_R_ADDR                                             24
+#define WF_LWTBL_R_MASK \
+	0x00000040 // 6- 6
+#define WF_LWTBL_R_SHIFT                                            6
+#define WF_LWTBL_SPE_IDX_DW                                         6
+#define WF_LWTBL_SPE_IDX_ADDR                                       24
+#define WF_LWTBL_SPE_IDX_MASK \
+	0x00000f80 // 11- 7
+#define WF_LWTBL_SPE_IDX_SHIFT                                      7
+#define WF_LWTBL_G2_DW                                              6
+#define WF_LWTBL_G2_ADDR                                            24
+#define WF_LWTBL_G2_MASK \
+	0x00001000 // 12-12
+#define WF_LWTBL_G2_SHIFT                                           12
+#define WF_LWTBL_G4_DW                                              6
+#define WF_LWTBL_G4_ADDR                                            24
+#define WF_LWTBL_G4_MASK \
+	0x00002000 // 13-13
+#define WF_LWTBL_G4_SHIFT                                           13
+#define WF_LWTBL_G8_DW                                              6
+#define WF_LWTBL_G8_ADDR                                            24
+#define WF_LWTBL_G8_MASK \
+	0x00004000 // 14-14
+#define WF_LWTBL_G8_SHIFT                                           14
+#define WF_LWTBL_G16_DW                                             6
+#define WF_LWTBL_G16_ADDR                                           24
+#define WF_LWTBL_G16_MASK \
+	0x00008000 // 15-15
+#define WF_LWTBL_G16_SHIFT                                          15
+#define WF_LWTBL_G2_LTF_DW                                          6
+#define WF_LWTBL_G2_LTF_ADDR                                        24
+#define WF_LWTBL_G2_LTF_MASK \
+	0x00030000 // 17-16
+#define WF_LWTBL_G2_LTF_SHIFT                                       16
+#define WF_LWTBL_G4_LTF_DW                                          6
+#define WF_LWTBL_G4_LTF_ADDR                                        24
+#define WF_LWTBL_G4_LTF_MASK \
+	0x000c0000 // 19-18
+#define WF_LWTBL_G4_LTF_SHIFT                                       18
+#define WF_LWTBL_G8_LTF_DW                                          6
+#define WF_LWTBL_G8_LTF_ADDR                                        24
+#define WF_LWTBL_G8_LTF_MASK \
+	0x00300000 // 21-20
+#define WF_LWTBL_G8_LTF_SHIFT                                       20
+#define WF_LWTBL_G16_LTF_DW                                         6
+#define WF_LWTBL_G16_LTF_ADDR                                       24
+#define WF_LWTBL_G16_LTF_MASK \
+	0x00c00000 // 23-22
+#define WF_LWTBL_G16_LTF_SHIFT                                      22
+#define WF_LWTBL_G2_HE_DW                                           6
+#define WF_LWTBL_G2_HE_ADDR                                         24
+#define WF_LWTBL_G2_HE_MASK \
+	0x03000000 // 25-24
+#define WF_LWTBL_G2_HE_SHIFT                                        24
+#define WF_LWTBL_G4_HE_DW                                           6
+#define WF_LWTBL_G4_HE_ADDR                                         24
+#define WF_LWTBL_G4_HE_MASK \
+	0x0c000000 // 27-26
+#define WF_LWTBL_G4_HE_SHIFT                                        26
+#define WF_LWTBL_G8_HE_DW                                           6
+#define WF_LWTBL_G8_HE_ADDR                                         24
+#define WF_LWTBL_G8_HE_MASK \
+	0x30000000 // 29-28
+#define WF_LWTBL_G8_HE_SHIFT                                        28
+#define WF_LWTBL_G16_HE_DW                                          6
+#define WF_LWTBL_G16_HE_ADDR                                        24
+#define WF_LWTBL_G16_HE_MASK \
+	0xc0000000 // 31-30
+#define WF_LWTBL_G16_HE_SHIFT                                       30
+// DW7
+#define WF_LWTBL_BA_WIN_SIZE0_DW                                    7
+#define WF_LWTBL_BA_WIN_SIZE0_ADDR                                  28
+#define WF_LWTBL_BA_WIN_SIZE0_MASK \
+	0x0000000f // 3- 0
+#define WF_LWTBL_BA_WIN_SIZE0_SHIFT                                 0
+#define WF_LWTBL_BA_WIN_SIZE1_DW                                    7
+#define WF_LWTBL_BA_WIN_SIZE1_ADDR                                  28
+#define WF_LWTBL_BA_WIN_SIZE1_MASK \
+	0x000000f0 // 7- 4
+#define WF_LWTBL_BA_WIN_SIZE1_SHIFT                                 4
+#define WF_LWTBL_BA_WIN_SIZE2_DW                                    7
+#define WF_LWTBL_BA_WIN_SIZE2_ADDR                                  28
+#define WF_LWTBL_BA_WIN_SIZE2_MASK \
+	0x00000f00 // 11- 8
+#define WF_LWTBL_BA_WIN_SIZE2_SHIFT                                 8
+#define WF_LWTBL_BA_WIN_SIZE3_DW                                    7
+#define WF_LWTBL_BA_WIN_SIZE3_ADDR                                  28
+#define WF_LWTBL_BA_WIN_SIZE3_MASK \
+	0x0000f000 // 15-12
+#define WF_LWTBL_BA_WIN_SIZE3_SHIFT                                 12
+#define WF_LWTBL_BA_WIN_SIZE4_DW                                    7
+#define WF_LWTBL_BA_WIN_SIZE4_ADDR                                  28
+#define WF_LWTBL_BA_WIN_SIZE4_MASK \
+	0x000f0000 // 19-16
+#define WF_LWTBL_BA_WIN_SIZE4_SHIFT                                 16
+#define WF_LWTBL_BA_WIN_SIZE5_DW                                    7
+#define WF_LWTBL_BA_WIN_SIZE5_ADDR                                  28
+#define WF_LWTBL_BA_WIN_SIZE5_MASK \
+	0x00f00000 // 23-20
+#define WF_LWTBL_BA_WIN_SIZE5_SHIFT                                 20
+#define WF_LWTBL_BA_WIN_SIZE6_DW                                    7
+#define WF_LWTBL_BA_WIN_SIZE6_ADDR                                  28
+#define WF_LWTBL_BA_WIN_SIZE6_MASK \
+	0x0f000000 // 27-24
+#define WF_LWTBL_BA_WIN_SIZE6_SHIFT                                 24
+#define WF_LWTBL_BA_WIN_SIZE7_DW                                    7
+#define WF_LWTBL_BA_WIN_SIZE7_ADDR                                  28
+#define WF_LWTBL_BA_WIN_SIZE7_MASK \
+	0xf0000000 // 31-28
+#define WF_LWTBL_BA_WIN_SIZE7_SHIFT                                 28
+// DW8
+#define WF_LWTBL_AC0_RTS_FAIL_CNT_DW                                8
+#define WF_LWTBL_AC0_RTS_FAIL_CNT_ADDR                              32
+#define WF_LWTBL_AC0_RTS_FAIL_CNT_MASK \
+	0x0000001f // 4- 0
+#define WF_LWTBL_AC0_RTS_FAIL_CNT_SHIFT                             0
+#define WF_LWTBL_AC1_RTS_FAIL_CNT_DW                                8
+#define WF_LWTBL_AC1_RTS_FAIL_CNT_ADDR                              32
+#define WF_LWTBL_AC1_RTS_FAIL_CNT_MASK \
+	0x000003e0 // 9- 5
+#define WF_LWTBL_AC1_RTS_FAIL_CNT_SHIFT                             5
+#define WF_LWTBL_AC2_RTS_FAIL_CNT_DW                                8
+#define WF_LWTBL_AC2_RTS_FAIL_CNT_ADDR                              32
+#define WF_LWTBL_AC2_RTS_FAIL_CNT_MASK \
+	0x00007c00 // 14-10
+#define WF_LWTBL_AC2_RTS_FAIL_CNT_SHIFT                             10
+#define WF_LWTBL_AC3_RTS_FAIL_CNT_DW                                8
+#define WF_LWTBL_AC3_RTS_FAIL_CNT_ADDR                              32
+#define WF_LWTBL_AC3_RTS_FAIL_CNT_MASK \
+	0x000f8000 // 19-15
+#define WF_LWTBL_AC3_RTS_FAIL_CNT_SHIFT                             15
+#define WF_LWTBL_PARTIAL_AID_DW                                     8
+#define WF_LWTBL_PARTIAL_AID_ADDR                                   32
+#define WF_LWTBL_PARTIAL_AID_MASK \
+	0x1ff00000 // 28-20
+#define WF_LWTBL_PARTIAL_AID_SHIFT                                  20
+#define WF_LWTBL_CHK_PER_DW                                         8
+#define WF_LWTBL_CHK_PER_ADDR                                       32
+#define WF_LWTBL_CHK_PER_MASK \
+	0x80000000 // 31-31
+#define WF_LWTBL_CHK_PER_SHIFT                                      31
+// DW9
+#define WF_LWTBL_RX_AVG_MPDU_SIZE_DW                                9
+#define WF_LWTBL_RX_AVG_MPDU_SIZE_ADDR                              36
+#define WF_LWTBL_RX_AVG_MPDU_SIZE_MASK \
+	0x00003fff // 13- 0
+#define WF_LWTBL_RX_AVG_MPDU_SIZE_SHIFT                             0
+#define WF_LWTBL_PRITX_SW_MODE_DW                                   9
+#define WF_LWTBL_PRITX_SW_MODE_ADDR                                 36
+#define WF_LWTBL_PRITX_SW_MODE_MASK \
+	0x00008000 // 15-15
+#define WF_LWTBL_PRITX_SW_MODE_SHIFT                                15
+#define WF_LWTBL_PRITX_SW_MODE_MASK_7992 \
+	0x00004000 // 14-14
+#define WF_LWTBL_PRITX_SW_MODE_SHIFT_7992                           14
+#define WF_LWTBL_PRITX_ERSU_DW                                      9
+#define WF_LWTBL_PRITX_ERSU_ADDR                                    36
+#define WF_LWTBL_PRITX_ERSU_MASK \
+	0x00010000 // 16-16
+#define WF_LWTBL_PRITX_ERSU_SHIFT                                   16
+#define WF_LWTBL_PRITX_ERSU_MASK_7992 \
+	0x00008000 // 15-15
+#define WF_LWTBL_PRITX_ERSU_SHIFT_7992                              15
+#define WF_LWTBL_PRITX_PLR_DW                                       9
+#define WF_LWTBL_PRITX_PLR_ADDR                                     36
+#define WF_LWTBL_PRITX_PLR_MASK \
+	0x00020000 // 17-17
+#define WF_LWTBL_PRITX_PLR_SHIFT                                    17
+#define WF_LWTBL_PRITX_PLR_MASK_7992 \
+	0x00030000 // 17-16
+#define WF_LWTBL_PRITX_PLR_SHIFT_7992                               16
+#define WF_LWTBL_PRITX_DCM_DW                                       9
+#define WF_LWTBL_PRITX_DCM_ADDR                                     36
+#define WF_LWTBL_PRITX_DCM_MASK \
+	0x00040000 // 18-18
+#define WF_LWTBL_PRITX_DCM_SHIFT                                    18
+#define WF_LWTBL_PRITX_ER106T_DW                                    9
+#define WF_LWTBL_PRITX_ER106T_ADDR                                  36
+#define WF_LWTBL_PRITX_ER106T_MASK \
+	0x00080000 // 19-19
+#define WF_LWTBL_PRITX_ER106T_SHIFT                                 19
+#define WF_LWTBL_FCAP_DW                                            9
+#define WF_LWTBL_FCAP_ADDR                                          36
+#define WF_LWTBL_FCAP_MASK \
+	0x00700000 // 22-20
+#define WF_LWTBL_FCAP_SHIFT                                         20
+#define WF_LWTBL_MPDU_FAIL_CNT_DW                                   9
+#define WF_LWTBL_MPDU_FAIL_CNT_ADDR                                 36
+#define WF_LWTBL_MPDU_FAIL_CNT_MASK \
+	0x03800000 // 25-23
+#define WF_LWTBL_MPDU_FAIL_CNT_SHIFT                                23
+#define WF_LWTBL_MPDU_OK_CNT_DW                                     9
+#define WF_LWTBL_MPDU_OK_CNT_ADDR                                   36
+#define WF_LWTBL_MPDU_OK_CNT_MASK \
+	0x1c000000 // 28-26
+#define WF_LWTBL_MPDU_OK_CNT_SHIFT                                  26
+#define WF_LWTBL_RATE_IDX_DW                                        9
+#define WF_LWTBL_RATE_IDX_ADDR                                      36
+#define WF_LWTBL_RATE_IDX_MASK \
+	0xe0000000 // 31-29
+#define WF_LWTBL_RATE_IDX_SHIFT                                     29
+// DW10
+#define WF_LWTBL_RATE1_DW                                           10
+#define WF_LWTBL_RATE1_ADDR                                         40
+#define WF_LWTBL_RATE1_MASK \
+	0x00007fff // 14- 0
+#define WF_LWTBL_RATE1_SHIFT                                        0
+#define WF_LWTBL_RATE2_DW                                           10
+#define WF_LWTBL_RATE2_ADDR                                         40
+#define WF_LWTBL_RATE2_MASK \
+	0x7fff0000 // 30-16
+#define WF_LWTBL_RATE2_SHIFT                                        16
+// DW11
+#define WF_LWTBL_RATE3_DW                                           11
+#define WF_LWTBL_RATE3_ADDR                                         44
+#define WF_LWTBL_RATE3_MASK \
+	0x00007fff // 14- 0
+#define WF_LWTBL_RATE3_SHIFT                                        0
+#define WF_LWTBL_RATE4_DW                                           11
+#define WF_LWTBL_RATE4_ADDR                                         44
+#define WF_LWTBL_RATE4_MASK \
+	0x7fff0000 // 30-16
+#define WF_LWTBL_RATE4_SHIFT                                        16
+// DW12
+#define WF_LWTBL_RATE5_DW                                           12
+#define WF_LWTBL_RATE5_ADDR                                         48
+#define WF_LWTBL_RATE5_MASK \
+	0x00007fff // 14- 0
+#define WF_LWTBL_RATE5_SHIFT                                        0
+#define WF_LWTBL_RATE6_DW                                           12
+#define WF_LWTBL_RATE6_ADDR                                         48
+#define WF_LWTBL_RATE6_MASK \
+	0x7fff0000 // 30-16
+#define WF_LWTBL_RATE6_SHIFT                                        16
+// DW13
+#define WF_LWTBL_RATE7_DW                                           13
+#define WF_LWTBL_RATE7_ADDR                                         52
+#define WF_LWTBL_RATE7_MASK \
+	0x00007fff // 14- 0
+#define WF_LWTBL_RATE7_SHIFT                                        0
+#define WF_LWTBL_RATE8_DW                                           13
+#define WF_LWTBL_RATE8_ADDR                                         52
+#define WF_LWTBL_RATE8_MASK \
+	0x7fff0000 // 30-16
+#define WF_LWTBL_RATE8_SHIFT                                        16
+// DW14
+#define WF_LWTBL_RATE1_TX_CNT_DW                                    14
+#define WF_LWTBL_RATE1_TX_CNT_ADDR                                  56
+#define WF_LWTBL_RATE1_TX_CNT_MASK \
+	0x0000ffff // 15- 0
+#define WF_LWTBL_RATE1_TX_CNT_SHIFT                                 0
+#define WF_LWTBL_CIPHER_SUIT_IGTK_DW                                14
+#define WF_LWTBL_CIPHER_SUIT_IGTK_ADDR                              56
+#define WF_LWTBL_CIPHER_SUIT_IGTK_MASK \
+	0x00003000 // 13-12
+#define WF_LWTBL_CIPHER_SUIT_IGTK_SHIFT                             12
+#define WF_LWTBL_CIPHER_SUIT_BIGTK_DW                               14
+#define WF_LWTBL_CIPHER_SUIT_BIGTK_ADDR                             56
+#define WF_LWTBL_CIPHER_SUIT_BIGTK_MASK \
+	0x0000c000 // 15-14
+#define WF_LWTBL_CIPHER_SUIT_BIGTK_SHIFT                            14
+#define WF_LWTBL_RATE1_FAIL_CNT_DW                                  14
+#define WF_LWTBL_RATE1_FAIL_CNT_ADDR                                56
+#define WF_LWTBL_RATE1_FAIL_CNT_MASK \
+	0xffff0000 // 31-16
+#define WF_LWTBL_RATE1_FAIL_CNT_SHIFT                               16
+// DW15
+#define WF_LWTBL_RATE2_OK_CNT_DW                                    15
+#define WF_LWTBL_RATE2_OK_CNT_ADDR                                  60
+#define WF_LWTBL_RATE2_OK_CNT_MASK \
+	0x0000ffff // 15- 0
+#define WF_LWTBL_RATE2_OK_CNT_SHIFT                                 0
+#define WF_LWTBL_RATE3_OK_CNT_DW                                    15
+#define WF_LWTBL_RATE3_OK_CNT_ADDR                                  60
+#define WF_LWTBL_RATE3_OK_CNT_MASK \
+	0xffff0000 // 31-16
+#define WF_LWTBL_RATE3_OK_CNT_SHIFT                                 16
+// DW16
+#define WF_LWTBL_CURRENT_BW_TX_CNT_DW                               16
+#define WF_LWTBL_CURRENT_BW_TX_CNT_ADDR                             64
+#define WF_LWTBL_CURRENT_BW_TX_CNT_MASK \
+	0x0000ffff // 15- 0
+#define WF_LWTBL_CURRENT_BW_TX_CNT_SHIFT                            0
+#define WF_LWTBL_CURRENT_BW_FAIL_CNT_DW                             16
+#define WF_LWTBL_CURRENT_BW_FAIL_CNT_ADDR                           64
+#define WF_LWTBL_CURRENT_BW_FAIL_CNT_MASK \
+	0xffff0000 // 31-16
+#define WF_LWTBL_CURRENT_BW_FAIL_CNT_SHIFT                          16
+// DW17
+#define WF_LWTBL_OTHER_BW_TX_CNT_DW                                 17
+#define WF_LWTBL_OTHER_BW_TX_CNT_ADDR                               68
+#define WF_LWTBL_OTHER_BW_TX_CNT_MASK \
+	0x0000ffff // 15- 0
+#define WF_LWTBL_OTHER_BW_TX_CNT_SHIFT                              0
+#define WF_LWTBL_OTHER_BW_FAIL_CNT_DW                               17
+#define WF_LWTBL_OTHER_BW_FAIL_CNT_ADDR                             68
+#define WF_LWTBL_OTHER_BW_FAIL_CNT_MASK \
+	0xffff0000 // 31-16
+#define WF_LWTBL_OTHER_BW_FAIL_CNT_SHIFT                            16
+// DW18
+#define WF_LWTBL_RTS_OK_CNT_DW                                      18
+#define WF_LWTBL_RTS_OK_CNT_ADDR                                    72
+#define WF_LWTBL_RTS_OK_CNT_MASK \
+	0x0000ffff // 15- 0
+#define WF_LWTBL_RTS_OK_CNT_SHIFT                                   0
+#define WF_LWTBL_RTS_FAIL_CNT_DW                                    18
+#define WF_LWTBL_RTS_FAIL_CNT_ADDR                                  72
+#define WF_LWTBL_RTS_FAIL_CNT_MASK \
+	0xffff0000 // 31-16
+#define WF_LWTBL_RTS_FAIL_CNT_SHIFT                                 16
+// DW19
+#define WF_LWTBL_DATA_RETRY_CNT_DW                                  19
+#define WF_LWTBL_DATA_RETRY_CNT_ADDR                                76
+#define WF_LWTBL_DATA_RETRY_CNT_MASK \
+	0x0000ffff // 15- 0
+#define WF_LWTBL_DATA_RETRY_CNT_SHIFT                               0
+#define WF_LWTBL_MGNT_RETRY_CNT_DW                                  19
+#define WF_LWTBL_MGNT_RETRY_CNT_ADDR                                76
+#define WF_LWTBL_MGNT_RETRY_CNT_MASK \
+	0xffff0000 // 31-16
+#define WF_LWTBL_MGNT_RETRY_CNT_SHIFT                               16
+// DW20
+#define WF_LWTBL_AC0_CTT_CDT_CRB_DW                                 20
+#define WF_LWTBL_AC0_CTT_CDT_CRB_ADDR                               80
+#define WF_LWTBL_AC0_CTT_CDT_CRB_MASK \
+	0xffffffff // 31- 0
+#define WF_LWTBL_AC0_CTT_CDT_CRB_SHIFT                              0
+// DW21
+// DO NOT process repeat field(adm[0])
+// DW22
+#define WF_LWTBL_AC1_CTT_CDT_CRB_DW                                 22
+#define WF_LWTBL_AC1_CTT_CDT_CRB_ADDR                               88
+#define WF_LWTBL_AC1_CTT_CDT_CRB_MASK \
+	0xffffffff // 31- 0
+#define WF_LWTBL_AC1_CTT_CDT_CRB_SHIFT                              0
+// DW23
+// DO NOT process repeat field(adm[1])
+// DW24
+#define WF_LWTBL_AC2_CTT_CDT_CRB_DW                                 24
+#define WF_LWTBL_AC2_CTT_CDT_CRB_ADDR                               96
+#define WF_LWTBL_AC2_CTT_CDT_CRB_MASK \
+	0xffffffff // 31- 0
+#define WF_LWTBL_AC2_CTT_CDT_CRB_SHIFT                              0
+// DW25
+// DO NOT process repeat field(adm[2])
+// DW26
+#define WF_LWTBL_AC3_CTT_CDT_CRB_DW                                 26
+#define WF_LWTBL_AC3_CTT_CDT_CRB_ADDR                               104
+#define WF_LWTBL_AC3_CTT_CDT_CRB_MASK \
+	0xffffffff // 31- 0
+#define WF_LWTBL_AC3_CTT_CDT_CRB_SHIFT                              0
+// DW27
+// DO NOT process repeat field(adm[3])
+// DW28
+#define WF_LWTBL_RELATED_IDX0_DW                                    28
+#define WF_LWTBL_RELATED_IDX0_ADDR                                  112
+#define WF_LWTBL_RELATED_IDX0_MASK \
+	0x00000fff // 11- 0
+#define WF_LWTBL_RELATED_IDX0_SHIFT                                 0
+#define WF_LWTBL_RELATED_BAND0_DW                                   28
+#define WF_LWTBL_RELATED_BAND0_ADDR                                 112
+#define WF_LWTBL_RELATED_BAND0_MASK \
+	0x00003000 // 13-12
+#define WF_LWTBL_RELATED_BAND0_SHIFT                                12
+#define WF_LWTBL_PRIMARY_MLD_BAND_DW                                28
+#define WF_LWTBL_PRIMARY_MLD_BAND_ADDR                              112
+#define WF_LWTBL_PRIMARY_MLD_BAND_MASK \
+	0x0000c000 // 15-14
+#define WF_LWTBL_PRIMARY_MLD_BAND_SHIFT                             14
+#define WF_LWTBL_RELATED_IDX1_DW                                    28
+#define WF_LWTBL_RELATED_IDX1_ADDR                                  112
+#define WF_LWTBL_RELATED_IDX1_MASK \
+	0x0fff0000 // 27-16
+#define WF_LWTBL_RELATED_IDX1_SHIFT                                 16
+#define WF_LWTBL_RELATED_BAND1_DW                                   28
+#define WF_LWTBL_RELATED_BAND1_ADDR                                 112
+#define WF_LWTBL_RELATED_BAND1_MASK \
+	0x30000000 // 29-28
+#define WF_LWTBL_RELATED_BAND1_SHIFT                                28
+#define WF_LWTBL_SECONDARY_MLD_BAND_DW                              28
+#define WF_LWTBL_SECONDARY_MLD_BAND_ADDR                            112
+#define WF_LWTBL_SECONDARY_MLD_BAND_MASK \
+	0xc0000000 // 31-30
+#define WF_LWTBL_SECONDARY_MLD_BAND_SHIFT                           30
+// DW29
+#define WF_LWTBL_DISPATCH_POLICY0_DW                                29
+#define WF_LWTBL_DISPATCH_POLICY0_ADDR                              116
+#define WF_LWTBL_DISPATCH_POLICY0_MASK \
+	0x00000003 // 1- 0
+#define WF_LWTBL_DISPATCH_POLICY0_SHIFT                             0
+#define WF_LWTBL_DISPATCH_POLICY1_DW                                29
+#define WF_LWTBL_DISPATCH_POLICY1_ADDR                              116
+#define WF_LWTBL_DISPATCH_POLICY1_MASK \
+	0x0000000c // 3- 2
+#define WF_LWTBL_DISPATCH_POLICY1_SHIFT                             2
+#define WF_LWTBL_DISPATCH_POLICY2_DW                                29
+#define WF_LWTBL_DISPATCH_POLICY2_ADDR                              116
+#define WF_LWTBL_DISPATCH_POLICY2_MASK \
+	0x00000030 // 5- 4
+#define WF_LWTBL_DISPATCH_POLICY2_SHIFT                             4
+#define WF_LWTBL_DISPATCH_POLICY3_DW                                29
+#define WF_LWTBL_DISPATCH_POLICY3_ADDR                              116
+#define WF_LWTBL_DISPATCH_POLICY3_MASK \
+	0x000000c0 // 7- 6
+#define WF_LWTBL_DISPATCH_POLICY3_SHIFT                             6
+#define WF_LWTBL_DISPATCH_POLICY4_DW                                29
+#define WF_LWTBL_DISPATCH_POLICY4_ADDR                              116
+#define WF_LWTBL_DISPATCH_POLICY4_MASK \
+	0x00000300 // 9- 8
+#define WF_LWTBL_DISPATCH_POLICY4_SHIFT                             8
+#define WF_LWTBL_DISPATCH_POLICY5_DW                                29
+#define WF_LWTBL_DISPATCH_POLICY5_ADDR                              116
+#define WF_LWTBL_DISPATCH_POLICY5_MASK \
+	0x00000c00 // 11-10
+#define WF_LWTBL_DISPATCH_POLICY5_SHIFT                             10
+#define WF_LWTBL_DISPATCH_POLICY6_DW                                29
+#define WF_LWTBL_DISPATCH_POLICY6_ADDR                              116
+#define WF_LWTBL_DISPATCH_POLICY6_MASK \
+	0x00003000 // 13-12
+#define WF_LWTBL_DISPATCH_POLICY6_SHIFT                             12
+#define WF_LWTBL_DISPATCH_POLICY7_DW                                29
+#define WF_LWTBL_DISPATCH_POLICY7_ADDR                              116
+#define WF_LWTBL_DISPATCH_POLICY7_MASK \
+	0x0000c000 // 15-14
+#define WF_LWTBL_DISPATCH_POLICY7_SHIFT                             14
+#define WF_LWTBL_OWN_MLD_ID_DW                                      29
+#define WF_LWTBL_OWN_MLD_ID_ADDR                                    116
+#define WF_LWTBL_OWN_MLD_ID_MASK \
+	0x003f0000 // 21-16
+#define WF_LWTBL_OWN_MLD_ID_SHIFT                                   16
+#define WF_LWTBL_EMLSR0_DW                                          29
+#define WF_LWTBL_EMLSR0_ADDR                                        116
+#define WF_LWTBL_EMLSR0_MASK \
+	0x00400000 // 22-22
+#define WF_LWTBL_EMLSR0_SHIFT                                       22
+#define WF_LWTBL_EMLMR0_DW                                          29
+#define WF_LWTBL_EMLMR0_ADDR                                        116
+#define WF_LWTBL_EMLMR0_MASK \
+	0x00800000 // 23-23
+#define WF_LWTBL_EMLMR0_SHIFT                                       23
+#define WF_LWTBL_EMLSR1_DW                                          29
+#define WF_LWTBL_EMLSR1_ADDR                                        116
+#define WF_LWTBL_EMLSR1_MASK \
+	0x01000000 // 24-24
+#define WF_LWTBL_EMLSR1_SHIFT                                       24
+#define WF_LWTBL_EMLMR1_DW                                          29
+#define WF_LWTBL_EMLMR1_ADDR                                        116
+#define WF_LWTBL_EMLMR1_MASK \
+	0x02000000 // 25-25
+#define WF_LWTBL_EMLMR1_SHIFT                                       25
+#define WF_LWTBL_EMLSR2_DW                                          29
+#define WF_LWTBL_EMLSR2_ADDR                                        116
+#define WF_LWTBL_EMLSR2_MASK \
+	0x04000000 // 26-26
+#define WF_LWTBL_EMLSR2_SHIFT                                       26
+#define WF_LWTBL_EMLMR2_DW                                          29
+#define WF_LWTBL_EMLMR2_ADDR                                        116
+#define WF_LWTBL_EMLMR2_MASK \
+	0x08000000 // 27-27
+#define WF_LWTBL_EMLMR2_SHIFT                                       27
+#define WF_LWTBL_STR_BITMAP_DW                                      29
+#define WF_LWTBL_STR_BITMAP_ADDR                                    116
+#define WF_LWTBL_STR_BITMAP_MASK \
+	0xe0000000 // 31-29
+#define WF_LWTBL_STR_BITMAP_SHIFT                                   29
+// DW30
+#define WF_LWTBL_DISPATCH_ORDER_DW                                  30
+#define WF_LWTBL_DISPATCH_ORDER_ADDR                                120
+#define WF_LWTBL_DISPATCH_ORDER_MASK \
+	0x0000007f // 6- 0
+#define WF_LWTBL_DISPATCH_ORDER_SHIFT                               0
+#define WF_LWTBL_DISPATCH_RATIO_DW                                  30
+#define WF_LWTBL_DISPATCH_RATIO_ADDR                                120
+#define WF_LWTBL_DISPATCH_RATIO_MASK \
+	0x00003f80 // 13- 7
+#define WF_LWTBL_DISPATCH_RATIO_SHIFT                               7
+#define WF_LWTBL_LINK_MGF_DW                                        30
+#define WF_LWTBL_LINK_MGF_ADDR                                      120
+#define WF_LWTBL_LINK_MGF_MASK \
+	0xffff0000 // 31-16
+#define WF_LWTBL_LINK_MGF_SHIFT                                     16
+// DW31
+#define WF_LWTBL_BFTX_TB_DW                                         31
+#define WF_LWTBL_BFTX_TB_ADDR                                       124
+#define WF_LWTBL_BFTX_TB_MASK \
+	0x00800000 // 23-23
+#define WF_LWTBL_DROP_DW                                            31
+#define WF_LWTBL_DROP_ADDR                                          124
+#define WF_LWTBL_DROP_MASK \
+	0x01000000 // 24-24
+#define WF_LWTBL_DROP_SHIFT                                         24
+#define WF_LWTBL_CASCAD_DW                                          31
+#define WF_LWTBL_CASCAD_ADDR                                        124
+#define WF_LWTBL_CASCAD_MASK \
+	0x02000000 // 25-25
+#define WF_LWTBL_CASCAD_SHIFT                                       25
+#define WF_LWTBL_ALL_ACK_DW                                         31
+#define WF_LWTBL_ALL_ACK_ADDR                                       124
+#define WF_LWTBL_ALL_ACK_MASK \
+	0x04000000 // 26-26
+#define WF_LWTBL_ALL_ACK_SHIFT                                      26
+#define WF_LWTBL_MPDU_SIZE_DW                                       31
+#define WF_LWTBL_MPDU_SIZE_ADDR                                     124
+#define WF_LWTBL_MPDU_SIZE_MASK \
+	0x18000000 // 28-27
+#define WF_LWTBL_MPDU_SIZE_SHIFT                                    27
+#define WF_LWTBL_RXD_DUP_MODE_DW                                    31
+#define WF_LWTBL_RXD_DUP_MODE_ADDR                                  124
+#define WF_LWTBL_RXD_DUP_MODE_MASK \
+	0x60000000 // 30-29
+#define WF_LWTBL_RXD_DUP_MODE_SHIFT                                 29
+#define WF_LWTBL_ACK_EN_DW                                          31
+#define WF_LWTBL_ACK_EN_ADDR                                        128
+#define WF_LWTBL_ACK_EN_MASK \
+	0x80000000 // 31-31
+#define WF_LWTBL_ACK_EN_SHIFT                                       31
+// DW32
+#define WF_LWTBL_OM_INFO_DW                                         32
+#define WF_LWTBL_OM_INFO_ADDR                                       128
+#define WF_LWTBL_OM_INFO_MASK \
+	0x00000fff // 11- 0
+#define WF_LWTBL_OM_INFO_SHIFT                                      0
+#define WF_LWTBL_OM_INFO_EHT_DW                                     32
+#define WF_LWTBL_OM_INFO_EHT_ADDR                                   128
+#define WF_LWTBL_OM_INFO_EHT_MASK \
+	0x0000f000 // 15-12
+#define WF_LWTBL_OM_INFO_EHT_SHIFT                                  12
+#define WF_LWTBL_RXD_DUP_FOR_OM_CHG_DW                              32
+#define WF_LWTBL_RXD_DUP_FOR_OM_CHG_ADDR                            128
+#define WF_LWTBL_RXD_DUP_FOR_OM_CHG_MASK \
+	0x00010000 // 16-16
+#define WF_LWTBL_RXD_DUP_FOR_OM_CHG_SHIFT                           16
+#define WF_LWTBL_RXD_DUP_WHITE_LIST_DW                              32
+#define WF_LWTBL_RXD_DUP_WHITE_LIST_ADDR                            128
+#define WF_LWTBL_RXD_DUP_WHITE_LIST_MASK \
+	0x1ffe0000 // 28-17
+#define WF_LWTBL_RXD_DUP_WHITE_LIST_SHIFT                           17
+// DW33
+#define WF_LWTBL_USER_RSSI_DW                                       33
+#define WF_LWTBL_USER_RSSI_ADDR                                     132
+#define WF_LWTBL_USER_RSSI_MASK \
+	0x000001ff // 8- 0
+#define WF_LWTBL_USER_RSSI_SHIFT                                    0
+#define WF_LWTBL_USER_SNR_DW                                        33
+#define WF_LWTBL_USER_SNR_ADDR                                      132
+#define WF_LWTBL_USER_SNR_MASK \
+	0x00007e00 // 14- 9
+#define WF_LWTBL_USER_SNR_SHIFT                                     9
+#define WF_LWTBL_RAPID_REACTION_RATE_DW                             33
+#define WF_LWTBL_RAPID_REACTION_RATE_ADDR                           132
+#define WF_LWTBL_RAPID_REACTION_RATE_MASK \
+	0x0fff0000 // 27-16
+#define WF_LWTBL_RAPID_REACTION_RATE_SHIFT                          16
+#define WF_LWTBL_HT_AMSDU_DW                                        33
+#define WF_LWTBL_HT_AMSDU_ADDR                                      132
+#define WF_LWTBL_HT_AMSDU_MASK \
+	0x40000000 // 30-30
+#define WF_LWTBL_HT_AMSDU_SHIFT                                     30
+#define WF_LWTBL_AMSDU_CROSS_LG_DW                                  33
+#define WF_LWTBL_AMSDU_CROSS_LG_ADDR                                132
+#define WF_LWTBL_AMSDU_CROSS_LG_MASK \
+	0x80000000 // 31-31
+#define WF_LWTBL_AMSDU_CROSS_LG_SHIFT                               31
+// DW34
+#define WF_LWTBL_RESP_RCPI0_DW                                      34
+#define WF_LWTBL_RESP_RCPI0_ADDR                                    136
+#define WF_LWTBL_RESP_RCPI0_MASK \
+	0x000000ff // 7- 0
+#define WF_LWTBL_RESP_RCPI0_SHIFT                                   0
+#define WF_LWTBL_RESP_RCPI1_DW                                      34
+#define WF_LWTBL_RESP_RCPI1_ADDR                                    136
+#define WF_LWTBL_RESP_RCPI1_MASK \
+	0x0000ff00 // 15- 8
+#define WF_LWTBL_RESP_RCPI1_SHIFT                                   8
+#define WF_LWTBL_RESP_RCPI2_DW                                      34
+#define WF_LWTBL_RESP_RCPI2_ADDR                                    136
+#define WF_LWTBL_RESP_RCPI2_MASK \
+	0x00ff0000 // 23-16
+#define WF_LWTBL_RESP_RCPI2_SHIFT                                   16
+#define WF_LWTBL_RESP_RCPI3_DW                                      34
+#define WF_LWTBL_RESP_RCPI3_ADDR                                    136
+#define WF_LWTBL_RESP_RCPI3_MASK \
+	0xff000000 // 31-24
+#define WF_LWTBL_RESP_RCPI3_SHIFT                                   24
+// DW35
+#define WF_LWTBL_SNR_RX0_DW                                         35
+#define WF_LWTBL_SNR_RX0_ADDR                                       140
+#define WF_LWTBL_SNR_RX0_MASK \
+	0x0000003f // 5- 0
+#define WF_LWTBL_SNR_RX0_SHIFT                                      0
+#define WF_LWTBL_SNR_RX1_DW                                         35
+#define WF_LWTBL_SNR_RX1_ADDR                                       140
+#define WF_LWTBL_SNR_RX1_MASK \
+	0x00000fc0 // 11- 6
+#define WF_LWTBL_SNR_RX1_SHIFT                                      6
+#define WF_LWTBL_SNR_RX2_DW                                         35
+#define WF_LWTBL_SNR_RX2_ADDR                                       140
+#define WF_LWTBL_SNR_RX2_MASK \
+	0x0003f000 // 17-12
+#define WF_LWTBL_SNR_RX2_SHIFT                                      12
+#define WF_LWTBL_SNR_RX3_DW                                         35
+#define WF_LWTBL_SNR_RX3_ADDR                                       140
+#define WF_LWTBL_SNR_RX3_MASK \
+	0x00fc0000 // 23-18
+#define WF_LWTBL_SNR_RX3_SHIFT                                      18
+
+/* WTBL Group - Packet Number */
+/* DW 2 */
+#define WTBL_PN0_MASK                   BITS(0, 7)
+#define WTBL_PN0_OFFSET                 0
+#define WTBL_PN1_MASK                   BITS(8, 15)
+#define WTBL_PN1_OFFSET                 8
+#define WTBL_PN2_MASK                   BITS(16, 23)
+#define WTBL_PN2_OFFSET                 16
+#define WTBL_PN3_MASK                   BITS(24, 31)
+#define WTBL_PN3_OFFSET                 24
+
+/* DW 3 */
+#define WTBL_PN4_MASK                   BITS(0, 7)
+#define WTBL_PN4_OFFSET                 0
+#define WTBL_PN5_MASK                   BITS(8, 15)
+#define WTBL_PN5_OFFSET                 8
+
+/* DW 4 */
+#define WTBL_BIPN0_MASK                 BITS(0, 7)
+#define WTBL_BIPN0_OFFSET               0
+#define WTBL_BIPN1_MASK                 BITS(8, 15)
+#define WTBL_BIPN1_OFFSET               8
+#define WTBL_BIPN2_MASK                 BITS(16, 23)
+#define WTBL_BIPN2_OFFSET               16
+#define WTBL_BIPN3_MASK                 BITS(24, 31)
+#define WTBL_BIPN3_OFFSET               24
+
+/* DW 5 */
+#define WTBL_BIPN4_MASK                 BITS(0, 7)
+#define WTBL_BIPN4_OFFSET               0
+#define WTBL_BIPN5_MASK                 BITS(8, 15)
+#define WTBL_BIPN5_OFFSET               8
+
+/* UWTBL DW 6 */
+#define WTBL_AMSDU_LEN_MASK             BITS(0, 5)
+#define WTBL_AMSDU_LEN_OFFSET           0
+#define WTBL_AMSDU_NUM_MASK             BITS(6, 10)
+#define WTBL_AMSDU_NUM_OFFSET           6
+#define WTBL_AMSDU_EN_MASK              BIT(11)
+#define WTBL_AMSDU_EN_OFFSET            11
+
+/* UWTBL DW 8 */
+#define WTBL_SEC_ADDR_MODE_MASK		BITS(20, 21)
+#define WTBL_SEC_ADDR_MODE_OFFSET	20
+
+/* LWTBL Rate field */
+#define WTBL_RATE_TX_RATE_MASK          BITS(0, 5)
+#define WTBL_RATE_TX_RATE_OFFSET        0
+#define WTBL_RATE_TX_MODE_MASK          BITS(6, 9)
+#define WTBL_RATE_TX_MODE_OFFSET        6
+#define WTBL_RATE_NSTS_MASK             BITS(10, 13)
+#define WTBL_RATE_NSTS_OFFSET           10
+#define WTBL_RATE_STBC_MASK             BIT(14)
+#define WTBL_RATE_STBC_OFFSET           14
+
+/***** WTBL(LMAC) DW Offset *****/
+/* LMAC WTBL Group - Peer Unique Information */
+#define WTBL_GROUP_PEER_INFO_DW_0               0
+#define WTBL_GROUP_PEER_INFO_DW_1               1
+
+/* WTBL Group - TxRx Capability/Information */
+#define WTBL_GROUP_TRX_CAP_DW_2                 2
+#define WTBL_GROUP_TRX_CAP_DW_3                 3
+#define WTBL_GROUP_TRX_CAP_DW_4                 4
+#define WTBL_GROUP_TRX_CAP_DW_5                 5
+#define WTBL_GROUP_TRX_CAP_DW_6                 6
+#define WTBL_GROUP_TRX_CAP_DW_7                 7
+#define WTBL_GROUP_TRX_CAP_DW_8                 8
+#define WTBL_GROUP_TRX_CAP_DW_9                 9
+
+/* WTBL Group - Auto Rate Table*/
+#define WTBL_GROUP_AUTO_RATE_1_2                10
+#define WTBL_GROUP_AUTO_RATE_3_4                11
+#define WTBL_GROUP_AUTO_RATE_5_6                12
+#define WTBL_GROUP_AUTO_RATE_7_8                13
+
+/* WTBL Group - Tx Counter */
+#define WTBL_GROUP_TX_CNT_LINE_1                14
+#define WTBL_GROUP_TX_CNT_LINE_2                15
+#define WTBL_GROUP_TX_CNT_LINE_3                16
+#define WTBL_GROUP_TX_CNT_LINE_4                17
+#define WTBL_GROUP_TX_CNT_LINE_5                18
+#define WTBL_GROUP_TX_CNT_LINE_6                19
+
+/* WTBL Group - Admission Control Counter */
+#define WTBL_GROUP_ADM_CNT_LINE_1               20
+#define WTBL_GROUP_ADM_CNT_LINE_2               21
+#define WTBL_GROUP_ADM_CNT_LINE_3               22
+#define WTBL_GROUP_ADM_CNT_LINE_4               23
+#define WTBL_GROUP_ADM_CNT_LINE_5               24
+#define WTBL_GROUP_ADM_CNT_LINE_6               25
+#define WTBL_GROUP_ADM_CNT_LINE_7               26
+#define WTBL_GROUP_ADM_CNT_LINE_8               27
+
+/* WTBL Group -MLO Info */
+#define WTBL_GROUP_MLO_INFO_LINE_1              28
+#define WTBL_GROUP_MLO_INFO_LINE_2              29
+#define WTBL_GROUP_MLO_INFO_LINE_3              30
+
+/* WTBL Group -RESP Info */
+#define WTBL_GROUP_RESP_INFO_DW_31              31
+
+/* WTBL Group -RX DUP Info */
+#define WTBL_GROUP_RX_DUP_INFO_DW_32            32
+
+/* WTBL Group - Rx Statistics Counter */
+#define WTBL_GROUP_RX_STAT_CNT_LINE_1           33
+#define WTBL_GROUP_RX_STAT_CNT_LINE_2           34
+#define WTBL_GROUP_RX_STAT_CNT_LINE_3           35
+
+/* UWTBL Group - HW AMSDU */
+#define UWTBL_HW_AMSDU_DW                       WF_UWTBL_AMSDU_CFG_DW
+
+/* LWTBL DW 4 */
+#define WTBL_DIS_RHTR                           WF_LWTBL_DIS_RHTR_MASK
+
+/* UWTBL DW 5 */
+#define WTBL_KEY_LINK_DW_KEY_LOC0_MASK          BITS(0, 10)
+#define WTBL_PSM				WF_LWTBL_PSM_MASK
+
+/* Need to sync with FW define */
+#define INVALID_KEY_ENTRY                       WTBL_KEY_LINK_DW_KEY_LOC0_MASK
+
+// RATE
+#define WTBL_RATE_TX_RATE_MASK          	BITS(0, 5)
+#define WTBL_RATE_TX_RATE_OFFSET        	0
+#define WTBL_RATE_TX_MODE_MASK          	BITS(6, 9)
+#define WTBL_RATE_TX_MODE_OFFSET        	6
+#define WTBL_RATE_NSTS_MASK             	BITS(10, 13)
+#define WTBL_RATE_NSTS_OFFSET           	10
+#define WTBL_RATE_STBC_MASK            	 	BIT(14)
+#define WTBL_RATE_STBC_OFFSET          	 	14
+#endif
+
+struct bin_debug_hdr {
+	__le32 magic_num;
+	__le16 serial_id;
+	__le16 msg_type;
+	__le16 len;
+	__le16 des_len;	/* descriptor len for rxd */
+} __packed;
+
+enum umac_port {
+	ENUM_UMAC_HIF_PORT_0         = 0,
+	ENUM_UMAC_CPU_PORT_1         = 1,
+	ENUM_UMAC_LMAC_PORT_2        = 2,
+	ENUM_PLE_CTRL_PSE_PORT_3     = 3,
+	ENUM_UMAC_PSE_PLE_PORT_TOTAL_NUM = 4
+};
+
+/* N9 MCU QUEUE LIST */
+enum umac_cpu_port_queue_idx {
+	ENUM_UMAC_CTX_Q_0 = 0,
+	ENUM_UMAC_CTX_Q_1 = 1,
+	ENUM_UMAC_CTX_Q_2 = 2,
+	ENUM_UMAC_CTX_Q_3 = 3,
+	ENUM_UMAC_CRX     = 0,
+	ENUM_UMAC_CIF_QUEUE_TOTAL_NUM = 4
+};
+
+/* LMAC PLE For PSE Control P3 */
+enum umac_ple_ctrl_port3_queue_idx {
+	ENUM_UMAC_PLE_CTRL_P3_Q_0X1E            = 0x1e,
+	ENUM_UMAC_PLE_CTRL_P3_Q_0X1F            = 0x1f,
+	ENUM_UMAC_PLE_CTRL_P3_TOTAL_NUM         = 2
+};
+
+/* PSE PLE QUEUE */
+#define CR_NUM_OF_AC_MT7996	34
+#define CR_NUM_OF_AC_MT7992	17
+struct bmac_queue_info {
+	char *QueueName;
+	u32 Portid;
+	u32 Queueid;
+	u32 tgid;
+};
+
+struct bmac_queue_info_t {
+	char *QueueName;
+	u32 Portid;
+	u32 Queueid;
+};
+
+#define WF_DRR_TOP_BASE                                        0x820c8800
+#define WF_DRR_TOP_SBRR_ADDR                                   (WF_DRR_TOP_BASE + 0x00E0) // 88E0
+#define WF_DRR_TOP_TWT_STA_MAP00_ADDR                          (WF_DRR_TOP_BASE + 0x0100) // 8900
+#define WF_DRR_TOP_TWT_STA_MAP_EXT_00_ADDR                     (WF_DRR_TOP_BASE + 0x0180) // 8980
+#define WF_DRR_TOP_AC0_STATION_PAUSE00_ADDR                    (WF_DRR_TOP_BASE + 0x0200) // 8A00
+#define WF_DRR_TOP_AC0_STATION_PAUSE_EXT_00_ADDR               (WF_DRR_TOP_BASE + 0x0280) // 8A80
+#define WF_DRR_TOP_AC1_STATION_PAUSE00_ADDR                    (WF_DRR_TOP_BASE + 0x0300) // 8B00
+#define WF_DRR_TOP_AC1_STATION_PAUSE_EXT_00_ADDR               (WF_DRR_TOP_BASE + 0x0380) // 8B80
+#define WF_DRR_TOP_AC2_STATION_PAUSE00_ADDR                    (WF_DRR_TOP_BASE + 0x0400) // 8C00
+#define WF_DRR_TOP_AC2_STATION_PAUSE_EXT_00_ADDR               (WF_DRR_TOP_BASE + 0x0480) // 8C80
+#define WF_DRR_TOP_AC3_STATION_PAUSE00_ADDR                    (WF_DRR_TOP_BASE + 0x0500) // 8D00
+#define WF_DRR_TOP_AC3_STATION_PAUSE_EXT_00_ADDR               (WF_DRR_TOP_BASE + 0x0580) // 8D80
+
+#define WF_DRR_TOP_SBRR_TARGET_BAND_MASK                       0x00000003                // TARGET_BAND[1..0]
+/* PLE AMSDU */
+#define WF_PLE_TOP_BASE                                        0x820c0000
+
+#define WF_PLE_TOP_AMSDU_PACK_1_MSDU_CNT_ADDR                  (WF_PLE_TOP_BASE + 0x10e0) // 10E0
+#define WF_PLE_TOP_AMSDU_PACK_2_MSDU_CNT_ADDR                  (WF_PLE_TOP_BASE + 0x10e4) // 10E4
+#define WF_PLE_TOP_AMSDU_PACK_3_MSDU_CNT_ADDR                  (WF_PLE_TOP_BASE + 0x10e8) // 10E8
+#define WF_PLE_TOP_AMSDU_PACK_4_MSDU_CNT_ADDR                  (WF_PLE_TOP_BASE + 0x10ec) // 10EC
+#define WF_PLE_TOP_AMSDU_PACK_5_MSDU_CNT_ADDR                  (WF_PLE_TOP_BASE + 0x10f0) // 10F0
+#define WF_PLE_TOP_AMSDU_PACK_6_MSDU_CNT_ADDR                  (WF_PLE_TOP_BASE + 0x10f4) // 10F4
+#define WF_PLE_TOP_AMSDU_PACK_7_MSDU_CNT_ADDR                  (WF_PLE_TOP_BASE + 0x10f8) // 10F8
+#define WF_PLE_TOP_AMSDU_PACK_8_MSDU_CNT_ADDR                  (WF_PLE_TOP_BASE + 0x10fc) // 10FC
+#define WF_PLE_TOP_AMSDU_PACK_NUM                              8
+
+/* PLE */
+#define WF_PLE_TOP_PBUF_CTRL_ADDR                              (WF_PLE_TOP_BASE + 0x04) // 0004
+
+#define WF_PLE_TOP_PG_HIF_GROUP_ADDR                           (WF_PLE_TOP_BASE + 0x0c) // 000C
+#define WF_PLE_TOP_PG_HIF_WMTXD_GROUP_ADDR                     (WF_PLE_TOP_BASE + 0x10) // 0010
+#define WF_PLE_TOP_PG_HIF_TXCMD_GROUP_ADDR                     (WF_PLE_TOP_BASE + 0x14) // 0014
+#define WF_PLE_TOP_PG_CPU_GROUP_ADDR                           (WF_PLE_TOP_BASE + 0x18) // 0018
+#define WF_PLE_TOP_QUEUE_EMPTY_ADDR                            (WF_PLE_TOP_BASE + 0x360) // 0360
+
+#define WF_PLE_TOP_DIS_STA_MAP0_ADDR                           (WF_PLE_TOP_BASE + 0x100) // 0100
+#define WF_PLE_TOP_DIS_STA_MAP1_ADDR                           (WF_PLE_TOP_BASE + 0x104) // 0104
+#define WF_PLE_TOP_DIS_STA_MAP2_ADDR                           (WF_PLE_TOP_BASE + 0x108) // 0108
+#define WF_PLE_TOP_DIS_STA_MAP3_ADDR                           (WF_PLE_TOP_BASE + 0x10c) // 010C
+#define WF_PLE_TOP_DIS_STA_MAP4_ADDR                           (WF_PLE_TOP_BASE + 0x110) // 0110
+#define WF_PLE_TOP_DIS_STA_MAP5_ADDR                           (WF_PLE_TOP_BASE + 0x114) // 0114
+#define WF_PLE_TOP_DIS_STA_MAP6_ADDR                           (WF_PLE_TOP_BASE + 0x118) // 0118
+#define WF_PLE_TOP_DIS_STA_MAP7_ADDR                           (WF_PLE_TOP_BASE + 0x11c) // 011C
+#define WF_PLE_TOP_DIS_STA_MAP8_ADDR                           (WF_PLE_TOP_BASE + 0x120) // 0120
+
+#define WF_PLE_TOP_TXCMD_QUEUE_EMPTY_ADDR                      (WF_PLE_TOP_BASE + 0x378) // 0378
+#define WF_PLE_TOP_NATIVE_TXCMD_QUEUE_EMPTY_ADDR               (WF_PLE_TOP_BASE + 0x37c) // 037C
+#define WF_PLE_TOP_BN1_TXCMD_QUEUE_EMPTY_ADDR                  (WF_PLE_TOP_BASE + 0x388) // 0388
+#define WF_PLE_TOP_BN1_NATIVE_TXCMD_QUEUE_EMPTY_ADDR           (WF_PLE_TOP_BASE + 0x38c) // 038C
+#define WF_PLE_TOP_BN2_TXCMD_QUEUE_EMPTY_ADDR                  (WF_PLE_TOP_BASE + 0x398) // 0398
+#define WF_PLE_TOP_BN2_NATIVE_TXCMD_QUEUE_EMPTY_ADDR           (WF_PLE_TOP_BASE + 0x39c) // 039C
+
+#define WF_PLE_TOP_FREEPG_CNT_ADDR                             (WF_PLE_TOP_BASE + 0x3a0) // 03A0
+#define WF_PLE_TOP_FREEPG_HEAD_TAIL_ADDR                       (WF_PLE_TOP_BASE + 0x3a4) // 03A4
+#define WF_PLE_TOP_HIF_PG_INFO_ADDR                            (WF_PLE_TOP_BASE + 0x3a8) // 03A8
+#define WF_PLE_TOP_HIF_WMTXD_PG_INFO_ADDR                      (WF_PLE_TOP_BASE + 0x3ac) // 03AC
+#define WF_PLE_TOP_HIF_TXCMD_PG_INFO_ADDR                      (WF_PLE_TOP_BASE + 0x3b0) // 03B0
+#define WF_PLE_TOP_CPU_PG_INFO_ADDR                            (WF_PLE_TOP_BASE + 0x3b4) // 03B4
+
+#define WF_PLE_TOP_FL_QUE_CTRL_0_ADDR                          (WF_PLE_TOP_BASE + 0x3e0) // 03E0
+#define WF_PLE_TOP_FL_QUE_CTRL_1_ADDR                          (WF_PLE_TOP_BASE + 0x3e4) // 03E4
+#define WF_PLE_TOP_FL_QUE_CTRL_2_ADDR                          (WF_PLE_TOP_BASE + 0x3e8) // 03E8
+#define WF_PLE_TOP_FL_QUE_CTRL_3_ADDR                          (WF_PLE_TOP_BASE + 0x3ec) // 03EC
+
+#define WF_PLE_TOP_AC0_QUEUE_EMPTY0_ADDR                       (WF_PLE_TOP_BASE + 0x600) // 0600
+#define WF_PLE_TOP_AC0_QUEUE_EMPTY1_ADDR                       (WF_PLE_TOP_BASE + 0x604) // 0604
+#define WF_PLE_TOP_AC0_QUEUE_EMPTY2_ADDR                       (WF_PLE_TOP_BASE + 0x608) // 0608
+#define WF_PLE_TOP_AC0_QUEUE_EMPTY3_ADDR                       (WF_PLE_TOP_BASE + 0x60c) // 060C
+#define WF_PLE_TOP_AC0_QUEUE_EMPTY4_ADDR                       (WF_PLE_TOP_BASE + 0x610) // 0610
+#define WF_PLE_TOP_AC0_QUEUE_EMPTY5_ADDR                       (WF_PLE_TOP_BASE + 0x614) // 0614
+#define WF_PLE_TOP_AC0_QUEUE_EMPTY6_ADDR                       (WF_PLE_TOP_BASE + 0x618) // 0618
+#define WF_PLE_TOP_AC0_QUEUE_EMPTY7_ADDR                       (WF_PLE_TOP_BASE + 0x61c) // 061C
+#define WF_PLE_TOP_AC0_QUEUE_EMPTY8_ADDR                       (WF_PLE_TOP_BASE + 0x620) // 0620
+#define WF_PLE_TOP_AC0_QUEUE_EMPTY_EXT0_ADDR                   (WF_PLE_TOP_BASE + 0x680) // 0680
+
+#define WF_PLE_TOP_AC1_QUEUE_EMPTY0_ADDR                       (WF_PLE_TOP_BASE + 0x700) // 0700
+#define WF_PLE_TOP_AC1_QUEUE_EMPTY1_ADDR                       (WF_PLE_TOP_BASE + 0x704) // 0704
+#define WF_PLE_TOP_AC1_QUEUE_EMPTY2_ADDR                       (WF_PLE_TOP_BASE + 0x708) // 0708
+#define WF_PLE_TOP_AC1_QUEUE_EMPTY3_ADDR                       (WF_PLE_TOP_BASE + 0x70c) // 070C
+#define WF_PLE_TOP_AC1_QUEUE_EMPTY4_ADDR                       (WF_PLE_TOP_BASE + 0x710) // 0710
+#define WF_PLE_TOP_AC1_QUEUE_EMPTY5_ADDR                       (WF_PLE_TOP_BASE + 0x714) // 0714
+#define WF_PLE_TOP_AC1_QUEUE_EMPTY6_ADDR                       (WF_PLE_TOP_BASE + 0x718) // 0718
+#define WF_PLE_TOP_AC1_QUEUE_EMPTY7_ADDR                       (WF_PLE_TOP_BASE + 0x71c) // 071C
+#define WF_PLE_TOP_AC1_QUEUE_EMPTY8_ADDR                       (WF_PLE_TOP_BASE + 0x720) // 0720
+#define WF_PLE_TOP_AC1_QUEUE_EMPTY_EXT0_ADDR                   (WF_PLE_TOP_BASE + 0x780) // 0780
+
+#define WF_PLE_TOP_AC2_QUEUE_EMPTY0_ADDR                       (WF_PLE_TOP_BASE + 0x800) // 0800
+#define WF_PLE_TOP_AC2_QUEUE_EMPTY1_ADDR                       (WF_PLE_TOP_BASE + 0x804) // 0804
+#define WF_PLE_TOP_AC2_QUEUE_EMPTY2_ADDR                       (WF_PLE_TOP_BASE + 0x808) // 0808
+#define WF_PLE_TOP_AC2_QUEUE_EMPTY3_ADDR                       (WF_PLE_TOP_BASE + 0x80c) // 080C
+#define WF_PLE_TOP_AC2_QUEUE_EMPTY4_ADDR                       (WF_PLE_TOP_BASE + 0x810) // 0810
+#define WF_PLE_TOP_AC2_QUEUE_EMPTY5_ADDR                       (WF_PLE_TOP_BASE + 0x814) // 0814
+#define WF_PLE_TOP_AC2_QUEUE_EMPTY6_ADDR                       (WF_PLE_TOP_BASE + 0x818) // 0818
+#define WF_PLE_TOP_AC2_QUEUE_EMPTY7_ADDR                       (WF_PLE_TOP_BASE + 0x81c) // 081C
+#define WF_PLE_TOP_AC2_QUEUE_EMPTY8_ADDR                       (WF_PLE_TOP_BASE + 0x820) // 0820
+#define WF_PLE_TOP_AC2_QUEUE_EMPTY_EXT0_ADDR                   (WF_PLE_TOP_BASE + 0x880) // 0880
+
+#define WF_PLE_TOP_AC3_QUEUE_EMPTY0_ADDR                       (WF_PLE_TOP_BASE + 0x900) // 0900
+#define WF_PLE_TOP_AC3_QUEUE_EMPTY1_ADDR                       (WF_PLE_TOP_BASE + 0x904) // 0904
+#define WF_PLE_TOP_AC3_QUEUE_EMPTY2_ADDR                       (WF_PLE_TOP_BASE + 0x908) // 0908
+#define WF_PLE_TOP_AC3_QUEUE_EMPTY3_ADDR                       (WF_PLE_TOP_BASE + 0x90c) // 090C
+#define WF_PLE_TOP_AC3_QUEUE_EMPTY4_ADDR                       (WF_PLE_TOP_BASE + 0x910) // 0910
+#define WF_PLE_TOP_AC3_QUEUE_EMPTY5_ADDR                       (WF_PLE_TOP_BASE + 0x914) // 0914
+#define WF_PLE_TOP_AC3_QUEUE_EMPTY6_ADDR                       (WF_PLE_TOP_BASE + 0x918) // 0918
+#define WF_PLE_TOP_AC3_QUEUE_EMPTY7_ADDR                       (WF_PLE_TOP_BASE + 0x91c) // 091C
+#define WF_PLE_TOP_AC3_QUEUE_EMPTY8_ADDR                       (WF_PLE_TOP_BASE + 0x920) // 0920
+#define WF_PLE_TOP_AC3_QUEUE_EMPTY_EXT0_ADDR                   (WF_PLE_TOP_BASE + 0x980) // 0980
+
+#define WF_PLE_TOP_QUEUE_EMPTY_ALL_AC_EMPTY_ADDR               WF_PLE_TOP_QUEUE_EMPTY_ADDR
+#define WF_PLE_TOP_QUEUE_EMPTY_ALL_AC_EMPTY_MASK               0x01000000                // ALL_AC_EMPTY[24]
+#define WF_PLE_TOP_QUEUE_EMPTY_ALL_AC_EMPTY_SHFT               24
+
+#define WF_PLE_TOP_PBUF_CTRL_PAGE_SIZE_CFG_ADDR                WF_PLE_TOP_PBUF_CTRL_ADDR
+#define WF_PLE_TOP_PBUF_CTRL_PAGE_SIZE_CFG_MASK                0x80000000                // PAGE_SIZE_CFG[31]
+#define WF_PLE_TOP_PBUF_CTRL_PAGE_SIZE_CFG_SHFT                31
+#define WF_PLE_TOP_PBUF_CTRL_PBUF_OFFSET_ADDR                  WF_PLE_TOP_PBUF_CTRL_ADDR
+#define WF_PLE_TOP_PBUF_CTRL_PBUF_OFFSET_MASK                  0x07FE0000                // PBUF_OFFSET[26..17]
+#define WF_PLE_TOP_PBUF_CTRL_PBUF_OFFSET_SHFT                  17
+#define WF_PLE_TOP_PBUF_CTRL_TOTAL_PAGE_NUM_ADDR               WF_PLE_TOP_PBUF_CTRL_ADDR
+#define WF_PLE_TOP_PBUF_CTRL_TOTAL_PAGE_NUM_MASK               0x00001FFF                // TOTAL_PAGE_NUM[12..0]
+#define WF_PLE_TOP_PBUF_CTRL_TOTAL_PAGE_NUM_SHFT               0
+
+#define WF_PLE_TOP_FREEPG_CNT_FFA_CNT_ADDR                     WF_PLE_TOP_FREEPG_CNT_ADDR
+#define WF_PLE_TOP_FREEPG_CNT_FFA_CNT_MASK                     0x1FFF0000                // FFA_CNT[28..16]
+#define WF_PLE_TOP_FREEPG_CNT_FFA_CNT_SHFT                     16
+#define WF_PLE_TOP_FREEPG_CNT_FREEPG_CNT_ADDR                  WF_PLE_TOP_FREEPG_CNT_ADDR
+#define WF_PLE_TOP_FREEPG_CNT_FREEPG_CNT_MASK                  0x00001FFF                // FREEPG_CNT[12..0]
+#define WF_PLE_TOP_FREEPG_CNT_FREEPG_CNT_SHFT                  0
+
+#define WF_PLE_TOP_FREEPG_HEAD_TAIL_FREEPG_TAIL_ADDR           WF_PLE_TOP_FREEPG_HEAD_TAIL_ADDR
+#define WF_PLE_TOP_FREEPG_HEAD_TAIL_FREEPG_TAIL_MASK           0x1FFF0000                // FREEPG_TAIL[28..16]
+#define WF_PLE_TOP_FREEPG_HEAD_TAIL_FREEPG_TAIL_SHFT           16
+#define WF_PLE_TOP_FREEPG_HEAD_TAIL_FREEPG_HEAD_ADDR           WF_PLE_TOP_FREEPG_HEAD_TAIL_ADDR
+#define WF_PLE_TOP_FREEPG_HEAD_TAIL_FREEPG_HEAD_MASK           0x00001FFF                // FREEPG_HEAD[12..0]
+#define WF_PLE_TOP_FREEPG_HEAD_TAIL_FREEPG_HEAD_SHFT           0
+
+#define WF_PLE_TOP_PG_HIF_GROUP_HIF_MAX_QUOTA_ADDR             WF_PLE_TOP_PG_HIF_GROUP_ADDR
+#define WF_PLE_TOP_PG_HIF_GROUP_HIF_MAX_QUOTA_MASK             0x1FFF0000                // HIF_MAX_QUOTA[28..16]
+#define WF_PLE_TOP_PG_HIF_GROUP_HIF_MAX_QUOTA_SHFT             16
+#define WF_PLE_TOP_PG_HIF_GROUP_HIF_MIN_QUOTA_ADDR             WF_PLE_TOP_PG_HIF_GROUP_ADDR
+#define WF_PLE_TOP_PG_HIF_GROUP_HIF_MIN_QUOTA_MASK             0x00001FFF                // HIF_MIN_QUOTA[12..0]
+#define WF_PLE_TOP_PG_HIF_GROUP_HIF_MIN_QUOTA_SHFT             0
+
+#define WF_PLE_TOP_HIF_PG_INFO_HIF_SRC_CNT_ADDR                WF_PLE_TOP_HIF_PG_INFO_ADDR
+#define WF_PLE_TOP_HIF_PG_INFO_HIF_SRC_CNT_MASK                0x1FFF0000                // HIF_SRC_CNT[28..16]
+#define WF_PLE_TOP_HIF_PG_INFO_HIF_SRC_CNT_SHFT                16
+#define WF_PLE_TOP_HIF_PG_INFO_HIF_RSV_CNT_ADDR                WF_PLE_TOP_HIF_PG_INFO_ADDR
+#define WF_PLE_TOP_HIF_PG_INFO_HIF_RSV_CNT_MASK                0x00001FFF                // HIF_RSV_CNT[12..0]
+#define WF_PLE_TOP_HIF_PG_INFO_HIF_RSV_CNT_SHFT                0
+
+#define WF_PLE_TOP_PG_HIF_WMTXD_GROUP_HIF_WMTXD_MAX_QUOTA_ADDR WF_PLE_TOP_PG_HIF_WMTXD_GROUP_ADDR
+#define WF_PLE_TOP_PG_HIF_WMTXD_GROUP_HIF_WMTXD_MAX_QUOTA_MASK 0x1FFF0000                // HIF_WMTXD_MAX_QUOTA[28..16]
+#define WF_PLE_TOP_PG_HIF_WMTXD_GROUP_HIF_WMTXD_MAX_QUOTA_SHFT 16
+#define WF_PLE_TOP_PG_HIF_WMTXD_GROUP_HIF_WMTXD_MIN_QUOTA_ADDR WF_PLE_TOP_PG_HIF_WMTXD_GROUP_ADDR
+#define WF_PLE_TOP_PG_HIF_WMTXD_GROUP_HIF_WMTXD_MIN_QUOTA_MASK 0x00001FFF                // HIF_WMTXD_MIN_QUOTA[12..0]
+#define WF_PLE_TOP_PG_HIF_WMTXD_GROUP_HIF_WMTXD_MIN_QUOTA_SHFT 0
+
+#define WF_PLE_TOP_HIF_WMTXD_PG_INFO_HIF_WMTXD_SRC_CNT_ADDR    WF_PLE_TOP_HIF_WMTXD_PG_INFO_ADDR
+#define WF_PLE_TOP_HIF_WMTXD_PG_INFO_HIF_WMTXD_SRC_CNT_MASK    0x1FFF0000                // HIF_WMTXD_SRC_CNT[28..16]
+#define WF_PLE_TOP_HIF_WMTXD_PG_INFO_HIF_WMTXD_SRC_CNT_SHFT    16
+#define WF_PLE_TOP_HIF_WMTXD_PG_INFO_HIF_WMTXD_RSV_CNT_ADDR    WF_PLE_TOP_HIF_WMTXD_PG_INFO_ADDR
+#define WF_PLE_TOP_HIF_WMTXD_PG_INFO_HIF_WMTXD_RSV_CNT_MASK    0x00001FFF                // HIF_WMTXD_RSV_CNT[12..0]
+#define WF_PLE_TOP_HIF_WMTXD_PG_INFO_HIF_WMTXD_RSV_CNT_SHFT    0
+
+#define WF_PLE_TOP_PG_HIF_TXCMD_GROUP_HIF_TXCMD_MAX_QUOTA_ADDR WF_PLE_TOP_PG_HIF_TXCMD_GROUP_ADDR
+#define WF_PLE_TOP_PG_HIF_TXCMD_GROUP_HIF_TXCMD_MAX_QUOTA_MASK 0x1FFF0000                // HIF_TXCMD_MAX_QUOTA[28..16]
+#define WF_PLE_TOP_PG_HIF_TXCMD_GROUP_HIF_TXCMD_MAX_QUOTA_SHFT 16
+#define WF_PLE_TOP_PG_HIF_TXCMD_GROUP_HIF_TXCMD_MIN_QUOTA_ADDR WF_PLE_TOP_PG_HIF_TXCMD_GROUP_ADDR
+#define WF_PLE_TOP_PG_HIF_TXCMD_GROUP_HIF_TXCMD_MIN_QUOTA_MASK 0x00001FFF                // HIF_TXCMD_MIN_QUOTA[12..0]
+#define WF_PLE_TOP_PG_HIF_TXCMD_GROUP_HIF_TXCMD_MIN_QUOTA_SHFT 0
+
+#define WF_PLE_TOP_HIF_TXCMD_PG_INFO_HIF_TXCMD_SRC_CNT_ADDR    WF_PLE_TOP_HIF_TXCMD_PG_INFO_ADDR
+#define WF_PLE_TOP_HIF_TXCMD_PG_INFO_HIF_TXCMD_SRC_CNT_MASK    0x1FFF0000                // HIF_TXCMD_SRC_CNT[28..16]
+#define WF_PLE_TOP_HIF_TXCMD_PG_INFO_HIF_TXCMD_SRC_CNT_SHFT    16
+#define WF_PLE_TOP_HIF_TXCMD_PG_INFO_HIF_TXCMD_RSV_CNT_ADDR    WF_PLE_TOP_HIF_TXCMD_PG_INFO_ADDR
+#define WF_PLE_TOP_HIF_TXCMD_PG_INFO_HIF_TXCMD_RSV_CNT_MASK    0x00001FFF                // HIF_TXCMD_RSV_CNT[12..0]
+#define WF_PLE_TOP_HIF_TXCMD_PG_INFO_HIF_TXCMD_RSV_CNT_SHFT    0
+
+#define WF_PLE_TOP_PG_CPU_GROUP_CPU_MAX_QUOTA_ADDR             WF_PLE_TOP_PG_CPU_GROUP_ADDR
+#define WF_PLE_TOP_PG_CPU_GROUP_CPU_MAX_QUOTA_MASK             0x1FFF0000                // CPU_MAX_QUOTA[28..16]
+#define WF_PLE_TOP_PG_CPU_GROUP_CPU_MAX_QUOTA_SHFT             16
+#define WF_PLE_TOP_PG_CPU_GROUP_CPU_MIN_QUOTA_ADDR             WF_PLE_TOP_PG_CPU_GROUP_ADDR
+#define WF_PLE_TOP_PG_CPU_GROUP_CPU_MIN_QUOTA_MASK             0x00001FFF                // CPU_MIN_QUOTA[12..0]
+#define WF_PLE_TOP_PG_CPU_GROUP_CPU_MIN_QUOTA_SHFT             0
+
+#define WF_PLE_TOP_CPU_PG_INFO_CPU_SRC_CNT_ADDR                WF_PLE_TOP_CPU_PG_INFO_ADDR
+#define WF_PLE_TOP_CPU_PG_INFO_CPU_SRC_CNT_MASK                0x1FFF0000                // CPU_SRC_CNT[28..16]
+#define WF_PLE_TOP_CPU_PG_INFO_CPU_SRC_CNT_SHFT                16
+#define WF_PLE_TOP_CPU_PG_INFO_CPU_RSV_CNT_ADDR                WF_PLE_TOP_CPU_PG_INFO_ADDR
+#define WF_PLE_TOP_CPU_PG_INFO_CPU_RSV_CNT_MASK                0x00001FFF                // CPU_RSV_CNT[12..0]
+#define WF_PLE_TOP_CPU_PG_INFO_CPU_RSV_CNT_SHFT                0
+
+#define WF_PLE_TOP_FL_QUE_CTRL_0_EXECUTE_ADDR                  WF_PLE_TOP_FL_QUE_CTRL_0_ADDR
+#define WF_PLE_TOP_FL_QUE_CTRL_0_EXECUTE_MASK                  0x80000000                // EXECUTE[31]
+#define WF_PLE_TOP_FL_QUE_CTRL_0_EXECUTE_SHFT                  31
+#define WF_PLE_TOP_FL_QUE_CTRL_0_Q_BUF_QID_ADDR                WF_PLE_TOP_FL_QUE_CTRL_0_ADDR
+#define WF_PLE_TOP_FL_QUE_CTRL_0_Q_BUF_QID_MASK                0x7F000000                // Q_BUF_QID[30..24]
+#define WF_PLE_TOP_FL_QUE_CTRL_0_Q_BUF_QID_SHFT                24
+#define WF_PLE_TOP_FL_QUE_CTRL_0_FL_BUFFER_ADDR_ADDR           WF_PLE_TOP_FL_QUE_CTRL_0_ADDR
+#define WF_PLE_TOP_FL_QUE_CTRL_0_FL_BUFFER_ADDR_MASK           0x00FFF000                // FL_BUFFER_ADDR[23..12]
+#define WF_PLE_TOP_FL_QUE_CTRL_0_FL_BUFFER_ADDR_SHFT           12
+#define WF_PLE_TOP_FL_QUE_CTRL_0_Q_BUF_WLANID_ADDR             WF_PLE_TOP_FL_QUE_CTRL_0_ADDR
+#define WF_PLE_TOP_FL_QUE_CTRL_0_Q_BUF_WLANID_MASK             0x00000FFF                // Q_BUF_WLANID[11..0]
+#define WF_PLE_TOP_FL_QUE_CTRL_0_Q_BUF_WLANID_SHFT             0
+
+#define WF_PLE_TOP_FL_QUE_CTRL_1_Q_BUF_TGID_ADDR               WF_PLE_TOP_FL_QUE_CTRL_1_ADDR
+#define WF_PLE_TOP_FL_QUE_CTRL_1_Q_BUF_TGID_MASK               0xC0000000                // Q_BUF_TGID[31..30]
+#define WF_PLE_TOP_FL_QUE_CTRL_1_Q_BUF_TGID_SHFT               30
+#define WF_PLE_TOP_FL_QUE_CTRL_1_Q_BUF_PID_ADDR                WF_PLE_TOP_FL_QUE_CTRL_1_ADDR
+#define WF_PLE_TOP_FL_QUE_CTRL_1_Q_BUF_PID_MASK                0x30000000                // Q_BUF_PID[29..28]
+#define WF_PLE_TOP_FL_QUE_CTRL_1_Q_BUF_PID_SHFT                28
+
+#define WF_PLE_TOP_FL_QUE_CTRL_2_QUEUE_TAIL_FID_ADDR           WF_PLE_TOP_FL_QUE_CTRL_2_ADDR
+#define WF_PLE_TOP_FL_QUE_CTRL_2_QUEUE_TAIL_FID_MASK           0x1FFF0000                // QUEUE_TAIL_FID[28..16]
+#define WF_PLE_TOP_FL_QUE_CTRL_2_QUEUE_TAIL_FID_SHFT           16
+#define WF_PLE_TOP_FL_QUE_CTRL_2_QUEUE_HEAD_FID_ADDR           WF_PLE_TOP_FL_QUE_CTRL_2_ADDR
+#define WF_PLE_TOP_FL_QUE_CTRL_2_QUEUE_HEAD_FID_MASK           0x00001FFF                // QUEUE_HEAD_FID[12..0]
+#define WF_PLE_TOP_FL_QUE_CTRL_2_QUEUE_HEAD_FID_SHFT           0
+
+#define WF_PLE_TOP_FL_QUE_CTRL_3_QUEUE_PKT_NUM_ADDR            WF_PLE_TOP_FL_QUE_CTRL_3_ADDR
+#define WF_PLE_TOP_FL_QUE_CTRL_3_QUEUE_PKT_NUM_MASK            0x00001FFF                // QUEUE_PKT_NUM[12..0]
+#define WF_PLE_TOP_FL_QUE_CTRL_3_QUEUE_PKT_NUM_SHFT            0
+
+#define WF_PLE_TOP_FL_QUE_CTRL_0_Q_BUF_TGID_ADDR               WF_PLE_TOP_FL_QUE_CTRL_0_ADDR
+#define WF_PLE_TOP_FL_QUE_CTRL_0_Q_BUF_TGID_MASK               0x00300000                // Q_BUF_TGID[21..20]
+#define WF_PLE_TOP_FL_QUE_CTRL_0_Q_BUF_TGID_SHFT               20
+#define WF_PLE_TOP_FL_QUE_CTRL_0_Q_BUF_PID_ADDR                WF_PLE_TOP_FL_QUE_CTRL_0_ADDR
+#define WF_PLE_TOP_FL_QUE_CTRL_0_Q_BUF_PID_MASK                0x00030000                // Q_BUF_PID[17..16]
+#define WF_PLE_TOP_FL_QUE_CTRL_0_Q_BUF_PID_SHFT                16
+/* PSE */
+#define WF_PSE_TOP_BASE                                        0x820c8000
+
+#define WF_PSE_TOP_PBUF_CTRL_ADDR                              (WF_PSE_TOP_BASE + 0x04) // 8004
+#define WF_PSE_TOP_QUEUE_EMPTY_ADDR                            (WF_PSE_TOP_BASE + 0xB0) // 80B0
+#define WF_PSE_TOP_QUEUE_EMPTY_1_ADDR                          (WF_PSE_TOP_BASE + 0xBC) // 80BC
+#define WF_PSE_TOP_PG_HIF0_GROUP_ADDR                          (WF_PSE_TOP_BASE + 0x110) // 8110
+#define WF_PSE_TOP_PG_HIF1_GROUP_ADDR                          (WF_PSE_TOP_BASE + 0x114) // 8114
+#define WF_PSE_TOP_PG_CPU_GROUP_ADDR                           (WF_PSE_TOP_BASE + 0x118) // 8118
+#define WF_PSE_TOP_PG_PLE_GROUP_ADDR                           (WF_PSE_TOP_BASE + 0x11C) // 811C
+#define WF_PSE_TOP_PG_PLE1_GROUP_ADDR                          (WF_PSE_TOP_BASE + 0x120) // 8120
+#define WF_PSE_TOP_PG_LMAC0_GROUP_ADDR                         (WF_PSE_TOP_BASE + 0x124) // 8124
+#define WF_PSE_TOP_PG_LMAC1_GROUP_ADDR                         (WF_PSE_TOP_BASE + 0x128) // 8128
+#define WF_PSE_TOP_PG_LMAC2_GROUP_ADDR                         (WF_PSE_TOP_BASE + 0x12C) // 812C
+#define WF_PSE_TOP_PG_LMAC3_GROUP_ADDR                         (WF_PSE_TOP_BASE + 0x130) // 8130
+#define WF_PSE_TOP_PG_MDP_GROUP_ADDR                           (WF_PSE_TOP_BASE + 0x134) // 8134
+#define WF_PSE_TOP_PG_MDP2_GROUP_ADDR                          (WF_PSE_TOP_BASE + 0x13C) // 813C
+#define WF_PSE_TOP_PG_HIF2_GROUP_ADDR                          (WF_PSE_TOP_BASE + 0x140) // 8140
+#define WF_PSE_TOP_PG_MDP3_GROUP_ADDR                          (WF_PSE_TOP_BASE + 0x144) // 8144
+#define WF_PSE_TOP_HIF0_PG_INFO_ADDR                           (WF_PSE_TOP_BASE + 0x150) // 8150
+#define WF_PSE_TOP_HIF1_PG_INFO_ADDR                           (WF_PSE_TOP_BASE + 0x154) // 8154
+#define WF_PSE_TOP_CPU_PG_INFO_ADDR                            (WF_PSE_TOP_BASE + 0x158) // 8158
+#define WF_PSE_TOP_PLE_PG_INFO_ADDR                            (WF_PSE_TOP_BASE + 0x15C) // 815C
+#define WF_PSE_TOP_PLE1_PG_INFO_ADDR                           (WF_PSE_TOP_BASE + 0x160) // 8160
+#define WF_PSE_TOP_LMAC0_PG_INFO_ADDR                          (WF_PSE_TOP_BASE + 0x164) // 8164
+#define WF_PSE_TOP_LMAC1_PG_INFO_ADDR                          (WF_PSE_TOP_BASE + 0x168) // 8168
+#define WF_PSE_TOP_LMAC2_PG_INFO_ADDR                          (WF_PSE_TOP_BASE + 0x16C) // 816C
+#define WF_PSE_TOP_LMAC3_PG_INFO_ADDR                          (WF_PSE_TOP_BASE + 0x170) // 8170
+#define WF_PSE_TOP_MDP_PG_INFO_ADDR                            (WF_PSE_TOP_BASE + 0x174) // 8174
+#define WF_PSE_TOP_MDP2_PG_INFO_ADDR                           (WF_PSE_TOP_BASE + 0x17C) // 817C
+#define WF_PSE_TOP_HIF2_PG_INFO_ADDR                           (WF_PSE_TOP_BASE + 0x180) // 8180
+#define WF_PSE_TOP_MDP3_PG_INFO_ADDR                           (WF_PSE_TOP_BASE + 0x184) // 8184
+#define WF_PSE_TOP_FL_QUE_CTRL_0_ADDR                          (WF_PSE_TOP_BASE + 0x1B0) // 81B0
+#define WF_PSE_TOP_FL_QUE_CTRL_1_ADDR                          (WF_PSE_TOP_BASE + 0x1B4) // 81B4
+#define WF_PSE_TOP_FL_QUE_CTRL_2_ADDR                          (WF_PSE_TOP_BASE + 0x1B8) // 81B8
+#define WF_PSE_TOP_FL_QUE_CTRL_3_ADDR                          (WF_PSE_TOP_BASE + 0x1BC) // 81BC
+#define WF_PSE_TOP_FREEPG_CNT_ADDR                             (WF_PSE_TOP_BASE + 0x3A0) // 83A0
+#define WF_PSE_TOP_FREEPG_HEAD_TAIL_ADDR                       (WF_PSE_TOP_BASE + 0x3A4) // 83A4
+
+#define WF_PSE_TOP_PBUF_CTRL_PAGE_SIZE_CFG_ADDR                WF_PSE_TOP_PBUF_CTRL_ADDR
+#define WF_PSE_TOP_PBUF_CTRL_PAGE_SIZE_CFG_MASK                0x80000000                // PAGE_SIZE_CFG[31]
+#define WF_PSE_TOP_PBUF_CTRL_PAGE_SIZE_CFG_SHFT                31
+#define WF_PSE_TOP_PBUF_CTRL_PBUF_OFFSET_ADDR                  WF_PSE_TOP_PBUF_CTRL_ADDR
+#define WF_PSE_TOP_PBUF_CTRL_PBUF_OFFSET_MASK                  0x07FE0000                // PBUF_OFFSET[26..17]
+#define WF_PSE_TOP_PBUF_CTRL_PBUF_OFFSET_SHFT                  17
+#define WF_PSE_TOP_PBUF_CTRL_TOTAL_PAGE_NUM_ADDR               WF_PSE_TOP_PBUF_CTRL_ADDR
+#define WF_PSE_TOP_PBUF_CTRL_TOTAL_PAGE_NUM_MASK               0x00001FFF                // TOTAL_PAGE_NUM[12..0]
+#define WF_PSE_TOP_PBUF_CTRL_TOTAL_PAGE_NUM_SHFT               0
+
+#define WF_PSE_TOP_QUEUE_EMPTY_RLS_Q_EMTPY_ADDR                WF_PSE_TOP_QUEUE_EMPTY_ADDR
+#define WF_PSE_TOP_QUEUE_EMPTY_RLS_Q_EMTPY_MASK                0x80000000                // RLS_Q_EMTPY[31]
+#define WF_PSE_TOP_QUEUE_EMPTY_RLS_Q_EMTPY_SHFT                31
+#define WF_PSE_TOP_QUEUE_EMPTY_CPU_Q4_EMPTY_ADDR               WF_PSE_TOP_QUEUE_EMPTY_ADDR
+#define WF_PSE_TOP_QUEUE_EMPTY_CPU_Q4_EMPTY_MASK               0x10000000                // CPU_Q4_EMPTY[28]
+#define WF_PSE_TOP_QUEUE_EMPTY_CPU_Q4_EMPTY_SHFT               28
+#define WF_PSE_TOP_QUEUE_EMPTY_MDP_RXIOC1_QUEUE_EMPTY_ADDR     WF_PSE_TOP_QUEUE_EMPTY_ADDR
+#define WF_PSE_TOP_QUEUE_EMPTY_MDP_RXIOC1_QUEUE_EMPTY_MASK     0x08000000                // MDP_RXIOC1_QUEUE_EMPTY[27]
+#define WF_PSE_TOP_QUEUE_EMPTY_MDP_RXIOC1_QUEUE_EMPTY_SHFT     27
+#define WF_PSE_TOP_QUEUE_EMPTY_MDP_TXIOC1_QUEUE_EMPTY_ADDR     WF_PSE_TOP_QUEUE_EMPTY_ADDR
+#define WF_PSE_TOP_QUEUE_EMPTY_MDP_TXIOC1_QUEUE_EMPTY_MASK     0x04000000                // MDP_TXIOC1_QUEUE_EMPTY[26]
+#define WF_PSE_TOP_QUEUE_EMPTY_MDP_TXIOC1_QUEUE_EMPTY_SHFT     26
+#define WF_PSE_TOP_QUEUE_EMPTY_SEC_TX1_QUEUE_EMPTY_ADDR        WF_PSE_TOP_QUEUE_EMPTY_ADDR
+#define WF_PSE_TOP_QUEUE_EMPTY_SEC_TX1_QUEUE_EMPTY_MASK        0x02000000                // SEC_TX1_QUEUE_EMPTY[25]
+#define WF_PSE_TOP_QUEUE_EMPTY_SEC_TX1_QUEUE_EMPTY_SHFT        25
+#define WF_PSE_TOP_QUEUE_EMPTY_MDP_TX1_QUEUE_EMPTY_ADDR        WF_PSE_TOP_QUEUE_EMPTY_ADDR
+#define WF_PSE_TOP_QUEUE_EMPTY_MDP_TX1_QUEUE_EMPTY_MASK        0x01000000                // MDP_TX1_QUEUE_EMPTY[24]
+#define WF_PSE_TOP_QUEUE_EMPTY_MDP_TX1_QUEUE_EMPTY_SHFT        24
+#define WF_PSE_TOP_QUEUE_EMPTY_MDP_RXIOC_QUEUE_EMPTY_ADDR      WF_PSE_TOP_QUEUE_EMPTY_ADDR
+#define WF_PSE_TOP_QUEUE_EMPTY_MDP_RXIOC_QUEUE_EMPTY_MASK      0x00800000                // MDP_RXIOC_QUEUE_EMPTY[23]
+#define WF_PSE_TOP_QUEUE_EMPTY_MDP_RXIOC_QUEUE_EMPTY_SHFT      23
+#define WF_PSE_TOP_QUEUE_EMPTY_MDP_TXIOC_QUEUE_EMPTY_ADDR      WF_PSE_TOP_QUEUE_EMPTY_ADDR
+#define WF_PSE_TOP_QUEUE_EMPTY_MDP_TXIOC_QUEUE_EMPTY_MASK      0x00400000                // MDP_TXIOC_QUEUE_EMPTY[22]
+#define WF_PSE_TOP_QUEUE_EMPTY_MDP_TXIOC_QUEUE_EMPTY_SHFT      22
+#define WF_PSE_TOP_QUEUE_EMPTY_SFD_PARK_QUEUE_EMPTY_ADDR       WF_PSE_TOP_QUEUE_EMPTY_ADDR
+#define WF_PSE_TOP_QUEUE_EMPTY_SFD_PARK_QUEUE_EMPTY_MASK       0x00200000                // SFD_PARK_QUEUE_EMPTY[21]
+#define WF_PSE_TOP_QUEUE_EMPTY_SFD_PARK_QUEUE_EMPTY_SHFT       21
+#define WF_PSE_TOP_QUEUE_EMPTY_SEC_RX_QUEUE_EMPTY_ADDR         WF_PSE_TOP_QUEUE_EMPTY_ADDR
+#define WF_PSE_TOP_QUEUE_EMPTY_SEC_RX_QUEUE_EMPTY_MASK         0x00100000                // SEC_RX_QUEUE_EMPTY[20]
+#define WF_PSE_TOP_QUEUE_EMPTY_SEC_RX_QUEUE_EMPTY_SHFT         20
+#define WF_PSE_TOP_QUEUE_EMPTY_SEC_TX_QUEUE_EMPTY_ADDR         WF_PSE_TOP_QUEUE_EMPTY_ADDR
+#define WF_PSE_TOP_QUEUE_EMPTY_SEC_TX_QUEUE_EMPTY_MASK         0x00080000                // SEC_TX_QUEUE_EMPTY[19]
+#define WF_PSE_TOP_QUEUE_EMPTY_SEC_TX_QUEUE_EMPTY_SHFT         19
+#define WF_PSE_TOP_QUEUE_EMPTY_MDP_RX_QUEUE_EMPTY_ADDR         WF_PSE_TOP_QUEUE_EMPTY_ADDR
+#define WF_PSE_TOP_QUEUE_EMPTY_MDP_RX_QUEUE_EMPTY_MASK         0x00040000                // MDP_RX_QUEUE_EMPTY[18]
+#define WF_PSE_TOP_QUEUE_EMPTY_MDP_RX_QUEUE_EMPTY_SHFT         18
+#define WF_PSE_TOP_QUEUE_EMPTY_MDP_TX_QUEUE_EMPTY_ADDR         WF_PSE_TOP_QUEUE_EMPTY_ADDR
+#define WF_PSE_TOP_QUEUE_EMPTY_MDP_TX_QUEUE_EMPTY_MASK         0x00020000                // MDP_TX_QUEUE_EMPTY[17]
+#define WF_PSE_TOP_QUEUE_EMPTY_MDP_TX_QUEUE_EMPTY_SHFT         17
+#define WF_PSE_TOP_QUEUE_EMPTY_LMAC_TX_QUEUE_EMPTY_ADDR        WF_PSE_TOP_QUEUE_EMPTY_ADDR
+#define WF_PSE_TOP_QUEUE_EMPTY_LMAC_TX_QUEUE_EMPTY_MASK        0x00010000                // LMAC_TX_QUEUE_EMPTY[16]
+#define WF_PSE_TOP_QUEUE_EMPTY_LMAC_TX_QUEUE_EMPTY_SHFT        16
+
+#define WF_PSE_TOP_QUEUE_EMPTY_CPU_Q3_EMPTY_ADDR               WF_PSE_TOP_QUEUE_EMPTY_ADDR
+#define WF_PSE_TOP_QUEUE_EMPTY_CPU_Q3_EMPTY_MASK               0x00000008                // CPU_Q3_EMPTY[3]
+#define WF_PSE_TOP_QUEUE_EMPTY_CPU_Q3_EMPTY_SHFT               3
+#define WF_PSE_TOP_QUEUE_EMPTY_CPU_Q2_EMPTY_ADDR               WF_PSE_TOP_QUEUE_EMPTY_ADDR
+#define WF_PSE_TOP_QUEUE_EMPTY_CPU_Q2_EMPTY_MASK               0x00000004                // CPU_Q2_EMPTY[2]
+#define WF_PSE_TOP_QUEUE_EMPTY_CPU_Q2_EMPTY_SHFT               2
+#define WF_PSE_TOP_QUEUE_EMPTY_CPU_Q1_EMPTY_ADDR               WF_PSE_TOP_QUEUE_EMPTY_ADDR
+#define WF_PSE_TOP_QUEUE_EMPTY_CPU_Q1_EMPTY_MASK               0x00000002                // CPU_Q1_EMPTY[1]
+#define WF_PSE_TOP_QUEUE_EMPTY_CPU_Q1_EMPTY_SHFT               1
+#define WF_PSE_TOP_QUEUE_EMPTY_CPU_Q0_EMPTY_ADDR               WF_PSE_TOP_QUEUE_EMPTY_ADDR
+#define WF_PSE_TOP_QUEUE_EMPTY_CPU_Q0_EMPTY_MASK               0x00000001                // CPU_Q0_EMPTY[0]
+#define WF_PSE_TOP_QUEUE_EMPTY_CPU_Q0_EMPTY_SHFT               0
+
+#define WF_PSE_TOP_QUEUE_EMPTY_1_HIF_13_EMPTY_ADDR             WF_PSE_TOP_QUEUE_EMPTY_1_ADDR
+#define WF_PSE_TOP_QUEUE_EMPTY_1_HIF_13_EMPTY_MASK             0x20000000                // HIF_13_EMPTY[29]
+#define WF_PSE_TOP_QUEUE_EMPTY_1_HIF_13_EMPTY_SHFT             29
+#define WF_PSE_TOP_QUEUE_EMPTY_1_HIF_12_EMPTY_ADDR             WF_PSE_TOP_QUEUE_EMPTY_1_ADDR
+#define WF_PSE_TOP_QUEUE_EMPTY_1_HIF_12_EMPTY_MASK             0x10000000                // HIF_12_EMPTY[28]
+#define WF_PSE_TOP_QUEUE_EMPTY_1_HIF_12_EMPTY_SHFT             28
+#define WF_PSE_TOP_QUEUE_EMPTY_1_HIF_11_EMPTY_ADDR             WF_PSE_TOP_QUEUE_EMPTY_1_ADDR
+#define WF_PSE_TOP_QUEUE_EMPTY_1_HIF_11_EMPTY_MASK             0x08000000                // HIF_11_EMPTY[27]
+#define WF_PSE_TOP_QUEUE_EMPTY_1_HIF_11_EMPTY_SHFT             27
+#define WF_PSE_TOP_QUEUE_EMPTY_1_HIF_10_EMPTY_ADDR             WF_PSE_TOP_QUEUE_EMPTY_1_ADDR
+#define WF_PSE_TOP_QUEUE_EMPTY_1_HIF_10_EMPTY_MASK             0x04000000                // HIF_10_EMPTY[26]
+#define WF_PSE_TOP_QUEUE_EMPTY_1_HIF_10_EMPTY_SHFT             26
+#define WF_PSE_TOP_QUEUE_EMPTY_1_HIF_9_EMPTY_ADDR              WF_PSE_TOP_QUEUE_EMPTY_1_ADDR
+#define WF_PSE_TOP_QUEUE_EMPTY_1_HIF_9_EMPTY_MASK              0x02000000                // HIF_9_EMPTY[25]
+#define WF_PSE_TOP_QUEUE_EMPTY_1_HIF_9_EMPTY_SHFT              25
+#define WF_PSE_TOP_QUEUE_EMPTY_1_HIF_8_EMPTY_ADDR              WF_PSE_TOP_QUEUE_EMPTY_1_ADDR
+#define WF_PSE_TOP_QUEUE_EMPTY_1_HIF_8_EMPTY_MASK              0x01000000                // HIF_8_EMPTY[24]
+#define WF_PSE_TOP_QUEUE_EMPTY_1_HIF_8_EMPTY_SHFT              24
+#define WF_PSE_TOP_QUEUE_EMPTY_1_HIF_7_EMPTY_ADDR              WF_PSE_TOP_QUEUE_EMPTY_1_ADDR
+#define WF_PSE_TOP_QUEUE_EMPTY_1_HIF_7_EMPTY_MASK              0x00800000                // HIF_7_EMPTY[23]
+#define WF_PSE_TOP_QUEUE_EMPTY_1_HIF_7_EMPTY_SHFT              23
+#define WF_PSE_TOP_QUEUE_EMPTY_1_HIF_6_EMPTY_ADDR              WF_PSE_TOP_QUEUE_EMPTY_1_ADDR
+#define WF_PSE_TOP_QUEUE_EMPTY_1_HIF_6_EMPTY_MASK              0x00400000                // HIF_6_EMPTY[22]
+#define WF_PSE_TOP_QUEUE_EMPTY_1_HIF_6_EMPTY_SHFT              22
+#define WF_PSE_TOP_QUEUE_EMPTY_1_HIF_5_EMPTY_ADDR              WF_PSE_TOP_QUEUE_EMPTY_1_ADDR
+#define WF_PSE_TOP_QUEUE_EMPTY_1_HIF_5_EMPTY_MASK              0x00200000                // HIF_5_EMPTY[21]
+#define WF_PSE_TOP_QUEUE_EMPTY_1_HIF_5_EMPTY_SHFT              21
+#define WF_PSE_TOP_QUEUE_EMPTY_1_HIF_4_EMPTY_ADDR              WF_PSE_TOP_QUEUE_EMPTY_1_ADDR
+#define WF_PSE_TOP_QUEUE_EMPTY_1_HIF_4_EMPTY_MASK              0x00100000                // HIF_4_EMPTY[20]
+#define WF_PSE_TOP_QUEUE_EMPTY_1_HIF_4_EMPTY_SHFT              20
+#define WF_PSE_TOP_QUEUE_EMPTY_1_HIF_3_EMPTY_ADDR              WF_PSE_TOP_QUEUE_EMPTY_1_ADDR
+#define WF_PSE_TOP_QUEUE_EMPTY_1_HIF_3_EMPTY_MASK              0x00080000                // HIF_3_EMPTY[19]
+#define WF_PSE_TOP_QUEUE_EMPTY_1_HIF_3_EMPTY_SHFT              19
+#define WF_PSE_TOP_QUEUE_EMPTY_1_HIF_2_EMPTY_ADDR              WF_PSE_TOP_QUEUE_EMPTY_1_ADDR
+#define WF_PSE_TOP_QUEUE_EMPTY_1_HIF_2_EMPTY_MASK              0x00040000                // HIF_2_EMPTY[18]
+#define WF_PSE_TOP_QUEUE_EMPTY_1_HIF_2_EMPTY_SHFT              18
+#define WF_PSE_TOP_QUEUE_EMPTY_1_HIF_1_EMPTY_ADDR              WF_PSE_TOP_QUEUE_EMPTY_1_ADDR
+#define WF_PSE_TOP_QUEUE_EMPTY_1_HIF_1_EMPTY_MASK              0x00020000                // HIF_1_EMPTY[17]
+#define WF_PSE_TOP_QUEUE_EMPTY_1_HIF_1_EMPTY_SHFT              17
+#define WF_PSE_TOP_QUEUE_EMPTY_1_HIF_0_EMPTY_ADDR              WF_PSE_TOP_QUEUE_EMPTY_1_ADDR
+#define WF_PSE_TOP_QUEUE_EMPTY_1_HIF_0_EMPTY_MASK              0x00010000                // HIF_0_EMPTY[16]
+#define WF_PSE_TOP_QUEUE_EMPTY_1_HIF_0_EMPTY_SHFT              16
+#define WF_PSE_TOP_QUEUE_EMPTY_1_MDP_RXIOC3_QUEUE_EMPTY_ADDR   WF_PSE_TOP_QUEUE_EMPTY_1_ADDR
+#define WF_PSE_TOP_QUEUE_EMPTY_1_MDP_RXIOC3_QUEUE_EMPTY_MASK   0x00008000                // MDP_RXIOC3_QUEUE_EMPTY[15]
+#define WF_PSE_TOP_QUEUE_EMPTY_1_MDP_RXIOC3_QUEUE_EMPTY_SHFT   15
+#define WF_PSE_TOP_QUEUE_EMPTY_1_MDP_RXIOC2_QUEUE_EMPTY_ADDR   WF_PSE_TOP_QUEUE_EMPTY_1_ADDR
+#define WF_PSE_TOP_QUEUE_EMPTY_1_MDP_RXIOC2_QUEUE_EMPTY_MASK   0x00000800                // MDP_RXIOC2_QUEUE_EMPTY[11]
+#define WF_PSE_TOP_QUEUE_EMPTY_1_MDP_RXIOC2_QUEUE_EMPTY_SHFT   11
+#define WF_PSE_TOP_QUEUE_EMPTY_1_MDP_TXIOC2_QUEUE_EMPTY_ADDR   WF_PSE_TOP_QUEUE_EMPTY_1_ADDR
+#define WF_PSE_TOP_QUEUE_EMPTY_1_MDP_TXIOC2_QUEUE_EMPTY_MASK   0x00000400                // MDP_TXIOC2_QUEUE_EMPTY[10]
+#define WF_PSE_TOP_QUEUE_EMPTY_1_MDP_TXIOC2_QUEUE_EMPTY_SHFT   10
+#define WF_PSE_TOP_QUEUE_EMPTY_1_SEC_TX2_QUEUE_EMPTY_ADDR      WF_PSE_TOP_QUEUE_EMPTY_1_ADDR
+#define WF_PSE_TOP_QUEUE_EMPTY_1_SEC_TX2_QUEUE_EMPTY_MASK      0x00000200                // SEC_TX2_QUEUE_EMPTY[9]
+#define WF_PSE_TOP_QUEUE_EMPTY_1_SEC_TX2_QUEUE_EMPTY_SHFT      9
+#define WF_PSE_TOP_QUEUE_EMPTY_1_MDP_TX2_QUEUE_EMPTY_ADDR      WF_PSE_TOP_QUEUE_EMPTY_1_ADDR
+#define WF_PSE_TOP_QUEUE_EMPTY_1_MDP_TX2_QUEUE_EMPTY_MASK      0x00000100                // MDP_TX2_QUEUE_EMPTY[8]
+#define WF_PSE_TOP_QUEUE_EMPTY_1_MDP_TX2_QUEUE_EMPTY_SHFT      8
+
+#define WF_PSE_TOP_PG_HIF0_GROUP_HIF0_MAX_QUOTA_ADDR           WF_PSE_TOP_PG_HIF0_GROUP_ADDR
+#define WF_PSE_TOP_PG_HIF0_GROUP_HIF0_MAX_QUOTA_MASK           0x1FFF0000                // HIF0_MAX_QUOTA[28..16]
+#define WF_PSE_TOP_PG_HIF0_GROUP_HIF0_MAX_QUOTA_SHFT           16
+#define WF_PSE_TOP_PG_HIF0_GROUP_HIF0_MIN_QUOTA_ADDR           WF_PSE_TOP_PG_HIF0_GROUP_ADDR
+#define WF_PSE_TOP_PG_HIF0_GROUP_HIF0_MIN_QUOTA_MASK           0x00001FFF                // HIF0_MIN_QUOTA[12..0]
+#define WF_PSE_TOP_PG_HIF0_GROUP_HIF0_MIN_QUOTA_SHFT           0
+
+
+#define WF_PSE_TOP_PG_HIF1_GROUP_HIF1_MAX_QUOTA_ADDR           WF_PSE_TOP_PG_HIF1_GROUP_ADDR
+#define WF_PSE_TOP_PG_HIF1_GROUP_HIF1_MAX_QUOTA_MASK           0x1FFF0000                // HIF1_MAX_QUOTA[28..16]
+#define WF_PSE_TOP_PG_HIF1_GROUP_HIF1_MAX_QUOTA_SHFT           16
+#define WF_PSE_TOP_PG_HIF1_GROUP_HIF1_MIN_QUOTA_ADDR           WF_PSE_TOP_PG_HIF1_GROUP_ADDR
+#define WF_PSE_TOP_PG_HIF1_GROUP_HIF1_MIN_QUOTA_MASK           0x00001FFF                // HIF1_MIN_QUOTA[12..0]
+#define WF_PSE_TOP_PG_HIF1_GROUP_HIF1_MIN_QUOTA_SHFT           0
+
+#define WF_PSE_TOP_PG_CPU_GROUP_CPU_MAX_QUOTA_ADDR             WF_PSE_TOP_PG_CPU_GROUP_ADDR
+#define WF_PSE_TOP_PG_CPU_GROUP_CPU_MAX_QUOTA_MASK             0x1FFF0000                // CPU_MAX_QUOTA[28..16]
+#define WF_PSE_TOP_PG_CPU_GROUP_CPU_MAX_QUOTA_SHFT             16
+#define WF_PSE_TOP_PG_CPU_GROUP_CPU_MIN_QUOTA_ADDR             WF_PSE_TOP_PG_CPU_GROUP_ADDR
+#define WF_PSE_TOP_PG_CPU_GROUP_CPU_MIN_QUOTA_MASK             0x00001FFF                // CPU_MIN_QUOTA[12..0]
+#define WF_PSE_TOP_PG_CPU_GROUP_CPU_MIN_QUOTA_SHFT             0
+
+#define WF_PSE_TOP_PG_PLE_GROUP_PLE_MAX_QUOTA_ADDR             WF_PSE_TOP_PG_PLE_GROUP_ADDR
+#define WF_PSE_TOP_PG_PLE_GROUP_PLE_MAX_QUOTA_MASK             0x1FFF0000                // PLE_MAX_QUOTA[28..16]
+#define WF_PSE_TOP_PG_PLE_GROUP_PLE_MAX_QUOTA_SHFT             16
+#define WF_PSE_TOP_PG_PLE_GROUP_PLE_MIN_QUOTA_ADDR             WF_PSE_TOP_PG_PLE_GROUP_ADDR
+#define WF_PSE_TOP_PG_PLE_GROUP_PLE_MIN_QUOTA_MASK             0x00001FFF                // PLE_MIN_QUOTA[12..0]
+#define WF_PSE_TOP_PG_PLE_GROUP_PLE_MIN_QUOTA_SHFT             0
+
+#define WF_PSE_TOP_PG_LMAC0_GROUP_LMAC0_MAX_QUOTA_ADDR         WF_PSE_TOP_PG_LMAC0_GROUP_ADDR
+#define WF_PSE_TOP_PG_LMAC0_GROUP_LMAC0_MAX_QUOTA_MASK         0x1FFF0000                // LMAC0_MAX_QUOTA[28..16]
+#define WF_PSE_TOP_PG_LMAC0_GROUP_LMAC0_MAX_QUOTA_SHFT         16
+#define WF_PSE_TOP_PG_LMAC0_GROUP_LMAC0_MIN_QUOTA_ADDR         WF_PSE_TOP_PG_LMAC0_GROUP_ADDR
+#define WF_PSE_TOP_PG_LMAC0_GROUP_LMAC0_MIN_QUOTA_MASK         0x00001FFF                // LMAC0_MIN_QUOTA[12..0]
+#define WF_PSE_TOP_PG_LMAC0_GROUP_LMAC0_MIN_QUOTA_SHFT         0
+
+#define WF_PSE_TOP_PG_LMAC1_GROUP_LMAC1_MAX_QUOTA_ADDR         WF_PSE_TOP_PG_LMAC1_GROUP_ADDR
+#define WF_PSE_TOP_PG_LMAC1_GROUP_LMAC1_MAX_QUOTA_MASK         0x1FFF0000                // LMAC1_MAX_QUOTA[28..16]
+#define WF_PSE_TOP_PG_LMAC1_GROUP_LMAC1_MAX_QUOTA_SHFT         16
+#define WF_PSE_TOP_PG_LMAC1_GROUP_LMAC1_MIN_QUOTA_ADDR         WF_PSE_TOP_PG_LMAC1_GROUP_ADDR
+#define WF_PSE_TOP_PG_LMAC1_GROUP_LMAC1_MIN_QUOTA_MASK         0x00001FFF                // LMAC1_MIN_QUOTA[12..0]
+#define WF_PSE_TOP_PG_LMAC1_GROUP_LMAC1_MIN_QUOTA_SHFT         0
+
+#define WF_PSE_TOP_PG_LMAC2_GROUP_LMAC2_MAX_QUOTA_ADDR         WF_PSE_TOP_PG_LMAC2_GROUP_ADDR
+#define WF_PSE_TOP_PG_LMAC2_GROUP_LMAC2_MAX_QUOTA_MASK         0x1FFF0000                // LMAC2_MAX_QUOTA[28..16]
+#define WF_PSE_TOP_PG_LMAC2_GROUP_LMAC2_MAX_QUOTA_SHFT         16
+#define WF_PSE_TOP_PG_LMAC2_GROUP_LMAC2_MIN_QUOTA_ADDR         WF_PSE_TOP_PG_LMAC2_GROUP_ADDR
+#define WF_PSE_TOP_PG_LMAC2_GROUP_LMAC2_MIN_QUOTA_MASK         0x00001FFF                // LMAC2_MIN_QUOTA[12..0]
+#define WF_PSE_TOP_PG_LMAC2_GROUP_LMAC2_MIN_QUOTA_SHFT         0
+
+#define WF_PSE_TOP_PG_LMAC3_GROUP_LMAC3_MAX_QUOTA_ADDR         WF_PSE_TOP_PG_LMAC3_GROUP_ADDR
+#define WF_PSE_TOP_PG_LMAC3_GROUP_LMAC3_MAX_QUOTA_MASK         0x1FFF0000                // LMAC3_MAX_QUOTA[28..16]
+#define WF_PSE_TOP_PG_LMAC3_GROUP_LMAC3_MAX_QUOTA_SHFT         16
+#define WF_PSE_TOP_PG_LMAC3_GROUP_LMAC3_MIN_QUOTA_ADDR         WF_PSE_TOP_PG_LMAC3_GROUP_ADDR
+#define WF_PSE_TOP_PG_LMAC3_GROUP_LMAC3_MIN_QUOTA_MASK         0x00001FFF                // LMAC3_MIN_QUOTA[12..0]
+#define WF_PSE_TOP_PG_LMAC3_GROUP_LMAC3_MIN_QUOTA_SHFT         0
+
+#define WF_PSE_TOP_PG_MDP_GROUP_MDP_MAX_QUOTA_ADDR             WF_PSE_TOP_PG_MDP_GROUP_ADDR
+#define WF_PSE_TOP_PG_MDP_GROUP_MDP_MAX_QUOTA_MASK             0x1FFF0000                // MDP_MAX_QUOTA[28..16]
+#define WF_PSE_TOP_PG_MDP_GROUP_MDP_MAX_QUOTA_SHFT             16
+#define WF_PSE_TOP_PG_MDP_GROUP_MDP_MIN_QUOTA_ADDR             WF_PSE_TOP_PG_MDP_GROUP_ADDR
+#define WF_PSE_TOP_PG_MDP_GROUP_MDP_MIN_QUOTA_MASK             0x00001FFF                // MDP_MIN_QUOTA[12..0]
+#define WF_PSE_TOP_PG_MDP_GROUP_MDP_MIN_QUOTA_SHFT             0
+
+#define WF_PSE_TOP_PG_MDP2_GROUP_MDP2_MAX_QUOTA_ADDR           WF_PSE_TOP_PG_MDP2_GROUP_ADDR
+#define WF_PSE_TOP_PG_MDP2_GROUP_MDP2_MAX_QUOTA_MASK           0x1FFF0000                // MDP2_MAX_QUOTA[28..16]
+#define WF_PSE_TOP_PG_MDP2_GROUP_MDP2_MAX_QUOTA_SHFT           16
+#define WF_PSE_TOP_PG_MDP2_GROUP_MDP2_MIN_QUOTA_ADDR           WF_PSE_TOP_PG_MDP2_GROUP_ADDR
+#define WF_PSE_TOP_PG_MDP2_GROUP_MDP2_MIN_QUOTA_MASK           0x00001FFF                // MDP2_MIN_QUOTA[12..0]
+#define WF_PSE_TOP_PG_MDP2_GROUP_MDP2_MIN_QUOTA_SHFT           0
+
+#define WF_PSE_TOP_PG_HIF2_GROUP_HIF2_MAX_QUOTA_ADDR           WF_PSE_TOP_PG_HIF2_GROUP_ADDR
+#define WF_PSE_TOP_PG_HIF2_GROUP_HIF2_MAX_QUOTA_MASK           0x1FFF0000                // HIF2_MAX_QUOTA[28..16]
+#define WF_PSE_TOP_PG_HIF2_GROUP_HIF2_MAX_QUOTA_SHFT           16
+#define WF_PSE_TOP_PG_HIF2_GROUP_HIF2_MIN_QUOTA_ADDR           WF_PSE_TOP_PG_HIF2_GROUP_ADDR
+#define WF_PSE_TOP_PG_HIF2_GROUP_HIF2_MIN_QUOTA_MASK           0x00001FFF                // HIF2_MIN_QUOTA[12..0]
+#define WF_PSE_TOP_PG_HIF2_GROUP_HIF2_MIN_QUOTA_SHFT           0
+
+#define WF_PSE_TOP_PG_MDP3_GROUP_MDP3_MAX_QUOTA_ADDR           WF_PSE_TOP_PG_MDP3_GROUP_ADDR
+#define WF_PSE_TOP_PG_MDP3_GROUP_MDP3_MAX_QUOTA_MASK           0x1FFF0000                // MDP3_MAX_QUOTA[28..16]
+#define WF_PSE_TOP_PG_MDP3_GROUP_MDP3_MAX_QUOTA_SHFT           16
+#define WF_PSE_TOP_PG_MDP3_GROUP_MDP3_MIN_QUOTA_ADDR           WF_PSE_TOP_PG_MDP3_GROUP_ADDR
+#define WF_PSE_TOP_PG_MDP3_GROUP_MDP3_MIN_QUOTA_MASK           0x00001FFF                // MDP3_MIN_QUOTA[12..0]
+#define WF_PSE_TOP_PG_MDP3_GROUP_MDP3_MIN_QUOTA_SHFT           0
+
+#define WF_PSE_TOP_HIF0_PG_INFO_HIF0_SRC_CNT_ADDR              WF_PSE_TOP_HIF0_PG_INFO_ADDR
+#define WF_PSE_TOP_HIF0_PG_INFO_HIF0_SRC_CNT_MASK              0x1FFF0000                // HIF0_SRC_CNT[28..16]
+#define WF_PSE_TOP_HIF0_PG_INFO_HIF0_SRC_CNT_SHFT              16
+#define WF_PSE_TOP_HIF0_PG_INFO_HIF0_RSV_CNT_ADDR              WF_PSE_TOP_HIF0_PG_INFO_ADDR
+#define WF_PSE_TOP_HIF0_PG_INFO_HIF0_RSV_CNT_MASK              0x00001FFF                // HIF0_RSV_CNT[12..0]
+#define WF_PSE_TOP_HIF0_PG_INFO_HIF0_RSV_CNT_SHFT              0
+
+#define WF_PSE_TOP_HIF1_PG_INFO_HIF1_SRC_CNT_ADDR              WF_PSE_TOP_HIF1_PG_INFO_ADDR
+#define WF_PSE_TOP_HIF1_PG_INFO_HIF1_SRC_CNT_MASK              0x1FFF0000                // HIF1_SRC_CNT[28..16]
+#define WF_PSE_TOP_HIF1_PG_INFO_HIF1_SRC_CNT_SHFT              16
+#define WF_PSE_TOP_HIF1_PG_INFO_HIF1_RSV_CNT_ADDR              WF_PSE_TOP_HIF1_PG_INFO_ADDR
+#define WF_PSE_TOP_HIF1_PG_INFO_HIF1_RSV_CNT_MASK              0x00001FFF                // HIF1_RSV_CNT[12..0]
+#define WF_PSE_TOP_HIF1_PG_INFO_HIF1_RSV_CNT_SHFT              0
+
+#define WF_PSE_TOP_CPU_PG_INFO_CPU_SRC_CNT_ADDR                WF_PSE_TOP_CPU_PG_INFO_ADDR
+#define WF_PSE_TOP_CPU_PG_INFO_CPU_SRC_CNT_MASK                0x1FFF0000                // CPU_SRC_CNT[28..16]
+#define WF_PSE_TOP_CPU_PG_INFO_CPU_SRC_CNT_SHFT                16
+#define WF_PSE_TOP_CPU_PG_INFO_CPU_RSV_CNT_ADDR                WF_PSE_TOP_CPU_PG_INFO_ADDR
+#define WF_PSE_TOP_CPU_PG_INFO_CPU_RSV_CNT_MASK                0x00001FFF                // CPU_RSV_CNT[12..0]
+#define WF_PSE_TOP_CPU_PG_INFO_CPU_RSV_CNT_SHFT                0
+
+#define WF_PSE_TOP_PLE_PG_INFO_PLE_SRC_CNT_ADDR                WF_PSE_TOP_PLE_PG_INFO_ADDR
+#define WF_PSE_TOP_PLE_PG_INFO_PLE_SRC_CNT_MASK                0x1FFF0000                // PLE_SRC_CNT[28..16]
+#define WF_PSE_TOP_PLE_PG_INFO_PLE_SRC_CNT_SHFT                16
+#define WF_PSE_TOP_PLE_PG_INFO_PLE_RSV_CNT_ADDR                WF_PSE_TOP_PLE_PG_INFO_ADDR
+#define WF_PSE_TOP_PLE_PG_INFO_PLE_RSV_CNT_MASK                0x00001FFF                // PLE_RSV_CNT[12..0]
+#define WF_PSE_TOP_PLE_PG_INFO_PLE_RSV_CNT_SHFT                0
+
+#define WF_PSE_TOP_LMAC0_PG_INFO_LMAC0_SRC_CNT_ADDR            WF_PSE_TOP_LMAC0_PG_INFO_ADDR
+#define WF_PSE_TOP_LMAC0_PG_INFO_LMAC0_SRC_CNT_MASK            0x1FFF0000                // LMAC0_SRC_CNT[28..16]
+#define WF_PSE_TOP_LMAC0_PG_INFO_LMAC0_SRC_CNT_SHFT            16
+#define WF_PSE_TOP_LMAC0_PG_INFO_LMAC0_RSV_CNT_ADDR            WF_PSE_TOP_LMAC0_PG_INFO_ADDR
+#define WF_PSE_TOP_LMAC0_PG_INFO_LMAC0_RSV_CNT_MASK            0x00001FFF                // LMAC0_RSV_CNT[12..0]
+#define WF_PSE_TOP_LMAC0_PG_INFO_LMAC0_RSV_CNT_SHFT            0
+
+#define WF_PSE_TOP_LMAC1_PG_INFO_LMAC1_SRC_CNT_ADDR            WF_PSE_TOP_LMAC1_PG_INFO_ADDR
+#define WF_PSE_TOP_LMAC1_PG_INFO_LMAC1_SRC_CNT_MASK            0x1FFF0000                // LMAC1_SRC_CNT[28..16]
+#define WF_PSE_TOP_LMAC1_PG_INFO_LMAC1_SRC_CNT_SHFT            16
+#define WF_PSE_TOP_LMAC1_PG_INFO_LMAC1_RSV_CNT_ADDR            WF_PSE_TOP_LMAC1_PG_INFO_ADDR
+#define WF_PSE_TOP_LMAC1_PG_INFO_LMAC1_RSV_CNT_MASK            0x00001FFF                // LMAC1_RSV_CNT[12..0]
+#define WF_PSE_TOP_LMAC1_PG_INFO_LMAC1_RSV_CNT_SHFT            0
+
+#define WF_PSE_TOP_LMAC2_PG_INFO_LMAC2_SRC_CNT_ADDR            WF_PSE_TOP_LMAC2_PG_INFO_ADDR
+#define WF_PSE_TOP_LMAC2_PG_INFO_LMAC2_SRC_CNT_MASK            0x1FFF0000                // LMAC2_SRC_CNT[28..16]
+#define WF_PSE_TOP_LMAC2_PG_INFO_LMAC2_SRC_CNT_SHFT            16
+#define WF_PSE_TOP_LMAC2_PG_INFO_LMAC2_RSV_CNT_ADDR            WF_PSE_TOP_LMAC2_PG_INFO_ADDR
+#define WF_PSE_TOP_LMAC2_PG_INFO_LMAC2_RSV_CNT_MASK            0x00001FFF                // LMAC2_RSV_CNT[12..0]
+#define WF_PSE_TOP_LMAC2_PG_INFO_LMAC2_RSV_CNT_SHFT            0
+
+#define WF_PSE_TOP_LMAC3_PG_INFO_LMAC3_SRC_CNT_ADDR            WF_PSE_TOP_LMAC3_PG_INFO_ADDR
+#define WF_PSE_TOP_LMAC3_PG_INFO_LMAC3_SRC_CNT_MASK            0x1FFF0000                // LMAC3_SRC_CNT[28..16]
+#define WF_PSE_TOP_LMAC3_PG_INFO_LMAC3_SRC_CNT_SHFT            16
+#define WF_PSE_TOP_LMAC3_PG_INFO_LMAC3_RSV_CNT_ADDR            WF_PSE_TOP_LMAC3_PG_INFO_ADDR
+#define WF_PSE_TOP_LMAC3_PG_INFO_LMAC3_RSV_CNT_MASK            0x00001FFF                // LMAC3_RSV_CNT[12..0]
+#define WF_PSE_TOP_LMAC3_PG_INFO_LMAC3_RSV_CNT_SHFT            0
+
+#define WF_PSE_TOP_MDP_PG_INFO_MDP_SRC_CNT_ADDR                WF_PSE_TOP_MDP_PG_INFO_ADDR
+#define WF_PSE_TOP_MDP_PG_INFO_MDP_SRC_CNT_MASK                0x1FFF0000                // MDP_SRC_CNT[28..16]
+#define WF_PSE_TOP_MDP_PG_INFO_MDP_SRC_CNT_SHFT                16
+#define WF_PSE_TOP_MDP_PG_INFO_MDP_RSV_CNT_ADDR                WF_PSE_TOP_MDP_PG_INFO_ADDR
+#define WF_PSE_TOP_MDP_PG_INFO_MDP_RSV_CNT_MASK                0x00001FFF                // MDP_RSV_CNT[12..0]
+#define WF_PSE_TOP_MDP_PG_INFO_MDP_RSV_CNT_SHFT                0
+
+#define WF_PSE_TOP_MDP2_PG_INFO_MDP2_SRC_CNT_ADDR              WF_PSE_TOP_MDP2_PG_INFO_ADDR
+#define WF_PSE_TOP_MDP2_PG_INFO_MDP2_SRC_CNT_MASK              0x1FFF0000                // MDP2_SRC_CNT[28..16]
+#define WF_PSE_TOP_MDP2_PG_INFO_MDP2_SRC_CNT_SHFT              16
+#define WF_PSE_TOP_MDP2_PG_INFO_MDP2_RSV_CNT_ADDR              WF_PSE_TOP_MDP2_PG_INFO_ADDR
+#define WF_PSE_TOP_MDP2_PG_INFO_MDP2_RSV_CNT_MASK              0x00001FFF                // MDP2_RSV_CNT[12..0]
+#define WF_PSE_TOP_MDP2_PG_INFO_MDP2_RSV_CNT_SHFT              0
+
+#define WF_PSE_TOP_HIF2_PG_INFO_HIF2_SRC_CNT_ADDR              WF_PSE_TOP_HIF2_PG_INFO_ADDR
+#define WF_PSE_TOP_HIF2_PG_INFO_HIF2_SRC_CNT_MASK              0x1FFF0000                // HIF2_SRC_CNT[28..16]
+#define WF_PSE_TOP_HIF2_PG_INFO_HIF2_SRC_CNT_SHFT              16
+#define WF_PSE_TOP_HIF2_PG_INFO_HIF2_RSV_CNT_ADDR              WF_PSE_TOP_HIF2_PG_INFO_ADDR
+#define WF_PSE_TOP_HIF2_PG_INFO_HIF2_RSV_CNT_MASK              0x00001FFF                // HIF2_RSV_CNT[12..0]
+#define WF_PSE_TOP_HIF2_PG_INFO_HIF2_RSV_CNT_SHFT              0
+
+#define WF_PSE_TOP_MDP3_PG_INFO_MDP3_SRC_CNT_ADDR              WF_PSE_TOP_MDP3_PG_INFO_ADDR
+#define WF_PSE_TOP_MDP3_PG_INFO_MDP3_SRC_CNT_MASK              0x1FFF0000                // MDP3_SRC_CNT[28..16]
+#define WF_PSE_TOP_MDP3_PG_INFO_MDP3_SRC_CNT_SHFT              16
+#define WF_PSE_TOP_MDP3_PG_INFO_MDP3_RSV_CNT_ADDR              WF_PSE_TOP_MDP3_PG_INFO_ADDR
+#define WF_PSE_TOP_MDP3_PG_INFO_MDP3_RSV_CNT_MASK              0x00001FFF                // MDP3_RSV_CNT[12..0]
+#define WF_PSE_TOP_MDP3_PG_INFO_MDP3_RSV_CNT_SHFT              0
+
+#define WF_PSE_TOP_FL_QUE_CTRL_0_EXECUTE_ADDR                  WF_PSE_TOP_FL_QUE_CTRL_0_ADDR
+#define WF_PSE_TOP_FL_QUE_CTRL_0_EXECUTE_MASK                  0x80000000                // EXECUTE[31]
+#define WF_PSE_TOP_FL_QUE_CTRL_0_EXECUTE_SHFT                  31
+#define WF_PSE_TOP_FL_QUE_CTRL_0_Q_BUF_QID_ADDR                WF_PSE_TOP_FL_QUE_CTRL_0_ADDR
+#define WF_PSE_TOP_FL_QUE_CTRL_0_Q_BUF_QID_MASK                0x7F000000                // Q_BUF_QID[30..24]
+#define WF_PSE_TOP_FL_QUE_CTRL_0_Q_BUF_QID_SHFT                24
+#define WF_PSE_TOP_FL_QUE_CTRL_0_Q_BUF_PID_SHFT                16
+
+#define WF_PSE_TOP_FL_QUE_CTRL_1_Q_BUF_PID_ADDR                WF_PSE_TOP_FL_QUE_CTRL_1_ADDR
+#define WF_PSE_TOP_FL_QUE_CTRL_1_Q_BUF_PID_MASK                0x30000000                // Q_BUF_PID[29..28]
+#define WF_PSE_TOP_FL_QUE_CTRL_1_Q_BUF_PID_SHFT                28
+
+#define WF_PSE_TOP_FL_QUE_CTRL_2_QUEUE_TAIL_FID_ADDR           WF_PSE_TOP_FL_QUE_CTRL_2_ADDR
+#define WF_PSE_TOP_FL_QUE_CTRL_2_QUEUE_TAIL_FID_MASK           0x1FFF0000                // QUEUE_TAIL_FID[28..16]
+#define WF_PSE_TOP_FL_QUE_CTRL_2_QUEUE_TAIL_FID_SHFT           16
+#define WF_PSE_TOP_FL_QUE_CTRL_2_QUEUE_HEAD_FID_ADDR           WF_PSE_TOP_FL_QUE_CTRL_2_ADDR
+#define WF_PSE_TOP_FL_QUE_CTRL_2_QUEUE_HEAD_FID_MASK           0x00001FFF                // QUEUE_HEAD_FID[12..0]
+#define WF_PSE_TOP_FL_QUE_CTRL_2_QUEUE_HEAD_FID_SHFT           0
+
+#define WF_PSE_TOP_FL_QUE_CTRL_3_QUEUE_PAGE_NUM_ADDR           WF_PSE_TOP_FL_QUE_CTRL_3_ADDR
+#define WF_PSE_TOP_FL_QUE_CTRL_3_QUEUE_PAGE_NUM_MASK           0x00FFF000                // QUEUE_PAGE_NUM[23..12]
+#define WF_PSE_TOP_FL_QUE_CTRL_3_QUEUE_PAGE_NUM_SHFT           12
+#define WF_PSE_TOP_FL_QUE_CTRL_3_QUEUE_PKT_NUM_ADDR            WF_PSE_TOP_FL_QUE_CTRL_3_ADDR
+#define WF_PSE_TOP_FL_QUE_CTRL_3_QUEUE_PKT_NUM_MASK            0x00001FFF                // QUEUE_PKT_NUM[12..0]
+#define WF_PSE_TOP_FL_QUE_CTRL_3_QUEUE_PKT_NUM_SHFT            0
+
+#define WF_PSE_TOP_FREEPG_CNT_FFA_CNT_ADDR                     WF_PSE_TOP_FREEPG_CNT_ADDR
+#define WF_PSE_TOP_FREEPG_CNT_FFA_CNT_MASK                     0x1FFF0000                // FFA_CNT[28..16]
+#define WF_PSE_TOP_FREEPG_CNT_FFA_CNT_SHFT                     16
+#define WF_PSE_TOP_FREEPG_CNT_FREEPG_CNT_ADDR                  WF_PSE_TOP_FREEPG_CNT_ADDR
+#define WF_PSE_TOP_FREEPG_CNT_FREEPG_CNT_MASK                  0x00001FFF                // FREEPG_CNT[12..0]
+#define WF_PSE_TOP_FREEPG_CNT_FREEPG_CNT_SHFT                  0
+
+#define WF_PSE_TOP_FREEPG_HEAD_TAIL_FREEPG_TAIL_ADDR           WF_PSE_TOP_FREEPG_HEAD_TAIL_ADDR
+#define WF_PSE_TOP_FREEPG_HEAD_TAIL_FREEPG_TAIL_MASK           0x1FFF0000                // FREEPG_TAIL[28..16]
+#define WF_PSE_TOP_FREEPG_HEAD_TAIL_FREEPG_TAIL_SHFT           16
+#define WF_PSE_TOP_FREEPG_HEAD_TAIL_FREEPG_HEAD_ADDR           WF_PSE_TOP_FREEPG_HEAD_TAIL_ADDR
+#define WF_PSE_TOP_FREEPG_HEAD_TAIL_FREEPG_HEAD_MASK           0x00001FFF                // FREEPG_HEAD[12..0]
+#define WF_PSE_TOP_FREEPG_HEAD_TAIL_FREEPG_HEAD_SHFT           0
+
+/* RXD */
+enum {
+	BMAC_GROUP_VLD_1 = 0x01,
+	BMAC_GROUP_VLD_2 = 0x02,
+	BMAC_GROUP_VLD_3 = 0x04,
+	BMAC_GROUP_VLD_4 = 0x08,
+	BMAC_GROUP_VLD_5 = 0x10,
+};
+
+#endif
diff --git a/mt7996/mtk_debug_i.h b/mt7996/mtk_debug_i.h
new file mode 100644
index 00000000..01023e16
--- /dev/null
+++ b/mt7996/mtk_debug_i.h
@@ -0,0 +1,1019 @@
+#ifndef __MTK_DEBUG_I_H
+#define __MTK_DEBUG_I_H
+
+#ifdef CONFIG_MTK_DEBUG
+
+// DW0
+#define WF_RX_DESCRIPTOR_RX_BYTE_COUNT_DW                                   0
+#define WF_RX_DESCRIPTOR_RX_BYTE_COUNT_ADDR                                 0
+#define WF_RX_DESCRIPTOR_RX_BYTE_COUNT_MASK                                 0x0000ffff // 15- 0
+#define WF_RX_DESCRIPTOR_RX_BYTE_COUNT_SHIFT                                0
+#define WF_RX_DESCRIPTOR_PACKET_TYPE_DW                                     0
+#define WF_RX_DESCRIPTOR_PACKET_TYPE_ADDR                                   0
+#define WF_RX_DESCRIPTOR_PACKET_TYPE_MASK                                   0xf8000000 // 31-27
+#define WF_RX_DESCRIPTOR_PACKET_TYPE_SHIFT                                  27
+// DW1
+#define WF_RX_DESCRIPTOR_MLD_ID_DW                                          1
+#define WF_RX_DESCRIPTOR_MLD_ID_ADDR                                        4
+#define WF_RX_DESCRIPTOR_MLD_ID_MASK                                        0x00000fff // 11- 0
+#define WF_RX_DESCRIPTOR_MLD_ID_SHIFT                                       0
+#define WF_RX_DESCRIPTOR_GROUP_VLD_DW                                       1
+#define WF_RX_DESCRIPTOR_GROUP_VLD_ADDR                                     4
+#define WF_RX_DESCRIPTOR_GROUP_VLD_MASK                                     0x001f0000 // 20-16
+#define WF_RX_DESCRIPTOR_GROUP_VLD_SHIFT                                    16
+#define WF_RX_DESCRIPTOR_KID_DW                                             1
+#define WF_RX_DESCRIPTOR_KID_ADDR                                           4
+#define WF_RX_DESCRIPTOR_KID_MASK                                           0x00600000 // 22-21
+#define WF_RX_DESCRIPTOR_KID_SHIFT                                          21
+#define WF_RX_DESCRIPTOR_CM_DW                                              1
+#define WF_RX_DESCRIPTOR_CM_ADDR                                            4
+#define WF_RX_DESCRIPTOR_CM_MASK                                            0x00800000 // 23-23
+#define WF_RX_DESCRIPTOR_CM_SHIFT                                           23
+#define WF_RX_DESCRIPTOR_CLM_DW                                             1
+#define WF_RX_DESCRIPTOR_CLM_ADDR                                           4
+#define WF_RX_DESCRIPTOR_CLM_MASK                                           0x01000000 // 24-24
+#define WF_RX_DESCRIPTOR_CLM_SHIFT                                          24
+#define WF_RX_DESCRIPTOR_I_DW                                               1
+#define WF_RX_DESCRIPTOR_I_ADDR                                             4
+#define WF_RX_DESCRIPTOR_I_MASK                                             0x02000000 // 25-25
+#define WF_RX_DESCRIPTOR_I_SHIFT                                            25
+#define WF_RX_DESCRIPTOR_T_DW                                               1
+#define WF_RX_DESCRIPTOR_T_ADDR                                             4
+#define WF_RX_DESCRIPTOR_T_MASK                                             0x04000000 // 26-26
+#define WF_RX_DESCRIPTOR_T_SHIFT                                            26
+#define WF_RX_DESCRIPTOR_BN_DW                                              1
+#define WF_RX_DESCRIPTOR_BN_ADDR                                            4
+#define WF_RX_DESCRIPTOR_BN_MASK                                            0x18000000 // 28-27
+#define WF_RX_DESCRIPTOR_BN_SHIFT                                           27
+#define WF_RX_DESCRIPTOR_BIPN_FAIL_DW                                       1
+#define WF_RX_DESCRIPTOR_BIPN_FAIL_ADDR                                     4
+#define WF_RX_DESCRIPTOR_BIPN_FAIL_MASK                                     0x20000000 // 29-29
+#define WF_RX_DESCRIPTOR_BIPN_FAIL_SHIFT                                    29
+// DW2
+#define WF_RX_DESCRIPTOR_BSSID_DW                                           2
+#define WF_RX_DESCRIPTOR_BSSID_ADDR                                         8
+#define WF_RX_DESCRIPTOR_BSSID_MASK                                         0x0000003f //  5- 0
+#define WF_RX_DESCRIPTOR_BSSID_SHIFT                                        0
+#define WF_RX_DESCRIPTOR_H_DW                                               2
+#define WF_RX_DESCRIPTOR_H_ADDR                                             8
+#define WF_RX_DESCRIPTOR_H_MASK                                             0x00000080 //  7- 7
+#define WF_RX_DESCRIPTOR_H_SHIFT                                            7
+#define WF_RX_DESCRIPTOR_HEADER_LENGTH_DW                                   2
+#define WF_RX_DESCRIPTOR_HEADER_LENGTH_ADDR                                 8
+#define WF_RX_DESCRIPTOR_HEADER_LENGTH_MASK                                 0x00001f00 // 12- 8
+#define WF_RX_DESCRIPTOR_HEADER_LENGTH_SHIFT                                8
+#define WF_RX_DESCRIPTOR_HO_DW                                              2
+#define WF_RX_DESCRIPTOR_HO_ADDR                                            8
+#define WF_RX_DESCRIPTOR_HO_MASK                                            0x0000e000 // 15-13
+#define WF_RX_DESCRIPTOR_HO_SHIFT                                           13
+#define WF_RX_DESCRIPTOR_SEC_MODE_DW                                        2
+#define WF_RX_DESCRIPTOR_SEC_MODE_ADDR                                      8
+#define WF_RX_DESCRIPTOR_SEC_MODE_MASK                                      0x001f0000 // 20-16
+#define WF_RX_DESCRIPTOR_SEC_MODE_SHIFT                                     16
+#define WF_RX_DESCRIPTOR_MUBAR_DW                                           2
+#define WF_RX_DESCRIPTOR_MUBAR_ADDR                                         8
+#define WF_RX_DESCRIPTOR_MUBAR_MASK                                         0x00200000 // 21-21
+#define WF_RX_DESCRIPTOR_MUBAR_SHIFT                                        21
+#define WF_RX_DESCRIPTOR_SWBIT_DW                                           2
+#define WF_RX_DESCRIPTOR_SWBIT_ADDR                                         8
+#define WF_RX_DESCRIPTOR_SWBIT_MASK                                         0x00400000 // 22-22
+#define WF_RX_DESCRIPTOR_SWBIT_SHIFT                                        22
+#define WF_RX_DESCRIPTOR_DAF_DW                                             2
+#define WF_RX_DESCRIPTOR_DAF_ADDR                                           8
+#define WF_RX_DESCRIPTOR_DAF_MASK                                           0x00800000 // 23-23
+#define WF_RX_DESCRIPTOR_DAF_SHIFT                                          23
+#define WF_RX_DESCRIPTOR_EL_DW                                              2
+#define WF_RX_DESCRIPTOR_EL_ADDR                                            8
+#define WF_RX_DESCRIPTOR_EL_MASK                                            0x01000000 // 24-24
+#define WF_RX_DESCRIPTOR_EL_SHIFT                                           24
+#define WF_RX_DESCRIPTOR_HTF_DW                                             2
+#define WF_RX_DESCRIPTOR_HTF_ADDR                                           8
+#define WF_RX_DESCRIPTOR_HTF_MASK                                           0x02000000 // 25-25
+#define WF_RX_DESCRIPTOR_HTF_SHIFT                                          25
+#define WF_RX_DESCRIPTOR_INTF_DW                                            2
+#define WF_RX_DESCRIPTOR_INTF_ADDR                                          8
+#define WF_RX_DESCRIPTOR_INTF_MASK                                          0x04000000 // 26-26
+#define WF_RX_DESCRIPTOR_INTF_SHIFT                                         26
+#define WF_RX_DESCRIPTOR_FRAG_DW                                            2
+#define WF_RX_DESCRIPTOR_FRAG_ADDR                                          8
+#define WF_RX_DESCRIPTOR_FRAG_MASK                                          0x08000000 // 27-27
+#define WF_RX_DESCRIPTOR_FRAG_SHIFT                                         27
+#define WF_RX_DESCRIPTOR_NUL_DW                                             2
+#define WF_RX_DESCRIPTOR_NUL_ADDR                                           8
+#define WF_RX_DESCRIPTOR_NUL_MASK                                           0x10000000 // 28-28
+#define WF_RX_DESCRIPTOR_NUL_SHIFT                                          28
+#define WF_RX_DESCRIPTOR_NDATA_DW                                           2
+#define WF_RX_DESCRIPTOR_NDATA_ADDR                                         8
+#define WF_RX_DESCRIPTOR_NDATA_MASK                                         0x20000000 // 29-29
+#define WF_RX_DESCRIPTOR_NDATA_SHIFT                                        29
+#define WF_RX_DESCRIPTOR_NAMP_DW                                            2
+#define WF_RX_DESCRIPTOR_NAMP_ADDR                                          8
+#define WF_RX_DESCRIPTOR_NAMP_MASK                                          0x40000000 // 30-30
+#define WF_RX_DESCRIPTOR_NAMP_SHIFT                                         30
+#define WF_RX_DESCRIPTOR_BF_RPT_DW                                          2
+#define WF_RX_DESCRIPTOR_BF_RPT_ADDR                                        8
+#define WF_RX_DESCRIPTOR_BF_RPT_MASK                                        0x80000000 // 31-31
+#define WF_RX_DESCRIPTOR_BF_RPT_SHIFT                                       31
+// DW3
+#define WF_RX_DESCRIPTOR_RXV_SN_DW                                          3
+#define WF_RX_DESCRIPTOR_RXV_SN_ADDR                                        12
+#define WF_RX_DESCRIPTOR_RXV_SN_MASK                                        0x000000ff //  7- 0
+#define WF_RX_DESCRIPTOR_RXV_SN_SHIFT                                       0
+#define WF_RX_DESCRIPTOR_CH_FREQUENCY_DW                                    3
+#define WF_RX_DESCRIPTOR_CH_FREQUENCY_ADDR                                  12
+#define WF_RX_DESCRIPTOR_CH_FREQUENCY_MASK                                  0x0000ff00 // 15- 8
+#define WF_RX_DESCRIPTOR_CH_FREQUENCY_SHIFT                                 8
+#define WF_RX_DESCRIPTOR_A1_TYPE_DW                                         3
+#define WF_RX_DESCRIPTOR_A1_TYPE_ADDR                                       12
+#define WF_RX_DESCRIPTOR_A1_TYPE_MASK                                       0x00030000 // 17-16
+#define WF_RX_DESCRIPTOR_A1_TYPE_SHIFT                                      16
+#define WF_RX_DESCRIPTOR_HTC_DW                                             3
+#define WF_RX_DESCRIPTOR_HTC_ADDR                                           12
+#define WF_RX_DESCRIPTOR_HTC_MASK                                           0x00040000 // 18-18
+#define WF_RX_DESCRIPTOR_HTC_SHIFT                                          18
+#define WF_RX_DESCRIPTOR_TCL_DW                                             3
+#define WF_RX_DESCRIPTOR_TCL_ADDR                                           12
+#define WF_RX_DESCRIPTOR_TCL_MASK                                           0x00080000 // 19-19
+#define WF_RX_DESCRIPTOR_TCL_SHIFT                                          19
+#define WF_RX_DESCRIPTOR_BBM_DW                                             3
+#define WF_RX_DESCRIPTOR_BBM_ADDR                                           12
+#define WF_RX_DESCRIPTOR_BBM_MASK                                           0x00100000 // 20-20
+#define WF_RX_DESCRIPTOR_BBM_SHIFT                                          20
+#define WF_RX_DESCRIPTOR_BU_DW                                              3
+#define WF_RX_DESCRIPTOR_BU_ADDR                                            12
+#define WF_RX_DESCRIPTOR_BU_MASK                                            0x00200000 // 21-21
+#define WF_RX_DESCRIPTOR_BU_SHIFT                                           21
+#define WF_RX_DESCRIPTOR_CO_ANT_DW                                          3
+#define WF_RX_DESCRIPTOR_CO_ANT_ADDR                                        12
+#define WF_RX_DESCRIPTOR_CO_ANT_MASK                                        0x00400000 // 22-22
+#define WF_RX_DESCRIPTOR_CO_ANT_SHIFT                                       22
+#define WF_RX_DESCRIPTOR_BF_CQI_DW                                          3
+#define WF_RX_DESCRIPTOR_BF_CQI_ADDR                                        12
+#define WF_RX_DESCRIPTOR_BF_CQI_MASK                                        0x00800000 // 23-23
+#define WF_RX_DESCRIPTOR_BF_CQI_SHIFT                                       23
+#define WF_RX_DESCRIPTOR_FC_DW                                              3
+#define WF_RX_DESCRIPTOR_FC_ADDR                                            12
+#define WF_RX_DESCRIPTOR_FC_MASK                                            0x01000000 // 24-24
+#define WF_RX_DESCRIPTOR_FC_SHIFT                                           24
+#define WF_RX_DESCRIPTOR_VLAN_DW                                            3
+#define WF_RX_DESCRIPTOR_VLAN_ADDR                                          12
+#define WF_RX_DESCRIPTOR_VLAN_MASK                                          0x80000000 // 31-31
+#define WF_RX_DESCRIPTOR_VLAN_SHIFT                                         31
+// DW4
+#define WF_RX_DESCRIPTOR_PF_DW                                              4
+#define WF_RX_DESCRIPTOR_PF_ADDR                                            16
+#define WF_RX_DESCRIPTOR_PF_MASK                                            0x00000003 //  1- 0
+#define WF_RX_DESCRIPTOR_PF_SHIFT                                           0
+#define WF_RX_DESCRIPTOR_MAC_DW                                             4
+#define WF_RX_DESCRIPTOR_MAC_ADDR                                           16
+#define WF_RX_DESCRIPTOR_MAC_MASK                                           0x00000004 //  2- 2
+#define WF_RX_DESCRIPTOR_MAC_SHIFT                                          2
+#define WF_RX_DESCRIPTOR_TID_DW                                             4
+#define WF_RX_DESCRIPTOR_TID_ADDR                                           16
+#define WF_RX_DESCRIPTOR_TID_MASK                                           0x00000078 //  6- 3
+#define WF_RX_DESCRIPTOR_TID_SHIFT                                          3
+#define WF_RX_DESCRIPTOR_ETHER_TYPE_OFFSET_DW                               4
+#define WF_RX_DESCRIPTOR_ETHER_TYPE_OFFSET_ADDR                             16
+#define WF_RX_DESCRIPTOR_ETHER_TYPE_OFFSET_MASK                             0x00003f80 // 13- 7
+#define WF_RX_DESCRIPTOR_ETHER_TYPE_OFFSET_SHIFT                            7
+#define WF_RX_DESCRIPTOR_IP_DW                                              4
+#define WF_RX_DESCRIPTOR_IP_ADDR                                            16
+#define WF_RX_DESCRIPTOR_IP_MASK                                            0x00004000 // 14-14
+#define WF_RX_DESCRIPTOR_IP_SHIFT                                           14
+#define WF_RX_DESCRIPTOR_UT_DW                                              4
+#define WF_RX_DESCRIPTOR_UT_ADDR                                            16
+#define WF_RX_DESCRIPTOR_UT_MASK                                            0x00008000 // 15-15
+#define WF_RX_DESCRIPTOR_UT_SHIFT                                           15
+#define WF_RX_DESCRIPTOR_PSE_FID_DW                                         4
+#define WF_RX_DESCRIPTOR_PSE_FID_ADDR                                       16
+#define WF_RX_DESCRIPTOR_PSE_FID_MASK                                       0x0fff0000 // 27-16
+#define WF_RX_DESCRIPTOR_PSE_FID_SHIFT                                      16
+// DW5
+// DW6
+#define WF_RX_DESCRIPTOR_CLS_BITMAP_31_0__DW                                6
+#define WF_RX_DESCRIPTOR_CLS_BITMAP_31_0__ADDR                              24
+#define WF_RX_DESCRIPTOR_CLS_BITMAP_31_0__MASK                              0xffffffff // 31- 0
+#define WF_RX_DESCRIPTOR_CLS_BITMAP_31_0__SHIFT                             0
+// DW7
+#define WF_RX_DESCRIPTOR_CLS_BITMAP_33_32__DW                               7
+#define WF_RX_DESCRIPTOR_CLS_BITMAP_33_32__ADDR                             28
+#define WF_RX_DESCRIPTOR_CLS_BITMAP_33_32__MASK                             0x00000003 //  1- 0
+#define WF_RX_DESCRIPTOR_CLS_BITMAP_33_32__SHIFT                            0
+#define WF_RX_DESCRIPTOR_DP_DW                                              7
+#define WF_RX_DESCRIPTOR_DP_ADDR                                            28
+#define WF_RX_DESCRIPTOR_DP_MASK                                            0x00080000 // 19-19
+#define WF_RX_DESCRIPTOR_DP_SHIFT                                           19
+#define WF_RX_DESCRIPTOR_CLS_DW                                             7
+#define WF_RX_DESCRIPTOR_CLS_ADDR                                           28
+#define WF_RX_DESCRIPTOR_CLS_MASK                                           0x00100000 // 20-20
+#define WF_RX_DESCRIPTOR_CLS_SHIFT                                          20
+#define WF_RX_DESCRIPTOR_OFLD_DW                                            7
+#define WF_RX_DESCRIPTOR_OFLD_ADDR                                          28
+#define WF_RX_DESCRIPTOR_OFLD_MASK                                          0x00600000 // 22-21
+#define WF_RX_DESCRIPTOR_OFLD_SHIFT                                         21
+#define WF_RX_DESCRIPTOR_MGC_DW                                             7
+#define WF_RX_DESCRIPTOR_MGC_ADDR                                           28
+#define WF_RX_DESCRIPTOR_MGC_MASK                                           0x00800000 // 23-23
+#define WF_RX_DESCRIPTOR_MGC_SHIFT                                          23
+#define WF_RX_DESCRIPTOR_WOL_DW                                             7
+#define WF_RX_DESCRIPTOR_WOL_ADDR                                           28
+#define WF_RX_DESCRIPTOR_WOL_MASK                                           0x1f000000 // 28-24
+#define WF_RX_DESCRIPTOR_WOL_SHIFT                                          24
+#define WF_RX_DESCRIPTOR_PF_MODE_DW                                         7
+#define WF_RX_DESCRIPTOR_PF_MODE_ADDR                                       28
+#define WF_RX_DESCRIPTOR_PF_MODE_MASK                                       0x20000000 // 29-29
+#define WF_RX_DESCRIPTOR_PF_MODE_SHIFT                                      29
+#define WF_RX_DESCRIPTOR_PF_STS_DW                                          7
+#define WF_RX_DESCRIPTOR_PF_STS_ADDR                                        28
+#define WF_RX_DESCRIPTOR_PF_STS_MASK                                        0xc0000000 // 31-30
+#define WF_RX_DESCRIPTOR_PF_STS_SHIFT                                       30
+// DW8
+#define WF_RX_DESCRIPTOR_FRAME_CONTROL_FIELD_DW                             8
+#define WF_RX_DESCRIPTOR_FRAME_CONTROL_FIELD_ADDR                           32
+#define WF_RX_DESCRIPTOR_FRAME_CONTROL_FIELD_MASK                           0x0000ffff // 15- 0
+#define WF_RX_DESCRIPTOR_FRAME_CONTROL_FIELD_SHIFT                          0
+#define WF_RX_DESCRIPTOR_PEER_MLD_ADDRESS_15_0__DW                          8
+#define WF_RX_DESCRIPTOR_PEER_MLD_ADDRESS_15_0__ADDR                        32
+#define WF_RX_DESCRIPTOR_PEER_MLD_ADDRESS_15_0__MASK                        0xffff0000 // 31-16
+#define WF_RX_DESCRIPTOR_PEER_MLD_ADDRESS_15_0__SHIFT                       16
+// DW9
+#define WF_RX_DESCRIPTOR_PEER_MLD_ADDRESS_47_16__DW                         9
+#define WF_RX_DESCRIPTOR_PEER_MLD_ADDRESS_47_16__ADDR                       36
+#define WF_RX_DESCRIPTOR_PEER_MLD_ADDRESS_47_16__MASK                       0xffffffff // 31- 0
+#define WF_RX_DESCRIPTOR_PEER_MLD_ADDRESS_47_16__SHIFT                      0
+// DW10
+#define WF_RX_DESCRIPTOR_FRAGMENT_NUMBER_DW                                 10
+#define WF_RX_DESCRIPTOR_FRAGMENT_NUMBER_ADDR                               40
+#define WF_RX_DESCRIPTOR_FRAGMENT_NUMBER_MASK                               0x0000000f //  3- 0
+#define WF_RX_DESCRIPTOR_FRAGMENT_NUMBER_SHIFT                              0
+#define WF_RX_DESCRIPTOR_SEQUENCE_NUMBER_DW                                 10
+#define WF_RX_DESCRIPTOR_SEQUENCE_NUMBER_ADDR                               40
+#define WF_RX_DESCRIPTOR_SEQUENCE_NUMBER_MASK                               0x0000fff0 // 15- 4
+#define WF_RX_DESCRIPTOR_SEQUENCE_NUMBER_SHIFT                              4
+#define WF_RX_DESCRIPTOR_QOS_CONTROL_FIELD_DW                               10
+#define WF_RX_DESCRIPTOR_QOS_CONTROL_FIELD_ADDR                             40
+#define WF_RX_DESCRIPTOR_QOS_CONTROL_FIELD_MASK                             0xffff0000 // 31-16
+#define WF_RX_DESCRIPTOR_QOS_CONTROL_FIELD_SHIFT                            16
+// DW11
+#define WF_RX_DESCRIPTOR_HT_CONTROL_FIELD_DW                                11
+#define WF_RX_DESCRIPTOR_HT_CONTROL_FIELD_ADDR                              44
+#define WF_RX_DESCRIPTOR_HT_CONTROL_FIELD_MASK                              0xffffffff // 31- 0
+#define WF_RX_DESCRIPTOR_HT_CONTROL_FIELD_SHIFT                             0
+// DW12
+#define WF_RX_DESCRIPTOR_PN_31_0__DW                                        12
+#define WF_RX_DESCRIPTOR_PN_31_0__ADDR                                      48
+#define WF_RX_DESCRIPTOR_PN_31_0__MASK                                      0xffffffff // 31- 0
+#define WF_RX_DESCRIPTOR_PN_31_0__SHIFT                                     0
+// DW13
+#define WF_RX_DESCRIPTOR_PN_63_32__DW                                       13
+#define WF_RX_DESCRIPTOR_PN_63_32__ADDR                                     52
+#define WF_RX_DESCRIPTOR_PN_63_32__MASK                                     0xffffffff // 31- 0
+#define WF_RX_DESCRIPTOR_PN_63_32__SHIFT                                    0
+// DW14
+#define WF_RX_DESCRIPTOR_PN_95_64__DW                                       14
+#define WF_RX_DESCRIPTOR_PN_95_64__ADDR                                     56
+#define WF_RX_DESCRIPTOR_PN_95_64__MASK                                     0xffffffff // 31- 0
+#define WF_RX_DESCRIPTOR_PN_95_64__SHIFT                                    0
+// DW15
+#define WF_RX_DESCRIPTOR_PN_127_96__DW                                      15
+#define WF_RX_DESCRIPTOR_PN_127_96__ADDR                                    60
+#define WF_RX_DESCRIPTOR_PN_127_96__MASK                                    0xffffffff // 31- 0
+#define WF_RX_DESCRIPTOR_PN_127_96__SHIFT                                   0
+// DW16
+#define WF_RX_DESCRIPTOR_TIMESTAMP_DW                                       16
+#define WF_RX_DESCRIPTOR_TIMESTAMP_ADDR                                     64
+#define WF_RX_DESCRIPTOR_TIMESTAMP_MASK                                     0xffffffff // 31- 0
+#define WF_RX_DESCRIPTOR_TIMESTAMP_SHIFT                                    0
+// DW17
+#define WF_RX_DESCRIPTOR_CRC_DW                                             17
+#define WF_RX_DESCRIPTOR_CRC_ADDR                                           68
+#define WF_RX_DESCRIPTOR_CRC_MASK                                           0xffffffff // 31- 0
+#define WF_RX_DESCRIPTOR_CRC_SHIFT                                          0
+// DW18
+// DW19
+// DW20
+#define WF_RX_DESCRIPTOR_P_RXV_DW                                           20
+#define WF_RX_DESCRIPTOR_P_RXV_ADDR                                         80
+#define WF_RX_DESCRIPTOR_P_RXV_MASK                                         0xffffffff // 31- 0
+#define WF_RX_DESCRIPTOR_P_RXV_SHIFT                                        0
+// DW21
+// DO NOT process repeat field(p_rxv)
+// DW22
+#define WF_RX_DESCRIPTOR_DBW_DW                                             22
+#define WF_RX_DESCRIPTOR_DBW_ADDR                                           88
+#define WF_RX_DESCRIPTOR_DBW_MASK                                           0x00000007 //  2- 0
+#define WF_RX_DESCRIPTOR_DBW_SHIFT                                          0
+#define WF_RX_DESCRIPTOR_GI_DW                                              22
+#define WF_RX_DESCRIPTOR_GI_ADDR                                            88
+#define WF_RX_DESCRIPTOR_GI_MASK                                            0x00000018 //  4- 3
+#define WF_RX_DESCRIPTOR_GI_SHIFT                                           3
+#define WF_RX_DESCRIPTOR_DCM_DW                                             22
+#define WF_RX_DESCRIPTOR_DCM_ADDR                                           88
+#define WF_RX_DESCRIPTOR_DCM_MASK                                           0x00000020 //  5- 5
+#define WF_RX_DESCRIPTOR_DCM_SHIFT                                          5
+#define WF_RX_DESCRIPTOR_NUM_RX_DW                                          22
+#define WF_RX_DESCRIPTOR_NUM_RX_ADDR                                        88
+#define WF_RX_DESCRIPTOR_NUM_RX_MASK                                        0x000001c0 //  8- 6
+#define WF_RX_DESCRIPTOR_NUM_RX_SHIFT                                       6
+#define WF_RX_DESCRIPTOR_STBC_DW                                            22
+#define WF_RX_DESCRIPTOR_STBC_ADDR                                          88
+#define WF_RX_DESCRIPTOR_STBC_MASK                                          0x00000600 // 10- 9
+#define WF_RX_DESCRIPTOR_STBC_SHIFT                                         9
+#define WF_RX_DESCRIPTOR_TX_MODE_DW                                         22
+#define WF_RX_DESCRIPTOR_TX_MODE_ADDR                                       88
+#define WF_RX_DESCRIPTOR_TX_MODE_MASK                                       0x00007800 // 14-11
+#define WF_RX_DESCRIPTOR_TX_MODE_SHIFT                                      11
+// DW23
+#define WF_RX_DESCRIPTOR_RCPI_DW                                            23
+#define WF_RX_DESCRIPTOR_RCPI_ADDR                                          92
+#define WF_RX_DESCRIPTOR_RCPI_MASK                                          0xffffffff // 31- 0
+#define WF_RX_DESCRIPTOR_RCPI_SHIFT                                         0
+// DW24
+#define WF_RX_DESCRIPTOR_C_RXV_DW                                           24
+#define WF_RX_DESCRIPTOR_C_RXV_ADDR                                         96
+#define WF_RX_DESCRIPTOR_C_RXV_MASK                                         0xffffffff // 31- 0
+#define WF_RX_DESCRIPTOR_C_RXV_SHIFT                                        0
+// DW25
+// DO NOT process repeat field(c_rxv)
+// DW26
+// DO NOT process repeat field(c_rxv)
+// DW27
+// DO NOT process repeat field(c_rxv)
+// DW28
+// DO NOT process repeat field(c_rxv)
+// DW29
+// DO NOT process repeat field(c_rxv)
+// DW30
+// DO NOT process repeat field(c_rxv)
+// DW31
+// DO NOT process repeat field(c_rxv)
+// DW32
+// DO NOT process repeat field(c_rxv)
+// DW33
+// DO NOT process repeat field(c_rxv)
+// DW34
+// DO NOT process repeat field(c_rxv)
+// DW35
+// DO NOT process repeat field(c_rxv)
+// DW36
+// DO NOT process repeat field(c_rxv)
+// DW37
+// DO NOT process repeat field(c_rxv)
+// DW38
+// DO NOT process repeat field(c_rxv)
+// DW39
+// DO NOT process repeat field(c_rxv)
+// DW40
+// DO NOT process repeat field(c_rxv)
+// DW41
+// DO NOT process repeat field(c_rxv)
+// DW42
+// DO NOT process repeat field(c_rxv)
+// DW43
+// DO NOT process repeat field(c_rxv)
+// DW44
+// DO NOT process repeat field(c_rxv)
+// DW45
+// DO NOT process repeat field(c_rxv)
+// DW46
+// DW47
+
+/* TXD */
+// DW0
+#define WF_TX_DESCRIPTOR_TX_BYTE_COUNT_DW                                   0
+#define WF_TX_DESCRIPTOR_TX_BYTE_COUNT_ADDR                                 0
+#define WF_TX_DESCRIPTOR_TX_BYTE_COUNT_MASK                                 0x0000ffff // 15- 0
+#define WF_TX_DESCRIPTOR_TX_BYTE_COUNT_SHIFT                                0
+#define WF_TX_DESCRIPTOR_ETHER_TYPE_OFFSET_DW                               0
+#define WF_TX_DESCRIPTOR_ETHER_TYPE_OFFSET_ADDR                             0
+#define WF_TX_DESCRIPTOR_ETHER_TYPE_OFFSET_MASK                             0x007f0000 // 22-16
+#define WF_TX_DESCRIPTOR_ETHER_TYPE_OFFSET_SHIFT                            16
+#define WF_TX_DESCRIPTOR_PKT_FT_DW                                          0
+#define WF_TX_DESCRIPTOR_PKT_FT_ADDR                                        0
+#define WF_TX_DESCRIPTOR_PKT_FT_MASK                                        0x01800000 // 24-23
+#define WF_TX_DESCRIPTOR_PKT_FT_SHIFT                                       23
+#define WF_TX_DESCRIPTOR_Q_IDX_DW                                           0
+#define WF_TX_DESCRIPTOR_Q_IDX_ADDR                                         0
+#define WF_TX_DESCRIPTOR_Q_IDX_MASK                                         0xfe000000 // 31-25
+#define WF_TX_DESCRIPTOR_Q_IDX_SHIFT                                        25
+// DW1
+#define WF_TX_DESCRIPTOR_MLD_ID_DW                                          1
+#define WF_TX_DESCRIPTOR_MLD_ID_ADDR                                        4
+#define WF_TX_DESCRIPTOR_MLD_ID_MASK                                        0x00000fff // 11- 0
+#define WF_TX_DESCRIPTOR_MLD_ID_SHIFT                                       0
+#define WF_TX_DESCRIPTOR_TGID_DW                                            1
+#define WF_TX_DESCRIPTOR_TGID_ADDR                                          4
+#define WF_TX_DESCRIPTOR_TGID_MASK                                          0x00003000 // 13-12
+#define WF_TX_DESCRIPTOR_TGID_SHIFT                                         12
+#define WF_TX_DESCRIPTOR_HF_DW                                              1
+#define WF_TX_DESCRIPTOR_HF_ADDR                                            4
+#define WF_TX_DESCRIPTOR_HF_MASK                                            0x0000c000 // 15-14
+#define WF_TX_DESCRIPTOR_HF_SHIFT                                           14
+#define WF_TX_DESCRIPTOR_HEADER_LENGTH_DW                                   1
+#define WF_TX_DESCRIPTOR_HEADER_LENGTH_ADDR                                 4
+#define WF_TX_DESCRIPTOR_HEADER_LENGTH_MASK                                 0x001f0000 // 20-16
+#define WF_TX_DESCRIPTOR_HEADER_LENGTH_SHIFT                                16
+#define WF_TX_DESCRIPTOR_MRD_DW                                             1
+#define WF_TX_DESCRIPTOR_MRD_ADDR                                           4
+#define WF_TX_DESCRIPTOR_MRD_MASK                                           0x00010000 // 16-16
+#define WF_TX_DESCRIPTOR_MRD_SHIFT                                          16
+#define WF_TX_DESCRIPTOR_EOSP_DW                                            1
+#define WF_TX_DESCRIPTOR_EOSP_ADDR                                          4
+#define WF_TX_DESCRIPTOR_EOSP_MASK                                          0x00020000 // 17-17
+#define WF_TX_DESCRIPTOR_EOSP_SHIFT                                         17
+#define WF_TX_DESCRIPTOR_EOSP_DW                                            1
+#define WF_TX_DESCRIPTOR_EOSP_ADDR                                          4
+#define WF_TX_DESCRIPTOR_EOSP_MASK                                          0x00020000 // 17-17
+#define WF_TX_DESCRIPTOR_EOSP_SHIFT                                         17
+#define WF_TX_DESCRIPTOR_AMS_DW                                             1
+#define WF_TX_DESCRIPTOR_AMS_ADDR                                           4
+#define WF_TX_DESCRIPTOR_AMS_MASK                                           0x00040000 // 18-18
+#define WF_TX_DESCRIPTOR_AMS_SHIFT                                          18
+#define WF_TX_DESCRIPTOR_RMVL_DW                                            1
+#define WF_TX_DESCRIPTOR_RMVL_ADDR                                          4
+#define WF_TX_DESCRIPTOR_RMVL_MASK                                          0x00040000 // 18-18
+#define WF_TX_DESCRIPTOR_RMVL_SHIFT                                         18
+#define WF_TX_DESCRIPTOR_VLAN_DW                                            1
+#define WF_TX_DESCRIPTOR_VLAN_ADDR                                          4
+#define WF_TX_DESCRIPTOR_VLAN_MASK                                          0x00080000 // 19-19
+#define WF_TX_DESCRIPTOR_VLAN_SHIFT                                         19
+#define WF_TX_DESCRIPTOR_ETYP_DW                                            1
+#define WF_TX_DESCRIPTOR_ETYP_ADDR                                          4
+#define WF_TX_DESCRIPTOR_ETYP_MASK                                          0x00100000 // 20-20
+#define WF_TX_DESCRIPTOR_ETYP_SHIFT                                         20
+#define WF_TX_DESCRIPTOR_TID_MGMT_TYPE_DW                                   1
+#define WF_TX_DESCRIPTOR_TID_MGMT_TYPE_ADDR                                 4
+#define WF_TX_DESCRIPTOR_TID_MGMT_TYPE_MASK                                 0x01e00000 // 24-21
+#define WF_TX_DESCRIPTOR_TID_MGMT_TYPE_SHIFT                                21
+#define WF_TX_DESCRIPTOR_OM_DW                                              1
+#define WF_TX_DESCRIPTOR_OM_ADDR                                            4
+#define WF_TX_DESCRIPTOR_OM_MASK                                            0x7e000000 // 30-25
+#define WF_TX_DESCRIPTOR_OM_SHIFT                                           25
+#define WF_TX_DESCRIPTOR_FR_DW                                              1
+#define WF_TX_DESCRIPTOR_FR_ADDR                                            4
+#define WF_TX_DESCRIPTOR_FR_MASK                                            0x80000000 // 31-31
+#define WF_TX_DESCRIPTOR_FR_SHIFT                                           31
+// DW2
+#define WF_TX_DESCRIPTOR_SUBTYPE_DW                                         2
+#define WF_TX_DESCRIPTOR_SUBTYPE_ADDR                                       8
+#define WF_TX_DESCRIPTOR_SUBTYPE_MASK                                       0x0000000f //  3- 0
+#define WF_TX_DESCRIPTOR_SUBTYPE_SHIFT                                      0
+#define WF_TX_DESCRIPTOR_FTYPE_DW                                           2
+#define WF_TX_DESCRIPTOR_FTYPE_ADDR                                         8
+#define WF_TX_DESCRIPTOR_FTYPE_MASK                                         0x00000030 //  5- 4
+#define WF_TX_DESCRIPTOR_FTYPE_SHIFT                                        4
+#define WF_TX_DESCRIPTOR_BF_TYPE_DW                                         2
+#define WF_TX_DESCRIPTOR_BF_TYPE_ADDR                                       8
+#define WF_TX_DESCRIPTOR_BF_TYPE_MASK                                       0x000000c0 //  7- 6
+#define WF_TX_DESCRIPTOR_BF_TYPE_SHIFT                                      6
+#define WF_TX_DESCRIPTOR_OM_MAP_DW                                          2
+#define WF_TX_DESCRIPTOR_OM_MAP_ADDR                                        8
+#define WF_TX_DESCRIPTOR_OM_MAP_MASK                                        0x00000100 //  8- 8
+#define WF_TX_DESCRIPTOR_OM_MAP_SHIFT                                       8
+#define WF_TX_DESCRIPTOR_RTS_DW                                             2
+#define WF_TX_DESCRIPTOR_RTS_ADDR                                           8
+#define WF_TX_DESCRIPTOR_RTS_MASK                                           0x00000200 //  9- 9
+#define WF_TX_DESCRIPTOR_RTS_SHIFT                                          9
+#define WF_TX_DESCRIPTOR_HEADER_PADDING_DW                                  2
+#define WF_TX_DESCRIPTOR_HEADER_PADDING_ADDR                                8
+#define WF_TX_DESCRIPTOR_HEADER_PADDING_MASK                                0x00000c00 // 11-10
+#define WF_TX_DESCRIPTOR_HEADER_PADDING_SHIFT                               10
+#define WF_TX_DESCRIPTOR_DU_DW                                              2
+#define WF_TX_DESCRIPTOR_DU_ADDR                                            8
+#define WF_TX_DESCRIPTOR_DU_MASK                                            0x00001000 // 12-12
+#define WF_TX_DESCRIPTOR_DU_SHIFT                                           12
+#define WF_TX_DESCRIPTOR_HE_DW                                              2
+#define WF_TX_DESCRIPTOR_HE_ADDR                                            8
+#define WF_TX_DESCRIPTOR_HE_MASK                                            0x00002000 // 13-13
+#define WF_TX_DESCRIPTOR_HE_SHIFT                                           13
+#define WF_TX_DESCRIPTOR_FRAG_DW                                            2
+#define WF_TX_DESCRIPTOR_FRAG_ADDR                                          8
+#define WF_TX_DESCRIPTOR_FRAG_MASK                                          0x0000c000 // 15-14
+#define WF_TX_DESCRIPTOR_FRAG_SHIFT                                         14
+#define WF_TX_DESCRIPTOR_REMAINING_TX_TIME_DW                               2
+#define WF_TX_DESCRIPTOR_REMAINING_TX_TIME_ADDR                             8
+#define WF_TX_DESCRIPTOR_REMAINING_TX_TIME_MASK                             0x03ff0000 // 25-16
+#define WF_TX_DESCRIPTOR_REMAINING_TX_TIME_SHIFT                            16
+#define WF_TX_DESCRIPTOR_POWER_OFFSET_DW                                    2
+#define WF_TX_DESCRIPTOR_POWER_OFFSET_ADDR                                  8
+#define WF_TX_DESCRIPTOR_POWER_OFFSET_MASK                                  0xfc000000 // 31-26
+#define WF_TX_DESCRIPTOR_POWER_OFFSET_SHIFT                                 26
+// DW3
+#define WF_TX_DESCRIPTOR_NA_DW                                              3
+#define WF_TX_DESCRIPTOR_NA_ADDR                                            12
+#define WF_TX_DESCRIPTOR_NA_MASK                                            0x00000001 //  0- 0
+#define WF_TX_DESCRIPTOR_NA_SHIFT                                           0
+#define WF_TX_DESCRIPTOR_PF_DW                                              3
+#define WF_TX_DESCRIPTOR_PF_ADDR                                            12
+#define WF_TX_DESCRIPTOR_PF_MASK                                            0x00000002 //  1- 1
+#define WF_TX_DESCRIPTOR_PF_SHIFT                                           1
+#define WF_TX_DESCRIPTOR_EMRD_DW                                            3
+#define WF_TX_DESCRIPTOR_EMRD_ADDR                                          12
+#define WF_TX_DESCRIPTOR_EMRD_MASK                                          0x00000004 //  2- 2
+#define WF_TX_DESCRIPTOR_EMRD_SHIFT                                         2
+#define WF_TX_DESCRIPTOR_EEOSP_DW                                           3
+#define WF_TX_DESCRIPTOR_EEOSP_ADDR                                         12
+#define WF_TX_DESCRIPTOR_EEOSP_MASK                                         0x00000008 //  3- 3
+#define WF_TX_DESCRIPTOR_EEOSP_SHIFT                                        3
+#define WF_TX_DESCRIPTOR_BM_DW                                              3
+#define WF_TX_DESCRIPTOR_BM_ADDR                                            12
+#define WF_TX_DESCRIPTOR_BM_MASK                                            0x00000010 //  4- 4
+#define WF_TX_DESCRIPTOR_BM_SHIFT                                           4
+#define WF_TX_DESCRIPTOR_HW_AMSDU_CAP_DW                                    3
+#define WF_TX_DESCRIPTOR_HW_AMSDU_CAP_ADDR                                  12
+#define WF_TX_DESCRIPTOR_HW_AMSDU_CAP_MASK                                  0x00000020 //  5- 5
+#define WF_TX_DESCRIPTOR_HW_AMSDU_CAP_SHIFT                                 5
+#define WF_TX_DESCRIPTOR_TX_COUNT_DW                                        3
+#define WF_TX_DESCRIPTOR_TX_COUNT_ADDR                                      12
+#define WF_TX_DESCRIPTOR_TX_COUNT_MASK                                      0x000007c0 // 10- 6
+#define WF_TX_DESCRIPTOR_TX_COUNT_SHIFT                                     6
+#define WF_TX_DESCRIPTOR_REMAINING_TX_COUNT_DW                              3
+#define WF_TX_DESCRIPTOR_REMAINING_TX_COUNT_ADDR                            12
+#define WF_TX_DESCRIPTOR_REMAINING_TX_COUNT_MASK                            0x0000f800 // 15-11
+#define WF_TX_DESCRIPTOR_REMAINING_TX_COUNT_SHIFT                           11
+#define WF_TX_DESCRIPTOR_SN_DW                                              3
+#define WF_TX_DESCRIPTOR_SN_ADDR                                            12
+#define WF_TX_DESCRIPTOR_SN_MASK                                            0x0fff0000 // 27-16
+#define WF_TX_DESCRIPTOR_SN_SHIFT                                           16
+#define WF_TX_DESCRIPTOR_BA_DIS_DW                                          3
+#define WF_TX_DESCRIPTOR_BA_DIS_ADDR                                        12
+#define WF_TX_DESCRIPTOR_BA_DIS_MASK                                        0x10000000 // 28-28
+#define WF_TX_DESCRIPTOR_BA_DIS_SHIFT                                       28
+#define WF_TX_DESCRIPTOR_PM_DW                                              3
+#define WF_TX_DESCRIPTOR_PM_ADDR                                            12
+#define WF_TX_DESCRIPTOR_PM_MASK                                            0x20000000 // 29-29
+#define WF_TX_DESCRIPTOR_PM_SHIFT                                           29
+#define WF_TX_DESCRIPTOR_PN_VLD_DW                                          3
+#define WF_TX_DESCRIPTOR_PN_VLD_ADDR                                        12
+#define WF_TX_DESCRIPTOR_PN_VLD_MASK                                        0x40000000 // 30-30
+#define WF_TX_DESCRIPTOR_PN_VLD_SHIFT                                       30
+#define WF_TX_DESCRIPTOR_SN_VLD_DW                                          3
+#define WF_TX_DESCRIPTOR_SN_VLD_ADDR                                        12
+#define WF_TX_DESCRIPTOR_SN_VLD_MASK                                        0x80000000 // 31-31
+#define WF_TX_DESCRIPTOR_SN_VLD_SHIFT                                       31
+// DW4
+#define WF_TX_DESCRIPTOR_PN_31_0__DW                                        4
+#define WF_TX_DESCRIPTOR_PN_31_0__ADDR                                      16
+#define WF_TX_DESCRIPTOR_PN_31_0__MASK                                      0xffffffff // 31- 0
+#define WF_TX_DESCRIPTOR_PN_31_0__SHIFT                                     0
+// DW5
+#define WF_TX_DESCRIPTOR_PID_DW                                             5
+#define WF_TX_DESCRIPTOR_PID_ADDR                                           20
+#define WF_TX_DESCRIPTOR_PID_MASK                                           0x000000ff //  7- 0
+#define WF_TX_DESCRIPTOR_PID_SHIFT                                          0
+#define WF_TX_DESCRIPTOR_TXSFM_DW                                           5
+#define WF_TX_DESCRIPTOR_TXSFM_ADDR                                         20
+#define WF_TX_DESCRIPTOR_TXSFM_MASK                                         0x00000100 //  8- 8
+#define WF_TX_DESCRIPTOR_TXSFM_SHIFT                                        8
+#define WF_TX_DESCRIPTOR_TXS2M_DW                                           5
+#define WF_TX_DESCRIPTOR_TXS2M_ADDR                                         20
+#define WF_TX_DESCRIPTOR_TXS2M_MASK                                         0x00000200 //  9- 9
+#define WF_TX_DESCRIPTOR_TXS2M_SHIFT                                        9
+#define WF_TX_DESCRIPTOR_TXS2H_DW                                           5
+#define WF_TX_DESCRIPTOR_TXS2H_ADDR                                         20
+#define WF_TX_DESCRIPTOR_TXS2H_MASK                                         0x00000400 // 10-10
+#define WF_TX_DESCRIPTOR_TXS2H_SHIFT                                        10
+#define WF_TX_DESCRIPTOR_FBCZ_DW                                            5
+#define WF_TX_DESCRIPTOR_FBCZ_ADDR                                          20
+#define WF_TX_DESCRIPTOR_FBCZ_MASK                                          0x00001000 // 12-12
+#define WF_TX_DESCRIPTOR_FBCZ_SHIFT                                         12
+#define WF_TX_DESCRIPTOR_BYPASS_RBB_DW                                      5
+#define WF_TX_DESCRIPTOR_BYPASS_RBB_ADDR                                    20
+#define WF_TX_DESCRIPTOR_BYPASS_RBB_MASK                                    0x00002000 // 13-13
+#define WF_TX_DESCRIPTOR_BYPASS_RBB_SHIFT                                   13
+#define WF_TX_DESCRIPTOR_BYPASS_TBB_DW                                      5
+#define WF_TX_DESCRIPTOR_BYPASS_TBB_ADDR                                    20
+#define WF_TX_DESCRIPTOR_BYPASS_TBB_MASK                                    0x00004000 // 14-14
+#define WF_TX_DESCRIPTOR_BYPASS_TBB_SHIFT                                   14
+#define WF_TX_DESCRIPTOR_FL_DW                                              5
+#define WF_TX_DESCRIPTOR_FL_ADDR                                            20
+#define WF_TX_DESCRIPTOR_FL_MASK                                            0x00008000 // 15-15
+#define WF_TX_DESCRIPTOR_FL_SHIFT                                           15
+#define WF_TX_DESCRIPTOR_PN_47_32__DW                                       5
+#define WF_TX_DESCRIPTOR_PN_47_32__ADDR                                     20
+#define WF_TX_DESCRIPTOR_PN_47_32__MASK                                     0xffff0000 // 31-16
+#define WF_TX_DESCRIPTOR_PN_47_32__SHIFT                                    16
+// DW6
+#define WF_TX_DESCRIPTOR_AMSDU_CAP_UTXB_DW                                  6
+#define WF_TX_DESCRIPTOR_AMSDU_CAP_UTXB_ADDR                                24
+#define WF_TX_DESCRIPTOR_AMSDU_CAP_UTXB_MASK                                0x00000002 //  1- 1
+#define WF_TX_DESCRIPTOR_AMSDU_CAP_UTXB_SHIFT                               1
+#define WF_TX_DESCRIPTOR_DAS_DW                                             6
+#define WF_TX_DESCRIPTOR_DAS_ADDR                                           24
+#define WF_TX_DESCRIPTOR_DAS_MASK                                           0x00000004 //  2- 2
+#define WF_TX_DESCRIPTOR_DAS_SHIFT                                          2
+#define WF_TX_DESCRIPTOR_DIS_MAT_DW                                         6
+#define WF_TX_DESCRIPTOR_DIS_MAT_ADDR                                       24
+#define WF_TX_DESCRIPTOR_DIS_MAT_MASK                                       0x00000008 //  3- 3
+#define WF_TX_DESCRIPTOR_DIS_MAT_SHIFT                                      3
+#define WF_TX_DESCRIPTOR_MSDU_COUNT_DW                                      6
+#define WF_TX_DESCRIPTOR_MSDU_COUNT_ADDR                                    24
+#define WF_TX_DESCRIPTOR_MSDU_COUNT_MASK                                    0x000003f0 //  9- 4
+#define WF_TX_DESCRIPTOR_MSDU_COUNT_SHIFT                                   4
+#define WF_TX_DESCRIPTOR_TIMESTAMP_OFFSET_IDX_DW                            6
+#define WF_TX_DESCRIPTOR_TIMESTAMP_OFFSET_IDX_ADDR                          24
+#define WF_TX_DESCRIPTOR_TIMESTAMP_OFFSET_IDX_MASK                          0x00007c00 // 14-10
+#define WF_TX_DESCRIPTOR_TIMESTAMP_OFFSET_IDX_SHIFT                         10
+#define WF_TX_DESCRIPTOR_TIMESTAMP_OFFSET_EN_DW                             6
+#define WF_TX_DESCRIPTOR_TIMESTAMP_OFFSET_EN_ADDR                           24
+#define WF_TX_DESCRIPTOR_TIMESTAMP_OFFSET_EN_MASK                           0x00008000 // 15-15
+#define WF_TX_DESCRIPTOR_TIMESTAMP_OFFSET_EN_SHIFT                          15
+#define WF_TX_DESCRIPTOR_FIXED_RATE_IDX_DW                                  6
+#define WF_TX_DESCRIPTOR_FIXED_RATE_IDX_ADDR                                24
+#define WF_TX_DESCRIPTOR_FIXED_RATE_IDX_MASK                                0x003f0000 // 21-16
+#define WF_TX_DESCRIPTOR_FIXED_RATE_IDX_SHIFT                               16
+#define WF_TX_DESCRIPTOR_BW_DW                                              6
+#define WF_TX_DESCRIPTOR_BW_ADDR                                            24
+#define WF_TX_DESCRIPTOR_BW_MASK                                            0x03c00000 // 25-22
+#define WF_TX_DESCRIPTOR_BW_SHIFT                                           22
+#define WF_TX_DESCRIPTOR_VTA_DW                                             6
+#define WF_TX_DESCRIPTOR_VTA_ADDR                                           24
+#define WF_TX_DESCRIPTOR_VTA_MASK                                           0x10000000 // 28-28
+#define WF_TX_DESCRIPTOR_VTA_SHIFT                                          28
+#define WF_TX_DESCRIPTOR_SRC_DW                                             6
+#define WF_TX_DESCRIPTOR_SRC_ADDR                                           24
+#define WF_TX_DESCRIPTOR_SRC_MASK                                           0xc0000000 // 31-30
+#define WF_TX_DESCRIPTOR_SRC_SHIFT                                          30
+// DW7
+#define WF_TX_DESCRIPTOR_SW_TX_TIME_DW                                      7
+#define WF_TX_DESCRIPTOR_SW_TX_TIME_ADDR                                    28
+#define WF_TX_DESCRIPTOR_SW_TX_TIME_MASK                                    0x000003ff //  9- 0
+#define WF_TX_DESCRIPTOR_SW_TX_TIME_SHIFT                                   0
+#define WF_TX_DESCRIPTOR_UT_DW                                              7
+#define WF_TX_DESCRIPTOR_UT_ADDR                                            28
+#define WF_TX_DESCRIPTOR_UT_MASK                                            0x00008000 // 15-15
+#define WF_TX_DESCRIPTOR_UT_SHIFT                                           15
+#define WF_TX_DESCRIPTOR_CTXD_CNT_DW                                        7
+#define WF_TX_DESCRIPTOR_CTXD_CNT_ADDR                                      28
+#define WF_TX_DESCRIPTOR_CTXD_CNT_MASK                                      0x03c00000 // 25-22
+#define WF_TX_DESCRIPTOR_CTXD_CNT_SHIFT                                     22
+#define WF_TX_DESCRIPTOR_CTXD_DW                                            7
+#define WF_TX_DESCRIPTOR_CTXD_ADDR                                          28
+#define WF_TX_DESCRIPTOR_CTXD_MASK                                          0x04000000 // 26-26
+#define WF_TX_DESCRIPTOR_CTXD_SHIFT                                         26
+#define WF_TX_DESCRIPTOR_HM_DW                                              7
+#define WF_TX_DESCRIPTOR_HM_ADDR                                            28
+#define WF_TX_DESCRIPTOR_HM_MASK                                            0x08000000 // 27-27
+#define WF_TX_DESCRIPTOR_HM_SHIFT                                           27
+#define WF_TX_DESCRIPTOR_DP_DW                                              7
+#define WF_TX_DESCRIPTOR_DP_ADDR                                            28
+#define WF_TX_DESCRIPTOR_DP_MASK                                            0x10000000 // 28-28
+#define WF_TX_DESCRIPTOR_DP_SHIFT                                           28
+#define WF_TX_DESCRIPTOR_IP_DW                                              7
+#define WF_TX_DESCRIPTOR_IP_ADDR                                            28
+#define WF_TX_DESCRIPTOR_IP_MASK                                            0x20000000 // 29-29
+#define WF_TX_DESCRIPTOR_IP_SHIFT                                           29
+#define WF_TX_DESCRIPTOR_TXD_LEN_DW                                         7
+#define WF_TX_DESCRIPTOR_TXD_LEN_ADDR                                       28
+#define WF_TX_DESCRIPTOR_TXD_LEN_MASK                                       0xc0000000 // 31-30
+#define WF_TX_DESCRIPTOR_TXD_LEN_SHIFT                                      30
+// DW8
+#define WF_TX_DESCRIPTOR_MSDU0_DW                                           8
+#define WF_TX_DESCRIPTOR_MSDU0_ADDR                                         32
+#define WF_TX_DESCRIPTOR_MSDU0_MASK                                         0x0000ffff // 15- 0
+#define WF_TX_DESCRIPTOR_MSDU0_SHIFT                                        0
+#define WF_TX_DESCRIPTOR_MSDU1_DW                                           8
+#define WF_TX_DESCRIPTOR_MSDU1_ADDR                                         32
+#define WF_TX_DESCRIPTOR_MSDU1_MASK                                         0xffff0000 // 31-16
+#define WF_TX_DESCRIPTOR_MSDU1_SHIFT                                        16
+// DW9
+#define WF_TX_DESCRIPTOR_MSDU2_DW                                           9
+#define WF_TX_DESCRIPTOR_MSDU2_ADDR                                         36
+#define WF_TX_DESCRIPTOR_MSDU2_MASK                                         0x0000ffff // 15- 0
+#define WF_TX_DESCRIPTOR_MSDU2_SHIFT                                        0
+#define WF_TX_DESCRIPTOR_MSDU3_DW                                           9
+#define WF_TX_DESCRIPTOR_MSDU3_ADDR                                         36
+#define WF_TX_DESCRIPTOR_MSDU3_MASK                                         0xffff0000 // 31-16
+#define WF_TX_DESCRIPTOR_MSDU3_SHIFT                                        16
+// DW10
+#define WF_TX_DESCRIPTOR_TXP0_DW                                            10
+#define WF_TX_DESCRIPTOR_TXP0_ADDR                                          40
+#define WF_TX_DESCRIPTOR_TXP0_MASK                                          0xffffffff // 31- 0
+#define WF_TX_DESCRIPTOR_TXP0_SHIFT                                         0
+// DW11
+// DO NOT process repeat field(txp[0])
+#define WF_TX_DESCRIPTOR_TXP1_DW                                            11
+#define WF_TX_DESCRIPTOR_TXP1_ADDR                                          44
+#define WF_TX_DESCRIPTOR_TXP1_MASK                                          0xffff0000 // 31-16
+#define WF_TX_DESCRIPTOR_TXP1_SHIFT                                         16
+// DW12
+// DO NOT process repeat field(txp[1])
+// DW13
+#define WF_TX_DESCRIPTOR_TXP2_DW                                            13
+#define WF_TX_DESCRIPTOR_TXP2_ADDR                                          52
+#define WF_TX_DESCRIPTOR_TXP2_MASK                                          0xffffffff // 31- 0
+#define WF_TX_DESCRIPTOR_TXP2_SHIFT                                         0
+// DW14
+// DO NOT process repeat field(txp[2])
+#define WF_TX_DESCRIPTOR_TXP3_DW                                            14
+#define WF_TX_DESCRIPTOR_TXP3_ADDR                                          56
+#define WF_TX_DESCRIPTOR_TXP3_MASK                                          0xffff0000 // 31-16
+#define WF_TX_DESCRIPTOR_TXP3_SHIFT                                         16
+// DW15
+// DO NOT process repeat field(txp[3])
+// DW16
+#define WF_TX_DESCRIPTOR_MSDU4_DW                                           16
+#define WF_TX_DESCRIPTOR_MSDU4_ADDR                                         64
+#define WF_TX_DESCRIPTOR_MSDU4_MASK                                         0x0000ffff // 15- 0
+#define WF_TX_DESCRIPTOR_MSDU4_SHIFT                                        0
+#define WF_TX_DESCRIPTOR_MSDU5_DW                                           16
+#define WF_TX_DESCRIPTOR_MSDU5_ADDR                                         64
+#define WF_TX_DESCRIPTOR_MSDU5_MASK                                         0xffff0000 // 31-16
+#define WF_TX_DESCRIPTOR_MSDU5_SHIFT                                        16
+// DW17
+#define WF_TX_DESCRIPTOR_MSDU6_DW                                           17
+#define WF_TX_DESCRIPTOR_MSDU6_ADDR                                         68
+#define WF_TX_DESCRIPTOR_MSDU6_MASK                                         0x0000ffff // 15- 0
+#define WF_TX_DESCRIPTOR_MSDU6_SHIFT                                        0
+#define WF_TX_DESCRIPTOR_MSDU7_DW                                           17
+#define WF_TX_DESCRIPTOR_MSDU7_ADDR                                         68
+#define WF_TX_DESCRIPTOR_MSDU7_MASK                                         0xffff0000 // 31-16
+#define WF_TX_DESCRIPTOR_MSDU7_SHIFT                                        16
+// DW18
+#define WF_TX_DESCRIPTOR_TXP4_DW                                            18
+#define WF_TX_DESCRIPTOR_TXP4_ADDR                                          72
+#define WF_TX_DESCRIPTOR_TXP4_MASK                                          0xffffffff // 31- 0
+#define WF_TX_DESCRIPTOR_TXP4_SHIFT                                         0
+// DW19
+// DO NOT process repeat field(txp[4])
+#define WF_TX_DESCRIPTOR_TXP5_DW                                            19
+#define WF_TX_DESCRIPTOR_TXP5_ADDR                                          76
+#define WF_TX_DESCRIPTOR_TXP5_MASK                                          0xffff0000 // 31-16
+#define WF_TX_DESCRIPTOR_TXP5_SHIFT                                         16
+// DW20
+// DO NOT process repeat field(txp[5])
+// DW21
+#define WF_TX_DESCRIPTOR_TXP6_DW                                            21
+#define WF_TX_DESCRIPTOR_TXP6_ADDR                                          84
+#define WF_TX_DESCRIPTOR_TXP6_MASK                                          0xffffffff // 31- 0
+#define WF_TX_DESCRIPTOR_TXP6_SHIFT                                         0
+// DW22
+// DO NOT process repeat field(txp[6])
+#define WF_TX_DESCRIPTOR_TXP7_DW                                            22
+#define WF_TX_DESCRIPTOR_TXP7_ADDR                                          88
+#define WF_TX_DESCRIPTOR_TXP7_MASK                                          0xffff0000 // 31-16
+#define WF_TX_DESCRIPTOR_TXP7_SHIFT                                         16
+// DW23
+// DO NOT process repeat field(txp[7])
+// DW24
+#define WF_TX_DESCRIPTOR_TXP8_DW                                            24
+#define WF_TX_DESCRIPTOR_TXP8_ADDR                                          96
+#define WF_TX_DESCRIPTOR_TXP8_MASK                                          0xffffffff // 31- 0
+#define WF_TX_DESCRIPTOR_TXP8_SHIFT                                         0
+// DW25
+// DO NOT process repeat field(txp[8])
+#define WF_TX_DESCRIPTOR_TXP9_DW                                            25
+#define WF_TX_DESCRIPTOR_TXP9_ADDR                                          100
+#define WF_TX_DESCRIPTOR_TXP9_MASK                                          0xffff0000 // 31-16
+#define WF_TX_DESCRIPTOR_TXP9_SHIFT                                         16
+// DW26
+// DO NOT process repeat field(txp[9])
+// DW27
+#define WF_TX_DESCRIPTOR_TXP10_DW                                           27
+#define WF_TX_DESCRIPTOR_TXP10_ADDR                                         108
+#define WF_TX_DESCRIPTOR_TXP10_MASK                                         0xffffffff // 31- 0
+#define WF_TX_DESCRIPTOR_TXP10_SHIFT                                        0
+// DW28
+// DO NOT process repeat field(txp[10])
+#define WF_TX_DESCRIPTOR_TXP11_DW                                           28
+#define WF_TX_DESCRIPTOR_TXP11_ADDR                                         112
+#define WF_TX_DESCRIPTOR_TXP11_MASK                                         0xffff0000 // 31-16
+#define WF_TX_DESCRIPTOR_TXP11_SHIFT                                        16
+// DW29
+// DO NOT process repeat field(txp[11])
+// DW30
+#define WF_TX_DESCRIPTOR_TXP12_DW                                           30
+#define WF_TX_DESCRIPTOR_TXP12_ADDR                                         120
+#define WF_TX_DESCRIPTOR_TXP12_MASK                                         0xffffffff // 31- 0
+#define WF_TX_DESCRIPTOR_TXP12_SHIFT                                        0
+// DW31
+// DO NOT process repeat field(txp[12])
+#define WF_TX_DESCRIPTOR_TXP13_DW                                           31
+#define WF_TX_DESCRIPTOR_TXP13_ADDR                                         124
+#define WF_TX_DESCRIPTOR_TXP13_MASK                                         0xffff0000 // 31-16
+#define WF_TX_DESCRIPTOR_TXP13_SHIFT                                        16
+// DW32
+// DO NOT process repeat field(txp[13])
+// DW33
+#define WF_TX_DESCRIPTOR_TXP14_DW                                           33
+#define WF_TX_DESCRIPTOR_TXP14_ADDR                                         132
+#define WF_TX_DESCRIPTOR_TXP14_MASK                                         0xffffffff // 31- 0
+#define WF_TX_DESCRIPTOR_TXP14_SHIFT                                        0
+// DW34
+// DO NOT process repeat field(txp[14])
+#define WF_TX_DESCRIPTOR_TXP15_DW                                           34
+#define WF_TX_DESCRIPTOR_TXP15_ADDR                                         136
+#define WF_TX_DESCRIPTOR_TXP15_MASK                                         0xffff0000 // 31-16
+#define WF_TX_DESCRIPTOR_TXP15_SHIFT                                        16
+// DW35
+// DO NOT process repeat field(txp[15])
+// DW36
+#define WF_TX_DESCRIPTOR_TXP16_DW                                           36
+#define WF_TX_DESCRIPTOR_TXP16_ADDR                                         144
+#define WF_TX_DESCRIPTOR_TXP16_MASK                                         0xffffffff // 31- 0
+#define WF_TX_DESCRIPTOR_TXP16_SHIFT                                        0
+// DW37
+// DO NOT process repeat field(txp[16])
+#define WF_TX_DESCRIPTOR_TXP17_DW                                           37
+#define WF_TX_DESCRIPTOR_TXP17_ADDR                                         148
+#define WF_TX_DESCRIPTOR_TXP17_MASK                                         0xffff0000 // 31-16
+#define WF_TX_DESCRIPTOR_TXP17_SHIFT                                        16
+// DW38
+// DO NOT process repeat field(txp[17])
+// DW39
+#define WF_TX_DESCRIPTOR_TXP18_DW                                           39
+#define WF_TX_DESCRIPTOR_TXP18_ADDR                                         156
+#define WF_TX_DESCRIPTOR_TXP18_MASK                                         0xffffffff // 31- 0
+#define WF_TX_DESCRIPTOR_TXP18_SHIFT                                        0
+// DW40
+// DO NOT process repeat field(txp[18])
+#define WF_TX_DESCRIPTOR_TXP19_DW                                           40
+#define WF_TX_DESCRIPTOR_TXP19_ADDR                                         160
+#define WF_TX_DESCRIPTOR_TXP19_MASK                                         0xffff0000 // 31-16
+#define WF_TX_DESCRIPTOR_TXP19_SHIFT                                        16
+// DW41
+// DO NOT process repeat field(txp[19])
+// DW42
+#define WF_TX_DESCRIPTOR_TXP20_DW                                           42
+#define WF_TX_DESCRIPTOR_TXP20_ADDR                                         168
+#define WF_TX_DESCRIPTOR_TXP20_MASK                                         0xffffffff // 31- 0
+#define WF_TX_DESCRIPTOR_TXP20_SHIFT                                        0
+// DW43
+// DO NOT process repeat field(txp[20])
+#define WF_TX_DESCRIPTOR_TXP21_DW                                           43
+#define WF_TX_DESCRIPTOR_TXP21_ADDR                                         172
+#define WF_TX_DESCRIPTOR_TXP21_MASK                                         0xffff0000 // 31-16
+#define WF_TX_DESCRIPTOR_TXP21_SHIFT                                        16
+// DW44
+// DO NOT process repeat field(txp[21])
+// DW45
+#define WF_TX_DESCRIPTOR_TXP22_DW                                           45
+#define WF_TX_DESCRIPTOR_TXP22_ADDR                                         180
+#define WF_TX_DESCRIPTOR_TXP22_MASK                                         0xffffffff // 31- 0
+#define WF_TX_DESCRIPTOR_TXP22_SHIFT                                        0
+// DW46
+// DO NOT process repeat field(txp[22])
+#define WF_TX_DESCRIPTOR_TXP23_DW                                           46
+#define WF_TX_DESCRIPTOR_TXP23_ADDR                                         184
+#define WF_TX_DESCRIPTOR_TXP23_MASK                                         0xffff0000 // 31-16
+#define WF_TX_DESCRIPTOR_TXP23_SHIFT                                        16
+// DW47
+// DO NOT process repeat field(txp[23])
+// DW48
+#define WF_TX_DESCRIPTOR_TXP24_DW                                           48
+#define WF_TX_DESCRIPTOR_TXP24_ADDR                                         192
+#define WF_TX_DESCRIPTOR_TXP24_MASK                                         0xffffffff // 31- 0
+#define WF_TX_DESCRIPTOR_TXP24_SHIFT                                        0
+// DW49
+// DO NOT process repeat field(txp[24])
+#define WF_TX_DESCRIPTOR_TXP25_DW                                           49
+#define WF_TX_DESCRIPTOR_TXP25_ADDR                                         196
+#define WF_TX_DESCRIPTOR_TXP25_MASK                                         0xffff0000 // 31-16
+#define WF_TX_DESCRIPTOR_TXP25_SHIFT                                        16
+// DW50
+// DO NOT process repeat field(txp[25])
+// DW51
+#define WF_TX_DESCRIPTOR_TXP26_DW                                           51
+#define WF_TX_DESCRIPTOR_TXP26_ADDR                                         204
+#define WF_TX_DESCRIPTOR_TXP26_MASK                                         0xffffffff // 31- 0
+#define WF_TX_DESCRIPTOR_TXP26_SHIFT                                        0
+// DW52
+// DO NOT process repeat field(txp[26])
+#define WF_TX_DESCRIPTOR_TXP27_DW                                           52
+#define WF_TX_DESCRIPTOR_TXP27_ADDR                                         208
+#define WF_TX_DESCRIPTOR_TXP27_MASK                                         0xffff0000 // 31-16
+#define WF_TX_DESCRIPTOR_TXP27_SHIFT                                        16
+// DW53
+// DO NOT process repeat field(txp[27])
+// DW54
+#define WF_TX_DESCRIPTOR_TXP28_DW                                           54
+#define WF_TX_DESCRIPTOR_TXP28_ADDR                                         216
+#define WF_TX_DESCRIPTOR_TXP28_MASK                                         0xffffffff // 31- 0
+#define WF_TX_DESCRIPTOR_TXP28_SHIFT                                        0
+// DW55
+// DO NOT process repeat field(txp[28])
+#define WF_TX_DESCRIPTOR_TXP29_DW                                           55
+#define WF_TX_DESCRIPTOR_TXP29_ADDR                                         220
+#define WF_TX_DESCRIPTOR_TXP29_MASK                                         0xffff0000 // 31-16
+#define WF_TX_DESCRIPTOR_TXP29_SHIFT                                        16
+// DW56
+// DO NOT process repeat field(txp[29])
+// DW57
+#define WF_TX_DESCRIPTOR_TXP30_DW                                           57
+#define WF_TX_DESCRIPTOR_TXP30_ADDR                                         228
+#define WF_TX_DESCRIPTOR_TXP30_MASK                                         0xffffffff // 31- 0
+#define WF_TX_DESCRIPTOR_TXP30_SHIFT                                        0
+// DW58
+// DO NOT process repeat field(txp[30])
+#define WF_TX_DESCRIPTOR_TXP31_DW                                           58
+#define WF_TX_DESCRIPTOR_TXP31_ADDR                                         232
+#define WF_TX_DESCRIPTOR_TXP31_MASK                                         0xffff0000 // 31-16
+#define WF_TX_DESCRIPTOR_TXP31_SHIFT                                        16
+// DW59
+// DO NOT process repeat field(txp[31])
+
+/* TXP PAO */
+#define HIF_TXP_V2_SIZE (24 * 4)
+/* DW0 */
+#define HIF_TXD_VERSION_SHIFT 19
+#define HIF_TXD_VERSION_MASK 0x00780000
+
+/* DW8 */
+#define HIF_TXP_PRIORITY_SHIFT 0
+#define HIF_TXP_PRIORITY_MASK 0x00000001
+#define HIF_TXP_FIXED_RATE_SHIFT 1
+#define HIF_TXP_FIXED_RATE_MASK 0x00000002
+#define HIF_TXP_TCP_SHIFT 2
+#define HIF_TXP_TCP_MASK 0x00000004
+#define HIF_TXP_NON_CIPHER_SHIFT 3
+#define HIF_TXP_NON_CIPHER_MASK 0x00000008
+#define HIF_TXP_VLAN_SHIFT 4
+#define HIF_TXP_VLAN_MASK 0x00000010
+#define HIF_TXP_BC_MC_FLAG_SHIFT 5
+#define HIF_TXP_BC_MC_FLAG_MASK 0x00000060
+#define HIF_TXP_FR_HOST_SHIFT 7
+#define HIF_TXP_FR_HOST_MASK 0x00000080
+#define HIF_TXP_ETYPE_SHIFT 8
+#define HIF_TXP_ETYPE_MASK 0x00000100
+#define HIF_TXP_TXP_AMSDU_SHIFT 9
+#define HIF_TXP_TXP_AMSDU_MASK 0x00000200
+#define HIF_TXP_TXP_MC_CLONE_SHIFT 10
+#define HIF_TXP_TXP_MC_CLONE_MASK 0x00000400
+#define HIF_TXP_TOKEN_ID_SHIFT 16
+#define HIF_TXP_TOKEN_ID_MASK 0xffff0000
+
+/* DW9 */
+#define HIF_TXP_BSS_IDX_SHIFT 0
+#define HIF_TXP_BSS_IDX_MASK 0x000000ff
+#define HIF_TXP_USER_PRIORITY_SHIFT 8
+#define HIF_TXP_USER_PRIORITY_MASK 0x0000ff00
+#define HIF_TXP_BUF_NUM_SHIFT 16
+#define HIF_TXP_BUF_NUM_MASK 0x001f0000
+#define HIF_TXP_MSDU_CNT_SHIFT 21
+#define HIF_TXP_MSDU_CNT_MASK 0x03e00000
+#define HIF_TXP_SRC_SHIFT 26
+#define HIF_TXP_SRC_MASK 0x0c000000
+
+/* DW10 */
+#define HIF_TXP_ETH_TYPE_SHIFT 0
+#define HIF_TXP_ETH_TYPE_MASK 0x0000ffff
+#define HIF_TXP_WLAN_IDX_SHIFT 16
+#define HIF_TXP_WLAN_IDX_MASK 0x0fff0000
+
+/* DW11 */
+#define HIF_TXP_PPE_INFO_SHIFT 0
+#define HIF_TXP_PPE_INFO_MASK 0xffffffff
+
+/* DW12 - DW31 */
+#define HIF_TXP_BUF_PTR0_L_SHIFT 0
+#define HIF_TXP_BUF_PTR0_L_MASK 0xffffffff
+#define HIF_TXP_BUF_LEN0_SHIFT 0
+#define HIF_TXP_BUF_LEN0_MASK 0x00000fff
+#define HIF_TXP_BUF_PTR0_H_SHIFT 12
+#define HIF_TXP_BUF_PTR0_H_MASK 0x0000f000
+#define HIF_TXP_BUF_LEN1_SHIFT 16
+#define HIF_TXP_BUF_LEN1_MASK 0x0fff0000
+#define HIF_TXP_BUF_PTR1_H_SHIFT 28
+#define HIF_TXP_BUF_PTR1_H_MASK 0xf0000000
+#define HIF_TXP_BUF_PTR1_L_SHIFT 0
+#define HIF_TXP_BUF_PTR1_L_MASK 0xffffffff
+
+/* DW31 */
+#define HIF_TXP_ML_SHIFT 16
+#define HIF_TXP_ML_MASK 0xffff0000
+
+/* UWTBL */
+#define MT_WF_UWTBL_BASE		0x820c4000
+#define MT_WF_UWTBL(ofs)		(MT_WF_UWTBL_BASE + (ofs))
+
+#define MT_WF_UWTBL_ITCR		MT_WF_UWTBL(0x130)
+#define MT_WF_UWTBL_ITCR0		MT_WF_UWTBL(0x138)
+#define MT_WF_UWTBL_ITCR1		MT_WF_UWTBL(0x13c)
+
+#define MT_WF_UWTBL_ITCR_SET		BIT(31)
+#define MT_WF_UWTBL_ITCR_INDEX		GENMASK(5, 0)
+
+/* RMAC */
+#define MT_WF_RMAC_SRAM_DATA0(_band)	MT_WF_RMAC(_band, 0x210)
+#define MT_WF_RMAC_SRAM_DATA1(_band)	MT_WF_RMAC(_band, 0x214)
+#define MT_WF_RMAC_SRAM_BITMAP0(_band)	MT_WF_RMAC(_band, 0x220)
+#define MT_WF_RMAC_SRAM_BITMAP1(_band)	MT_WF_RMAC(_band, 0x224)
+#define MT_WF_RMAC_MEM_CTRL(_band)	MT_WF_RMAC(_band, 0x228)
+
+#define MT_WF_RMAC_MEM_CRTL_TRIG	BIT(31)
+#define MT_WF_RMAC_MEM_CRTL_TDX		GENMASK(7, 0)
+
+/* AGG */
+#define MT_AGG_REMAP_CTRL(_band)	MT_WF_AGG(_band, 0x094)
+#define MT_AGG_REMAP_CTRL_OM_REMAP	GENMASK(5, 0)
+
+/* TMAC */
+#define MT_WF_TMAC_WMM0_OFFSET		0x0c4
+#define MT_WF_TMAC_WMM1_OFFSET		0x364
+#define MT_WF_TMAC_WMM2_OFFSET		0x36c
+#define MT_WF_TMAC_WMM3_OFFSET		0x374
+#define MT_WF_TMAC_WMM_TXOP_MASK	GENMASK(31, 16)
+#define MT_WF_TMAC_WMM_TXOP_SHIFT	16
+#endif
+
+#endif
diff --git a/mt7996/mtk_debugfs.c b/mt7996/mtk_debugfs.c
new file mode 100644
index 00000000..f01242de
--- /dev/null
+++ b/mt7996/mtk_debugfs.c
@@ -0,0 +1,4503 @@
+// SPDX-License-Identifier: ISC
+/*
+ * Copyright (C) 2023 MediaTek Inc.
+ */
+#include "mt7996.h"
+#include "../mt76.h"
+#include "mcu.h"
+#include "mac.h"
+#include "eeprom.h"
+#include "mtk_debug.h"
+#include "mtk_mcu.h"
+#include "coredump.h"
+
+#ifdef CONFIG_MTK_DEBUG
+
+#ifndef PKG_YEAR
+#define PKG_YEAR 0
+#endif
+
+#ifndef PKG_MONTH
+#define PKG_MONTH 0
+#endif
+
+/* AGG INFO */
+static int mt7996_agginfo_show(struct seq_file *s, void *data)
+{
+	struct mt7996_phy *phy = s->private;
+	struct mt7996_dev *dev = phy->dev;
+	u64 total_burst, total_ampdu, ampdu_cnt[16];
+	u32 value, idx, row_idx, col_idx, start_range, agg_rang_sel[16], burst_cnt[16], band_offset = 0;
+	u8 partial_str[16] = {}, full_str[64] = {};
+	u8 band_idx = phy->mt76->band_idx;
+
+	switch (band_idx) {
+	case 0:
+		band_offset = 0;
+		break;
+	case 1:
+		band_offset = BN1_WF_AGG_TOP_BASE - BN0_WF_AGG_TOP_BASE;
+		break;
+	case 2:
+		band_offset = IP1_BN0_WF_AGG_TOP_BASE - BN0_WF_AGG_TOP_BASE;
+		break;
+	default:
+		return 0;
+	}
+
+	seq_printf(s, "Band %d AGG Status\n", band_idx);
+	seq_printf(s, "===============================\n");
+	value = mt76_rr(dev, BN0_WF_AGG_TOP_AALCR0_ADDR + band_offset);
+	seq_printf(s, "AC00 Agg limit = %d\t", (value & BN0_WF_AGG_TOP_AALCR0_AC00_AGG_LIMIT_MASK) >>  BN0_WF_AGG_TOP_AALCR0_AC00_AGG_LIMIT_SHFT);
+	seq_printf(s, "AC01 Agg limit = %d\t", (value & BN0_WF_AGG_TOP_AALCR0_AC01_AGG_LIMIT_MASK) >>  BN0_WF_AGG_TOP_AALCR0_AC01_AGG_LIMIT_SHFT);
+	value = mt76_rr(dev, BN0_WF_AGG_TOP_AALCR1_ADDR + band_offset);
+	seq_printf(s, "AC02 Agg limit = %d\t", (value & BN0_WF_AGG_TOP_AALCR1_AC02_AGG_LIMIT_MASK) >>  BN0_WF_AGG_TOP_AALCR1_AC02_AGG_LIMIT_SHFT);
+	seq_printf(s, "AC03 Agg limit = %d\t", (value & BN0_WF_AGG_TOP_AALCR1_AC03_AGG_LIMIT_MASK) >>  BN0_WF_AGG_TOP_AALCR1_AC03_AGG_LIMIT_SHFT);
+	value = mt76_rr(dev, BN0_WF_AGG_TOP_AALCR2_ADDR + band_offset);
+	seq_printf(s, "AC10 Agg limit = %d\t", (value & BN0_WF_AGG_TOP_AALCR2_AC10_AGG_LIMIT_MASK) >>  BN0_WF_AGG_TOP_AALCR2_AC10_AGG_LIMIT_SHFT);
+	seq_printf(s, "AC11 Agg limit = %d\t", (value & BN0_WF_AGG_TOP_AALCR2_AC11_AGG_LIMIT_MASK) >>  BN0_WF_AGG_TOP_AALCR2_AC11_AGG_LIMIT_SHFT);
+	value = mt76_rr(dev, BN0_WF_AGG_TOP_AALCR3_ADDR + band_offset);
+	seq_printf(s, "AC12 Agg limit = %d\t", (value & BN0_WF_AGG_TOP_AALCR3_AC12_AGG_LIMIT_MASK) >>  BN0_WF_AGG_TOP_AALCR3_AC12_AGG_LIMIT_SHFT);
+	seq_printf(s, "AC13 Agg limit = %d\t", (value & BN0_WF_AGG_TOP_AALCR3_AC13_AGG_LIMIT_MASK) >>  BN0_WF_AGG_TOP_AALCR3_AC13_AGG_LIMIT_SHFT);
+	value = mt76_rr(dev, BN0_WF_AGG_TOP_AALCR4_ADDR + band_offset);
+	seq_printf(s, "AC20 Agg limit = %d\t", (value & BN0_WF_AGG_TOP_AALCR4_AC20_AGG_LIMIT_MASK) >>  BN0_WF_AGG_TOP_AALCR4_AC20_AGG_LIMIT_SHFT);
+	seq_printf(s, "AC21 Agg limit = %d\t", (value & BN0_WF_AGG_TOP_AALCR4_AC21_AGG_LIMIT_MASK) >>  BN0_WF_AGG_TOP_AALCR4_AC21_AGG_LIMIT_SHFT);
+	value = mt76_rr(dev, BN0_WF_AGG_TOP_AALCR5_ADDR + band_offset);
+	seq_printf(s, "AC22 Agg limit = %d\t", (value & BN0_WF_AGG_TOP_AALCR5_AC22_AGG_LIMIT_MASK) >>  BN0_WF_AGG_TOP_AALCR5_AC22_AGG_LIMIT_SHFT);
+	seq_printf(s, "AC23 Agg limit = %d\t", (value & BN0_WF_AGG_TOP_AALCR5_AC23_AGG_LIMIT_MASK) >>  BN0_WF_AGG_TOP_AALCR5_AC23_AGG_LIMIT_SHFT);
+	value = mt76_rr(dev, BN0_WF_AGG_TOP_AALCR6_ADDR + band_offset);
+	seq_printf(s, "AC30 Agg limit = %d\t", (value & BN0_WF_AGG_TOP_AALCR6_AC30_AGG_LIMIT_MASK) >>  BN0_WF_AGG_TOP_AALCR6_AC30_AGG_LIMIT_SHFT);
+	seq_printf(s, "AC31 Agg limit = %d\t", (value & BN0_WF_AGG_TOP_AALCR6_AC31_AGG_LIMIT_MASK) >>  BN0_WF_AGG_TOP_AALCR6_AC31_AGG_LIMIT_SHFT);
+	value = mt76_rr(dev, BN0_WF_AGG_TOP_AALCR7_ADDR + band_offset);
+	seq_printf(s, "AC32 Agg limit = %d\t", (value & BN0_WF_AGG_TOP_AALCR7_AC32_AGG_LIMIT_MASK) >>  BN0_WF_AGG_TOP_AALCR7_AC32_AGG_LIMIT_SHFT);
+	seq_printf(s, "AC33 Agg limit = %d\t", (value & BN0_WF_AGG_TOP_AALCR7_AC33_AGG_LIMIT_MASK) >>  BN0_WF_AGG_TOP_AALCR7_AC33_AGG_LIMIT_SHFT);
+
+	switch (band_idx) {
+	case 0:
+		band_offset = 0;
+		break;
+	case 1:
+		band_offset = BN1_WF_MIB_TOP_BASE - BN0_WF_MIB_TOP_BASE;
+		break;
+	case 2:
+		band_offset = IP1_BN0_WF_MIB_TOP_BASE - BN0_WF_MIB_TOP_BASE;
+		break;
+	default:
+		return 0;
+	}
+
+	seq_printf(s, "===AMPDU Related Counters===\n");
+
+	value = mt76_rr(dev, BN0_WF_MIB_TOP_TRARC0_ADDR + band_offset);
+	agg_rang_sel[0] = (value & BN0_WF_MIB_TOP_TRARC0_AGG_RANG_SEL_0_MASK) >> BN0_WF_MIB_TOP_TRARC0_AGG_RANG_SEL_0_SHFT;
+	agg_rang_sel[1] = (value & BN0_WF_MIB_TOP_TRARC0_AGG_RANG_SEL_1_MASK) >> BN0_WF_MIB_TOP_TRARC0_AGG_RANG_SEL_1_SHFT;
+	value = mt76_rr(dev, BN0_WF_MIB_TOP_TRARC1_ADDR + band_offset);
+	agg_rang_sel[2] = (value & BN0_WF_MIB_TOP_TRARC1_AGG_RANG_SEL_2_MASK) >> BN0_WF_MIB_TOP_TRARC1_AGG_RANG_SEL_2_SHFT;
+	agg_rang_sel[3] = (value & BN0_WF_MIB_TOP_TRARC1_AGG_RANG_SEL_3_MASK) >> BN0_WF_MIB_TOP_TRARC1_AGG_RANG_SEL_3_SHFT;
+	value = mt76_rr(dev, BN0_WF_MIB_TOP_TRARC2_ADDR + band_offset);
+	agg_rang_sel[4] = (value & BN0_WF_MIB_TOP_TRARC2_AGG_RANG_SEL_4_MASK) >> BN0_WF_MIB_TOP_TRARC2_AGG_RANG_SEL_4_SHFT;
+	agg_rang_sel[5] = (value & BN0_WF_MIB_TOP_TRARC2_AGG_RANG_SEL_5_MASK) >> BN0_WF_MIB_TOP_TRARC2_AGG_RANG_SEL_5_SHFT;
+	value = mt76_rr(dev, BN0_WF_MIB_TOP_TRARC3_ADDR + band_offset);
+	agg_rang_sel[6] = (value & BN0_WF_MIB_TOP_TRARC3_AGG_RANG_SEL_6_MASK) >> BN0_WF_MIB_TOP_TRARC3_AGG_RANG_SEL_6_SHFT;
+	agg_rang_sel[7] = (value & BN0_WF_MIB_TOP_TRARC3_AGG_RANG_SEL_7_MASK) >> BN0_WF_MIB_TOP_TRARC3_AGG_RANG_SEL_7_SHFT;
+	value = mt76_rr(dev, BN0_WF_MIB_TOP_TRARC4_ADDR + band_offset);
+	agg_rang_sel[8] = (value & BN0_WF_MIB_TOP_TRARC4_AGG_RANG_SEL_8_MASK) >> BN0_WF_MIB_TOP_TRARC4_AGG_RANG_SEL_8_SHFT;
+	agg_rang_sel[9] = (value & BN0_WF_MIB_TOP_TRARC4_AGG_RANG_SEL_9_MASK) >> BN0_WF_MIB_TOP_TRARC4_AGG_RANG_SEL_9_SHFT;
+	value = mt76_rr(dev, BN0_WF_MIB_TOP_TRARC5_ADDR + band_offset);
+	agg_rang_sel[10] = (value & BN0_WF_MIB_TOP_TRARC5_AGG_RANG_SEL_10_MASK) >> BN0_WF_MIB_TOP_TRARC5_AGG_RANG_SEL_10_SHFT;
+	agg_rang_sel[11] = (value & BN0_WF_MIB_TOP_TRARC5_AGG_RANG_SEL_11_MASK) >> BN0_WF_MIB_TOP_TRARC5_AGG_RANG_SEL_11_SHFT;
+	value = mt76_rr(dev, BN0_WF_MIB_TOP_TRARC6_ADDR + band_offset);
+	agg_rang_sel[12] = (value & BN0_WF_MIB_TOP_TRARC6_AGG_RANG_SEL_12_MASK) >> BN0_WF_MIB_TOP_TRARC6_AGG_RANG_SEL_12_SHFT;
+	agg_rang_sel[13] = (value & BN0_WF_MIB_TOP_TRARC6_AGG_RANG_SEL_13_MASK) >> BN0_WF_MIB_TOP_TRARC6_AGG_RANG_SEL_13_SHFT;
+	value = mt76_rr(dev, BN0_WF_MIB_TOP_TRARC7_ADDR + band_offset);
+	agg_rang_sel[14] = (value & BN0_WF_MIB_TOP_TRARC7_AGG_RANG_SEL_14_MASK) >> BN0_WF_MIB_TOP_TRARC7_AGG_RANG_SEL_14_SHFT;
+
+	burst_cnt[0] = mt76_rr(dev, BN0_WF_MIB_TOP_TRDR0_ADDR + band_offset);
+	burst_cnt[1] = mt76_rr(dev, BN0_WF_MIB_TOP_TRDR1_ADDR + band_offset);
+	burst_cnt[2] = mt76_rr(dev, BN0_WF_MIB_TOP_TRDR2_ADDR + band_offset);
+	burst_cnt[3] = mt76_rr(dev, BN0_WF_MIB_TOP_TRDR3_ADDR + band_offset);
+	burst_cnt[4] = mt76_rr(dev, BN0_WF_MIB_TOP_TRDR4_ADDR + band_offset);
+	burst_cnt[5] = mt76_rr(dev, BN0_WF_MIB_TOP_TRDR5_ADDR + band_offset);
+	burst_cnt[6] = mt76_rr(dev, BN0_WF_MIB_TOP_TRDR6_ADDR + band_offset);
+	burst_cnt[7] = mt76_rr(dev, BN0_WF_MIB_TOP_TRDR7_ADDR + band_offset);
+	burst_cnt[8] = mt76_rr(dev, BN0_WF_MIB_TOP_TRDR8_ADDR + band_offset);
+	burst_cnt[9] = mt76_rr(dev, BN0_WF_MIB_TOP_TRDR9_ADDR + band_offset);
+	burst_cnt[10] = mt76_rr(dev, BN0_WF_MIB_TOP_TRDR10_ADDR + band_offset);
+	burst_cnt[11] = mt76_rr(dev, BN0_WF_MIB_TOP_TRDR11_ADDR + band_offset);
+	burst_cnt[12] = mt76_rr(dev, BN0_WF_MIB_TOP_TRDR12_ADDR + band_offset);
+	burst_cnt[13] = mt76_rr(dev, BN0_WF_MIB_TOP_TRDR13_ADDR + band_offset);
+	burst_cnt[14] = mt76_rr(dev, BN0_WF_MIB_TOP_TRDR14_ADDR + band_offset);
+	burst_cnt[15] = mt76_rr(dev, BN0_WF_MIB_TOP_TRDR15_ADDR + band_offset);
+
+	start_range = 1;
+	total_burst = 0;
+	total_ampdu = 0;
+	agg_rang_sel[15] = 1023;
+
+	/* Need to add 1 after read from AGG_RANG_SEL CR */
+	for (idx = 0; idx < 16; idx++) {
+		agg_rang_sel[idx]++;
+		total_burst += burst_cnt[idx];
+
+		if (start_range == agg_rang_sel[idx])
+			ampdu_cnt[idx] = (u64) start_range * burst_cnt[idx];
+		else
+			ampdu_cnt[idx] = (u64) ((start_range + agg_rang_sel[idx]) >> 1) * burst_cnt[idx];
+
+		start_range = agg_rang_sel[idx] + 1;
+		total_ampdu += ampdu_cnt[idx];
+	}
+
+	start_range = 1;
+	sprintf(full_str, "%13s ", "Tx Agg Range:");
+
+	for (row_idx = 0; row_idx < 4; row_idx++) {
+		for (col_idx = 0; col_idx < 4; col_idx++, idx++) {
+			idx = 4 * row_idx + col_idx;
+
+			if (start_range == agg_rang_sel[idx])
+				sprintf(partial_str, "%d", agg_rang_sel[idx]);
+			else
+				sprintf(partial_str, "%d~%d", start_range, agg_rang_sel[idx]);
+
+			start_range = agg_rang_sel[idx] + 1;
+			sprintf(full_str + strlen(full_str), "%-11s ", partial_str);
+		}
+
+		idx = 4 * row_idx;
+
+		seq_printf(s, "%s\n", full_str);
+		seq_printf(s, "%13s 0x%-9x 0x%-9x 0x%-9x 0x%-9x\n",
+			row_idx ? "" : "Burst count:",
+			burst_cnt[idx], burst_cnt[idx + 1],
+			burst_cnt[idx + 2], burst_cnt[idx + 3]);
+
+		if (total_burst != 0) {
+			if (row_idx == 0)
+				sprintf(full_str, "%13s ",
+					"Burst ratio:");
+			else
+				sprintf(full_str, "%13s ", "");
+
+			for (col_idx = 0; col_idx < 4; col_idx++) {
+				u64 count = (u64) burst_cnt[idx + col_idx] * 100;
+
+				sprintf(partial_str, "(%llu%%)",
+					div64_u64(count, total_burst));
+				sprintf(full_str + strlen(full_str),
+					"%-11s ", partial_str);
+			}
+
+			seq_printf(s, "%s\n", full_str);
+
+			if (row_idx == 0)
+				sprintf(full_str, "%13s ",
+					"MDPU ratio:");
+			else
+				sprintf(full_str, "%13s ", "");
+
+			for (col_idx = 0; col_idx < 4; col_idx++) {
+				u64 count = ampdu_cnt[idx + col_idx] * 100;
+
+				sprintf(partial_str, "(%llu%%)",
+					div64_u64(count, total_ampdu));
+				sprintf(full_str + strlen(full_str),
+					"%-11s ", partial_str);
+			}
+
+			seq_printf(s, "%s\n", full_str);
+		}
+
+		sprintf(full_str, "%13s ", "");
+	}
+
+	return 0;
+}
+DEFINE_SHOW_ATTRIBUTE(mt7996_agginfo);
+
+/* AMSDU INFO */
+static int mt7996_amsdu_result_read(struct seq_file *s, void *data)
+{
+	struct mt7996_dev *dev = dev_get_drvdata(s->private);
+	struct mt7996_phy *phy = &dev->phy;
+	struct mt76_mib_stats *mib = &phy->mib;
+	static u32 tx_amsdu_last[MT76_MAX_AMSDU_NUM] = {0};
+	static u32 tx_amsdu_cnt_last = 0;
+	u32 tx_amsdu, tx_amsdu_cnt, ratio;
+	int i;
+
+	mutex_lock(&dev->mt76.mutex);
+
+	mt7996_mac_update_stats(phy);
+
+	tx_amsdu_cnt = mib->tx_amsdu_cnt - tx_amsdu_cnt_last;
+
+	seq_puts(s, "Tx MSDU statistics:\n");
+	for (i = 0; i < ARRAY_SIZE(mib->tx_amsdu); i++) {
+		tx_amsdu = mib->tx_amsdu[i] - tx_amsdu_last[i];
+		ratio = tx_amsdu_cnt ? tx_amsdu * 100 / tx_amsdu_cnt : 0;
+
+		seq_printf(s, "AMSDU pack count of %d MSDU in TXD: %8d (%3d%%)\n",
+			   i + 1, tx_amsdu, ratio);
+
+		tx_amsdu_last[i] = mib->tx_amsdu[i];
+	}
+
+	tx_amsdu_cnt_last = mib->tx_amsdu_cnt;
+
+	mutex_unlock(&dev->mt76.mutex);
+
+	return 0;
+}
+
+/* DBG MODLE */
+static int
+mt7996_fw_debug_module_set(void *data, u64 module)
+{
+	struct mt7996_dev *dev = data;
+
+	dev->dbg.fw_dbg_module = module;
+	return 0;
+}
+
+static int
+mt7996_fw_debug_module_get(void *data, u64 *module)
+{
+	struct mt7996_dev *dev = data;
+
+	*module = dev->dbg.fw_dbg_module;
+	return 0;
+}
+
+DEFINE_DEBUGFS_ATTRIBUTE(fops_fw_debug_module, mt7996_fw_debug_module_get,
+			 mt7996_fw_debug_module_set, "%lld\n");
+
+static int
+mt7996_fw_debug_level_set(void *data, u64 level)
+{
+	struct mt7996_dev *dev = data;
+
+	dev->dbg.fw_dbg_lv = level;
+	mt7996_mcu_fw_dbg_ctrl(dev, dev->dbg.fw_dbg_module, dev->dbg.fw_dbg_lv);
+	return 0;
+}
+
+static int
+mt7996_fw_debug_level_get(void *data, u64 *level)
+{
+	struct mt7996_dev *dev = data;
+
+	*level = dev->dbg.fw_dbg_lv;
+	return 0;
+}
+
+DEFINE_DEBUGFS_ATTRIBUTE(fops_fw_debug_level, mt7996_fw_debug_level_get,
+			 mt7996_fw_debug_level_set, "%lld\n");
+
+/* usage: echo 0x[arg3][arg2][arg1] > fw_wa_set */
+static int
+mt7996_wa_set(void *data, u64 val)
+{
+	struct mt7996_dev *dev = data;
+	u32 arg1, arg2, arg3;
+
+	arg1 = FIELD_GET(GENMASK_ULL(7, 0), val);
+	arg2 = FIELD_GET(GENMASK_ULL(15, 8), val);
+	arg3 = FIELD_GET(GENMASK_ULL(23, 16), val);
+
+	return mt7996_mcu_wa_cmd(dev, MCU_WA_PARAM_CMD(SET),
+				arg1, arg2, arg3);
+}
+
+DEFINE_DEBUGFS_ATTRIBUTE(fops_wa_set, NULL, mt7996_wa_set,
+			 "0x%llx\n");
+
+/* usage: echo 0x[arg3][arg2][arg1] > fw_wa_query */
+static int
+mt7996_wa_query(void *data, u64 val)
+{
+	struct mt7996_dev *dev = data;
+	u32 arg1, arg2, arg3;
+
+	arg1 = FIELD_GET(GENMASK_ULL(7, 0), val);
+	arg2 = FIELD_GET(GENMASK_ULL(15, 8), val);
+	arg3 = FIELD_GET(GENMASK_ULL(23, 16), val);
+
+	return mt7996_mcu_wa_cmd(dev, MCU_WA_PARAM_CMD(QUERY),
+				arg1, arg2, arg3);
+	return 0;
+}
+
+DEFINE_DEBUGFS_ATTRIBUTE(fops_wa_query, NULL, mt7996_wa_query,
+			 "0x%llx\n");
+
+static int mt7996_dump_version(struct seq_file *s, void *data)
+{
+#define MAX_ADIE_NUM	3
+	struct mt7996_dev *dev = dev_get_drvdata(s->private);
+	u32 regval;
+	u16 adie_chip_id, adie_chip_ver;
+	int adie_idx;
+	static const char * const fem_type[] = {
+		[MT7996_FEM_EXT] = "eFEM",
+		[MT7996_FEM_INT] = "iFEM",
+		[MT7996_FEM_MIX] = "mixed FEM",
+	};
+
+	seq_printf(s, "Version: 4.3.%02d.%02d\n", PKG_YEAR, PKG_MONTH);
+
+	if (!test_bit(MT76_STATE_MCU_RUNNING, &dev->mphy.state))
+		return 0;
+
+	seq_printf(s, "Rom Patch Build Time: %.16s\n", dev->patch_build_date);
+	seq_printf(s, "WM Patch Build Time: %.15s, Mode: %s\n",
+		   dev->ram_build_date[MT7996_RAM_TYPE_WM],
+		   dev->testmode_enable ? "Testmode" : "Normal mode");
+	seq_printf(s, "WA Patch Build Time: %.15s\n",
+		   dev->ram_build_date[MT7996_RAM_TYPE_WA]);
+	seq_printf(s, "DSP Patch Build Time: %.15s\n",
+		   dev->ram_build_date[MT7996_RAM_TYPE_DSP]);
+	for (adie_idx = 0; adie_idx < MAX_ADIE_NUM; adie_idx++) {
+		mt7996_mcu_rf_regval(dev, MT_ADIE_CHIP_ID(adie_idx), &regval, false);
+		adie_chip_id = FIELD_GET(MT_ADIE_CHIP_ID_MASK, regval);
+		adie_chip_ver = FIELD_GET(MT_ADIE_VERSION_MASK, regval);
+		if (adie_chip_id)
+			seq_printf(s, "Adie %d: ID = 0x%04x, Ver = 0x%04x\n",
+				   adie_idx, adie_chip_id, adie_chip_ver);
+		else
+			seq_printf(s, "Adie %d: ID = N/A, Ver = N/A\n", adie_idx);
+	}
+	seq_printf(s, "FEM type: %s\n", fem_type[dev->var.fem]);
+
+	return 0;
+}
+
+/* fw wm call trace info dump */
+void mt7996_show_lp_history(struct seq_file *s, u32 type)
+{
+	struct mt7996_dev *dev = dev_get_drvdata(s->private);
+	struct mt7996_crash_data *crash_data;
+	struct mt7996_coredump *dump;
+	u64 now = 0;
+	int i = 0;
+	u8 fw_type = !!type;
+
+	mutex_lock(&dev->dump_mutex);
+
+	crash_data = mt7996_coredump_new(dev, fw_type);
+	if (!crash_data) {
+		mutex_unlock(&dev->dump_mutex);
+		seq_printf(s, "the coredump is disable!\n");
+		return;
+	}
+	mutex_unlock(&dev->dump_mutex);
+
+	dump = mt7996_coredump_build(dev, fw_type, false);
+	if (!dump) {
+		seq_printf(s, "no call stack data found!\n");
+		return;
+	}
+
+	seq_printf(s, "\x1b[32m%s log output\x1b[0m\n", dump->fw_type);
+	seq_printf(s, "\x1b[32mfw status: %s\n", dump->fw_state);
+	/* PC log */
+	now = jiffies;
+	for (i = 0; i < 10; i++)
+		seq_printf(s, "\tCurrent PC=%x\n", dump->pc_cur[i]);
+
+	seq_printf(s, "PC log contorl=0x%x(T=%llu)(latest PC index = 0x%x)\n",
+		dump->pc_dbg_ctrl, now, dump->pc_cur_idx);
+	for (i = 0; i < 32; i++)
+		seq_printf(s, "\tPC log(%d)=0x%08x\n", i, dump->pc_stack[i]);
+
+	/* LR log */
+	now = jiffies;
+	seq_printf(s, "\nLR log contorl=0x%x(T=%llu)(latest LR index = 0x%x)\n",
+		dump->lr_dbg_ctrl, now, dump->lr_cur_idx);
+	for (i = 0; i < 32; i++)
+		seq_printf(s, "\tLR log(%d)=0x%08x\n", i, dump->lr_stack[i]);
+
+	vfree(dump);
+}
+
+static int mt7996_fw_wa_info_read(struct seq_file *s, void *data)
+{
+	seq_printf(s, "======[ShowPcLpHistory]======\n");
+	mt7996_show_lp_history(s, MT7996_RAM_TYPE_WA);
+	seq_printf(s, "======[End ShowPcLpHistory]==\n");
+
+	return 0;
+}
+
+static int mt7996_fw_wm_info_read(struct seq_file *s, void *data)
+{
+	seq_printf(s, "======[ShowPcLpHistory]======\n");
+	mt7996_show_lp_history(s, MT7996_RAM_TYPE_WM);
+	seq_printf(s, "======[End ShowPcLpHistory]==\n");
+
+	return 0;
+}
+
+/* dma info dump */
+static void
+dump_dma_tx_ring_info(struct seq_file *s, struct mt7996_dev *dev,  char *str1, char *str2, u32 ring_base)
+{
+	u32 base, cnt, cidx, didx, queue_cnt;
+
+	base= mt76_rr(dev, ring_base);
+	cnt = mt76_rr(dev, ring_base + 4);
+	cidx = mt76_rr(dev, ring_base + 8);
+	didx = mt76_rr(dev, ring_base + 12);
+	queue_cnt = (cidx >= didx) ? (cidx - didx) : (cidx - didx + cnt);
+
+	seq_printf(s, "%20s %6s %10x %15x %10x %10x %10x\n", str1, str2, base, cnt, cidx, didx, queue_cnt);
+}
+
+static void
+dump_dma_rx_ring_info(struct seq_file *s, struct mt7996_dev *dev,  char *str1, char *str2, u32 ring_base)
+{
+	u32 base, ctrl1, cnt, cidx, didx, queue_cnt;
+
+	base= mt76_rr(dev, ring_base);
+	ctrl1 = mt76_rr(dev, ring_base + 4);
+	cidx = mt76_rr(dev, ring_base + 8) & 0xfff;
+	didx = mt76_rr(dev, ring_base + 12) & 0xfff;
+	cnt = ctrl1 & 0xfff;
+	queue_cnt = (didx > cidx) ? (didx - cidx - 1) : (didx - cidx + cnt - 1);
+
+	seq_printf(s, "%20s %6s %10x %10x(%3x) %10x %10x %10x\n",
+		   str1, str2, base, ctrl1, cnt, cidx, didx, queue_cnt);
+}
+
+static void
+mt7996_show_dma_info(struct seq_file *s, struct mt7996_dev *dev)
+{
+	u32 sys_ctrl[10];
+
+	/* HOST DMA0 information */
+	sys_ctrl[0] = mt76_rr(dev, WF_WFDMA_HOST_DMA0_HOST_INT_STA_ADDR);
+	sys_ctrl[1] = mt76_rr(dev, WF_WFDMA_HOST_DMA0_HOST_INT_ENA_ADDR);
+	sys_ctrl[2] = mt76_rr(dev, WF_WFDMA_HOST_DMA0_WPDMA_GLO_CFG_ADDR);
+
+	seq_printf(s, "HOST_DMA Configuration\n");
+	seq_printf(s, "%10s %10s %10s %10s %10s %10s\n",
+		"DMA", "IntCSR", "IntMask", "Glocfg", "Tx/RxEn", "Tx/RxBusy");
+	seq_printf(s, "%10s %10x %10x %10x %4x/%5x %4x/%5x\n",
+		"DMA0", sys_ctrl[0], sys_ctrl[1], sys_ctrl[2],
+		(sys_ctrl[2] & WF_WFDMA_HOST_DMA0_WPDMA_GLO_CFG_TX_DMA_EN_MASK)
+			>> WF_WFDMA_HOST_DMA0_WPDMA_GLO_CFG_TX_DMA_EN_SHFT,
+		(sys_ctrl[2] & WF_WFDMA_HOST_DMA0_WPDMA_GLO_CFG_RX_DMA_EN_MASK)
+			>> WF_WFDMA_HOST_DMA0_WPDMA_GLO_CFG_RX_DMA_EN_SHFT,
+		(sys_ctrl[2] & WF_WFDMA_HOST_DMA0_WPDMA_GLO_CFG_TX_DMA_BUSY_MASK)
+			>> WF_WFDMA_HOST_DMA0_WPDMA_GLO_CFG_TX_DMA_BUSY_SHFT,
+		(sys_ctrl[2] & WF_WFDMA_HOST_DMA0_WPDMA_GLO_CFG_RX_DMA_BUSY_MASK)
+			>> WF_WFDMA_HOST_DMA0_WPDMA_GLO_CFG_RX_DMA_BUSY_SHFT);
+
+	if (dev->hif2) {
+		/* HOST DMA1 information */
+		sys_ctrl[0] = mt76_rr(dev, WF_WFDMA_HOST_DMA0_PCIE1_HOST_INT_STA_ADDR);
+		sys_ctrl[1] = mt76_rr(dev, WF_WFDMA_HOST_DMA0_PCIE1_HOST_INT_ENA_ADDR);
+		sys_ctrl[2] = mt76_rr(dev, WF_WFDMA_HOST_DMA0_PCIE1_WPDMA_GLO_CFG_ADDR);
+
+		seq_printf(s, "%10s %10x %10x %10x %4x/%5x %4x/%5x\n",
+			"DMA0P1", sys_ctrl[0], sys_ctrl[1], sys_ctrl[2],
+			(sys_ctrl[2] & WF_WFDMA_HOST_DMA0_PCIE1_WPDMA_GLO_CFG_TX_DMA_EN_MASK)
+				>> WF_WFDMA_HOST_DMA0_PCIE1_WPDMA_GLO_CFG_TX_DMA_EN_SHFT,
+			(sys_ctrl[2] & WF_WFDMA_HOST_DMA0_PCIE1_WPDMA_GLO_CFG_RX_DMA_EN_MASK)
+				>> WF_WFDMA_HOST_DMA0_PCIE1_WPDMA_GLO_CFG_RX_DMA_EN_SHFT,
+			(sys_ctrl[2] & WF_WFDMA_HOST_DMA0_PCIE1_WPDMA_GLO_CFG_TX_DMA_BUSY_MASK)
+				>> WF_WFDMA_HOST_DMA0_PCIE1_WPDMA_GLO_CFG_TX_DMA_BUSY_SHFT,
+			(sys_ctrl[2] & WF_WFDMA_HOST_DMA0_PCIE1_WPDMA_GLO_CFG_RX_DMA_BUSY_MASK)
+				>> WF_WFDMA_HOST_DMA0_PCIE1_WPDMA_GLO_CFG_RX_DMA_BUSY_SHFT);
+	}
+
+	seq_printf(s, "HOST_DMA0 Ring Configuration\n");
+	seq_printf(s, "%20s %6s %10s %15s %10s %10s %10s\n",
+		"Name", "Used", "Base", "Ctrl1(Cnt)", "CIDX", "DIDX", "QCnt");
+	dump_dma_tx_ring_info(s, dev, "T0:TXD0(H2MAC)", "STA",
+		WF_WFDMA_HOST_DMA0_WPDMA_TX_RING0_CTRL0_ADDR);
+	dump_dma_tx_ring_info(s, dev, "T1:TXD1(H2MAC)", "STA",
+		WF_WFDMA_HOST_DMA0_WPDMA_TX_RING1_CTRL0_ADDR);
+	dump_dma_tx_ring_info(s, dev, "T2:TXD2(H2MAC)", "STA",
+		WF_WFDMA_HOST_DMA0_WPDMA_TX_RING2_CTRL0_ADDR);
+	dump_dma_tx_ring_info(s, dev, "T3:", "STA",
+		WF_WFDMA_HOST_DMA0_WPDMA_TX_RING3_CTRL0_ADDR);
+	dump_dma_tx_ring_info(s, dev, "T4:", "STA",
+		WF_WFDMA_HOST_DMA0_WPDMA_TX_RING4_CTRL0_ADDR);
+	dump_dma_tx_ring_info(s, dev, "T5:", "STA",
+		WF_WFDMA_HOST_DMA0_WPDMA_TX_RING5_CTRL0_ADDR);
+	dump_dma_tx_ring_info(s, dev, "T6:", "STA",
+		WF_WFDMA_HOST_DMA0_WPDMA_TX_RING6_CTRL0_ADDR);
+	dump_dma_tx_ring_info(s, dev, "T16:FWDL", "Both",
+		WF_WFDMA_HOST_DMA0_WPDMA_TX_RING16_CTRL0_ADDR);
+	dump_dma_tx_ring_info(s, dev, "T17:Cmd(H2WM)", "Both",
+		WF_WFDMA_HOST_DMA0_WPDMA_TX_RING17_CTRL0_ADDR);
+	dump_dma_tx_ring_info(s, dev, "T18:TXD0(H2WA)", "AP",
+		WF_WFDMA_HOST_DMA0_WPDMA_TX_RING18_CTRL0_ADDR);
+	dump_dma_tx_ring_info(s, dev, "T19:TXD1(H2WA)", "AP",
+		WF_WFDMA_HOST_DMA0_WPDMA_TX_RING19_CTRL0_ADDR);
+	dump_dma_tx_ring_info(s, dev, "T20:Cmd(H2WA)", "AP",
+		WF_WFDMA_HOST_DMA0_WPDMA_TX_RING20_CTRL0_ADDR);
+	dump_dma_tx_ring_info(s, dev, "T21:TXD2(H2WA)", "AP",
+		WF_WFDMA_HOST_DMA0_WPDMA_TX_RING21_CTRL0_ADDR);
+	dump_dma_tx_ring_info(s, dev, "T22:TXD3(H2WA)", "AP",
+		WF_WFDMA_HOST_DMA0_WPDMA_TX_RING22_CTRL0_ADDR);
+
+
+	dump_dma_rx_ring_info(s, dev, "R0:Event(WM2H)", "Both",
+		WF_WFDMA_HOST_DMA0_WPDMA_RX_RING0_CTRL0_ADDR);
+	dump_dma_rx_ring_info(s, dev, "R1:Event(WA2H)", "AP",
+		WF_WFDMA_HOST_DMA0_WPDMA_RX_RING1_CTRL0_ADDR);
+	dump_dma_rx_ring_info(s, dev, "R2:TxDone0(WA2H)", "AP",
+		WF_WFDMA_HOST_DMA0_WPDMA_RX_RING2_CTRL0_ADDR);
+	dump_dma_rx_ring_info(s, dev, "R3:TxDone1(WA2H)", "AP",
+		WF_WFDMA_HOST_DMA0_WPDMA_RX_RING3_CTRL0_ADDR);
+	dump_dma_rx_ring_info(s, dev, "R4:Data0(MAC2H)", "Both",
+		WF_WFDMA_HOST_DMA0_WPDMA_RX_RING4_CTRL0_ADDR);
+	dump_dma_rx_ring_info(s, dev, "R5:Data1(MAC2H)", "Both",
+		WF_WFDMA_HOST_DMA0_WPDMA_RX_RING5_CTRL0_ADDR);
+	if (is_mt7996(&dev->mt76))
+		dump_dma_rx_ring_info(s, dev, "R6:BUF1(MAC2H)", "Both",
+			WF_WFDMA_HOST_DMA0_WPDMA_RX_RING6_CTRL0_ADDR);
+	else
+		dump_dma_rx_ring_info(s, dev, "R6:TxDone0(MAC2H)", "Both",
+			WF_WFDMA_HOST_DMA0_WPDMA_RX_RING6_CTRL0_ADDR);
+	dump_dma_rx_ring_info(s, dev, "R7:TxDone1(MAC2H)", "Both",
+		WF_WFDMA_HOST_DMA0_WPDMA_RX_RING7_CTRL0_ADDR);
+	dump_dma_rx_ring_info(s, dev, "R8:BUF0(MAC2H)", "Both",
+		WF_WFDMA_HOST_DMA0_WPDMA_RX_RING8_CTRL0_ADDR);
+	if (is_mt7996(&dev->mt76))
+		dump_dma_rx_ring_info(s, dev, "R9:TxDone0(MAC2H)", "Both",
+			WF_WFDMA_HOST_DMA0_WPDMA_RX_RING9_CTRL0_ADDR);
+	else
+		dump_dma_rx_ring_info(s, dev, "R9:BUF0(MAC2H)", "Both",
+			WF_WFDMA_HOST_DMA0_WPDMA_RX_RING9_CTRL0_ADDR);
+	dump_dma_rx_ring_info(s, dev, "R10:MSDU_PG0(MAC2H)", "Both",
+		WF_WFDMA_HOST_DMA0_WPDMA_RX_RING10_CTRL0_ADDR);
+	dump_dma_rx_ring_info(s, dev, "R11:MSDU_PG1(MAC2H)", "Both",
+		WF_WFDMA_HOST_DMA0_WPDMA_RX_RING11_CTRL0_ADDR);
+	dump_dma_rx_ring_info(s, dev, "R12:MSDU_PG2(MAC2H)", "Both",
+		WF_WFDMA_HOST_DMA0_WPDMA_RX_RING12_CTRL0_ADDR);
+	dump_dma_rx_ring_info(s, dev, "IND:IND_CMD(MAC2H)", "Both",
+		WF_RRO_TOP_IND_CMD_0_CTRL0_ADDR);
+
+	if (dev->hif2) {
+		seq_printf(s, "HOST_DMA0 PCIe1 Ring Configuration\n");
+		seq_printf(s, "%20s %6s %10s %15s %10s %10s %10s\n",
+			"Name", "Used", "Base", "Ctrl1(Cnt)", "CIDX", "DIDX", "QCnt");
+		dump_dma_tx_ring_info(s, dev, "T21:TXD2(H2WA)", "AP",
+			WF_WFDMA_HOST_DMA0_PCIE1_WPDMA_TX_RING21_CTRL0_ADDR);
+		dump_dma_tx_ring_info(s, dev, "T22:TXD?(H2WA)", "AP",
+			WF_WFDMA_HOST_DMA0_PCIE1_WPDMA_TX_RING22_CTRL0_ADDR);
+		dump_dma_rx_ring_info(s, dev, "R3:TxDone1(WA2H)", "AP",
+			WF_WFDMA_HOST_DMA0_PCIE1_WPDMA_RX_RING3_CTRL0_ADDR);
+		dump_dma_rx_ring_info(s, dev, "R5:Data1(MAC2H)", "Both",
+			WF_WFDMA_HOST_DMA0_PCIE1_WPDMA_RX_RING5_CTRL0_ADDR);
+		if (is_mt7996(&dev->mt76))
+			dump_dma_rx_ring_info(s, dev, "R6:BUF1(MAC2H)", "Both",
+				WF_WFDMA_HOST_DMA0_PCIE1_WPDMA_RX_RING6_CTRL0_ADDR);
+		dump_dma_rx_ring_info(s, dev, "R7:TxDone1(MAC2H)", "Both",
+			WF_WFDMA_HOST_DMA0_PCIE1_WPDMA_RX_RING7_CTRL0_ADDR);
+		if (is_mt7992(&dev->mt76))
+			dump_dma_rx_ring_info(s, dev, "R9:BUF1(MAC2H)", "Both",
+				WF_WFDMA_HOST_DMA0_PCIE1_WPDMA_RX_RING9_CTRL0_ADDR);
+	}
+
+	/* MCU DMA information */
+	sys_ctrl[0] = mt76_rr(dev, WF_WFDMA_MCU_DMA0_WPDMA_GLO_CFG_ADDR);
+	sys_ctrl[1] = mt76_rr(dev, WF_WFDMA_MCU_DMA0_HOST_INT_STA_ADDR);
+	sys_ctrl[2] = mt76_rr(dev, WF_WFDMA_MCU_DMA0_HOST_INT_ENA_ADDR);
+
+	seq_printf(s, "MCU_DMA Configuration\n");
+	seq_printf(s, "%10s %10s %10s %10s %10s %10s\n",
+		"DMA", "IntCSR", "IntMask", "Glocfg", "Tx/RxEn", "Tx/RxBusy");
+	seq_printf(s, "%10s %10x %10x %10x %4x/%5x %4x/%5x\n",
+		"DMA0", sys_ctrl[1], sys_ctrl[2], sys_ctrl[0],
+		(sys_ctrl[0] & WF_WFDMA_MCU_DMA0_WPDMA_GLO_CFG_TX_DMA_EN_MASK)
+			>> WF_WFDMA_MCU_DMA0_WPDMA_GLO_CFG_TX_DMA_EN_SHFT,
+		(sys_ctrl[0] & WF_WFDMA_MCU_DMA0_WPDMA_GLO_CFG_RX_DMA_EN_MASK)
+			>> WF_WFDMA_MCU_DMA0_WPDMA_GLO_CFG_RX_DMA_EN_SHFT,
+		(sys_ctrl[0] & WF_WFDMA_MCU_DMA0_WPDMA_GLO_CFG_TX_DMA_BUSY_MASK)
+			>> WF_WFDMA_MCU_DMA0_WPDMA_GLO_CFG_TX_DMA_BUSY_SHFT,
+		(sys_ctrl[0] & WF_WFDMA_MCU_DMA0_WPDMA_GLO_CFG_RX_DMA_BUSY_MASK)
+			>> WF_WFDMA_MCU_DMA0_WPDMA_GLO_CFG_RX_DMA_BUSY_SHFT);
+
+	seq_printf(s, "MCU_DMA0 Ring Configuration\n");
+	seq_printf(s, "%20s %6s %10s %15s %10s %10s %10s\n",
+		"Name", "Used", "Base", "Cnt", "CIDX", "DIDX", "QCnt");
+	dump_dma_tx_ring_info(s, dev, "T0:Event(WM2H)", "Both",
+		WF_WFDMA_MCU_DMA0_WPDMA_TX_RING0_CTRL0_ADDR);
+	dump_dma_tx_ring_info(s, dev, "T1:Event(WA2H)", "AP",
+		WF_WFDMA_MCU_DMA0_WPDMA_TX_RING1_CTRL0_ADDR);
+	dump_dma_tx_ring_info(s, dev, "T2:TxDone0(WA2H)", "AP",
+		WF_WFDMA_MCU_DMA0_WPDMA_TX_RING2_CTRL0_ADDR);
+	dump_dma_tx_ring_info(s, dev, "T3:TxDone1(WA2H)", "AP",
+		WF_WFDMA_MCU_DMA0_WPDMA_TX_RING3_CTRL0_ADDR);
+	dump_dma_tx_ring_info(s, dev, "T4:TXD(WM2MAC)", "Both",
+		WF_WFDMA_MCU_DMA0_WPDMA_TX_RING4_CTRL0_ADDR);
+	dump_dma_tx_ring_info(s, dev, "T5:TXCMD(WM2MAC)", "Both",
+		WF_WFDMA_MCU_DMA0_WPDMA_TX_RING5_CTRL0_ADDR);
+	dump_dma_tx_ring_info(s, dev, "T6:TXD(WA2MAC)", "AP",
+		WF_WFDMA_MCU_DMA0_WPDMA_TX_RING6_CTRL0_ADDR);
+	dump_dma_rx_ring_info(s, dev, "R0:FWDL", "Both",
+		WF_WFDMA_MCU_DMA0_WPDMA_RX_RING0_CTRL0_ADDR);
+	dump_dma_rx_ring_info(s, dev, "R1:Cmd(H2WM)", "Both",
+		WF_WFDMA_MCU_DMA0_WPDMA_RX_RING1_CTRL0_ADDR);
+	dump_dma_rx_ring_info(s, dev, "R2:TXD0(H2WA)", "AP",
+		WF_WFDMA_MCU_DMA0_WPDMA_RX_RING2_CTRL0_ADDR);
+	dump_dma_rx_ring_info(s, dev, "R3:TXD1(H2WA)", "AP",
+		WF_WFDMA_MCU_DMA0_WPDMA_RX_RING3_CTRL0_ADDR);
+	dump_dma_rx_ring_info(s, dev, "R4:Cmd(H2WA)", "AP",
+		WF_WFDMA_MCU_DMA0_WPDMA_RX_RING4_CTRL0_ADDR);
+	dump_dma_rx_ring_info(s, dev, "R5:Data0(MAC2WM)", "Both",
+		WF_WFDMA_MCU_DMA0_WPDMA_RX_RING5_CTRL0_ADDR);
+	dump_dma_rx_ring_info(s, dev, "R6:TxDone(MAC2WM)", "Both",
+		WF_WFDMA_MCU_DMA0_WPDMA_RX_RING6_CTRL0_ADDR);
+	dump_dma_rx_ring_info(s, dev, "R7:SPL/RPT(MAC2WM)", "Both",
+		WF_WFDMA_MCU_DMA0_WPDMA_RX_RING7_CTRL0_ADDR);
+	dump_dma_rx_ring_info(s, dev, "R8:TxDone(MAC2WA)", "AP",
+		WF_WFDMA_MCU_DMA0_WPDMA_RX_RING8_CTRL0_ADDR);
+	dump_dma_rx_ring_info(s, dev, "R9:Data1(MAC2WM)", "Both",
+		WF_WFDMA_MCU_DMA0_WPDMA_RX_RING9_CTRL0_ADDR);
+	dump_dma_rx_ring_info(s, dev, "R10:TXD2(H2WA)", "AP",
+		WF_WFDMA_MCU_DMA0_WPDMA_RX_RING10_CTRL0_ADDR);
+
+	/* MEM DMA information */
+	sys_ctrl[0] = mt76_rr(dev, WF_WFDMA_MEM_DMA_WPDMA_GLO_CFG_ADDR);
+	sys_ctrl[1] = mt76_rr(dev, WF_WFDMA_MEM_DMA_HOST_INT_STA_ADDR);
+	sys_ctrl[2] = mt76_rr(dev, WF_WFDMA_MEM_DMA_HOST_INT_ENA_ADDR);
+
+	seq_printf(s, "MEM_DMA Configuration\n");
+	seq_printf(s, "%10s %10s %10s %10s %10s %10s\n",
+		"DMA", "IntCSR", "IntMask", "Glocfg", "Tx/RxEn", "Tx/RxBusy");
+	seq_printf(s, "%10s %10x %10x %10x %4x/%5x %4x/%5x\n",
+		"MEM", sys_ctrl[1], sys_ctrl[2], sys_ctrl[0],
+		(sys_ctrl[0] & WF_WFDMA_MEM_DMA_WPDMA_GLO_CFG_TX_DMA_EN_MASK)
+			>> WF_WFDMA_MEM_DMA_WPDMA_GLO_CFG_TX_DMA_EN_SHFT,
+		(sys_ctrl[0] & WF_WFDMA_MEM_DMA_WPDMA_GLO_CFG_RX_DMA_EN_MASK)
+			>> WF_WFDMA_MEM_DMA_WPDMA_GLO_CFG_RX_DMA_EN_SHFT,
+		(sys_ctrl[0] & WF_WFDMA_MEM_DMA_WPDMA_GLO_CFG_TX_DMA_BUSY_MASK)
+			>> WF_WFDMA_MEM_DMA_WPDMA_GLO_CFG_TX_DMA_BUSY_SHFT,
+		(sys_ctrl[0] & WF_WFDMA_MEM_DMA_WPDMA_GLO_CFG_RX_DMA_BUSY_MASK)
+			>> WF_WFDMA_MEM_DMA_WPDMA_GLO_CFG_RX_DMA_BUSY_SHFT);
+
+	seq_printf(s, "MEM_DMA Ring Configuration\n");
+	seq_printf(s, "%20s %6s %10s %10s %10s %10s %10s\n",
+		"Name", "Used", "Base", "Cnt", "CIDX", "DIDX", "QCnt");
+	dump_dma_tx_ring_info(s, dev, "T0:CmdEvent(WM2WA)", "AP",
+		WF_WFDMA_MEM_DMA_WPDMA_TX_RING0_CTRL0_ADDR);
+	dump_dma_tx_ring_info(s, dev, "T1:CmdEvent(WA2WM)", "AP",
+		WF_WFDMA_MEM_DMA_WPDMA_TX_RING1_CTRL0_ADDR);
+	dump_dma_rx_ring_info(s, dev, "R0:CmdEvent(WM2WA)", "AP",
+		WF_WFDMA_MEM_DMA_WPDMA_RX_RING0_CTRL0_ADDR);
+	dump_dma_rx_ring_info(s, dev, "R1:CmdEvent(WA2WM)", "AP",
+		WF_WFDMA_MEM_DMA_WPDMA_RX_RING1_CTRL0_ADDR);
+}
+
+static int mt7996_trinfo_read(struct seq_file *s, void *data)
+{
+	struct mt7996_dev *dev = dev_get_drvdata(s->private);
+	mt7996_show_dma_info(s, dev);
+	return 0;
+}
+
+/* MIB INFO */
+static int mt7996_mibinfo_show(struct seq_file *s, void *data)
+{
+#define BSS_NUM	4
+	struct mt7996_phy *phy = s->private;
+	struct mt7996_dev *dev = phy->dev;
+	u8 band_idx = phy->mt76->band_idx;
+	u8 bss_nums = BSS_NUM;
+	u32 idx;
+	u32 mac_val, band_offset = 0, band_offset_umib = 0;
+	u32 msdr6, msdr9, msdr18;
+	u32 rvsr0, rscr26, rscr35, mctr5, mctr6, msr0, msr1, msr2;
+	u32 tbcr0, tbcr1, tbcr2, tbcr3, tbcr4;
+	u32 btscr[7];
+	u32 tdrcr[5];
+	u32 mbtocr[16], mbtbcr[16], mbrocr[16], mbrbcr[16];
+	u32 btcr, btbcr, brocr, brbcr, btdcr, brdcr;
+	u32 mu_cnt[5];
+	u32 ampdu_cnt[3];
+	u64 per;
+
+	switch (band_idx) {
+	case 0:
+		band_offset = 0;
+		band_offset_umib = 0;
+		break;
+	case 1:
+		band_offset = BN1_WF_MIB_TOP_BASE - BN0_WF_MIB_TOP_BASE;
+		band_offset_umib = WF_UMIB_TOP_B1BROCR_ADDR - WF_UMIB_TOP_B0BROCR_ADDR;
+		break;
+	case 2:
+		band_offset = IP1_BN0_WF_MIB_TOP_BASE - BN0_WF_MIB_TOP_BASE;
+		band_offset_umib = WF_UMIB_TOP_B2BROCR_ADDR - WF_UMIB_TOP_B0BROCR_ADDR;
+		break;
+	default:
+		return true;
+	}
+
+	seq_printf(s, "Band %d MIB Status\n", band_idx);
+	seq_printf(s, "===============================\n");
+	mac_val = mt76_rr(dev, BN0_WF_MIB_TOP_M0SCR0_ADDR + band_offset);
+	seq_printf(s, "MIB Status Control=0x%x\n", mac_val);
+
+	msdr6 = mt76_rr(dev, BN0_WF_MIB_TOP_M0SDR6_ADDR + band_offset);
+	rvsr0 = mt76_rr(dev, BN0_WF_MIB_TOP_RVSR0_ADDR + band_offset);
+	rscr35 = mt76_rr(dev, BN0_WF_MIB_TOP_RSCR35_ADDR + band_offset);
+	msdr9 = mt76_rr(dev, BN0_WF_MIB_TOP_M0SDR9_ADDR + band_offset);
+	rscr26 = mt76_rr(dev, BN0_WF_MIB_TOP_RSCR26_ADDR + band_offset);
+	mctr5 = mt76_rr(dev, BN0_WF_MIB_TOP_MCTR5_ADDR + band_offset);
+	mctr6 = mt76_rr(dev, BN0_WF_MIB_TOP_MCTR6_ADDR + band_offset);
+	msdr18 = mt76_rr(dev, BN0_WF_MIB_TOP_M0SDR18_ADDR + band_offset);
+	msr0 = mt76_rr(dev, BN0_WF_MIB_TOP_MSR0_ADDR + band_offset);
+	msr1 = mt76_rr(dev, BN0_WF_MIB_TOP_MSR1_ADDR + band_offset);
+	msr2 = mt76_rr(dev, BN0_WF_MIB_TOP_MSR2_ADDR + band_offset);
+	ampdu_cnt[0] = mt76_rr(dev, BN0_WF_MIB_TOP_TSCR0_ADDR + band_offset);
+	ampdu_cnt[1] = mt76_rr(dev, BN0_WF_MIB_TOP_TSCR3_ADDR + band_offset);
+	ampdu_cnt[2] = mt76_rr(dev, BN0_WF_MIB_TOP_TSCR4_ADDR + band_offset);
+	ampdu_cnt[1] &= BN0_WF_MIB_TOP_TSCR3_AMPDU_MPDU_COUNT_MASK;
+	ampdu_cnt[2] &= BN0_WF_MIB_TOP_TSCR4_AMPDU_ACKED_COUNT_MASK;
+
+	seq_printf(s, "===Phy/Timing Related Counters===\n");
+	seq_printf(s, "\tChannelIdleCnt=0x%x\n",
+		msdr6 & BN0_WF_MIB_TOP_M0SDR6_CHANNEL_IDLE_COUNT_MASK);
+	seq_printf(s, "\tCCA_NAV_Tx_Time=0x%x\n",
+		msdr9 & BN0_WF_MIB_TOP_M0SDR9_CCA_NAV_TX_TIME_MASK);
+	seq_printf(s, "\tRx_MDRDY_CNT=0x%x\n",
+		rscr26 & BN0_WF_MIB_TOP_RSCR26_RX_MDRDY_COUNT_MASK);
+	seq_printf(s, "\tCCK_MDRDY_TIME=0x%x, OFDM_MDRDY_TIME=0x%x",
+		msr0 & BN0_WF_MIB_TOP_MSR0_CCK_MDRDY_TIME_MASK,
+		msr1 & BN0_WF_MIB_TOP_MSR1_OFDM_LG_MIXED_VHT_MDRDY_TIME_MASK);
+	seq_printf(s, ", OFDM_GREEN_MDRDY_TIME=0x%x\n",
+		msr2 & BN0_WF_MIB_TOP_MSR2_OFDM_GREEN_MDRDY_TIME_MASK);
+	seq_printf(s, "\tPrim CCA Time=0x%x\n",
+		mctr5 & BN0_WF_MIB_TOP_MCTR5_P_CCA_TIME_MASK);
+	seq_printf(s, "\tSec CCA Time=0x%x\n",
+		mctr6 & BN0_WF_MIB_TOP_MCTR6_S_CCA_TIME_MASK);
+	seq_printf(s, "\tPrim ED Time=0x%x\n",
+		msdr18 & BN0_WF_MIB_TOP_M0SDR18_P_ED_TIME_MASK);
+
+	seq_printf(s, "===Tx Related Counters(Generic)===\n");
+	mac_val = mt76_rr(dev, BN0_WF_MIB_TOP_TSCR18_ADDR + band_offset);
+	dev->dbg.bcn_total_cnt[band_idx] +=
+		(mac_val & BN0_WF_MIB_TOP_TSCR18_BEACONTXCOUNT_MASK);
+	seq_printf(s, "\tBeaconTxCnt=0x%x\n", dev->dbg.bcn_total_cnt[band_idx]);
+	dev->dbg.bcn_total_cnt[band_idx] = 0;
+
+	tbcr0 = mt76_rr(dev, BN0_WF_MIB_TOP_TBCR0_ADDR + band_offset);
+	seq_printf(s, "\tTx 20MHz Cnt=0x%x\n",
+		tbcr0 & BN0_WF_MIB_TOP_TBCR0_TX_20MHZ_CNT_MASK);
+	tbcr1 = mt76_rr(dev, BN0_WF_MIB_TOP_TBCR1_ADDR + band_offset);
+	seq_printf(s, "\tTx 40MHz Cnt=0x%x\n",
+		tbcr1 & BN0_WF_MIB_TOP_TBCR1_TX_40MHZ_CNT_MASK);
+	tbcr2 = mt76_rr(dev, BN0_WF_MIB_TOP_TBCR2_ADDR + band_offset);
+	seq_printf(s, "\tTx 80MHz Cnt=0x%x\n",
+		tbcr2 & BN0_WF_MIB_TOP_TBCR2_TX_80MHZ_CNT_MASK);
+	tbcr3 = mt76_rr(dev, BN0_WF_MIB_TOP_TBCR3_ADDR + band_offset);
+	seq_printf(s, "\tTx 160MHz Cnt=0x%x\n",
+		tbcr3 & BN0_WF_MIB_TOP_TBCR3_TX_160MHZ_CNT_MASK);
+	tbcr4 = mt76_rr(dev, BN0_WF_MIB_TOP_TBCR4_ADDR + band_offset);
+	seq_printf(s, "\tTx 320MHz Cnt=0x%x\n",
+		tbcr4 & BN0_WF_MIB_TOP_TBCR4_TX_320MHZ_CNT_MASK);
+	seq_printf(s, "\tAMPDU Cnt=0x%x\n", ampdu_cnt[0]);
+	seq_printf(s, "\tAMPDU MPDU Cnt=0x%x\n", ampdu_cnt[1]);
+	seq_printf(s, "\tAMPDU MPDU Ack Cnt=0x%x\n", ampdu_cnt[2]);
+	per = (ampdu_cnt[2] == 0 ?
+		0 : 1000 * (ampdu_cnt[1] - ampdu_cnt[2]) / ampdu_cnt[1]);
+	seq_printf(s, "\tAMPDU MPDU PER=%llu.%1llu%%\n", per / 10, per % 10);
+
+	seq_printf(s, "===MU Related Counters===\n");
+	mu_cnt[0] = mt76_rr(dev, BN0_WF_MIB_TOP_BSCR2_ADDR + band_offset);
+	mu_cnt[1] = mt76_rr(dev, BN0_WF_MIB_TOP_TSCR5_ADDR + band_offset);
+	mu_cnt[2] = mt76_rr(dev, BN0_WF_MIB_TOP_TSCR6_ADDR + band_offset);
+	mu_cnt[3] = mt76_rr(dev, BN0_WF_MIB_TOP_TSCR8_ADDR + band_offset);
+	mu_cnt[4] = mt76_rr(dev, BN0_WF_MIB_TOP_TSCR7_ADDR + band_offset);
+
+	seq_printf(s, "\tMUBF_TX_COUNT=0x%x\n",
+		mu_cnt[0] & BN0_WF_MIB_TOP_BSCR2_MUBF_TX_COUNT_MASK);
+	seq_printf(s, "\tMU_TX_MPDU_COUNT(Ok+Fail)=0x%x\n", mu_cnt[1]);
+	seq_printf(s, "\tMU_TX_OK_MPDU_COUNT=0x%x\n", mu_cnt[2]);
+	seq_printf(s, "\tMU_TO_MU_FAIL_PPDU_COUNT=0x%x\n", mu_cnt[3]);
+	seq_printf(s, "\tSU_TX_OK_MPDU_COUNT=0x%x\n", mu_cnt[4]);
+
+	seq_printf(s, "===Rx Related Counters(Generic)===\n");
+	seq_printf(s, "\tVector Mismacth Cnt=0x%x\n",
+		rvsr0 & BN0_WF_MIB_TOP_RVSR0_VEC_MISS_COUNT_MASK);
+	seq_printf(s, "\tDelimiter Fail Cnt=0x%x\n",
+		rscr35 & BN0_WF_MIB_TOP_RSCR35_DELIMITER_FAIL_COUNT_MASK);
+
+	mac_val = mt76_rr(dev, BN0_WF_MIB_TOP_RSCR1_ADDR + band_offset);
+	seq_printf(s, "\tRxFCSErrCnt=0x%x\n",
+		(mac_val & BN0_WF_MIB_TOP_RSCR1_RX_FCS_ERROR_COUNT_MASK));
+	mac_val = mt76_rr(dev, BN0_WF_MIB_TOP_RSCR33_ADDR + band_offset);
+	seq_printf(s, "\tRxFifoFullCnt=0x%x\n",
+		(mac_val & BN0_WF_MIB_TOP_RSCR33_RX_FIFO_FULL_COUNT_MASK));
+	mac_val = mt76_rr(dev, BN0_WF_MIB_TOP_RSCR36_ADDR + band_offset);
+	seq_printf(s, "\tRxLenMismatch=0x%x\n",
+		(mac_val & BN0_WF_MIB_TOP_RSCR36_RX_LEN_MISMATCH_MASK));
+	mac_val = mt76_rr(dev, BN0_WF_MIB_TOP_RSCR31_ADDR + band_offset);
+	seq_printf(s, "\tRxMPDUCnt=0x%x\n",
+		(mac_val & BN0_WF_MIB_TOP_RSCR31_RX_MPDU_COUNT_MASK));
+	mac_val = mt76_rr(dev, BN0_WF_MIB_TOP_RSCR27_ADDR + band_offset);
+	seq_printf(s, "\tRx AMPDU Cnt=0x%x\n", mac_val);
+	mac_val = mt76_rr(dev, BN0_WF_MIB_TOP_RSCR28_ADDR + band_offset);
+	seq_printf(s, "\tRx Total ByteCnt=0x%x\n", mac_val);
+
+
+	/* Per-BSS T/RX Counters */
+	seq_printf(s, "===Per-BSS Related Tx/Rx Counters===\n");
+	seq_printf(s, "BSS Idx TxCnt/DataCnt TxByteCnt RxOkCnt/DataCnt RxByteCnt\n");
+	for (idx = 0; idx < bss_nums; idx++) {
+		btcr = mt76_rr(dev, BN0_WF_MIB_TOP_BTCR_ADDR + band_offset + idx * 4);
+		btdcr = mt76_rr(dev, BN0_WF_MIB_TOP_BTDCR_ADDR + band_offset + idx * 4);
+		btbcr = mt76_rr(dev, BN0_WF_MIB_TOP_BTBCR_ADDR + band_offset + idx * 4);
+
+		brocr = mt76_rr(dev, WF_UMIB_TOP_B0BROCR_ADDR + band_offset_umib + idx * 4);
+		brdcr = mt76_rr(dev, WF_UMIB_TOP_B0BRDCR_ADDR + band_offset_umib + idx * 4);
+		brbcr = mt76_rr(dev, WF_UMIB_TOP_B0BRBCR_ADDR + band_offset_umib + idx * 4);
+
+		seq_printf(s, "%d\t 0x%x/0x%x\t 0x%x \t 0x%x/0x%x \t 0x%x\n",
+			idx, btcr, btdcr, btbcr, brocr, brdcr, brbcr);
+	}
+
+	seq_printf(s, "===Per-BSS Related MIB Counters===\n");
+	seq_printf(s, "BSS Idx RTSTx/RetryCnt BAMissCnt AckFailCnt FrmRetry1/2/3Cnt\n");
+
+	/* Per-BSS TX Status */
+	for (idx = 0; idx < bss_nums; idx++) {
+		btscr[0] = mt76_rr(dev, BN0_WF_MIB_TOP_BTSCR5_ADDR + band_offset + idx * 4);
+		btscr[1] = mt76_rr(dev, BN0_WF_MIB_TOP_BTSCR6_ADDR + band_offset + idx * 4);
+		btscr[2] = mt76_rr(dev, BN0_WF_MIB_TOP_BTSCR0_ADDR + band_offset + idx * 4);
+		btscr[3] = mt76_rr(dev, BN0_WF_MIB_TOP_BTSCR1_ADDR + band_offset + idx * 4);
+		btscr[4] = mt76_rr(dev, BN0_WF_MIB_TOP_BTSCR2_ADDR + band_offset + idx * 4);
+		btscr[5] = mt76_rr(dev, BN0_WF_MIB_TOP_BTSCR3_ADDR + band_offset + idx * 4);
+		btscr[6] = mt76_rr(dev, BN0_WF_MIB_TOP_BTSCR4_ADDR + band_offset + idx * 4);
+
+		seq_printf(s, "%d:\t0x%x/0x%x  0x%x \t 0x%x \t  0x%x/0x%x/0x%x\n",
+			idx, (btscr[0] & BN0_WF_MIB_TOP_BTSCR5_RTSTXCOUNTn_MASK),
+			(btscr[1] & BN0_WF_MIB_TOP_BTSCR6_RTSRETRYCOUNTn_MASK),
+			(btscr[2] & BN0_WF_MIB_TOP_BTSCR0_BAMISSCOUNTn_MASK),
+			(btscr[3] & BN0_WF_MIB_TOP_BTSCR1_ACKFAILCOUNTn_MASK),
+			(btscr[4] & BN0_WF_MIB_TOP_BTSCR2_FRAMERETRYCOUNTn_MASK),
+			(btscr[5] & BN0_WF_MIB_TOP_BTSCR3_FRAMERETRY2COUNTn_MASK),
+			(btscr[6] & BN0_WF_MIB_TOP_BTSCR4_FRAMERETRY3COUNTn_MASK));
+	}
+
+	/* Dummy delimiter insertion result */
+	seq_printf(s, "===Dummy delimiter insertion result===\n");
+	tdrcr[0] = mt76_rr(dev, BN0_WF_MIB_TOP_TDRCR0_ADDR + band_offset);
+	tdrcr[1] = mt76_rr(dev, BN0_WF_MIB_TOP_TDRCR1_ADDR + band_offset);
+	tdrcr[2] = mt76_rr(dev, BN0_WF_MIB_TOP_TDRCR2_ADDR + band_offset);
+	tdrcr[3] = mt76_rr(dev, BN0_WF_MIB_TOP_TDRCR3_ADDR + band_offset);
+	tdrcr[4] = mt76_rr(dev, BN0_WF_MIB_TOP_TDRCR4_ADDR + band_offset);
+
+	seq_printf(s, "Range0 = %d\t Range1 = %d\t Range2 = %d\t Range3 = %d\t Range4 = %d\n",
+		tdrcr[0],
+		tdrcr[1],
+		tdrcr[2],
+		tdrcr[3],
+		tdrcr[4]);
+
+	/* Per-MBSS T/RX Counters */
+	seq_printf(s, "===Per-MBSS Related Tx/Rx Counters===\n");
+	seq_printf(s, "MBSSIdx   TxOkCnt  TxByteCnt  RxOkCnt  RxByteCnt\n");
+
+	for (idx = 0; idx < 16; idx++) {
+		mbtocr[idx] = mt76_rr(dev, BN0_WF_MIB_TOP_BTOCR_ADDR + band_offset + (bss_nums + idx) * 4);
+		mbtbcr[idx] = mt76_rr(dev, BN0_WF_MIB_TOP_BTBCR_ADDR + band_offset + (bss_nums + idx) * 4);
+
+		mbrocr[idx] = mt76_rr(dev, WF_UMIB_TOP_B0BROCR_ADDR + band_offset_umib + (bss_nums + idx) * 4);
+		mbrbcr[idx] = mt76_rr(dev, WF_UMIB_TOP_B0BRBCR_ADDR + band_offset_umib + (bss_nums + idx) * 4);
+	}
+
+	for (idx = 0; idx < 16; idx++) {
+		seq_printf(s, "%d\t 0x%x\t 0x%x \t 0x%x \t 0x%x\n",
+			idx, mbtocr[idx], mbtbcr[idx], mbrocr[idx], mbrbcr[idx]);
+	}
+
+	return 0;
+}
+DEFINE_SHOW_ATTRIBUTE(mt7996_mibinfo);
+
+/* WTBL INFO */
+static int
+mt7996_wtbl_read_raw(struct mt7996_dev *dev, u16 idx,
+		     enum mt7996_wtbl_type type, u16 start_dw,
+		     u16 len, void *buf)
+{
+	u32 *dest_cpy = (u32 *)buf;
+	u32 size_dw = len;
+	u32 src = 0;
+
+	if (!buf)
+		return 0xFF;
+
+	if (type == WTBL_TYPE_LMAC) {
+		mt76_wr(dev, MT_DBG_WTBLON_TOP_WDUCR_ADDR,
+			FIELD_PREP(MT_DBG_WTBLON_TOP_WDUCR_GROUP, (idx >> 7)));
+		src = LWTBL_IDX2BASE(idx, start_dw);
+	} else if (type == WTBL_TYPE_UMAC) {
+		mt76_wr(dev,  MT_DBG_UWTBL_TOP_WDUCR_ADDR,
+			FIELD_PREP(MT_DBG_UWTBL_TOP_WDUCR_GROUP, (idx >> 7)));
+		src = UWTBL_IDX2BASE(idx, start_dw);
+	} else if (type == WTBL_TYPE_KEY) {
+		mt76_wr(dev,  MT_DBG_UWTBL_TOP_WDUCR_ADDR,
+			MT_DBG_UWTBL_TOP_WDUCR_TARGET |
+			FIELD_PREP(MT_DBG_UWTBL_TOP_WDUCR_GROUP, (idx >> 7)));
+		src = KEYTBL_IDX2BASE(idx, start_dw);
+	}
+
+	while (size_dw--) {
+		*dest_cpy++ = mt76_rr(dev, src);
+		src += 4;
+	};
+
+	return 0;
+}
+
+#if 0
+static int
+mt7996_wtbl_write_raw(struct mt7996_dev *dev, u16 idx,
+			  enum mt7996_wtbl_type type, u16 start_dw,
+			  u32 val)
+{
+	u32 addr = 0;
+
+	if (type == WTBL_TYPE_LMAC) {
+		mt76_wr(dev, MT_DBG_WTBLON_TOP_WDUCR_ADDR,
+			FIELD_PREP(MT_DBG_WTBLON_TOP_WDUCR_GROUP, (idx >> 7)));
+		addr = LWTBL_IDX2BASE(idx, start_dw);
+	} else if (type == WTBL_TYPE_UMAC) {
+		mt76_wr(dev, MT_DBG_UWTBL_TOP_WDUCR_ADDR,
+			FIELD_PREP(MT_DBG_UWTBL_TOP_WDUCR_GROUP, (idx >> 7)));
+		addr = UWTBL_IDX2BASE(idx, start_dw);
+	} else if (type == WTBL_TYPE_KEY) {
+		mt76_wr(dev, MT_DBG_UWTBL_TOP_WDUCR_ADDR,
+			MT_DBG_UWTBL_TOP_WDUCR_TARGET |
+			FIELD_PREP(MT_DBG_UWTBL_TOP_WDUCR_GROUP, (idx >> 7)));
+		addr = KEYTBL_IDX2BASE(idx, start_dw);
+	}
+
+	mt76_wr(dev, addr, val);
+
+	return 0;
+}
+#endif
+
+static const struct berse_wtbl_parse WTBL_LMAC_DW0[] = {
+	{"MUAR_IDX",	WF_LWTBL_MUAR_MASK,	WF_LWTBL_MUAR_SHIFT,	false},
+	{"RCA1",	WF_LWTBL_RCA1_MASK,	NO_SHIFT_DEFINE,	false},
+	{"KID",		WF_LWTBL_KID_MASK,	WF_LWTBL_KID_SHIFT,	false},
+	{"RCID",	WF_LWTBL_RCID_MASK,	NO_SHIFT_DEFINE,	false},
+	{"BAND",	WF_LWTBL_BAND_MASK,	WF_LWTBL_BAND_SHIFT,	false},
+	{"RV",		WF_LWTBL_RV_MASK,	NO_SHIFT_DEFINE,	false},
+	{"RCA2",	WF_LWTBL_RCA2_MASK,	NO_SHIFT_DEFINE,	false},
+	{"WPI_FLAG",	WF_LWTBL_WPI_FLAG_MASK,	NO_SHIFT_DEFINE,	true},
+	{NULL,}
+};
+
+static void parse_fmac_lwtbl_dw0_1(struct seq_file *s, u8 *lwtbl)
+{
+	u32 *addr = 0;
+	u32 dw_value = 0;
+	u16 i = 0;
+
+	seq_printf(s, "\t\n");
+	seq_printf(s, "LinkAddr: %02x:%02x:%02x:%02x:%02x:%02x(D0[B0~15], D1[B0~31])\n",
+		lwtbl[4], lwtbl[5], lwtbl[6], lwtbl[7], lwtbl[0], lwtbl[1]);
+
+	/* LMAC WTBL DW 0 */
+	seq_printf(s, "\t\n");
+	seq_printf(s, "LWTBL DW 0/1\n");
+	addr = (u32 *)&(lwtbl[WTBL_GROUP_PEER_INFO_DW_0*4]);
+	dw_value = *addr;
+
+	while (WTBL_LMAC_DW0[i].name) {
+
+		if (WTBL_LMAC_DW0[i].shift == NO_SHIFT_DEFINE)
+			seq_printf(s, "\t%s:%d\n", WTBL_LMAC_DW0[i].name,
+					 (dw_value & WTBL_LMAC_DW0[i].mask) ? 1 : 0);
+		else
+			seq_printf(s, "\t%s:%u\n", WTBL_LMAC_DW0[i].name,
+					  (dw_value & WTBL_LMAC_DW0[i].mask) >> WTBL_LMAC_DW0[i].shift);
+		i++;
+	}
+}
+
+static const struct berse_wtbl_parse *WTBL_LMAC_DW2;
+static const struct berse_wtbl_parse WTBL_LMAC_DW2_7996[] = {
+	{"AID",			WF_LWTBL_AID_MASK,		WF_LWTBL_AID_SHIFT,			false},
+	{"GID_SU",		WF_LWTBL_GID_SU_MASK,		NO_SHIFT_DEFINE,			false},
+	{"SPP_EN",		WF_LWTBL_SPP_EN_MASK,		NO_SHIFT_DEFINE,			false},
+	{"WPI_EVEN",		WF_LWTBL_WPI_EVEN_MASK,		NO_SHIFT_DEFINE,			false},
+	{"AAD_OM",		WF_LWTBL_AAD_OM_MASK,		NO_SHIFT_DEFINE,			false},
+	{"CIPHER_PGTK",		WF_LWTBL_CIPHER_SUIT_PGTK_MASK,	WF_LWTBL_CIPHER_SUIT_PGTK_SHIFT,	true},
+	{"FROM_DS",		WF_LWTBL_FD_MASK,		NO_SHIFT_DEFINE,			false},
+	{"TO_DS",		WF_LWTBL_TD_MASK,		NO_SHIFT_DEFINE,			false},
+	{"SW",			WF_LWTBL_SW_MASK,		NO_SHIFT_DEFINE,			false},
+	{"UL",			WF_LWTBL_UL_MASK,		NO_SHIFT_DEFINE,			false},
+	{"TX_POWER_SAVE",	WF_LWTBL_TX_PS_MASK,		NO_SHIFT_DEFINE,			true},
+	{"QOS",			WF_LWTBL_QOS_MASK,		NO_SHIFT_DEFINE,			false},
+	{"HT",			WF_LWTBL_HT_MASK,		NO_SHIFT_DEFINE,			false},
+	{"VHT",			WF_LWTBL_VHT_MASK,		NO_SHIFT_DEFINE,			false},
+	{"HE",			WF_LWTBL_HE_MASK,		NO_SHIFT_DEFINE,			false},
+	{"EHT",			WF_LWTBL_EHT_MASK,		NO_SHIFT_DEFINE,			false},
+	{"MESH",		WF_LWTBL_MESH_MASK,		NO_SHIFT_DEFINE,			true},
+	{NULL,}
+};
+
+static const struct berse_wtbl_parse WTBL_LMAC_DW2_7992[] = {
+	{"AID",			WF_LWTBL_AID_MASK,		WF_LWTBL_AID_SHIFT,			false},
+	{"GID_SU",		WF_LWTBL_GID_SU_MASK,		NO_SHIFT_DEFINE,			false},
+	{"DUAL_PTEC_EN",	WF_LWTBL_DUAL_PTEC_EN_MASK,	NO_SHIFT_DEFINE,			false},
+	{"DUAL_CTS_CAP",	WF_LWTBL_DUAL_CTS_CAP_MASK,	NO_SHIFT_DEFINE,			false},
+	{"CIPHER_PGTK",		WF_LWTBL_CIPHER_SUIT_PGTK_MASK,	WF_LWTBL_CIPHER_SUIT_PGTK_SHIFT,	true},
+	{"FROM_DS",		WF_LWTBL_FD_MASK,		NO_SHIFT_DEFINE,			false},
+	{"TO_DS",		WF_LWTBL_TD_MASK,		NO_SHIFT_DEFINE,			false},
+	{"SW",			WF_LWTBL_SW_MASK,		NO_SHIFT_DEFINE,			false},
+	{"UL",			WF_LWTBL_UL_MASK,		NO_SHIFT_DEFINE,			false},
+	{"TX_POWER_SAVE",	WF_LWTBL_TX_PS_MASK,		NO_SHIFT_DEFINE,			true},
+	{"QOS",			WF_LWTBL_QOS_MASK,		NO_SHIFT_DEFINE,			false},
+	{"HT",			WF_LWTBL_HT_MASK,		NO_SHIFT_DEFINE,			false},
+	{"VHT",			WF_LWTBL_VHT_MASK,		NO_SHIFT_DEFINE,			false},
+	{"HE",			WF_LWTBL_HE_MASK,		NO_SHIFT_DEFINE,			false},
+	{"EHT",			WF_LWTBL_EHT_MASK,		NO_SHIFT_DEFINE,			false},
+	{"MESH",		WF_LWTBL_MESH_MASK,		NO_SHIFT_DEFINE,			true},
+	{NULL,}
+};
+
+static void parse_fmac_lwtbl_dw2(struct seq_file *s, u8 *lwtbl)
+{
+	u32 *addr = 0;
+	u32 dw_value = 0;
+	u16 i = 0;
+
+	/* LMAC WTBL DW 2 */
+	seq_printf(s, "\t\n");
+	seq_printf(s, "LWTBL DW 2\n");
+	addr = (u32 *)&(lwtbl[WTBL_GROUP_TRX_CAP_DW_2*4]);
+	dw_value = *addr;
+
+	while (WTBL_LMAC_DW2[i].name) {
+
+		if (WTBL_LMAC_DW2[i].shift == NO_SHIFT_DEFINE)
+			seq_printf(s, "\t%s:%d\n", WTBL_LMAC_DW2[i].name,
+					 (dw_value & WTBL_LMAC_DW2[i].mask) ? 1 : 0);
+		else
+			seq_printf(s, "\t%s:%u\n", WTBL_LMAC_DW2[i].name,
+					  (dw_value & WTBL_LMAC_DW2[i].mask) >> WTBL_LMAC_DW2[i].shift);
+		i++;
+	}
+}
+
+static const struct berse_wtbl_parse WTBL_LMAC_DW3[] = {
+	{"WMM_Q",		WF_LWTBL_WMM_Q_MASK,			WF_LWTBL_WMM_Q_SHIFT,			false},
+	{"EHT_SIG_MCS",		WF_LWTBL_EHT_SIG_MCS_MASK,		WF_LWTBL_EHT_SIG_MCS_SHIFT,		false},
+	{"HDRT_MODE",		WF_LWTBL_HDRT_MODE_MASK,		NO_SHIFT_DEFINE,			false},
+	{"BEAM_CHG",		WF_LWTBL_BEAM_CHG_MASK,			NO_SHIFT_DEFINE,			false},
+	{"EHT_LTF_SYM_NUM",	WF_LWTBL_EHT_LTF_SYM_NUM_OPT_MASK,	WF_LWTBL_EHT_LTF_SYM_NUM_OPT_SHIFT,	true},
+	{"PFMU_IDX",		WF_LWTBL_PFMU_IDX_MASK,			WF_LWTBL_PFMU_IDX_SHIFT,		false},
+	{"ULPF_IDX",		WF_LWTBL_ULPF_IDX_MASK,			WF_LWTBL_ULPF_IDX_SHIFT,		false},
+	{"RIBF",		WF_LWTBL_RIBF_MASK,			NO_SHIFT_DEFINE,			false},
+	{"ULPF",		WF_LWTBL_ULPF_MASK,			NO_SHIFT_DEFINE,			false},
+	{"BYPASS_TXSMM",	WF_LWTBL_BYPASS_TXSMM_MASK,		NO_SHIFT_DEFINE,			true},
+	{"TBF_HT",		WF_LWTBL_TBF_HT_MASK,			NO_SHIFT_DEFINE,			false},
+	{"TBF_VHT",		WF_LWTBL_TBF_VHT_MASK,			NO_SHIFT_DEFINE,			false},
+	{"TBF_HE",		WF_LWTBL_TBF_HE_MASK,			NO_SHIFT_DEFINE,			false},
+	{"TBF_EHT",		WF_LWTBL_TBF_EHT_MASK,			NO_SHIFT_DEFINE,			false},
+	{"IGN_FBK",		WF_LWTBL_IGN_FBK_MASK,			NO_SHIFT_DEFINE,			true},
+	{NULL,}
+};
+
+static void parse_fmac_lwtbl_dw3(struct seq_file *s, u8 *lwtbl)
+{
+	u32 *addr = 0;
+	u32 dw_value = 0;
+	u16 i = 0;
+
+	/* LMAC WTBL DW 3 */
+	seq_printf(s, "\t\n");
+	seq_printf(s, "LWTBL DW 3\n");
+	addr = (u32 *)&(lwtbl[WTBL_GROUP_TRX_CAP_DW_3*4]);
+	dw_value = *addr;
+
+	while (WTBL_LMAC_DW3[i].name) {
+
+		if (WTBL_LMAC_DW3[i].shift == NO_SHIFT_DEFINE)
+			seq_printf(s, "\t%s:%d\n", WTBL_LMAC_DW3[i].name,
+					 (dw_value & WTBL_LMAC_DW3[i].mask) ? 1 : 0);
+		else
+			seq_printf(s, "\t%s:%u\n", WTBL_LMAC_DW3[i].name,
+					  (dw_value & WTBL_LMAC_DW3[i].mask) >> WTBL_LMAC_DW3[i].shift);
+		i++;
+	}
+}
+
+static const struct berse_wtbl_parse WTBL_LMAC_DW4[] = {
+	{"NEGOTIATED_WINSIZE0",	WF_LWTBL_NEGOTIATED_WINSIZE0_MASK,	WF_LWTBL_NEGOTIATED_WINSIZE0_SHIFT,	false},
+	{"WINSIZE1",		WF_LWTBL_NEGOTIATED_WINSIZE1_MASK,	WF_LWTBL_NEGOTIATED_WINSIZE1_SHIFT,	false},
+	{"WINSIZE2",		WF_LWTBL_NEGOTIATED_WINSIZE2_MASK,	WF_LWTBL_NEGOTIATED_WINSIZE2_SHIFT,	false},
+	{"WINSIZE3",		WF_LWTBL_NEGOTIATED_WINSIZE3_MASK,	WF_LWTBL_NEGOTIATED_WINSIZE3_SHIFT,	true},
+	{"WINSIZE4",		WF_LWTBL_NEGOTIATED_WINSIZE4_MASK,	WF_LWTBL_NEGOTIATED_WINSIZE4_SHIFT,	false},
+	{"WINSIZE5",		WF_LWTBL_NEGOTIATED_WINSIZE5_MASK,	WF_LWTBL_NEGOTIATED_WINSIZE5_SHIFT,	false},
+	{"WINSIZE6",		WF_LWTBL_NEGOTIATED_WINSIZE6_MASK,	WF_LWTBL_NEGOTIATED_WINSIZE6_SHIFT,	false},
+	{"WINSIZE7",		WF_LWTBL_NEGOTIATED_WINSIZE7_MASK,	WF_LWTBL_NEGOTIATED_WINSIZE7_SHIFT,	true},
+	{"PE",			WF_LWTBL_PE_MASK,			WF_LWTBL_PE_SHIFT,			false},
+	{"DIS_RHTR",		WF_LWTBL_DIS_RHTR_MASK,			NO_SHIFT_DEFINE,			false},
+	{"LDPC_HT",		WF_LWTBL_LDPC_HT_MASK,			NO_SHIFT_DEFINE,			false},
+	{"LDPC_VHT",		WF_LWTBL_LDPC_VHT_MASK,			NO_SHIFT_DEFINE,			false},
+	{"LDPC_HE",		WF_LWTBL_LDPC_HE_MASK,			NO_SHIFT_DEFINE,			false},
+	{"LDPC_EHT",		WF_LWTBL_LDPC_EHT_MASK,			NO_SHIFT_DEFINE,			true},
+	{"BA_MODE",		WF_LWTBL_BA_MODE_MASK,			NO_SHIFT_DEFINE,			true},
+	{NULL,}
+};
+
+static void parse_fmac_lwtbl_dw4(struct seq_file *s, u8 *lwtbl)
+{
+	u32 *addr = 0;
+	u32 dw_value = 0;
+	u16 i = 0;
+
+	/* LMAC WTBL DW 4 */
+	seq_printf(s, "\t\n");
+	seq_printf(s, "LWTBL DW 4\n");
+	addr = (u32 *)&(lwtbl[WTBL_GROUP_TRX_CAP_DW_4*4]);
+	dw_value = *addr;
+
+	while (WTBL_LMAC_DW4[i].name) {
+		if (WTBL_LMAC_DW4[i].shift == NO_SHIFT_DEFINE)
+			seq_printf(s, "\t%s:%d\n", WTBL_LMAC_DW4[i].name,
+					 (dw_value & WTBL_LMAC_DW4[i].mask) ? 1 : 0);
+		else
+			seq_printf(s, "\t%s:%u\n", WTBL_LMAC_DW4[i].name,
+					  (dw_value & WTBL_LMAC_DW4[i].mask) >> WTBL_LMAC_DW4[i].shift);
+		i++;
+	}
+}
+
+static const struct berse_wtbl_parse *WTBL_LMAC_DW5;
+static const struct berse_wtbl_parse WTBL_LMAC_DW5_7996[] = {
+	{"AF",			WF_LWTBL_AF_MASK,		WF_LWTBL_AF_SHIFT,		false},
+	{"AF_HE",		WF_LWTBL_AF_HE_MASK,		WF_LWTBL_AF_HE_SHIFT,		false},
+	{"RTS",			WF_LWTBL_RTS_MASK,		NO_SHIFT_DEFINE,		false},
+	{"SMPS",		WF_LWTBL_SMPS_MASK,		NO_SHIFT_DEFINE,		false},
+	{"DYN_BW",		WF_LWTBL_DYN_BW_MASK,		NO_SHIFT_DEFINE,		true},
+	{"MMSS",		WF_LWTBL_MMSS_MASK,		WF_LWTBL_MMSS_SHIFT,		false},
+	{"USR",			WF_LWTBL_USR_MASK,		NO_SHIFT_DEFINE,		false},
+	{"SR_RATE",		WF_LWTBL_SR_R_MASK,		WF_LWTBL_SR_R_SHIFT,		false},
+	{"SR_ABORT",		WF_LWTBL_SR_ABORT_MASK,		NO_SHIFT_DEFINE,		true},
+	{"TX_POWER_OFFSET",	WF_LWTBL_TX_POWER_OFFSET_MASK,  WF_LWTBL_TX_POWER_OFFSET_SHIFT,	false},
+	{"LTF_EHT",		WF_LWTBL_LTF_EHT_MASK,		WF_LWTBL_LTF_EHT_SHIFT, 	false},
+	{"GI_EHT",		WF_LWTBL_GI_EHT_MASK,		WF_LWTBL_GI_EHT_SHIFT,		false},
+	{"DOPPL",		WF_LWTBL_DOPPL_MASK,		NO_SHIFT_DEFINE,		false},
+	{"TXOP_PS_CAP",		WF_LWTBL_TXOP_PS_CAP_MASK,	NO_SHIFT_DEFINE,		false},
+	{"DONOT_UPDATE_I_PSM",	WF_LWTBL_DU_I_PSM_MASK,		NO_SHIFT_DEFINE,		true},
+	{"I_PSM",		WF_LWTBL_I_PSM_MASK,		NO_SHIFT_DEFINE,		false},
+	{"PSM",			WF_LWTBL_PSM_MASK,		NO_SHIFT_DEFINE,		false},
+	{"SKIP_TX",		WF_LWTBL_SKIP_TX_MASK,		NO_SHIFT_DEFINE,		true},
+	{NULL,}
+};
+
+static const struct berse_wtbl_parse WTBL_LMAC_DW5_7992[] = {
+	{"AF",			WF_LWTBL_AF_MASK_7992,		WF_LWTBL_AF_SHIFT,		false},
+	{"RTS",			WF_LWTBL_RTS_MASK,		NO_SHIFT_DEFINE,		false},
+	{"SMPS",		WF_LWTBL_SMPS_MASK,		NO_SHIFT_DEFINE,		false},
+	{"DYN_BW",		WF_LWTBL_DYN_BW_MASK,		NO_SHIFT_DEFINE,		true},
+	{"MMSS",		WF_LWTBL_MMSS_MASK,		WF_LWTBL_MMSS_SHIFT,		false},
+	{"USR",			WF_LWTBL_USR_MASK,		NO_SHIFT_DEFINE,		false},
+	{"SR_RATE",		WF_LWTBL_SR_R_MASK,		WF_LWTBL_SR_R_SHIFT,		false},
+	{"SR_ABORT",		WF_LWTBL_SR_ABORT_MASK,		NO_SHIFT_DEFINE,		true},
+	{"TX_POWER_OFFSET",	WF_LWTBL_TX_POWER_OFFSET_MASK,	WF_LWTBL_TX_POWER_OFFSET_SHIFT,	false},
+	{"LTF_EHT",		WF_LWTBL_LTF_EHT_MASK,		WF_LWTBL_LTF_EHT_SHIFT,		false},
+	{"GI_EHT",		WF_LWTBL_GI_EHT_MASK,		WF_LWTBL_GI_EHT_SHIFT,		false},
+	{"DOPPL",		WF_LWTBL_DOPPL_MASK,		NO_SHIFT_DEFINE,		false},
+	{"TXOP_PS_CAP",		WF_LWTBL_TXOP_PS_CAP_MASK,	NO_SHIFT_DEFINE,		false},
+	{"DONOT_UPDATE_I_PSM",	WF_LWTBL_DU_I_PSM_MASK,		NO_SHIFT_DEFINE,		true},
+	{"I_PSM",		WF_LWTBL_I_PSM_MASK,		NO_SHIFT_DEFINE,		false},
+	{"PSM",			WF_LWTBL_PSM_MASK,		NO_SHIFT_DEFINE,		false},
+	{"SKIP_TX",		WF_LWTBL_SKIP_TX_MASK,		NO_SHIFT_DEFINE,		true},
+	{NULL,}
+};
+
+static void parse_fmac_lwtbl_dw5(struct seq_file *s, u8 *lwtbl)
+{
+	u32 *addr = 0;
+	u32 dw_value = 0;
+	u16 i = 0;
+
+	/* LMAC WTBL DW 5 */
+	seq_printf(s, "\t\n");
+	seq_printf(s, "LWTBL DW 5\n");
+	addr = (u32 *)&(lwtbl[WTBL_GROUP_TRX_CAP_DW_5*4]);
+	dw_value = *addr;
+
+	while (WTBL_LMAC_DW5[i].name) {
+		if (WTBL_LMAC_DW5[i].shift == NO_SHIFT_DEFINE)
+			seq_printf(s, "\t%s:%d\n", WTBL_LMAC_DW5[i].name,
+					 (dw_value & WTBL_LMAC_DW5[i].mask) ? 1 : 0);
+		else
+			seq_printf(s, "\t%s:%u\n", WTBL_LMAC_DW5[i].name,
+					  (dw_value & WTBL_LMAC_DW5[i].mask) >> WTBL_LMAC_DW5[i].shift);
+		i++;
+	}
+}
+
+static const struct berse_wtbl_parse WTBL_LMAC_DW6[] = {
+	{"CBRN",	WF_LWTBL_CBRN_MASK,	WF_LWTBL_CBRN_SHIFT,	false},
+	{"DBNSS_EN",	WF_LWTBL_DBNSS_EN_MASK,	NO_SHIFT_DEFINE,	false},
+	{"BAF_EN",	WF_LWTBL_BAF_EN_MASK,	NO_SHIFT_DEFINE,	false},
+	{"RDGBA",	WF_LWTBL_RDGBA_MASK,	NO_SHIFT_DEFINE,	false},
+	{"RDG",		WF_LWTBL_R_MASK,	NO_SHIFT_DEFINE,	false},
+	{"SPE_IDX",	WF_LWTBL_SPE_IDX_MASK,	WF_LWTBL_SPE_IDX_SHIFT,	true},
+	{"G2",		WF_LWTBL_G2_MASK,	NO_SHIFT_DEFINE,	false},
+	{"G4",		WF_LWTBL_G4_MASK,	NO_SHIFT_DEFINE,	false},
+	{"G8",		WF_LWTBL_G8_MASK,	NO_SHIFT_DEFINE,	false},
+	{"G16",		WF_LWTBL_G16_MASK,	NO_SHIFT_DEFINE,	true},
+	{"G2_LTF",	WF_LWTBL_G2_LTF_MASK,	WF_LWTBL_G2_LTF_SHIFT,	false},
+	{"G4_LTF",	WF_LWTBL_G4_LTF_MASK,	WF_LWTBL_G4_LTF_SHIFT,	false},
+	{"G8_LTF",	WF_LWTBL_G8_LTF_MASK,	WF_LWTBL_G8_LTF_SHIFT,	false},
+	{"G16_LTF",	WF_LWTBL_G16_LTF_MASK,	WF_LWTBL_G16_LTF_SHIFT,	true},
+	{"G2_HE",	WF_LWTBL_G2_HE_MASK,	WF_LWTBL_G2_HE_SHIFT,	false},
+	{"G4_HE",	WF_LWTBL_G4_HE_MASK,	WF_LWTBL_G4_HE_SHIFT,	false},
+	{"G8_HE",	WF_LWTBL_G8_HE_MASK,	WF_LWTBL_G8_HE_SHIFT,	false},
+	{"G16_HE",	WF_LWTBL_G16_HE_MASK,	WF_LWTBL_G16_HE_SHIFT,	true},
+	{NULL,}
+};
+
+static void parse_fmac_lwtbl_dw6(struct seq_file *s, u8 *lwtbl)
+{
+	u32 *addr = 0;
+	u32 dw_value = 0;
+	u16 i = 0;
+
+	/* LMAC WTBL DW 6 */
+	seq_printf(s, "\t\n");
+	seq_printf(s, "LWTBL DW 6\n");
+	addr = (u32 *)&(lwtbl[WTBL_GROUP_TRX_CAP_DW_6*4]);
+	dw_value = *addr;
+
+	while (WTBL_LMAC_DW6[i].name) {
+		if (WTBL_LMAC_DW6[i].shift == NO_SHIFT_DEFINE)
+			seq_printf(s, "\t%s:%d\n", WTBL_LMAC_DW6[i].name,
+					 (dw_value & WTBL_LMAC_DW6[i].mask) ? 1 : 0);
+		else
+			seq_printf(s, "\t%s:%u\n", WTBL_LMAC_DW6[i].name,
+					  (dw_value & WTBL_LMAC_DW6[i].mask) >> WTBL_LMAC_DW6[i].shift);
+		i++;
+	}
+}
+
+static void parse_fmac_lwtbl_dw7(struct seq_file *s, u8 *lwtbl)
+{
+	u32 *addr = 0;
+	u32 dw_value = 0;
+	int i = 0;
+
+	/* LMAC WTBL DW 7 */
+	seq_printf(s, "\t\n");
+	seq_printf(s, "LWTBL DW 7\n");
+	addr = (u32 *)&(lwtbl[WTBL_GROUP_TRX_CAP_DW_7*4]);
+	dw_value = *addr;
+
+	for (i = 0; i < 8; i++) {
+		seq_printf(s, "\tBA_WIN_SIZE%u:%lu\n", i, ((dw_value & BITS(i*4, i*4+3)) >> i*4));
+	}
+}
+
+static const struct berse_wtbl_parse WTBL_LMAC_DW8[] = {
+	{"RTS_FAIL_CNT_AC0",	WF_LWTBL_AC0_RTS_FAIL_CNT_MASK,	WF_LWTBL_AC0_RTS_FAIL_CNT_SHIFT,	false},
+	{"AC1",			WF_LWTBL_AC1_RTS_FAIL_CNT_MASK,	WF_LWTBL_AC1_RTS_FAIL_CNT_SHIFT,	false},
+	{"AC2",			WF_LWTBL_AC2_RTS_FAIL_CNT_MASK,	WF_LWTBL_AC2_RTS_FAIL_CNT_SHIFT,	false},
+	{"AC3",			WF_LWTBL_AC3_RTS_FAIL_CNT_MASK,	WF_LWTBL_AC3_RTS_FAIL_CNT_SHIFT,	true},
+	{"PARTIAL_AID",		WF_LWTBL_PARTIAL_AID_MASK,	WF_LWTBL_PARTIAL_AID_SHIFT,		false},
+	{"CHK_PER",		WF_LWTBL_CHK_PER_MASK,		NO_SHIFT_DEFINE,			true},
+	{NULL,}
+};
+
+static void parse_fmac_lwtbl_dw8(struct seq_file *s, u8 *lwtbl)
+{
+	u32 *addr = 0;
+	u32 dw_value = 0;
+	u16 i = 0;
+
+	/* LMAC WTBL DW 8 */
+	seq_printf(s, "\t\n");
+	seq_printf(s, "LWTBL DW 8\n");
+	addr = (u32 *)&(lwtbl[WTBL_GROUP_TRX_CAP_DW_8*4]);
+	dw_value = *addr;
+
+	while (WTBL_LMAC_DW8[i].name) {
+		if (WTBL_LMAC_DW8[i].shift == NO_SHIFT_DEFINE)
+			seq_printf(s, "\t%s:%d\n", WTBL_LMAC_DW8[i].name,
+					 (dw_value & WTBL_LMAC_DW8[i].mask) ? 1 : 0);
+		else
+			seq_printf(s, "\t%s:%u\n", WTBL_LMAC_DW8[i].name,
+					  (dw_value & WTBL_LMAC_DW8[i].mask) >> WTBL_LMAC_DW8[i].shift);
+		i++;
+	}
+}
+
+static const struct berse_wtbl_parse *WTBL_LMAC_DW9;
+static const struct berse_wtbl_parse WTBL_LMAC_DW9_7996[] = {
+	{"RX_AVG_MPDU_SIZE",	WF_LWTBL_RX_AVG_MPDU_SIZE_MASK,	WF_LWTBL_RX_AVG_MPDU_SIZE_SHIFT,	false},
+	{"PRITX_SW_MODE",	WF_LWTBL_PRITX_SW_MODE_MASK,	NO_SHIFT_DEFINE,			false},
+	{"PRITX_ERSU",		WF_LWTBL_PRITX_ERSU_MASK,	NO_SHIFT_DEFINE,			false},
+	{"PRITX_PLR",		WF_LWTBL_PRITX_PLR_MASK,	NO_SHIFT_DEFINE,			true},
+	{"PRITX_DCM",		WF_LWTBL_PRITX_DCM_MASK,	NO_SHIFT_DEFINE,			false},
+	{"PRITX_ER106T",	WF_LWTBL_PRITX_ER106T_MASK,	NO_SHIFT_DEFINE,			true},
+	/* {"FCAP(0:20 1:~40)",	WTBL_FCAP_20_TO_160_MHZ,	WTBL_FCAP_20_TO_160_MHZ_OFFSET}, */
+	{"MPDU_FAIL_CNT",	WF_LWTBL_MPDU_FAIL_CNT_MASK,	WF_LWTBL_MPDU_FAIL_CNT_SHIFT,		false},
+	{"MPDU_OK_CNT",		WF_LWTBL_MPDU_OK_CNT_MASK,	WF_LWTBL_MPDU_OK_CNT_SHIFT,		false},
+	{"RATE_IDX",		WF_LWTBL_RATE_IDX_MASK,		WF_LWTBL_RATE_IDX_SHIFT,		true},
+	{NULL,}
+};
+
+static const struct berse_wtbl_parse WTBL_LMAC_DW9_7992[] = {
+	{"RX_AVG_MPDU_SIZE",	WF_LWTBL_RX_AVG_MPDU_SIZE_MASK,		WF_LWTBL_RX_AVG_MPDU_SIZE_SHIFT,	false},
+	{"PRITX_SW_MODE",	WF_LWTBL_PRITX_SW_MODE_MASK_7992,	NO_SHIFT_DEFINE,			false},
+	{"PRITX_ERSU",		WF_LWTBL_PRITX_ERSU_MASK_7992,		NO_SHIFT_DEFINE,			false},
+	{"PRITX_PLR",		WF_LWTBL_PRITX_PLR_MASK_7992,		NO_SHIFT_DEFINE,			true},
+	{"PRITX_DCM",		WF_LWTBL_PRITX_DCM_MASK,		NO_SHIFT_DEFINE,			false},
+	{"PRITX_ER106T",	WF_LWTBL_PRITX_ER106T_MASK,		NO_SHIFT_DEFINE,			true},
+	/* {"FCAP(0:20 1:~40)",	WTBL_FCAP_20_TO_160_MHZ,		WTBL_FCAP_20_TO_160_MHZ_OFFSET}, */
+	{"MPDU_FAIL_CNT",	WF_LWTBL_MPDU_FAIL_CNT_MASK,		WF_LWTBL_MPDU_FAIL_CNT_SHIFT,		false},
+	{"MPDU_OK_CNT",		WF_LWTBL_MPDU_OK_CNT_MASK,		WF_LWTBL_MPDU_OK_CNT_SHIFT,		false},
+	{"RATE_IDX",		WF_LWTBL_RATE_IDX_MASK,			WF_LWTBL_RATE_IDX_SHIFT,		true},
+	{NULL,}
+};
+
+char *fcap_name[] = {"20MHz", "20/40MHz", "20/40/80MHz", "20/40/80/160/80+80MHz", "20/40/80/160/80+80/320MHz"};
+
+static void parse_fmac_lwtbl_dw9(struct seq_file *s, u8 *lwtbl)
+{
+	u32 *addr = 0;
+	u32 dw_value = 0;
+	u16 i = 0;
+
+	/* LMAC WTBL DW 9 */
+	seq_printf(s, "\t\n");
+	seq_printf(s, "LWTBL DW 9\n");
+	addr = (u32 *)&(lwtbl[WTBL_GROUP_TRX_CAP_DW_9*4]);
+	dw_value = *addr;
+
+	while (WTBL_LMAC_DW9[i].name) {
+		if (WTBL_LMAC_DW9[i].shift == NO_SHIFT_DEFINE)
+			seq_printf(s, "\t%s:%d\n", WTBL_LMAC_DW9[i].name,
+					 (dw_value & WTBL_LMAC_DW9[i].mask) ? 1 : 0);
+		else
+			seq_printf(s, "\t%s:%u\n", WTBL_LMAC_DW9[i].name,
+					  (dw_value & WTBL_LMAC_DW9[i].mask) >> WTBL_LMAC_DW9[i].shift);
+		i++;
+	}
+
+	/* FCAP parser */
+	seq_printf(s, "\t\n");
+	seq_printf(s, "FCAP:%s\n", fcap_name[(dw_value & WF_LWTBL_FCAP_MASK) >> WF_LWTBL_FCAP_SHIFT]);
+}
+
+#define HW_TX_RATE_TO_MODE(_x)			(((_x) & WTBL_RATE_TX_MODE_MASK) >> WTBL_RATE_TX_MODE_OFFSET)
+#define HW_TX_RATE_TO_MCS(_x, _mode)		((_x) & WTBL_RATE_TX_RATE_MASK >> WTBL_RATE_TX_RATE_OFFSET)
+#define HW_TX_RATE_TO_NSS(_x)			(((_x) & WTBL_RATE_NSTS_MASK) >> WTBL_RATE_NSTS_OFFSET)
+#define HW_TX_RATE_TO_STBC(_x)			(((_x) & WTBL_RATE_STBC_MASK) >> WTBL_RATE_STBC_OFFSET)
+
+#define MAX_TX_MODE 16
+static char *HW_TX_MODE_STR[] = {"CCK", "OFDM", "HT-Mix", "HT-GF", "VHT",
+				 "N/A", "N/A", "N/A",
+				 "HE_SU", "HE_EXT_SU", "HE_TRIG", "HE_MU",
+				 "N/A",
+				 "EHT_EXT_SU", "EHT_TRIG", "EHT_MU",
+				 "N/A"};
+static char *HW_TX_RATE_CCK_STR[] = {"1M", "2Mlong", "5.5Mlong", "11Mlong", "N/A", "2Mshort", "5.5Mshort", "11Mshort", "N/A"};
+static char *HW_TX_RATE_OFDM_STR[] = {"6M", "9M", "12M", "18M", "24M", "36M", "48M", "54M", "N/A"};
+
+static char *hw_rate_ofdm_str(uint16_t ofdm_idx)
+{
+	switch (ofdm_idx) {
+	case 11: /* 6M */
+		return HW_TX_RATE_OFDM_STR[0];
+
+	case 15: /* 9M */
+		return HW_TX_RATE_OFDM_STR[1];
+
+	case 10: /* 12M */
+		return HW_TX_RATE_OFDM_STR[2];
+
+	case 14: /* 18M */
+		return HW_TX_RATE_OFDM_STR[3];
+
+	case 9: /* 24M */
+		return HW_TX_RATE_OFDM_STR[4];
+
+	case 13: /* 36M */
+		return HW_TX_RATE_OFDM_STR[5];
+
+	case 8: /* 48M */
+		return HW_TX_RATE_OFDM_STR[6];
+
+	case 12: /* 54M */
+		return HW_TX_RATE_OFDM_STR[7];
+
+	default:
+		return HW_TX_RATE_OFDM_STR[8];
+	}
+}
+
+static char *hw_rate_str(u8 mode, uint16_t rate_idx)
+{
+	if (mode == 0)
+		return rate_idx < 8 ? HW_TX_RATE_CCK_STR[rate_idx] : HW_TX_RATE_CCK_STR[8];
+	else if (mode == 1)
+		return hw_rate_ofdm_str(rate_idx);
+	else
+		return "MCS";
+}
+
+static void
+parse_rate(struct seq_file *s, uint16_t rate_idx, uint16_t txrate)
+{
+	uint16_t txmode, mcs, nss, stbc;
+
+	txmode = HW_TX_RATE_TO_MODE(txrate);
+	mcs = HW_TX_RATE_TO_MCS(txrate, txmode);
+	nss = HW_TX_RATE_TO_NSS(txrate);
+	stbc = HW_TX_RATE_TO_STBC(txrate);
+
+	seq_printf(s, "\tRate%d(0x%x):TxMode=%d(%s), TxRate=%d(%s), Nsts=%d, STBC=%d\n",
+			  rate_idx + 1, txrate,
+			  txmode, (txmode < MAX_TX_MODE ? HW_TX_MODE_STR[txmode] : HW_TX_MODE_STR[MAX_TX_MODE]),
+			  mcs, hw_rate_str(txmode, mcs), nss, stbc);
+}
+
+
+static const struct berse_wtbl_parse WTBL_LMAC_DW10[] = {
+	{"RATE1",	WF_LWTBL_RATE1_MASK,	WF_LWTBL_RATE1_SHIFT},
+	{"RATE2",	WF_LWTBL_RATE2_MASK,	WF_LWTBL_RATE2_SHIFT},
+	{NULL,}
+};
+
+static void parse_fmac_lwtbl_dw10(struct seq_file *s, u8 *lwtbl)
+{
+	u32 *addr = 0;
+	u32 dw_value = 0;
+	u16 i = 0;
+
+	/* LMAC WTBL DW 10 */
+	seq_printf(s, "\t\n");
+	seq_printf(s, "LWTBL DW 10\n");
+	addr = (u32 *)&(lwtbl[WTBL_GROUP_AUTO_RATE_1_2*4]);
+	dw_value = *addr;
+
+	while (WTBL_LMAC_DW10[i].name) {
+		parse_rate(s, i, (dw_value & WTBL_LMAC_DW10[i].mask) >> WTBL_LMAC_DW10[i].shift);
+		i++;
+	}
+}
+
+static const struct berse_wtbl_parse WTBL_LMAC_DW11[] = {
+	{"RATE3",	WF_LWTBL_RATE3_MASK,	WF_LWTBL_RATE3_SHIFT},
+	{"RATE4",	WF_LWTBL_RATE4_MASK,	WF_LWTBL_RATE4_SHIFT},
+	{NULL,}
+};
+
+static void parse_fmac_lwtbl_dw11(struct seq_file *s, u8 *lwtbl)
+{
+	u32 *addr = 0;
+	u32 dw_value = 0;
+	u16 i = 0;
+
+	/* LMAC WTBL DW 11 */
+	seq_printf(s, "\t\n");
+	seq_printf(s, "LWTBL DW 11\n");
+	addr = (u32 *)&(lwtbl[WTBL_GROUP_AUTO_RATE_3_4*4]);
+	dw_value = *addr;
+
+	while (WTBL_LMAC_DW11[i].name) {
+		parse_rate(s, i+2, (dw_value & WTBL_LMAC_DW11[i].mask) >> WTBL_LMAC_DW11[i].shift);
+		i++;
+	}
+}
+
+static const struct berse_wtbl_parse WTBL_LMAC_DW12[] = {
+	{"RATE5",	WF_LWTBL_RATE5_MASK,	WF_LWTBL_RATE5_SHIFT},
+	{"RATE6",	WF_LWTBL_RATE6_MASK,	WF_LWTBL_RATE6_SHIFT},
+	{NULL,}
+};
+
+static void parse_fmac_lwtbl_dw12(struct seq_file *s, u8 *lwtbl)
+{
+	u32 *addr = 0;
+	u32 dw_value = 0;
+	u16 i = 0;
+
+	/* LMAC WTBL DW 12 */
+	seq_printf(s, "\t\n");
+	seq_printf(s, "LWTBL DW 12\n");
+	addr = (u32 *)&(lwtbl[WTBL_GROUP_AUTO_RATE_5_6*4]);
+	dw_value = *addr;
+
+	while (WTBL_LMAC_DW12[i].name) {
+		parse_rate(s, i+4, (dw_value & WTBL_LMAC_DW12[i].mask) >> WTBL_LMAC_DW12[i].shift);
+		i++;
+	}
+}
+
+static const struct berse_wtbl_parse WTBL_LMAC_DW13[] = {
+	{"RATE7",	WF_LWTBL_RATE7_MASK,	WF_LWTBL_RATE7_SHIFT},
+	{"RATE8",	WF_LWTBL_RATE8_MASK,	WF_LWTBL_RATE8_SHIFT},
+	{NULL,}
+};
+
+static void parse_fmac_lwtbl_dw13(struct seq_file *s, u8 *lwtbl)
+{
+	u32 *addr = 0;
+	u32 dw_value = 0;
+	u16 i = 0;
+
+	/* LMAC WTBL DW 13 */
+	seq_printf(s, "\t\n");
+	seq_printf(s, "LWTBL DW 13\n");
+	addr = (u32 *)&(lwtbl[WTBL_GROUP_AUTO_RATE_7_8*4]);
+	dw_value = *addr;
+
+	while (WTBL_LMAC_DW13[i].name) {
+		parse_rate(s, i+6, (dw_value & WTBL_LMAC_DW13[i].mask) >> WTBL_LMAC_DW13[i].shift);
+		i++;
+	}
+}
+
+static const struct berse_wtbl_parse WTBL_LMAC_DW14_BMC[] = {
+	{"CIPHER_IGTK",		WF_LWTBL_CIPHER_SUIT_IGTK_MASK,		WF_LWTBL_CIPHER_SUIT_IGTK_SHIFT,	false},
+	{"CIPHER_BIGTK",	WF_LWTBL_CIPHER_SUIT_BIGTK_MASK,	WF_LWTBL_CIPHER_SUIT_BIGTK_SHIFT,	true},
+	{NULL,}
+};
+
+static const struct berse_wtbl_parse WTBL_LMAC_DW14[] = {
+	{"RATE1_TX_CNT",	WF_LWTBL_RATE1_TX_CNT_MASK,	WF_LWTBL_RATE1_TX_CNT_SHIFT,	false},
+	{"RATE1_FAIL_CNT",	WF_LWTBL_RATE1_FAIL_CNT_MASK,	WF_LWTBL_RATE1_FAIL_CNT_SHIFT,	true},
+	{NULL,}
+};
+
+static void parse_fmac_lwtbl_dw14(struct seq_file *s, u8 *lwtbl)
+{
+	u32 *addr, *muar_addr = 0;
+	u32 dw_value, muar_dw_value = 0;
+	u16 i = 0;
+
+	/* DUMP DW14 for BMC entry only */
+	muar_addr = (u32 *)&(lwtbl[WF_LWTBL_MUAR_DW*4]);
+	muar_dw_value = *muar_addr;
+	if (((muar_dw_value & WF_LWTBL_MUAR_MASK) >> WF_LWTBL_MUAR_SHIFT)
+		== MUAR_INDEX_OWN_MAC_ADDR_BC_MC) {
+		/* LMAC WTBL DW 14 */
+		seq_printf(s, "\t\n");
+		seq_printf(s, "LWTBL DW 14\n");
+		addr = (u32 *)&(lwtbl[WF_LWTBL_CIPHER_SUIT_IGTK_DW*4]);
+		dw_value = *addr;
+
+		while (WTBL_LMAC_DW14_BMC[i].name) {
+			if (WTBL_LMAC_DW14_BMC[i].shift == NO_SHIFT_DEFINE)
+				seq_printf(s, "\t%s:%d\n", WTBL_LMAC_DW14_BMC[i].name,
+					(dw_value & WTBL_LMAC_DW14_BMC[i].mask) ? 1 : 0);
+			else
+				seq_printf(s, "\t%s:%u\n", WTBL_LMAC_DW14_BMC[i].name,
+					(dw_value & WTBL_LMAC_DW14_BMC[i].mask) >> WTBL_LMAC_DW14_BMC[i].shift);
+			i++;
+		}
+	} else {
+		seq_printf(s, "\t\n");
+		seq_printf(s, "LWTBL DW 14\n");
+		addr = (u32 *)&(lwtbl[WF_LWTBL_CIPHER_SUIT_IGTK_DW*4]);
+		dw_value = *addr;
+
+		while (WTBL_LMAC_DW14[i].name) {
+			if (WTBL_LMAC_DW14[i].shift == NO_SHIFT_DEFINE)
+				seq_printf(s, "\t%s:%d\n", WTBL_LMAC_DW14[i].name,
+					(dw_value & WTBL_LMAC_DW14[i].mask) ? 1 : 0);
+			else
+				seq_printf(s, "\t%s:%u\n", WTBL_LMAC_DW14[i].name,
+					(dw_value & WTBL_LMAC_DW14[i].mask) >> WTBL_LMAC_DW14[i].shift);
+			i++;
+		}
+	}
+}
+
+static const struct berse_wtbl_parse WTBL_LMAC_DW28[] = {
+	{"RELATED_IDX0",	WF_LWTBL_RELATED_IDX0_MASK,		WF_LWTBL_RELATED_IDX0_SHIFT,		false},
+	{"RELATED_BAND0",	WF_LWTBL_RELATED_BAND0_MASK,		WF_LWTBL_RELATED_BAND0_SHIFT,		false},
+	{"PRI_MLD_BAND",	WF_LWTBL_PRIMARY_MLD_BAND_MASK,		WF_LWTBL_PRIMARY_MLD_BAND_SHIFT,	true},
+	{"RELATED_IDX1",	WF_LWTBL_RELATED_IDX1_MASK,		WF_LWTBL_RELATED_IDX1_SHIFT,		false},
+	{"RELATED_BAND1",	WF_LWTBL_RELATED_BAND1_MASK,		WF_LWTBL_RELATED_BAND1_SHIFT,		false},
+	{"SEC_MLD_BAND",	WF_LWTBL_SECONDARY_MLD_BAND_MASK,	WF_LWTBL_SECONDARY_MLD_BAND_SHIFT,	true},
+	{NULL,}
+};
+
+static void parse_fmac_lwtbl_dw28(struct seq_file *s, u8 *lwtbl)
+{
+	u32 *addr = 0;
+	u32 dw_value = 0;
+	u16 i = 0;
+
+	/* LMAC WTBL DW 28 */
+	seq_printf(s, "\t\n");
+	seq_printf(s, "LWTBL DW 28\n");
+	addr = (u32 *)&(lwtbl[WTBL_GROUP_MLO_INFO_LINE_1*4]);
+	dw_value = *addr;
+
+	while (WTBL_LMAC_DW28[i].name) {
+		if (WTBL_LMAC_DW28[i].shift == NO_SHIFT_DEFINE)
+			seq_printf(s, "\t%s:%d\n", WTBL_LMAC_DW28[i].name,
+				(dw_value & WTBL_LMAC_DW28[i].mask) ? 1 : 0);
+		else
+			seq_printf(s, "\t%s:%u\n", WTBL_LMAC_DW28[i].name,
+				(dw_value & WTBL_LMAC_DW28[i].mask) >>
+					WTBL_LMAC_DW28[i].shift);
+		i++;
+	}
+}
+
+static const struct berse_wtbl_parse WTBL_LMAC_DW29[] = {
+	{"DISPATCH_POLICY_MLD_TID0",	WF_LWTBL_DISPATCH_POLICY0_MASK,		WF_LWTBL_DISPATCH_POLICY0_SHIFT,	false},
+	{"MLD_TID1",			WF_LWTBL_DISPATCH_POLICY1_MASK,		WF_LWTBL_DISPATCH_POLICY1_SHIFT,	false},
+	{"MLD_TID2",			WF_LWTBL_DISPATCH_POLICY2_MASK,		WF_LWTBL_DISPATCH_POLICY2_SHIFT,	false},
+	{"MLD_TID3",			WF_LWTBL_DISPATCH_POLICY3_MASK,		WF_LWTBL_DISPATCH_POLICY3_SHIFT,	true},
+	{"MLD_TID4",			WF_LWTBL_DISPATCH_POLICY4_MASK,		WF_LWTBL_DISPATCH_POLICY4_SHIFT,	false},
+	{"MLD_TID5",			WF_LWTBL_DISPATCH_POLICY5_MASK,		WF_LWTBL_DISPATCH_POLICY5_SHIFT,	false},
+	{"MLD_TID6",			WF_LWTBL_DISPATCH_POLICY6_MASK,		WF_LWTBL_DISPATCH_POLICY6_SHIFT,	false},
+	{"MLD_TID7",			WF_LWTBL_DISPATCH_POLICY7_MASK,		WF_LWTBL_DISPATCH_POLICY7_SHIFT,	true},
+	{"OMLD_ID",			WF_LWTBL_OWN_MLD_ID_MASK,		WF_LWTBL_OWN_MLD_ID_SHIFT,		false},
+	{"EMLSR0",			WF_LWTBL_EMLSR0_MASK,			NO_SHIFT_DEFINE,			false},
+	{"EMLMR0",			WF_LWTBL_EMLMR0_MASK,			NO_SHIFT_DEFINE,			false},
+	{"EMLSR1",			WF_LWTBL_EMLSR1_MASK,			NO_SHIFT_DEFINE,			false},
+	{"EMLMR1",			WF_LWTBL_EMLMR1_MASK,			NO_SHIFT_DEFINE,			true},
+	{"EMLSR2",			WF_LWTBL_EMLSR2_MASK,			NO_SHIFT_DEFINE,			false},
+	{"EMLMR2",			WF_LWTBL_EMLMR2_MASK,			NO_SHIFT_DEFINE,			false},
+	{"STR_BITMAP",			WF_LWTBL_STR_BITMAP_MASK,		WF_LWTBL_STR_BITMAP_SHIFT,		true},
+	{NULL,}
+};
+
+static void parse_fmac_lwtbl_dw29(struct seq_file *s, u8 *lwtbl)
+{
+	u32 *addr = 0;
+	u32 dw_value = 0;
+	u16 i = 0;
+
+	/* LMAC WTBL DW 29 */
+	seq_printf(s, "\t\n");
+	seq_printf(s, "LWTBL DW 29\n");
+	addr = (u32 *)&(lwtbl[WTBL_GROUP_MLO_INFO_LINE_2*4]);
+	dw_value = *addr;
+
+	while (WTBL_LMAC_DW29[i].name) {
+		if (WTBL_LMAC_DW29[i].shift == NO_SHIFT_DEFINE)
+			seq_printf(s, "\t%s:%d\n", WTBL_LMAC_DW29[i].name,
+				(dw_value & WTBL_LMAC_DW29[i].mask) ? 1 : 0);
+		else
+			seq_printf(s, "\t%s:%u\n", WTBL_LMAC_DW29[i].name,
+				(dw_value & WTBL_LMAC_DW29[i].mask) >>
+					WTBL_LMAC_DW29[i].shift);
+		i++;
+	}
+}
+
+static const struct berse_wtbl_parse WTBL_LMAC_DW30[] = {
+	{"DISPATCH_ORDER",	WF_LWTBL_DISPATCH_ORDER_MASK,	WF_LWTBL_DISPATCH_ORDER_SHIFT,	false},
+	{"DISPATCH_RATIO",	WF_LWTBL_DISPATCH_RATIO_MASK,	WF_LWTBL_DISPATCH_RATIO_SHIFT,	false},
+	{"LINK_MGF",		WF_LWTBL_LINK_MGF_MASK,		WF_LWTBL_LINK_MGF_SHIFT,	true},
+	{NULL,}
+};
+
+static void parse_fmac_lwtbl_dw30(struct seq_file *s, u8 *lwtbl)
+{
+	u32 *addr = 0;
+	u32 dw_value = 0;
+	u16 i = 0;
+
+	/* LMAC WTBL DW 30 */
+	seq_printf(s, "\t\n");
+	seq_printf(s, "LWTBL DW 30\n");
+	addr = (u32 *)&(lwtbl[WTBL_GROUP_MLO_INFO_LINE_3*4]);
+	dw_value = *addr;
+
+
+	while (WTBL_LMAC_DW30[i].name) {
+		if (WTBL_LMAC_DW30[i].shift == NO_SHIFT_DEFINE)
+			seq_printf(s, "\t%s:%d\n", WTBL_LMAC_DW30[i].name,
+				(dw_value & WTBL_LMAC_DW30[i].mask) ? 1 : 0);
+		else
+			seq_printf(s, "\t%s:%u\n", WTBL_LMAC_DW30[i].name,
+				(dw_value & WTBL_LMAC_DW30[i].mask) >> WTBL_LMAC_DW30[i].shift);
+		i++;
+	}
+}
+
+static const struct berse_wtbl_parse WTBL_LMAC_DW31[] = {
+	{"BFTX_TB",		WF_LWTBL_BFTX_TB_MASK,		NO_SHIFT_DEFINE,		false},
+	{"DROP",		WF_LWTBL_DROP_MASK,		NO_SHIFT_DEFINE,		false},
+	{"CASCAD",		WF_LWTBL_CASCAD_MASK,		NO_SHIFT_DEFINE,		false},
+	{"ALL_ACK",		WF_LWTBL_ALL_ACK_MASK,		NO_SHIFT_DEFINE,		false},
+	{"MPDU_SIZE",		WF_LWTBL_MPDU_SIZE_MASK,	WF_LWTBL_MPDU_SIZE_SHIFT,	false},
+	{"RXD_DUP_MODE",	WF_LWTBL_RXD_DUP_MODE_MASK,	WF_LWTBL_RXD_DUP_MODE_SHIFT,	true},
+	{"ACK_EN",		WF_LWTBL_ACK_EN_MASK,		NO_SHIFT_DEFINE,		true},
+	{NULL,}
+};
+
+static void parse_fmac_lwtbl_dw31(struct seq_file *s, u8 *lwtbl)
+{
+	u32 *addr = 0;
+	u32 dw_value = 0;
+	u16 i = 0;
+
+	/* LMAC WTBL DW 31 */
+	seq_printf(s, "\t\n");
+	seq_printf(s, "LWTBL DW 31\n");
+	addr = (u32 *)&(lwtbl[WTBL_GROUP_RESP_INFO_DW_31*4]);
+	dw_value = *addr;
+
+	while (WTBL_LMAC_DW31[i].name) {
+		if (WTBL_LMAC_DW31[i].shift == NO_SHIFT_DEFINE)
+			seq_printf(s, "\t%s:%d\n", WTBL_LMAC_DW31[i].name,
+				(dw_value & WTBL_LMAC_DW31[i].mask) ? 1 : 0);
+		else
+			seq_printf(s, "\t%s:%u\n", WTBL_LMAC_DW31[i].name,
+				(dw_value & WTBL_LMAC_DW31[i].mask) >>
+					WTBL_LMAC_DW31[i].shift);
+		i++;
+	}
+}
+
+static const struct berse_wtbl_parse WTBL_LMAC_DW32[] = {
+	{"OM_INFO",			WF_LWTBL_OM_INFO_MASK,			WF_LWTBL_OM_INFO_SHIFT,		false},
+	{"OM_INFO_EHT",         WF_LWTBL_OM_INFO_EHT_MASK,         WF_LWTBL_OM_INFO_EHT_SHIFT,  false},
+	{"RXD_DUP_FOR_OM_CHG",		WF_LWTBL_RXD_DUP_FOR_OM_CHG_MASK,	NO_SHIFT_DEFINE,		false},
+	{"RXD_DUP_WHITE_LIST",	WF_LWTBL_RXD_DUP_WHITE_LIST_MASK,	WF_LWTBL_RXD_DUP_WHITE_LIST_SHIFT,	false},
+	{NULL,}
+};
+
+static void parse_fmac_lwtbl_dw32(struct seq_file *s, u8 *lwtbl)
+{
+	u32 *addr = 0;
+	u32 dw_value = 0;
+	u16 i = 0;
+
+	/* LMAC WTBL DW 32 */
+	seq_printf(s, "\t\n");
+	seq_printf(s, "LWTBL DW 32\n");
+	addr = (u32 *)&(lwtbl[WTBL_GROUP_RX_DUP_INFO_DW_32*4]);
+	dw_value = *addr;
+
+	while (WTBL_LMAC_DW32[i].name) {
+		if (WTBL_LMAC_DW32[i].shift == NO_SHIFT_DEFINE)
+			seq_printf(s, "\t%s:%d\n", WTBL_LMAC_DW32[i].name,
+				(dw_value & WTBL_LMAC_DW32[i].mask) ? 1 : 0);
+		else
+			seq_printf(s, "\t%s:%u\n", WTBL_LMAC_DW32[i].name,
+				(dw_value & WTBL_LMAC_DW32[i].mask) >>
+					WTBL_LMAC_DW32[i].shift);
+		i++;
+	}
+}
+
+static const struct berse_wtbl_parse WTBL_LMAC_DW33[] = {
+	{"USER_RSSI",			WF_LWTBL_USER_RSSI_MASK,		WF_LWTBL_USER_RSSI_SHIFT,		false},
+	{"USER_SNR",			WF_LWTBL_USER_SNR_MASK,			WF_LWTBL_USER_SNR_SHIFT,		false},
+	{"RAPID_REACTION_RATE",		WF_LWTBL_RAPID_REACTION_RATE_MASK,	WF_LWTBL_RAPID_REACTION_RATE_SHIFT,	true},
+	{"HT_AMSDU(Read Only)",		WF_LWTBL_HT_AMSDU_MASK,			NO_SHIFT_DEFINE,			false},
+	{"AMSDU_CROSS_LG(Read Only)",	WF_LWTBL_AMSDU_CROSS_LG_MASK,		NO_SHIFT_DEFINE,			true},
+	{NULL,}
+};
+
+static void parse_fmac_lwtbl_dw33(struct seq_file *s, u8 *lwtbl)
+{
+	u32 *addr = 0;
+	u32 dw_value = 0;
+	u16 i = 0;
+
+	/* LMAC WTBL DW 33 */
+	seq_printf(s, "\t\n");
+	seq_printf(s, "LWTBL DW 33\n");
+	addr = (u32 *)&(lwtbl[WTBL_GROUP_RX_STAT_CNT_LINE_1*4]);
+	dw_value = *addr;
+
+	while (WTBL_LMAC_DW33[i].name) {
+		if (WTBL_LMAC_DW33[i].shift == NO_SHIFT_DEFINE)
+			seq_printf(s, "\t%s:%d\n", WTBL_LMAC_DW33[i].name,
+				(dw_value & WTBL_LMAC_DW33[i].mask) ? 1 : 0);
+		else
+			seq_printf(s, "\t%s:%u\n", WTBL_LMAC_DW33[i].name,
+				(dw_value & WTBL_LMAC_DW33[i].mask) >>
+					WTBL_LMAC_DW33[i].shift);
+		i++;
+	}
+}
+
+static const struct berse_wtbl_parse WTBL_LMAC_DW34[] = {
+	{"RESP_RCPI0",	WF_LWTBL_RESP_RCPI0_MASK,	WF_LWTBL_RESP_RCPI0_SHIFT,	false},
+	{"RCPI1",	WF_LWTBL_RESP_RCPI1_MASK,	WF_LWTBL_RESP_RCPI1_SHIFT,	false},
+	{"RCPI2",	WF_LWTBL_RESP_RCPI2_MASK,	WF_LWTBL_RESP_RCPI2_SHIFT,	false},
+	{"RCPI3",	WF_LWTBL_RESP_RCPI3_MASK,	WF_LWTBL_RESP_RCPI3_SHIFT,	true},
+	{NULL,}
+};
+
+static void parse_fmac_lwtbl_dw34(struct seq_file *s, u8 *lwtbl)
+{
+	u32 *addr = 0;
+	u32 dw_value = 0;
+	u16 i = 0;
+
+	/* LMAC WTBL DW 34 */
+	seq_printf(s, "\t\n");
+	seq_printf(s, "LWTBL DW 34\n");
+	addr = (u32 *)&(lwtbl[WTBL_GROUP_RX_STAT_CNT_LINE_2*4]);
+	dw_value = *addr;
+
+
+	while (WTBL_LMAC_DW34[i].name) {
+		if (WTBL_LMAC_DW34[i].shift == NO_SHIFT_DEFINE)
+			seq_printf(s, "\t%s:%d\n", WTBL_LMAC_DW34[i].name,
+				(dw_value & WTBL_LMAC_DW34[i].mask) ? 1 : 0);
+		else
+			seq_printf(s, "\t%s:%u\n", WTBL_LMAC_DW34[i].name,
+				(dw_value & WTBL_LMAC_DW34[i].mask) >>
+					WTBL_LMAC_DW34[i].shift);
+		i++;
+	}
+}
+
+static const struct berse_wtbl_parse WTBL_LMAC_DW35[] = {
+	{"SNR 0",	WF_LWTBL_SNR_RX0_MASK,		WF_LWTBL_SNR_RX0_SHIFT,		false},
+	{"SNR 1",	WF_LWTBL_SNR_RX1_MASK,		WF_LWTBL_SNR_RX1_SHIFT,		false},
+	{"SNR 2",	WF_LWTBL_SNR_RX2_MASK,		WF_LWTBL_SNR_RX2_SHIFT,		false},
+	{"SNR 3",	WF_LWTBL_SNR_RX3_MASK,		WF_LWTBL_SNR_RX3_SHIFT,		true},
+	{NULL,}
+};
+
+static void parse_fmac_lwtbl_dw35(struct seq_file *s, u8 *lwtbl)
+{
+	u32 *addr = 0;
+	u32 dw_value = 0;
+	u16 i = 0;
+
+	/* LMAC WTBL DW 35 */
+	seq_printf(s, "\t\n");
+	seq_printf(s, "LWTBL DW 35\n");
+	addr = (u32 *)&(lwtbl[WTBL_GROUP_RX_STAT_CNT_LINE_3*4]);
+	dw_value = *addr;
+
+
+	while (WTBL_LMAC_DW35[i].name) {
+		if (WTBL_LMAC_DW35[i].shift == NO_SHIFT_DEFINE)
+			seq_printf(s, "\t%s:%d\n", WTBL_LMAC_DW35[i].name,
+				(dw_value & WTBL_LMAC_DW35[i].mask) ? 1 : 0);
+		else
+			seq_printf(s, "\t%s:%u\n", WTBL_LMAC_DW35[i].name,
+				(dw_value & WTBL_LMAC_DW35[i].mask) >>
+					WTBL_LMAC_DW35[i].shift);
+		i++;
+	}
+}
+
+static void parse_fmac_lwtbl_rx_stats(struct seq_file *s, u8 *lwtbl)
+{
+	parse_fmac_lwtbl_dw33(s, lwtbl);
+	parse_fmac_lwtbl_dw34(s, lwtbl);
+	parse_fmac_lwtbl_dw35(s, lwtbl);
+}
+
+static void parse_fmac_lwtbl_mlo_info(struct seq_file *s, u8 *lwtbl)
+{
+	parse_fmac_lwtbl_dw28(s, lwtbl);
+	parse_fmac_lwtbl_dw29(s, lwtbl);
+	parse_fmac_lwtbl_dw30(s, lwtbl);
+}
+
+static const struct berse_wtbl_parse WTBL_UMAC_DW9[] = {
+	{"RELATED_IDX0",	WF_UWTBL_RELATED_IDX0_MASK,		WF_UWTBL_RELATED_IDX0_SHIFT,		false},
+	{"RELATED_BAND0",	WF_UWTBL_RELATED_BAND0_MASK,		WF_UWTBL_RELATED_BAND0_SHIFT,		false},
+	{"PRI_MLD_BAND",	WF_UWTBL_PRIMARY_MLD_BAND_MASK,		WF_UWTBL_PRIMARY_MLD_BAND_SHIFT,	true},
+	{"RELATED_IDX1",	WF_UWTBL_RELATED_IDX1_MASK,		WF_UWTBL_RELATED_IDX1_SHIFT,		false},
+	{"RELATED_BAND1",	WF_UWTBL_RELATED_BAND1_MASK,		WF_UWTBL_RELATED_BAND1_SHIFT,		false},
+	{"SEC_MLD_BAND",	WF_UWTBL_SECONDARY_MLD_BAND_MASK,	WF_UWTBL_SECONDARY_MLD_BAND_SHIFT,	true},
+	{NULL,}
+};
+
+static void parse_fmac_uwtbl_mlo_info(struct seq_file *s, u8 *uwtbl)
+{
+	u32 *addr = 0;
+	u32 dw_value = 0;
+	u16 i = 0;
+
+	seq_printf(s, "\t\n");
+	seq_printf(s, "MldAddr: %02x:%02x:%02x:%02x:%02x:%02x(D0[B0~15], D1[B0~31])\n",
+		uwtbl[4], uwtbl[5], uwtbl[6], uwtbl[7], uwtbl[0], uwtbl[1]);
+
+	/* UMAC WTBL DW 0 */
+	seq_printf(s, "\t\n");
+	seq_printf(s, "UWTBL DW 0\n");
+	addr = (u32 *)&(uwtbl[WF_UWTBL_OWN_MLD_ID_DW*4]);
+	dw_value = *addr;
+
+	seq_printf(s, "\t%s:%u\n", "OMLD_ID",
+		(dw_value & WF_UWTBL_OWN_MLD_ID_MASK) >> WF_UWTBL_OWN_MLD_ID_SHIFT);
+
+	/* UMAC WTBL DW 9 */
+	seq_printf(s, "\t\n");
+	seq_printf(s, "UWTBL DW 9\n");
+	addr = (u32 *)&(uwtbl[WF_UWTBL_RELATED_IDX0_DW*4]);
+	dw_value = *addr;
+
+	while (WTBL_UMAC_DW9[i].name) {
+
+		if (WTBL_UMAC_DW9[i].shift == NO_SHIFT_DEFINE)
+			seq_printf(s, "\t%s:%d\n", WTBL_UMAC_DW9[i].name,
+				(dw_value & WTBL_UMAC_DW9[i].mask) ? 1 : 0);
+		else
+			seq_printf(s, "\t%s:%u\n", WTBL_UMAC_DW9[i].name,
+				 (dw_value & WTBL_UMAC_DW9[i].mask) >>
+					WTBL_UMAC_DW9[i].shift);
+		i++;
+	}
+}
+
+static bool
+is_wtbl_bigtk_exist(u8 *lwtbl)
+{
+	u32 *addr = 0;
+	u32 dw_value = 0;
+
+	addr = (u32 *)&(lwtbl[WF_LWTBL_MUAR_DW*4]);
+	dw_value = *addr;
+	if (((dw_value & WF_LWTBL_MUAR_MASK) >> WF_LWTBL_MUAR_SHIFT) ==
+					MUAR_INDEX_OWN_MAC_ADDR_BC_MC) {
+		addr = (u32 *)&(lwtbl[WF_LWTBL_CIPHER_SUIT_BIGTK_DW*4]);
+		dw_value = *addr;
+		if (((dw_value & WF_LWTBL_CIPHER_SUIT_BIGTK_MASK) >>
+			WF_LWTBL_CIPHER_SUIT_BIGTK_SHIFT) != IGTK_CIPHER_SUIT_NONE)
+			return true;
+	}
+
+	return false;
+}
+
+static const struct berse_wtbl_parse WTBL_UMAC_DW2[] = {
+	{"PN0",		WTBL_PN0_MASK,		WTBL_PN0_OFFSET,	false},
+	{"PN1",		WTBL_PN1_MASK,		WTBL_PN1_OFFSET,	false},
+	{"PN2",		WTBL_PN2_MASK,		WTBL_PN2_OFFSET,	true},
+	{"PN3",		WTBL_PN3_MASK,		WTBL_PN3_OFFSET,	false},
+	{NULL,}
+};
+
+static const struct berse_wtbl_parse WTBL_UMAC_DW3[] = {
+	{"PN4",		WTBL_PN4_MASK,		WTBL_PN4_OFFSET,	false},
+	{"PN5",		WTBL_PN5_MASK,		WTBL_PN5_OFFSET,	true},
+	{"COM_SN",	WF_UWTBL_COM_SN_MASK,	WF_UWTBL_COM_SN_SHIFT,	true},
+	{NULL,}
+};
+
+static const struct berse_wtbl_parse WTBL_UMAC_DW4_BIPN[] = {
+	{"BIPN0",	WTBL_BIPN0_MASK,	WTBL_BIPN0_OFFSET,	false},
+	{"BIPN1",	WTBL_BIPN1_MASK,	WTBL_BIPN1_OFFSET,	false},
+	{"BIPN2",	WTBL_BIPN2_MASK,	WTBL_BIPN2_OFFSET,	true},
+	{"BIPN3",	WTBL_BIPN3_MASK,	WTBL_BIPN3_OFFSET,	false},
+	{NULL,}
+};
+
+static const struct berse_wtbl_parse WTBL_UMAC_DW5_BIPN[] = {
+	{"BIPN4",	WTBL_BIPN4_MASK,	WTBL_BIPN4_OFFSET,	false},
+	{"BIPN5",	WTBL_BIPN5_MASK,	WTBL_BIPN5_OFFSET,	true},
+	{NULL,}
+};
+
+static void parse_fmac_uwtbl_pn(struct seq_file *s, u8 *uwtbl, u8 *lwtbl)
+{
+	u32 *addr = 0;
+	u32 dw_value = 0;
+	u16 i = 0;
+
+	seq_printf(s, "\t\n");
+	seq_printf(s, "UWTBL PN\n");
+
+	/* UMAC WTBL DW 2/3 */
+	addr = (u32 *)&(uwtbl[WF_UWTBL_PN_31_0__DW*4]);
+	dw_value = *addr;
+
+	while (WTBL_UMAC_DW2[i].name) {
+		seq_printf(s, "\t%s:%u\n", WTBL_UMAC_DW2[i].name,
+			(dw_value & WTBL_UMAC_DW2[i].mask) >>
+				WTBL_UMAC_DW2[i].shift);
+		i++;
+	}
+
+	i = 0;
+	addr = (u32 *)&(uwtbl[WF_UWTBL_PN_47_32__DW*4]);
+	dw_value = *addr;
+
+	while (WTBL_UMAC_DW3[i].name) {
+		seq_printf(s, "\t%s:%u\n", WTBL_UMAC_DW3[i].name,
+			 (dw_value & WTBL_UMAC_DW3[i].mask) >>
+			WTBL_UMAC_DW3[i].shift);
+		i++;
+	}
+
+
+	/* UMAC WTBL DW 4/5 for BIGTK */
+	if (is_wtbl_bigtk_exist(lwtbl) == true) {
+		i = 0;
+		addr = (u32 *)&(uwtbl[WF_UWTBL_RX_BIPN_31_0__DW*4]);
+		dw_value = *addr;
+
+		while (WTBL_UMAC_DW4_BIPN[i].name) {
+			seq_printf(s, "\t%s:%u\n", WTBL_UMAC_DW4_BIPN[i].name,
+				(dw_value & WTBL_UMAC_DW4_BIPN[i].mask) >>
+					WTBL_UMAC_DW4_BIPN[i].shift);
+			i++;
+		}
+
+		i = 0;
+		addr = (u32 *)&(uwtbl[WF_UWTBL_RX_BIPN_47_32__DW*4]);
+		dw_value = *addr;
+
+		while (WTBL_UMAC_DW5_BIPN[i].name) {
+			seq_printf(s, "\t%s:%u\n", WTBL_UMAC_DW5_BIPN[i].name,
+				(dw_value & WTBL_UMAC_DW5_BIPN[i].mask) >>
+				WTBL_UMAC_DW5_BIPN[i].shift);
+			i++;
+		}
+	}
+}
+
+static void parse_fmac_uwtbl_sn(struct seq_file *s, u8 *uwtbl)
+{
+	u32 *addr = 0;
+	u32 u2SN = 0;
+
+	/* UMAC WTBL DW SN part */
+	seq_printf(s, "\t\n");
+	seq_printf(s, "UWTBL SN\n");
+
+	addr = (u32 *)&(uwtbl[WF_UWTBL_TID0_SN_DW*4]);
+	u2SN = ((*addr) & WF_UWTBL_TID0_SN_MASK) >> WF_UWTBL_TID0_SN_SHIFT;
+	seq_printf(s, "\t%s:%u\n", "TID0_AC0_SN", u2SN);
+
+	addr = (u32 *)&(uwtbl[WF_UWTBL_TID1_SN_DW*4]);
+	u2SN = ((*addr) & WF_UWTBL_TID1_SN_MASK) >> WF_UWTBL_TID1_SN_SHIFT;
+	seq_printf(s, "\t%s:%u\n", "TID1_AC1_SN", u2SN);
+
+	addr = (u32 *)&(uwtbl[WF_UWTBL_TID2_SN_7_0__DW*4]);
+	u2SN = ((*addr) & WF_UWTBL_TID2_SN_7_0__MASK) >>
+				WF_UWTBL_TID2_SN_7_0__SHIFT;
+	addr = (u32 *)&(uwtbl[WF_UWTBL_TID2_SN_11_8__DW*4]);
+	u2SN |= (((*addr) & WF_UWTBL_TID2_SN_11_8__MASK) >>
+			WF_UWTBL_TID2_SN_11_8__SHIFT) << 8;
+	seq_printf(s, "\t%s:%u\n", "TID2_AC2_SN", u2SN);
+
+	addr = (u32 *)&(uwtbl[WF_UWTBL_TID3_SN_DW*4]);
+	u2SN = ((*addr) & WF_UWTBL_TID3_SN_MASK) >> WF_UWTBL_TID3_SN_SHIFT;
+	seq_printf(s, "\t%s:%u\n", "TID3_AC3_SN", u2SN);
+
+	addr = (u32 *)&(uwtbl[WF_UWTBL_TID4_SN_DW*4]);
+	u2SN = ((*addr) & WF_UWTBL_TID4_SN_MASK) >> WF_UWTBL_TID4_SN_SHIFT;
+	seq_printf(s, "\t%s:%u\n", "TID4_SN", u2SN);
+
+	addr = (u32 *)&(uwtbl[WF_UWTBL_TID5_SN_3_0__DW*4]);
+	u2SN = ((*addr) & WF_UWTBL_TID5_SN_3_0__MASK) >>
+				WF_UWTBL_TID5_SN_3_0__SHIFT;
+	addr = (u32 *)&(uwtbl[WF_UWTBL_TID5_SN_11_4__DW*4]);
+	u2SN |= (((*addr) & WF_UWTBL_TID5_SN_11_4__MASK) >>
+				WF_UWTBL_TID5_SN_11_4__SHIFT) << 4;
+	seq_printf(s, "\t%s:%u\n", "TID5_SN", u2SN);
+
+	addr = (u32 *)&(uwtbl[WF_UWTBL_TID6_SN_DW*4]);
+	u2SN = ((*addr) & WF_UWTBL_TID6_SN_MASK) >> WF_UWTBL_TID6_SN_SHIFT;
+	seq_printf(s, "\t%s:%u\n", "TID6_SN", u2SN);
+
+	addr = (u32 *)&(uwtbl[WF_UWTBL_TID7_SN_DW*4]);
+	u2SN = ((*addr) & WF_UWTBL_TID7_SN_MASK) >> WF_UWTBL_TID7_SN_SHIFT;
+	seq_printf(s, "\t%s:%u\n", "TID7_SN", u2SN);
+
+	addr = (u32 *)&(uwtbl[WF_UWTBL_COM_SN_DW*4]);
+	u2SN = ((*addr) & WF_UWTBL_COM_SN_MASK) >> WF_UWTBL_COM_SN_SHIFT;
+	seq_printf(s, "\t%s:%u\n", "COM_SN", u2SN);
+}
+
+static void dump_key_table(
+	struct seq_file *s,
+	uint16_t keyloc0,
+	uint16_t keyloc1,
+	uint16_t keyloc2
+)
+{
+#define ONE_KEY_ENTRY_LEN_IN_DW                8
+	struct mt7996_dev *dev = dev_get_drvdata(s->private);
+	u8 keytbl[ONE_KEY_ENTRY_LEN_IN_DW*4] = {0};
+	uint16_t x;
+
+	seq_printf(s, "\t\n");
+	seq_printf(s, "\t%s:%d\n", "keyloc0", keyloc0);
+	if (keyloc0 != INVALID_KEY_ENTRY) {
+
+		/* Don't swap below two lines, halWtblReadRaw will
+		* write new value WF_WTBLON_TOP_WDUCR_ADDR
+		*/
+		mt7996_wtbl_read_raw(dev, keyloc0,
+			WTBL_TYPE_KEY, 0, ONE_KEY_ENTRY_LEN_IN_DW, keytbl);
+		seq_printf(s, "\t\tKEY WTBL Addr: group:0x%x=0x%x addr: 0x%lx\n",
+			MT_DBG_UWTBL_TOP_WDUCR_ADDR,
+			mt76_rr(dev, MT_DBG_UWTBL_TOP_WDUCR_ADDR),
+			KEYTBL_IDX2BASE(keyloc0, 0));
+		for (x = 0; x < ONE_KEY_ENTRY_LEN_IN_DW; x++) {
+			seq_printf(s, "\t\tDW%02d: %02x %02x %02x %02x\n",
+				x,
+				keytbl[x * 4 + 3],
+				keytbl[x * 4 + 2],
+				keytbl[x * 4 + 1],
+				keytbl[x * 4]);
+		}
+	}
+
+	seq_printf(s, "\t%s:%d\n", "keyloc1", keyloc1);
+	if (keyloc1 != INVALID_KEY_ENTRY) {
+		/* Don't swap below two lines, halWtblReadRaw will
+		* write new value WF_WTBLON_TOP_WDUCR_ADDR
+		*/
+		mt7996_wtbl_read_raw(dev, keyloc1,
+			WTBL_TYPE_KEY, 0, ONE_KEY_ENTRY_LEN_IN_DW, keytbl);
+		seq_printf(s, "\t\tKEY WTBL Addr: group:0x%x=0x%x addr: 0x%lx\n",
+			MT_DBG_UWTBL_TOP_WDUCR_ADDR,
+			mt76_rr(dev, MT_DBG_UWTBL_TOP_WDUCR_ADDR),
+			KEYTBL_IDX2BASE(keyloc1, 0));
+		for (x = 0; x < ONE_KEY_ENTRY_LEN_IN_DW; x++) {
+			seq_printf(s, "\t\tDW%02d: %02x %02x %02x %02x\n",
+				x,
+				keytbl[x * 4 + 3],
+				keytbl[x * 4 + 2],
+				keytbl[x * 4 + 1],
+				keytbl[x * 4]);
+		}
+	}
+
+	seq_printf(s, "\t%s:%d\n", "keyloc2", keyloc2);
+	if (keyloc2 != INVALID_KEY_ENTRY) {
+		/* Don't swap below two lines, halWtblReadRaw will
+		* write new value WF_WTBLON_TOP_WDUCR_ADDR
+		*/
+		mt7996_wtbl_read_raw(dev, keyloc2,
+			WTBL_TYPE_KEY, 0, ONE_KEY_ENTRY_LEN_IN_DW, keytbl);
+		seq_printf(s, "\t\tKEY WTBL Addr: group:0x%x=0x%x addr: 0x%lx\n",
+			MT_DBG_UWTBL_TOP_WDUCR_ADDR,
+			mt76_rr(dev, MT_DBG_UWTBL_TOP_WDUCR_ADDR),
+			KEYTBL_IDX2BASE(keyloc2, 0));
+		for (x = 0; x < ONE_KEY_ENTRY_LEN_IN_DW; x++) {
+			seq_printf(s, "\t\tDW%02d: %02x %02x %02x %02x\n",
+				x,
+				keytbl[x * 4 + 3],
+				keytbl[x * 4 + 2],
+				keytbl[x * 4 + 1],
+				keytbl[x * 4]);
+		}
+	}
+}
+
+static void parse_fmac_uwtbl_key_info(struct seq_file *s, u8 *uwtbl, u8 *lwtbl)
+{
+	u32 *addr = 0;
+	u32 dw_value = 0;
+	uint16_t keyloc0 = INVALID_KEY_ENTRY;
+	uint16_t keyloc1 = INVALID_KEY_ENTRY;
+	uint16_t keyloc2 = INVALID_KEY_ENTRY;
+
+	/* UMAC WTBL DW 7 */
+	seq_printf(s, "\t\n");
+	seq_printf(s, "UWTBL key info\n");
+
+	addr = (u32 *)&(uwtbl[WF_UWTBL_KEY_LOC0_DW*4]);
+	dw_value = *addr;
+	keyloc0 = (dw_value & WF_UWTBL_KEY_LOC0_MASK) >> WF_UWTBL_KEY_LOC0_SHIFT;
+	keyloc1 = (dw_value & WF_UWTBL_KEY_LOC1_MASK) >> WF_UWTBL_KEY_LOC1_SHIFT;
+
+	seq_printf(s, "\t%s:%u/%u\n", "Key Loc 0/1", keyloc0, keyloc1);
+
+	/* UMAC WTBL DW 6 for BIGTK */
+	if (is_wtbl_bigtk_exist(lwtbl) == true) {
+		addr = (u32 *)&(uwtbl[WF_UWTBL_KEY_LOC2_DW*4]);
+		dw_value = *addr;
+		keyloc2 = (dw_value & WF_UWTBL_KEY_LOC2_MASK) >>
+			WF_UWTBL_KEY_LOC2_SHIFT;
+		seq_printf(s, "\t%s:%u\n", "Key Loc 2", keyloc2);
+	}
+
+	/* Parse KEY link */
+	dump_key_table(s, keyloc0, keyloc1, keyloc2);
+}
+
+static const struct berse_wtbl_parse WTBL_UMAC_DW8[] = {
+	{"UWTBL_WMM_Q",		WF_UWTBL_WMM_Q_MASK,		WF_UWTBL_WMM_Q_SHIFT,	false},
+	{"UWTBL_QOS",		WF_UWTBL_QOS_MASK,		NO_SHIFT_DEFINE,	false},
+	{"UWTBL_HT_VHT_HE",	WF_UWTBL_HT_MASK,		NO_SHIFT_DEFINE,	false},
+	{"UWTBL_HDRT_MODE",	WF_UWTBL_HDRT_MODE_MASK,	NO_SHIFT_DEFINE,	true},
+	{NULL,}
+};
+
+static void parse_fmac_uwtbl_msdu_info(struct seq_file *s, u8 *uwtbl)
+{
+	u32 *addr = 0;
+	u32 dw_value = 0;
+	u32 amsdu_len = 0;
+	u16 i = 0;
+
+	/* UMAC WTBL DW 8 */
+	seq_printf(s, "\t\n");
+	seq_printf(s, "UWTBL DW8\n");
+
+	addr = (u32 *)&(uwtbl[WF_UWTBL_AMSDU_CFG_DW*4]);
+	dw_value = *addr;
+
+	while (WTBL_UMAC_DW8[i].name) {
+
+		if (WTBL_UMAC_DW8[i].shift == NO_SHIFT_DEFINE)
+			seq_printf(s, "\t%s:%d\n", WTBL_UMAC_DW8[i].name,
+				(dw_value & WTBL_UMAC_DW8[i].mask) ? 1 : 0);
+		else
+			seq_printf(s, "\t%s:%u\n", WTBL_UMAC_DW8[i].name,
+				(dw_value & WTBL_UMAC_DW8[i].mask) >>
+					WTBL_UMAC_DW8[i].shift);
+		i++;
+	}
+
+	/* UMAC WTBL DW 8 - SEC_ADDR_MODE */
+	addr = (u32 *)&(uwtbl[WF_UWTBL_SEC_ADDR_MODE_DW*4]);
+	dw_value = *addr;
+	seq_printf(s, "\t%s:%lu\n", "SEC_ADDR_MODE",
+		(dw_value & WTBL_SEC_ADDR_MODE_MASK) >> WTBL_SEC_ADDR_MODE_OFFSET);
+
+	/* UMAC WTBL DW 8 - AMSDU_CFG */
+	seq_printf(s, "\t%s:%d\n", "HW AMSDU Enable",
+				(dw_value & WTBL_AMSDU_EN_MASK) ? 1 : 0);
+
+	amsdu_len = (dw_value & WTBL_AMSDU_LEN_MASK) >> WTBL_AMSDU_LEN_OFFSET;
+	if (amsdu_len == 0)
+		seq_printf(s, "\t%s:invalid (WTBL value=0x%x)\n", "HW AMSDU Len",
+			amsdu_len);
+	else if (amsdu_len == 1)
+		seq_printf(s, "\t%s:%d~%d (WTBL value=0x%x)\n", "HW AMSDU Len",
+			1,
+			255,
+			amsdu_len);
+	else if (amsdu_len == 2)
+		seq_printf(s, "\t%s:%d~%d (WTBL value=0x%x)\n", "HW AMSDU Len",
+			256,
+			511,
+			amsdu_len);
+	else if (amsdu_len == 3)
+		seq_printf(s, "\t%s:%d~%d (WTBL value=0x%x)\n", "HW AMSDU Len",
+			512,
+			767,
+			amsdu_len);
+	else
+		seq_printf(s, "\t%s:%d~%d (WTBL value=0x%x)\n", "HW AMSDU Len",
+			256 * (amsdu_len - 1),
+			256 * (amsdu_len - 1) + 255,
+			amsdu_len);
+
+	seq_printf(s, "\t%s:%lu (WTBL value=0x%lx)\n", "HW AMSDU Num",
+		((dw_value & WTBL_AMSDU_NUM_MASK) >> WTBL_AMSDU_NUM_OFFSET) + 1,
+		(dw_value & WTBL_AMSDU_NUM_MASK) >> WTBL_AMSDU_NUM_OFFSET);
+}
+
+static int mt7996_wtbl_read(struct seq_file *s, void *data)
+{
+	struct mt7996_dev *dev = dev_get_drvdata(s->private);
+	u8 lwtbl[LWTBL_LEN_IN_DW * 4] = {0};
+	u8 uwtbl[UWTBL_LEN_IN_DW * 4] = {0};
+	int x;
+
+	mt7996_wtbl_read_raw(dev, dev->wlan_idx, WTBL_TYPE_LMAC, 0,
+				 LWTBL_LEN_IN_DW, lwtbl);
+	seq_printf(s, "Dump WTBL info of WLAN_IDX:%d\n", dev->wlan_idx);
+	seq_printf(s, "LMAC WTBL Addr: group:0x%x=0x%x addr: 0x%lx\n",
+		   MT_DBG_WTBLON_TOP_WDUCR_ADDR,
+		   mt76_rr(dev, MT_DBG_WTBLON_TOP_WDUCR_ADDR),
+		   LWTBL_IDX2BASE(dev->wlan_idx, 0));
+	for (x = 0; x < LWTBL_LEN_IN_DW; x++) {
+		seq_printf(s, "DW%02d: %02x %02x %02x %02x\n",
+			   x,
+			   lwtbl[x * 4 + 3],
+			   lwtbl[x * 4 + 2],
+			   lwtbl[x * 4 + 1],
+			   lwtbl[x * 4]);
+	}
+
+	/* Parse LWTBL */
+	parse_fmac_lwtbl_dw0_1(s, lwtbl);
+	parse_fmac_lwtbl_dw2(s, lwtbl);
+	parse_fmac_lwtbl_dw3(s, lwtbl);
+	parse_fmac_lwtbl_dw4(s, lwtbl);
+	parse_fmac_lwtbl_dw5(s, lwtbl);
+	parse_fmac_lwtbl_dw6(s, lwtbl);
+	parse_fmac_lwtbl_dw7(s, lwtbl);
+	parse_fmac_lwtbl_dw8(s, lwtbl);
+	parse_fmac_lwtbl_dw9(s, lwtbl);
+	parse_fmac_lwtbl_dw10(s, lwtbl);
+	parse_fmac_lwtbl_dw11(s, lwtbl);
+	parse_fmac_lwtbl_dw12(s, lwtbl);
+	parse_fmac_lwtbl_dw13(s, lwtbl);
+	parse_fmac_lwtbl_dw14(s, lwtbl);
+	parse_fmac_lwtbl_mlo_info(s, lwtbl);
+	parse_fmac_lwtbl_dw31(s, lwtbl);
+	parse_fmac_lwtbl_dw32(s, lwtbl);
+	parse_fmac_lwtbl_rx_stats(s, lwtbl);
+
+	mt7996_wtbl_read_raw(dev, dev->wlan_idx, WTBL_TYPE_UMAC, 0,
+				 UWTBL_LEN_IN_DW, uwtbl);
+	seq_printf(s, "Dump WTBL info of WLAN_IDX:%d\n", dev->wlan_idx);
+	seq_printf(s, "UMAC WTBL Addr: group:0x%x=0x%x addr: 0x%lx\n",
+		   MT_DBG_UWTBL_TOP_WDUCR_ADDR,
+		   mt76_rr(dev, MT_DBG_UWTBL_TOP_WDUCR_ADDR),
+		   UWTBL_IDX2BASE(dev->wlan_idx, 0));
+	for (x = 0; x < UWTBL_LEN_IN_DW; x++) {
+		seq_printf(s, "DW%02d: %02x %02x %02x %02x\n",
+			   x,
+			   uwtbl[x * 4 + 3],
+			   uwtbl[x * 4 + 2],
+			   uwtbl[x * 4 + 1],
+			   uwtbl[x * 4]);
+	}
+
+	/* Parse UWTBL */
+	parse_fmac_uwtbl_mlo_info(s, uwtbl);
+	parse_fmac_uwtbl_pn(s, uwtbl, lwtbl);
+	parse_fmac_uwtbl_sn(s, uwtbl);
+	parse_fmac_uwtbl_key_info(s, uwtbl, lwtbl);
+	parse_fmac_uwtbl_msdu_info(s, uwtbl);
+
+	return 0;
+}
+
+static int mt7996_sta_info(struct seq_file *s, void *data)
+{
+	struct mt7996_dev *dev = dev_get_drvdata(s->private);
+	u8 lwtbl[LWTBL_LEN_IN_DW*4] = {0};
+	u16 i = 0;
+
+	for (i=0; i < mt7996_wtbl_size(dev); i++) {
+		mt7996_wtbl_read_raw(dev, i, WTBL_TYPE_LMAC, 0,
+				     LWTBL_LEN_IN_DW, lwtbl);
+
+		if (lwtbl[4] || lwtbl[5] || lwtbl[6] || lwtbl[7] || lwtbl[0] || lwtbl[1]) {
+			u32 *addr, dw_value;
+
+			seq_printf(s, "wcid:%d\tAddr: %02x:%02x:%02x:%02x:%02x:%02x",
+					i, lwtbl[4], lwtbl[5], lwtbl[6], lwtbl[7], lwtbl[0], lwtbl[1]);
+
+			addr = (u32 *)&(lwtbl[WTBL_GROUP_TRX_CAP_DW_2*4]);
+			dw_value = *addr;
+			seq_printf(s, "\t%s:%u", WTBL_LMAC_DW2[0].name,
+					(dw_value & WTBL_LMAC_DW2[0].mask) >> WTBL_LMAC_DW2[0].shift);
+
+			addr = (u32 *)&(lwtbl[WTBL_GROUP_TRX_CAP_DW_5*4]);
+			dw_value = *addr;
+			seq_printf(s, "\tPSM:%u\n", !!(dw_value & WF_LWTBL_PSM_MASK));
+		}
+	}
+
+	return 0;
+}
+
+static int mt7996_token_read(struct seq_file *s, void *data)
+{
+	struct mt7996_dev *dev = dev_get_drvdata(s->private);
+	int msdu_id;
+	struct mt76_txwi_cache *txwi;
+
+	seq_printf(s, "Token from host:\n");
+	spin_lock_bh(&dev->mt76.token_lock);
+	idr_for_each_entry(&dev->mt76.token, txwi, msdu_id) {
+		seq_printf(s, "%4d (pending time %u ms)\n", msdu_id,
+			   jiffies_to_msecs(jiffies - txwi->jiffies));
+	}
+	spin_unlock_bh(&dev->mt76.token_lock);
+	seq_printf(s, "\n");
+
+	return 0;
+}
+
+static int
+mt7996_scs_enable_set(void *data, u64 val)
+{
+	struct mt7996_phy *phy = data;
+
+	return mt7996_mcu_set_scs(phy, (u8) val);
+}
+DEFINE_DEBUGFS_ATTRIBUTE(fops_scs_enable, NULL,
+			 mt7996_scs_enable_set, "%lld\n");
+
+static int
+mt7996_txpower_level_set(void *data, u64 val)
+{
+	struct mt7996_phy *phy = data;
+	int ret;
+
+	if (val > 100)
+		return -EINVAL;
+
+	ret = mt7996_mcu_set_tx_power_ctrl(phy, UNI_TXPOWER_PERCENTAGE_CTRL, !!val);
+	if (ret)
+		return ret;
+
+	return mt7996_mcu_set_tx_power_ctrl(phy, UNI_TXPOWER_PERCENTAGE_DROP_CTRL, val);
+}
+
+DEFINE_DEBUGFS_ATTRIBUTE(fops_txpower_level, NULL,
+			 mt7996_txpower_level_set, "%lld\n");
+
+static ssize_t
+mt7996_get_txpower_info(struct file *file, char __user *user_buf,
+			size_t count, loff_t *ppos)
+{
+	struct mt7996_phy *phy = file->private_data;
+	struct mt7996_mcu_txpower_event *event;
+	struct txpower_basic_info *basic_info;
+	struct device_node *np;
+	static const size_t size = 2048;
+	int len = 0;
+	ssize_t ret;
+	char *buf;
+
+	buf = kzalloc(size, GFP_KERNEL);
+	event = kzalloc(sizeof(*event), GFP_KERNEL);
+	if (!buf || !event) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	ret = mt7996_mcu_get_tx_power_info(phy, BASIC_INFO, event);
+	if (ret ||
+	    le32_to_cpu(event->basic_info.category) != UNI_TXPOWER_BASIC_INFO)
+		goto out;
+
+	basic_info = &event->basic_info;
+
+	len += scnprintf(buf + len, size - len,
+			 "======================== BASIC INFO ========================\n");
+	len += scnprintf(buf + len, size - len, "    Band Index: %d, Channel Band: %d\n",
+			 basic_info->band_idx, basic_info->band);
+	len += scnprintf(buf + len, size - len, "    PA Type: %s\n",
+			 basic_info->is_epa ? "ePA" : "iPA");
+	len += scnprintf(buf + len, size - len, "    LNA Type: %s\n",
+			 basic_info->is_elna ? "eLNA" : "iLNA");
+
+	len += scnprintf(buf + len, size - len,
+			 "------------------------------------------------------------\n");
+	len += scnprintf(buf + len, size - len, "    SKU: %s\n",
+			 basic_info->sku_enable ? "enable" : "disable");
+	len += scnprintf(buf + len, size - len, "    Percentage Control: %s\n",
+			 basic_info->percentage_ctrl_enable ? "enable" : "disable");
+	len += scnprintf(buf + len, size - len, "    Power Drop: %d [dBm]\n",
+			 basic_info->power_drop_level >> 1);
+	len += scnprintf(buf + len, size - len, "    Backoff: %s\n",
+			 basic_info->bf_backoff_enable ? "enable" : "disable");
+	len += scnprintf(buf + len, size - len, "    TX Front-end Loss:  %d, %d, %d, %d\n",
+			 basic_info->front_end_loss_tx[0], basic_info->front_end_loss_tx[1],
+			 basic_info->front_end_loss_tx[2], basic_info->front_end_loss_tx[3]);
+	len += scnprintf(buf + len, size - len, "    RX Front-end Loss:  %d, %d, %d, %d\n",
+			 basic_info->front_end_loss_rx[0], basic_info->front_end_loss_rx[1],
+			 basic_info->front_end_loss_rx[2], basic_info->front_end_loss_rx[3]);
+	len += scnprintf(buf + len, size - len,
+			 "    MU TX Power Mode:  %s\n",
+			 basic_info->mu_tx_power_manual_enable ? "manual" : "auto");
+	len += scnprintf(buf + len, size - len,
+			 "    MU TX Power (Auto / Manual): %d / %d [0.5 dBm]\n",
+			 basic_info->mu_tx_power_auto, basic_info->mu_tx_power_manual);
+	len += scnprintf(buf + len, size - len,
+			 "    Thermal Compensation:  %s\n",
+			 basic_info->thermal_compensate_enable ? "enable" : "disable");
+	len += scnprintf(buf + len, size - len,
+			 "    Theraml Compensation Value: %d\n",
+			 basic_info->thermal_compensate_value);
+	np = mt76_find_power_limits_node(phy->mt76->dev);
+	len += scnprintf(buf + len, size - len,
+			 "    RegDB:  %s\n",
+			 !np ? "enable" : "disable");
+	ret = simple_read_from_buffer(user_buf, count, ppos, buf, len);
+
+out:
+	kfree(buf);
+	kfree(event);
+	return ret;
+}
+
+static const struct file_operations mt7996_txpower_info_fops = {
+	.read = mt7996_get_txpower_info,
+	.open = simple_open,
+	.owner = THIS_MODULE,
+	.llseek = default_llseek,
+};
+
+#define mt7996_txpower_puts(rate, _len)							\
+({											\
+	len += scnprintf(buf + len, size - len, "%-*s:", _len, #rate " (TMAC)");	\
+	for (i = 0; i < mt7996_sku_group_len[SKU_##rate]; i++, offs++)			\
+		len += scnprintf(buf + len, size - len, " %6d",				\
+				 event->phy_rate_info.frame_power[offs][band_idx]);	\
+	len += scnprintf(buf + len, size - len, "\n");					\
+})
+
+static ssize_t
+mt7996_get_txpower_sku(struct file *file, char __user *user_buf,
+		       size_t count, loff_t *ppos)
+{
+	struct mt7996_phy *phy = file->private_data;
+	struct mt7996_dev *dev = phy->dev;
+	struct mt7996_mcu_txpower_event *event;
+	struct ieee80211_channel *chan = phy->mt76->chandef.chan;
+	struct ieee80211_supported_band sband;
+	u8 band_idx = phy->mt76->band_idx;
+	static const size_t size = 5120;
+	int i, offs = 0, len = 0;
+	u32 target_power = 0;
+	int n_chains = hweight16(phy->mt76->chainmask);
+	int path_delta = mt76_tx_power_path_delta(n_chains);
+	int pwr_delta;
+	ssize_t ret;
+	char *buf;
+	u32 reg;
+
+	buf = kzalloc(size, GFP_KERNEL);
+	event = kzalloc(sizeof(*event), GFP_KERNEL);
+	if (!buf || !event) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	ret = mt7996_mcu_get_tx_power_info(phy, PHY_RATE_INFO, event);
+	if (ret ||
+	    le32_to_cpu(event->phy_rate_info.category) != UNI_TXPOWER_PHY_RATE_INFO)
+		goto out;
+
+	len += scnprintf(buf + len, size - len,
+			 "\nPhy %d TX Power Table (Channel %d)\n",
+			 band_idx, phy->mt76->chandef.chan->hw_value);
+	len += scnprintf(buf + len, size - len, "%-21s  %6s %6s %6s %6s\n",
+			 " ", "1m", "2m", "5m", "11m");
+	mt7996_txpower_puts(CCK, 21);
+
+	len += scnprintf(buf + len, size - len,
+			 "%-21s  %6s %6s %6s %6s %6s %6s %6s %6s\n",
+			 " ", "6m", "9m", "12m", "18m", "24m", "36m", "48m",
+			 "54m");
+	mt7996_txpower_puts(OFDM, 21);
+
+	len += scnprintf(buf + len, size - len,
+			 "%-21s  %6s %6s %6s %6s %6s %6s %6s %6s\n",
+			 " ", "mcs0", "mcs1", "mcs2", "mcs3", "mcs4",
+			 "mcs5", "mcs6", "mcs7");
+	mt7996_txpower_puts(HT20, 21);
+
+	len += scnprintf(buf + len, size - len,
+			 "%-21s  %6s %6s %6s %6s %6s %6s %6s %6s %6s\n",
+			 " ", "mcs0", "mcs1", "mcs2", "mcs3", "mcs4", "mcs5",
+			 "mcs6", "mcs7", "mcs32");
+	mt7996_txpower_puts(HT40, 21);
+
+	len += scnprintf(buf + len, size - len,
+			 "%-21s  %6s %6s %6s %6s %6s %6s %6s %6s %6s %6s %6s %6s\n",
+			 " ", "mcs0", "mcs1", "mcs2", "mcs3", "mcs4", "mcs5",
+			 "mcs6", "mcs7", "mcs8", "mcs9", "mcs10", "mcs11");
+	mt7996_txpower_puts(VHT20, 21);
+	mt7996_txpower_puts(VHT40, 21);
+	mt7996_txpower_puts(VHT80, 21);
+	mt7996_txpower_puts(VHT160, 21);
+	mt7996_txpower_puts(HE26, 21);
+	mt7996_txpower_puts(HE52, 21);
+	mt7996_txpower_puts(HE106, 21);
+	len += scnprintf(buf + len, size - len, "BW20/");
+	mt7996_txpower_puts(HE242, 16);
+	len += scnprintf(buf + len, size - len, "BW40/");
+	mt7996_txpower_puts(HE484, 16);
+	len += scnprintf(buf + len, size - len, "BW80/");
+	mt7996_txpower_puts(HE996, 16);
+	len += scnprintf(buf + len, size - len, "BW160/");
+	mt7996_txpower_puts(HE2x996, 15);
+
+	len += scnprintf(buf + len, size - len,
+			 "%-21s  %6s %6s %6s %6s %6s %6s %6s %6s ",
+			 " ", "mcs0", "mcs1", "mcs2", "mcs3", "mcs4", "mcs5", "mcs6", "mcs7");
+	len += scnprintf(buf + len, size - len,
+			 "%6s %6s %6s %6s %6s %6s %6s %6s\n",
+			 "mcs8", "mcs9", "mcs10", "mcs11", "mcs12", "mcs13", "mcs14", "mcs15");
+	mt7996_txpower_puts(EHT26, 21);
+	mt7996_txpower_puts(EHT52, 21);
+	mt7996_txpower_puts(EHT106, 21);
+	len += scnprintf(buf + len, size - len, "BW20/");
+	mt7996_txpower_puts(EHT242, 16);
+	len += scnprintf(buf + len, size - len, "BW40/");
+	mt7996_txpower_puts(EHT484, 16);
+	len += scnprintf(buf + len, size - len, "BW80/");
+	mt7996_txpower_puts(EHT996, 16);
+	len += scnprintf(buf + len, size - len, "BW160/");
+	mt7996_txpower_puts(EHT2x996, 15);
+	len += scnprintf(buf + len, size - len, "BW320/");
+	mt7996_txpower_puts(EHT4x996, 15);
+	mt7996_txpower_puts(EHT26_52, 21);
+	mt7996_txpower_puts(EHT26_106, 21);
+	mt7996_txpower_puts(EHT484_242, 21);
+	mt7996_txpower_puts(EHT996_484, 21);
+	mt7996_txpower_puts(EHT996_484_242, 21);
+	mt7996_txpower_puts(EHT2x996_484, 21);
+	mt7996_txpower_puts(EHT3x996, 21);
+	mt7996_txpower_puts(EHT3x996_484, 21);
+
+	len += scnprintf(buf + len, size - len, "\nePA Gain: %d\n",
+			 event->phy_rate_info.epa_gain);
+	len += scnprintf(buf + len, size - len, "Max Power Bound: %d\n",
+			 event->phy_rate_info.max_power_bound);
+	len += scnprintf(buf + len, size - len, "Min Power Bound: %d\n",
+			 event->phy_rate_info.min_power_bound);
+
+	reg = MT_WF_PHYDFE_TSSI_TXCTRL01(band_idx);
+	len += scnprintf(buf + len, size - len,
+			 "\nBBP TX Power (target power from TMAC)  : %6ld [0.5 dBm]\n",
+			 mt76_get_field(dev, reg, MT_WF_PHYDFE_TSSI_TXCTRL_POWER_TMAC));
+	len += scnprintf(buf + len, size - len,
+			 "RegDB maximum power:\t%d [dBm]\n",
+			 chan->max_reg_power);
+
+	if (chan->band == NL80211_BAND_2GHZ)
+		sband = phy->mt76->sband_2g.sband;
+	else if (chan->band == NL80211_BAND_5GHZ)
+		sband = phy->mt76->sband_5g.sband;
+	else if (chan->band == NL80211_BAND_6GHZ)
+		sband = phy->mt76->sband_6g.sband;
+
+	pwr_delta = mt7996_eeprom_get_power_delta(dev, sband.band);
+
+	target_power = max_t(u32, target_power, mt7996_eeprom_get_target_power(dev, chan));
+	target_power += pwr_delta + path_delta;
+	target_power = DIV_ROUND_UP(target_power, 2);
+	len += scnprintf(buf + len, size - len,
+			 "eeprom maximum power:\t%d [dBm]\n",
+			 target_power);
+
+	len += scnprintf(buf + len, size - len,
+			 "path_delta:\t%d [0.5 dBm]\n",
+			 path_delta);
+
+	ret = simple_read_from_buffer(user_buf, count, ppos, buf, len);
+
+out:
+	kfree(buf);
+	kfree(event);
+	return ret;
+}
+
+static const struct file_operations mt7996_txpower_sku_fops = {
+	.read = mt7996_get_txpower_sku,
+	.open = simple_open,
+	.owner = THIS_MODULE,
+	.llseek = default_llseek,
+};
+
+#define mt7996_txpower_path_puts(rate, arr_length)					\
+({											\
+	len += scnprintf(buf + len, size - len, "%23s:", #rate " (TMAC)");		\
+	for (i = 0; i < arr_length; i++, offs++)					\
+		len += scnprintf(buf + len, size - len, " %4d",				\
+				 event->backoff_table_info.frame_power[offs]);		\
+	len += scnprintf(buf + len, size - len, "\n");					\
+})
+
+static ssize_t
+mt7996_get_txpower_path(struct file *file, char __user *user_buf,
+		       size_t count, loff_t *ppos)
+{
+	struct mt7996_phy *phy = file->private_data;
+	struct mt7996_mcu_txpower_event *event;
+	static const size_t size = 5120;
+	int i, offs = 0, len = 0;
+	ssize_t ret;
+	char *buf;
+
+	buf = kzalloc(size, GFP_KERNEL);
+	event = kzalloc(sizeof(*event), GFP_KERNEL);
+	if (!buf || !event) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	ret = mt7996_mcu_get_tx_power_info(phy, BACKOFF_TABLE_INFO, event);
+	if (ret ||
+	    le32_to_cpu(event->phy_rate_info.category) != UNI_TXPOWER_BACKOFF_TABLE_SHOW_INFO)
+		goto out;
+
+	len += scnprintf(buf + len, size - len, "\n%*c", 25, ' ');
+	len += scnprintf(buf + len, size - len, "1T1S/2T1S/3T1S/4T1S/5T1S/2T2S/3T2S/4T2S/5T2S/"
+			 "3T3S/4T3S/5T3S/4T4S/5T4S/5T5S\n");
+
+	mt7996_txpower_path_puts(CCK, 5);
+	mt7996_txpower_path_puts(OFDM, 5);
+	mt7996_txpower_path_puts(BF-OFDM, 4);
+
+	mt7996_txpower_path_puts(RU26, 15);
+	mt7996_txpower_path_puts(BF-RU26, 15);
+	mt7996_txpower_path_puts(RU52, 15);
+	mt7996_txpower_path_puts(BF-RU52, 15);
+	mt7996_txpower_path_puts(RU26_52, 15);
+	mt7996_txpower_path_puts(BF-RU26_52, 15);
+	mt7996_txpower_path_puts(RU106, 15);
+	mt7996_txpower_path_puts(BF-RU106, 15);
+	mt7996_txpower_path_puts(RU106_52, 15);
+	mt7996_txpower_path_puts(BF-RU106_52, 15);
+
+	mt7996_txpower_path_puts(BW20/RU242, 15);
+	mt7996_txpower_path_puts(BF-BW20/RU242, 15);
+	mt7996_txpower_path_puts(BW40/RU484, 15);
+	mt7996_txpower_path_puts(BF-BW40/RU484, 15);
+	mt7996_txpower_path_puts(RU242_484, 15);
+	mt7996_txpower_path_puts(BF-RU242_484, 15);
+	mt7996_txpower_path_puts(BW80/RU996, 15);
+	mt7996_txpower_path_puts(BF-BW80/RU996, 15);
+	mt7996_txpower_path_puts(RU484_996, 15);
+	mt7996_txpower_path_puts(BF-RU484_996, 15);
+	mt7996_txpower_path_puts(RU242_484_996, 15);
+	mt7996_txpower_path_puts(BF-RU242_484_996, 15);
+	mt7996_txpower_path_puts(BW160/RU996x2, 15);
+	mt7996_txpower_path_puts(BF-BW160/RU996x2, 15);
+	mt7996_txpower_path_puts(RU484_996x2, 15);
+	mt7996_txpower_path_puts(BF-RU484_996x2, 15);
+	mt7996_txpower_path_puts(RU996x3, 15);
+	mt7996_txpower_path_puts(BF-RU996x3, 15);
+	mt7996_txpower_path_puts(RU484_996x3, 15);
+	mt7996_txpower_path_puts(BF-RU484_996x3, 15);
+	mt7996_txpower_path_puts(BW320/RU996x4, 15);
+	mt7996_txpower_path_puts(BF-BW320/RU996x4, 15);
+
+	len += scnprintf(buf + len, size - len, "\nBackoff table: %s\n",
+			 event->backoff_table_info.backoff_en ? "enable" : "disable");
+
+	ret = simple_read_from_buffer(user_buf, count, ppos, buf, len);
+
+out:
+	kfree(buf);
+	kfree(event);
+	return ret;
+}
+
+static const struct file_operations mt7996_txpower_path_fops = {
+	.read = mt7996_get_txpower_path,
+	.open = simple_open,
+	.owner = THIS_MODULE,
+	.llseek = default_llseek,
+};
+
+static int mt7996_show_eeprom_mode(struct seq_file *s, void *data)
+{
+	struct mt7996_dev *dev = dev_get_drvdata(s->private);
+	struct mt76_dev *mdev = &dev->mt76;
+#ifdef CONFIG_NL80211_TESTMODE
+	const char *mtd_name = mdev->test_mtd.name;
+	u32 mtd_offset = mdev->test_mtd.offset;
+#else
+	const char *mtd_name = NULL;
+	u32 mtd_offset;
+#endif
+
+	seq_printf(s, "Current eeprom mode:\n");
+
+	switch (dev->eeprom_mode) {
+	case DEFAULT_BIN_MODE:
+		seq_printf(s, "   default bin mode\n   filename = %s\n", mt7996_eeprom_name(dev));
+		break;
+	case EFUSE_MODE:
+		seq_printf(s, "   efuse mode\n");
+		break;
+	case FLASH_MODE:
+		if (mtd_name)
+			seq_printf(s, "   flash mode\n   mtd name = %s\n   flash offset = 0x%x\n",
+				   mtd_name, mtd_offset);
+		else
+			seq_printf(s, "   flash mode\n");
+		break;
+	case BIN_FILE_MODE:
+		seq_printf(s, "   bin file mode\n   filename = %s\n", dev->mt76.bin_file_name);
+		break;
+	default:
+		break;
+	}
+
+	return 0;
+}
+
+static int
+mt7996_sr_enable_get(void *data, u64 *val)
+{
+	struct mt7996_phy *phy = data;
+
+	*val = phy->sr_enable;
+
+	return 0;
+}
+
+static int
+mt7996_sr_enable_set(void *data, u64 val)
+{
+	struct mt7996_phy *phy = data;
+	int ret;
+
+	if (!!val == phy->sr_enable)
+		return 0;
+
+	ret = mt7996_mcu_set_sr_enable(phy, UNI_CMD_SR_CFG_SR_ENABLE, val, true);
+	if (ret)
+		return ret;
+
+	return mt7996_mcu_set_sr_enable(phy, UNI_CMD_SR_CFG_SR_ENABLE, 0, false);
+}
+DEFINE_DEBUGFS_ATTRIBUTE(fops_sr_enable, mt7996_sr_enable_get,
+			 mt7996_sr_enable_set, "%lld\n");
+static int
+mt7996_sr_enhanced_enable_get(void *data, u64 *val)
+{
+	struct mt7996_phy *phy = data;
+
+	*val = phy->enhanced_sr_enable;
+
+	return 0;
+}
+
+static int
+mt7996_sr_enhanced_enable_set(void *data, u64 val)
+{
+	struct mt7996_phy *phy = data;
+	int ret;
+
+	if (!!val == phy->enhanced_sr_enable)
+		return 0;
+
+	ret = mt7996_mcu_set_sr_enable(phy, UNI_CMD_SR_HW_ENHANCE_SR_ENABLE, val, true);
+	if (ret)
+		return ret;
+
+	return mt7996_mcu_set_sr_enable(phy, UNI_CMD_SR_HW_ENHANCE_SR_ENABLE, 0, false);
+}
+DEFINE_DEBUGFS_ATTRIBUTE(fops_sr_enhanced_enable, mt7996_sr_enhanced_enable_get,
+			 mt7996_sr_enhanced_enable_set, "%lld\n");
+
+static int
+mt7996_sr_stats_show(struct seq_file *file, void *data)
+{
+	struct mt7996_phy *phy = file->private;
+
+	mt7996_mcu_set_sr_enable(phy, UNI_CMD_SR_HW_IND, 0, false);
+
+	return 0;
+}
+DEFINE_SHOW_ATTRIBUTE(mt7996_sr_stats);
+
+static int
+mt7996_sr_scene_cond_show(struct seq_file *file, void *data)
+{
+	struct mt7996_phy *phy = file->private;
+
+	mt7996_mcu_set_sr_enable(phy, UNI_CMD_SR_SW_SD, 0, false);
+
+	return 0;
+}
+DEFINE_SHOW_ATTRIBUTE(mt7996_sr_scene_cond);
+
+static int
+mt7996_starec_bf_read_set(void *data, u64 wlan_idx)
+{
+	struct mt7996_phy *phy = data;
+
+	return mt7996_mcu_set_txbf_internal(phy, BF_STA_REC_READ, wlan_idx, 0);
+}
+DEFINE_DEBUGFS_ATTRIBUTE(fops_starec_bf_read, NULL,
+			 mt7996_starec_bf_read_set, "%lld\n");
+
+static ssize_t
+mt7996_bf_txsnd_info_set(struct file *file,
+			 const char __user *user_buf,
+			 size_t count, loff_t *ppos)
+{
+	struct mt7996_phy *phy = file->private_data;
+	char buf[40];
+	int ret;
+
+	if (count >= sizeof(buf))
+		return -EINVAL;
+
+	if (copy_from_user(buf, user_buf, count))
+		return -EFAULT;
+
+	if (count && buf[count - 1] == '\n')
+		buf[count - 1] = '\0';
+	else
+		buf[count] = '\0';
+
+	ret = mt7996_mcu_set_txbf_snd_info(phy, buf);
+
+	if (ret) return -EFAULT;
+
+	return count;
+}
+
+static const struct file_operations fops_bf_txsnd_info = {
+	.write = mt7996_bf_txsnd_info_set,
+	.read = NULL,
+	.open = simple_open,
+	.llseek = default_llseek,
+};
+
+static int
+mt7996_bf_fbk_rpt_set(void *data, u64 wlan_idx)
+{
+	struct mt7996_phy *phy = data;
+
+	return mt7996_mcu_set_txbf_internal(phy, BF_FBRPT_DBG_INFO_READ, wlan_idx, 0);
+}
+DEFINE_DEBUGFS_ATTRIBUTE(fops_bf_fbk_rpt, NULL,
+			 mt7996_bf_fbk_rpt_set, "%lld\n");
+
+static int
+mt7996_bf_pfmu_tag_read_set(void *data, u64 wlan_idx)
+{
+	struct mt7996_phy *phy = data;
+
+	return mt7996_mcu_set_txbf_internal(phy, BF_PFMU_TAG_READ, wlan_idx, 1);
+}
+DEFINE_DEBUGFS_ATTRIBUTE(fops_bf_pfmu_tag_read, NULL,
+			 mt7996_bf_pfmu_tag_read_set, "%lld\n");
+
+static int
+mt7996_muru_fixed_rate_set(void *data, u64 val)
+{
+	struct mt7996_dev *dev = data;
+
+	return mt7996_mcu_set_muru_fixed_rate_enable(dev, UNI_CMD_MURU_FIXED_RATE_CTRL,
+						     val);
+}
+DEFINE_DEBUGFS_ATTRIBUTE(fops_muru_fixed_rate_enable, NULL,
+			 mt7996_muru_fixed_rate_set, "%lld\n");
+
+static ssize_t
+mt7996_muru_fixed_rate_parameter_set(struct file *file,
+				     const char __user *user_buf,
+				     size_t count, loff_t *ppos)
+{
+	struct mt7996_dev *dev = file->private_data;
+	char buf[40];
+	int ret;
+
+	if (count >= sizeof(buf))
+		return -EINVAL;
+
+	if (copy_from_user(buf, user_buf, count))
+		return -EFAULT;
+
+	if (count && buf[count - 1] == '\n')
+		buf[count - 1] = '\0';
+	else
+		buf[count] = '\0';
+
+
+	ret = mt7996_mcu_set_muru_fixed_rate_parameter(dev, UNI_CMD_MURU_FIXED_GROUP_RATE_CTRL,
+						       buf);
+
+	if (ret) return -EFAULT;
+
+	return count;
+}
+
+static const struct file_operations fops_muru_fixed_group_rate = {
+	.write = mt7996_muru_fixed_rate_parameter_set,
+	.read = NULL,
+	.open = simple_open,
+	.llseek = default_llseek,
+};
+
+static int mt7996_muru_prot_thr_set(void *data, u64 val)
+{
+	struct mt7996_dev *dev = data;
+
+	return mt7996_mcu_muru_set_prot_frame_thr(dev, (u32)val);
+}
+
+DEFINE_DEBUGFS_ATTRIBUTE(fops_muru_prot_thr, NULL,
+			 mt7996_muru_prot_thr_set, "%lld\n");
+
+static int
+mt7996_red_config_set(void *data, u64 val)
+{
+	struct mt7996_dev *dev = data;
+
+	return mt7996_mcu_red_config(dev, !!val);
+}
+
+DEFINE_DEBUGFS_ATTRIBUTE(fops_red_config, NULL,
+			 mt7996_red_config_set, "%lld\n");
+
+static int
+mt7996_vow_drr_dbg(void *data, u64 val)
+{
+	struct mt7996_dev *dev = data;
+
+	return mt7996_mcu_set_vow_drr_dbg(dev, (u32)val);
+}
+DEFINE_DEBUGFS_ATTRIBUTE(fops_vow_drr_dbg, NULL,
+			 mt7996_vow_drr_dbg, "%lld\n");
+
+static int
+mt7996_rro_session_read(struct seq_file *s, void *data)
+{
+	struct mt7996_dev *dev = dev_get_drvdata(s->private);
+	struct mt7996_rro_ba_session *tbl;
+	u32 value[2];
+
+	mt76_wr(dev, MT_RRO_DBG_RD_CTRL, MT_RRO_DBG_RD_EXEC +
+		(dev->dbg.sid >> 1) + 0x200);
+
+	if (dev->dbg.sid & 0x1) {
+		value[0] = mt76_rr(dev, MT_RRO_DBG_RDAT_DW(2));
+		value[1] = mt76_rr(dev, MT_RRO_DBG_RDAT_DW(3));
+	} else {
+		value[0] = mt76_rr(dev, MT_RRO_DBG_RDAT_DW(0));
+		value[1] = mt76_rr(dev, MT_RRO_DBG_RDAT_DW(1));
+	}
+
+	tbl = (struct mt7996_rro_ba_session *)&value[0];
+
+	seq_printf(s, " seid %d:\nba session table DW0:%08x DW2:%08x\n",
+		   dev->dbg.sid, value[0], value[1]);
+
+	seq_printf(s, "ack_sn = 0x%x, last_in_sn = 0x%x, sat/bn/bc/bd/cn = %d/%d/%d/%d/%d\n",
+		   tbl->ack_sn, tbl->last_in_sn, tbl->sat, tbl->bn, tbl->bc, tbl->bd, tbl->cn);
+
+	seq_printf(s, "within_cnt = %d, to_sel = %d, last_in_rxtime = %d\n",
+		   tbl->within_cnt, tbl->to_sel, tbl->last_in_rxtime);
+
+	return 0;
+}
+
+static int
+mt7996_show_rro_mib(struct seq_file *s, void *data)
+{
+	struct mt7996_dev *dev = dev_get_drvdata(s->private);
+	u32 reg[12];
+
+	seq_printf(s, "RRO mib Info:\n");
+
+	reg[0] = mt76_rr(dev, WF_RRO_TOP_STATISTIC(0));
+	reg[1] = mt76_rr(dev, WF_RRO_TOP_STATISTIC(1));
+	reg[2] = mt76_rr(dev, WF_RRO_TOP_STATISTIC(2));
+	reg[3] = mt76_rr(dev, WF_RRO_TOP_STATISTIC(3));
+	reg[4] = mt76_rr(dev, WF_RRO_TOP_STATISTIC(4));
+	reg[5] = mt76_rr(dev, WF_RRO_TOP_STATISTIC(5));
+	reg[6] = mt76_rr(dev, WF_RRO_TOP_STATISTIC(6));
+	reg[7] = mt76_rr(dev, WF_RRO_TOP_STATISTIC(7));
+	reg[8] = mt76_rr(dev, WF_RRO_TOP_STATISTIC(8));
+	reg[9] = mt76_rr(dev, WF_RRO_TOP_STATISTIC(9));
+	reg[10] = mt76_rr(dev, WF_RRO_TOP_STATISTIC(10));
+	reg[11] = mt76_rr(dev, WF_RRO_TOP_STATISTIC(11));
+
+	seq_printf(s, "STEP_ONE/WITHIN/SURPASS = %x/%x/%x\n", reg[0], reg[3], reg[4]);
+	seq_printf(s, "REPEAT/OLDPKT/BAR = %x/%x/%x\n", reg[1], reg[2], reg[5]);
+	seq_printf(s, "SURPASS with big gap = %x\n", reg[6]);
+	seq_printf(s, "DISCONNECT/INVALID = %x/%x\n", reg[7], reg[8]);
+	seq_printf(s, "TO(Step one)/TO(flush all) = %x/%x\n", reg[9], reg[10]);
+	seq_printf(s, "buf ran out = %x\n", reg[11]);
+
+	return 0;
+}
+
+static int
+mt7996_thermal_enable_get(void *data, u64 *enable)
+{
+	struct mt7996_phy *phy = data;
+
+	*enable = phy->thermal_protection_enable;
+
+	return 0;
+}
+
+static int
+mt7996_thermal_enable_set(void *data, u64 action)
+{
+	struct mt7996_phy *phy = data;
+	int ret;
+	u8 throttling;
+
+	if (action > 1)
+		return -EINVAL;
+
+	if (!!action == phy->thermal_protection_enable)
+		return 0;
+
+	ret = mt7996_mcu_set_thermal_protect(phy, !!action);
+	if (ret)
+		return ret;
+
+	if (!!!action)
+		goto out;
+
+	throttling = MT7996_THERMAL_THROTTLE_MAX - phy->cdev_state;
+	ret = mt7996_mcu_set_thermal_throttling(phy, throttling);
+	if (ret)
+		return ret;
+
+out:
+	phy->thermal_protection_enable = !!action;
+
+	return 0;
+}
+DEFINE_DEBUGFS_ATTRIBUTE(fops_thermal_enable, mt7996_thermal_enable_get,
+			 mt7996_thermal_enable_set, "%lld\n");
+
+static int
+mt7996_thermal_recal_set(void *data, u64 val)
+{
+#define THERMAL_DEBUG_OPERATION_MANUAL_TRIGGER 2
+#define THERMAL_DEBUG_MODE_RECAL 1
+	struct mt7996_dev *dev = data;
+
+	if (val > THERMAL_DEBUG_OPERATION_MANUAL_TRIGGER)
+		return -EINVAL;
+
+	return mt7996_mcu_thermal_debug(dev, THERMAL_DEBUG_MODE_RECAL, val);
+}
+
+DEFINE_DEBUGFS_ATTRIBUTE(fops_thermal_recal, NULL,
+			 mt7996_thermal_recal_set, "%llu\n");
+
+static int
+mt7996_reset_counter(void *data, u64 val)
+{
+	struct mt7996_dev *dev = data;
+	struct mt76_dev *mdev = &dev->mt76;
+	struct mt76_wcid *wcid;
+	int ret;
+
+	/* Reset read-clear counters in FW and WTBL. */
+	ret = mt7996_mcu_get_all_sta_info(mdev, UNI_ALL_STA_TXRX_ADM_STAT);
+	if (ret)
+		return ret;
+
+	ret = mt7996_mcu_get_all_sta_info(mdev, UNI_ALL_STA_TXRX_MSDU_COUNT);
+	if (ret)
+		return ret;
+
+	ret = mt7996_mcu_get_all_sta_info(mdev, UNI_ALL_STA_TXRX_AIRTIME);
+	if (ret)
+		return ret;
+
+	/* Reset counters in MT76. */
+	rcu_read_lock();
+	wcid = rcu_dereference(dev->mt76.wcid[dev->wlan_idx]);
+	if (wcid)
+		memset(&wcid->stats, 0, sizeof(struct mt76_sta_stats));
+	else
+		ret = -EINVAL;
+	rcu_read_unlock();
+
+	return ret;
+}
+DEFINE_DEBUGFS_ATTRIBUTE(fops_reset_counter, NULL, mt7996_reset_counter, "%llu\n");
+
+void mt7996_packet_log_to_host(struct mt7996_dev *dev, const void *data, int len, int type, int des_len)
+{
+	struct bin_debug_hdr *hdr;
+	char *buf;
+
+	if (len > 1500 - sizeof(*hdr))
+	len = 1500 - sizeof(*hdr);
+
+	buf = kzalloc(sizeof(*hdr) + len, GFP_KERNEL);
+	if (!buf)
+		return;
+
+	hdr = (struct bin_debug_hdr *)buf;
+	hdr->magic_num = cpu_to_le32(PKT_BIN_DEBUG_MAGIC);
+	hdr->serial_id = cpu_to_le16(dev->fw_debug_seq++);
+	hdr->msg_type = cpu_to_le16(type);
+	hdr->len = cpu_to_le16(len);
+	hdr->des_len = cpu_to_le16(des_len);
+
+	memcpy(buf + sizeof(*hdr), data, len);
+
+	mt7996_debugfs_rx_log(dev, buf, sizeof(*hdr) + len);
+	kfree(buf);
+}
+
+static int mt7996_rx_token_read(struct seq_file *s, void *data)
+{
+	struct mt7996_dev *dev = dev_get_drvdata(s->private);
+	int id, count = 0;
+	struct mt76_rxwi_cache *r;
+
+	seq_printf(s, "Rx cut through token:\n");
+	spin_lock_bh(&dev->mt76.rx_token_lock);
+	idr_for_each_entry(&dev->mt76.rx_token, r, id) {
+		count++;
+	}
+	seq_printf(s, "\ttotal:%8d used:%8d\n",
+		   dev->mt76.rx_token_size, count);
+	spin_unlock_bh(&dev->mt76.rx_token_lock);
+
+	return 0;
+}
+
+/* AMSDU SETTING */
+static ssize_t mt7996_amsdu_algo_write(struct file *file,
+				   const char __user *user_buf,
+				   size_t count,
+				   loff_t *ppos)
+{
+	struct mt7996_dev *dev = file->private_data;
+	char buf[100];
+	int ret;
+	struct {
+		u8 _rsv[4];
+
+		u16 tag;
+		u16 len;
+
+		u16 wlan_idx;
+		u8 algo_en;
+		u8 rsv[1];
+	} __packed data = {
+		.tag = cpu_to_le16(UNI_MEC_AMSDU_ALGO_EN_STA),
+		.len = cpu_to_le16(sizeof(data) - 4),
+	};
+
+	if (count >= sizeof(buf))
+		return -EINVAL;
+
+	if (copy_from_user(buf, user_buf, count))
+		return -EFAULT;
+
+	if (count && buf[count - 1] == '\n')
+		buf[count - 1] = '\0';
+	else
+		buf[count] = '\0';
+
+	if (sscanf(buf, "%hu %hhu", &data.wlan_idx, &data.algo_en) != 2)
+		return -EINVAL;
+
+	if (data.wlan_idx >= mt7996_wtbl_size(dev))
+		return -EINVAL;
+
+	ret = mt76_mcu_send_msg(&dev->mt76, MCU_WM_UNI_CMD(MEC), &data,
+				sizeof(data), true);
+	if (ret)
+		return -EINVAL;
+
+	return count;
+}
+static const struct file_operations fops_amsdu_algo = {
+	.write = mt7996_amsdu_algo_write,
+	.read = NULL,
+	.open = simple_open,
+	.llseek = default_llseek,
+};
+
+static ssize_t mt7996_amsdu_para_write(struct file *file,
+				   const char __user *user_buf,
+				   size_t count,
+				   loff_t *ppos)
+{
+	struct mt7996_dev *dev = file->private_data;
+	char buf[100];
+	int ret;
+	struct {
+		u8 _rsv[4];
+
+		u16 tag;
+		u16 len;
+
+		u16 wlan_idx;
+		u8  amsdu_en;
+		u8  num;
+		u16 lenth;
+		u8  rsv[2];
+	} __packed data = {
+		.tag = cpu_to_le16(UNI_MEC_AMSDU_PARA_STA),
+		.len = cpu_to_le16(sizeof(data) - 4),
+	};
+
+	if (count >= sizeof(buf))
+		return -EINVAL;
+
+	if (copy_from_user(buf, user_buf, count))
+		return -EFAULT;
+
+	if (count && buf[count - 1] == '\n')
+		buf[count - 1] = '\0';
+	else
+		buf[count] = '\0';
+
+	if (sscanf(buf, "%hu %hhu %hhu %hu", &data.wlan_idx, &data.amsdu_en, &data.num, &data.lenth) != 4)
+		return -EINVAL;
+
+	if (data.wlan_idx >= mt7996_wtbl_size(dev))
+		return -EINVAL;
+
+	ret = mt76_mcu_send_msg(&dev->mt76, MCU_WM_UNI_CMD(MEC), &data,
+			  sizeof(data), true);
+	if (ret)
+		return -EINVAL;
+
+	return count;
+}
+static const struct file_operations fops_amsdu_para = {
+	.write = mt7996_amsdu_para_write,
+	.read = NULL,
+	.open = simple_open,
+	.llseek = default_llseek,
+};
+
+/* PSE INFO */
+static struct bmac_queue_info_t pse_queue_empty_info[] = {
+	{"CPU Q0",  ENUM_UMAC_CPU_PORT_1,     ENUM_UMAC_CTX_Q_0},
+	{"CPU Q1",  ENUM_UMAC_CPU_PORT_1,     ENUM_UMAC_CTX_Q_1},
+	{"CPU Q2",  ENUM_UMAC_CPU_PORT_1,     ENUM_UMAC_CTX_Q_2},
+	{"CPU Q3",  ENUM_UMAC_CPU_PORT_1,     ENUM_UMAC_CTX_Q_3},
+	{NULL, 0, 0}, {NULL, 0, 0}, {NULL, 0, 0}, {NULL, 0, 0}, /* 4~7 not defined */
+	{NULL, 0, 0}, {NULL, 0, 0}, {NULL, 0, 0}, {NULL, 0, 0}, {NULL, 0, 0}, {NULL, 0, 0},
+	{NULL, 0, 0}, {NULL, 0, 0},  /* 14~15 not defined */
+	{"LMAC Q",  ENUM_UMAC_LMAC_PORT_2,    0},
+	{"MDP TX Q0", ENUM_UMAC_LMAC_PORT_2, 1},
+	{"MDP RX Q", ENUM_UMAC_LMAC_PORT_2, 2},
+	{"SEC TX Q0", ENUM_UMAC_LMAC_PORT_2, 3},
+	{"SEC RX Q", ENUM_UMAC_LMAC_PORT_2, 4},
+	{"SFD_PARK Q", ENUM_UMAC_LMAC_PORT_2, 5},
+	{"MDP_TXIOC Q0", ENUM_UMAC_LMAC_PORT_2, 6},
+	{"MDP_RXIOC Q0", ENUM_UMAC_LMAC_PORT_2, 7},
+	{"MDP TX Q1", ENUM_UMAC_LMAC_PORT_2, 0x11},
+	{"SEC TX Q1", ENUM_UMAC_LMAC_PORT_2, 0x13},
+	{"MDP_TXIOC Q1", ENUM_UMAC_LMAC_PORT_2, 0x16},
+	{"MDP_RXIOC Q1", ENUM_UMAC_LMAC_PORT_2, 0x17},
+	{"CPU Q3",  ENUM_UMAC_CPU_PORT_1,     4},
+	{NULL, 0, 0}, {NULL, 0, 0},
+	{"RLS Q",  ENUM_PLE_CTRL_PSE_PORT_3, ENUM_UMAC_PLE_CTRL_P3_Q_0X1F}
+};
+
+static struct bmac_queue_info_t pse_queue_empty2_info[] = {
+	{"MDP_TDPIOC Q0", ENUM_UMAC_LMAC_PORT_2, 0x8},
+	{"MDP_RDPIOC Q0", ENUM_UMAC_LMAC_PORT_2, 0x9},
+	{"MDP_TDPIOC Q1", ENUM_UMAC_LMAC_PORT_2, 0x18},
+	{"MDP_RDPIOC Q1", ENUM_UMAC_LMAC_PORT_2, 0x19},
+	{"MDP_TDPIOC Q2", ENUM_UMAC_LMAC_PORT_2, 0x28},
+	{"MDP_RDPIOC Q2", ENUM_UMAC_LMAC_PORT_2, 0x29},
+	{NULL, 0, 0},
+	{"MDP_RDPIOC Q3", ENUM_UMAC_LMAC_PORT_2, 0x39},
+	{"MDP TX Q2", ENUM_UMAC_LMAC_PORT_2, 0x21},
+	{"SEC TX Q2", ENUM_UMAC_LMAC_PORT_2, 0x23},
+	{"MDP_TXIOC Q2", ENUM_UMAC_LMAC_PORT_2, 0x26},
+	{"MDP_RXIOC Q2", ENUM_UMAC_LMAC_PORT_2, 0x27},
+	{NULL, 0, 0}, {NULL, 0, 0}, {NULL, 0, 0},
+	{"MDP_RXIOC Q3", ENUM_UMAC_LMAC_PORT_2, 0x37},
+	{"HIF Q0", ENUM_UMAC_HIF_PORT_0,    0},
+	{"HIF Q1", ENUM_UMAC_HIF_PORT_0,    1},
+	{"HIF Q2", ENUM_UMAC_HIF_PORT_0,    2},
+	{"HIF Q3", ENUM_UMAC_HIF_PORT_0,    3},
+	{"HIF Q4", ENUM_UMAC_HIF_PORT_0,    4},
+	{"HIF Q5", ENUM_UMAC_HIF_PORT_0,    5},
+	{"HIF Q6", ENUM_UMAC_HIF_PORT_0,    6},
+	{"HIF Q7", ENUM_UMAC_HIF_PORT_0,    7},
+	{"HIF Q8", ENUM_UMAC_HIF_PORT_0,    8},
+	{"HIF Q9", ENUM_UMAC_HIF_PORT_0,    9},
+	{"HIF Q10", ENUM_UMAC_HIF_PORT_0,    10},
+	{"HIF Q11", ENUM_UMAC_HIF_PORT_0,    11},
+	{"HIF Q12", ENUM_UMAC_HIF_PORT_0,    12},
+	{"HIF Q13", ENUM_UMAC_HIF_PORT_0,    13},
+	{NULL, 0, 0}, {NULL, 0, 0}
+};
+
+static int
+mt7996_pseinfo_read(struct seq_file *s, void *data)
+{
+	struct mt7996_dev *dev = dev_get_drvdata(s->private);
+	u32 pse_buf_ctrl, pg_sz, pg_num;
+	u32 pse_stat[2], pg_flow_ctrl[28] = {0};
+	u32 fpg_cnt, ffa_cnt, fpg_head, fpg_tail;
+	u32 max_q, min_q, rsv_pg, used_pg;
+	int i;
+
+	pse_buf_ctrl = mt76_rr(dev, WF_PSE_TOP_PBUF_CTRL_ADDR);
+	pse_stat[0] = mt76_rr(dev, WF_PSE_TOP_QUEUE_EMPTY_ADDR);
+	pse_stat[1] = mt76_rr(dev, WF_PSE_TOP_QUEUE_EMPTY_1_ADDR);
+	pg_flow_ctrl[0] = mt76_rr(dev, WF_PSE_TOP_FREEPG_CNT_ADDR);
+	pg_flow_ctrl[1] = mt76_rr(dev, WF_PSE_TOP_FREEPG_HEAD_TAIL_ADDR);
+	pg_flow_ctrl[2] = mt76_rr(dev, WF_PSE_TOP_PG_HIF0_GROUP_ADDR);
+	pg_flow_ctrl[3] = mt76_rr(dev, WF_PSE_TOP_HIF0_PG_INFO_ADDR);
+	pg_flow_ctrl[4] = mt76_rr(dev, WF_PSE_TOP_PG_HIF1_GROUP_ADDR);
+	pg_flow_ctrl[5] = mt76_rr(dev, WF_PSE_TOP_HIF1_PG_INFO_ADDR);
+	pg_flow_ctrl[6] = mt76_rr(dev, WF_PSE_TOP_PG_CPU_GROUP_ADDR);
+	pg_flow_ctrl[7] = mt76_rr(dev, WF_PSE_TOP_CPU_PG_INFO_ADDR);
+	pg_flow_ctrl[8] = mt76_rr(dev, WF_PSE_TOP_PG_LMAC0_GROUP_ADDR);
+	pg_flow_ctrl[9] = mt76_rr(dev, WF_PSE_TOP_LMAC0_PG_INFO_ADDR);
+	pg_flow_ctrl[10] = mt76_rr(dev, WF_PSE_TOP_PG_LMAC1_GROUP_ADDR);
+	pg_flow_ctrl[11] = mt76_rr(dev, WF_PSE_TOP_LMAC1_PG_INFO_ADDR);
+	pg_flow_ctrl[12] = mt76_rr(dev, WF_PSE_TOP_PG_LMAC2_GROUP_ADDR);
+	pg_flow_ctrl[13] = mt76_rr(dev, WF_PSE_TOP_LMAC2_PG_INFO_ADDR);
+	pg_flow_ctrl[14] = mt76_rr(dev, WF_PSE_TOP_PG_PLE_GROUP_ADDR);
+	pg_flow_ctrl[15] = mt76_rr(dev, WF_PSE_TOP_PLE_PG_INFO_ADDR);
+	pg_flow_ctrl[16] = mt76_rr(dev, WF_PSE_TOP_PG_LMAC3_GROUP_ADDR);
+	pg_flow_ctrl[17] = mt76_rr(dev, WF_PSE_TOP_LMAC3_PG_INFO_ADDR);
+	pg_flow_ctrl[18] = mt76_rr(dev, WF_PSE_TOP_PG_MDP_GROUP_ADDR);
+	pg_flow_ctrl[19] = mt76_rr(dev, WF_PSE_TOP_MDP_PG_INFO_ADDR);
+	pg_flow_ctrl[20] = mt76_rr(dev, WF_PSE_TOP_PG_PLE1_GROUP_ADDR);
+	pg_flow_ctrl[21] = mt76_rr(dev, WF_PSE_TOP_PLE1_PG_INFO_ADDR);
+	pg_flow_ctrl[22] = mt76_rr(dev, WF_PSE_TOP_PG_MDP2_GROUP_ADDR);
+	pg_flow_ctrl[23] = mt76_rr(dev, WF_PSE_TOP_MDP2_PG_INFO_ADDR);
+	if (mt7996_band_valid(dev, MT_BAND2)) {
+		pg_flow_ctrl[24] = mt76_rr(dev, WF_PSE_TOP_PG_MDP3_GROUP_ADDR);
+		pg_flow_ctrl[25] = mt76_rr(dev, WF_PSE_TOP_MDP3_PG_INFO_ADDR);
+	}
+	pg_flow_ctrl[26] = mt76_rr(dev, WF_PSE_TOP_PG_HIF2_GROUP_ADDR);
+	pg_flow_ctrl[27] = mt76_rr(dev, WF_PSE_TOP_HIF2_PG_INFO_ADDR);
+	/* Configuration Info */
+	seq_printf(s, "PSE Configuration Info:\n");
+	seq_printf(s, "\tPacket Buffer Control: 0x%08x\n", pse_buf_ctrl);
+	pg_sz = (pse_buf_ctrl & WF_PSE_TOP_PBUF_CTRL_PAGE_SIZE_CFG_MASK) >> WF_PSE_TOP_PBUF_CTRL_PAGE_SIZE_CFG_SHFT;
+	seq_printf(s, "\t\tPage Size=%d(%d bytes per page)\n", pg_sz, (pg_sz == 1 ? 256 : 128));
+	seq_printf(s, "\t\tPage Offset=%d(in unit of 64KB)\n",
+			 (pse_buf_ctrl & WF_PSE_TOP_PBUF_CTRL_PBUF_OFFSET_MASK) >> WF_PSE_TOP_PBUF_CTRL_PBUF_OFFSET_SHFT);
+	pg_num = (pse_buf_ctrl & WF_PSE_TOP_PBUF_CTRL_TOTAL_PAGE_NUM_MASK) >> WF_PSE_TOP_PBUF_CTRL_TOTAL_PAGE_NUM_SHFT;
+	seq_printf(s, "\t\tTotal page numbers=%d pages\n", pg_num);
+	/* Page Flow Control */
+	seq_printf(s, "PSE Page Flow Control:\n");
+	seq_printf(s, "\tFree page counter: 0x%08x\n", pg_flow_ctrl[0]);
+	fpg_cnt = (pg_flow_ctrl[0] & WF_PSE_TOP_FREEPG_CNT_FREEPG_CNT_MASK) >> WF_PSE_TOP_FREEPG_CNT_FREEPG_CNT_SHFT;
+	seq_printf(s, "\t\tThe toal page number of free=0x%03x\n", fpg_cnt);
+	ffa_cnt = (pg_flow_ctrl[0] & WF_PSE_TOP_FREEPG_CNT_FFA_CNT_MASK) >> WF_PSE_TOP_FREEPG_CNT_FFA_CNT_SHFT;
+	seq_printf(s, "\t\tThe free page numbers of free for all=0x%03x\n", ffa_cnt);
+	seq_printf(s, "\tFree page head and tail: 0x%08x\n", pg_flow_ctrl[1]);
+	fpg_head = (pg_flow_ctrl[1] & WF_PSE_TOP_FREEPG_HEAD_TAIL_FREEPG_HEAD_MASK) >> WF_PSE_TOP_FREEPG_HEAD_TAIL_FREEPG_HEAD_SHFT;
+	fpg_tail = (pg_flow_ctrl[1] & WF_PSE_TOP_FREEPG_HEAD_TAIL_FREEPG_TAIL_MASK) >> WF_PSE_TOP_FREEPG_HEAD_TAIL_FREEPG_TAIL_SHFT;
+	seq_printf(s, "\t\tThe tail/head page of free page list=0x%03x/0x%03x\n", fpg_tail, fpg_head);
+	seq_printf(s, "\tReserved page counter of HIF0 group: 0x%08x\n", pg_flow_ctrl[2]);
+	seq_printf(s, "\tHIF0 group page status: 0x%08x\n", pg_flow_ctrl[3]);
+	min_q = (pg_flow_ctrl[2] & WF_PSE_TOP_PG_HIF0_GROUP_HIF0_MIN_QUOTA_MASK) >> WF_PSE_TOP_PG_HIF0_GROUP_HIF0_MIN_QUOTA_SHFT;
+	max_q = (pg_flow_ctrl[2] & WF_PSE_TOP_PG_HIF0_GROUP_HIF0_MAX_QUOTA_MASK) >> WF_PSE_TOP_PG_HIF0_GROUP_HIF0_MAX_QUOTA_SHFT;
+	seq_printf(s, "\t\tThe max/min quota pages of HIF0 group=0x%03x/0x%03x\n", max_q, min_q);
+	rsv_pg = (pg_flow_ctrl[3] & WF_PSE_TOP_HIF0_PG_INFO_HIF0_RSV_CNT_MASK) >> WF_PSE_TOP_HIF0_PG_INFO_HIF0_RSV_CNT_SHFT;
+	used_pg = (pg_flow_ctrl[3] & WF_PSE_TOP_HIF0_PG_INFO_HIF0_SRC_CNT_MASK) >> WF_PSE_TOP_HIF0_PG_INFO_HIF0_SRC_CNT_SHFT;
+	seq_printf(s, "\t\tThe used/reserved pages of HIF0 group=0x%03x/0x%03x\n", used_pg, rsv_pg);
+	seq_printf(s, "\tReserved page counter of HIF1 group: 0x%08x\n", pg_flow_ctrl[4]);
+	seq_printf(s, "\tHIF1 group page status: 0x%08x\n", pg_flow_ctrl[5]);
+	min_q = (pg_flow_ctrl[4] & WF_PSE_TOP_PG_HIF1_GROUP_HIF1_MIN_QUOTA_MASK) >> WF_PSE_TOP_PG_HIF1_GROUP_HIF1_MIN_QUOTA_SHFT;
+	max_q = (pg_flow_ctrl[4] & WF_PSE_TOP_PG_HIF1_GROUP_HIF1_MAX_QUOTA_MASK) >> WF_PSE_TOP_PG_HIF1_GROUP_HIF1_MAX_QUOTA_SHFT;
+	seq_printf(s, "\t\tThe max/min quota pages of HIF1 group=0x%03x/0x%03x\n", max_q, min_q);
+	rsv_pg = (pg_flow_ctrl[5] & WF_PSE_TOP_HIF1_PG_INFO_HIF1_RSV_CNT_MASK) >> WF_PSE_TOP_HIF1_PG_INFO_HIF1_RSV_CNT_SHFT;
+	used_pg = (pg_flow_ctrl[5] & WF_PSE_TOP_HIF1_PG_INFO_HIF1_SRC_CNT_MASK) >> WF_PSE_TOP_HIF1_PG_INFO_HIF1_SRC_CNT_SHFT;
+	seq_printf(s, "\t\tThe used/reserved pages of HIF1 group=0x%03x/0x%03x\n", used_pg, rsv_pg);
+	seq_printf(s, "\tReserved page counter of HIF2 group: 0x%08x\n", pg_flow_ctrl[26]);
+	seq_printf(s, "\tHIF2 group page status: 0x%08x\n", pg_flow_ctrl[27]);
+	min_q = (pg_flow_ctrl[26] & WF_PSE_TOP_PG_HIF2_GROUP_HIF2_MIN_QUOTA_MASK) >> WF_PSE_TOP_PG_HIF2_GROUP_HIF2_MIN_QUOTA_SHFT;
+	max_q = (pg_flow_ctrl[26] & WF_PSE_TOP_PG_HIF2_GROUP_HIF2_MAX_QUOTA_MASK) >> WF_PSE_TOP_PG_HIF2_GROUP_HIF2_MAX_QUOTA_SHFT;
+	seq_printf(s, "\t\tThe max/min quota pages of HIF2 group=0x%03x/0x%03x\n", max_q, min_q);
+	rsv_pg = (pg_flow_ctrl[27] & WF_PSE_TOP_HIF2_PG_INFO_HIF2_RSV_CNT_MASK) >> WF_PSE_TOP_HIF2_PG_INFO_HIF2_RSV_CNT_SHFT;
+	used_pg = (pg_flow_ctrl[27] & WF_PSE_TOP_HIF2_PG_INFO_HIF2_SRC_CNT_MASK) >> WF_PSE_TOP_HIF2_PG_INFO_HIF2_SRC_CNT_SHFT;
+	seq_printf(s, "\t\tThe used/reserved pages of HIF2 group=0x%03x/0x%03x\n", used_pg, rsv_pg);
+	seq_printf(s, "\tReserved page counter of CPU group: 0x%08x\n", pg_flow_ctrl[6]);
+	seq_printf(s, "\tCPU group page status: 0x%08x\n", pg_flow_ctrl[7]);
+	min_q = (pg_flow_ctrl[6] & WF_PSE_TOP_PG_CPU_GROUP_CPU_MIN_QUOTA_MASK) >> WF_PSE_TOP_PG_CPU_GROUP_CPU_MIN_QUOTA_SHFT;
+	max_q = (pg_flow_ctrl[6] & WF_PSE_TOP_PG_CPU_GROUP_CPU_MAX_QUOTA_MASK) >> WF_PSE_TOP_PG_CPU_GROUP_CPU_MAX_QUOTA_SHFT;
+	seq_printf(s, "\t\tThe max/min quota pages of CPU group=0x%03x/0x%03x\n", max_q, min_q);
+	rsv_pg = (pg_flow_ctrl[7] & WF_PSE_TOP_CPU_PG_INFO_CPU_RSV_CNT_MASK) >> WF_PSE_TOP_CPU_PG_INFO_CPU_RSV_CNT_SHFT;
+	used_pg = (pg_flow_ctrl[7] & WF_PSE_TOP_CPU_PG_INFO_CPU_SRC_CNT_MASK) >> WF_PSE_TOP_CPU_PG_INFO_CPU_SRC_CNT_SHFT;
+	seq_printf(s, "\t\tThe used/reserved pages of CPU group=0x%03x/0x%03x\n", used_pg, rsv_pg);
+	seq_printf(s, "\tReserved page counter of LMAC0 group: 0x%08x\n", pg_flow_ctrl[8]);
+	seq_printf(s, "\tLMAC0 group page status: 0x%08x\n", pg_flow_ctrl[9]);
+	min_q = (pg_flow_ctrl[8] & WF_PSE_TOP_PG_LMAC0_GROUP_LMAC0_MIN_QUOTA_MASK) >> WF_PSE_TOP_PG_LMAC0_GROUP_LMAC0_MIN_QUOTA_SHFT;
+	max_q = (pg_flow_ctrl[8] & WF_PSE_TOP_PG_LMAC0_GROUP_LMAC0_MAX_QUOTA_MASK) >> WF_PSE_TOP_PG_LMAC0_GROUP_LMAC0_MAX_QUOTA_SHFT;
+	seq_printf(s, "\t\tThe max/min quota pages of LMAC0 group=0x%03x/0x%03x\n", max_q, min_q);
+	rsv_pg = (pg_flow_ctrl[9] & WF_PSE_TOP_LMAC0_PG_INFO_LMAC0_RSV_CNT_MASK) >> WF_PSE_TOP_LMAC0_PG_INFO_LMAC0_RSV_CNT_SHFT;
+	used_pg = (pg_flow_ctrl[9] & WF_PSE_TOP_LMAC0_PG_INFO_LMAC0_SRC_CNT_MASK) >> WF_PSE_TOP_LMAC0_PG_INFO_LMAC0_SRC_CNT_SHFT;
+	seq_printf(s, "\t\tThe used/reserved pages of LMAC0 group=0x%03x/0x%03x\n", used_pg, rsv_pg);
+	seq_printf(s, "\tReserved page counter of LMAC1 group: 0x%08x\n", pg_flow_ctrl[10]);
+	seq_printf(s, "\tLMAC1 group page status: 0x%08x\n", pg_flow_ctrl[11]);
+	min_q = (pg_flow_ctrl[10] & WF_PSE_TOP_PG_LMAC1_GROUP_LMAC1_MIN_QUOTA_MASK) >> WF_PSE_TOP_PG_LMAC1_GROUP_LMAC1_MIN_QUOTA_SHFT;
+	max_q = (pg_flow_ctrl[10] & WF_PSE_TOP_PG_LMAC1_GROUP_LMAC1_MAX_QUOTA_MASK) >> WF_PSE_TOP_PG_LMAC1_GROUP_LMAC1_MAX_QUOTA_SHFT;
+	seq_printf(s, "\t\tThe max/min quota pages of LMAC1 group=0x%03x/0x%03x\n", max_q, min_q);
+	rsv_pg = (pg_flow_ctrl[11] & WF_PSE_TOP_LMAC1_PG_INFO_LMAC1_RSV_CNT_MASK) >> WF_PSE_TOP_LMAC1_PG_INFO_LMAC1_RSV_CNT_SHFT;
+	used_pg = (pg_flow_ctrl[11] & WF_PSE_TOP_LMAC1_PG_INFO_LMAC1_SRC_CNT_MASK) >> WF_PSE_TOP_LMAC1_PG_INFO_LMAC1_SRC_CNT_SHFT;
+	seq_printf(s, "\t\tThe used/reserved pages of LMAC1 group=0x%03x/0x%03x\n", used_pg, rsv_pg);
+	seq_printf(s, "\tReserved page counter of LMAC2 group: 0x%08x\n", pg_flow_ctrl[11]);
+	seq_printf(s, "\tLMAC2 group page status: 0x%08x\n", pg_flow_ctrl[12]);
+	min_q = (pg_flow_ctrl[12] & WF_PSE_TOP_PG_LMAC2_GROUP_LMAC2_MIN_QUOTA_MASK) >> WF_PSE_TOP_PG_LMAC2_GROUP_LMAC2_MIN_QUOTA_SHFT;
+	max_q = (pg_flow_ctrl[12] & WF_PSE_TOP_PG_LMAC2_GROUP_LMAC2_MAX_QUOTA_MASK) >> WF_PSE_TOP_PG_LMAC2_GROUP_LMAC2_MAX_QUOTA_SHFT;
+	seq_printf(s, "\t\tThe max/min quota pages of LMAC2 group=0x%03x/0x%03x\n", max_q, min_q);
+	rsv_pg = (pg_flow_ctrl[13] & WF_PSE_TOP_LMAC2_PG_INFO_LMAC2_RSV_CNT_MASK) >> WF_PSE_TOP_LMAC2_PG_INFO_LMAC2_RSV_CNT_SHFT;
+	used_pg = (pg_flow_ctrl[13] & WF_PSE_TOP_LMAC2_PG_INFO_LMAC2_SRC_CNT_MASK) >> WF_PSE_TOP_LMAC2_PG_INFO_LMAC2_SRC_CNT_SHFT;
+	seq_printf(s, "\t\tThe used/reserved pages of LMAC2 group=0x%03x/0x%03x\n", used_pg, rsv_pg);
+
+	seq_printf(s, "\tReserved page counter of LMAC3 group: 0x%08x\n", pg_flow_ctrl[16]);
+	seq_printf(s, "\tLMAC3 group page status: 0x%08x\n", pg_flow_ctrl[17]);
+	min_q = (pg_flow_ctrl[16] & WF_PSE_TOP_PG_LMAC3_GROUP_LMAC3_MIN_QUOTA_MASK) >> WF_PSE_TOP_PG_LMAC3_GROUP_LMAC3_MIN_QUOTA_SHFT;
+	max_q = (pg_flow_ctrl[16] & WF_PSE_TOP_PG_LMAC3_GROUP_LMAC3_MAX_QUOTA_MASK) >> WF_PSE_TOP_PG_LMAC3_GROUP_LMAC3_MAX_QUOTA_SHFT;
+	seq_printf(s, "\t\tThe max/min quota pages of LMAC3 group=0x%03x/0x%03x\n", max_q, min_q);
+	rsv_pg = (pg_flow_ctrl[17] & WF_PSE_TOP_LMAC3_PG_INFO_LMAC3_RSV_CNT_MASK) >> WF_PSE_TOP_LMAC3_PG_INFO_LMAC3_RSV_CNT_SHFT;
+	used_pg = (pg_flow_ctrl[17] & WF_PSE_TOP_LMAC3_PG_INFO_LMAC3_SRC_CNT_MASK) >> WF_PSE_TOP_LMAC3_PG_INFO_LMAC3_SRC_CNT_SHFT;
+	seq_printf(s, "\t\tThe used/reserved pages of LMAC3 group=0x%03x/0x%03x\n", used_pg, rsv_pg);
+
+	seq_printf(s, "\tReserved page counter of PLE group: 0x%08x\n", pg_flow_ctrl[14]);
+	seq_printf(s, "\tPLE group page status: 0x%08x\n", pg_flow_ctrl[15]);
+	min_q = (pg_flow_ctrl[14] & WF_PSE_TOP_PG_PLE_GROUP_PLE_MIN_QUOTA_MASK) >> WF_PSE_TOP_PG_PLE_GROUP_PLE_MIN_QUOTA_SHFT;
+	max_q = (pg_flow_ctrl[14] & WF_PSE_TOP_PG_PLE_GROUP_PLE_MAX_QUOTA_MASK) >> WF_PSE_TOP_PG_PLE_GROUP_PLE_MAX_QUOTA_SHFT;
+	seq_printf(s, "\t\tThe max/min quota pages of PLE group=0x%03x/0x%03x\n", max_q, min_q);
+	rsv_pg = (pg_flow_ctrl[15] & WF_PSE_TOP_PLE_PG_INFO_PLE_RSV_CNT_MASK) >> WF_PSE_TOP_PLE_PG_INFO_PLE_RSV_CNT_SHFT;
+	used_pg = (pg_flow_ctrl[15] & WF_PSE_TOP_PLE_PG_INFO_PLE_SRC_CNT_MASK) >> WF_PSE_TOP_PLE_PG_INFO_PLE_SRC_CNT_SHFT;
+	seq_printf(s, "\t\tThe used/reserved pages of PLE group=0x%03x/0x%03x\n", used_pg, rsv_pg);
+
+	seq_printf(s, "\tReserved page counter of PLE1 group: 0x%08x\n", pg_flow_ctrl[14]);
+	seq_printf(s, "\tPLE1 group page status: 0x%08x\n", pg_flow_ctrl[15]);
+	min_q = (pg_flow_ctrl[20] & WF_PSE_TOP_PG_PLE_GROUP_PLE_MIN_QUOTA_MASK) >> WF_PSE_TOP_PG_PLE_GROUP_PLE_MIN_QUOTA_SHFT;
+	max_q = (pg_flow_ctrl[20] & WF_PSE_TOP_PG_PLE_GROUP_PLE_MAX_QUOTA_MASK) >> WF_PSE_TOP_PG_PLE_GROUP_PLE_MAX_QUOTA_SHFT;
+	seq_printf(s, "\t\tThe max/min quota pages of PLE1 group=0x%03x/0x%03x\n", max_q, min_q);
+	rsv_pg = (pg_flow_ctrl[21] & WF_PSE_TOP_PLE_PG_INFO_PLE_RSV_CNT_MASK) >> WF_PSE_TOP_PLE_PG_INFO_PLE_RSV_CNT_SHFT;
+	used_pg = (pg_flow_ctrl[21] & WF_PSE_TOP_PLE_PG_INFO_PLE_SRC_CNT_MASK) >> WF_PSE_TOP_PLE_PG_INFO_PLE_SRC_CNT_SHFT;
+	seq_printf(s, "\t\tThe used/reserved pages of PLE1 group=0x%03x/0x%03x\n", used_pg, rsv_pg);
+
+	seq_printf(s, "\tReserved page counter of MDP group: 0x%08x\n", pg_flow_ctrl[18]);
+	seq_printf(s, "\tMDP group page status: 0x%08x\n", pg_flow_ctrl[19]);
+	min_q = (pg_flow_ctrl[18] & WF_PSE_TOP_PG_MDP_GROUP_MDP_MIN_QUOTA_MASK) >> WF_PSE_TOP_PG_MDP_GROUP_MDP_MIN_QUOTA_SHFT;
+	max_q = (pg_flow_ctrl[18] & WF_PSE_TOP_PG_MDP_GROUP_MDP_MAX_QUOTA_MASK) >> WF_PSE_TOP_PG_MDP_GROUP_MDP_MAX_QUOTA_SHFT;
+	seq_printf(s, "\t\tThe max/min quota pages of MDP group=0x%03x/0x%03x\n", max_q, min_q);
+	rsv_pg = (pg_flow_ctrl[19] & WF_PSE_TOP_MDP_PG_INFO_MDP_RSV_CNT_MASK) >> WF_PSE_TOP_MDP_PG_INFO_MDP_RSV_CNT_SHFT;
+	used_pg = (pg_flow_ctrl[19] & WF_PSE_TOP_MDP_PG_INFO_MDP_SRC_CNT_MASK) >> WF_PSE_TOP_MDP_PG_INFO_MDP_SRC_CNT_SHFT;
+	seq_printf(s, "\t\tThe used/reserved pages of MDP group=0x%03x/0x%03x\n", used_pg, rsv_pg);
+	seq_printf(s, "\tReserved page counter of MDP2 group: 0x%08x\n", pg_flow_ctrl[22]);
+	seq_printf(s, "\tMDP2 group page status: 0x%08x\n", pg_flow_ctrl[23]);
+	min_q = (pg_flow_ctrl[22] & WF_PSE_TOP_PG_MDP2_GROUP_MDP2_MIN_QUOTA_MASK) >> WF_PSE_TOP_PG_MDP2_GROUP_MDP2_MIN_QUOTA_SHFT;
+	max_q = (pg_flow_ctrl[22] & WF_PSE_TOP_PG_MDP2_GROUP_MDP2_MAX_QUOTA_MASK) >> WF_PSE_TOP_PG_MDP2_GROUP_MDP2_MAX_QUOTA_SHFT;
+	seq_printf(s, "\t\tThe max/min quota pages of MDP2 group=0x%03x/0x%03x\n", max_q, min_q);
+	rsv_pg = (pg_flow_ctrl[23] & WF_PSE_TOP_MDP2_PG_INFO_MDP2_RSV_CNT_MASK) >> WF_PSE_TOP_MDP2_PG_INFO_MDP2_RSV_CNT_SHFT;
+	used_pg = (pg_flow_ctrl[23] & WF_PSE_TOP_MDP2_PG_INFO_MDP2_SRC_CNT_MASK) >> WF_PSE_TOP_MDP2_PG_INFO_MDP2_SRC_CNT_SHFT;
+	seq_printf(s, "\t\tThe used/reserved pages of MDP2 group=0x%03x/0x%03x\n", used_pg, rsv_pg);
+	if (mt7996_band_valid(dev, MT_BAND2)) {
+		seq_printf(s, "\tReserved page counter of MDP3 group: 0x%08x\n", pg_flow_ctrl[24]);
+		seq_printf(s, "\tMDP3 group page status: 0x%08x\n", pg_flow_ctrl[25]);
+		min_q = (pg_flow_ctrl[24] & WF_PSE_TOP_PG_MDP3_GROUP_MDP3_MIN_QUOTA_MASK) >> WF_PSE_TOP_PG_MDP3_GROUP_MDP3_MIN_QUOTA_SHFT;
+		max_q = (pg_flow_ctrl[24] & WF_PSE_TOP_PG_MDP3_GROUP_MDP3_MAX_QUOTA_MASK) >> WF_PSE_TOP_PG_MDP3_GROUP_MDP3_MAX_QUOTA_SHFT;
+		seq_printf(s, "\t\tThe max/min quota pages of MDP3 group=0x%03x/0x%03x\n", max_q, min_q);
+		rsv_pg = (pg_flow_ctrl[25] & WF_PSE_TOP_MDP3_PG_INFO_MDP3_RSV_CNT_MASK) >> WF_PSE_TOP_MDP3_PG_INFO_MDP3_RSV_CNT_SHFT;
+		used_pg = (pg_flow_ctrl[25] & WF_PSE_TOP_MDP3_PG_INFO_MDP3_SRC_CNT_MASK) >> WF_PSE_TOP_MDP3_PG_INFO_MDP3_SRC_CNT_SHFT;
+		seq_printf(s, "\t\tThe used/reserved pages of MDP3 group=0x%03x/0x%03x\n", used_pg, rsv_pg);
+	}
+	/* Queue Empty Status */
+	seq_printf(s, "PSE Queue Empty Status:\n");
+	seq_printf(s, "\tQUEUE_EMPTY: 0x%08x, QUEUE_EMPTY2: 0x%08x\n", pse_stat[0], pse_stat[1]);
+	seq_printf(s, "\t\tCPU Q0/1/2/3/4 empty=%d/%d/%d/%d/%d\n",
+			  (pse_stat[0] & WF_PSE_TOP_QUEUE_EMPTY_CPU_Q0_EMPTY_MASK) >> WF_PSE_TOP_QUEUE_EMPTY_CPU_Q0_EMPTY_SHFT,
+			  ((pse_stat[0] & WF_PSE_TOP_QUEUE_EMPTY_CPU_Q1_EMPTY_MASK) >> WF_PSE_TOP_QUEUE_EMPTY_CPU_Q1_EMPTY_SHFT),
+			  ((pse_stat[0] & WF_PSE_TOP_QUEUE_EMPTY_CPU_Q2_EMPTY_MASK) >> WF_PSE_TOP_QUEUE_EMPTY_CPU_Q2_EMPTY_SHFT),
+			  ((pse_stat[0] & WF_PSE_TOP_QUEUE_EMPTY_CPU_Q3_EMPTY_MASK) >> WF_PSE_TOP_QUEUE_EMPTY_CPU_Q3_EMPTY_SHFT),
+			  ((pse_stat[0] & WF_PSE_TOP_QUEUE_EMPTY_CPU_Q4_EMPTY_MASK) >> WF_PSE_TOP_QUEUE_EMPTY_CPU_Q4_EMPTY_SHFT));
+	seq_printf(s, "\t\tHIF Q0/1/2/3/4/5/6/7/8/9/10/11/12/13 empty=%d/%d/%d/%d/%d/%d/%d/%d/%d/%d/%d/%d/%d/%d\n",
+			  ((pse_stat[1] & WF_PSE_TOP_QUEUE_EMPTY_1_HIF_0_EMPTY_MASK) >> WF_PSE_TOP_QUEUE_EMPTY_1_HIF_0_EMPTY_SHFT),
+			  ((pse_stat[1] & WF_PSE_TOP_QUEUE_EMPTY_1_HIF_1_EMPTY_MASK) >> WF_PSE_TOP_QUEUE_EMPTY_1_HIF_1_EMPTY_SHFT),
+			  ((pse_stat[1] & WF_PSE_TOP_QUEUE_EMPTY_1_HIF_2_EMPTY_MASK) >> WF_PSE_TOP_QUEUE_EMPTY_1_HIF_2_EMPTY_SHFT),
+			  ((pse_stat[1] & WF_PSE_TOP_QUEUE_EMPTY_1_HIF_3_EMPTY_MASK) >> WF_PSE_TOP_QUEUE_EMPTY_1_HIF_3_EMPTY_SHFT),
+			  ((pse_stat[1] & WF_PSE_TOP_QUEUE_EMPTY_1_HIF_4_EMPTY_MASK) >> WF_PSE_TOP_QUEUE_EMPTY_1_HIF_4_EMPTY_SHFT),
+			  ((pse_stat[1] & WF_PSE_TOP_QUEUE_EMPTY_1_HIF_5_EMPTY_MASK) >> WF_PSE_TOP_QUEUE_EMPTY_1_HIF_5_EMPTY_SHFT),
+			  ((pse_stat[1] & WF_PSE_TOP_QUEUE_EMPTY_1_HIF_6_EMPTY_MASK) >> WF_PSE_TOP_QUEUE_EMPTY_1_HIF_6_EMPTY_SHFT),
+			  ((pse_stat[1] & WF_PSE_TOP_QUEUE_EMPTY_1_HIF_7_EMPTY_MASK) >> WF_PSE_TOP_QUEUE_EMPTY_1_HIF_7_EMPTY_SHFT),
+			  ((pse_stat[1] & WF_PSE_TOP_QUEUE_EMPTY_1_HIF_8_EMPTY_MASK) >> WF_PSE_TOP_QUEUE_EMPTY_1_HIF_8_EMPTY_SHFT),
+			  ((pse_stat[1] & WF_PSE_TOP_QUEUE_EMPTY_1_HIF_9_EMPTY_MASK) >> WF_PSE_TOP_QUEUE_EMPTY_1_HIF_9_EMPTY_SHFT),
+			  ((pse_stat[1] & WF_PSE_TOP_QUEUE_EMPTY_1_HIF_10_EMPTY_MASK) >> WF_PSE_TOP_QUEUE_EMPTY_1_HIF_10_EMPTY_SHFT),
+			  ((pse_stat[1] & WF_PSE_TOP_QUEUE_EMPTY_1_HIF_11_EMPTY_MASK) >> WF_PSE_TOP_QUEUE_EMPTY_1_HIF_11_EMPTY_SHFT),
+			  ((pse_stat[1] & WF_PSE_TOP_QUEUE_EMPTY_1_HIF_12_EMPTY_MASK) >> WF_PSE_TOP_QUEUE_EMPTY_1_HIF_12_EMPTY_SHFT),
+			  ((pse_stat[1] & WF_PSE_TOP_QUEUE_EMPTY_1_HIF_13_EMPTY_MASK) >> WF_PSE_TOP_QUEUE_EMPTY_1_HIF_13_EMPTY_SHFT));
+	seq_printf(s, "\t\tLMAC TX Q empty=%d\n",
+			  ((pse_stat[0] & WF_PSE_TOP_QUEUE_EMPTY_LMAC_TX_QUEUE_EMPTY_MASK) >> WF_PSE_TOP_QUEUE_EMPTY_LMAC_TX_QUEUE_EMPTY_SHFT));
+	seq_printf(s, "\t\tMDP TX Q0/Q1/Q2/RX Q empty=%d/%d/%d/%d\n",
+			  ((pse_stat[0] & WF_PSE_TOP_QUEUE_EMPTY_MDP_TX_QUEUE_EMPTY_MASK) >> WF_PSE_TOP_QUEUE_EMPTY_MDP_TX_QUEUE_EMPTY_SHFT),
+			  ((pse_stat[0] & WF_PSE_TOP_QUEUE_EMPTY_MDP_TX1_QUEUE_EMPTY_MASK) >> WF_PSE_TOP_QUEUE_EMPTY_MDP_TX1_QUEUE_EMPTY_SHFT),
+			  ((pse_stat[1] & WF_PSE_TOP_QUEUE_EMPTY_1_MDP_TX2_QUEUE_EMPTY_MASK) >> WF_PSE_TOP_QUEUE_EMPTY_1_MDP_TX2_QUEUE_EMPTY_SHFT),
+			  ((pse_stat[0] & WF_PSE_TOP_QUEUE_EMPTY_MDP_RX_QUEUE_EMPTY_MASK) >> WF_PSE_TOP_QUEUE_EMPTY_MDP_RX_QUEUE_EMPTY_SHFT));
+	seq_printf(s, "\t\tSEC TX Q0/Q1/Q2/RX Q empty=%d/%d/%d/%d\n",
+			  ((pse_stat[0] & WF_PSE_TOP_QUEUE_EMPTY_SEC_TX_QUEUE_EMPTY_MASK) >> WF_PSE_TOP_QUEUE_EMPTY_SEC_TX_QUEUE_EMPTY_SHFT),
+			  ((pse_stat[0] & WF_PSE_TOP_QUEUE_EMPTY_SEC_TX1_QUEUE_EMPTY_MASK) >> WF_PSE_TOP_QUEUE_EMPTY_SEC_TX1_QUEUE_EMPTY_SHFT),
+			  ((pse_stat[1] & WF_PSE_TOP_QUEUE_EMPTY_1_SEC_TX2_QUEUE_EMPTY_MASK) >> WF_PSE_TOP_QUEUE_EMPTY_1_SEC_TX2_QUEUE_EMPTY_SHFT),
+			  ((pse_stat[0] & WF_PSE_TOP_QUEUE_EMPTY_SEC_RX_QUEUE_EMPTY_MASK) >> WF_PSE_TOP_QUEUE_EMPTY_SEC_RX_QUEUE_EMPTY_SHFT));
+	seq_printf(s, "\t\tSFD PARK Q empty=%d\n",
+			  ((pse_stat[0] & WF_PSE_TOP_QUEUE_EMPTY_SFD_PARK_QUEUE_EMPTY_MASK) >> WF_PSE_TOP_QUEUE_EMPTY_SFD_PARK_QUEUE_EMPTY_SHFT));
+	seq_printf(s, "\t\tMDP TXIOC Q0/Q1/Q2 empty=%d/%d/%d\n",
+			  ((pse_stat[0] & WF_PSE_TOP_QUEUE_EMPTY_MDP_TXIOC_QUEUE_EMPTY_MASK) >> WF_PSE_TOP_QUEUE_EMPTY_MDP_TXIOC_QUEUE_EMPTY_SHFT),
+			  ((pse_stat[0] & WF_PSE_TOP_QUEUE_EMPTY_MDP_TXIOC1_QUEUE_EMPTY_MASK) >> WF_PSE_TOP_QUEUE_EMPTY_MDP_TXIOC1_QUEUE_EMPTY_SHFT),
+			  ((pse_stat[1] & WF_PSE_TOP_QUEUE_EMPTY_1_MDP_TXIOC2_QUEUE_EMPTY_MASK) >> WF_PSE_TOP_QUEUE_EMPTY_1_MDP_TXIOC2_QUEUE_EMPTY_SHFT));
+	seq_printf(s, "\t\tMDP RXIOC Q0/Q1/Q2/Q3 empty=%d/%d/%d/%d\n",
+			  ((pse_stat[0] & WF_PSE_TOP_QUEUE_EMPTY_MDP_RXIOC_QUEUE_EMPTY_MASK) >> WF_PSE_TOP_QUEUE_EMPTY_MDP_RXIOC_QUEUE_EMPTY_SHFT),
+			  ((pse_stat[0] & WF_PSE_TOP_QUEUE_EMPTY_MDP_RXIOC1_QUEUE_EMPTY_MASK) >> WF_PSE_TOP_QUEUE_EMPTY_MDP_RXIOC1_QUEUE_EMPTY_SHFT),
+			  ((pse_stat[1] & WF_PSE_TOP_QUEUE_EMPTY_1_MDP_RXIOC2_QUEUE_EMPTY_MASK) >> WF_PSE_TOP_QUEUE_EMPTY_1_MDP_RXIOC2_QUEUE_EMPTY_SHFT),
+			  ((pse_stat[1] & WF_PSE_TOP_QUEUE_EMPTY_1_MDP_RXIOC3_QUEUE_EMPTY_MASK) >> WF_PSE_TOP_QUEUE_EMPTY_1_MDP_RXIOC3_QUEUE_EMPTY_SHFT));
+	seq_printf(s, "\t\tRLS Q empty=%d\n",
+			  ((pse_stat[0] & WF_PSE_TOP_QUEUE_EMPTY_RLS_Q_EMTPY_MASK) >> WF_PSE_TOP_QUEUE_EMPTY_RLS_Q_EMTPY_SHFT));
+	seq_printf(s, "Nonempty Q info:\n");
+
+	for (i = 0; i < 31; i++) {
+		if (((pse_stat[0] & (0x1 << i)) >> i) == 0) {
+			u32 hfid, tfid, pktcnt, fl_que_ctrl[3] = {0};
+
+			if (pse_queue_empty_info[i].QueueName != NULL) {
+				seq_printf(s, "\t%s: ", pse_queue_empty_info[i].QueueName);
+				fl_que_ctrl[0] |= WF_PSE_TOP_FL_QUE_CTRL_0_EXECUTE_MASK;
+				fl_que_ctrl[0] |= (pse_queue_empty_info[i].Portid << WF_PSE_TOP_FL_QUE_CTRL_0_Q_BUF_PID_SHFT);
+				fl_que_ctrl[0] |= (pse_queue_empty_info[i].Queueid << WF_PSE_TOP_FL_QUE_CTRL_0_Q_BUF_QID_SHFT);
+			} else
+				continue;
+
+			fl_que_ctrl[0] |= (0x1 << 31);
+			mt76_wr(dev, WF_PSE_TOP_FL_QUE_CTRL_0_ADDR, fl_que_ctrl[0]);
+			fl_que_ctrl[1] = mt76_rr(dev, WF_PSE_TOP_FL_QUE_CTRL_2_ADDR);
+			fl_que_ctrl[2] = mt76_rr(dev, WF_PSE_TOP_FL_QUE_CTRL_3_ADDR);
+			hfid = (fl_que_ctrl[1] & WF_PSE_TOP_FL_QUE_CTRL_2_QUEUE_HEAD_FID_MASK) >> WF_PSE_TOP_FL_QUE_CTRL_2_QUEUE_HEAD_FID_SHFT;
+			tfid = (fl_que_ctrl[1] & WF_PSE_TOP_FL_QUE_CTRL_2_QUEUE_TAIL_FID_MASK) >> WF_PSE_TOP_FL_QUE_CTRL_2_QUEUE_TAIL_FID_SHFT;
+			pktcnt = (fl_que_ctrl[2] & WF_PSE_TOP_FL_QUE_CTRL_3_QUEUE_PKT_NUM_MASK) >> WF_PSE_TOP_FL_QUE_CTRL_3_QUEUE_PKT_NUM_SHFT;
+			seq_printf(s, "tail/head fid = 0x%03x/0x%03x, pkt cnt = 0x%03x\n",
+					  tfid, hfid, pktcnt);
+		}
+	}
+
+	for (i = 0; i < 31; i++) {
+		if (((pse_stat[1] & (0x1 << i)) >> i) == 0) {
+			u32 hfid, tfid, pktcnt, fl_que_ctrl[3] = {0};
+
+			if (pse_queue_empty2_info[i].QueueName != NULL) {
+				seq_printf(s, "\t%s: ", pse_queue_empty2_info[i].QueueName);
+				fl_que_ctrl[0] |= WF_PSE_TOP_FL_QUE_CTRL_0_EXECUTE_MASK;
+				fl_que_ctrl[0] |= (pse_queue_empty2_info[i].Portid << WF_PSE_TOP_FL_QUE_CTRL_0_Q_BUF_PID_SHFT);
+				fl_que_ctrl[0] |= (pse_queue_empty2_info[i].Queueid << WF_PSE_TOP_FL_QUE_CTRL_0_Q_BUF_QID_SHFT);
+			} else
+				continue;
+
+			fl_que_ctrl[0] |= (0x1 << 31);
+			mt76_wr(dev, WF_PSE_TOP_FL_QUE_CTRL_0_ADDR, fl_que_ctrl[0]);
+			fl_que_ctrl[1] = mt76_rr(dev, WF_PSE_TOP_FL_QUE_CTRL_2_ADDR);
+			fl_que_ctrl[2] = mt76_rr(dev, WF_PSE_TOP_FL_QUE_CTRL_3_ADDR);
+			hfid = (fl_que_ctrl[1] & WF_PSE_TOP_FL_QUE_CTRL_2_QUEUE_HEAD_FID_MASK) >> WF_PSE_TOP_FL_QUE_CTRL_2_QUEUE_HEAD_FID_SHFT;
+			tfid = (fl_que_ctrl[1] & WF_PSE_TOP_FL_QUE_CTRL_2_QUEUE_TAIL_FID_MASK) >> WF_PSE_TOP_FL_QUE_CTRL_2_QUEUE_TAIL_FID_SHFT;
+			pktcnt = (fl_que_ctrl[2] & WF_PSE_TOP_FL_QUE_CTRL_3_QUEUE_PKT_NUM_MASK) >> WF_PSE_TOP_FL_QUE_CTRL_3_QUEUE_PKT_NUM_SHFT;
+			seq_printf(s, "tail/head fid = 0x%03x/0x%03x, pkt cnt = 0x%03x\n",
+					  tfid, hfid, pktcnt);
+		}
+	}
+
+	return 0;
+}
+
+/* PLE INFO */
+static char *sta_ctrl_reg[] = {"ENABLE", "DISABLE", "PAUSE", "TWT_PAUSE"};
+static struct bmac_queue_info ple_queue_empty_info[] = {
+	{"CPU Q0",  ENUM_UMAC_CPU_PORT_1,     ENUM_UMAC_CTX_Q_0, 0},
+	{"CPU Q1",  ENUM_UMAC_CPU_PORT_1,     ENUM_UMAC_CTX_Q_1, 0},
+	{"CPU Q2",  ENUM_UMAC_CPU_PORT_1,     ENUM_UMAC_CTX_Q_2, 0},
+	{"CPU Q3",  ENUM_UMAC_CPU_PORT_1,     ENUM_UMAC_CTX_Q_3, 0},
+	{"ALTX Q0", ENUM_UMAC_LMAC_PORT_2,    0x10, 0},
+	{"BMC Q0",  ENUM_UMAC_LMAC_PORT_2,    0x11, 0},
+	{"BCN Q0",  ENUM_UMAC_LMAC_PORT_2,    0x12, 0},
+	{"PSMP Q0", ENUM_UMAC_LMAC_PORT_2,    0x13, 0},
+	{"ALTX Q1", ENUM_UMAC_LMAC_PORT_2,    0x10, 1},
+	{"BMC Q1",  ENUM_UMAC_LMAC_PORT_2,    0x11, 1},
+	{"BCN Q1",  ENUM_UMAC_LMAC_PORT_2,    0x12, 1},
+	{"PSMP Q1", ENUM_UMAC_LMAC_PORT_2,    0x13, 1},
+	{"ALTX Q2", ENUM_UMAC_LMAC_PORT_2,    0x10, 2},
+	{"BMC Q2",  ENUM_UMAC_LMAC_PORT_2,    0x11, 2},
+	{"BCN Q2",  ENUM_UMAC_LMAC_PORT_2,    0x12, 2},
+	{"PSMP Q2", ENUM_UMAC_LMAC_PORT_2,    0x13, 2},
+	{"NAF Q",   ENUM_UMAC_LMAC_PORT_2,    0x18, 0},
+	{"NBCN Q",  ENUM_UMAC_LMAC_PORT_2,    0x19, 0},
+	{NULL, 0, 0, 0}, {NULL, 0, 0, 0}, /* 18, 19 not defined */
+	{"FIXFID Q", ENUM_UMAC_LMAC_PORT_2, 0x1a, 0},
+	{NULL, 0, 0, 0}, {NULL, 0, 0, 0}, {NULL, 0, 0, 0}, {NULL, 0, 0, 0}, {NULL, 0, 0, 0},
+	{NULL, 0, 0, 0}, {NULL, 0, 0, 0},
+	{"RLS4 Q",   ENUM_PLE_CTRL_PSE_PORT_3, 0x7c, 0},
+	{"RLS3 Q",   ENUM_PLE_CTRL_PSE_PORT_3, 0x7d, 0},
+	{"RLS2 Q",   ENUM_PLE_CTRL_PSE_PORT_3, 0x7e, 0},
+	{"RLS Q",  ENUM_PLE_CTRL_PSE_PORT_3, 0x7f, 0}
+};
+
+static struct bmac_queue_info_t ple_txcmd_queue_empty_info[__MT_MAX_BAND][32] = {
+	{{"AC00Q", ENUM_UMAC_LMAC_PORT_2, 0x40},
+	 {"AC01Q", ENUM_UMAC_LMAC_PORT_2, 0x41},
+	 {"AC02Q", ENUM_UMAC_LMAC_PORT_2, 0x42},
+	 {"AC03Q", ENUM_UMAC_LMAC_PORT_2, 0x43},
+	 {"AC10Q", ENUM_UMAC_LMAC_PORT_2, 0x44},
+	 {"AC11Q", ENUM_UMAC_LMAC_PORT_2, 0x45},
+	 {"AC12Q", ENUM_UMAC_LMAC_PORT_2, 0x46},
+	 {"AC13Q", ENUM_UMAC_LMAC_PORT_2, 0x47},
+	 {"AC20Q", ENUM_UMAC_LMAC_PORT_2, 0x48},
+	 {"AC21Q", ENUM_UMAC_LMAC_PORT_2, 0x49},
+	 {"AC22Q", ENUM_UMAC_LMAC_PORT_2, 0x4a},
+	 {"AC23Q", ENUM_UMAC_LMAC_PORT_2, 0x4b},
+	 {"AC30Q", ENUM_UMAC_LMAC_PORT_2, 0x4c},
+	 {"AC31Q", ENUM_UMAC_LMAC_PORT_2, 0x4d},
+	 {"AC32Q", ENUM_UMAC_LMAC_PORT_2, 0x4e},
+	 {"AC33Q", ENUM_UMAC_LMAC_PORT_2, 0x4f},
+	 {"ALTX Q0", ENUM_UMAC_LMAC_PORT_2, 0x70},
+	 {"TF Q0", ENUM_UMAC_LMAC_PORT_2, 0x71},
+	 {"TWT TSF-TF Q0", ENUM_UMAC_LMAC_PORT_2, 0x72},
+	 {"TWT DL Q0", ENUM_UMAC_LMAC_PORT_2, 0x73},
+	 {"TWT UL Q0", ENUM_UMAC_LMAC_PORT_2, 0x74},
+	 {NULL, 0, 0}, {NULL, 0, 0}, {NULL, 0, 0}, {NULL, 0, 0},
+	 {NULL, 0, 0}, {NULL, 0, 0}, {NULL, 0, 0}, {NULL, 0, 0},
+	 {NULL, 0, 0}, {NULL, 0, 0}, {NULL, 0, 0}},
+
+	{{"AC00Q", ENUM_UMAC_LMAC_PORT_2, 0x50},
+	 {"AC01Q", ENUM_UMAC_LMAC_PORT_2, 0x51},
+	 {"AC02Q", ENUM_UMAC_LMAC_PORT_2, 0x52},
+	 {"AC03Q", ENUM_UMAC_LMAC_PORT_2, 0x53},
+	 {"AC10Q", ENUM_UMAC_LMAC_PORT_2, 0x54},
+	 {"AC11Q", ENUM_UMAC_LMAC_PORT_2, 0x55},
+	 {"AC12Q", ENUM_UMAC_LMAC_PORT_2, 0x56},
+	 {"AC13Q", ENUM_UMAC_LMAC_PORT_2, 0x57},
+	 {"AC20Q", ENUM_UMAC_LMAC_PORT_2, 0x58},
+	 {"AC21Q", ENUM_UMAC_LMAC_PORT_2, 0x59},
+	 {"AC22Q", ENUM_UMAC_LMAC_PORT_2, 0x5a},
+	 {"AC23Q", ENUM_UMAC_LMAC_PORT_2, 0x5b},
+	 {"AC30Q", ENUM_UMAC_LMAC_PORT_2, 0x5c},
+	 {"AC31Q", ENUM_UMAC_LMAC_PORT_2, 0x5d},
+	 {"AC32Q", ENUM_UMAC_LMAC_PORT_2, 0x5e},
+	 {"AC33Q", ENUM_UMAC_LMAC_PORT_2, 0x5f},
+	 {"ALTX Q0", ENUM_UMAC_LMAC_PORT_2, 0x75},
+	 {"TF Q0", ENUM_UMAC_LMAC_PORT_2, 0x76},
+	 {"TWT TSF-TF Q0", ENUM_UMAC_LMAC_PORT_2, 0x77},
+	 {"TWT DL Q0", ENUM_UMAC_LMAC_PORT_2, 0x78},
+	 {"TWT UL Q0", ENUM_UMAC_LMAC_PORT_2, 0x79},
+	 {NULL, 0, 0}, {NULL, 0, 0}, {NULL, 0, 0}, {NULL, 0, 0},
+	 {NULL, 0, 0}, {NULL, 0, 0}, {NULL, 0, 0}, {NULL, 0, 0},
+	 {NULL, 0, 0}, {NULL, 0, 0}, {NULL, 0, 0}},
+
+	{{"AC00Q", ENUM_UMAC_LMAC_PORT_2, 0x60},
+	 {"AC01Q", ENUM_UMAC_LMAC_PORT_2, 0x61},
+	 {"AC02Q", ENUM_UMAC_LMAC_PORT_2, 0x62},
+	 {"AC03Q", ENUM_UMAC_LMAC_PORT_2, 0x63},
+	 {"AC10Q", ENUM_UMAC_LMAC_PORT_2, 0x64},
+	 {"AC11Q", ENUM_UMAC_LMAC_PORT_2, 0x65},
+	 {"AC12Q", ENUM_UMAC_LMAC_PORT_2, 0x66},
+	 {"AC13Q", ENUM_UMAC_LMAC_PORT_2, 0x67},
+	 {"AC20Q", ENUM_UMAC_LMAC_PORT_2, 0x68},
+	 {"AC21Q", ENUM_UMAC_LMAC_PORT_2, 0x69},
+	 {"AC22Q", ENUM_UMAC_LMAC_PORT_2, 0x6a},
+	 {"AC23Q", ENUM_UMAC_LMAC_PORT_2, 0x6b},
+	 {"AC30Q", ENUM_UMAC_LMAC_PORT_2, 0x6c},
+	 {"AC31Q", ENUM_UMAC_LMAC_PORT_2, 0x6d},
+	 {"AC32Q", ENUM_UMAC_LMAC_PORT_2, 0x6e},
+	 {"AC33Q", ENUM_UMAC_LMAC_PORT_2, 0x6f},
+	 {"ALTX Q0", ENUM_UMAC_LMAC_PORT_2, 0x7a},
+	 {"TF Q0", ENUM_UMAC_LMAC_PORT_2, 0x7b},
+	 {"TWT TSF-TF Q0", ENUM_UMAC_LMAC_PORT_2, 0x7c},
+	 {"TWT DL Q0", ENUM_UMAC_LMAC_PORT_2, 0x7d},
+	 {"TWT UL Q0", ENUM_UMAC_LMAC_PORT_2, 0x7e},
+	 {NULL, 0, 0}, {NULL, 0, 0}, {NULL, 0, 0}, {NULL, 0, 0},
+	 {NULL, 0, 0}, {NULL, 0, 0}, {NULL, 0, 0}, {NULL, 0, 0},
+	 {NULL, 0, 0}, {NULL, 0, 0}, {NULL, 0, 0}}
+};
+
+static size_t
+ple_cr_num_of_ac(struct mt76_dev *dev)
+{
+	switch (mt76_chip(dev)) {
+	case 0x7990:
+		return CR_NUM_OF_AC_MT7996;
+	case 0x7992:
+	default:
+		return CR_NUM_OF_AC_MT7992;
+	}
+}
+
+static void
+mt7996_show_ple_pg_info(struct mt7996_dev *dev, struct seq_file *s)
+{
+	u32 val[2];
+
+	seq_printf(s, "PLE Configuration Info:\n");
+
+	val[0] = mt76_rr(dev, WF_PLE_TOP_PBUF_CTRL_ADDR);
+	seq_printf(s, "\tPacket Buffer Control: 0x%08x\n", val[0]);
+	seq_printf(s, "\t\tPage size: %u bytes\n",
+		   u32_get_bits(val[0], WF_PLE_TOP_PBUF_CTRL_PAGE_SIZE_CFG_MASK) ? 128 : 64);
+	seq_printf(s, "\t\tPacket buffer offset: %u (unit: 2KB)\n",
+		   u32_get_bits(val[0], WF_PLE_TOP_PBUF_CTRL_PBUF_OFFSET_MASK));
+	seq_printf(s, "\t\tTotal number of pages: %u pages\n",
+		   u32_get_bits(val[0], WF_PLE_TOP_PBUF_CTRL_TOTAL_PAGE_NUM_MASK));
+
+	seq_printf(s, "PLE Page Flow Control:\n");
+
+	val[0] = mt76_rr(dev, WF_PLE_TOP_FREEPG_CNT_ADDR);
+	val[1] = mt76_rr(dev, WF_PLE_TOP_FREEPG_HEAD_TAIL_ADDR);
+	seq_printf(s, "\tFree Page Counter: 0x%08x\n", val[0]);
+	seq_printf(s, "\tFree Page Head and Tail: 0x%08x\n", val[1]);
+	seq_printf(s, "\t\tNumber of free pages: 0x%04x\n",
+		   u32_get_bits(val[0], WF_PLE_TOP_FREEPG_CNT_FREEPG_CNT_MASK));
+	seq_printf(s, "\t\tNumber of unassigned pages: 0x%04x\n",
+		   u32_get_bits(val[0], WF_PLE_TOP_FREEPG_CNT_FFA_CNT_MASK));
+	seq_printf(s, "\t\tFID of tail/head free page: 0x%04x/0x%04x\n",
+		   u32_get_bits(val[1], WF_PLE_TOP_FREEPG_HEAD_TAIL_FREEPG_TAIL_MASK),
+		   u32_get_bits(val[1], WF_PLE_TOP_FREEPG_HEAD_TAIL_FREEPG_HEAD_MASK));
+
+	val[0] = mt76_rr(dev, WF_PLE_TOP_PG_HIF_GROUP_ADDR);
+	val[1] = mt76_rr(dev, WF_PLE_TOP_HIF_PG_INFO_ADDR);
+	seq_printf(s, "\tReserved Page Counter of HIF Group: 0x%08x\n", val[0]);
+	seq_printf(s, "\tHIF Group Page Status: 0x%08x\n", val[1]);
+	seq_printf(s, "\t\tMax/min page quota for HIF group: 0x%04x/0x%04x\n",
+		   u32_get_bits(val[0], WF_PLE_TOP_PG_HIF_GROUP_HIF_MAX_QUOTA_MASK),
+		   u32_get_bits(val[0], WF_PLE_TOP_PG_HIF_GROUP_HIF_MIN_QUOTA_MASK));
+	seq_printf(s, "\t\tUsed/free page count for HIF group: 0x%04x/0x%04x\n",
+		   u32_get_bits(val[1], WF_PLE_TOP_HIF_PG_INFO_HIF_SRC_CNT_MASK),
+		   u32_get_bits(val[1], WF_PLE_TOP_HIF_PG_INFO_HIF_RSV_CNT_MASK));
+
+	val[0] = mt76_rr(dev, WF_PLE_TOP_PG_HIF_WMTXD_GROUP_ADDR);
+	val[1] = mt76_rr(dev, WF_PLE_TOP_HIF_WMTXD_PG_INFO_ADDR);
+	seq_printf(s, "\tReserved Page Counter of HIF WMCPU TXD Group: 0x%08x\n", val[0]);
+	seq_printf(s, "\tHIF WMCPU TXD Group Page Status: 0x%08x\n", val[1]);
+	seq_printf(s, "\t\tMax/min page quota for HIF WMCPU TXD group: 0x%04x/0x%04x\n",
+		   u32_get_bits(val[0], WF_PLE_TOP_PG_HIF_WMTXD_GROUP_HIF_WMTXD_MAX_QUOTA_MASK),
+		   u32_get_bits(val[0], WF_PLE_TOP_PG_HIF_WMTXD_GROUP_HIF_WMTXD_MIN_QUOTA_MASK));
+	seq_printf(s, "\t\tUsed/free page count for HIF WMCPU TXD group: 0x%04x/0x%04x\n",
+		   u32_get_bits(val[1], WF_PLE_TOP_HIF_WMTXD_PG_INFO_HIF_WMTXD_SRC_CNT_MASK),
+		   u32_get_bits(val[1], WF_PLE_TOP_HIF_WMTXD_PG_INFO_HIF_WMTXD_RSV_CNT_MASK));
+
+	val[0] = mt76_rr(dev, WF_PLE_TOP_PG_HIF_TXCMD_GROUP_ADDR);
+	val[1] = mt76_rr(dev, WF_PLE_TOP_HIF_TXCMD_PG_INFO_ADDR);
+	seq_printf(s, "\tReserved Page Counter of HIF TXCMD Group: 0x%08x\n", val[0]);
+	seq_printf(s, "\tHIF TXCMD Group Page Status: 0x%08x\n", val[1]);
+	seq_printf(s, "\t\tMax/min page quota for HIF TXCMD group: 0x%04x/0x%04x\n",
+		   u32_get_bits(val[0], WF_PLE_TOP_PG_HIF_TXCMD_GROUP_HIF_TXCMD_MAX_QUOTA_MASK),
+		   u32_get_bits(val[0], WF_PLE_TOP_PG_HIF_TXCMD_GROUP_HIF_TXCMD_MIN_QUOTA_MASK));
+	seq_printf(s, "\t\tUsed/free page count for HIF TXCMD group: 0x%04x/0x%04x\n",
+		   u32_get_bits(val[1], WF_PLE_TOP_HIF_TXCMD_PG_INFO_HIF_TXCMD_SRC_CNT_MASK),
+		   u32_get_bits(val[1], WF_PLE_TOP_HIF_TXCMD_PG_INFO_HIF_TXCMD_RSV_CNT_MASK));
+
+	val[0] = mt76_rr(dev, WF_PLE_TOP_PG_CPU_GROUP_ADDR);
+	val[1] = mt76_rr(dev, WF_PLE_TOP_CPU_PG_INFO_ADDR);
+	seq_printf(s, "\tReserved Page Counter of CPU Group: 0x%08x\n", val[0]);
+	seq_printf(s, "\tCPU Group Page Status: 0x%08x\n", val[1]);
+	seq_printf(s, "\t\tMax/min page quota for CPU group: 0x%04x/0x%04x\n",
+		   u32_get_bits(val[0], WF_PLE_TOP_PG_CPU_GROUP_CPU_MAX_QUOTA_MASK),
+		   u32_get_bits(val[0], WF_PLE_TOP_PG_CPU_GROUP_CPU_MIN_QUOTA_MASK));
+	seq_printf(s, "\t\tUsed/free page count for CPU group: 0x%04x/0x%04x\n",
+		   u32_get_bits(val[1], WF_PLE_TOP_CPU_PG_INFO_CPU_SRC_CNT_MASK),
+		   u32_get_bits(val[1], WF_PLE_TOP_CPU_PG_INFO_CPU_RSV_CNT_MASK));
+}
+
+static void
+mt7996_get_ple_acq_stat(struct mt7996_dev *dev, unsigned long *ple_stat)
+{
+	u32 i, addr;
+	size_t cr_num_of_ac = ple_cr_num_of_ac(&dev->mt76);
+
+	ple_stat[0] = mt76_rr(dev, WF_PLE_TOP_QUEUE_EMPTY_ADDR);
+
+	/* Legacy */
+	addr = WF_PLE_TOP_AC0_QUEUE_EMPTY0_ADDR;
+	for (i = 1; i <= cr_num_of_ac; i++, addr += 4) {
+		if (i == cr_num_of_ac && is_mt7992(&dev->mt76))
+			ple_stat[i] = mt76_rr(dev, WF_PLE_TOP_AC0_QUEUE_EMPTY_EXT0_ADDR);
+		else
+			ple_stat[i] = mt76_rr(dev, addr);
+	}
+
+	addr = WF_PLE_TOP_AC1_QUEUE_EMPTY0_ADDR;
+	for (; i <= cr_num_of_ac * 2; i++, addr += 4) {
+		if (i == cr_num_of_ac * 2 && is_mt7992(&dev->mt76))
+			ple_stat[i] = mt76_rr(dev, WF_PLE_TOP_AC1_QUEUE_EMPTY_EXT0_ADDR);
+		else
+			ple_stat[i] = mt76_rr(dev, addr);
+	}
+
+	addr = WF_PLE_TOP_AC2_QUEUE_EMPTY0_ADDR;
+	for (; i <= cr_num_of_ac * 3; i++, addr += 4) {
+		if (i == cr_num_of_ac * 3 && is_mt7992(&dev->mt76))
+			ple_stat[i] = mt76_rr(dev, WF_PLE_TOP_AC2_QUEUE_EMPTY_EXT0_ADDR);
+		else
+			ple_stat[i] = mt76_rr(dev, addr);
+	}
+
+	addr = WF_PLE_TOP_AC3_QUEUE_EMPTY0_ADDR;
+	for (; i <= cr_num_of_ac * 4; i++, addr += 4) {
+		if (i == cr_num_of_ac * 4 && is_mt7992(&dev->mt76))
+			ple_stat[i] = mt76_rr(dev, WF_PLE_TOP_AC3_QUEUE_EMPTY_EXT0_ADDR);
+		else
+			ple_stat[i] = mt76_rr(dev, addr);
+	}
+}
+
+static void
+mt7996_get_sta_pause(struct mt7996_dev *dev, u8 band, u32 *sta_pause, u32 *twt_pause)
+{
+	u32 i, addr;
+	size_t cr_num_of_ac = ple_cr_num_of_ac(&dev->mt76);
+
+	/* switch to target band */
+	mt76_wr(dev, WF_DRR_TOP_SBRR_ADDR, u32_encode_bits(band, WF_DRR_TOP_SBRR_TARGET_BAND_MASK));
+
+	/* Legacy */
+	addr = WF_DRR_TOP_AC0_STATION_PAUSE00_ADDR;
+	for (i = 0; i < cr_num_of_ac; i++, addr += 4) {
+		if (i == cr_num_of_ac - 1 && is_mt7992(&dev->mt76))
+			sta_pause[i] = mt76_rr(dev, WF_DRR_TOP_AC0_STATION_PAUSE_EXT_00_ADDR);
+		else
+			sta_pause[i] = mt76_rr(dev, addr);
+	}
+
+	addr = WF_DRR_TOP_AC1_STATION_PAUSE00_ADDR;
+	for (; i < cr_num_of_ac * 2; i++, addr += 4) {
+		if (i == cr_num_of_ac * 2 - 1 && is_mt7992(&dev->mt76))
+			sta_pause[i] = mt76_rr(dev, WF_DRR_TOP_AC1_STATION_PAUSE_EXT_00_ADDR);
+		else
+			sta_pause[i] = mt76_rr(dev, addr);
+	}
+
+	addr = WF_DRR_TOP_AC2_STATION_PAUSE00_ADDR;
+	for (; i < cr_num_of_ac * 3; i++, addr += 4) {
+		if (i == cr_num_of_ac * 3 - 1 && is_mt7992(&dev->mt76))
+			sta_pause[i] = mt76_rr(dev, WF_DRR_TOP_AC2_STATION_PAUSE_EXT_00_ADDR);
+		else
+			sta_pause[i] = mt76_rr(dev, addr);
+	}
+
+	addr = WF_DRR_TOP_AC3_STATION_PAUSE00_ADDR;
+	for (; i < cr_num_of_ac * 4; i++, addr += 4) {
+		if (i == cr_num_of_ac * 4 - 1 && is_mt7992(&dev->mt76))
+			sta_pause[i] = mt76_rr(dev, WF_DRR_TOP_AC3_STATION_PAUSE_EXT_00_ADDR);
+		else
+			sta_pause[i] = mt76_rr(dev, addr);
+	}
+
+	/* TWT */
+	addr = WF_DRR_TOP_TWT_STA_MAP00_ADDR;
+	for (i = 0; i < cr_num_of_ac; i++, addr += 4) {
+		if (i == cr_num_of_ac - 1 && is_mt7992(&dev->mt76))
+			twt_pause[i] = mt76_rr(dev, WF_DRR_TOP_TWT_STA_MAP_EXT_00_ADDR);
+		else
+			twt_pause[i] = mt76_rr(dev, addr);
+	}
+}
+
+static void
+mt7996_get_ple_queue_info(struct mt7996_dev *dev, u32 pid, u32 qid, u32 tgid,
+			  u16 wlan_idx, u16 *hfid, u16 *tfid, u16 *pktcnt)
+{
+	u32 val = WF_PLE_TOP_FL_QUE_CTRL_0_EXECUTE_MASK |
+		  u32_encode_bits(pid, WF_PLE_TOP_FL_QUE_CTRL_0_Q_BUF_PID_MASK) |
+		  u32_encode_bits(tgid, WF_PLE_TOP_FL_QUE_CTRL_0_Q_BUF_TGID_MASK) |
+		  u32_encode_bits(qid, WF_PLE_TOP_FL_QUE_CTRL_0_Q_BUF_QID_MASK) |
+		  u32_encode_bits(wlan_idx, WF_PLE_TOP_FL_QUE_CTRL_0_Q_BUF_WLANID_MASK);
+	mt76_wr(dev, WF_PLE_TOP_FL_QUE_CTRL_0_ADDR, val);
+
+	val = mt76_rr(dev, WF_PLE_TOP_FL_QUE_CTRL_2_ADDR);
+	*hfid = u32_get_bits(val, WF_PLE_TOP_FL_QUE_CTRL_2_QUEUE_HEAD_FID_MASK);
+	*tfid = u32_get_bits(val, WF_PLE_TOP_FL_QUE_CTRL_2_QUEUE_TAIL_FID_MASK);
+
+	val = mt76_rr(dev, WF_PLE_TOP_FL_QUE_CTRL_3_ADDR);
+	*pktcnt = u32_get_bits(val, WF_PLE_TOP_FL_QUE_CTRL_3_QUEUE_PKT_NUM_MASK);
+}
+
+static void
+mt7996_show_sta_acq_info(struct seq_file *s, unsigned long *ple_stat,
+			 u32 *sta_pause, u32 *twt_sta_pause)
+{
+	struct mt7996_dev *dev = dev_get_drvdata(s->private);
+	size_t cr_num_of_ac = ple_cr_num_of_ac(&dev->mt76);
+	size_t cr_num_of_all_ac = cr_num_of_ac * IEEE80211_NUM_ACS;
+	int i, j;
+
+	for (j = 0; j < cr_num_of_all_ac; j++) { /* show AC Q info */
+		for (i = 0; i < 32; i++) {
+			if (!test_bit(i, &ple_stat[j + 1])) {
+				u16 hfid, tfid, pktcnt, wlan_idx = i + (j % cr_num_of_ac) * 32;
+				u8 wmmidx, ctrl = 0, acq_idx = j / cr_num_of_ac;
+				struct mt7996_link_sta *mlink;
+				struct mt76_wcid *wcid;
+				size_t idx;
+
+				if (wlan_idx >= MT76_N_WCIDS) {
+					seq_printf(s, "Error: WCID %hu exceeded threshold.\n", wlan_idx);
+					continue;
+				}
+				wcid = rcu_dereference(dev->mt76.wcid[wlan_idx]);
+				if (!wcid) {
+					seq_printf(s, "Error: STA %hu does not exist.\n", wlan_idx);
+					continue;
+				}
+				mlink = container_of(wcid, struct mt7996_link_sta, wcid);
+				wmmidx = mlink->sta->vif->deflink.mt76.wmm_idx;
+
+				seq_printf(s, "\tSTA%hu AC%hhu: ", wlan_idx, acq_idx);
+				mt7996_get_ple_queue_info(dev, ENUM_UMAC_LMAC_PORT_2, acq_idx,
+							  0, wlan_idx, &hfid, &tfid, &pktcnt);
+				seq_printf(s, "tail/head fid = 0x%04x/0x%04x, pkt cnt = 0x%04x",
+					   tfid, hfid, pktcnt);
+
+				idx = wcid->phy_idx * cr_num_of_all_ac + j;
+				if (sta_pause[idx] & BIT(i))
+					ctrl = 2;
+
+				idx = wcid->phy_idx * cr_num_of_ac + j % cr_num_of_ac;
+				if (twt_sta_pause[idx] & BIT(i))
+					ctrl = 3;
+
+				seq_printf(s, ", ctrl = %s (wmmidx=%hhu, band=%hhu)\n",
+					   sta_ctrl_reg[ctrl], wmmidx, wcid->phy_idx);
+			}
+		}
+	}
+}
+
+static void
+mt7996_show_txcmdq_info(struct seq_file *s)
+{
+	const u32 txcmd_queue_empty_addr[__MT_MAX_BAND][2] = {
+		[MT_BAND0] = {WF_PLE_TOP_TXCMD_QUEUE_EMPTY_ADDR,
+			      WF_PLE_TOP_NATIVE_TXCMD_QUEUE_EMPTY_ADDR},
+		[MT_BAND1] = {WF_PLE_TOP_BN1_TXCMD_QUEUE_EMPTY_ADDR,
+			      WF_PLE_TOP_BN1_NATIVE_TXCMD_QUEUE_EMPTY_ADDR},
+		[MT_BAND2] = {WF_PLE_TOP_BN2_TXCMD_QUEUE_EMPTY_ADDR,
+			      WF_PLE_TOP_BN2_NATIVE_TXCMD_QUEUE_EMPTY_ADDR}
+	};
+	struct mt7996_dev *dev = dev_get_drvdata(s->private);
+	u8 band;
+
+	for (band = MT_BAND0; band < __MT_MAX_BAND; ++band) {
+		unsigned long txcmdq_stat, native_txcmdq_stat;
+		int i;
+
+		if (!dev->mt76.phys[band])
+			continue;
+
+		txcmdq_stat = mt76_rr(dev, txcmd_queue_empty_addr[band][0]);
+		native_txcmdq_stat = mt76_rr(dev, txcmd_queue_empty_addr[band][1]);
+
+		seq_printf(s, "Band%hhu Non-native/native TXCMD Queue Empty: 0x%08lx/0x%08lx\n",
+			   band, txcmdq_stat, native_txcmdq_stat);
+
+		for (i = 0; i < 32 ; i++) {
+			if (!test_bit(i, &native_txcmdq_stat)) {
+				struct bmac_queue_info_t *queue = &ple_txcmd_queue_empty_info[band][i];
+				u16 hfid, tfid, pktcnt;
+
+				if (!queue->QueueName)
+					continue;
+
+				seq_printf(s, "\t%s: ", queue->QueueName);
+				mt7996_get_ple_queue_info(dev, queue->Portid, queue->Queueid,
+							  0, 0, &hfid, &tfid, &pktcnt);
+				seq_printf(s, "tail/head fid = 0x%04x/0x%04x, pkt cnt = 0x%04x\n",
+					   tfid, hfid, pktcnt);
+			}
+		}
+	}
+}
+
+static int
+mt7996_pleinfo_read(struct seq_file *s, void *data)
+{
+	struct mt7996_dev *dev = dev_get_drvdata(s->private);
+	size_t cr_num_of_ac = ple_cr_num_of_ac(&dev->mt76);
+	size_t cr_num_of_all_ac = cr_num_of_ac * IEEE80211_NUM_ACS;
+	u32 *sta_pause, *twt_sta_pause;
+	unsigned long *ple_stat;
+	int i, j, ret = 0;
+
+	ple_stat = kzalloc((cr_num_of_all_ac + 1) * sizeof(unsigned long), GFP_KERNEL);
+	if (!ple_stat)
+		return -ENOMEM;
+
+	sta_pause = kzalloc(__MT_MAX_BAND * cr_num_of_all_ac * sizeof(u32), GFP_KERNEL);
+	if (!sta_pause) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	twt_sta_pause = kzalloc(__MT_MAX_BAND * cr_num_of_ac * sizeof(u32), GFP_KERNEL);
+	if (!twt_sta_pause) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	mt7996_show_ple_pg_info(dev, s);
+	mt7996_get_ple_acq_stat(dev, ple_stat);
+
+	for (i = MT_BAND0; i < __MT_MAX_BAND; i++) {
+		if (dev->mt76.phys[i])
+			mt7996_get_sta_pause(dev, i,
+					     sta_pause + i * cr_num_of_all_ac,
+					     twt_sta_pause + i * cr_num_of_ac);
+	}
+
+	if ((ple_stat[0] & WF_PLE_TOP_QUEUE_EMPTY_ALL_AC_EMPTY_MASK) == 0) {
+		for (j = 0; j < cr_num_of_all_ac; j++) {
+			if (j % cr_num_of_ac == 0)
+				seq_printf(s, "\n\tSTA in nonempty AC%ld TXD queue: ", j / cr_num_of_ac);
+
+			for (i = 0; i < 32; i++) {
+				if (!test_bit(i, &ple_stat[j + 1]))
+					seq_printf(s, "%lu ", i + (j % cr_num_of_ac) * 32);
+			}
+		}
+		seq_printf(s, "\n");
+	}
+
+	seq_printf(s, "Nonempty TXD Queue Info:\n");
+
+	for (i = 0; i < 32; i++) {
+		if (!test_bit(i, &ple_stat[0])) {
+			struct bmac_queue_info *queue = &ple_queue_empty_info[i];
+			u16 hfid, tfid, pktcnt;
+
+			if (!queue->QueueName)
+				continue;
+
+			seq_printf(s, "\t%s: ", queue->QueueName);
+			mt7996_get_ple_queue_info(dev, queue->Portid, queue->Queueid,
+						  queue->tgid, 0, &hfid, &tfid, &pktcnt);
+			seq_printf(s, "tail/head fid = 0x%04x/0x%04x, pkt cnt = 0x%04x\n",
+				   tfid, hfid, pktcnt);
+		}
+	}
+
+	mt7996_show_sta_acq_info(s, ple_stat, sta_pause, twt_sta_pause);
+	mt7996_show_txcmdq_info(s);
+
+	kfree(twt_sta_pause);
+out:
+	kfree(sta_pause);
+	kfree(ple_stat);
+	return ret;
+}
+
+static int
+mt7996_tx_drop_show(struct seq_file *s, void *data)
+{
+	struct mt7996_dev *dev = s->private;
+	struct mt76_dev *mdev = &dev->mt76;
+	struct mt76_tx_debug *dev_stats = &mdev->tx_dbg_stats;
+	struct mt76_tx_debug *phy_stats[__MT_MAX_BAND];
+	int i = 0;
+
+	seq_printf(s, "\t\t\t\t       dev");
+	for (i = 0; i < __MT_MAX_BAND; i++) {
+		seq_printf(s, "       Band%d", i);
+		if (mdev->phys[i]) {
+			phy_stats[i] = &mdev->phys[i]->tx_dbg_stats;
+		} else {
+			phy_stats[i] = kzalloc(sizeof(struct mt76_tx_debug),
+					       GFP_KERNEL);
+			if (!phy_stats[i])
+				goto out;
+		}
+
+	}
+	seq_printf(s, "       total\n");
+
+	seq_printf(s, "%-30s%12d%12d%12d%12d%12d\n", "Receive from mac80211",
+		       dev_stats->tx_from_mac80211,
+		       phy_stats[0]->tx_from_mac80211,
+		       phy_stats[1]->tx_from_mac80211,
+		       phy_stats[2]->tx_from_mac80211,
+		       dev_stats->tx_from_mac80211 +
+		       phy_stats[0]->tx_from_mac80211 +
+		       phy_stats[1]->tx_from_mac80211 +
+		       phy_stats[2]->tx_from_mac80211);
+	seq_printf(s, "%-30s%12d%12d%12d%12d%12d\n\n", "Send to hw",
+		       dev_stats->tx_to_hw,
+		       phy_stats[0]->tx_to_hw,
+		       phy_stats[1]->tx_to_hw,
+		       phy_stats[2]->tx_to_hw,
+		       dev_stats->tx_to_hw +
+		       phy_stats[0]->tx_to_hw +
+		       phy_stats[1]->tx_to_hw +
+		       phy_stats[2]->tx_to_hw);
+#define __pr(t) seq_printf(s, "Drop due to %-18s%12d%12d%12d%12d%12d\n",\
+			   #t, dev_stats->tx_drop[MT_TX_DROP_##t],	\
+			   phy_stats[0]->tx_drop[MT_TX_DROP_##t],	\
+			   phy_stats[1]->tx_drop[MT_TX_DROP_##t],	\
+			   phy_stats[2]->tx_drop[MT_TX_DROP_##t],	\
+			   dev_stats->tx_drop[MT_TX_DROP_##t] +		\
+			   phy_stats[0]->tx_drop[MT_TX_DROP_##t] + 	\
+			   phy_stats[1]->tx_drop[MT_TX_DROP_##t] +	\
+			   phy_stats[2]->tx_drop[MT_TX_DROP_##t])
+
+	__pr(IN_TESTMODE);
+	__pr(WCID_NOT_INIT);
+	__pr(STOPPED_QUEUE);
+	__pr(RESET_STATE);
+	__pr(GET_TXWI_FAIL);
+	__pr(DMA_FAIL);
+	__pr(AGG_EXCEEDED);
+	__pr(RING_FULL);
+	__pr(INVALID_SKB);
+	__pr(GET_TOKEN_FAIL);
+	__pr(ADDR_TRANS_FAIL);
+	__pr(INVALID_WCID);
+	__pr(INVALID_LINK);
+
+#undef __pr
+out:
+	for (i = 0; i < __MT_MAX_BAND; i++) {
+		if (!mdev->phys[i] && phy_stats[i])
+			kfree(phy_stats[i]);
+	}
+
+	return 0;
+}
+DEFINE_SHOW_ATTRIBUTE(mt7996_tx_drop);
+
+static int
+mt7996_rx_drop_show(struct seq_file *s, void *data)
+{
+	struct mt7996_dev *dev = s->private;
+	struct mt76_dev *mdev = &dev->mt76;
+	struct mt76_rx_debug *stats[__MT_MAX_BAND];
+	struct mt76_queue *q[2];
+	int i = 0;
+
+	q[0] = &mdev->q_rx[MT_RXQ_MAIN];
+	q[1] = is_mt7996(mdev) ? &mdev->q_rx[MT_RXQ_BAND2] :
+				 &mdev->q_rx[MT_RXQ_BAND1];
+
+	seq_printf(s, "\t\t\t\t   ");
+	for (i = 0; i < 2; i++) {
+		seq_printf(s, "        RXQ%d", q[i]->hw_idx);
+	}
+	seq_printf(s, "\n");
+
+#define __pr(t) seq_printf(s, "Drop due to %-22s%12d%12d\n", #t, \
+			   q[0]->rx_drop[MT_RX_DROP_##t],	\
+			   q[1]->rx_drop[MT_RX_DROP_##t]);
+	__pr(DMAD_RRO_REPEAT);
+	__pr(DMAD_RRO_OLDPKT);
+	__pr(DMAD_RRO_PN_CHK_FAIL);
+	__pr(DMAD_WO_FRAG);
+	__pr(DMAD_WO_DROP);
+	__pr(DMAD_ADDR_NOT_FOUND);
+	__pr(DMAD_TOKEN_NOT_FOUND);
+	__pr(DMAD_GET_TOKEN_FAIL);
+	__pr(DMAD_GET_RXWI_FAIL);
+	__pr(DMAD_NOMEM);
+	__pr(DMAD_DMA_MAPPING_FAIL);
+	__pr(FRAG);
+	__pr(BUILD_SKB_FAIL);
+#undef __pr
+
+	seq_printf(s, "\n\t\t\t\t   ");
+	for (i = 0; i < __MT_MAX_BAND; i++) {
+		seq_printf(s, "       Band%d", i);
+		if (mdev->phys[i]) {
+			stats[i] = &mdev->phys[i]->rx_dbg_stats;
+		} else {
+			stats[i] = kzalloc(sizeof(struct mt76_rx_debug),
+					       GFP_KERNEL);
+			if (!stats[i])
+				goto out;
+		}
+	}
+	seq_printf(s, "\n");
+	seq_printf(s, "%-35s%12d%12d%12d\n", "Receive from hw",
+		       stats[MT_BAND0]->rx_from_hw,
+		       stats[MT_BAND1]->rx_from_hw,
+		       stats[MT_BAND2]->rx_from_hw);
+	seq_printf(s, "%-35s%12d%12d%12d\n\n", "Send to mac80211",
+		       stats[MT_BAND0]->rx_to_mac80211,
+		       stats[MT_BAND1]->rx_to_mac80211,
+		       stats[MT_BAND2]->rx_to_mac80211);
+#define __pr(t) seq_printf(s, "Drop due to %-22s%12d%12d%12d\n", #t, \
+			   stats[MT_BAND0]->rx_drop[MT_RX_DROP_##t],	\
+			   stats[MT_BAND1]->rx_drop[MT_RX_DROP_##t],	\
+			   stats[MT_BAND2]->rx_drop[MT_RX_DROP_##t])
+	__pr(RXD_ERR);
+	__pr(STATE_ERR);
+	__pr(RFC_PKT);
+	__pr(AGG_SN_LESS);
+	__pr(AGG_DUP);
+#undef __pr
+
+out:
+	for (i = 0; i < __MT_MAX_BAND; i++) {
+		if (!mdev->phys[i] && stats[i])
+			kfree(stats[i]);
+	}
+
+	return 0;
+}
+DEFINE_SHOW_ATTRIBUTE(mt7996_rx_drop);
+/* DRR */
+static int
+mt7996_drr_info(struct seq_file *s, void *data)
+{
+	/* TODO: Wait MIB counter API implement complete */
+	return 0;
+}
+
+static ssize_t mt7996_muru_dbg_info_set(struct file *file,
+					const char __user *user_buf,
+					size_t count, loff_t *ppos)
+{
+	struct mt7996_dev *dev = file->private_data;
+	char buf[10];
+	u16 item;
+	u8 val;
+	int ret;
+
+	if (count >= sizeof(buf))
+		return -EINVAL;
+
+	if (copy_from_user(buf, user_buf, count))
+		return -EFAULT;
+
+	if (count && buf[count - 1] == '\n')
+		buf[count - 1] = '\0';
+	else
+		buf[count] = '\0';
+
+	if (sscanf(buf, "%hu-%hhu", &item, &val) != 2) {
+		dev_warn(dev->mt76.dev,"format: item-value\n");
+		return -EINVAL;
+	}
+
+	ret = mt7996_mcu_muru_dbg_info(dev, item, val);
+	if (ret) {
+		dev_warn(dev->mt76.dev, "Fail to send mcu cmd.\n");
+		return -EFAULT;
+	}
+
+	return count;
+}
+
+static const struct file_operations fops_muru_dbg_info = {
+	.write = mt7996_muru_dbg_info_set,
+	.open = simple_open,
+	.owner = THIS_MODULE,
+	.llseek = default_llseek,
+};
+
+void mt7996_mtk_init_band_debugfs(struct mt7996_phy *phy, struct dentry *dir)
+{
+	/* agg */
+	debugfs_create_file("agginfo", 0400, dir, phy, &mt7996_agginfo_fops);
+	debugfs_create_file("mibinfo", 0400, dir, phy, &mt7996_mibinfo_fops);
+	debugfs_create_file("txpower_level", 0600, dir, phy, &fops_txpower_level);
+	debugfs_create_file("txpower_info", 0600, dir, phy, &mt7996_txpower_info_fops);
+	debugfs_create_file("txpower_sku", 0600, dir, phy, &mt7996_txpower_sku_fops);
+	debugfs_create_file("txpower_path", 0600, dir, phy, &mt7996_txpower_path_fops);
+
+	debugfs_create_file("sr_enable", 0600, dir, phy, &fops_sr_enable);
+	debugfs_create_file("sr_enhanced_enable", 0600, dir, phy, &fops_sr_enhanced_enable);
+	debugfs_create_file("sr_stats", 0400, dir, phy, &mt7996_sr_stats_fops);
+	debugfs_create_file("sr_scene_cond", 0400, dir, phy, &mt7996_sr_scene_cond_fops);
+
+	debugfs_create_file("bf_txsnd_info", 0600, dir, phy, &fops_bf_txsnd_info);
+	debugfs_create_file("bf_starec_read", 0600, dir, phy, &fops_starec_bf_read);
+	debugfs_create_file("bf_fbk_rpt", 0600, dir, phy, &fops_bf_fbk_rpt);
+	debugfs_create_file("pfmu_tag_read", 0600, dir, phy, &fops_bf_pfmu_tag_read);
+
+	debugfs_create_file("thermal_enable", 0600, dir, phy, &fops_thermal_enable);
+	debugfs_create_file("scs_enable", 0200, dir, phy, &fops_scs_enable);
+}
+
+void mt7996_mtk_init_dev_debugfs(struct mt7996_dev *dev, struct dentry *dir)
+{
+	u32 device_id = (dev->mt76.rev) >> 16;
+	int i = 0;
+	static const struct mt7996_dbg_reg_desc dbg_reg_s[] = {
+		{ 0x7990, mt7996_dbg_offs },
+		{ 0x7992, mt7992_dbg_offs },
+	};
+
+	for (i = 0; i < ARRAY_SIZE(dbg_reg_s); i++) {
+		if (device_id == dbg_reg_s[i].id) {
+			dev->dbg_reg = &dbg_reg_s[i];
+			break;
+		}
+	}
+
+	if (is_mt7996(&dev->mt76)) {
+		WTBL_LMAC_DW2 = WTBL_LMAC_DW2_7996;
+		WTBL_LMAC_DW5 = WTBL_LMAC_DW5_7996;
+		WTBL_LMAC_DW9 = WTBL_LMAC_DW9_7996;
+	} else {
+		WTBL_LMAC_DW2 = WTBL_LMAC_DW2_7992;
+		WTBL_LMAC_DW5 = WTBL_LMAC_DW5_7992;
+		WTBL_LMAC_DW9 = WTBL_LMAC_DW9_7992;
+	}
+
+	/* amsdu */
+	debugfs_create_devm_seqfile(dev->mt76.dev, "amsdu_info", dir,
+				    mt7996_amsdu_result_read);
+
+	debugfs_create_file("fw_debug_module", 0600, dir, dev,
+			    &fops_fw_debug_module);
+	debugfs_create_file("fw_debug_level", 0600, dir, dev,
+			    &fops_fw_debug_level);
+	debugfs_create_file("fw_wa_query", 0600, dir, dev, &fops_wa_query);
+	debugfs_create_file("fw_wa_set", 0600, dir, dev, &fops_wa_set);
+	debugfs_create_devm_seqfile(dev->mt76.dev, "fw_version", dir,
+				    mt7996_dump_version);
+	debugfs_create_devm_seqfile(dev->mt76.dev, "fw_wa_info", dir,
+				    mt7996_fw_wa_info_read);
+	debugfs_create_devm_seqfile(dev->mt76.dev, "fw_wm_info", dir,
+				    mt7996_fw_wm_info_read);
+
+	debugfs_create_devm_seqfile(dev->mt76.dev, "sta_info", dir,
+				    mt7996_sta_info);
+
+	debugfs_create_devm_seqfile(dev->mt76.dev, "tr_info", dir,
+				    mt7996_trinfo_read);
+
+	debugfs_create_devm_seqfile(dev->mt76.dev, "eeprom_mode", dir,
+				    mt7996_show_eeprom_mode);
+
+	debugfs_create_devm_seqfile(dev->mt76.dev, "wtbl_info", dir,
+				    mt7996_wtbl_read);
+
+	debugfs_create_devm_seqfile(dev->mt76.dev, "token", dir, mt7996_token_read);
+	debugfs_create_file("red", 0200, dir, dev, &fops_red_config);
+	debugfs_create_file("vow_drr_dbg", 0200, dir, dev, &fops_vow_drr_dbg);
+
+	dev->dbg.sku_disable = true; /* For SQC */
+	debugfs_create_u8("sku_disable", 0600, dir, &dev->dbg.sku_disable);
+
+	debugfs_create_file("muru_prot_thr", 0200, dir, dev, &fops_muru_prot_thr);
+	debugfs_create_file("muru_fixed_rate_enable", 0600, dir, dev,
+			    &fops_muru_fixed_rate_enable);
+	debugfs_create_file("muru_fixed_group_rate", 0600, dir, dev,
+			    &fops_muru_fixed_group_rate);
+
+	if (dev->has_rro) {
+		debugfs_create_u32("rro_sid", 0600, dir, &dev->dbg.sid);
+		debugfs_create_devm_seqfile(dev->mt76.dev, "rro_sid_info", dir,
+					    mt7996_rro_session_read);
+		debugfs_create_devm_seqfile(dev->mt76.dev, "rro_mib", dir,
+					    mt7996_show_rro_mib);
+	}
+
+	debugfs_create_file("thermal_recal", 0200, dir, dev, &fops_thermal_recal);
+	debugfs_create_file("reset_counter", 0200, dir, dev, &fops_reset_counter);
+
+	debugfs_create_devm_seqfile(dev->mt76.dev, "drr_info", dir,
+				    mt7996_drr_info);
+
+	debugfs_create_u32("token_idx", 0600, dir, &dev->dbg.token_idx);
+	debugfs_create_devm_seqfile(dev->mt76.dev, "rx_token", dir,
+				    mt7996_rx_token_read);
+
+	debugfs_create_devm_seqfile(dev->mt76.dev, "ple_info", dir,
+				    mt7996_pleinfo_read);
+	debugfs_create_devm_seqfile(dev->mt76.dev, "pse_info", dir,
+				    mt7996_pseinfo_read);
+	/* amsdu */
+	debugfs_create_file("amsdu_algo", 0600, dir, dev, &fops_amsdu_algo);
+	debugfs_create_file("amsdu_para", 0600, dir, dev, &fops_amsdu_para);
+
+	/* Drop counters */
+	debugfs_create_file("tx_drop_stats", 0400, dir, dev, &mt7996_tx_drop_fops);
+	debugfs_create_file("rx_drop_stats", 0400, dir, dev, &mt7996_rx_drop_fops);
+
+	debugfs_create_file("muru_dbg", 0200, dir, dev, &fops_muru_dbg_info);
+}
+
+#endif
diff --git a/mt7996/mtk_debugfs_i.c b/mt7996/mtk_debugfs_i.c
new file mode 100644
index 00000000..c9224eee
--- /dev/null
+++ b/mt7996/mtk_debugfs_i.c
@@ -0,0 +1,1017 @@
+#include <linux/inet.h>
+#include "mt7996.h"
+#include "../mt76.h"
+#include "mcu.h"
+#include "mac.h"
+#include "eeprom.h"
+#include "mtk_debug.h"
+#include "mtk_debug_i.h"
+#include "mtk_mcu.h"
+
+#ifdef CONFIG_MTK_DEBUG
+
+#define info_or_seq_printf(seq, fmt, ...)	do {	\
+	if (seq)					\
+		seq_printf(seq, fmt, ##__VA_ARGS__);	\
+	else						\
+		pr_info(fmt, ##__VA_ARGS__);		\
+} while (0)
+
+static void info_or_seq_hex_dump(struct seq_file *seq, int prefix_type,
+				 int rowsize, int groupsize, const void *buf,
+				 size_t len, bool ascii)
+{
+	if (seq)
+		seq_hex_dump(seq, "", prefix_type, rowsize, groupsize,
+			     buf, len, ascii);
+	else
+		print_hex_dump(KERN_INFO, "", prefix_type,
+			       rowsize, groupsize, buf, len, ascii);
+}
+
+//bmac dump mac txp
+static void mt7996_dump_bmac_mac_txp_info(struct seq_file *s, struct mt7996_dev *dev,
+					  __le32 *txp)
+{
+	struct mt7996_txp_token {
+		__le16 msdu[4];
+	} *msdu;
+	struct mt7996_txp_ptr {
+		__le32 addr1;
+		__le32 addr_info;
+		__le32 addr2;
+	} *ptr;
+	int i = 0;
+
+	for (i = 0; i < 12; i = i+2 ) {
+		if (i == 0 || i == 4) {
+			msdu = (struct mt7996_txp_token *) txp;
+			info_or_seq_printf(s, "msdu token(%d-%d)=%ld %ld %ld %ld (0x%08x-0x%08x)\n", i, i+3,
+				(msdu->msdu[0] & GENMASK(14, 0)),
+				(msdu->msdu[1] & GENMASK(14, 0)),
+				(msdu->msdu[2] & GENMASK(14, 0)),
+				(msdu->msdu[3] & GENMASK(14, 0)), *txp, *(txp+1));
+			txp = txp + 2;
+		}
+		ptr = (struct mt7996_txp_ptr *) txp;
+		info_or_seq_printf(s, "ptr%02d : addr(0x%08x) len(%ld) addr_h(%02lx) SRC(%d) ML(%d) \n",
+			i, ptr->addr1,
+			FIELD_GET(GENMASK(11, 0), ptr->addr_info),
+			FIELD_GET(GENMASK(13, 12), ptr->addr_info),
+			!!(ptr->addr_info & BIT(14)),
+			!!(ptr->addr_info & BIT(15)));
+		info_or_seq_printf(s, "ptr%02d : addr(0x%08x) len(%ld) addr_h(%02lx) SRC(%d) ML(%d) \n",
+			i+1, ptr->addr2,
+			FIELD_GET(GENMASK(27, 16), ptr->addr_info),
+			FIELD_GET(GENMASK(29, 28), ptr->addr_info),
+			!!(ptr->addr_info & BIT(30)),
+			!!(ptr->addr_info & BIT(31)));
+		txp = txp + 3;
+	}
+}
+
+//bmac dump hif txp
+void mt7996_dump_bmac_hif_txp_info(struct seq_file *s, struct mt7996_dev *dev,
+				   __le32 *txp, u32 hif_txp_ver)
+{
+	int i, j = 0;
+	u32 dw;
+
+	info_or_seq_printf(s, "txp raw data: size=%d\n", HIF_TXP_V2_SIZE);
+	info_or_seq_hex_dump(s, DUMP_PREFIX_OFFSET, 16, 1, (u8 *)txp, HIF_TXP_V2_SIZE, false);
+
+	info_or_seq_printf(s, "BMAC_TXP Fields:\n");
+
+	/* dw0 */
+	if (hif_txp_ver == 2) {
+		dw = le32_to_cpu(txp[0]);
+		info_or_seq_printf(s, "HIF_TXP_PRIORITY = %d\n",
+				GET_FIELD(HIF_TXP_PRIORITY, dw));
+		info_or_seq_printf(s, "HIF_TXP_FIXED_RATE = %d\n",
+				GET_FIELD(HIF_TXP_FIXED_RATE, dw));
+		info_or_seq_printf(s, "HIF_TXP_TCP = %d\n",
+				GET_FIELD(HIF_TXP_TCP, dw));
+		info_or_seq_printf(s, "HIF_TXP_NON_CIPHER = %d\n",
+				GET_FIELD(HIF_TXP_NON_CIPHER, dw));
+		info_or_seq_printf(s, "HIF_TXP_VLAN = %d\n",
+				GET_FIELD(HIF_TXP_VLAN, dw));
+		info_or_seq_printf(s, "HIF_TXP_BC_MC_FLAG = %d\n",
+				GET_FIELD(HIF_TXP_BC_MC_FLAG, dw));
+		info_or_seq_printf(s, "HIF_TXP_FR_HOST = %d\n",
+				GET_FIELD(HIF_TXP_FR_HOST, dw));
+		info_or_seq_printf(s, "HIF_TXP_ETYPE = %d\n",
+				GET_FIELD(HIF_TXP_ETYPE, dw));
+		info_or_seq_printf(s, "HIF_TXP_TXP_AMSDU = %d\n",
+				GET_FIELD(HIF_TXP_TXP_AMSDU, dw));
+		info_or_seq_printf(s, "HIF_TXP_TXP_MC_CLONE = %d\n",
+				GET_FIELD(HIF_TXP_TXP_MC_CLONE, dw));
+		info_or_seq_printf(s, "HIF_TXP_TOKEN_ID = %d\n",
+				GET_FIELD(HIF_TXP_TOKEN_ID, dw));
+
+		/* dw1 */
+		dw = le32_to_cpu(txp[1]);
+		info_or_seq_printf(s, "HIF_TXP_BSS_IDX = %d\n",
+				GET_FIELD(HIF_TXP_BSS_IDX, dw));
+		info_or_seq_printf(s, "HIF_TXP_USER_PRIORITY = %d\n",
+				GET_FIELD(HIF_TXP_USER_PRIORITY, dw));
+		info_or_seq_printf(s, "HIF_TXP_BUF_NUM = %d\n",
+				GET_FIELD(HIF_TXP_BUF_NUM, dw));
+		info_or_seq_printf(s, "HIF_TXP_MSDU_CNT = %d\n",
+				GET_FIELD(HIF_TXP_MSDU_CNT, dw));
+		info_or_seq_printf(s, "HIF_TXP_SRC = %d\n",
+				GET_FIELD(HIF_TXP_SRC, dw));
+
+		/* dw2 */
+		dw = le32_to_cpu(txp[2]);
+		info_or_seq_printf(s, "HIF_TXP_ETH_TYPE(network-endian) = 0x%x\n",
+				GET_FIELD(HIF_TXP_ETH_TYPE, dw));
+		info_or_seq_printf(s, "HIF_TXP_WLAN_IDX = %d\n",
+				GET_FIELD(HIF_TXP_WLAN_IDX, dw));
+
+		/* dw3 */
+		dw = le32_to_cpu(txp[3]);
+		info_or_seq_printf(s, "HIF_TXP_PPE_INFO = 0x%x\n",
+				GET_FIELD(HIF_TXP_PPE_INFO, dw));
+
+		for (i = 0; i < 13; i++) {
+			if (i % 2 == 0) {
+				info_or_seq_printf(s, "HIF_TXP_BUF_PTR%d_L = 0x%x\n",
+						i, GET_FIELD(HIF_TXP_BUF_PTR0_L,
+						le32_to_cpu(txp[4 + j])));
+				j++;
+				info_or_seq_printf(s, "HIF_TXP_BUF_LEN%d = %d\n",
+						i, GET_FIELD(HIF_TXP_BUF_LEN0, le32_to_cpu(txp[4 + j])));
+				info_or_seq_printf(s, "HIF_TXP_BUF_PTR%d_H = 0x%x\n",
+						i, GET_FIELD(HIF_TXP_BUF_PTR0_H, le32_to_cpu(txp[4 + j])));
+				if (i <= 10) {
+					info_or_seq_printf(s, "HIF_TXP_BUF_LEN%d = %d\n",
+							i + 1, GET_FIELD(HIF_TXP_BUF_LEN1, le32_to_cpu(txp[4 + j])));
+					info_or_seq_printf(s, "HIF_TXP_BUF_PTR%d_H = 0x%x\n",
+							i + 1, GET_FIELD(HIF_TXP_BUF_PTR1_H, le32_to_cpu(txp[4 + j])));
+				}
+				j++;
+			} else {
+				info_or_seq_printf(s, "HIF_TXP_BUF_PTR%d_L = 0x%x\n",
+					i, GET_FIELD(HIF_TXP_BUF_PTR1_L,
+					le32_to_cpu(txp[4 + j])));
+				j++;
+			}
+		}
+
+		info_or_seq_printf(s, "ml = 0x%x\n",
+			GET_FIELD(HIF_TXP_ML, le32_to_cpu(txp[23])));
+	} else {
+		struct mt76_connac_txp_common *txp_v1 = (struct mt76_connac_txp_common *)txp;
+
+		info_or_seq_printf(s, "FLAGS = (%04x)\n", txp_v1->fw.flags);
+
+		info_or_seq_printf(s, "MSDU = %d\n", txp_v1->fw.token);
+
+		info_or_seq_printf(s, "BSS_IDX = %d\n", txp_v1->fw.bss_idx);
+
+		info_or_seq_printf(s, "WCID = %d\n",txp_v1->fw.rept_wds_wcid);
+
+		info_or_seq_printf(s, "MSDU_CNT = %d\n", txp_v1->fw.nbuf);
+
+		for (i = 0; i < MT_TXP_MAX_BUF_NUM; i++)
+			info_or_seq_printf(s, "ptr%02d : addr(0x%08x) len(%d)\n", i, le32_to_cpu(txp_v1->fw.buf[i]),
+				le16_to_cpu(txp_v1->fw.len[i]));
+	}
+}
+
+/* bmac txd dump */
+void mt7996_dump_bmac_txd_info(struct seq_file *s, struct mt7996_dev *dev,
+			       __le32 *txd, bool is_hif_txd, bool dump_txp)
+{
+	u32 hif_txp_ver = 0;
+
+	/* dump stop */
+	if (!dev->dbg.txd_read_cnt)
+		return;
+
+	/* force dump */
+	if (dev->dbg.txd_read_cnt > 8)
+		dev->dbg.txd_read_cnt = 8;
+
+	/* dump txd_read_cnt times */
+	if (dev->dbg.txd_read_cnt != 8)
+		dev->dbg.txd_read_cnt--;
+
+	info_or_seq_printf(s, "txd raw data: size=%d\n", MT_TXD_SIZE);
+	info_or_seq_hex_dump(s, DUMP_PREFIX_OFFSET, 16, 1, (u8 *)txd, MT_TXD_SIZE, false);
+
+	info_or_seq_printf(s, "BMAC_TXD Fields:\n");
+	/* dw0 */
+	if (is_hif_txd) {
+		hif_txp_ver = FIELD_GET(GENMASK(22, 19), txd[0]);
+		info_or_seq_printf(s, "HIF TXD VER = %d\n", hif_txp_ver);
+	}
+	info_or_seq_printf(s, "TX_BYTE_COUNT = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_TX_BYTE_COUNT, txd[0]));
+	info_or_seq_printf(s, "ETHER_TYPE_OFFSET(word) = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_ETHER_TYPE_OFFSET, txd[0]));
+	info_or_seq_printf(s, "PKT_FT = %d%s%s%s%s\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_PKT_FT, txd[0]),
+			GET_FIELD(WF_TX_DESCRIPTOR_PKT_FT, txd[0]) == 0 ? "(ct)" : "",
+			GET_FIELD(WF_TX_DESCRIPTOR_PKT_FT, txd[0]) == 1 ? "(s&f)" : "",
+			GET_FIELD(WF_TX_DESCRIPTOR_PKT_FT, txd[0]) == 2 ? "(cmd)" : "",
+			GET_FIELD(WF_TX_DESCRIPTOR_PKT_FT, txd[0]) == 3 ? "(redirect)" : "");
+	info_or_seq_printf(s, "Q_IDX = %d%s%s%s\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_Q_IDX, txd[0]),
+			GET_FIELD(WF_TX_DESCRIPTOR_Q_IDX, txd[0]) == 0x10 ? "(ALTX)" : "",
+			GET_FIELD(WF_TX_DESCRIPTOR_Q_IDX, txd[0]) == 0x11 ? "(BMC)" : "",
+			GET_FIELD(WF_TX_DESCRIPTOR_Q_IDX, txd[0]) == 0x12 ? "(BCN)" : "");
+
+	/* dw1 */
+	info_or_seq_printf(s, "MLD_ID = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_MLD_ID, txd[1]));
+	info_or_seq_printf(s, "TGID = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_TGID, txd[1]));
+	info_or_seq_printf(s, "HF = %d%s%s%s%s\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_HF, txd[1]),
+			GET_FIELD(WF_TX_DESCRIPTOR_HF, txd[1]) == 0 ? "(eth/802.3)" : "",
+			GET_FIELD(WF_TX_DESCRIPTOR_HF, txd[1]) == 1 ? "(cmd)" : "",
+			GET_FIELD(WF_TX_DESCRIPTOR_HF, txd[1]) == 2 ? "(802.11)" : "",
+			GET_FIELD(WF_TX_DESCRIPTOR_HF, txd[1]) == 3 ? "(802.11 enhanced" : "");
+	info_or_seq_printf(s, "802.11 HEADER_LENGTH = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_HF, txd[1]) == 2 ?
+			GET_FIELD(WF_TX_DESCRIPTOR_HEADER_LENGTH, txd[1]) : 0);
+	info_or_seq_printf(s, "MRD = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_HF, txd[1]) == 0 ?
+			GET_FIELD(WF_TX_DESCRIPTOR_MRD, txd[1]) : 0);
+	info_or_seq_printf(s, "EOSP = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_HF, txd[1]) == 0 ?
+			GET_FIELD(WF_TX_DESCRIPTOR_EOSP, txd[1]) : 0);
+	info_or_seq_printf(s, "AMS = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_HF, txd[1]) == 3 ?
+			GET_FIELD(WF_TX_DESCRIPTOR_AMS, txd[1]) : 0);
+	info_or_seq_printf(s, "RMVL = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_HF, txd[1]) == 0 ?
+			GET_FIELD(WF_TX_DESCRIPTOR_RMVL, txd[1]): 0);
+	info_or_seq_printf(s, "VLAN = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_HF, txd[1]) == 0 ?
+			GET_FIELD(WF_TX_DESCRIPTOR_VLAN, txd[1]) : 0);
+	info_or_seq_printf(s, "ETYP = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_HF, txd[1]) == 0 ?
+			GET_FIELD(WF_TX_DESCRIPTOR_ETYP, txd[1]) : 0);
+	info_or_seq_printf(s, "TID_MGMT_TYPE = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_TID_MGMT_TYPE, txd[1]));
+	info_or_seq_printf(s, "OM = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_OM, txd[1]));
+	info_or_seq_printf(s, "FR = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_FR, txd[1]));
+
+	/* dw2 */
+	info_or_seq_printf(s, "SUBTYPE = %d%s%s%s%s\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_SUBTYPE, txd[2]),
+			(GET_FIELD(WF_TX_DESCRIPTOR_FTYPE, txd[2]) == 0) &&
+			(GET_FIELD(WF_TX_DESCRIPTOR_SUBTYPE, txd[2]) == 13) ?
+			"(action)" : "",
+			(GET_FIELD(WF_TX_DESCRIPTOR_FTYPE, txd[2]) == 1) &&
+			(GET_FIELD(WF_TX_DESCRIPTOR_SUBTYPE, txd[2]) == 8) ?
+			"(bar)" : "",
+			(GET_FIELD(WF_TX_DESCRIPTOR_FTYPE, txd[2]) == 2) &&
+			(GET_FIELD(WF_TX_DESCRIPTOR_SUBTYPE, txd[2]) == 4) ?
+			"(null)" : "",
+			(GET_FIELD(WF_TX_DESCRIPTOR_FTYPE, txd[2]) == 2) &&
+			(GET_FIELD(WF_TX_DESCRIPTOR_SUBTYPE, txd[2]) == 12) ?
+			"(qos null)" : "");
+
+	info_or_seq_printf(s, "FTYPE = %d%s%s%s\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_FTYPE, txd[2]),
+			GET_FIELD(WF_TX_DESCRIPTOR_FTYPE, txd[2]) == 0 ? "(mgmt)" : "",
+			GET_FIELD(WF_TX_DESCRIPTOR_FTYPE, txd[2]) == 1 ? "(ctl)" : "",
+			GET_FIELD(WF_TX_DESCRIPTOR_FTYPE, txd[2]) == 2 ? "(data)" : "");
+	info_or_seq_printf(s, "BF_TYPE = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_BF_TYPE, txd[2]));
+	info_or_seq_printf(s, "OM_MAP = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_OM_MAP, txd[2]));
+	info_or_seq_printf(s, "RTS = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_RTS, txd[2]));
+	info_or_seq_printf(s, "HEADER_PADDING = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_HEADER_PADDING, txd[2]));
+	info_or_seq_printf(s, "DU = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_DU, txd[2]));
+	info_or_seq_printf(s, "HE = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_HE, txd[2]));
+	info_or_seq_printf(s, "FRAG = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_FRAG, txd[2]));
+	info_or_seq_printf(s, "REMAINING_TX_TIME = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_REMAINING_TX_TIME, txd[2]));
+	info_or_seq_printf(s, "POWER_OFFSET = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_POWER_OFFSET, txd[2]));
+
+	/* dw3 */
+	info_or_seq_printf(s, "NA = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_NA, txd[3]));
+	info_or_seq_printf(s, "PF = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_PF, txd[3]));
+	info_or_seq_printf(s, "EMRD = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_EMRD, txd[3]));
+	info_or_seq_printf(s, "EEOSP = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_EEOSP, txd[3]));
+	info_or_seq_printf(s, "BM = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_BM, txd[3]));
+	info_or_seq_printf(s, "HW_AMSDU_CAP = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_HW_AMSDU_CAP, txd[3]));
+	info_or_seq_printf(s, "TX_COUNT = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_TX_COUNT, txd[3]));
+	info_or_seq_printf(s, "REMAINING_TX_COUNT = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_REMAINING_TX_COUNT, txd[3]));
+	info_or_seq_printf(s, "SN = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_SN, txd[3]));
+	info_or_seq_printf(s, "BA_DIS = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_BA_DIS, txd[3]));
+	info_or_seq_printf(s, "PM = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_PM, txd[3]));
+	info_or_seq_printf(s, "PN_VLD = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_PN_VLD, txd[3]));
+	info_or_seq_printf(s, "SN_VLD = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_SN_VLD, txd[3]));
+
+	/* dw4 */
+	info_or_seq_printf(s, "PN_31_0 = 0x%x\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_PN_31_0_, txd[4]));
+
+	/* dw5 */
+	info_or_seq_printf(s, "PID = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_PID, txd[5]));
+	info_or_seq_printf(s, "TXSFM = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_TXSFM, txd[5]));
+	info_or_seq_printf(s, "TXS2M = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_TXS2M, txd[5]));
+	info_or_seq_printf(s, "TXS2H = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_TXS2H, txd[5]));
+	info_or_seq_printf(s, "FBCZ = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_FBCZ, txd[5]));
+	info_or_seq_printf(s, "BYPASS_RBB = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_BYPASS_RBB, txd[5]));
+
+	info_or_seq_printf(s, "FL = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_FL, txd[5]));
+	info_or_seq_printf(s, "PN_47_32 = 0x%x\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_PN_47_32_, txd[5]));
+
+	/* dw6 */
+	info_or_seq_printf(s, "AMSDU_CAP_UTXB = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_AMSDU_CAP_UTXB, txd[6]));
+	info_or_seq_printf(s, "DAS = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_DAS, txd[6]));
+	info_or_seq_printf(s, "DIS_MAT = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_DIS_MAT, txd[6]));
+	info_or_seq_printf(s, "MSDU_COUNT = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_MSDU_COUNT, txd[6]));
+	info_or_seq_printf(s, "TIMESTAMP_OFFSET = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_TIMESTAMP_OFFSET_IDX, txd[6]));
+	info_or_seq_printf(s, "FIXED_RATE_IDX = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_FIXED_RATE_IDX, txd[6]));
+	info_or_seq_printf(s, "BW = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_BW, txd[6]));
+	info_or_seq_printf(s, "VTA = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_VTA, txd[6]));
+	info_or_seq_printf(s, "SRC = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_SRC, txd[6]));
+
+	/* dw7 */
+	info_or_seq_printf(s, "SW_TX_TIME(unit:65536ns) = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_SW_TX_TIME , txd[7]));
+	info_or_seq_printf(s, "UT = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_UT, txd[7]));
+	info_or_seq_printf(s, "CTXD_CNT = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_CTXD_CNT, txd[7]));
+	info_or_seq_printf(s, "HM = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_HM, txd[7]));
+	info_or_seq_printf(s, "DP = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_DP, txd[7]));
+	info_or_seq_printf(s, "IP = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_IP, txd[7]));
+	info_or_seq_printf(s, "TXD_LEN = %d\n",
+			GET_FIELD(WF_TX_DESCRIPTOR_TXD_LEN, txd[7]));
+
+	if (dump_txp) {
+		__le32 *txp = txd + 8;
+
+		if (is_hif_txd)
+			mt7996_dump_bmac_hif_txp_info(s, dev, txp, hif_txp_ver);
+		else
+			mt7996_dump_bmac_mac_txp_info(s, dev, txp);
+	}
+}
+
+static void
+mt7996_dump_mac_fid(struct seq_file *s, struct mt7996_dev *dev, u32 fid, bool is_ple)
+{
+#define PLE_MEM_SIZE	 128
+#define PSE_MEM_SIZE	 256
+	 u8 data[PSE_MEM_SIZE] = {0};
+	 u32 addr = 0;
+	 int i = 0, cr_cnt = PSE_MEM_SIZE;
+	 u32 *ptr = (u32 *) data;
+
+	 if (is_ple) {
+		cr_cnt = PLE_MEM_SIZE;
+		seq_printf(s, "dump ple: fid = 0x%08x\n", fid);
+	 } else {
+		seq_printf(s, "dump pse: fid = 0x%08x\n", fid);
+	 }
+
+	 for (i = 0; i < cr_cnt; i = i + 4) {
+		if (is_ple)
+			addr = (0xa << 28 | fid << 15) + i;
+		else
+			addr = (0xb << 28 | fid << 15) + i;
+		*ptr = mt76_rr(dev, addr);
+		ptr++;
+	 }
+
+	 seq_printf(s, "raw data: size=%d\n", cr_cnt);
+
+	 seq_hex_dump(s, "", DUMP_PREFIX_OFFSET, 16, 1, (u8 *)data, cr_cnt, false);
+	 /* dump one txd info */
+	 if (is_ple) {
+		 dev->dbg.txd_read_cnt = 1;
+		 mt7996_dump_bmac_txd_info(s, dev, (__le32 *)&data[0], false, true);
+	 }
+}
+
+static int
+mt7996_ple_fid_read(struct seq_file *s, void *data) {
+	 struct mt7996_dev *dev = dev_get_drvdata(s->private);
+
+	 mt7996_dump_mac_fid(s, dev, dev->dbg.fid_idx, true);
+	 return 0;
+}
+
+static int
+mt7996_pse_fid_read(struct seq_file *s, void *data) {
+	 struct mt7996_dev *dev = dev_get_drvdata(s->private);
+
+	 mt7996_dump_mac_fid(s, dev, dev->dbg.fid_idx, false);
+	 return 0;
+}
+
+void mt7996_dump_bmac_rxd_info(struct mt7996_dev *dev, __le32 *rxd)
+{
+	/* dump stop */
+	if (!dev->dbg.rxd_read_cnt)
+		return;
+
+	/* force dump */
+	if (dev->dbg.rxd_read_cnt > 8)
+		dev->dbg.rxd_read_cnt = 8;
+
+	/* dump txd_read_cnt times */
+	if (dev->dbg.rxd_read_cnt != 8)
+		dev->dbg.rxd_read_cnt--;
+
+	printk("rxd raw data: size=%d\n", MT_TXD_SIZE);
+	print_hex_dump(KERN_ERR , "", DUMP_PREFIX_OFFSET, 16, 1, (u8 *)rxd, 96, false);
+
+	printk("BMAC_RXD Fields:\n");
+
+	/* group0 */
+	/* dw0 */
+	printk("RX_BYTE_COUNT = %d\n",
+			GET_FIELD(WF_RX_DESCRIPTOR_RX_BYTE_COUNT, le32_to_cpu(rxd[0])));
+	printk("PACKET_TYPE = %d\n",
+			GET_FIELD(WF_RX_DESCRIPTOR_PACKET_TYPE, le32_to_cpu(rxd[0])));
+
+	/* dw1 */
+	printk("MLD_ID = %d\n",
+			GET_FIELD(WF_RX_DESCRIPTOR_MLD_ID, le32_to_cpu(rxd[1])));
+	printk("GROUP_VLD = 0x%x%s%s%s%s%s\n",
+			GET_FIELD(WF_RX_DESCRIPTOR_GROUP_VLD, le32_to_cpu(rxd[1])),
+			GET_FIELD(WF_RX_DESCRIPTOR_GROUP_VLD, le32_to_cpu(rxd[1]))
+			& BMAC_GROUP_VLD_1 ? "[group1]" : "",
+			GET_FIELD(WF_RX_DESCRIPTOR_GROUP_VLD, le32_to_cpu(rxd[1]))
+			& BMAC_GROUP_VLD_2 ? "[group2]" : "",
+			GET_FIELD(WF_RX_DESCRIPTOR_GROUP_VLD, le32_to_cpu(rxd[1]))
+			& BMAC_GROUP_VLD_3 ? "[group3]" : "",
+			GET_FIELD(WF_RX_DESCRIPTOR_GROUP_VLD, le32_to_cpu(rxd[1]))
+			& BMAC_GROUP_VLD_4 ? "[group4]" : "",
+			GET_FIELD(WF_RX_DESCRIPTOR_GROUP_VLD, le32_to_cpu(rxd[1]))
+			& BMAC_GROUP_VLD_5 ? "[group5]" : "");
+	printk("KID = %d\n",
+			GET_FIELD(WF_RX_DESCRIPTOR_KID, le32_to_cpu(rxd[1])));
+	printk("CM = %d\n",
+			GET_FIELD(WF_RX_DESCRIPTOR_CM, le32_to_cpu(rxd[1])));
+	printk("CLM = %d\n",
+			GET_FIELD(WF_RX_DESCRIPTOR_CLM, le32_to_cpu(rxd[1])));
+	printk("I = %d\n",
+			GET_FIELD(WF_RX_DESCRIPTOR_I, le32_to_cpu(rxd[1])));
+	printk("T = %d\n",
+			GET_FIELD(WF_RX_DESCRIPTOR_T, le32_to_cpu(rxd[1])));
+	printk("BN = %d\n",
+			GET_FIELD(WF_RX_DESCRIPTOR_BN, le32_to_cpu(rxd[1])));
+	printk("BIPN_FAIL = %d\n",
+			GET_FIELD(WF_RX_DESCRIPTOR_BIPN_FAIL, le32_to_cpu(rxd[1])));
+
+	/* dw2 */
+	printk("BSSID = %d\n",
+			GET_FIELD(WF_RX_DESCRIPTOR_BSSID, le32_to_cpu(rxd[2])));
+	printk("H = %d%s\n",
+			GET_FIELD(WF_RX_DESCRIPTOR_H, le32_to_cpu(rxd[2])),
+			GET_FIELD(WF_RX_DESCRIPTOR_H, le32_to_cpu(rxd[2])) == 0 ?
+			"802.11 frame" : "eth/802.3 frame");
+	printk("HEADER_LENGTH(word) = %d\n",
+			GET_FIELD(WF_RX_DESCRIPTOR_HEADER_LENGTH, le32_to_cpu(rxd[2])));
+	printk("HO(word) = %d\n",
+			GET_FIELD(WF_RX_DESCRIPTOR_HO, le32_to_cpu(rxd[2])));
+	printk("SEC_MODE = %d\n",
+			GET_FIELD(WF_RX_DESCRIPTOR_SEC_MODE, le32_to_cpu(rxd[2])));
+	printk("MUBAR = %d\n",
+			GET_FIELD(WF_RX_DESCRIPTOR_MUBAR, le32_to_cpu(rxd[2])));
+	printk("SWBIT = %d\n",
+			GET_FIELD(WF_RX_DESCRIPTOR_SWBIT, le32_to_cpu(rxd[2])));
+	printk("DAF = %d\n",
+			GET_FIELD(WF_RX_DESCRIPTOR_DAF, le32_to_cpu(rxd[2])));
+	printk("EL = %d\n",
+			GET_FIELD(WF_RX_DESCRIPTOR_EL, le32_to_cpu(rxd[2])));
+	printk("HTF = %d\n",
+			GET_FIELD(WF_RX_DESCRIPTOR_HTF, le32_to_cpu(rxd[2])));
+	printk("INTF = %d\n",
+			GET_FIELD(WF_RX_DESCRIPTOR_INTF, le32_to_cpu(rxd[2])));
+	printk("FRAG = %d\n",
+			GET_FIELD(WF_RX_DESCRIPTOR_FRAG, le32_to_cpu(rxd[2])));
+	printk("NUL = %d\n",
+			GET_FIELD(WF_RX_DESCRIPTOR_NUL, le32_to_cpu(rxd[2])));
+	printk("NDATA = %d%s\n",
+			GET_FIELD(WF_RX_DESCRIPTOR_NDATA, le32_to_cpu(rxd[2])),
+			GET_FIELD(WF_RX_DESCRIPTOR_NDATA, le32_to_cpu(rxd[2])) == 0 ?
+			"[data frame]" : "[mgmt/ctl frame]");
+	printk("NAMP = %d%s\n",
+			GET_FIELD(WF_RX_DESCRIPTOR_NAMP, le32_to_cpu(rxd[2])),
+			GET_FIELD(WF_RX_DESCRIPTOR_NAMP, le32_to_cpu(rxd[2])) == 0 ?
+			"[ampdu frame]" : "[mpdu frame]");
+	printk("BF_RPT = %d\n",
+			GET_FIELD(WF_RX_DESCRIPTOR_BF_RPT, le32_to_cpu(rxd[2])));
+
+	/* dw3 */
+	printk("RXV_SN = %d\n",
+			GET_FIELD(WF_RX_DESCRIPTOR_RXV_SN, le32_to_cpu(rxd[3])));
+	printk("CH_FREQUENCY = %d\n",
+			GET_FIELD(WF_RX_DESCRIPTOR_CH_FREQUENCY, le32_to_cpu(rxd[3])));
+	printk("A1_TYPE = %d%s%s%s%s\n",
+			GET_FIELD(WF_RX_DESCRIPTOR_A1_TYPE, le32_to_cpu(rxd[3])),
+			GET_FIELD(WF_RX_DESCRIPTOR_A1_TYPE, le32_to_cpu(rxd[3])) == 0 ?
+			"[reserved]" : "",
+			GET_FIELD(WF_RX_DESCRIPTOR_A1_TYPE, le32_to_cpu(rxd[3])) == 1 ?
+			"[uc2me]" : "",
+			GET_FIELD(WF_RX_DESCRIPTOR_A1_TYPE, le32_to_cpu(rxd[3])) == 2 ?
+			"[mc]" : "",
+			GET_FIELD(WF_RX_DESCRIPTOR_A1_TYPE, le32_to_cpu(rxd[3])) == 3 ?
+			"[bc]" : "");
+	printk("HTC = %d\n",
+			GET_FIELD(WF_RX_DESCRIPTOR_HTC, le32_to_cpu(rxd[3])));
+	printk("TCL = %d\n",
+			GET_FIELD(WF_RX_DESCRIPTOR_TCL, le32_to_cpu(rxd[3])));
+	printk("BBM = %d\n",
+			GET_FIELD(WF_RX_DESCRIPTOR_BBM, le32_to_cpu(rxd[3])));
+	printk("BU = %d\n",
+			GET_FIELD(WF_RX_DESCRIPTOR_BU, le32_to_cpu(rxd[3])));
+	printk("CO_ANT = %d\n",
+			GET_FIELD(WF_RX_DESCRIPTOR_CO_ANT, le32_to_cpu(rxd[3])));
+	printk("BF_CQI = %d\n",
+			GET_FIELD(WF_RX_DESCRIPTOR_BF_CQI, le32_to_cpu(rxd[3])));
+	printk("FC = %d\n",
+			GET_FIELD(WF_RX_DESCRIPTOR_FC, le32_to_cpu(rxd[3])));
+	printk("VLAN = %d\n",
+			GET_FIELD(WF_RX_DESCRIPTOR_VLAN, le32_to_cpu(rxd[3])));
+
+	/* dw4 */
+	printk("PF = %d%s%s%s%s\n",
+			GET_FIELD(WF_RX_DESCRIPTOR_PF, le32_to_cpu(rxd[4])),
+			GET_FIELD(WF_RX_DESCRIPTOR_PF, le32_to_cpu(rxd[4])) == 0 ?
+			"[msdu]" : "",
+			GET_FIELD(WF_RX_DESCRIPTOR_PF, le32_to_cpu(rxd[4])) == 1 ?
+			"[final amsdu]" : "",
+			GET_FIELD(WF_RX_DESCRIPTOR_PF, le32_to_cpu(rxd[4])) == 2 ?
+			"[middle amsdu]" : "",
+			GET_FIELD(WF_RX_DESCRIPTOR_PF, le32_to_cpu(rxd[4])) == 3 ?
+			"[first amsdu]" : "");
+	printk("MAC = %d\n",
+			GET_FIELD(WF_RX_DESCRIPTOR_MAC, le32_to_cpu(rxd[4])));
+	printk("TID = %d\n",
+			GET_FIELD(WF_RX_DESCRIPTOR_TID, le32_to_cpu(rxd[4])));
+	printk("ETHER_TYPE_OFFSET = %d\n",
+			GET_FIELD(WF_RX_DESCRIPTOR_ETHER_TYPE_OFFSET, le32_to_cpu(rxd[4])));
+	printk("IP = %d\n",
+			GET_FIELD(WF_RX_DESCRIPTOR_IP, le32_to_cpu(rxd[4])));
+	printk("UT = %d\n",
+			GET_FIELD(WF_RX_DESCRIPTOR_UT, le32_to_cpu(rxd[4])));
+	printk("PSE_FID = %d\n",
+			GET_FIELD(WF_RX_DESCRIPTOR_PSE_FID, le32_to_cpu(rxd[4])));
+
+	/* group4 */
+	/* dw0 */
+	printk("FRAME_CONTROL_FIELD = 0x%x\n",
+			GET_FIELD(WF_RX_DESCRIPTOR_GROUP_VLD, le32_to_cpu(rxd[1]))
+			& BMAC_GROUP_VLD_4 ?
+			GET_FIELD(WF_RX_DESCRIPTOR_FRAME_CONTROL_FIELD, le32_to_cpu(rxd[8])) : 0);
+	printk("PEER_MLD_ADDRESS_15_0 = 0x%x\n",
+			GET_FIELD(WF_RX_DESCRIPTOR_GROUP_VLD, le32_to_cpu(rxd[1]))
+			& BMAC_GROUP_VLD_4 ?
+			GET_FIELD(WF_RX_DESCRIPTOR_PEER_MLD_ADDRESS_15_0_,
+			le32_to_cpu(rxd[8])) : 0);
+
+	/* dw1 */
+	printk("PEER_MLD_ADDRESS_47_16 = 0x%x\n",
+			GET_FIELD(WF_RX_DESCRIPTOR_GROUP_VLD, le32_to_cpu(rxd[1]))
+			& BMAC_GROUP_VLD_4 ?
+			GET_FIELD(WF_RX_DESCRIPTOR_PEER_MLD_ADDRESS_47_16_,
+			le32_to_cpu(rxd[9])) : 0);
+
+	/* dw2 */
+	printk("FRAGMENT_NUMBER = %d\n",
+			GET_FIELD(WF_RX_DESCRIPTOR_GROUP_VLD, le32_to_cpu(rxd[1]))
+			& BMAC_GROUP_VLD_4 ?
+			GET_FIELD(WF_RX_DESCRIPTOR_FRAGMENT_NUMBER,
+			le32_to_cpu(rxd[10])) : 0);
+	printk("SEQUENCE_NUMBER = %d\n",
+			GET_FIELD(WF_RX_DESCRIPTOR_GROUP_VLD, le32_to_cpu(rxd[1]))
+			& BMAC_GROUP_VLD_4 ?
+			GET_FIELD(WF_RX_DESCRIPTOR_SEQUENCE_NUMBER,
+			le32_to_cpu(rxd[10])) : 0);
+	printk("QOS_CONTROL_FIELD = 0x%x\n",
+			GET_FIELD(WF_RX_DESCRIPTOR_GROUP_VLD, le32_to_cpu(rxd[1]))
+			& BMAC_GROUP_VLD_4 ?
+			GET_FIELD(WF_RX_DESCRIPTOR_QOS_CONTROL_FIELD,
+			le32_to_cpu(rxd[10])) : 0);
+
+	/* dw3 */
+	printk("HT_CONTROL_FIELD = 0x%x\n",
+			GET_FIELD(WF_RX_DESCRIPTOR_GROUP_VLD, le32_to_cpu(rxd[1]))
+			& BMAC_GROUP_VLD_4 ?
+			GET_FIELD(WF_RX_DESCRIPTOR_HT_CONTROL_FIELD,
+			le32_to_cpu(rxd[11])) : 0);
+}
+
+static int mt7996_token_txd_read(struct seq_file *s, void *data)
+{
+	struct mt7996_dev *dev = dev_get_drvdata(s->private);
+	struct mt76_txwi_cache *t;
+	u8* txwi;
+
+	seq_printf(s, "\n");
+	spin_lock_bh(&dev->mt76.token_lock);
+
+	t = idr_find(&dev->mt76.token, dev->dbg.token_idx);
+	if (t != NULL) {
+		struct mt76_dev *mdev = &dev->mt76;
+		txwi = ((u8*)(t)) - (mdev->drv->txwi_size);
+		/* dump one txd info */
+		dev->dbg.txd_read_cnt = 1;
+		mt7996_dump_bmac_txd_info(s, dev, (__le32 *)txwi, true, true);
+		seq_printf(s, "\n");
+		seq_printf(s, "[SKB]\n");
+		seq_hex_dump(s, "", DUMP_PREFIX_OFFSET, 16, 1, (u8 *)t->skb->data, t->skb->len, false);
+		seq_printf(s, "\n");
+	}
+	spin_unlock_bh(&dev->mt76.token_lock);
+	return 0;
+}
+
+static int mt7996_rx_msdu_pg_read(struct seq_file *s, void *data)
+{
+	struct mt7996_dev *dev = dev_get_drvdata(s->private);
+	struct list_head *p;
+	int i, count = 0, total = 0;
+
+	seq_printf(s, "Rx Msdu page:\n");
+	spin_lock(&dev->wed_rro.lock);
+	for (i = 0; i < MT7996_RRO_MSDU_PG_HASH_SIZE; i++) {
+		list_for_each(p, &dev->wed_rro.pg_hash_head[i]) {
+			count++;
+		}
+	}
+
+	total = count;
+	list_for_each(p, &dev->wed_rro.pg_addr_cache) {
+		total++;
+	}
+	seq_printf(s, "\ttotal:%8d used:%8d\n", total, count);
+	spin_unlock(&dev->wed_rro.lock);
+
+	return 0;
+}
+
+static int
+mt7996_mat_table_show(struct seq_file *s, void *data)
+{
+#define MT_MAX_MAT_TABLE_SIZE	63
+	struct mt7996_dev *dev = s->private;
+	int i;
+
+	for (i = 0; i < MT_MAX_MAT_TABLE_SIZE; i++) {
+		u32 req = MT_WF_UWTBL_ITCR_SET |
+			  u32_encode_bits(i, MT_WF_UWTBL_ITCR_INDEX);
+		u32 dw[2];
+		u8 *addr = (u8 *)dw;
+
+		mt76_wr(dev, MT_WF_UWTBL_ITCR, req);
+		dw[0] = mt76_rr(dev, MT_WF_UWTBL_ITCR0);
+		dw[1] = mt76_rr(dev, MT_WF_UWTBL_ITCR1);
+
+		if (dw[0] || dw[1])
+			seq_printf(s, "own_mld_id%d\tAddr: %pM\n", i, addr);
+	}
+	return 0;
+}
+DEFINE_SHOW_ATTRIBUTE(mt7996_mat_table);
+
+static int
+mt7996_rmac_table_show(struct seq_file *s, void *data)
+{
+	struct mt7996_phy *phy = s->private;
+	struct mt7996_dev *dev = phy->dev;
+	unsigned long usage_bitmap[2] = {0};
+	int i, j;
+	u8 band = phy->mt76->band_idx;
+
+	usage_bitmap[0] = (unsigned long)mt76_rr(dev, MT_WF_RMAC_SRAM_BITMAP0(band));
+	usage_bitmap[1] = (unsigned long)mt76_rr(dev, MT_WF_RMAC_SRAM_BITMAP1(band));
+
+	for (i = 0; i < 2; i++) {
+		for_each_set_bit(j, &usage_bitmap[i], 32) {
+			u32 req = MT_WF_RMAC_MEM_CRTL_TRIG |
+				  u32_encode_bits(i * 32 + j, MT_WF_RMAC_MEM_CRTL_TDX);
+			u32 dw[2];
+			u8 *addr = (u8 *)dw;
+
+			mt76_wr(dev, MT_WF_RMAC_MEM_CTRL(band), req);
+			dw[0] = mt76_rr(dev, MT_WF_RMAC_SRAM_DATA0(band));
+			dw[1] = mt76_rr(dev, MT_WF_RMAC_SRAM_DATA1(band));
+
+			seq_printf(s, "omac_idx%d\tAddr: %pM\n", i * 32 + j, addr);
+		}
+	}
+
+	return 0;
+}
+DEFINE_SHOW_ATTRIBUTE(mt7996_rmac_table);
+
+static int
+mt7996_agg_table_show(struct seq_file *s, void *data)
+{
+	struct mt7996_phy *phy = s->private;
+	struct mt7996_dev *dev = phy->dev;
+	int i, j;
+	u8 band = phy->mt76->band_idx;
+
+	for (i = 0; i < 4; i++) {
+		u32 value = mt76_rr(dev, MT_AGG_REMAP_CTRL(band) + 4 * i);
+
+		for (j = 0; j < 4; j++) {
+			u8 shift = 8 * j;
+			u32 mask = MT_AGG_REMAP_CTRL_OM_REMAP << shift;
+
+			seq_printf(s, "idx%d: %d\n", i * 4 + j,
+				      (value & mask) >> shift);
+		}
+	}
+
+	return 0;
+}
+DEFINE_SHOW_ATTRIBUTE(mt7996_agg_table);
+
+static ssize_t mt7996_mlo_agc_tx_set(struct file *file,
+				     const char __user *user_buf,
+				     size_t count, loff_t *ppos)
+{
+	struct mt7996_dev *dev = file->private_data;
+	struct mt7996_mlo_agc_set req;
+	char buf[100];
+	int ret;
+	u16 mgf;
+
+	memset(&req, 0, sizeof(req));
+
+	if (count >= sizeof(buf))
+		return -EINVAL;
+
+	if (copy_from_user(buf, user_buf, count))
+		return -EFAULT;
+
+	if (count && buf[count - 1] == '\n')
+		buf[count - 1] = '\0';
+	else
+		buf[count] = '\0';
+
+	if (sscanf(buf, "%hhu %hhu %hhu %hhu %hu %hhu %hhu",
+		   &req.mld_id, &req.link_id, &req.ac, &req.disp_pol,
+		   &mgf, &req.ratio, &req.order) != 7) {
+		dev_warn(dev->mt76.dev,
+			 "format: [MldRecIdx] [Link] [Ac] [DispPol] [MGF] [Ratio] [Order]\n");
+		goto out;
+	}
+
+	req.tag = cpu_to_le16(UNI_CMD_MLO_AGC_TX);
+	req.len = cpu_to_le16(sizeof(req) - 4);
+	req.mgf = cpu_to_le16(mgf);
+
+	ret = mt7996_mcu_mlo_agc(dev, &req, sizeof(req));
+	if (ret)
+		return -EFAULT;
+
+out:
+	return count;
+}
+
+static const struct file_operations fops_mlo_agc_tx = {
+	.write = mt7996_mlo_agc_tx_set,
+	.open = simple_open,
+	.owner = THIS_MODULE,
+	.llseek = default_llseek,
+};
+
+static ssize_t mt7996_be_txop_set(struct file *file,
+			       const char __user *user_buf,
+			       size_t count, loff_t *ppos)
+{
+	struct mt7996_dev *dev = file->private_data;
+	char buf[100], role[4];
+	u32 ofs;
+	u16 txop, decimal;
+	int i = 0;
+
+	if (count >= sizeof(buf))
+		return -EINVAL;
+
+	if (copy_from_user(buf, user_buf, count))
+		return -EFAULT;
+
+	if (count && buf[count - 1] == '\n')
+		buf[count - 1] = '\0';
+	else
+		buf[count] = '\0';
+
+	if (sscanf(buf, "%3s %hu.%hu", role, &txop, &decimal) != 3)
+		goto err;
+
+	if (!strncmp(role, "ap", 2))
+		ofs = MT_WF_TMAC_WMM0_OFFSET;
+	else if (!strncmp(role, "sta", 3))
+		ofs = MT_WF_TMAC_WMM3_OFFSET;
+	else
+		goto err;
+
+	/* Change unit to 32 us */
+	txop = (txop * 1000 + decimal * 100 + 16) >> 5;
+
+	for (i = 0; i < __MT_MAX_BAND; i++) {
+		if (!dev->mt76.phys[i])
+			continue;
+
+		mt76_rmw(dev, MT_WF_TMAC(i, ofs), MT_WF_TMAC_WMM_TXOP_MASK,
+			 txop << MT_WF_TMAC_WMM_TXOP_SHIFT);
+	}
+
+	return count;
+err:
+	dev_warn(dev->mt76.dev,
+		 "format: [ap|sta] [tx_queue_data2_burst]\n");
+	return -EINVAL;
+}
+
+static ssize_t mt7996_be_txop_dump(struct file *file, char __user *user_buf,
+				size_t count, loff_t *ppos)
+{
+	struct mt7996_dev *dev = file->private_data;
+	static const size_t size = 2048;
+	int len = 0, i, ret;
+	char *buf;
+	enum {
+		AP,
+		STA,
+		MAX_IF_TYPE,
+	};
+
+	buf = kzalloc(size, GFP_KERNEL);
+	if (!buf)
+		return -ENOMEM;
+
+	len += scnprintf(buf + len, size - len, "Band\tAP (WMM0)\t\tSTA (WMM3)\n");
+
+	for (i = 0; i < __MT_MAX_BAND; i++) {
+		u32 txop[MAX_IF_TYPE], tx_burst[MAX_IF_TYPE];
+
+		if (!dev->mt76.phys[i])
+			continue;
+
+#define MT7996_READ_TXOP(role, base)						\
+do {										\
+	txop[role] = mt76_rr(dev, MT_WF_TMAC(i, base));				\
+	tx_burst[role] = u32_get_bits(txop[role], MT_WF_TMAC_WMM_TXOP_MASK);	\
+	tx_burst[role] = tx_burst[role] ? ((tx_burst[role] << 5) - 16) / 100 : 0;\
+} while (0)
+		MT7996_READ_TXOP(AP, MT_WF_TMAC_WMM0_OFFSET);
+		MT7996_READ_TXOP(STA, MT_WF_TMAC_WMM3_OFFSET);
+#undef MT7996_READ_TXOP
+
+		len += scnprintf(buf + len, size - len,
+			"%d\t0x%08x (%1u.%1u) \t0x%08x (%1u.%1u)\n", i,
+			txop[AP], tx_burst[AP] / 10, tx_burst[AP] % 10,
+			txop[STA], tx_burst[STA] / 10, tx_burst[STA] % 10);
+	}
+	ret = simple_read_from_buffer(user_buf, count, ppos, buf, len);
+
+	kfree(buf);
+	return ret;
+}
+
+static const struct file_operations fops_mt7996_txop = {
+	.write = mt7996_be_txop_set,
+	.read = mt7996_be_txop_dump,
+	.open = simple_open,
+	.owner = THIS_MODULE,
+	.llseek = default_llseek,
+};
+
+static ssize_t mt7996_mlo_agc_trig_set(struct file *file,
+				       const char __user *user_buf,
+				       size_t count, loff_t *ppos)
+{
+	struct mt7996_dev *dev = file->private_data;
+	struct mt7996_mlo_agc_set req;
+	char buf[100];
+	int ret;
+	u16 mgf;
+
+	memset(&req, 0, sizeof(req));
+
+	if (count >= sizeof(buf))
+		return -EINVAL;
+
+	if (copy_from_user(buf, user_buf, count))
+		return -EFAULT;
+
+	if (count && buf[count - 1] == '\n')
+		buf[count - 1] = '\0';
+	else
+		buf[count] = '\0';
+
+	if (sscanf(buf, "%hhu %hhu %hhu %hhu %hu %hhu",
+		   &req.mld_id, &req.link_id, &req.ac, &req.disp_pol,
+		   &mgf, &req.ratio) != 6) {
+		dev_warn(dev->mt76.dev,
+			 "format: [MldRecIdx] [Link] [Ac] [DispPol] [MGF] [Ratio]\n");
+		goto out;
+	}
+
+	req.tag = cpu_to_le16(UNI_CMD_MLO_AGC_TRIG);
+	req.len = cpu_to_le16(sizeof(req) - 4);
+	req.mgf = cpu_to_le16(mgf);
+
+	ret = mt7996_mcu_mlo_agc(dev, &req, sizeof(req));
+	if (ret)
+		return -EFAULT;
+
+out:
+	return count;
+}
+
+static const struct file_operations fops_mlo_agc_trig = {
+	.write = mt7996_mlo_agc_trig_set,
+	.open = simple_open,
+	.owner = THIS_MODULE,
+	.llseek = default_llseek,
+};
+
+int mt7996_mtk_init_dev_debugfs_internal(struct mt7996_phy *phy, struct dentry *dir)
+{
+	struct mt7996_dev *dev = phy->dev;
+
+	debugfs_create_devm_seqfile(dev->mt76.dev, "token_txd", dir,
+				    mt7996_token_txd_read);
+	debugfs_create_u32("txd_dump", 0600, dir, &dev->dbg.txd_read_cnt);
+	debugfs_create_u32("rxd_dump", 0600, dir, &dev->dbg.rxd_read_cnt);
+	debugfs_create_devm_seqfile(dev->mt76.dev, "rx_msdu_pg", dir,
+				    mt7996_rx_msdu_pg_read);
+
+	/* ple/pse fid raw data dump */
+	debugfs_create_u32("fid_idx", 0600, dir, &dev->dbg.fid_idx);
+	debugfs_create_devm_seqfile(dev->mt76.dev, "ple_fid", dir,
+				    mt7996_ple_fid_read);
+	debugfs_create_devm_seqfile(dev->mt76.dev, "pse_fid", dir,
+				    mt7996_pse_fid_read);
+
+	debugfs_create_u8("dump_ple_txd", 0600, dir, &dev->dbg.dump_ple_txd);
+	debugfs_create_file("txop", 0600, dir, dev, &fops_mt7996_txop);
+
+	/* MLO related Table */
+	debugfs_create_file("mat_table", 0400, dir, dev, &mt7996_mat_table_fops);
+	debugfs_create_file("mlo_agc_tx", 0200, dir, dev, &fops_mlo_agc_tx);
+	debugfs_create_file("mlo_agc_trig", 0200, dir, dev, &fops_mlo_agc_trig);
+
+	return 0;
+}
+
+int mt7996_mtk_init_band_debugfs_internal(struct mt7996_phy *phy, struct dentry *dir)
+{
+	/* MLO related Table */
+	debugfs_create_file("rmac_table", 0400, dir, phy, &mt7996_rmac_table_fops);
+	debugfs_create_file("agg_table", 0400, dir, phy, &mt7996_agg_table_fops);
+
+	return 0;
+}
+#endif
diff --git a/mt7996/mtk_mcu.c b/mt7996/mtk_mcu.c
new file mode 100644
index 00000000..82e3f721
--- /dev/null
+++ b/mt7996/mtk_mcu.c
@@ -0,0 +1,1373 @@
+// SPDX-License-Identifier: ISC
+/*
+ * Copyright (C) 2023 MediaTek Inc.
+ */
+
+#include <linux/firmware.h>
+#include <linux/fs.h>
+#include "mt7996.h"
+#include "mcu.h"
+#include "mac.h"
+#include "mtk_mcu.h"
+
+#ifdef CONFIG_MTK_DEBUG
+
+int mt7996_mcu_get_tx_power_info(struct mt7996_phy *phy, u8 category, void *event)
+{
+	struct mt7996_dev *dev = phy->dev;
+	struct tx_power_ctrl req = {
+		.tag = cpu_to_le16(UNI_TXPOWER_SHOW_INFO),
+		.len = cpu_to_le16(sizeof(req) - 4),
+		.power_ctrl_id = UNI_TXPOWER_SHOW_INFO,
+		.show_info_category = category,
+		.band_idx = phy->mt76->band_idx,
+	};
+	struct sk_buff *skb;
+	int ret;
+
+	ret = mt76_mcu_send_and_get_msg(&dev->mt76,
+					MCU_WM_UNI_CMD_QUERY(TXPOWER),
+					&req, sizeof(req), true, &skb);
+	if (ret)
+		return ret;
+
+	memcpy(event, skb->data, sizeof(struct mt7996_mcu_txpower_event));
+
+	dev_kfree_skb(skb);
+
+	return 0;
+}
+
+int mt7996_mcu_muru_dbg_info(struct mt7996_dev *dev, u16 item, u8 val)
+{
+	struct {
+		u8 __rsv1[4];
+
+		__le16 tag;
+		__le16 len;
+
+		__le16 item;
+		u8 __rsv2[2];
+		__le32 value;
+	} __packed req = {
+		.tag = cpu_to_le16(UNI_CMD_MURU_DBG_INFO),
+		.len = cpu_to_le16(sizeof(req) - 4),
+		.item = cpu_to_le16(item),
+		.value = cpu_to_le32(val),
+	};
+
+	return mt76_mcu_send_msg(&dev->mt76, MCU_WM_UNI_CMD(MURU), &req,
+				 sizeof(req), true);
+}
+
+int mt7996_mcu_edcca_enable(struct mt7996_phy *phy, bool enable)
+{
+	struct mt7996_dev *dev = phy->dev;
+	struct cfg80211_chan_def *chandef = &phy->mt76->chandef;
+	enum nl80211_band band = chandef->chan->band;
+	struct {
+		u8 band_idx;
+		u8 _rsv[3];
+
+		__le16 tag;
+		__le16 len;
+		u8 enable;
+		u8 std;
+		u8 _rsv2[2];
+	} __packed req = {
+		.band_idx = phy->mt76->band_idx,
+		.tag = cpu_to_le16(UNI_BAND_CONFIG_EDCCA_ENABLE),
+		.len = cpu_to_le16(sizeof(req) - 4),
+		.enable = enable,
+		.std = EDCCA_DEFAULT,
+	};
+
+	switch (dev->mt76.region) {
+	case NL80211_DFS_JP:
+		req.std = EDCCA_JAPAN;
+		break;
+	case NL80211_DFS_FCC:
+		if (band == NL80211_BAND_6GHZ)
+			req.std = EDCCA_FCC;
+		break;
+	case NL80211_DFS_ETSI:
+		if (band == NL80211_BAND_6GHZ)
+			req.std = EDCCA_ETSI;
+		break;
+	default:
+		break;
+	}
+
+	return mt76_mcu_send_msg(&phy->dev->mt76, MCU_WM_UNI_CMD(BAND_CONFIG),
+				 &req, sizeof(req), true);
+}
+
+int mt7996_mcu_edcca_threshold_ctrl(struct mt7996_phy *phy, u8 *value, bool set)
+{
+	struct {
+		u8 band_idx;
+		u8 _rsv[3];
+
+		__le16 tag;
+		__le16 len;
+		u8 threshold[4];
+		bool init;
+	} __packed *res, req = {
+		.band_idx = phy->mt76->band_idx,
+		.tag = cpu_to_le16(UNI_BAND_CONFIG_EDCCA_THRESHOLD),
+		.len = cpu_to_le16(sizeof(req) - 4),
+		.init = false,
+	};
+	struct sk_buff *skb;
+	int ret;
+	int i;
+
+	for (i = 0; i < EDCCA_MAX_BW_NUM; i++)
+		req.threshold[i] = value[i];
+
+	if (set)
+		return mt76_mcu_send_msg(&phy->dev->mt76, MCU_WM_UNI_CMD(BAND_CONFIG),
+					 &req, sizeof(req), true);
+
+	ret = mt76_mcu_send_and_get_msg(&phy->dev->mt76,
+					MCU_WM_UNI_CMD_QUERY(BAND_CONFIG),
+					&req, sizeof(req), true, &skb);
+
+	if (ret)
+		return ret;
+
+	res = (void *)skb->data;
+
+	for (i = 0; i < EDCCA_MAX_BW_NUM; i++)
+		value[i] = res->threshold[i];
+
+	dev_kfree_skb(skb);
+
+	return 0;
+}
+
+int mt7996_mcu_set_sr_enable(struct mt7996_phy *phy, u8 action, u64 val, bool set)
+{
+	struct {
+		u8 band_idx;
+		u8 _rsv[3];
+
+		__le16 tag;
+		__le16 len;
+
+		__le32 val;
+
+	} __packed req = {
+		.band_idx = phy->mt76->band_idx,
+
+		.tag = cpu_to_le16(action),
+		.len = cpu_to_le16(sizeof(req) - 4),
+
+		.val = cpu_to_le32((u32) val),
+	};
+
+	if (set)
+		return mt76_mcu_send_msg(&phy->dev->mt76, MCU_WM_UNI_CMD(SR), &req,
+					 sizeof(req), false);
+	else
+		return mt76_mcu_send_msg(&phy->dev->mt76, MCU_WM_UNI_CMD_QUERY(SR), &req,
+					 sizeof(req), false);
+}
+
+void mt7996_mcu_rx_sr_swsd(struct mt7996_dev *dev, struct sk_buff *skb)
+{
+#define SR_SCENE_DETECTION_TIMER_PERIOD_MS 500
+	struct mt7996_mcu_sr_swsd_event *event;
+	static const char * const rules[] = {"1 - NO CONNECTED", "2 - NO CONGESTION",
+					     "3 - NO INTERFERENCE", "4 - SR ON"};
+	u8 idx;
+
+	event = (struct mt7996_mcu_sr_swsd_event *)skb->data;
+	idx = event->basic.band_idx;
+
+	dev_info(dev->mt76.dev, "Band index = %u\n", le16_to_cpu(event->basic.band_idx));
+	dev_info(dev->mt76.dev, "Hit Rule = %s\n", rules[event->tlv[idx].rule]);
+	dev_info(dev->mt76.dev, "Timer Period = %d(us)\n"
+		 "Congestion Ratio  = %d.%1d%%\n",
+		 SR_SCENE_DETECTION_TIMER_PERIOD_MS * 1000,
+		 le32_to_cpu(event->tlv[idx].total_airtime_ratio) / 10,
+		 le32_to_cpu(event->tlv[idx].total_airtime_ratio) % 10);
+	dev_info(dev->mt76.dev,
+		 "Total Airtime = %d(us)\n"
+		 "ChBusy = %d\n"
+		 "SrTx = %d\n"
+		 "OBSS = %d\n"
+		 "MyTx = %d\n"
+		 "MyRx = %d\n"
+		 "Interference Ratio = %d.%1d%%\n",
+		 le32_to_cpu(event->tlv[idx].total_airtime),
+		 le32_to_cpu(event->tlv[idx].channel_busy_time),
+		 le32_to_cpu(event->tlv[idx].sr_tx_airtime),
+		 le32_to_cpu(event->tlv[idx].obss_airtime),
+		 le32_to_cpu(event->tlv[idx].my_tx_airtime),
+		 le32_to_cpu(event->tlv[idx].my_rx_airtime),
+		 le32_to_cpu(event->tlv[idx].obss_airtime_ratio) / 10,
+		 le32_to_cpu(event->tlv[idx].obss_airtime_ratio) % 10);
+}
+
+void mt7996_mcu_rx_sr_hw_indicator(struct mt7996_dev *dev, struct sk_buff *skb)
+{
+	struct mt7996_mcu_sr_hw_ind_event *event;
+
+	event = (struct mt7996_mcu_sr_hw_ind_event *)skb->data;
+
+	dev_info(dev->mt76.dev, "Inter PPDU Count = %u\n",
+		 le16_to_cpu(event->inter_bss_ppdu_cnt));
+	dev_info(dev->mt76.dev, "SR Valid Count = %u\n",
+		 le16_to_cpu(event->non_srg_valid_cnt));
+	dev_info(dev->mt76.dev, "SR Tx Count = %u\n",
+		 le32_to_cpu(event->sr_ampdu_mpdu_cnt));
+	dev_info(dev->mt76.dev, "SR Tx Acked Count = %u\n",
+		 le32_to_cpu(event->sr_ampdu_mpdu_acked_cnt));
+}
+
+void mt7996_mcu_rx_sr_event(struct mt7996_dev *dev, struct sk_buff *skb)
+{
+	struct mt76_phy *mphy = &dev->mt76.phy;
+	struct mt7996_phy *phy;
+	struct mt7996_mcu_sr_common_event *event;
+
+	event = (struct mt7996_mcu_sr_common_event *)skb->data;
+	mphy = dev->mt76.phys[event->basic.band_idx];
+	if (!mphy)
+		return;
+
+	phy = (struct mt7996_phy *)mphy->priv;
+
+	switch (le16_to_cpu(event->basic.tag)) {
+	case UNI_EVENT_SR_CFG_SR_ENABLE:
+		phy->sr_enable = le32_to_cpu(event->value) ? true : false;
+		break;
+	case UNI_EVENT_SR_HW_ESR_ENABLE:
+		phy->enhanced_sr_enable = le32_to_cpu(event->value) ? true : false;
+		break;
+	case UNI_EVENT_SR_SW_SD:
+		mt7996_mcu_rx_sr_swsd(dev, skb);
+		break;
+	case UNI_EVENT_SR_HW_IND:
+		mt7996_mcu_rx_sr_hw_indicator(dev, skb);
+		break;
+	default:
+		dev_info(dev->mt76.dev, "Unknown SR event tag %d\n",
+			 le16_to_cpu(event->basic.tag));
+	}
+}
+
+int mt7996_mcu_set_dup_wtbl(struct mt7996_dev *dev)
+{
+#define CHIP_CONFIG_DUP_WTBL	4
+#define DUP_WTBL_NUM	80
+	struct {
+		u8 _rsv[4];
+
+		__le16 tag;
+		__le16 len;
+		__le16 base;
+		__le16 num;
+		u8 _rsv2[4];
+	} __packed req = {
+		.tag = cpu_to_le16(CHIP_CONFIG_DUP_WTBL),
+		.len = cpu_to_le16(sizeof(req) - 4),
+		.base = cpu_to_le16(MT7996_WTBL_STA - DUP_WTBL_NUM + 1),
+		.num = cpu_to_le16(DUP_WTBL_NUM),
+	};
+
+	return mt76_mcu_send_msg(&dev->mt76, MCU_WM_UNI_CMD(CHIP_CONFIG), &req,
+				 sizeof(req), true);
+}
+
+static struct tlv *
+__mt7996_mcu_add_uni_tlv(struct sk_buff *skb, u16 tag, u16 len)
+{
+	struct tlv *ptlv, tlv = {
+		.tag = cpu_to_le16(tag),
+		.len = cpu_to_le16(len),
+	};
+
+	ptlv = skb_put(skb, len);
+	memcpy(ptlv, &tlv, sizeof(tlv));
+
+	return ptlv;
+}
+
+int mt7996_mcu_set_txbf_internal(struct mt7996_phy *phy, u8 action, int idx, bool bfer)
+{
+	struct mt7996_dev *dev = phy->dev;
+#define MT7996_MTK_BF_MAX_SIZE	sizeof(struct bf_starec_read)
+	struct uni_header hdr;
+	struct sk_buff *skb;
+	struct tlv *tlv;
+	int len = sizeof(hdr) + MT7996_MTK_BF_MAX_SIZE;
+
+	memset(&hdr, 0, sizeof(hdr));
+
+	skb = mt76_mcu_msg_alloc(&dev->mt76, NULL, len);
+	if (!skb)
+		return -ENOMEM;
+
+	skb_put_data(skb, &hdr, sizeof(hdr));
+
+	switch (action) {
+	case BF_PFMU_TAG_READ: {
+		struct bf_pfmu_tag *req;
+
+		tlv = __mt7996_mcu_add_uni_tlv(skb, action, sizeof(*req));
+		req = (struct bf_pfmu_tag *)tlv;
+		req->pfmu_id = idx;
+		req->bfer = bfer;
+		req->band_idx = phy->mt76->band_idx;
+		break;
+	}
+	case BF_STA_REC_READ: {
+		struct bf_starec_read *req;
+
+		tlv = __mt7996_mcu_add_uni_tlv(skb, action, sizeof(*req));
+		req = (struct bf_starec_read *)tlv;
+		req->wlan_idx = idx;
+		break;
+	}
+	case BF_FBRPT_DBG_INFO_READ: {
+		struct bf_fbk_rpt_info *req;
+
+		if (idx != 0) {
+			dev_info(dev->mt76.dev, "Invalid input");
+			return 0;
+		}
+
+		tlv = __mt7996_mcu_add_uni_tlv(skb, action, sizeof(*req));
+		req = (struct bf_fbk_rpt_info *)tlv;
+		req->action = idx;
+		req->band_idx = phy->mt76->band_idx;
+		break;
+	}
+	default:
+		return -EINVAL;
+	}
+
+	return mt76_mcu_skb_send_msg(&phy->dev->mt76, skb, MCU_WM_UNI_CMD(BF), false);
+}
+
+int mt7996_mcu_set_txbf_snd_info(struct mt7996_phy *phy, void *para)
+{
+	char *buf = (char *)para;
+	__le16 input[5] = {0};
+	u8 recv_arg = 0;
+	struct bf_txsnd_info *req;
+	struct uni_header hdr;
+	struct sk_buff *skb;
+	struct tlv *tlv;
+	int len = sizeof(hdr) + MT7996_MTK_BF_MAX_SIZE;
+
+	memset(&hdr, 0, sizeof(hdr));
+
+	skb = mt76_mcu_msg_alloc(&phy->dev->mt76, NULL, len);
+	if (!skb)
+		return -ENOMEM;
+
+	skb_put_data(skb, &hdr, sizeof(hdr));
+
+	recv_arg = sscanf(buf, "%hx:%hx:%hx:%hx:%hx", &input[0], &input[1], &input[2],
+						      &input[3], &input[4]);
+
+	if (!recv_arg)
+		return -EINVAL;
+
+	tlv = __mt7996_mcu_add_uni_tlv(skb, BF_TXSND_INFO, sizeof(*req));
+	req = (struct bf_txsnd_info *)tlv;
+	req->action = input[0];
+
+	switch (req->action) {
+	case BF_SND_READ_INFO: {
+		req->read_clr = input[1];
+		break;
+	}
+	case BF_SND_CFG_OPT: {
+		req->vht_opt = input[1];
+		req->he_opt = input[2];
+		req->glo_opt = input[3];
+		break;
+	}
+	case BF_SND_CFG_INTV: {
+		req->wlan_idx = input[1];
+		req->snd_intv = input[2];
+		break;
+	}
+	case BF_SND_STA_STOP: {
+		req->wlan_idx = input[1];
+		req->snd_stop = input[2];
+		break;
+	}
+	case BF_SND_CFG_MAX_STA: {
+		req->max_snd_stas = input[1];
+		break;
+	}
+	case BF_SND_CFG_BFRP: {
+		req->man = input[1];
+		req->tx_time = input[2];
+		req->mcs = input[3];
+		req->ldpc = input[4];
+		break;
+	}
+	case BF_SND_CFG_INF: {
+		req->inf = input[1];
+		break;
+	}
+	case BF_SND_CFG_TXOP_SND: {
+		req->man = input[1];
+		req->ac_queue = input[2];
+		req->sxn_protect = input[3];
+		req->direct_fbk = input[4];
+		break;
+	}
+	default:
+		return -EINVAL;
+	}
+
+	return mt76_mcu_skb_send_msg(&phy->dev->mt76, skb, MCU_WM_UNI_CMD(BF), false);
+}
+
+static inline void
+mt7996_ibf_phase_assign(struct mt7996_dev *dev,
+			struct mt7996_ibf_cal_info *cal,
+			struct mt7996_txbf_phase *phase)
+{
+	/* fw return ibf calibrated data with
+	 * the mt7996_txbf_phase_info_5g struct for both 2G and 5G.
+	 * (return struct mt7992_txbf_phase_info_5g for ibf 2.0)
+	 * Therefore, memcpy cannot be used here.
+	 */
+	if (get_ibf_version(dev) != IBF_VER_2) {
+		phase_assign(cal->group, v1, m_t0_h, true);
+		phase_assign(cal->group, v1, m_t1_h, true);
+		phase_assign(cal->group, v1, m_t2_h, true);
+		phase_assign(cal->group, v1, m_t2_h_sx2, false);
+		phase_assign_rx_v1(cal->group, v1, r0);
+		phase_assign_rx_v1(cal->group, v1, r1);
+		phase_assign_rx_v1(cal->group, v1, r2);
+		phase_assign_rx_v1(cal->group, v1, r3);
+		phase_assign_rx(cal->group, v1, r2_sx2, false);
+		phase_assign_rx(cal->group, v1, r3_sx2, false);
+		phase_assign(cal->group, v1, r0_reserved, false);
+		phase_assign(cal->group, v1, r1_reserved, false);
+		phase_assign(cal->group, v1, r2_reserved, false);
+		phase_assign(cal->group, v1, r3_reserved, false);
+		phase_assign(cal->group, v1, r2_sx2_reserved, false);
+		phase_assign(cal->group, v1, r3_sx2_reserved, false);
+	} else {
+		phase_assign(cal->group, v2, m_t0_h, true);
+		phase_assign(cal->group, v2, m_t1_h, true);
+		phase_assign(cal->group, v2, m_t2_h, true);
+		if (cal->group) {
+			phase->v2.phase_5g.m_t3_h = cal->v2.phase_5g.m_t3_h;
+			dev_info(dev->mt76.dev, "m_t3_h = %d\n", phase->v2.phase_5g.m_t3_h);
+		}
+		phase_assign_rx_ext(cal->group, v2, r0, true);
+		phase_assign_rx_ext(cal->group, v2, r1, true);
+		phase_assign_rx_ext(cal->group, v2, r2, true);
+		phase_assign_rx_ext(cal->group, v2, r3, true);
+		if (cal->group) {
+			memcpy(&phase->v2.phase_5g.r4, &cal->v2.phase_5g.r4,
+			       sizeof(struct txbf_rx_phase_ext));
+			dev_info(dev->mt76.dev, "r4.rx_uh = %d\n", phase->v2.phase_5g.r4.rx_uh);
+			dev_info(dev->mt76.dev, "r4.rx_h = %d\n", phase->v2.phase_5g.r4.rx_h);
+			dev_info(dev->mt76.dev, "r4.rx_mh = %d\n", phase->v2.phase_5g.r4.rx_mh);
+			dev_info(dev->mt76.dev, "r4.rx_m = %d\n", phase->v2.phase_5g.r4.rx_m);
+			dev_info(dev->mt76.dev, "r4.rx_l = %d\n", phase->v2.phase_5g.r4.rx_l);
+			dev_info(dev->mt76.dev, "r4.rx_ul = %d\n", phase->v2.phase_5g.r4.rx_ul);
+		}
+	}
+}
+
+void
+mt7996_mcu_rx_bf_event(struct mt7996_dev *dev, struct sk_buff *skb)
+{
+	struct mt7996_mcu_bf_basic_event *event;
+
+	event = (struct mt7996_mcu_bf_basic_event *)skb->data;
+
+	dev_info(dev->mt76.dev, " bf_event tag = %d\n", event->tag);
+
+	switch (event->tag) {
+	case UNI_EVENT_BF_PFMU_TAG: {
+
+		struct mt7996_pfmu_tag_event *tag;
+		u32 *raw_t1, *raw_t2;
+
+		tag = (struct mt7996_pfmu_tag_event *) skb->data;
+
+		raw_t1 = (u32 *)&tag->t1;
+		raw_t2 = (u32 *)&tag->t2;
+
+		dev_info(dev->mt76.dev, "=================== TXBf Profile Tag1 Info ==================\n");
+		dev_info(dev->mt76.dev,
+			 "DW0 = 0x%08x, DW1 = 0x%08x, DW2 = 0x%08x\n",
+			 raw_t1[0], raw_t1[1], raw_t1[2]);
+		dev_info(dev->mt76.dev,
+			 "DW4 = 0x%08x, DW5 = 0x%08x, DW6 = 0x%08x\n\n",
+			 raw_t1[3], raw_t1[4], raw_t1[5]);
+		dev_info(dev->mt76.dev, "PFMU ID = %d              Invalid status = %d\n",
+			 tag->t1.pfmu_idx, tag->t1.invalid_prof);
+		dev_info(dev->mt76.dev, "iBf/eBf = %d\n\n", tag->t1.ebf);
+		dev_info(dev->mt76.dev, "DBW   = %d\n", tag->t1.data_bw);
+		dev_info(dev->mt76.dev, "SU/MU = %d\n", tag->t1.is_mu);
+		dev_info(dev->mt76.dev,
+			 "nrow = %d, ncol = %d, ng = %d, LM = %d, CodeBook = %d MobCalEn = %d\n",
+			 tag->t1.nr, tag->t1.nc, tag->t1.ngroup, tag->t1.lm, tag->t1.codebook,
+			 tag->t1.mob_cal_en);
+
+		if (tag->t1.lm <= BF_LM_HE)
+			dev_info(dev->mt76.dev, "RU start = %d, RU end = %d\n",
+				 tag->t1.field.ru_start_id, tag->t1.field.ru_end_id);
+		else
+			dev_info(dev->mt76.dev, "PartialBW = %d\n",
+				 tag->t1.bw_info.partial_bw_info);
+
+		dev_info(dev->mt76.dev, "Mem Col1 = %d, Mem Row1 = %d, Mem Col2 = %d, Mem Row2 = %d\n",
+			 tag->t1.col_id1, tag->t1.row_id1, tag->t1.col_id2, tag->t1.row_id2);
+		dev_info(dev->mt76.dev, "Mem Col3 = %d, Mem Row3 = %d, Mem Col4 = %d, Mem Row4 = %d\n\n",
+			 tag->t1.col_id3, tag->t1.row_id3, tag->t1.col_id4, tag->t1.row_id4);
+		dev_info(dev->mt76.dev,
+			 "STS0_SNR = 0x%02x, STS1_SNR = 0x%02x, STS2_SNR = 0x%02x, STS3_SNR = 0x%02x\n",
+			 tag->t1.snr_sts0, tag->t1.snr_sts1, tag->t1.snr_sts2, tag->t1.snr_sts3);
+		dev_info(dev->mt76.dev,
+			 "STS4_SNR = 0x%02x, STS5_SNR = 0x%02x, STS6_SNR = 0x%02x, STS7_SNR = 0x%02x\n",
+			 tag->t1.snr_sts4, tag->t1.snr_sts5, tag->t1.snr_sts6, tag->t1.snr_sts7);
+		dev_info(dev->mt76.dev, "=============================================================\n");
+
+		dev_info(dev->mt76.dev, "=================== TXBf Profile Tag2 Info ==================\n");
+		dev_info(dev->mt76.dev,
+			 "DW0 = 0x%08x, DW1 = 0x%08x, DW2 = 0x%08x\n",
+			 raw_t2[0], raw_t2[1], raw_t2[2]);
+		dev_info(dev->mt76.dev,
+			 "DW3 = 0x%08x, DW4 = 0x%08x, DW5 = 0x%08x\n\n",
+			 raw_t2[3], raw_t2[4], raw_t2[5]);
+		dev_info(dev->mt76.dev, "Smart antenna ID = 0x%x,  SE index = %d\n",
+			 tag->t2.smart_ant, tag->t2.se_idx);
+		dev_info(dev->mt76.dev, "Timeout = 0x%x\n", tag->t2.ibf_timeout);
+		dev_info(dev->mt76.dev, "Desired BW = %d, Desired Ncol = %d, Desired Nrow = %d\n",
+			 tag->t2.ibf_data_bw, tag->t2.ibf_nc, tag->t2.ibf_nr);
+		dev_info(dev->mt76.dev, "Desired RU Allocation = %d\n", tag->t2.ibf_ru);
+		dev_info(dev->mt76.dev, "Mobility DeltaT = %d, Mobility LQ = %d\n",
+			 tag->t2.mob_delta_t, tag->t2.mob_lq_result);
+		dev_info(dev->mt76.dev, "=============================================================\n");
+		break;
+	}
+	case UNI_EVENT_BF_STAREC: {
+
+		struct mt7996_mcu_bf_starec_read *r;
+
+		r = (struct mt7996_mcu_bf_starec_read *)skb->data;
+		dev_info(dev->mt76.dev, "=================== BF StaRec ===================\n"
+					"rStaRecBf.u2PfmuId      = %d\n"
+					"rStaRecBf.fgSU_MU       = %d\n"
+					"rStaRecBf.u1TxBfCap     = %d\n"
+					"rStaRecBf.ucSoundingPhy = %d\n"
+					"rStaRecBf.ucNdpaRate    = %d\n"
+					"rStaRecBf.ucNdpRate     = %d\n"
+					"rStaRecBf.ucReptPollRate= %d\n"
+					"rStaRecBf.ucTxMode      = %d\n"
+					"rStaRecBf.ucNc          = %d\n"
+					"rStaRecBf.ucNr          = %d\n"
+					"rStaRecBf.ucCBW         = %d\n"
+					"rStaRecBf.ucMemRequire20M = %d\n"
+					"rStaRecBf.ucMemRow0     = %d\n"
+					"rStaRecBf.ucMemCol0     = %d\n"
+					"rStaRecBf.ucMemRow1     = %d\n"
+					"rStaRecBf.ucMemCol1     = %d\n"
+					"rStaRecBf.ucMemRow2     = %d\n"
+					"rStaRecBf.ucMemCol2     = %d\n"
+					"rStaRecBf.ucMemRow3     = %d\n"
+					"rStaRecBf.ucMemCol3     = %d\n",
+					r->pfmu_id,
+					r->is_su_mu,
+					r->txbf_cap,
+					r->sounding_phy,
+					r->ndpa_rate,
+					r->ndp_rate,
+					r->rpt_poll_rate,
+					r->tx_mode,
+					r->nc,
+					r->nr,
+					r->bw,
+					r->mem_require_20m,
+					r->mem_row0,
+					r->mem_col0,
+					r->mem_row1,
+					r->mem_col1,
+					r->mem_row2,
+					r->mem_col2,
+					r->mem_row3,
+					r->mem_col3);
+
+		dev_info(dev->mt76.dev, "rStaRecBf.u2SmartAnt    = 0x%x\n"
+					"rStaRecBf.ucSEIdx       = %d\n"
+					"rStaRecBf.uciBfTimeOut  = 0x%x\n"
+					"rStaRecBf.uciBfDBW      = %d\n"
+					"rStaRecBf.uciBfNcol     = %d\n"
+					"rStaRecBf.uciBfNrow     = %d\n"
+					"rStaRecBf.nr_bw160      = %d\n"
+					"rStaRecBf.nc_bw160 	  = %d\n"
+					"rStaRecBf.ru_start_idx  = %d\n"
+					"rStaRecBf.ru_end_idx 	  = %d\n"
+					"rStaRecBf.trigger_su 	  = %d\n"
+					"rStaRecBf.trigger_mu 	  = %d\n"
+					"rStaRecBf.ng16_su 	  = %d\n"
+					"rStaRecBf.ng16_mu 	  = %d\n"
+					"rStaRecBf.codebook42_su = %d\n"
+					"rStaRecBf.codebook75_mu = %d\n"
+					"rStaRecBf.he_ltf 	      = %d\n"
+					"======================================\n",
+					r->smart_ant,
+					r->se_idx,
+					r->bf_timeout,
+					r->bf_dbw,
+					r->bf_ncol,
+					r->bf_nrow,
+					r->nr_lt_bw80,
+					r->nc_lt_bw80,
+					r->ru_start_idx,
+					r->ru_end_idx,
+					r->trigger_su,
+					r->trigger_mu,
+					r->ng16_su,
+					r->ng16_mu,
+					r->codebook42_su,
+					r->codebook75_mu,
+					r->he_ltf);
+		break;
+	}
+	case UNI_EVENT_BF_FBK_INFO: {
+		struct mt7996_mcu_txbf_fbk_info *info;
+		__le32 total, i;
+
+		info = (struct mt7996_mcu_txbf_fbk_info *)skb->data;
+
+		total = info->u4PFMUWRDoneCnt + info->u4PFMUWRFailCnt;
+		total += info->u4PFMUWRTimeoutFreeCnt + info->u4FbRptPktDropCnt;
+
+		dev_info(dev->mt76.dev, "\n");
+		dev_info(dev->mt76.dev, "\x1b[32m =================================\x1b[m\n");
+		dev_info(dev->mt76.dev, "\x1b[32m PFMUWRDoneCnt              = %u\x1b[m\n",
+			info->u4PFMUWRDoneCnt);
+		dev_info(dev->mt76.dev, "\x1b[32m PFMUWRFailCnt              = %u\x1b[m\n",
+			info->u4PFMUWRFailCnt);
+		dev_info(dev->mt76.dev, "\x1b[32m PFMUWRTimeOutCnt           = %u\x1b[m\n",
+			info->u4PFMUWRTimeOutCnt);
+		dev_info(dev->mt76.dev, "\x1b[32m PFMUWRTimeoutFreeCnt       = %u\x1b[m\n",
+			info->u4PFMUWRTimeoutFreeCnt);
+		dev_info(dev->mt76.dev, "\x1b[32m FbRptPktDropCnt            = %u\x1b[m\n",
+			info->u4FbRptPktDropCnt);
+		dev_info(dev->mt76.dev, "\x1b[32m TotalFbRptPkt              = %u\x1b[m\n", total);
+		dev_info(dev->mt76.dev, "\x1b[32m PollPFMUIntrStatTimeOut    = %u(micro-sec)\x1b[m\n",
+			info->u4PollPFMUIntrStatTimeOut);
+		dev_info(dev->mt76.dev, "\x1b[32m FbRptDeQInterval           = %u(milli-sec)\x1b[m\n",
+			info->u4DeQInterval);
+		dev_info(dev->mt76.dev, "\x1b[32m PktCntInFbRptTimeOutQ      = %u\x1b[m\n",
+			info->u4RptPktTimeOutListNum);
+		dev_info(dev->mt76.dev, "\x1b[32m PktCntInFbRptQ             = %u\x1b[m\n",
+			info->u4RptPktListNum);
+
+		// [ToDo] Check if it is valid entry
+		for (i = 0; ((i < 5) && (i < CFG_BF_STA_REC_NUM)); i++) {
+
+			// [ToDo] AID needs to be refined
+			dev_info(dev->mt76.dev,"\x1b[32m AID%u  RxFbRptCnt           = %u\x1b[m\n"
+				, i, info->au4RxPerStaFbRptCnt[i]);
+		}
+
+		break;
+	}
+	case UNI_EVENT_BF_TXSND_INFO: {
+		struct mt7996_mcu_tx_snd_info *info;
+		struct uni_event_bf_txsnd_sta_info *snd_sta_info;
+		int Idx;
+		int max_wtbl_size = mt7996_wtbl_size(dev);
+
+		info = (struct mt7996_mcu_tx_snd_info *)skb->data;
+		dev_info(dev->mt76.dev, "=================== Global Setting ===================\n");
+
+		dev_info(dev->mt76.dev, "VhtOpt = 0x%02X, HeOpt = 0x%02X, GloOpt = 0x%02X\n",
+			info->vht_opt, info->he_opt, info->glo_opt);
+
+		for (Idx = 0; Idx < BF_SND_CTRL_STA_DWORD_CNT; Idx++) {
+			dev_info(dev->mt76.dev, "SuSta[%d] = 0x%08X,", Idx,
+				 info->snd_rec_su_sta[Idx]);
+			if ((Idx & 0x03) == 0x03)
+				dev_info(dev->mt76.dev, "\n");
+		}
+
+		if ((Idx & 0x03) != 0x03)
+			dev_info(dev->mt76.dev, "\n");
+
+
+		for (Idx = 0; Idx < BF_SND_CTRL_STA_DWORD_CNT; Idx++) {
+			dev_info(dev->mt76.dev, "VhtMuSta[%d] = 0x%08X,", Idx, info->snd_rec_vht_mu_sta[Idx]);
+			if ((Idx & 0x03) == 0x03)
+				dev_info(dev->mt76.dev, "\n");
+		}
+
+		if ((Idx & 0x03) != 0x03)
+			dev_info(dev->mt76.dev, "\n");
+
+		for (Idx = 0; Idx < BF_SND_CTRL_STA_DWORD_CNT; Idx++) {
+			dev_info(dev->mt76.dev, "HeTBSta[%d] = 0x%08X,", Idx, info->snd_rec_he_tb_sta[Idx]);
+			if ((Idx & 0x03) == 0x03)
+				dev_info(dev->mt76.dev, "\n");
+		}
+
+		if ((Idx & 0x03) != 0x03)
+			dev_info(dev->mt76.dev, "\n");
+
+		for (Idx = 0; Idx < BF_SND_CTRL_STA_DWORD_CNT; Idx++) {
+			dev_info(dev->mt76.dev, "EhtTBSta[%d] = 0x%08X,", Idx, info->snd_rec_eht_tb_sta[Idx]);
+			if ((Idx & 0x03) == 0x03)
+				dev_info(dev->mt76.dev, "\n");
+		}
+
+		if ((Idx & 0x03) != 0x03)
+			dev_info(dev->mt76.dev, "\n");
+
+		for (Idx = 0; Idx < CFG_WIFI_RAM_BAND_NUM; Idx++) {
+			dev_info(dev->mt76.dev, "Band%u:\n", Idx);
+			dev_info(dev->mt76.dev, "	 Wlan Idx For VHT MC Sounding = %u\n", info->wlan_idx_for_mc_snd[Idx]);
+			dev_info(dev->mt76.dev, "	 Wlan Idx For HE TB Sounding = %u\n", info->wlan_idx_for_he_tb_snd[Idx]);
+			dev_info(dev->mt76.dev, "	 Wlan Idx For EHT TB Sounding = %u\n", info->wlan_idx_for_eht_tb_snd[Idx]);
+		}
+
+		dev_info(dev->mt76.dev, "ULLen = %d, ULMcs = %d, ULLDCP = %d\n",
+			info->ul_length, info->mcs, info->ldpc);
+
+		dev_info(dev->mt76.dev, "=================== STA Info ===================\n");
+
+		for (Idx = 1; (Idx < 5 && (Idx < CFG_BF_STA_REC_NUM)); Idx++) {
+			snd_sta_info = &info->snd_sta_info[Idx];
+			dev_info(dev->mt76.dev, "Idx%2u Interval = %d, interval counter = %d, TxCnt = %d, StopReason = 0x%02X\n",
+				Idx,
+				snd_sta_info->snd_intv,
+				snd_sta_info->snd_intv_cnt,
+				snd_sta_info->snd_tx_cnt,
+				snd_sta_info->snd_stop_reason);
+		}
+
+		dev_info(dev->mt76.dev, "=================== STA Info Connected ===================\n");
+		// [ToDo] How to iterate and get AID info of station
+		// Check UniEventBFCtrlTxSndHandle() on Logan
+
+		//hardcode max_wtbl_size as 5
+		max_wtbl_size = 5;
+		for (Idx = 1; ((Idx < max_wtbl_size) && (Idx < CFG_BF_STA_REC_NUM)); Idx++) {
+
+			// [ToDo] We do not show AID info here
+			snd_sta_info = &info->snd_sta_info[Idx];
+			dev_info(dev->mt76.dev, " Interval = %d (%u ms), interval counter = %d (%u ms), TxCnt = %d, StopReason = 0x%02X\n",
+				snd_sta_info->snd_intv,
+				snd_sta_info->snd_intv * 10,
+				snd_sta_info->snd_intv_cnt,
+				snd_sta_info->snd_intv_cnt * 10,
+				snd_sta_info->snd_tx_cnt,
+				snd_sta_info->snd_stop_reason);
+		}
+
+		dev_info(dev->mt76.dev, "======================================\n");
+
+		break;
+	}
+	case UNI_EVENT_BF_CAL_PHASE: {
+		struct mt7996_ibf_cal_info *cal;
+		struct mt7996_txbf_phase *phase;
+		union {
+			struct mt7996_txbf_phase_out v1;
+			struct mt7992_txbf_phase_out v2;
+		} phase_out;
+		int phase_out_size = sizeof(struct mt7996_txbf_phase_out);
+
+		cal = (struct mt7996_ibf_cal_info *)skb->data;
+		phase = (struct mt7996_txbf_phase *)dev->test.txbf_phase_cal;
+		if (get_ibf_version(dev) == IBF_VER_2)
+			phase_out_size = sizeof(struct mt7992_txbf_phase_out);
+		memcpy(&phase_out, &cal->buf, phase_out_size);
+		switch (cal->cal_type) {
+		case IBF_PHASE_CAL_NORMAL:
+		case IBF_PHASE_CAL_NORMAL_INSTRUMENT:
+			/* Only calibrate group M */
+			if (cal->group_l_m_n != GROUP_M)
+				break;
+			phase = &phase[cal->group];
+			phase->status = cal->status;
+			dev_info(dev->mt76.dev, "Calibrated result = %d\n", phase->status);
+			dev_info(dev->mt76.dev, "Group %d and Group M\n", cal->group);
+			mt7996_ibf_phase_assign(dev, cal, phase);
+			break;
+		case IBF_PHASE_CAL_VERIFY:
+		case IBF_PHASE_CAL_VERIFY_INSTRUMENT:
+			dev_info(dev->mt76.dev, "Verification result = %d\n", cal->status);
+			break;
+		default:
+			break;
+		}
+
+		if (get_ibf_version(dev) == IBF_VER_2) {
+			dev_info(dev->mt76.dev,
+				 "c0_uh = %d, c1_uh = %d, c2_uh = %d, c3_uh = %d c4_uh = %d\n",
+				 phase_out.v2.c0_uh, phase_out.v2.c1_uh, phase_out.v2.c2_uh,
+				 phase_out.v2.c3_uh, phase_out.v2.c4_uh);
+			dev_info(dev->mt76.dev,
+				 "c0_h = %d, c1_h = %d, c2_h = %d, c3_h = %d c4_h = %d\n",
+				 phase_out.v2.c0_h, phase_out.v2.c1_h, phase_out.v2.c2_h,
+				 phase_out.v2.c3_h, phase_out.v2.c4_h);
+			dev_info(dev->mt76.dev,
+				 "c0_mh = %d, c1_mh = %d, c2_mh = %d, c3_mh = %d c4_mh = %d\n",
+				 phase_out.v2.c0_mh, phase_out.v2.c1_mh, phase_out.v2.c2_mh,
+				 phase_out.v2.c3_mh, phase_out.v2.c4_mh);
+			dev_info(dev->mt76.dev,
+				 "c0_m = %d, c1_m = %d, c2_m = %d, c3_m = %d c4_m = %d\n",
+				 phase_out.v2.c0_m, phase_out.v2.c1_m, phase_out.v2.c2_m,
+				 phase_out.v2.c3_m, phase_out.v2.c4_m);
+			dev_info(dev->mt76.dev,
+				 "c0_l = %d, c1_l = %d, c2_l = %d, c3_l = %d c4_l = %d\n",
+				 phase_out.v2.c0_l, phase_out.v2.c1_l, phase_out.v2.c2_l,
+				 phase_out.v2.c3_l, phase_out.v2.c4_l);
+		} else {
+			dev_info(dev->mt76.dev,
+				 "c0_uh = %d, c1_uh = %d, c2_uh = %d, c3_uh = %d\n",
+				 phase_out.v1.c0_uh, phase_out.v1.c1_uh,
+				 phase_out.v1.c2_uh, phase_out.v1.c3_uh);
+			dev_info(dev->mt76.dev,
+				 "c0_h = %d, c1_h = %d, c2_h = %d, c3_h = %d\n",
+				 phase_out.v1.c0_h, phase_out.v1.c1_h,
+				 phase_out.v1.c2_h, phase_out.v1.c3_h);
+			dev_info(dev->mt76.dev,
+				 "c0_mh = %d, c1_mh = %d, c2_mh = %d, c3_mh = %d\n",
+				 phase_out.v1.c0_mh, phase_out.v1.c1_mh,
+				 phase_out.v1.c2_mh, phase_out.v1.c3_mh);
+			dev_info(dev->mt76.dev,
+				 "c0_m = %d, c1_m = %d, c2_m = %d, c3_m = %d\n",
+				 phase_out.v1.c0_m, phase_out.v1.c1_m,
+				 phase_out.v1.c2_m, phase_out.v1.c3_m);
+			dev_info(dev->mt76.dev,
+				 "c0_l = %d, c1_l = %d, c2_l = %d, c3_l = %d\n",
+				 phase_out.v1.c0_l, phase_out.v1.c1_l,
+				 phase_out.v1.c2_l, phase_out.v1.c3_l);
+		}
+
+		break;
+	}
+	default:
+		dev_info(dev->mt76.dev, "%s: unknown bf event tag %d\n",
+			 __func__, event->tag);
+	}
+
+}
+
+
+int mt7996_mcu_set_muru_fixed_rate_enable(struct mt7996_dev *dev, u8 action, int val)
+{
+	struct {
+		u8 _rsv[4];
+
+		__le16 tag;
+		__le16 len;
+
+		__le16 value;
+		__le16 rsv;
+	} __packed data = {
+		.tag = cpu_to_le16(action),
+		.len = cpu_to_le16(sizeof(data) - 4),
+		.value = cpu_to_le16(!!val),
+	};
+
+	return mt76_mcu_send_msg(&dev->mt76, MCU_WM_UNI_CMD(MURU), &data, sizeof(data),
+				 false);
+}
+
+int mt7996_mcu_set_muru_fixed_rate_parameter(struct mt7996_dev *dev, u8 action, void *para)
+{
+	char *buf = (char *)para;
+	u8 num_user = 0, recv_arg = 0, max_mcs = 0, usr_mcs[4] = {0};
+	__le16 bw;
+	int i;
+	struct {
+		u8 _rsv[4];
+
+		__le16 tag;
+		__le16 len;
+
+		u8 cmd_version;
+		u8 cmd_revision;
+		__le16 rsv;
+
+		struct uni_muru_mum_set_group_tbl_entry entry;
+	} __packed data = {
+		.tag = cpu_to_le16(action),
+		.len = cpu_to_le16(sizeof(data) - 4),
+	};
+
+#define __RUALLOC_TYPE_CHECK_HE(BW) ((BW == RUALLOC_BW20) || (BW == RUALLOC_BW40) || (BW == RUALLOC_BW80) || (BW == RUALLOC_BW160))
+#define __RUALLOC_TYPE_CHECK_EHT(BW) (__RUALLOC_TYPE_CHECK_HE(BW) || (BW == RUALLOC_BW320))
+	/* [Num of user] - 1~4
+	 * [RUAlloc] - BW320: 395, BW160: 137, BW80: 134, BW40: 130, BW20: 122
+	 * [LTF/GI] - For VHT, short GI: 0, Long GI: 1; 	 *
+	 * For HE/EHT, 4xLTF+3.2us: 0, 4xLTF+0.8us: 1, 2xLTF+0.8us:2
+	 * [Phy/FullBW] - VHT: 0 / HEFullBw: 1 / HEPartialBw: 2 / EHTFullBW: 3, EHTPartialBW: 4
+	 * [DL/UL] DL: 0, UL: 1, DL_UL: 2
+	 * [Wcid User0] - WCID 0
+	 * [MCS of WCID0] - For HE/VHT, 0-11: 1ss MCS0-MCS11, 12-23: 2SS MCS0-MCS11
+	 * For EHT, 0-13: 1ss MCS0-MCS13, 14-27: 2SS MCS0-MCS13
+	 * [WCID 1]
+	 * [MCS of WCID1]
+	 * [WCID 2]
+	 * [MCS of WCID2]
+	 * [WCID 3]
+	 * [MCS of WCID3]
+	 */
+
+	recv_arg = sscanf(buf, "%hhu %hu %hhu %hhu %hhu %hu %hhu %hu %hhu %hu %hhu %hu %hhu",
+			  &num_user, &bw, &data.entry.gi, &data.entry.capa, &data.entry.dl_ul,
+			  &data.entry.wlan_idx0, &usr_mcs[0],
+			  &data.entry.wlan_idx1, &usr_mcs[1],
+			  &data.entry.wlan_idx2, &usr_mcs[2],
+			  &data.entry.wlan_idx3, &usr_mcs[3]);
+
+	if (recv_arg != (5 + (2 * num_user))) {
+		dev_err(dev->mt76.dev, "The number of argument is invalid\n");
+		goto error;
+	}
+
+	if (num_user > 0 && num_user < 5)
+		data.entry.num_user = num_user - 1;
+	else {
+		dev_err(dev->mt76.dev, "The number of user count is invalid\n");
+		goto error;
+	}
+
+	/**
+	 * Older chip shall be set as HE. Refer to getHWSupportByChip() in Logan
+	 * driver to know the value for differnt chips
+	 */
+	data.cmd_version = UNI_CMD_MURU_VER_EHT;
+
+	if (data.cmd_version == UNI_CMD_MURU_VER_EHT)
+		max_mcs = UNI_MAX_MCS_SUPPORT_EHT;
+	else
+		max_mcs = UNI_MAX_MCS_SUPPORT_HE;
+
+
+	// Parameter Check
+	if (data.cmd_version != UNI_CMD_MURU_VER_EHT) {
+		if ((data.entry.capa > MAX_MODBF_HE) || (bw == RUALLOC_BW320))
+			goto error;
+	} else {
+		if ((data.entry.capa <= MAX_MODBF_HE) && (bw == RUALLOC_BW320))
+			goto error;
+	}
+
+	if (data.entry.capa <= MAX_MODBF_HE)
+		max_mcs = UNI_MAX_MCS_SUPPORT_HE;
+
+	if (__RUALLOC_TYPE_CHECK_EHT(bw)) {
+		data.entry.ru_alloc = (u8)(bw & 0xFF);
+		if (bw == RUALLOC_BW320)
+			data.entry.ru_alloc_ext = (u8)(bw >> 8);
+	} else {
+		dev_err(dev->mt76.dev, "RU_ALLOC argument is invalid\n");
+		goto error;
+	}
+
+	if ((data.entry.gi > 2) ||
+	    ((data.entry.gi > 1) && (data.entry.capa == MAX_MODBF_VHT))) {
+		dev_err(dev->mt76.dev, "GI argument is invalid\n");
+		goto error;
+	}
+
+	if (data.entry.dl_ul > 2) {
+		dev_err(dev->mt76.dev, "DL_UL argument is invalid\n");
+		goto error;
+	}
+
+#define __mcs_handler(_n)							\
+	do {									\
+		if (usr_mcs[_n] > max_mcs) {					\
+			usr_mcs[_n] -= (max_mcs + 1);				\
+			data.entry.nss##_n = 1;					\
+			if (usr_mcs[_n] > max_mcs)				\
+				usr_mcs[_n] = max_mcs;				\
+		}								\
+		if ((data.entry.dl_ul & 0x1) == 0)				\
+			data.entry.dl_mcs_user##_n = usr_mcs[_n];		\
+		if ((data.entry.dl_ul & 0x3) > 0)				\
+			data.entry.ul_mcs_user##_n = usr_mcs[_n];		\
+	}									\
+	while (0)
+
+	for (i=0; i<= data.entry.num_user; i++) {
+		switch (i) {
+			case 0:
+				__mcs_handler(0);
+				break;
+			case 1:
+				__mcs_handler(1);
+				break;
+			case 2:
+				__mcs_handler(2);
+				break;
+			case 3:
+				__mcs_handler(3);
+				break;
+			default:
+				break;
+		}
+	}
+#undef __mcs_handler
+
+
+	return mt76_mcu_send_msg(&dev->mt76, MCU_WM_UNI_CMD(MURU), &data,
+				 sizeof(data), false);
+
+error:
+	dev_err(dev->mt76.dev, "Command failed!\n");
+	return -EINVAL;
+}
+
+/**
+ * This function can be used to build the following commands
+ * MURU_SUTX_CTRL (0x10)
+ * SET_FORCE_MU (0x33)
+ * SET_MUDL_ACK_POLICY (0xC8)
+ * SET_TRIG_TYPE (0xC9)
+ * SET_20M_DYN_ALGO (0xCA)
+ * SET_CERT_MU_EDCA_OVERRIDE (0xCD)
+ */
+int mt7996_mcu_set_muru_cmd(struct mt7996_dev *dev, u16 action, int val)
+{
+	struct {
+		u8 _rsv[4];
+
+		__le16 tag;
+		__le16 len;
+
+		u8 config;
+		u8 rsv[3];
+	} __packed data = {
+		.tag = cpu_to_le16(action),
+		.len = cpu_to_le16(sizeof(data) - 4),
+		.config = (u8) val,
+	};
+
+	return mt76_mcu_send_msg(&dev->mt76, MCU_WM_UNI_CMD(MURU), &data, sizeof(data),
+				 false);
+}
+
+int mt7996_mcu_muru_set_prot_frame_thr(struct mt7996_dev *dev, u32 val)
+{
+	struct {
+		u8 _rsv[4];
+
+		__le16 tag;
+		__le16 len;
+
+		__le32 prot_frame_thr;
+	} __packed data = {
+		.tag = cpu_to_le16(UNI_CMD_MURU_PROT_FRAME_THR),
+		.len = cpu_to_le16(sizeof(data) - 4),
+		.prot_frame_thr = cpu_to_le32(val),
+	};
+
+	return mt76_mcu_send_msg(&dev->mt76, MCU_WM_UNI_CMD(MURU), &data, sizeof(data),
+				 false);
+}
+
+int mt7996_mcu_set_bypass_smthint(struct mt7996_phy *phy, u8 val)
+{
+#define BF_PHY_SMTH_INT_BYPASS 0
+#define BYPASS_VAL 1
+	struct mt7996_dev *dev = phy->dev;
+	struct {
+		u8 _rsv[4];
+
+		u16 tag;
+		u16 len;
+
+		u8 action;
+		u8 band_idx;
+		u8 smthintbypass;
+		u8 __rsv2[5];
+	} __packed data = {
+		.tag = cpu_to_le16(BF_CFG_PHY),
+		.len = cpu_to_le16(sizeof(data) - 4),
+		.action = BF_PHY_SMTH_INT_BYPASS,
+		.band_idx = phy->mt76->band_idx,
+		.smthintbypass = val,
+	};
+
+	if (val != BYPASS_VAL)
+		return -EINVAL;
+
+	return mt76_mcu_send_msg(&dev->mt76, MCU_WM_UNI_CMD(BF), &data, sizeof(data),
+				 true);
+}
+
+int mt7996_mcu_set_bsrp_ctrl(struct mt7996_phy *phy, u16 interval,
+			     u16 ru_alloc, u32 trig_type, u8 trig_flow, u8 ext_cmd)
+{
+	struct mt7996_dev *dev = phy->dev;
+	struct {
+		u8 _rsv[4];
+
+		__le16 tag;
+		__le16 len;
+
+		__le16 interval;
+		__le16 ru_alloc;
+		__le32 trigger_type;
+		u8 trigger_flow;
+		u8 ext_cmd_bsrp;
+		u8 band_bitmap;
+		u8 _rsv2;
+	} __packed req = {
+		.tag = cpu_to_le16(UNI_CMD_MURU_BSRP_CTRL),
+		.len = cpu_to_le16(sizeof(req) - 4),
+		.interval = cpu_to_le16(interval),
+		.ru_alloc = cpu_to_le16(ru_alloc),
+		.trigger_type = cpu_to_le32(trig_type),
+		.trigger_flow = trig_flow,
+		.ext_cmd_bsrp = ext_cmd,
+		.band_bitmap = mt7996_band_valid(dev, MT_BAND2) ?
+			       GENMASK(2, 0) : GENMASK(1, 0),
+	};
+
+	return mt76_mcu_send_msg(&dev->mt76, MCU_WM_UNI_CMD(MURU), &req,
+				 sizeof(req), false);
+}
+
+int mt7996_mcu_set_rfeature_trig_type(struct mt7996_phy *phy, u8 enable, u8 trig_type)
+{
+	struct mt7996_dev *dev = phy->dev;
+	int ret = 0;
+	char buf[] = "01:00:00:1B";
+
+	if (enable) {
+		ret = mt7996_mcu_set_muru_cmd(dev, UNI_CMD_MURU_SET_TRIG_TYPE, trig_type);
+		if (ret)
+			return ret;
+	}
+
+	switch (trig_type) {
+	case CAPI_BASIC:
+		return mt7996_mcu_set_bsrp_ctrl(phy, 5, 67, 0, 0, enable);
+	case CAPI_BRP:
+		return mt7996_mcu_set_txbf_snd_info(phy, buf);
+	case CAPI_MU_BAR:
+		return mt7996_mcu_set_muru_cmd(dev, UNI_CMD_MURU_SET_MUDL_ACK_POLICY,
+					       MU_DL_ACK_POLICY_MU_BAR);
+	case CAPI_BSRP:
+		return mt7996_mcu_set_bsrp_ctrl(phy, 5, 67, 4, 0, enable);
+	default:
+		return 0;
+	}
+}
+
+int mt7996_mcu_set_muru_cfg(struct mt7996_phy *phy, void *data)
+{
+	struct mt7996_dev *dev = phy->dev;
+	struct mt7996_muru *muru;
+	struct {
+		u8 _rsv[4];
+
+		__le16 tag;
+		__le16 len;
+
+		u8 version;
+		u8 revision;
+		u8 _rsv2[2];
+
+		struct mt7996_muru muru;
+	} __packed req = {
+		.tag = cpu_to_le16(UNI_CMD_MURU_MUNUAL_CONFIG),
+		.len = cpu_to_le16(sizeof(req) - 4),
+		.version = UNI_CMD_MURU_VER_EHT,
+	};
+
+	muru = (struct mt7996_muru *) data;
+	memcpy(&req.muru, muru, sizeof(struct mt7996_muru));
+
+	return mt76_mcu_send_msg(&dev->mt76, MCU_WM_UNI_CMD(MURU), &req,
+				 sizeof(req), false);
+}
+
+int mt7996_set_muru_cfg(struct mt7996_phy *phy, u8 action, u8 val)
+{
+	struct mt7996_muru *muru;
+	struct mt7996_muru_dl *dl;
+	struct mt7996_muru_ul *ul;
+	struct mt7996_muru_comm *comm;
+	int ret = 0;
+
+	muru = kzalloc(sizeof(struct mt7996_muru), GFP_KERNEL);
+	dl = &muru->dl;
+	ul = &muru->ul;
+	comm = &muru->comm;
+
+	switch (action) {
+	case MU_CTRL_DL_USER_CNT:
+		dl->user_num = val;
+		comm->ppdu_format = MURU_PPDU_HE_MU;
+		comm->sch_type = MURU_OFDMA_SCH_TYPE_DL;
+		muru->cfg_comm = cpu_to_le32(MURU_COMM_SET);
+		muru->cfg_dl = cpu_to_le32(MURU_FIXED_DL_TOTAL_USER_CNT);
+		ret = mt7996_mcu_set_muru_cfg(phy, muru);
+		break;
+	case MU_CTRL_UL_USER_CNT:
+		ul->user_num = val;
+		comm->ppdu_format = MURU_PPDU_HE_TRIG;
+		comm->sch_type = MURU_OFDMA_SCH_TYPE_UL;
+		muru->cfg_comm = cpu_to_le32(MURU_COMM_SET);
+		muru->cfg_ul = cpu_to_le32(MURU_FIXED_UL_TOTAL_USER_CNT);
+		ret = mt7996_mcu_set_muru_cfg(phy, muru);
+		break;
+	default:
+		break;
+	}
+
+	kfree(muru);
+	return ret;
+}
+
+void mt7996_mcu_set_ppdu_tx_type(struct mt7996_phy *phy, u8 ppdu_type)
+{
+	struct mt7996_dev *dev = phy->dev;
+	int enable_su;
+
+	switch (ppdu_type) {
+	case CAPI_SU:
+		enable_su = 1;
+		mt7996_mcu_set_muru_cmd(dev, UNI_CMD_MURU_SUTX_CTRL, enable_su);
+		mt7996_set_muru_cfg(phy, MU_CTRL_DL_USER_CNT, 0);
+		break;
+	case CAPI_MU:
+		enable_su = 0;
+		mt7996_mcu_set_muru_cmd(dev, UNI_CMD_MURU_SUTX_CTRL, enable_su);
+		break;
+	default:
+		break;
+	}
+}
+
+void mt7996_mcu_set_nusers_ofdma(struct mt7996_phy *phy, u8 type, u8 user_cnt)
+{
+	struct mt7996_dev *dev = phy->dev;
+	int enable_su = 0;
+
+	mt7996_mcu_set_muru_cmd(dev, UNI_CMD_MURU_SUTX_CTRL, enable_su);
+	mt7996_mcu_set_muru_cmd(dev, UNI_CMD_MURU_SET_MUDL_ACK_POLICY, MU_DL_ACK_POLICY_SU_BAR);
+	mt7996_mcu_muru_set_prot_frame_thr(dev, 9999);
+
+	mt7996_set_muru_cfg(phy, type, user_cnt);
+}
+
+void mt7996_mcu_set_mimo(struct mt7996_phy *phy)
+{
+	struct mt7996_dev *dev = phy->dev;
+	struct cfg80211_chan_def *chandef = &phy->mt76->chandef;
+	int disable_ra = 1;
+	char buf[] = "2 134 0 1 0 1 2 2 2";
+	int force_mu = 1;
+
+	switch (chandef->width) {
+	case NL80211_CHAN_WIDTH_20_NOHT:
+	case NL80211_CHAN_WIDTH_20:
+		strscpy(buf, "2 122 0 1 0 1 2 2 2", sizeof(buf));
+		break;
+	case NL80211_CHAN_WIDTH_80:
+		break;
+	case NL80211_CHAN_WIDTH_160:
+		strscpy(buf, "2 137 0 1 0 1 2 2 2", sizeof(buf));
+		break;
+	default:
+		break;
+	}
+
+	mt7996_mcu_set_muru_cmd(dev, UNI_CMD_MURU_SET_MUDL_ACK_POLICY, MU_DL_ACK_POLICY_SU_BAR);
+	mt7996_mcu_set_muru_fixed_rate_enable(dev, UNI_CMD_MURU_FIXED_RATE_CTRL, disable_ra);
+	mt7996_mcu_set_muru_fixed_rate_parameter(dev, UNI_CMD_MURU_FIXED_GROUP_RATE_CTRL, buf);
+	mt7996_mcu_set_muru_cmd(dev, UNI_CMD_MURU_SET_FORCE_MU, force_mu);
+}
+
+void mt7996_mcu_set_cert(struct mt7996_phy *phy, u8 type)
+{
+	struct mt7996_dev *dev = phy->dev;
+	struct {
+		u8 _rsv[4];
+
+		__le16 tag;
+		__le16 len;
+		u8 action;
+		u8 _rsv2[3];
+	} __packed req = {
+		.tag = cpu_to_le16(UNI_CMD_CERT_CFG),
+		.len = cpu_to_le16(sizeof(req) - 4),
+		.action = type, /* 1: CAPI Enable */
+	};
+
+	mt76_mcu_send_msg(&dev->mt76, MCU_WM_UNI_CMD(WSYS_CONFIG), &req,
+			  sizeof(req), false);
+}
+
+int mt7996_mcu_set_vow_drr_dbg(struct mt7996_dev *dev, u32 val)
+{
+#define MT7996_VOW_DEBUG_MODE	0xe
+	struct {
+		u8 __rsv1[4];
+
+		__le16 tag;
+		__le16 len;
+		u8 __rsv2[4];
+		__le32 action;
+		__le32 val;
+		u8 __rsv3[8];
+	} __packed req = {
+		.tag = cpu_to_le16(UNI_VOW_DRR_CTRL),
+		.len = cpu_to_le16(sizeof(req) - 4),
+		.action = cpu_to_le32(MT7996_VOW_DEBUG_MODE),
+		.val = cpu_to_le32(val),
+	};
+
+	if (val & ~VOW_DRR_DBG_FLAGS)
+		return -EINVAL;
+
+	return mt76_mcu_send_msg(&dev->mt76, MCU_WM_UNI_CMD(VOW), &req,
+				 sizeof(req), true);
+}
+
+int mt7996_mcu_thermal_debug(struct mt7996_dev *dev, u8 mode, u8 action)
+{
+	struct {
+		u8 __rsv1[4];
+
+		__le16 tag;
+		__le16 len;
+
+		u8 mode;
+		u8 action;
+		u8 __rsv2[2];
+	} __packed req = {
+		.tag = cpu_to_le16(mode),
+		.len = cpu_to_le16(sizeof(req) - 4),
+		.mode = mode,
+		.action = action,
+	};
+
+	return mt76_mcu_send_msg(&dev->mt76, MCU_WM_UNI_CMD(THERMAL_CAL), &req,
+	                         sizeof(req), true);
+}
+
+int mt7996_mcu_mlo_agc(struct mt7996_dev *dev, const void *data, int len)
+{
+	return mt76_mcu_send_msg(&dev->mt76, MCU_WM_UNI_CMD(MLO), data,
+	                        len, true);
+}
+#endif
diff --git a/mt7996/mtk_mcu.h b/mt7996/mtk_mcu.h
new file mode 100644
index 00000000..2cffc893
--- /dev/null
+++ b/mt7996/mtk_mcu.h
@@ -0,0 +1,1167 @@
+/* SPDX-License-Identifier: ISC */
+/*
+ * Copyright (C) 2023 MediaTek Inc.
+ */
+
+#ifndef __MT7996_MTK_MCU_H
+#define __MT7996_MTK_MCU_H
+
+#include "../mt76_connac_mcu.h"
+
+#ifdef CONFIG_MTK_DEBUG
+
+enum {
+	UNI_CMD_MURU_DBG_INFO = 0x18,
+};
+
+struct txpower_basic_info {
+	u8 category;
+	u8 rsv1;
+
+	/* basic info */
+	u8 band_idx;
+	u8 band;
+
+	/* board type info */
+	bool is_epa;
+	bool is_elna;
+
+	/* power percentage info */
+	bool percentage_ctrl_enable;
+	s8 power_drop_level;
+
+	/* frond-end loss TX info */
+	s8 front_end_loss_tx[4];
+
+	/* frond-end loss RX info */
+	s8 front_end_loss_rx[4];
+
+	/* thermal info */
+	bool thermal_compensate_enable;
+	s8 thermal_compensate_value;
+	u8 rsv2;
+
+	/* TX power max/min limit info */
+	s8 max_power_bound;
+	s8 min_power_bound;
+
+	/* power limit info */
+	bool sku_enable;
+	bool bf_backoff_enable;
+
+	/* MU TX power info */
+	bool mu_tx_power_manual_enable;
+	s8 mu_tx_power_auto;
+	s8 mu_tx_power_manual;
+	u8 rsv3;
+};
+
+struct txpower_phy_rate_info {
+	u8 category;
+	u8 band_idx;
+	u8 band;
+	u8 epa_gain;
+
+	/* rate power info [dBm] */
+	s8 frame_power[MT7996_SKU_RATE_NUM][__MT_MAX_BAND];
+
+	/* TX power max/min limit info */
+	s8 max_power_bound;
+	s8 min_power_bound;
+	u8 rsv1;
+};
+
+struct txpower_backoff_table_info {
+	u8 category;
+	u8 band_idx;
+	u8 band;
+	u8 backoff_en;
+
+	s8 frame_power[MT7996_SKU_PATH_NUM];
+	u8 rsv[3];
+};
+
+struct mt7996_mcu_txpower_event {
+	u8 _rsv[4];
+
+	__le16 tag;
+	__le16 len;
+
+	union {
+		struct txpower_basic_info basic_info;
+		struct txpower_phy_rate_info phy_rate_info;
+		struct txpower_backoff_table_info backoff_table_info;
+	};
+};
+
+enum txpower_category {
+	BASIC_INFO,
+	BACKOFF_TABLE_INFO,
+	PHY_RATE_INFO,
+};
+
+enum txpower_event {
+	UNI_TXPOWER_BASIC_INFO = 0,
+	UNI_TXPOWER_BACKOFF_TABLE_SHOW_INFO = 3,
+	UNI_TXPOWER_PHY_RATE_INFO = 5,
+};
+
+enum {
+	EDCCA_CTRL_SET_EN = 0,
+	EDCCA_CTRL_SET_THRES,
+	EDCCA_CTRL_GET_EN,
+	EDCCA_CTRL_GET_THRES,
+	EDCCA_CTRL_NUM,
+};
+
+enum {
+	EDCCA_DEFAULT = 0,
+	EDCCA_FCC = 1,
+	EDCCA_ETSI = 2,
+	EDCCA_JAPAN = 3
+};
+
+enum {
+	UNI_CMD_MURU_BSRP_CTRL = 0x01,
+	UNI_CMD_MURU_SUTX_CTRL = 0x10,
+	UNI_CMD_MURU_FIXED_RATE_CTRL = 0x11,
+	UNI_CMD_MURU_FIXED_GROUP_RATE_CTRL = 0x12,
+	UNI_CMD_MURU_SET_FORCE_MU = 0x33,
+	UNI_CMD_MURU_MUNUAL_CONFIG = 0x64,
+	UNI_CMD_MURU_SET_MUDL_ACK_POLICY = 0xC8,
+	UNI_CMD_MURU_SET_TRIG_TYPE = 0xC9,
+	UNI_CMD_MURU_SET_20M_DYN_ALGO = 0xCA,
+	UNI_CMD_MURU_PROT_FRAME_THR = 0xCC,
+	UNI_CMD_MURU_SET_CERT_MU_EDCA_OVERRIDE,
+};
+
+struct bf_pfmu_tag {
+	__le16 tag;
+	__le16 len;
+
+	u8 pfmu_id;
+	bool bfer;
+	u8 band_idx;
+	u8 __rsv[5];
+	u8 buf[56];
+} __packed;
+
+struct bf_starec_read {
+	__le16 tag;
+	__le16 len;
+
+	__le16 wlan_idx;
+	u8 __rsv[2];
+} __packed;
+
+struct bf_fbk_rpt_info {
+	__le16 tag;
+	__le16 len;
+
+	__le16 wlan_idx; // Only need for dynamic_pfmu_update 0x4
+	u8 action;
+	u8 band_idx;
+	u8 __rsv[4];
+
+} __packed;
+
+struct bf_txsnd_info {
+	__le16 tag;
+	__le16 len;
+
+	u8 action;
+	u8 read_clr;
+	u8 vht_opt;
+	u8 he_opt;
+	__le16 wlan_idx;
+	u8 glo_opt;
+	u8 snd_intv;
+	u8 snd_stop;
+	u8 max_snd_stas;
+	u8 tx_time;
+	u8 mcs;
+	u8 ldpc;
+	u8 inf;
+	u8 man;
+	u8 ac_queue;
+	u8 sxn_protect;
+	u8 direct_fbk;
+	u8 __rsv[2];
+} __packed;
+
+#define MAX_PHASE_GROUP_NUM	13
+
+struct bf_phase_comp {
+	__le16 tag;
+	__le16 len;
+
+	u8 bw;
+	u8 jp_band;
+	u8 band_idx;
+	bool read_from_e2p;
+	bool disable;
+	u8 group;
+	u8 rsv[2];
+	u8 buf[44];
+} __packed;
+
+struct bf_tx_apply {
+	__le16 tag;
+	__le16 len;
+
+	__le16 wlan_idx;
+	bool ebf;
+	bool ibf;
+	bool mu_txbf;
+	bool phase_cal;
+	u8 rsv[2];
+} __packed;
+
+struct bf_phase_cal {
+	__le16 tag;
+	__le16 len;
+
+	u8 group_l_m_n;
+	u8 group;
+	u8 sx2;
+	u8 cal_type;
+	u8 lna_gain_level;
+	u8 band_idx;
+	u8 version;
+	u8 rsv[1];
+} __packed;
+
+struct bf_txcmd {
+	__le16 tag;
+	__le16 len;
+
+	u8 action;
+	u8 bf_manual;
+	u8 bf_bit;
+	u8 rsv[5];
+} __packed;
+
+struct bf_pfmu_data_all {
+	__le16 tag;
+	__le16 len;
+
+	u8 pfmu_id;
+	u8 band_idx;
+	u8 rsv[2];
+
+	u8 buf[640];
+} __packed;
+
+#define TXBF_DUT_MAC_SUBADDR		0x22
+#define TXBF_GOLDEN_MAC_SUBADDR		0x11
+
+struct mt7996_tm_bf_req {
+	u8 _rsv[4];
+
+	union {
+		struct bf_sounding_on sounding;
+		struct bf_tx_apply tx_apply;
+		struct bf_pfmu_tag pfmu_tag;
+		struct bf_pfmu_data_all pfmu_data_all;
+		struct bf_phase_cal phase_cal;
+		struct bf_phase_comp phase_comp;
+		struct bf_txcmd txcmd;
+	};
+} __packed;
+
+enum tm_trx_mac_type {
+	TM_TRX_MAC_TX = 1,
+	TM_TRX_MAC_RX,
+	TM_TRX_MAC_TXRX,
+	TM_TRX_MAC_TXRX_RXV,
+	TM_TRX_MAC_RXV,
+	TM_TRX_MAC_RX_RXV,
+};
+
+enum tm_trx_param_idx {
+	TM_TRX_PARAM_RSV,
+	/* MAC */
+	TM_TRX_PARAM_SET_TRX,
+	TM_TRX_PARAM_RX_FILTER,
+	TM_TRX_PARAM_RX_FILTER_PKT_LEN,
+	TM_TRX_PARAM_SLOT_TIME,
+	TM_TRX_PARAM_CLEAN_PERSTA_TXQUEUE,
+	TM_TRX_PARAM_AMPDU_WTBL,
+	TM_TRX_PARAM_MU_RX_AID,
+	TM_TRX_PARAM_PHY_MANUAL_TX,
+
+	/* PHY */
+	TM_TRX_PARAM_RX_PATH,
+	TM_TRX_PARAM_TX_STREAM,
+	TM_TRX_PARAM_TSSI_STATUS,
+	TM_TRX_PARAM_DPD_STATUS,
+	TM_TRX_PARAM_RATE_POWER_OFFSET_ON_OFF,
+	TM_TRX_PARAM_THERMO_COMP_STATUS,
+	TM_TRX_PARAM_FREQ_OFFSET,
+	TM_TRX_PARAM_FAGC_RSSI_PATH,
+	TM_TRX_PARAM_PHY_STATUS_COUNT,
+	TM_TRX_PARAM_RXV_INDEX,
+
+	TM_TRX_PARAM_ANTENNA_PORT,
+	TM_TRX_PARAM_THERMAL_ONOFF,
+	TM_TRX_PARAM_TX_POWER_CONTROL_ALL_RF,
+	TM_TRX_PARAM_RATE_POWER_OFFSET,
+	TM_TRX_PARAM_SLT_CMD_TEST,
+	TM_TRX_PARAM_SKU,
+	TM_TRX_PARAM_POWER_PERCENTAGE_ON_OFF,
+	TM_TRX_PARAM_BF_BACKOFF_ON_OFF,
+	TM_TRX_PARAM_POWER_PERCENTAGE_LEVEL,
+	TM_TRX_PARAM_FRTBL_CFG,
+	TM_TRX_PARAM_PREAMBLE_PUNC_ON_OFF,
+
+	TM_TRX_PARAM_MAX_NUM,
+};
+
+enum trx_action {
+	TM_TRX_ACTION_SET,
+	TM_TRX_ACTION_GET,
+};
+
+struct tm_trx_set {
+	u8 type;
+	u8 enable;
+	u8 band_idx;
+	u8 rsv;
+} __packed;
+
+struct mt7996_tm_trx_req {
+	u8 param_num;
+	u8 _rsv[3];
+
+	__le16 tag;
+	__le16 len;
+
+	__le16 param_idx;
+	u8 band_idx;
+	u8 testmode_en;
+	u8 action;
+	u8 rsv[3];
+
+	u32 data;
+	struct tm_trx_set set_trx;
+
+	u8 buf[220];
+} __packed;
+
+struct mt7996_mcu_bf_basic_event {
+	struct mt7996_mcu_rxd rxd;
+
+	u8 __rsv1[4];
+
+	__le16 tag;
+	__le16 len;
+};
+
+struct mt7996_mcu_bf_starec_read {
+
+	struct mt7996_mcu_bf_basic_event event;
+
+	__le16 pfmu_id;
+	bool is_su_mu;
+	u8 txbf_cap;
+	u8 sounding_phy;
+	u8 ndpa_rate;
+	u8 ndp_rate;
+	u8 rpt_poll_rate;
+	u8 tx_mode;
+	u8 nc;
+	u8 nr;
+	u8 bw;
+	u8 total_mem_require;
+	u8 mem_require_20m;
+	u8 mem_row0;
+	u8 mem_col0:6;
+	u8 mem_row0_msb:2;
+	u8 mem_row1;
+	u8 mem_col1:6;
+	u8 mem_row1_msb:2;
+	u8 mem_row2;
+	u8 mem_col2:6;
+	u8 mem_row2_msb:2;
+	u8 mem_row3;
+	u8 mem_col3:6;
+	u8 mem_row3_msb:2;
+
+	__le16 smart_ant;
+	u8 se_idx;
+	u8 auto_sounding_ctrl;
+
+	u8 bf_timeout;
+	u8 bf_dbw;
+	u8 bf_ncol;
+	u8 bf_nrow;
+
+	u8 nr_lt_bw80;
+	u8 nc_lt_bw80;
+	u8 ru_start_idx;
+	u8 ru_end_idx;
+
+	bool trigger_su;
+	bool trigger_mu;
+
+	bool ng16_su;
+	bool ng16_mu;
+
+	bool codebook42_su;
+	bool codebook75_mu;
+
+	u8 he_ltf;
+	u8 rsv[3];
+};
+
+#define TXBF_PFMU_ID_NUM_MAX 48
+
+#define TXBF_PFMU_ID_NUM_MAX_TBTC_BAND0 TXBF_PFMU_ID_NUM_MAX
+#define TXBF_PFMU_ID_NUM_MAX_TBTC_BAND1 TXBF_PFMU_ID_NUM_MAX
+#define TXBF_PFMU_ID_NUM_MAX_TBTC_BAND2 TXBF_PFMU_ID_NUM_MAX
+
+/* CFG_BF_STA_REC shall be varied based on BAND Num */
+#define CFG_BF_STA_REC_NUM (TXBF_PFMU_ID_NUM_MAX_TBTC_BAND0 + TXBF_PFMU_ID_NUM_MAX_TBTC_BAND1 + TXBF_PFMU_ID_NUM_MAX_TBTC_BAND2)
+
+#define BF_SND_CTRL_STA_DWORD_CNT   ((CFG_BF_STA_REC_NUM + 0x1F) >> 5)
+
+#ifndef ALIGN_4
+	#define ALIGN_4(_value)             (((_value) + 3) & ~3u)
+#endif /* ALIGN_4 */
+
+#define CFG_WIFI_RAM_BAND_NUM 3
+
+struct uni_event_bf_txsnd_sta_info {
+	u8 snd_intv;       /* Sounding interval upper bound, unit:15ms */
+	u8 snd_intv_cnt;   /* Sounding interval counter */
+	u8 snd_tx_cnt;     /* Tx sounding count for debug */
+	u8 snd_stop_reason;  /* Bitwise reason to put in Stop Queue */
+};
+
+struct mt7996_mcu_tx_snd_info {
+
+	struct mt7996_mcu_bf_basic_event event;
+
+	u8 vht_opt;
+	u8 he_opt;
+	u8 glo_opt;
+	u8 __rsv;
+	__le32 snd_rec_su_sta[BF_SND_CTRL_STA_DWORD_CNT];
+	__le32 snd_rec_vht_mu_sta[BF_SND_CTRL_STA_DWORD_CNT];
+	__le32 snd_rec_he_tb_sta[BF_SND_CTRL_STA_DWORD_CNT];
+	__le32 snd_rec_eht_tb_sta[BF_SND_CTRL_STA_DWORD_CNT];
+	__le16 wlan_idx_for_mc_snd[ALIGN_4(CFG_WIFI_RAM_BAND_NUM)];
+	__le16 wlan_idx_for_he_tb_snd[ALIGN_4(CFG_WIFI_RAM_BAND_NUM)];
+	__le16 wlan_idx_for_eht_tb_snd[ALIGN_4(CFG_WIFI_RAM_BAND_NUM)];
+	__le16 ul_length;
+	u8 mcs;
+	u8 ldpc;
+	struct uni_event_bf_txsnd_sta_info snd_sta_info[CFG_BF_STA_REC_NUM];
+};
+
+struct mt7996_mcu_txbf_fbk_info {
+
+	struct mt7996_mcu_bf_basic_event event;
+
+	__le32 u4DeQInterval;     /* By ms */
+	__le32 u4PollPFMUIntrStatTimeOut; /* micro-sec */
+	__le32 u4RptPktTimeOutListNum;
+	__le32 u4RptPktListNum;
+	__le32 u4PFMUWRTimeOutCnt;
+	__le32 u4PFMUWRFailCnt;
+	__le32 u4PFMUWRDoneCnt;
+	__le32 u4PFMUWRTimeoutFreeCnt;
+	__le32 u4FbRptPktDropCnt;
+	__le32 au4RxPerStaFbRptCnt[CFG_BF_STA_REC_NUM];
+};
+
+struct pfmu_ru_field {
+	__le32 ru_start_id:7;
+	__le32 _rsv1:1;
+	__le32 ru_end_id:7;
+	__le32 _rsv2:1;
+} __packed;
+
+struct pfmu_partial_bw_info {
+	__le32 partial_bw_info:9;
+	__le32 _rsv1:7;
+} __packed;
+
+struct mt7996_pfmu_tag1 {
+	__le32 pfmu_idx:10;
+	__le32 ebf:1;
+	__le32 data_bw:3;
+	__le32 lm:3;
+	__le32 is_mu:1;
+	__le32 nr:3;
+	__le32 nc:3;
+	__le32 codebook:2;
+	__le32 ngroup:2;
+	__le32 invalid_prof:1;
+	__le32 _rsv:3;
+
+	__le32 col_id1:7, row_id1:9;
+	__le32 col_id2:7, row_id2:9;
+	__le32 col_id3:7, row_id3:9;
+	__le32 col_id4:7, row_id4:9;
+
+	union {
+		struct pfmu_ru_field field;
+		struct pfmu_partial_bw_info bw_info;
+	};
+	__le32 mob_cal_en:1;
+	__le32 _rsv2:3;
+	__le32 mob_ru_alloc:9;	/* EHT profile uses full 9 bit */
+	__le32 _rsv3:3;
+
+	__le32 snr_sts0:8, snr_sts1:8, snr_sts2:8, snr_sts3:8;
+	__le32 snr_sts4:8, snr_sts5:8, snr_sts6:8, snr_sts7:8;
+
+	__le32 _rsv4;
+} __packed;
+
+struct mt7996_pfmu_tag2 {
+	__le32 smart_ant:24;
+	__le32 se_idx:5;
+	__le32 _rsv:3;
+
+	__le32 _rsv1:16;
+	__le32 ibf_timeout:8;
+	__le32 _rsv2:8;
+
+	__le32 ibf_data_bw:3;
+	__le32 ibf_nc:3;
+	__le32 ibf_nr:3;
+	__le32 ibf_ru:9;
+	__le32 _rsv3:14;
+
+	__le32 mob_delta_t:8;
+	__le32 mob_lq_result:7;
+	__le32 _rsv5:1;
+	__le32 _rsv6:16;
+
+	__le32 _rsv7;
+} __packed;
+
+struct mt7996_pfmu_tag_event {
+	struct mt7996_mcu_bf_basic_event event;
+
+	u8 bfer;
+	u8 __rsv[3];
+
+	struct mt7996_pfmu_tag1 t1;
+	struct mt7996_pfmu_tag2 t2;
+};
+
+struct mt7996_pfmu_tag {
+	struct mt7996_pfmu_tag1 t1;
+	struct mt7996_pfmu_tag2 t2;
+};
+
+enum bf_lm_type {
+	BF_LM_LEGACY,
+	BF_LM_HT,
+	BF_LM_VHT,
+	BF_LM_HE,
+	BF_LM_EHT,
+};
+
+struct mt7996_txbf_phase_out {
+	u8 c0_l;
+	u8 c1_l;
+	u8 c2_l;
+	u8 c3_l;
+	u8 c0_m;
+	u8 c1_m;
+	u8 c2_m;
+	u8 c3_m;
+	u8 c0_mh;
+	u8 c1_mh;
+	u8 c2_mh;
+	u8 c3_mh;
+	u8 c0_h;
+	u8 c1_h;
+	u8 c2_h;
+	u8 c3_h;
+	u8 c0_uh;
+	u8 c1_uh;
+	u8 c2_uh;
+	u8 c3_uh;
+};
+
+struct mt7992_txbf_phase_out {
+	u8 c0_l;
+	u8 c1_l;
+	u8 c2_l;
+	u8 c3_l;
+	u8 c4_l;
+	u8 c0_m;
+	u8 c1_m;
+	u8 c2_m;
+	u8 c3_m;
+	u8 c4_m;
+	u8 c0_mh;
+	u8 c1_mh;
+	u8 c2_mh;
+	u8 c3_mh;
+	u8 c4_mh;
+	u8 c0_h;
+	u8 c1_h;
+	u8 c2_h;
+	u8 c3_h;
+	u8 c4_h;
+	u8 c0_uh;
+	u8 c1_uh;
+	u8 c2_uh;
+	u8 c3_uh;
+	u8 c4_uh;
+};
+
+struct txbf_rx_phase {
+	u8 rx_uh;
+	u8 rx_h;
+	u8 rx_m;
+	u8 rx_l;
+	u8 rx_ul;
+};
+
+struct txbf_rx_phase_ext {
+	u8 rx_uh;
+	u8 rx_h;
+	u8 rx_mh;
+	u8 rx_m;
+	u8 rx_l;
+	u8 rx_ul;
+};
+
+struct mt7996_txbf_phase_info_2g {
+	struct txbf_rx_phase r0;
+	struct txbf_rx_phase r1;
+	struct txbf_rx_phase r2;
+	struct txbf_rx_phase r3;
+	struct txbf_rx_phase r2_sx2;
+	struct txbf_rx_phase r3_sx2;
+	u8 m_t0_h;
+	u8 m_t1_h;
+	u8 m_t2_h;
+	u8 m_t2_h_sx2;
+	u8 r0_reserved;
+	u8 r1_reserved;
+	u8 r2_reserved;
+	u8 r3_reserved;
+	u8 r2_sx2_reserved;
+	u8 r3_sx2_reserved;
+};
+
+struct mt7996_txbf_phase_info_5g {
+	struct txbf_rx_phase_ext r0;
+	struct txbf_rx_phase_ext r1;
+	struct txbf_rx_phase_ext r2;
+	struct txbf_rx_phase_ext r3;
+	struct txbf_rx_phase r2_sx2;	/* no middle-high in r2_sx2 */
+	struct txbf_rx_phase r3_sx2;	/* no middle-high in r3_sx2 */
+	u8 m_t0_h;
+	u8 m_t1_h;
+	u8 m_t2_h;
+	u8 m_t2_h_sx2;
+	u8 r0_reserved;
+	u8 r1_reserved;
+	u8 r2_reserved;
+	u8 r3_reserved;
+	u8 r2_sx2_reserved;
+	u8 r3_sx2_reserved;
+};
+
+struct mt7992_txbf_phase_info_2g {
+	struct txbf_rx_phase_ext r0;
+	struct txbf_rx_phase_ext r1;
+	struct txbf_rx_phase_ext r2;
+	struct txbf_rx_phase_ext r3;
+	u8 m_t0_h;
+	u8 m_t1_h;
+	u8 m_t2_h;
+};
+
+struct mt7992_txbf_phase_info_5g {
+	struct txbf_rx_phase_ext r0;
+	struct txbf_rx_phase_ext r1;
+	struct txbf_rx_phase_ext r2;
+	struct txbf_rx_phase_ext r3;
+	struct txbf_rx_phase_ext r4;
+	u8 m_t0_h;
+	u8 m_t1_h;
+	u8 m_t2_h;
+	u8 m_t3_h;
+};
+
+struct mt7996_txbf_phase {
+	u8 status;
+	union {
+		union {
+			struct mt7996_txbf_phase_info_2g phase_2g;
+			struct mt7996_txbf_phase_info_5g phase_5g;
+		} v1;
+		union {
+			struct mt7992_txbf_phase_info_2g phase_2g;
+			struct mt7992_txbf_phase_info_5g phase_5g;
+		} v2;
+		u8 buf[44];
+	};
+};
+
+#define phase_assign(group, v, field, dump, ...)	({					\
+	if (group) {										\
+		phase->v.phase_5g.field = cal->v.phase_5g.field;				\
+		if (dump)									\
+			dev_info(dev->mt76.dev, "%s = %d\n", #field, phase->v.phase_5g.field);	\
+	} else {										\
+		phase->v.phase_2g.field = cal->v.phase_5g.field;				\
+		if (dump)									\
+			dev_info(dev->mt76.dev, "%s = %d\n", #field, phase->v.phase_2g.field);	\
+	}											\
+})
+
+#define phase_assign_rx(group, v, rx, dump, ...)	({					\
+	phase_assign(group, v, rx.rx_uh, dump);							\
+	phase_assign(group, v, rx.rx_h, dump);							\
+	phase_assign(group, v, rx.rx_m, dump);							\
+	phase_assign(group, v, rx.rx_l, dump);							\
+	phase_assign(group, v, rx.rx_ul, dump);							\
+})
+
+#define phase_assign_rx_ext(group, v, rx, dump, ...)	({					\
+	phase_assign(group, v, rx.rx_uh, dump);							\
+	phase_assign(group, v, rx.rx_h, dump);							\
+	phase_assign(group, v, rx.rx_mh, dump);							\
+	phase_assign(group, v, rx.rx_m, dump);							\
+	phase_assign(group, v, rx.rx_l, dump);							\
+	phase_assign(group, v, rx.rx_ul, dump);							\
+})
+
+#define phase_assign_rx_v1(group, v, rx, ...)	({						\
+	if (group) {										\
+		phase_assign(group, v, rx.rx_uh, true);						\
+		phase_assign(group, v, rx.rx_h, true);						\
+		phase->v.phase_5g.rx.rx_mh = cal->v.phase_5g.rx.rx_mh;				\
+		dev_info(dev->mt76.dev, "%s.rx_mh = %d\n", #rx, phase->v.phase_5g.rx.rx_mh);	\
+		phase_assign(group, v, rx.rx_m, true);						\
+		phase_assign(group, v, rx.rx_l, true);						\
+		phase_assign(group, v, rx.rx_ul, true);						\
+	} else {										\
+		phase_assign_rx(group, v, rx, true, ...);					\
+	}											\
+})
+
+#define GROUP_L		0
+#define GROUP_M		1
+#define GROUP_H		2
+
+struct mt7996_pfmu_data {
+	__le16 subc_idx;
+	__le16 phi11;
+	__le16 phi21;
+	__le16 phi31;
+};
+
+struct mt7996_pfmu_data_5x5 {
+	__le16 subc_idx;
+	__le16 phi11;
+	__le16 phi21;
+	__le16 phi31;
+	__le16 phi41;
+};
+
+struct mt7996_ibf_cal_info {
+	struct mt7996_mcu_bf_basic_event event;
+
+	u8 category_id;
+	u8 group_l_m_n;
+	u8 group;
+	bool sx2;
+	u8 status;
+	u8 cal_type;
+	u8 nsts;
+	u8 version;
+	union {
+		struct {
+			struct mt7996_txbf_phase_out phase_out;
+			union {
+				struct mt7996_txbf_phase_info_2g phase_2g;
+				struct mt7996_txbf_phase_info_5g phase_5g;
+			};
+		} v1;
+		struct {
+			struct mt7992_txbf_phase_out phase_out;
+			union {
+				struct mt7992_txbf_phase_info_2g phase_2g;
+				struct mt7992_txbf_phase_info_5g phase_5g;
+			};
+		} v2;
+		u8 buf[64];
+	};
+} __packed;
+
+enum {
+	IBF_PHASE_CAL_UNSPEC,
+	IBF_PHASE_CAL_NORMAL,
+	IBF_PHASE_CAL_VERIFY,
+	IBF_PHASE_CAL_NORMAL_INSTRUMENT,
+	IBF_PHASE_CAL_VERIFY_INSTRUMENT,
+};
+
+enum ibf_version {
+	IBF_VER_1,
+	IBF_VER_2 = 3,
+};
+
+static inline int get_ibf_version(struct mt7996_dev *dev)
+{
+	switch (mt76_chip(&dev->mt76)) {
+	case 0x7990:
+		return IBF_VER_1;
+	case 0x7992:
+	default:
+		return IBF_VER_2;
+	}
+}
+
+#define MT7996_TXBF_SUBCAR_NUM		64
+#define MT7996_TXBF_PFMU_DATA_LEN	(MT7996_TXBF_SUBCAR_NUM * sizeof(struct mt7996_pfmu_data))
+#define MT7996_TXBF_PFMU_DATA_LEN_5X5	(MT7996_TXBF_SUBCAR_NUM * \
+					 sizeof(struct mt7996_pfmu_data_5x5))
+
+enum {
+	UNI_EVENT_BF_PFMU_TAG = 0x5,
+	UNI_EVENT_BF_PFMU_DATA = 0x7,
+	UNI_EVENT_BF_STAREC = 0xB,
+	UNI_EVENT_BF_CAL_PHASE = 0xC,
+	UNI_EVENT_BF_FBK_INFO = 0x17,
+	UNI_EVENT_BF_TXSND_INFO = 0x18,
+	UNI_EVENT_BF_PLY_INFO = 0x19,
+	UNI_EVENT_BF_METRIC_INFO = 0x1A,
+	UNI_EVENT_BF_TXCMD_CFG_INFO = 0x1B,
+	UNI_EVENT_BF_SND_CNT_INFO = 0x1D,
+	UNI_EVENT_BF_MAX_NUM
+};
+
+struct uni_muru_mum_set_group_tbl_entry {
+	__le16 wlan_idx0;
+	__le16 wlan_idx1;
+	__le16 wlan_idx2;
+	__le16 wlan_idx3;
+
+	u8 dl_mcs_user0:4;
+	u8 dl_mcs_user1:4;
+	u8 dl_mcs_user2:4;
+	u8 dl_mcs_user3:4;
+	u8 ul_mcs_user0:4;
+	u8 ul_mcs_user1:4;
+	u8 ul_mcs_user2:4;
+	u8 ul_mcs_user3:4;
+
+	u8 num_user:2;
+	u8 rsv:6;
+	u8 nss0:2;
+	u8 nss1:2;
+	u8 nss2:2;
+	u8 nss3:2;
+	u8 ru_alloc;
+	u8 ru_alloc_ext;
+
+	u8 capa;
+	u8 gi;
+	u8 dl_ul;
+	u8 _rsv2;
+};
+
+enum UNI_CMD_MURU_VER_T {
+	UNI_CMD_MURU_VER_LEG = 0,
+	UNI_CMD_MURU_VER_HE,
+	UNI_CMD_MURU_VER_EHT,
+	UNI_CMD_MURU_VER_MAX
+};
+
+#define UNI_MAX_MCS_SUPPORT_HE 11
+#define UNI_MAX_MCS_SUPPORT_EHT 13
+
+enum {
+	RUALLOC_BW20 = 122,
+	RUALLOC_BW40 = 130,
+	RUALLOC_BW80 = 134,
+	RUALLOC_BW160 = 137,
+	RUALLOC_BW320 = 395,
+};
+
+enum {
+	MAX_MODBF_VHT = 0,
+	MAX_MODBF_HE = 2,
+	MAX_MODBF_EHT = 4,
+};
+
+enum {
+	BF_SND_READ_INFO = 0,
+	BF_SND_CFG_OPT,
+	BF_SND_CFG_INTV,
+	BF_SND_STA_STOP,
+	BF_SND_CFG_MAX_STA,
+	BF_SND_CFG_BFRP,
+	BF_SND_CFG_INF,
+	BF_SND_CFG_TXOP_SND
+};
+
+enum {
+	UNI_EVENT_SR_CFG_SR_ENABLE = 0x1,
+	UNI_EVENT_SR_SW_SD = 0x83,
+	UNI_EVENT_SR_HW_IND = 0xC9,
+	UNI_EVENT_SR_HW_ESR_ENABLE = 0xD8,
+};
+enum {
+	UNI_CMD_SR_CFG_SR_ENABLE = 0x1,
+	UNI_CMD_SR_SW_SD = 0x84,
+	UNI_CMD_SR_HW_IND = 0xCB,
+	UNI_CMD_SR_HW_ENHANCE_SR_ENABLE = 0xDA,
+};
+
+struct mt7996_mcu_sr_basic_event {
+	struct mt7996_mcu_rxd rxd;
+
+	u8 band_idx;
+	u8 _rsv[3];
+
+	__le16 tag;
+	__le16 len;
+};
+
+struct sr_sd_tlv {
+	u8 _rsv[16];
+	__le32 sr_tx_airtime;
+	__le32 obss_airtime;
+	__le32 my_tx_airtime;
+	__le32 my_rx_airtime;
+	__le32 channel_busy_time;
+	__le32 total_airtime;
+	__le32 total_airtime_ratio;
+	__le32 obss_airtime_ratio;
+	u8 rule;
+	u8 _rsv2[59];
+} __packed;
+
+struct mt7996_mcu_sr_swsd_event {
+	struct mt7996_mcu_sr_basic_event basic;
+	struct sr_sd_tlv tlv[3];
+} __packed;
+
+struct mt7996_mcu_sr_common_event {
+	struct mt7996_mcu_sr_basic_event basic;
+	__le32 value;
+};
+
+struct mt7996_mcu_sr_hw_ind_event {
+	struct mt7996_mcu_sr_basic_event basic;
+	__le16 non_srg_valid_cnt;
+	u8 _rsv[4];
+	__le16 inter_bss_ppdu_cnt;
+	u8 _rsv2[4];
+	__le32 sr_ampdu_mpdu_cnt;
+	__le32 sr_ampdu_mpdu_acked_cnt;
+};
+
+struct mt7996_muru_comm {
+	u8 pda_pol;
+	u8 band;
+	u8 spe_idx;
+	u8 proc_type;
+
+	__le16 mlo_ctrl;
+	u8 sch_type;
+	u8 ppdu_format;
+	u8 ac;
+	u8 _rsv[3];
+};
+
+struct mt7996_muru_dl {
+	u8 user_num;
+	u8 tx_mode;
+	u8 bw;
+	u8 gi;
+
+	u8 ltf;
+	u8 mcs;
+	u8 dcm;
+	u8 cmprs;
+
+	__le16 ru[16];
+
+	u8 c26[2];
+	u8 ack_policy;
+	u8 tx_power;
+
+	__le16 mu_ppdu_duration;
+	u8 agc_disp_order;
+	u8 _rsv1;
+
+	u8 agc_disp_pol;
+	u8 agc_disp_ratio;
+	__le16 agc_disp_linkMFG;
+
+	__le16 prmbl_punc_bmp;
+	u8 _rsv2[2];
+
+	struct {
+		__le16 wlan_idx;
+		u8 ru_alloc_seg;
+		u8 ru_idx;
+		u8 ldpc;
+		u8 nss;
+		u8 mcs;
+		u8 mu_group_idx;
+		u8 vht_groud_id;
+		u8 vht_up;
+		u8 he_start_stream;
+		u8 he_mu_spatial;
+		__le16 tx_power_alpha;
+		u8 ack_policy;
+		u8 ru_allo_ps160;
+	} usr[16];
+};
+
+struct mt7996_muru_ul {
+	u8 user_num;
+	u8 tx_mode;
+
+	u8 ba_type;
+	u8 _rsv;
+
+	u8 bw;
+	u8 gi_ltf;
+	__le16 ul_len;
+
+	__le16 trig_cnt;
+	u8 pad;
+	u8 trig_type;
+
+	__le16 trig_intv;
+	u8 trig_ta[ETH_ALEN];
+	__le16 ul_ru[16];
+
+	u8 c26[2];
+	__le16 agc_disp_linkMFG;
+
+	u8 agc_disp_mu_len;
+	u8 agc_disp_pol;
+	u8 agc_disp_ratio;
+	u8 agc_disp_pu_idx;
+
+	struct {
+		__le16 wlan_idx;
+		u8 ru_alloc_seg;
+		u8 ru_idx;
+		u8 ldpc;
+		u8 nss;
+		u8 mcs;
+		u8 target_rssi;
+		__le32 trig_pkt_size;
+		u8 ru_allo_ps160;
+		u8 _rsv2[3];
+	} usr[16];
+};
+
+struct mt7996_muru_dbg {
+	/* HE TB RX Debug */
+	__le32 rx_hetb_nonsf_en_bitmap;
+	__le32 rx_hetb_cfg[2];
+};
+
+struct mt7996_muru {
+	__le32 cfg_comm;
+	__le32 cfg_dl;
+	__le32 cfg_ul;
+	__le32 cfg_dbg;
+
+	struct mt7996_muru_comm comm;
+	struct mt7996_muru_dl dl;
+	struct mt7996_muru_ul ul;
+	struct mt7996_muru_dbg dbg;
+};
+
+
+#define MURU_PPDU_HE_TRIG	BIT(2)
+#define MURU_PPDU_HE_MU		BIT(3)
+
+#define MURU_OFDMA_SCH_TYPE_DL	BIT(0)
+#define MURU_OFDMA_SCH_TYPE_UL	BIT(1)
+
+/* Common Config */
+#define MURU_COMM_PPDU_FMT	BIT(0)
+#define MURU_COMM_SCH_TYPE	BIT(1)
+#define MURU_COMM_BAND		BIT(2)
+#define MURU_COMM_WMM		BIT(3)
+#define MURU_COMM_SPE_IDX	BIT(4)
+#define MURU_COMM_PROC_TYPE	BIT(5)
+#define MURU_COMM_SET		(MURU_COMM_PPDU_FMT | MURU_COMM_SCH_TYPE)
+#define MURU_COMM_SET_TM	(MURU_COMM_PPDU_FMT | MURU_COMM_BAND | \
+				 MURU_COMM_WMM | MURU_COMM_SPE_IDX)
+
+/* DL Common config */
+#define MURU_FIXED_DL_TOTAL_USER_CNT	BIT(4)
+
+/* UL Common Config */
+#define MURU_FIXED_UL_TOTAL_USER_CNT	BIT(4)
+
+enum {
+	CAPI_SU,
+	CAPI_MU,
+	CAPI_ER_SU,
+	CAPI_TB,
+	CAPI_LEGACY
+};
+
+enum {
+	CAPI_BASIC,
+	CAPI_BRP,
+	CAPI_MU_BAR,
+	CAPI_MU_RTS,
+	CAPI_BSRP,
+	CAPI_GCR_MU_BAR,
+	CAPI_BQRP,
+	CAPI_NDP_FRP,
+};
+
+enum {
+	MU_DL_ACK_POLICY_MU_BAR = 3,
+	MU_DL_ACK_POLICY_TF_FOR_ACK = 4,
+	MU_DL_ACK_POLICY_SU_BAR = 5,
+};
+
+enum muru_vendor_ctrl {
+	MU_CTRL_UPDATE,
+	MU_CTRL_DL_USER_CNT,
+	MU_CTRL_UL_USER_CNT,
+};
+
+enum {
+	VOW_DRR_DBG_DUMP_BMP = BIT(0),
+	VOW_DRR_DBG_EST_AT_PRINT = BIT(1),
+	VOW_DRR_DBG_ADJ_GLOBAL_THLD = BIT(21),
+	VOW_DRR_DBG_PRN_LOUD = BIT(22),
+	VOW_DRR_DBG_PRN_ADJ_STA = BIT(23),
+	VOW_DRR_DBG_FIX_CR = GENMASK(27, 24),
+	VOW_DRR_DBG_CLR_FIX_CR = BIT(28),
+	VOW_DRR_DBG_DISABLE = BIT(29),
+	VOW_DRR_DBG_DUMP_CR = BIT(30),
+	VOW_DRR_DBG_PRN = BIT(31)
+};
+
+#define VOW_DRR_DBG_FLAGS (VOW_DRR_DBG_DUMP_BMP |	\
+			  VOW_DRR_DBG_EST_AT_PRINT |	\
+			  VOW_DRR_DBG_ADJ_GLOBAL_THLD |	\
+			  VOW_DRR_DBG_PRN_LOUD |	\
+			  VOW_DRR_DBG_PRN_ADJ_STA |	\
+			  VOW_DRR_DBG_FIX_CR |		\
+			  VOW_DRR_DBG_CLR_FIX_CR |	\
+			  VOW_DRR_DBG_DISABLE |		\
+			  VOW_DRR_DBG_DUMP_CR |		\
+			  VOW_DRR_DBG_PRN)
+#endif
+
+#endif
diff --git a/mt7996/pci.c b/mt7996/pci.c
index a4338367..a5cdd150 100644
--- a/mt7996/pci.c
+++ b/mt7996/pci.c
@@ -5,12 +5,14 @@
 
 #include <linux/kernel.h>
 #include <linux/module.h>
-#include <linux/pci.h>
 
 #include "mt7996.h"
 #include "mac.h"
 #include "../trace.h"
 
+static bool hif2_enable = false;
+module_param(hif2_enable, bool, 0644);
+
 static LIST_HEAD(hif_list);
 static DEFINE_SPINLOCK(hif_lock);
 static u32 hif_idx;
@@ -63,6 +65,9 @@ static struct mt7996_hif *mt7996_pci_init_hif2(struct pci_dev *pdev)
 {
 	hif_idx++;
 
+	if (!hif2_enable)
+		return NULL;
+
 	if (!pci_get_device(PCI_VENDOR_ID_MEDIATEK, MT7996_DEVICE_ID_2, NULL) &&
 	    !pci_get_device(PCI_VENDOR_ID_MEDIATEK, MT7992_DEVICE_ID_2, NULL))
 		return NULL;
@@ -77,6 +82,9 @@ static int mt7996_pci_hif2_probe(struct pci_dev *pdev)
 {
 	struct mt7996_hif *hif;
 
+	if (!hif2_enable)
+		return 0;
+
 	hif = devm_kzalloc(&pdev->dev, sizeof(*hif), GFP_KERNEL);
 	if (!hif)
 		return -ENOMEM;
@@ -84,6 +92,7 @@ static int mt7996_pci_hif2_probe(struct pci_dev *pdev)
 	hif->dev = &pdev->dev;
 	hif->regs = pcim_iomap_table(pdev)[0];
 	hif->irq = pdev->irq;
+	pcie_bandwidth_available(pdev, NULL, &hif->speed, &hif->width);
 	spin_lock_bh(&hif_lock);
 	list_add(&hif->list, &hif_list);
 	spin_unlock_bh(&hif_lock);
@@ -98,9 +107,11 @@ static int mt7996_pci_probe(struct pci_dev *pdev,
 	struct pci_dev *hif2_dev;
 	struct mt7996_hif *hif2;
 	struct mt7996_dev *dev;
-	int irq, hif2_irq, ret;
+	int irq, ret;
 	struct mt76_dev *mdev;
 
+	hif2_enable |= (id->device == 0x7990 || id->device == 0x7991 || id->device == 0x799a);
+
 	ret = pcim_enable_device(pdev);
 	if (ret)
 		return ret;
@@ -133,6 +144,8 @@ static int mt7996_pci_probe(struct pci_dev *pdev,
 	mdev = &dev->mt76;
 	mt7996_wfsys_reset(dev);
 	hif2 = mt7996_pci_init_hif2(pdev);
+	if (hif2)
+		dev->hif2 = hif2;
 
 	ret = mt7996_mmio_wed_init(dev, pdev, false, &irq);
 	if (ret < 0)
@@ -157,11 +170,12 @@ static int mt7996_pci_probe(struct pci_dev *pdev,
 
 	if (hif2) {
 		hif2_dev = container_of(hif2->dev, struct pci_dev, dev);
-		dev->hif2 = hif2;
+		ret = 0;
+
+		ret = mt7996_mmio_wed_init(dev, hif2_dev, true, &irq);
 
-		ret = mt7996_mmio_wed_init(dev, hif2_dev, true, &hif2_irq);
 		if (ret < 0)
-			goto free_hif2_wed_irq_vector;
+			goto free_wed_or_irq_vector;
 
 		if (!ret) {
 			ret = pci_alloc_irq_vectors(hif2_dev, 1, 1,
@@ -170,14 +184,15 @@ static int mt7996_pci_probe(struct pci_dev *pdev,
 				goto free_hif2;
 
 			dev->hif2->irq = hif2_dev->irq;
-			hif2_irq = dev->hif2->irq;
+		} else {
+			dev->hif2->irq = irq;
 		}
 
-		ret = devm_request_irq(mdev->dev, hif2_irq, mt7996_irq_handler,
-				       IRQF_SHARED, KBUILD_MODNAME "-hif",
-				       dev);
+		ret = devm_request_irq(mdev->dev, dev->hif2->irq,
+				       mt7996_irq_handler, IRQF_SHARED,
+				       KBUILD_MODNAME "-hif", dev);
 		if (ret)
-			goto free_hif2_wed_irq_vector;
+			goto free_hif2_irq_vector;
 
 		mt76_wr(dev, MT_INT1_MASK_CSR, 0);
 		/* master switch of PCIe tnterrupt enable */
@@ -192,8 +207,8 @@ static int mt7996_pci_probe(struct pci_dev *pdev,
 
 free_hif2_irq:
 	if (dev->hif2)
-		devm_free_irq(mdev->dev, hif2_irq, dev);
-free_hif2_wed_irq_vector:
+		devm_free_irq(mdev->dev, dev->hif2->irq, dev);
+free_hif2_irq_vector:
 	if (dev->hif2) {
 		if (mtk_wed_device_active(&dev->mt76.mmio.wed_hif2))
 			mtk_wed_device_detach(&dev->mt76.mmio.wed_hif2);
diff --git a/mt7996/regs.h b/mt7996/regs.h
index 1876a968..a0b57e59 100644
--- a/mt7996/regs.h
+++ b/mt7996/regs.h
@@ -77,6 +77,8 @@ enum offs_rev {
 #define MT_RRO_BA_BITMAP_BASE1			MT_RRO_TOP(0xC)
 #define WF_RRO_AXI_MST_CFG			MT_RRO_TOP(0xB8)
 #define WF_RRO_AXI_MST_CFG_DIDX_OK		BIT(12)
+
+#define MT_RRO_ADDR_ARRAY_BASE0			MT_RRO_TOP(0x30)
 #define MT_RRO_ADDR_ARRAY_BASE1			MT_RRO_TOP(0x34)
 #define MT_RRO_ADDR_ARRAY_ELEM_ADDR_SEG_MODE	BIT(31)
 
@@ -97,6 +99,14 @@ enum offs_rev {
 
 #define MT_RRO_ADDR_ELEM_SEG_ADDR0		MT_RRO_TOP(0x400)
 
+#define MT_RRO_3_0_EMU_CONF			MT_RRO_TOP(0x600)
+#define MT_RRO_3_0_EMU_CONF_EN_MASK		BIT(11)
+
+#define MT_RRO_3_1_GLOBAL_CONFIG		MT_RRO_TOP(0x604)
+#define MT_RRO_3_1_GLOBAL_CONFIG_INTERLEAVE_EN	BIT(0)
+
+#define MT_RRO_MSDU_PG_SEG_ADDR0		MT_RRO_TOP(0x620)
+
 #define MT_RRO_ACK_SN_CTRL			MT_RRO_TOP(0x50)
 #define MT_RRO_ACK_SN_CTRL_SN_MASK		GENMASK(27, 16)
 #define MT_RRO_ACK_SN_CTRL_SESSION_MASK		GENMASK(11, 0)
@@ -112,6 +122,8 @@ enum offs_rev {
 #define MT_MCU_INT_EVENT_DMA_INIT		BIT(1)
 #define MT_MCU_INT_EVENT_RESET_DONE		BIT(3)
 
+#define WF_RRO_TOP_STATISTIC(_n)		MT_RRO_TOP(0x180 + _n * 0x4)
+
 /* PLE */
 #define MT_PLE_BASE				0x820c0000
 #define MT_PLE(ofs)				(MT_PLE_BASE + (ofs))
@@ -175,9 +187,6 @@ enum offs_rev {
 #define MT_WTBLOFF_RSCR_RCPI_MODE		GENMASK(31, 30)
 #define MT_WTBLOFF_RSCR_RCPI_PARAM		GENMASK(25, 24)
 
-#define MT_WTBLOFF_ACR(_band)			MT_WTBLOFF(_band, 0x010)
-#define MT_WTBLOFF_ADM_BACKOFFTIME		BIT(29)
-
 /* ETBF: band 0(0x820ea000), band 1(0x820fa000), band 2(0x830ea000) */
 #define MT_WF_ETBF_BASE(_band)			__BASE(WF_ETBF_BASE, (_band))
 #define MT_WF_ETBF(_band, ofs)			(MT_WF_ETBF_BASE(_band) + (ofs))
@@ -329,6 +338,9 @@ enum offs_rev {
 #define MT_ARB_SCR_TX_DISABLE			BIT(8)
 #define MT_ARB_SCR_RX_DISABLE			BIT(9)
 
+#define MT_ARB_TQSAXM0(_band)			MT_WF_ARB(_band, 0x180)
+#define MT_ARB_TQSAXM_ALTX_START_MASK		GENMASK(12, 8)
+
 /* RMAC: band 0(0x820e5000), band 1(0x820f5000), band 2(0x830e5000), */
 #define MT_WF_RMAC_BASE(_band)			__BASE(WF_RMAC_BASE, (_band))
 #define MT_WF_RMAC(_band, ofs)			(MT_WF_RMAC_BASE(_band) + (ofs))
@@ -401,7 +413,9 @@ enum offs_rev {
 
 #define MT_WFDMA0_RX_INT_PCIE_SEL		MT_WFDMA0(0x154)
 #define MT_WFDMA0_RX_INT_SEL_RING3		BIT(3)
+#define MT_WFDMA0_RX_INT_SEL_RING5		BIT(5)
 #define MT_WFDMA0_RX_INT_SEL_RING6		BIT(6)
+#define MT_WFDMA0_RX_INT_SEL_RING9		BIT(9)
 
 #define MT_WFDMA0_MCU_HOST_INT_ENA		MT_WFDMA0(0x1f4)
 
@@ -421,6 +435,7 @@ enum offs_rev {
 #define WF_WFDMA0_GLO_CFG_EXT0			MT_WFDMA0(0x2b0)
 #define WF_WFDMA0_GLO_CFG_EXT0_RX_WB_RXD	BIT(18)
 #define WF_WFDMA0_GLO_CFG_EXT0_WED_MERGE_MODE	BIT(14)
+#define WF_WFDMA0_GLO_CFG_EXT0_OUTSTAND_MASK	GENMASK(27, 24)
 
 #define WF_WFDMA0_GLO_CFG_EXT1			MT_WFDMA0(0x2b4)
 #define WF_WFDMA0_GLO_CFG_EXT1_CALC_MODE	BIT(31)
@@ -440,6 +455,8 @@ enum offs_rev {
 
 #define MT_WFDMA_HOST_CONFIG			MT_WFDMA_EXT_CSR(0x30)
 #define MT_WFDMA_HOST_CONFIG_PDMA_BAND		BIT(0)
+#define MT_WFDMA_HOST_CONFIG_BAND0_PCIE1	BIT(20)
+#define MT_WFDMA_HOST_CONFIG_BAND1_PCIE1	BIT(21)
 #define MT_WFDMA_HOST_CONFIG_BAND2_PCIE1	BIT(22)
 
 #define MT_WFDMA_EXT_CSR_HIF_MISC		MT_WFDMA_EXT_CSR(0x44)
@@ -448,6 +465,9 @@ enum offs_rev {
 #define MT_WFDMA_AXI_R2A_CTRL			MT_WFDMA_EXT_CSR(0x500)
 #define MT_WFDMA_AXI_R2A_CTRL_OUTSTAND_MASK	GENMASK(4, 0)
 
+#define MT_WFDMA_AXI_R2A_CTRL2			MT_WFDMA_EXT_CSR(0x508)
+#define MT_WFDMA_AXI_R2A_CTRL2_OUTSTAND_MASK	GENMASK(31, 28)
+
 #define MT_PCIE_RECOG_ID			0xd7090
 #define MT_PCIE_RECOG_ID_MASK			GENMASK(30, 0)
 #define MT_PCIE_RECOG_ID_SEM			BIT(31)
@@ -503,13 +523,15 @@ enum offs_rev {
 #define MT_INT_RX_DONE_WA_EXT			BIT(3) /* for mt7992 */
 #define MT_INT_RX_DONE_WA_TRI			BIT(3)
 #define MT_INT_RX_TXFREE_MAIN			BIT(17)
+#define MT_INT_RX_TXFREE_BAND1			BIT(15)
 #define MT_INT_RX_TXFREE_TRI			BIT(15)
+#define MT_INT_RX_TXFREE_BAND1_EXT		BIT(19) /* for mt7992 two PCIE*/
 #define MT_INT_RX_DONE_BAND2_EXT		BIT(23)
 #define MT_INT_RX_TXFREE_EXT			BIT(26)
 #define MT_INT_MCU_CMD				BIT(29)
 
 #define MT_INT_RX_DONE_RRO_BAND0		BIT(16)
-#define MT_INT_RX_DONE_RRO_BAND1		BIT(16)
+#define MT_INT_RX_DONE_RRO_BAND1		BIT(17)
 #define MT_INT_RX_DONE_RRO_BAND2		BIT(14)
 #define MT_INT_RX_DONE_RRO_IND			BIT(11)
 #define MT_INT_RX_DONE_MSDU_PG_BAND0		BIT(18)
@@ -600,7 +622,8 @@ enum offs_rev {
 
 /* FW MODE SYNC */
 #define MT_FW_ASSERT_CNT			0x02208274
-#define MT_FW_DUMP_STATE			0x02209e90
+#define MT_FW_WM_DUMP_STATE			0x02209e90
+#define MT_FW_WA_DUMP_STATE			0x7C05B080
 
 #define MT_SWDEF_BASE				0x00401400
 
@@ -697,33 +720,42 @@ enum offs_rev {
 						 ((_wf) << 16) + (ofs))
 #define MT_WF_PHYRX_CSD_IRPI(_band, _wf)	MT_WF_PHYRX_CSD(_band, _wf, 0x1000)
 
-/* PHYRX CTRL */
-#define MT_WF_PHYRX_BAND_BASE			0x83080000
-#define MT_WF_PHYRX_BAND(_band, ofs)		(MT_WF_PHYRX_BAND_BASE + \
+/* PHYDFE CTRL */
+#define MT_WF_PHYDFE_TSSI_TXCTRL01(_band)	MT_WF_PHYRX_CSD(_band, 0, 0xc718)
+#define MT_WF_PHYDFE_TSSI_TXCTRL_POWER_TMAC	GENMASK(31, 24)
+
+/* PHY CTRL */
+#define MT_WF_PHY_BAND_BASE			0x83080000
+#define MT_WF_PHY_BAND(_band, ofs)		(MT_WF_PHY_BAND_BASE + \
 						 ((_band) << 20) + (ofs))
 
-#define MT_WF_PHYRX_BAND_GID_TAB_VLD0(_band)	MT_WF_PHYRX_BAND(_band, 0x1054)
-#define MT_WF_PHYRX_BAND_GID_TAB_VLD1(_band)	MT_WF_PHYRX_BAND(_band, 0x1058)
-#define MT_WF_PHYRX_BAND_GID_TAB_POS0(_band)	MT_WF_PHYRX_BAND(_band, 0x105c)
-#define MT_WF_PHYRX_BAND_GID_TAB_POS1(_band)	MT_WF_PHYRX_BAND(_band, 0x1060)
-#define MT_WF_PHYRX_BAND_GID_TAB_POS2(_band)	MT_WF_PHYRX_BAND(_band, 0x1064)
-#define MT_WF_PHYRX_BAND_GID_TAB_POS3(_band)	MT_WF_PHYRX_BAND(_band, 0x1068)
+#define MT_WF_PHYRX_BAND_GID_TAB_VLD0(_band)	MT_WF_PHY_BAND(_band, 0x1054)
+#define MT_WF_PHYRX_BAND_GID_TAB_VLD1(_band)	MT_WF_PHY_BAND(_band, 0x1058)
+#define MT_WF_PHYRX_BAND_GID_TAB_POS0(_band)	MT_WF_PHY_BAND(_band, 0x105c)
+#define MT_WF_PHYRX_BAND_GID_TAB_POS1(_band)	MT_WF_PHY_BAND(_band, 0x1060)
+#define MT_WF_PHYRX_BAND_GID_TAB_POS2(_band)	MT_WF_PHY_BAND(_band, 0x1064)
+#define MT_WF_PHYRX_BAND_GID_TAB_POS3(_band)	MT_WF_PHY_BAND(_band, 0x1068)
 
-#define MT_WF_PHYRX_BAND_RX_CTRL1(_band)	MT_WF_PHYRX_BAND(_band, 0x2004)
+/* PHYRX CTRL */
+#define MT_WF_PHYRX_BAND_RX_CTRL1(_band)	MT_WF_PHY_BAND(_band, 0x2004)
 #define MT_WF_PHYRX_BAND_RX_CTRL1_IPI_EN	GENMASK(2, 0)
 #define MT_WF_PHYRX_BAND_RX_CTRL1_STSCNT_EN	GENMASK(11, 9)
 
 /* PHYRX CSD BAND */
-#define MT_WF_PHYRX_CSD_BAND_RXTD12(_band)		MT_WF_PHYRX_BAND(_band, 0x8230)
+#define MT_WF_PHYRX_CSD_BAND_RXTD12(_band)		MT_WF_PHY_BAND(_band, 0x8230)
 #define MT_WF_PHYRX_CSD_BAND_RXTD12_IRPI_SW_CLR_ONLY	BIT(18)
 #define MT_WF_PHYRX_CSD_BAND_RXTD12_IRPI_SW_CLR		BIT(29)
 
 /* CONN MCU EXCP CON */
+#define MT_MCU_WA_EXCP_BASE			0x890d0000
 #define MT_MCU_WM_EXCP_BASE			0x89050000
+
 #define MT_MCU_WM_EXCP(ofs)			(MT_MCU_WM_EXCP_BASE + (ofs))
 #define MT_MCU_WM_EXCP_PC_CTRL			MT_MCU_WM_EXCP(0x100)
+#define MT_MCU_WM_EXCP_PC_CTRL_IDX_STATUS	GENMASK(20, 16)
 #define MT_MCU_WM_EXCP_PC_LOG			MT_MCU_WM_EXCP(0x104)
 #define MT_MCU_WM_EXCP_LR_CTRL			MT_MCU_WM_EXCP(0x200)
+#define MT_MCU_WM_EXCP_LR_CTRL_IDX_STATUS	GENMASK(20, 16)
 #define MT_MCU_WM_EXCP_LR_LOG			MT_MCU_WM_EXCP(0x204)
 
 /* CONN AFE CTL CON */
diff --git a/mt7996/testmode.c b/mt7996/testmode.c
new file mode 100644
index 00000000..b542651d
--- /dev/null
+++ b/mt7996/testmode.c
@@ -0,0 +1,2192 @@
+// SPDX-License-Identifier: ISC
+/*
+ * Copyright (C) 2022 MediaTek Inc.
+ */
+
+#include "mt7996.h"
+#include "mac.h"
+#include "mcu.h"
+#include "testmode.h"
+#include "eeprom.h"
+#include "mtk_mcu.h"
+
+enum {
+	TM_CHANGED_TXPOWER,
+	TM_CHANGED_FREQ_OFFSET,
+	TM_CHANGED_SKU_EN,
+	TM_CHANGED_TX_LENGTH,
+	TM_CHANGED_TX_TIME,
+	TM_CHANGED_CFG,
+	TM_CHANGED_OFF_CHAN_CH,
+	TM_CHANGED_OFF_CHAN_CENTER_CH,
+	TM_CHANGED_OFF_CHAN_BW,
+	TM_CHANGED_IPI_THRESHOLD,
+	TM_CHANGED_IPI_PERIOD,
+	TM_CHANGED_IPI_RESET,
+	TM_CHANGED_TXBF_ACT,
+	TM_CHANGED_TX_ANTENNA,
+	TM_CHANGED_TX_RATE_NSS,
+	TM_CHANGED_TX_RATE_IDX,
+
+	/* must be last */
+	NUM_TM_CHANGED
+};
+
+static const u8 tm_change_map[] = {
+	[TM_CHANGED_TXPOWER] = MT76_TM_ATTR_TX_POWER,
+	[TM_CHANGED_FREQ_OFFSET] = MT76_TM_ATTR_FREQ_OFFSET,
+	[TM_CHANGED_SKU_EN] = MT76_TM_ATTR_SKU_EN,
+	[TM_CHANGED_TX_LENGTH] = MT76_TM_ATTR_TX_LENGTH,
+	[TM_CHANGED_TX_TIME] = MT76_TM_ATTR_TX_TIME,
+	[TM_CHANGED_CFG] = MT76_TM_ATTR_CFG,
+	[TM_CHANGED_OFF_CHAN_CH] = MT76_TM_ATTR_OFF_CH_SCAN_CH,
+	[TM_CHANGED_OFF_CHAN_CENTER_CH] = MT76_TM_ATTR_OFF_CH_SCAN_CENTER_CH,
+	[TM_CHANGED_OFF_CHAN_BW] = MT76_TM_ATTR_OFF_CH_SCAN_BW,
+	[TM_CHANGED_IPI_THRESHOLD] = MT76_TM_ATTR_IPI_THRESHOLD,
+	[TM_CHANGED_IPI_PERIOD] = MT76_TM_ATTR_IPI_PERIOD,
+	[TM_CHANGED_IPI_RESET] = MT76_TM_ATTR_IPI_RESET,
+	[TM_CHANGED_TXBF_ACT] = MT76_TM_ATTR_TXBF_ACT,
+	[TM_CHANGED_TX_ANTENNA] = MT76_TM_ATTR_TX_ANTENNA,
+	[TM_CHANGED_TX_RATE_NSS] = MT76_TM_ATTR_TX_RATE_NSS,
+	[TM_CHANGED_TX_RATE_IDX] = MT76_TM_ATTR_TX_RATE_IDX,
+};
+
+static void mt7996_tm_ipi_work(struct work_struct *work);
+static int mt7996_tm_txbf_apply_tx(struct mt7996_phy *phy, u16 wlan_idx,
+				   bool ebf, bool ibf, bool phase_cal);
+
+static u32 mt7996_tm_bw_mapping(enum nl80211_chan_width width, enum bw_mapping_method method)
+{
+	static const u32 width_to_bw[][NUM_BW_MAP] = {
+		[NL80211_CHAN_WIDTH_40] = {FW_CDBW_40MHZ, TM_CBW_40MHZ, BF_CDBW_40MHZ, 40,
+					   FIRST_CONTROL_CHAN_BITMAP_BW40},
+		[NL80211_CHAN_WIDTH_80] = {FW_CDBW_80MHZ, TM_CBW_80MHZ, BF_CDBW_80MHZ, 80,
+					   FIRST_CONTROL_CHAN_BITMAP_BW80},
+		[NL80211_CHAN_WIDTH_80P80] = {FW_CDBW_8080MHZ, TM_CBW_8080MHZ, BF_CDBW_8080MHZ,
+					      80, 0x0},
+		[NL80211_CHAN_WIDTH_160] = {FW_CDBW_160MHZ, TM_CBW_160MHZ, BF_CDBW_160MHZ, 160,
+					    FIRST_CONTROL_CHAN_BITMAP_BW160},
+		[NL80211_CHAN_WIDTH_5] = {FW_CDBW_5MHZ, TM_CBW_5MHZ, BF_CDBW_5MHZ, 5, 0x0},
+		[NL80211_CHAN_WIDTH_10] = {FW_CDBW_10MHZ, TM_CBW_10MHZ, BF_CDBW_10MHZ, 10, 0x0},
+		[NL80211_CHAN_WIDTH_20] = {FW_CDBW_20MHZ, TM_CBW_20MHZ, BF_CDBW_20MHZ, 20, 0x0},
+		[NL80211_CHAN_WIDTH_20_NOHT] = {FW_CDBW_20MHZ, TM_CBW_20MHZ, BF_CDBW_20MHZ,
+						20, 0x0},
+		[NL80211_CHAN_WIDTH_320] = {FW_CDBW_320MHZ, TM_CBW_320MHZ, BF_CDBW_320MHZ,
+					    320, 0x0},
+	};
+
+	if (width >= ARRAY_SIZE(width_to_bw))
+		return 0;
+
+	return width_to_bw[width][method];
+}
+
+static u8 mt7996_tm_rate_mapping(u8 tx_rate_mode, enum rate_mapping_type type)
+{
+	static const u8 rate_to_phy[][NUM_RATE_MAP] = {
+		[MT76_TM_TX_MODE_CCK] = {MT_PHY_TYPE_CCK, BF_LM_LEGACY},
+		[MT76_TM_TX_MODE_OFDM] = {MT_PHY_TYPE_OFDM, BF_LM_LEGACY},
+		[MT76_TM_TX_MODE_HT] = {MT_PHY_TYPE_HT, BF_LM_HT},
+		[MT76_TM_TX_MODE_VHT] = {MT_PHY_TYPE_VHT, BF_LM_VHT},
+		[MT76_TM_TX_MODE_HE_SU] = {MT_PHY_TYPE_HE_SU, BF_LM_HE},
+		[MT76_TM_TX_MODE_HE_EXT_SU] = {MT_PHY_TYPE_HE_EXT_SU, BF_LM_HE},
+		[MT76_TM_TX_MODE_HE_TB] = {MT_PHY_TYPE_HE_TB, BF_LM_HE},
+		[MT76_TM_TX_MODE_HE_MU] = {MT_PHY_TYPE_HE_MU, BF_LM_HE},
+		[MT76_TM_TX_MODE_EHT_SU] = {MT_PHY_TYPE_EHT_SU, BF_LM_EHT},
+		[MT76_TM_TX_MODE_EHT_TRIG] = {MT_PHY_TYPE_EHT_TRIG, BF_LM_EHT},
+		[MT76_TM_TX_MODE_EHT_MU] = {MT_PHY_TYPE_EHT_MU, BF_LM_EHT},
+	};
+
+	if (tx_rate_mode > MT76_TM_TX_MODE_MAX)
+		return -EINVAL;
+
+	return rate_to_phy[tx_rate_mode][type];
+}
+
+static int
+mt7996_tm_check_antenna(struct mt7996_phy *phy)
+{
+	struct mt76_testmode_data *td = &phy->mt76->test;
+	struct mt7996_dev *dev = phy->dev;
+	u8 band_idx = phy->mt76->band_idx;
+	u32 chainmask = phy->mt76->chainmask;
+	u32 aux_rx_mask;
+
+	chainmask = chainmask >> dev->chainshift[band_idx];
+	aux_rx_mask = BIT(fls(chainmask)) * phy->has_aux_rx;
+	if (td->tx_antenna_mask & ~(chainmask | aux_rx_mask)) {
+		dev_err(dev->mt76.dev,
+			"tx antenna mask 0x%x exceeds hw limit (chainmask 0x%x, has aux rx: %s)\n",
+			td->tx_antenna_mask, chainmask, phy->has_aux_rx ? "yes" : "no");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int
+mt7996_tm_set(struct mt7996_dev *dev, u32 func_idx, u32 data)
+{
+	struct mt7996_tm_req req = {
+		.rf_test = {
+			.tag = cpu_to_le16(UNI_RF_TEST_CTRL),
+			.len = cpu_to_le16(sizeof(req.rf_test)),
+			.action = RF_ACTION_SET,
+			.op.rf.func_idx = func_idx,
+			.op.rf.param.func_data = cpu_to_le32(data),
+		},
+	};
+	bool wait = (data == RF_CMD(START_TX)) ? true : false;
+
+	return mt76_mcu_send_msg(&dev->mt76, MCU_WM_UNI_CMD(TESTMODE_CTRL), &req,
+				 sizeof(req), wait);
+}
+
+static int
+mt7996_tm_get(struct mt7996_dev *dev, u32 func_idx, u32 data, u32 *result)
+{
+	struct mt7996_tm_req req = {
+		.rf_test = {
+			.tag = cpu_to_le16(UNI_RF_TEST_CTRL),
+			.len = cpu_to_le16(sizeof(req.rf_test)),
+			.action = RF_ACTION_GET,
+			.op.rf.func_idx = func_idx,
+			.op.rf.param.func_data = cpu_to_le32(data),
+		},
+	};
+	struct mt7996_tm_event *event;
+	struct sk_buff *skb;
+	int ret;
+
+	ret = mt76_mcu_send_and_get_msg(&dev->mt76, MCU_WM_UNI_CMD_QUERY(TESTMODE_CTRL),
+					&req, sizeof(req), true, &skb);
+	if (ret)
+		return ret;
+
+	event = (struct mt7996_tm_event *)skb->data;
+	*result = event->result.payload_length;
+
+	dev_kfree_skb(skb);
+
+	return ret;
+}
+
+static void
+mt7996_tm_set_antenna(struct mt7996_phy *phy, u32 func_idx)
+{
+#define SPE_INDEX_MASK		BIT(31)
+#define TX_ANTENNA_MASK		GENMASK(4, 0)
+#define RX_ANTENNA_MASK		GENMASK(20, 16)
+	struct mt7996_dev *dev = phy->dev;
+	struct mt76_testmode_data *td = &phy->mt76->test;
+	u32 antenna_mask;
+
+	if (!mt76_testmode_param_present(td, MT76_TM_ATTR_TX_ANTENNA))
+		return;
+
+	if (func_idx == SET_ID(TX_PATH))
+		antenna_mask = td->tx_spe_idx ? (SPE_INDEX_MASK | td->tx_spe_idx) :
+						td->tx_antenna_mask & TX_ANTENNA_MASK;
+	else if (func_idx == SET_ID(RX_PATH))
+		antenna_mask = u32_encode_bits(td->tx_antenna_mask, RX_ANTENNA_MASK);
+	else
+		return;
+
+	mt7996_tm_set(dev, func_idx, antenna_mask);
+}
+
+static void
+mt7996_tm_set_mac_addr(struct mt7996_dev *dev, u8 *addr, u32 func_idx)
+{
+#define REMAIN_PART_TAG		BIT(18)
+	u32 own_mac_first = 0, own_mac_remain = 0;
+	int len = sizeof(u32);
+
+	memcpy(&own_mac_first, addr, len);
+	mt7996_tm_set(dev, func_idx, own_mac_first);
+	/* Set the remain part of mac address */
+	memcpy(&own_mac_remain, addr + len, ETH_ALEN - len);
+	mt7996_tm_set(dev, func_idx | REMAIN_PART_TAG, own_mac_remain);
+}
+
+static int
+mt7996_tm_rf_switch_mode(struct mt7996_dev *dev, u32 op_mode)
+{
+	struct mt7996_tm_req req = {
+		.rf_test = {
+			.tag = cpu_to_le16(UNI_RF_TEST_CTRL),
+			.len = cpu_to_le16(sizeof(req.rf_test)),
+			.action = RF_ACTION_SWITCH_TO_RF_TEST,
+			.op.op_mode = cpu_to_le32(op_mode),
+		},
+	};
+
+	return mt76_mcu_send_msg(&dev->mt76, MCU_WM_UNI_CMD(TESTMODE_CTRL), &req,
+				 sizeof(req), false);
+}
+
+static void
+mt7996_tm_init(struct mt7996_phy *phy, bool en)
+{
+	struct mt7996_dev *dev = phy->dev;
+	struct mt7996_vif *mvif = (struct mt7996_vif *)phy->monitor_vif->drv_priv;
+	u8 rf_test_mode = en ? RF_OPER_RF_TEST : RF_OPER_NORMAL;
+
+	if (!test_bit(MT76_STATE_RUNNING, &phy->mt76->state))
+		return;
+
+	mt7996_mcu_set_tx_power_ctrl(phy, POWER_CTRL(ATE_MODE), en);
+	mt7996_mcu_set_tx_power_ctrl(phy, POWER_CTRL(SKU_POWER_LIMIT), !en);
+	mt7996_mcu_set_tx_power_ctrl(phy, POWER_CTRL(BACKOFF_POWER_LIMIT), !en);
+
+	mt7996_tm_rf_switch_mode(dev, rf_test_mode);
+
+	mt7996_mcu_add_bss_info(phy, &phy->monitor_vif->bss_conf, &mvif->deflink, &mvif->sta.deflink, en);
+	mt7996_mcu_add_sta(dev, &phy->monitor_vif->bss_conf, &mvif->deflink, NULL, &mvif->sta.deflink, en, false);
+
+	mt7996_tm_set(dev, SET_ID(BAND_IDX), phy->mt76->band_idx);
+
+	/* use firmware counter for RX stats */
+	phy->mt76->test.flag |= MT_TM_FW_RX_COUNT;
+
+	if (en)
+		INIT_DELAYED_WORK(&phy->ipi_work, mt7996_tm_ipi_work);
+}
+
+void
+mt7996_tm_update_channel(struct mt7996_phy *phy)
+{
+#define CHAN_FREQ_BW_80P80_TAG		(SET_ID(CHAN_FREQ) | BIT(16))
+	struct mt7996_dev *dev = phy->dev;
+	struct cfg80211_chan_def *chandef = &phy->mt76->chandef;
+	struct ieee80211_channel *chan = chandef->chan;
+	u8 width = chandef->width;
+	static const u8 ch_band[] = {
+		[NL80211_BAND_2GHZ] = 0,
+		[NL80211_BAND_5GHZ] = 1,
+		[NL80211_BAND_6GHZ] = 2,
+	};
+
+	if (!chan || !chandef) {
+		dev_info(dev->mt76.dev, "chandef not found, channel update failed!\n");
+		return;
+	}
+
+	/* system bw */
+	mt7996_tm_set(dev, SET_ID(CBW), mt7996_tm_bw_mapping(width, BW_MAP_NL_TO_FW));
+
+	if (width == NL80211_CHAN_WIDTH_80P80) {
+		width = NL80211_CHAN_WIDTH_160;
+		mt7996_tm_set(dev, CHAN_FREQ_BW_80P80_TAG, chandef->center_freq2 * 1000);
+	}
+
+	/* TODO: define per-packet bw */
+	/* per-packet bw */
+	mt7996_tm_set(dev, SET_ID(DBW), mt7996_tm_bw_mapping(width, BW_MAP_NL_TO_FW));
+
+	/* control channel selection index */
+	mt7996_tm_set(dev, SET_ID(PRIMARY_CH), 0);
+	mt7996_tm_set(dev, SET_ID(BAND), ch_band[chan->band]);
+
+	/* trigger switch channel calibration */
+	mt7996_tm_set(dev, SET_ID(CHAN_FREQ), chandef->center_freq1 * 1000);
+
+	// TODO: update power limit table
+}
+
+static void
+mt7996_tm_tx_stop(struct mt76_phy *mphy)
+{
+	struct mt76_testmode_data *td = &mphy->test;
+	struct mt7996_phy *phy = mphy->priv;
+	struct mt7996_dev *dev = phy->dev;
+
+	mt7996_tm_set(dev, SET_ID(COMMAND), RF_CMD(STOP_TEST));
+	td->tx_pending = 0;
+}
+
+static void
+mt7996_tm_set_tx_frames(struct mt7996_phy *phy, bool en)
+{
+#define FRAME_CONTROL		0x88
+	struct mt76_testmode_data *td = &phy->mt76->test;
+	struct mt7996_dev *dev = phy->dev;
+
+	//TODO: RU operation, replace mcs, nss, and ldpc
+	if (en) {
+		mt7996_tm_set(dev, SET_ID(MAC_HEADER), FRAME_CONTROL);
+		mt7996_tm_set(dev, SET_ID(SEQ_CTRL), 0);
+		mt7996_tm_set(dev, SET_ID(TX_COUNT), td->tx_count);
+		mt7996_tm_set(dev, SET_ID(TX_MODE),
+			      mt7996_tm_rate_mapping(td->tx_rate_mode, RATE_MODE_TO_PHY));
+		mt7996_tm_set(dev, SET_ID(TX_RATE), td->tx_rate_idx);
+
+		if (mt76_testmode_param_present(td, MT76_TM_ATTR_TX_POWER))
+			mt7996_tm_set(dev, SET_ID(POWER), td->tx_power[0]);
+
+		if (mt76_testmode_param_present(td, MT76_TM_ATTR_TX_TIME)) {
+			mt7996_tm_set(dev, SET_ID(TX_LEN), 0);
+			mt7996_tm_set(dev, SET_ID(TX_TIME), td->tx_time);
+		} else {
+			mt7996_tm_set(dev, SET_ID(TX_LEN), td->tx_mpdu_len);
+			mt7996_tm_set(dev, SET_ID(TX_TIME), 0);
+		}
+
+		mt7996_tm_set_antenna(phy, SET_ID(TX_PATH));
+		mt7996_tm_set_antenna(phy, SET_ID(RX_PATH));
+		mt7996_tm_set(dev, SET_ID(STBC), td->tx_rate_stbc);
+		mt7996_tm_set(dev, SET_ID(ENCODE_MODE), td->tx_rate_ldpc);
+		mt7996_tm_set(dev, SET_ID(IBF_ENABLE), td->ibf);
+		mt7996_tm_set(dev, SET_ID(EBF_ENABLE), td->ebf);
+		mt7996_tm_set(dev, SET_ID(IPG), td->tx_ipg);
+		mt7996_tm_set(dev, SET_ID(GI), td->tx_rate_sgi);
+		mt7996_tm_set(dev, SET_ID(NSS), td->tx_rate_nss);
+		mt7996_tm_set(dev, SET_ID(AID_OFFSET), 0);
+		mt7996_tm_set(dev, SET_ID(PUNCTURE), td->tx_preamble_puncture);
+
+		mt7996_tm_set(dev, SET_ID(MAX_PE), 2);
+		mt7996_tm_set(dev, SET_ID(HW_TX_MODE), 0);
+		if (!td->bf_en)
+			mt7996_tm_update_channel(phy);
+
+		/* trigger firmware to start TX */
+		mt7996_tm_set(dev, SET_ID(COMMAND), RF_CMD(START_TX));
+	} else {
+		mt7996_tm_tx_stop(phy->mt76);
+	}
+}
+
+static int
+mt7996_tm_rx_stats_user_ctrl(struct mt7996_phy *phy, u16 user_idx)
+{
+	struct mt7996_dev *dev = phy->dev;
+	struct mt7996_tm_rx_req req = {
+		.band = phy->mt76->band_idx,
+		.user_ctrl = {
+			.tag = cpu_to_le16(UNI_TM_RX_STAT_SET_USER_CTRL),
+			.len = cpu_to_le16(sizeof(req.user_ctrl)),
+			.band_idx = phy->mt76->band_idx,
+			.user_idx = cpu_to_le16(user_idx),
+		},
+	};
+
+	return mt76_mcu_send_msg(&dev->mt76, MCU_WM_UNI_CMD(TESTMODE_RX_STAT), &req,
+				 sizeof(req), false);
+}
+
+static void
+mt7996_tm_set_rx_frames(struct mt7996_phy *phy, bool en)
+{
+#define RX_MU_DISABLE	0xf800
+	struct mt76_testmode_data *td = &phy->mt76->test;
+	struct mt7996_dev *dev = phy->dev;
+	int ret;
+
+	if (en) {
+		ret = mt7996_tm_rx_stats_user_ctrl(phy, td->aid);
+		if (ret) {
+			dev_info(dev->mt76.dev, "Set RX stats user control failed!\n");
+			return;
+		}
+
+		if (!td->bf_en)
+			mt7996_tm_update_channel(phy);
+
+		if (td->tx_rate_mode >= MT76_TM_TX_MODE_HE_MU) {
+			if (td->aid)
+				ret = mt7996_tm_set(dev, SET_ID(RX_MU_AID), td->aid);
+			else
+				ret = mt7996_tm_set(dev, SET_ID(RX_MU_AID), RX_MU_DISABLE);
+		}
+		mt7996_tm_set(dev, SET_ID(TX_MODE),
+			      mt7996_tm_rate_mapping(td->tx_rate_mode, RATE_MODE_TO_PHY));
+		mt7996_tm_set(dev, SET_ID(GI), td->tx_rate_sgi);
+		mt7996_tm_set_antenna(phy, SET_ID(RX_PATH));
+		mt7996_tm_set(dev, SET_ID(MAX_PE), 2);
+
+		mt7996_tm_set_mac_addr(dev, td->addr[1], SET_ID(SA));
+
+		/* trigger firmware to start RX */
+		mt7996_tm_set(dev, SET_ID(COMMAND), RF_CMD(START_RX));
+	} else {
+		/* trigger firmware to stop RX */
+		mt7996_tm_set(dev, SET_ID(COMMAND), RF_CMD(STOP_TEST));
+	}
+}
+
+static void
+mt7996_tm_set_tx_cont(struct mt7996_phy *phy, bool en)
+{
+#define CONT_WAVE_MODE_OFDM	3
+	struct mt76_testmode_data *td = &phy->mt76->test;
+	struct mt7996_dev *dev = phy->dev;
+
+	if (en) {
+		mt7996_tm_update_channel(phy);
+		mt7996_tm_set(dev, SET_ID(TX_MODE),
+			      mt7996_tm_rate_mapping(td->tx_rate_mode, RATE_MODE_TO_PHY));
+		mt7996_tm_set(dev, SET_ID(TX_RATE), td->tx_rate_idx);
+		/* fix payload is OFDM */
+		mt7996_tm_set(dev, SET_ID(CONT_WAVE_MODE), CONT_WAVE_MODE_OFDM);
+		mt7996_tm_set(dev, SET_ID(ANT_MASK), td->tx_antenna_mask);
+
+		/* trigger firmware to start CONT TX */
+		mt7996_tm_set(dev, SET_ID(COMMAND), RF_CMD(CONT_WAVE));
+	} else {
+		/* trigger firmware to stop CONT TX  */
+		mt7996_tm_set(dev, SET_ID(COMMAND), RF_CMD(STOP_TEST));
+	}
+}
+
+static int
+mt7996_tm_group_prek(struct mt7996_phy *phy, enum mt76_testmode_state state)
+{
+	u8 *eeprom, do_precal;
+	u32 i, group_size, dpd_size, size, offs, *pre_cal;
+	int ret = 0;
+	struct mt7996_dev *dev = phy->dev;
+	struct mt76_dev *mdev = &dev->mt76;
+	struct mt7996_tm_req req = {
+		.rf_test = {
+			.tag = cpu_to_le16(UNI_RF_TEST_CTRL),
+			.len = cpu_to_le16(sizeof(req.rf_test)),
+			.action = RF_ACTION_IN_RF_TEST,
+			.icap_len = RF_TEST_ICAP_LEN,
+			.op.rf.func_idx = cpu_to_le32(RF_TEST_RE_CAL),
+			.op.rf.param.cal_param.func_data = cpu_to_le32(RF_PRE_CAL),
+			.op.rf.param.cal_param.band_idx = phy->mt76->band_idx,
+		},
+	};
+
+	if (!dev->flash_mode) {
+		dev_err(dev->mt76.dev, "Currently not in FLASH or BIN FILE mode, return!\n");
+		return -EOPNOTSUPP;
+	}
+
+	eeprom = mdev->eeprom.data;
+	dev->cur_prek_offset = 0;
+	group_size = MT_EE_CAL_GROUP_SIZE;
+	dpd_size = MT_EE_CAL_DPD_SIZE;
+	size = group_size + dpd_size;
+	offs = MT_EE_DO_PRE_CAL;
+	do_precal = (MT_EE_WIFI_CAL_GROUP_2G * !!PREK(GROUP_SIZE_2G)) |
+		    (MT_EE_WIFI_CAL_GROUP_5G * !!PREK(GROUP_SIZE_5G)) |
+		    (MT_EE_WIFI_CAL_GROUP_6G * !!PREK(GROUP_SIZE_6G));
+
+	switch (state) {
+	case MT76_TM_STATE_GROUP_PREK:
+		if (!dev->cal) {
+			dev->cal = devm_kzalloc(mdev->dev, size, GFP_KERNEL);
+			if (!dev->cal)
+				return -ENOMEM;
+		}
+
+		ret = mt76_mcu_send_msg(&dev->mt76, MCU_WM_UNI_CMD(TESTMODE_CTRL), &req,
+					sizeof(req), false);
+		wait_event_timeout(mdev->mcu.wait, dev->cur_prek_offset == group_size,
+				   30 * HZ);
+
+		if (ret)
+			dev_err(dev->mt76.dev, "Group Pre-cal: mcu send msg failed!\n");
+		else
+			eeprom[offs] |= do_precal;
+		break;
+	case MT76_TM_STATE_GROUP_PREK_DUMP:
+		pre_cal = (u32 *)dev->cal;
+		if (!pre_cal) {
+			dev_info(dev->mt76.dev, "Not group pre-cal yet!\n");
+			return ret;
+		}
+		dev_info(dev->mt76.dev, "Group Pre-Cal:\n");
+		for (i = 0; i < (group_size / sizeof(u32)); i += 4) {
+			dev_info(dev->mt76.dev, "[0x%08lx] 0x%8x 0x%8x 0x%8x 0x%8x\n",
+				 i * sizeof(u32), pre_cal[i], pre_cal[i + 1],
+				 pre_cal[i + 2], pre_cal[i + 3]);
+		}
+		break;
+	case MT76_TM_STATE_GROUP_PREK_CLEAN:
+		pre_cal = (u32 *)dev->cal;
+		if (!pre_cal)
+			return ret;
+		memset(pre_cal, 0, group_size);
+		eeprom[offs] &= ~MT_EE_WIFI_CAL_GROUP;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return ret;
+}
+
+static int
+mt7996_tm_dpd_prek_send_req(struct mt7996_phy *phy, struct mt7996_tm_req *req,
+			    const struct ieee80211_channel *chan_list, u32 channel_size,
+			    enum nl80211_chan_width width, u32 func_data)
+{
+	struct mt7996_dev *dev = phy->dev;
+	struct mt76_phy *mphy = phy->mt76;
+	struct cfg80211_chan_def chandef_backup, *chandef = &mphy->chandef;
+	struct ieee80211_channel chan_backup;
+	int i, ret, skip_ch_num = DPD_CH_NUM(BW20_5G_SKIP);
+
+	if (!chan_list)
+		return -EOPNOTSUPP;
+	if (!channel_size)
+		return 0;
+
+	req->rf_test.op.rf.param.cal_param.func_data = cpu_to_le32(func_data);
+
+	memcpy(&chan_backup, chandef->chan, sizeof(struct ieee80211_channel));
+	memcpy(&chandef_backup, chandef, sizeof(struct cfg80211_chan_def));
+
+	for (i = 0; i < channel_size; i++) {
+		if (chan_list[i].band == NL80211_BAND_5GHZ &&
+		    chan_list[i].hw_value >= dpd_5g_skip_ch_list[0].hw_value &&
+		    chan_list[i].hw_value <= dpd_5g_skip_ch_list[skip_ch_num - 1].hw_value)
+			continue;
+
+		memcpy(chandef->chan, &chan_list[i], sizeof(struct ieee80211_channel));
+		chandef->width = width;
+
+		/* set channel switch reason */
+		mphy->hw->conf.flags |= IEEE80211_CONF_OFFCHANNEL;
+		mt7996_mcu_set_chan_info(phy, UNI_CHANNEL_SWITCH);
+
+		ret = mt76_mcu_send_msg(&dev->mt76, MCU_WM_UNI_CMD(TESTMODE_CTRL), req,
+					sizeof(*req), false);
+		if (ret) {
+			dev_err(dev->mt76.dev, "DPD Pre-cal: mcu send msg failed!\n");
+			goto out;
+		}
+	}
+
+out:
+	mphy->hw->conf.flags &= ~IEEE80211_CONF_OFFCHANNEL;
+	memcpy(chandef, &chandef_backup, sizeof(struct cfg80211_chan_def));
+	memcpy(chandef->chan, &chan_backup, sizeof(struct ieee80211_channel));
+	mt7996_mcu_set_chan_info(phy, UNI_CHANNEL_SWITCH);
+
+	return ret;
+}
+
+static int
+mt7996_tm_dpd_prek(struct mt7996_phy *phy, enum mt76_testmode_state state)
+{
+	struct mt7996_dev *dev = phy->dev;
+	struct mt76_dev *mdev = &dev->mt76;
+	struct mt76_phy *mphy = phy->mt76;
+	struct mt7996_tm_req req = {
+		.rf_test = {
+			.tag = cpu_to_le16(UNI_RF_TEST_CTRL),
+			.len = cpu_to_le16(sizeof(req.rf_test)),
+			.action = RF_ACTION_IN_RF_TEST,
+			.icap_len = RF_TEST_ICAP_LEN,
+			.op.rf.func_idx = cpu_to_le32(RF_TEST_RE_CAL),
+			.op.rf.param.cal_param.band_idx = phy->mt76->band_idx,
+		},
+	};
+	u32 i, j, group_size, dpd_size, size, offs, *pre_cal;
+	u32 wait_on_prek_offset = 0;
+	u8 do_precal, *eeprom;
+	int ret = 0;
+
+	if (!dev->flash_mode) {
+		dev_err(dev->mt76.dev, "Currently not in FLASH or BIN FILE mode, return!\n");
+		return -EOPNOTSUPP;
+	}
+
+	eeprom = mdev->eeprom.data;
+	dev->cur_prek_offset = 0;
+	group_size = MT_EE_CAL_GROUP_SIZE;
+	dpd_size = MT_EE_CAL_DPD_SIZE;
+	size = group_size + dpd_size;
+	offs = MT_EE_DO_PRE_CAL;
+
+	if (!dev->cal && state < MT76_TM_STATE_DPD_DUMP) {
+		dev->cal = devm_kzalloc(mdev->dev, size, GFP_KERNEL);
+		if (!dev->cal)
+			return -ENOMEM;
+	}
+
+	switch (state) {
+	case MT76_TM_STATE_DPD_2G:
+		ret = mt7996_tm_dpd_prek_send_req(phy, &req, dpd_2g_ch_list_bw20,
+						  DPD_CH_NUM(BW20_2G),
+						  NL80211_CHAN_WIDTH_20, RF_DPD_FLAT_CAL);
+		wait_on_prek_offset += DPD_CH_NUM(BW20_2G) * DPD_PER_CH_BW20_SIZE;
+		wait_event_timeout(mdev->mcu.wait, dev->cur_prek_offset == wait_on_prek_offset,
+				   30 * HZ);
+
+		do_precal = MT_EE_WIFI_CAL_DPD_2G;
+		break;
+	case MT76_TM_STATE_DPD_5G:
+		/* 5g channel bw20 calibration */
+		ret = mt7996_tm_dpd_prek_send_req(phy, &req, mphy->sband_5g.sband.channels,
+						  mphy->sband_5g.sband.n_channels,
+						  NL80211_CHAN_WIDTH_20, RF_DPD_FLAT_5G_CAL);
+		if (ret)
+			return ret;
+		wait_on_prek_offset += DPD_CH_NUM(BW20_5G) * DPD_PER_CH_BW20_SIZE;
+		wait_event_timeout(mdev->mcu.wait, dev->cur_prek_offset == wait_on_prek_offset,
+				   30 * HZ);
+
+		/* 5g channel bw80 calibration */
+		ret = mt7996_tm_dpd_prek_send_req(phy, &req, dpd_5g_ch_list_bw80,
+						  DPD_CH_NUM(BW80_5G),
+						  NL80211_CHAN_WIDTH_80, RF_DPD_FLAT_5G_MEM_CAL);
+		if (ret)
+			return ret;
+		wait_on_prek_offset += DPD_CH_NUM(BW80_5G) * DPD_PER_CH_GT_BW20_SIZE;
+		wait_event_timeout(mdev->mcu.wait, dev->cur_prek_offset == wait_on_prek_offset,
+				   30 * HZ);
+
+		/* 5g channel bw160 calibration */
+		ret = mt7996_tm_dpd_prek_send_req(phy, &req, dpd_5g_ch_list_bw160,
+						  DPD_CH_NUM(BW160_5G),
+						  NL80211_CHAN_WIDTH_160, RF_DPD_FLAT_5G_MEM_CAL);
+		wait_on_prek_offset += DPD_CH_NUM(BW160_5G) * DPD_PER_CH_GT_BW20_SIZE;
+		wait_event_timeout(mdev->mcu.wait, dev->cur_prek_offset == wait_on_prek_offset,
+				   30 * HZ);
+
+		do_precal = MT_EE_WIFI_CAL_DPD_5G;
+		break;
+	case MT76_TM_STATE_DPD_6G:
+		/* 6g channel bw20 calibration */
+		ret = mt7996_tm_dpd_prek_send_req(phy, &req, mphy->sband_6g.sband.channels,
+						  mphy->sband_6g.sband.n_channels,
+						  NL80211_CHAN_WIDTH_20, RF_DPD_FLAT_6G_CAL);
+		if (ret)
+			return ret;
+		wait_on_prek_offset += DPD_CH_NUM(BW20_6G) * DPD_PER_CH_BW20_SIZE;
+		wait_event_timeout(mdev->mcu.wait, dev->cur_prek_offset == wait_on_prek_offset,
+				   30 * HZ);
+
+		/* 6g channel bw80 calibration */
+		ret = mt7996_tm_dpd_prek_send_req(phy, &req, dpd_6g_ch_list_bw80,
+						  DPD_CH_NUM(BW80_6G),
+						  NL80211_CHAN_WIDTH_80, RF_DPD_FLAT_6G_MEM_CAL);
+		if (ret)
+			return ret;
+		wait_on_prek_offset += DPD_CH_NUM(BW80_6G) * DPD_PER_CH_GT_BW20_SIZE;
+		wait_event_timeout(mdev->mcu.wait, dev->cur_prek_offset == wait_on_prek_offset,
+				   30 * HZ);
+
+		/* 6g channel bw160 calibration */
+		ret = mt7996_tm_dpd_prek_send_req(phy, &req, dpd_6g_ch_list_bw160,
+						  DPD_CH_NUM(BW160_6G),
+						  NL80211_CHAN_WIDTH_160, RF_DPD_FLAT_6G_MEM_CAL);
+		if (ret)
+			return ret;
+		wait_on_prek_offset += DPD_CH_NUM(BW160_6G) * DPD_PER_CH_GT_BW20_SIZE;
+		wait_event_timeout(mdev->mcu.wait, dev->cur_prek_offset == wait_on_prek_offset,
+				   30 * HZ);
+
+		/* 6g channel bw320 calibration */
+		ret = mt7996_tm_dpd_prek_send_req(phy, &req, dpd_6g_ch_list_bw320,
+						  DPD_CH_NUM(BW320_6G),
+						  NL80211_CHAN_WIDTH_320, RF_DPD_FLAT_6G_MEM_CAL);
+		wait_on_prek_offset += DPD_CH_NUM(BW320_6G) * DPD_PER_CH_GT_BW20_SIZE;
+		wait_event_timeout(mdev->mcu.wait, dev->cur_prek_offset == wait_on_prek_offset,
+				   30 * HZ);
+
+		do_precal = MT_EE_WIFI_CAL_DPD_6G;
+		break;
+	case MT76_TM_STATE_DPD_DUMP:
+		if (!dev->cal) {
+			dev_info(dev->mt76.dev, "Not DPD pre-cal yet!\n");
+			return ret;
+		}
+		pre_cal = (u32 *)dev->cal;
+		dev_info(dev->mt76.dev, "DPD Pre-Cal:\n");
+		for (i = 0; i < dpd_size / sizeof(u32); i += 4) {
+			j = i + (group_size / sizeof(u32));
+			dev_info(dev->mt76.dev, "[0x%08lx] 0x%8x 0x%8x 0x%8x 0x%8x\n",
+				 j * sizeof(u32), pre_cal[j], pre_cal[j + 1],
+				 pre_cal[j + 2], pre_cal[j + 3]);
+		}
+		return 0;
+	case MT76_TM_STATE_DPD_CLEAN:
+		pre_cal = (u32 *)dev->cal;
+		if (!pre_cal)
+			return ret;
+		memset(pre_cal + (group_size / sizeof(u32)), 0, dpd_size);
+		do_precal = MT_EE_WIFI_CAL_DPD;
+		eeprom[offs] &= ~do_precal;
+		return 0;
+	default:
+		return -EINVAL;
+	}
+
+	if (!ret)
+		eeprom[offs] |= do_precal;
+
+	return ret;
+}
+
+static int
+mt7996_tm_dump_precal(struct mt76_phy *mphy, struct sk_buff *msg, int flag, int type)
+{
+#define DPD_PER_CHAN_SIZE_MASK		GENMASK(31, 30)
+#define DPD_2G_RATIO_MASK		GENMASK(29, 20)
+#define DPD_5G_RATIO_MASK		GENMASK(19, 10)
+#define DPD_6G_RATIO_MASK		GENMASK(9, 0)
+	struct mt7996_phy *phy = mphy->priv;
+	struct mt7996_dev *dev = phy->dev;
+	u32 i, group_size, dpd_size, total_size, size, dpd_info = 0;
+	u32 dpd_size_2g, dpd_size_5g, dpd_size_6g;
+	u32 base, offs, transmit_size = 1000;
+	u8 *pre_cal, *eeprom;
+	void *precal;
+	enum prek_ops {
+		PREK_GET_INFO,
+		PREK_SYNC_ALL,
+		PREK_SYNC_GROUP,
+		PREK_SYNC_DPD_2G,
+		PREK_SYNC_DPD_5G,
+		PREK_SYNC_DPD_6G,
+		PREK_CLEAN_GROUP,
+		PREK_CLEAN_DPD,
+	};
+
+	if (!dev->cal) {
+		dev_info(dev->mt76.dev, "Not pre-cal yet!\n");
+		return 0;
+	}
+
+	group_size = MT_EE_CAL_GROUP_SIZE;
+	dpd_size = MT_EE_CAL_DPD_SIZE;
+	total_size = group_size + dpd_size;
+	pre_cal = dev->cal;
+	eeprom = dev->mt76.eeprom.data;
+	offs = MT_EE_DO_PRE_CAL;
+
+	dpd_size_2g = MT_EE_CAL_DPD_SIZE_2G;
+	dpd_size_5g = MT_EE_CAL_DPD_SIZE_5G;
+	dpd_size_6g = MT_EE_CAL_DPD_SIZE_6G;
+
+	switch (type) {
+	case PREK_SYNC_ALL:
+		base = 0;
+		size = total_size;
+		break;
+	case PREK_SYNC_GROUP:
+		base = 0;
+		size = group_size;
+		break;
+	case PREK_SYNC_DPD_2G:
+		base = group_size;
+		size = dpd_size_2g;
+		break;
+	case PREK_SYNC_DPD_5G:
+		base = group_size + dpd_size_2g;
+		size = dpd_size_5g;
+		break;
+	case PREK_SYNC_DPD_6G:
+		base = group_size + dpd_size_2g + dpd_size_5g;
+		size = dpd_size_6g;
+		break;
+	case PREK_GET_INFO:
+		break;
+	default:
+		return 0;
+	}
+
+	if (!flag) {
+		if (eeprom[offs] & MT_EE_WIFI_CAL_DPD) {
+			dpd_info |= u32_encode_bits(1, DPD_PER_CHAN_SIZE_MASK) |
+				    u32_encode_bits(dpd_size_2g / MT_EE_CAL_UNIT,
+						    DPD_2G_RATIO_MASK) |
+				    u32_encode_bits(dpd_size_5g / MT_EE_CAL_UNIT,
+						    DPD_5G_RATIO_MASK) |
+				    u32_encode_bits(dpd_size_6g / MT_EE_CAL_UNIT,
+						    DPD_6G_RATIO_MASK);
+		}
+		dev->cur_prek_offset = 0;
+		precal = nla_nest_start(msg, MT76_TM_ATTR_PRECAL_INFO);
+		if (!precal)
+			return -ENOMEM;
+		nla_put_u32(msg, 0, group_size);
+		nla_put_u32(msg, 1, dpd_size);
+		nla_put_u32(msg, 2, dpd_info);
+		nla_put_u32(msg, 3, transmit_size);
+		nla_put_u32(msg, 4, eeprom[offs]);
+		nla_nest_end(msg, precal);
+	} else {
+		precal = nla_nest_start(msg, MT76_TM_ATTR_PRECAL);
+		if (!precal)
+			return -ENOMEM;
+
+		transmit_size = (dev->cur_prek_offset + transmit_size < size) ?
+				transmit_size : (size - dev->cur_prek_offset);
+		for (i = 0; i < transmit_size; i++) {
+			if (nla_put_u8(msg, i, pre_cal[base + dev->cur_prek_offset + i]))
+				return -ENOMEM;
+		}
+		dev->cur_prek_offset += transmit_size;
+
+		nla_nest_end(msg, precal);
+	}
+
+	return 0;
+}
+
+static void
+mt7996_tm_re_cal_event(struct mt7996_dev *dev, struct mt7996_tm_rf_test_result *result,
+		       struct mt7996_tm_rf_test_data *data)
+{
+	u32 base, dpd_size_2g, dpd_size_5g, dpd_size_6g, cal_idx, cal_type, len = 0;
+	u8 *pre_cal;
+
+	pre_cal = dev->cal;
+	dpd_size_2g = MT_EE_CAL_DPD_SIZE_2G;
+	dpd_size_5g = MT_EE_CAL_DPD_SIZE_5G;
+	dpd_size_6g = MT_EE_CAL_DPD_SIZE_6G;
+
+	cal_idx = le32_to_cpu(data->cal_idx);
+	cal_type = le32_to_cpu(data->cal_type);
+	len = le32_to_cpu(result->payload_length);
+	len = len - sizeof(struct mt7996_tm_rf_test_data);
+
+	switch (cal_type) {
+	case RF_PRE_CAL:
+		base = 0;
+		break;
+	case RF_DPD_FLAT_CAL:
+		base = MT_EE_CAL_GROUP_SIZE;
+		break;
+	case RF_DPD_FLAT_5G_CAL:
+	case RF_DPD_FLAT_5G_MEM_CAL:
+		base = MT_EE_CAL_GROUP_SIZE + dpd_size_2g;
+		break;
+	case RF_DPD_FLAT_6G_CAL:
+	case RF_DPD_FLAT_6G_MEM_CAL:
+		base = MT_EE_CAL_GROUP_SIZE + dpd_size_2g + dpd_size_5g;
+		break;
+	default:
+		dev_info(dev->mt76.dev, "Unknown calibration type!\n");
+		return;
+	}
+	pre_cal += (base + dev->cur_prek_offset);
+
+	memcpy(pre_cal, data->cal_data, len);
+	dev->cur_prek_offset += len;
+}
+
+void mt7996_tm_rf_test_event(struct mt7996_dev *dev, struct sk_buff *skb)
+{
+	struct mt7996_tm_event *event;
+	struct mt7996_tm_rf_test_result *result;
+	struct mt7996_tm_rf_test_data *data;
+	static u32 event_type;
+
+	skb_pull(skb, sizeof(struct mt7996_mcu_rxd));
+	event = (struct mt7996_tm_event *)skb->data;
+	result = (struct mt7996_tm_rf_test_result *)&event->result;
+	data = (struct mt7996_tm_rf_test_data *)result->data;
+
+	event_type = le32_to_cpu(result->func_idx);
+
+	switch (event_type) {
+	case RF_TEST_RE_CAL:
+		mt7996_tm_re_cal_event(dev, result, data);
+		break;
+	default:
+		break;
+	}
+}
+
+static u8
+mt7996_tm_get_center_chan(struct mt7996_phy *phy, struct cfg80211_chan_def *chandef)
+{
+	struct mt76_phy *mphy = phy->mt76;
+	const struct ieee80211_channel *chan = mphy->sband_5g.sband.channels;
+	u32 bitmap, i, offset, width_mhz, size = mphy->sband_5g.sband.n_channels;
+	u16 first_control = 0, control_chan = chandef->chan->hw_value;
+	bool not_first;
+
+	bitmap = mt7996_tm_bw_mapping(chandef->width, BW_MAP_NL_TO_CONTROL_BITMAP_5G);
+	if (!bitmap)
+		return control_chan;
+
+	width_mhz = mt7996_tm_bw_mapping(chandef->width, BW_MAP_NL_TO_MHZ);
+	offset = width_mhz / 10 - 2;
+
+	for (i = 0; i < size; i++) {
+		not_first = (chandef->width != NL80211_CHAN_WIDTH_160) ?
+			    (i % bitmap) : (i >= 32) || !((1 << i) & bitmap);
+		if (not_first)
+			continue;
+
+		if (control_chan >= chan[i].hw_value)
+			first_control = chan[i].hw_value;
+		else
+			break;
+	}
+
+	if (first_control == 0)
+		return control_chan;
+
+	return first_control + offset;
+}
+
+static int
+mt7996_tm_set_offchan(struct mt7996_phy *phy, bool no_center)
+{
+	struct mt76_phy *mphy = phy->mt76;
+	struct mt7996_dev *dev = phy->dev;
+	struct ieee80211_hw *hw = mphy->hw;
+	struct mt76_testmode_data *td = &phy->mt76->test;
+	struct cfg80211_chan_def chandef = {};
+	struct ieee80211_channel *chan;
+	int ret, freq = ieee80211_channel_to_frequency(td->offchan_ch, NL80211_BAND_5GHZ);
+
+	if (!mphy->cap.has_5ghz || !freq) {
+		ret = -EINVAL;
+		dev_info(dev->mt76.dev, "Failed to set offchan (invalid band or channel)!\n");
+		goto out;
+	}
+
+	chandef.width = td->offchan_bw;
+	chan = ieee80211_get_channel(hw->wiphy, freq);
+	chandef.chan = chan;
+	if (no_center)
+		td->offchan_center_ch = mt7996_tm_get_center_chan(phy, &chandef);
+	chandef.center_freq1 = ieee80211_channel_to_frequency(td->offchan_center_ch,
+							      NL80211_BAND_5GHZ);
+	if (!cfg80211_chandef_valid(&chandef)) {
+		ret = -EINVAL;
+		dev_info(dev->mt76.dev, "Failed to set offchan, chandef is invalid!\n");
+		goto out;
+	}
+
+	memset(&dev->rdd2_chandef, 0, sizeof(struct cfg80211_chan_def));
+
+	ret = mt7996_mcu_rdd_background_enable(phy, &chandef);
+
+	if (ret)
+		goto out;
+
+	dev->rdd2_phy = phy;
+	dev->rdd2_chandef = chandef;
+
+	return 0;
+
+out:
+	td->offchan_ch = 0;
+	td->offchan_center_ch = 0;
+	td->offchan_bw = 0;
+
+	return ret;
+}
+
+static void
+mt7996_tm_ipi_hist_ctrl(struct mt7996_phy *phy, struct mt7996_tm_rdd_ipi_ctrl *data, u8 cmd)
+{
+#define MT_IPI_RESET		0x830a5dfc
+#define MT_IPI_RESET_MASK	BIT(28)
+#define MT_IPI_COUNTER_BASE	0x83041000
+#define MT_IPI_COUNTER(idx)	(MT_IPI_COUNTER_BASE + ((idx) * 4))
+	struct mt7996_dev *dev = phy->dev;
+	bool val;
+	int i;
+
+	if (cmd == RDD_SET_IPI_HIST_RESET) {
+		val = mt76_rr(dev, MT_IPI_RESET) & MT_IPI_RESET_MASK;
+		mt76_rmw_field(dev, MT_IPI_RESET, MT_IPI_RESET_MASK, !val);
+		return;
+	}
+
+	for (i = 0; i < POWER_INDICATE_HIST_MAX; i++)
+		data->ipi_hist_val[i] = mt76_rr(dev, MT_IPI_COUNTER(i));
+}
+
+static void
+mt7996_tm_ipi_work(struct work_struct *work)
+{
+#define PRECISION	100
+	struct mt7996_phy *phy = container_of(work, struct mt7996_phy, ipi_work.work);
+	struct mt7996_dev *dev = phy->dev;
+	struct mt76_testmode_data *td = &phy->mt76->test;
+	struct mt7996_tm_rdd_ipi_ctrl data;
+	u32 ipi_idx, ipi_free_count, ipi_percentage;
+	u32 ipi_hist_count_th = 0, ipi_hist_total_count = 0;
+	u32 self_idle_ratio, ipi_idle_ratio, channel_load;
+	u32 *ipi_hist_data;
+	const char *power_lower_bound, *power_upper_bound;
+	static const char * const ipi_idx_to_power_bound[] = {
+		[RDD_IPI_HIST_0] = "-92",
+		[RDD_IPI_HIST_1] = "-89",
+		[RDD_IPI_HIST_2] = "-86",
+		[RDD_IPI_HIST_3] = "-83",
+		[RDD_IPI_HIST_4] = "-80",
+		[RDD_IPI_HIST_5] = "-75",
+		[RDD_IPI_HIST_6] = "-70",
+		[RDD_IPI_HIST_7] = "-65",
+		[RDD_IPI_HIST_8] = "-60",
+		[RDD_IPI_HIST_9] = "-55",
+		[RDD_IPI_HIST_10] = "inf",
+	};
+
+	memset(&data, 0, sizeof(data));
+	mt7996_tm_ipi_hist_ctrl(phy, &data, RDD_IPI_HIST_ALL_CNT);
+
+	ipi_hist_data = data.ipi_hist_val;
+	for (ipi_idx = 0; ipi_idx < POWER_INDICATE_HIST_MAX; ipi_idx++) {
+		power_lower_bound = ipi_idx ? ipi_idx_to_power_bound[ipi_idx - 1] : "-inf";
+		power_upper_bound = ipi_idx_to_power_bound[ipi_idx];
+
+		dev_info(dev->mt76.dev, "IPI %d (power range: (%s, %s] dBm): ipi count = %d\n",
+			 ipi_idx, power_lower_bound, power_upper_bound, ipi_hist_data[ipi_idx]);
+
+		if (td->ipi_threshold <= ipi_idx && ipi_idx <= RDD_IPI_HIST_10)
+			ipi_hist_count_th += ipi_hist_data[ipi_idx];
+
+		ipi_hist_total_count += ipi_hist_data[ipi_idx];
+	}
+
+	ipi_free_count = ipi_hist_data[RDD_IPI_FREE_RUN_CNT];
+
+	dev_info(dev->mt76.dev, "IPI threshold %d: ipi_hist_count_th = %d, ipi_free_count = %d\n",
+		 td->ipi_threshold, ipi_hist_count_th, ipi_free_count);
+	dev_info(dev->mt76.dev, "TX assert time =  %d [ms]\n", data.tx_assert_time / 1000);
+
+	/* calculate channel load = (self idle ratio - idle ratio) / self idle ratio */
+	if (ipi_hist_count_th >= UINT_MAX / (100 * PRECISION))
+		ipi_percentage = 100 * PRECISION *
+				 (ipi_hist_count_th / (100 * PRECISION)) /
+				 (ipi_free_count / (100 * PRECISION));
+	else
+		ipi_percentage = PRECISION * 100 * ipi_hist_count_th / ipi_free_count;
+
+	ipi_idle_ratio = ((100 * PRECISION) - ipi_percentage) / PRECISION;
+
+	self_idle_ratio = PRECISION * 100 *
+			  (td->ipi_period - (data.tx_assert_time / 1000)) /
+			  td->ipi_period / PRECISION;
+
+	if (self_idle_ratio < ipi_idle_ratio)
+		channel_load = 0;
+	else
+		channel_load = self_idle_ratio - ipi_idle_ratio;
+
+	if (self_idle_ratio <= td->ipi_threshold) {
+		dev_info(dev->mt76.dev, "band[%d]: self idle ratio = %d%%, idle ratio = %d%%\n",
+			 phy->mt76->band_idx, self_idle_ratio, ipi_idle_ratio);
+		return;
+	}
+
+	channel_load = (100 * channel_load) / self_idle_ratio;
+	dev_info(dev->mt76.dev,
+		 "band[%d]: chan load = %d%%, self idle ratio = %d%%, idle ratio = %d%%\n",
+		 phy->mt76->band_idx, channel_load, self_idle_ratio, ipi_idle_ratio);
+}
+
+static int
+mt7996_tm_set_ipi(struct mt7996_phy *phy)
+{
+	struct mt76_testmode_data *td = &phy->mt76->test;
+
+	/* reset IPI CR */
+	mt7996_tm_ipi_hist_ctrl(phy, NULL, RDD_SET_IPI_HIST_RESET);
+
+	cancel_delayed_work(&phy->ipi_work);
+	ieee80211_queue_delayed_work(phy->mt76->hw, &phy->ipi_work,
+				     msecs_to_jiffies(td->ipi_period));
+
+	return 0;
+}
+
+static int
+mt7996_tm_set_trx_mac(struct mt7996_phy *phy, u8 type, bool en)
+{
+#define UNI_TM_TRX_CTRL 0
+	struct mt7996_dev *dev = phy->dev;
+	struct mt7996_tm_trx_req req = {
+		.param_num = 1,
+		.tag = cpu_to_le16(UNI_TM_TRX_CTRL),
+		.len = cpu_to_le16(sizeof(req) - 4),
+		.param_idx = cpu_to_le16(TM_TRX_PARAM_SET_TRX),
+		.band_idx = phy->mt76->band_idx,
+		.testmode_en = 1,
+		.action = TM_TRX_ACTION_SET,
+		.set_trx = {
+			.type = type,
+			.enable = en,
+			.band_idx = phy->mt76->band_idx,
+		}
+	};
+
+	return mt76_mcu_send_msg(&dev->mt76, MCU_WM_UNI_CMD(TESTMODE_TRX_PARAM),
+				 &req, sizeof(req), false);
+}
+
+static int
+mt7996_tm_txbf_init(struct mt7996_phy *phy, u16 *val)
+{
+#define EBF_BBP_RX_OFFSET	0x10280
+#define EBF_BBP_RX_ENABLE	(BIT(0) | BIT(15))
+	struct mt7996_dev *dev = phy->dev;
+	struct mt76_testmode_data *td = &phy->mt76->test;
+	bool enable = val[0];
+	void *phase_cal, *pfmu_data, *pfmu_tag;
+	u8 nss, band_idx = phy->mt76->band_idx;
+	enum nl80211_chan_width width = NL80211_CHAN_WIDTH_20;
+	u8 sub_addr = td->is_txbf_dut ? TXBF_DUT_MAC_SUBADDR : TXBF_GOLDEN_MAC_SUBADDR;
+	u8 peer_addr = td->is_txbf_dut ? TXBF_GOLDEN_MAC_SUBADDR : TXBF_DUT_MAC_SUBADDR;
+	u8 bss_addr = TXBF_DUT_MAC_SUBADDR;
+	u8 addr[ETH_ALEN] = {0x00, sub_addr, sub_addr, sub_addr, sub_addr, sub_addr};
+	u8 bssid[ETH_ALEN] = {0x00, bss_addr, bss_addr, bss_addr, bss_addr, bss_addr};
+	u8 peer_addrs[ETH_ALEN] = {0x00, peer_addr, peer_addr, peer_addr, peer_addr, peer_addr};
+	struct mt7996_vif *mvif = (struct mt7996_vif *)phy->monitor_vif->drv_priv;
+
+	if (!enable) {
+		td->bf_en = false;
+		return 0;
+	}
+
+	if (!dev->test.txbf_phase_cal) {
+		phase_cal = devm_kzalloc(dev->mt76.dev,
+					 sizeof(struct mt7996_txbf_phase) *
+					 MAX_PHASE_GROUP_NUM,
+					 GFP_KERNEL);
+		if (!phase_cal)
+			return -ENOMEM;
+
+		dev->test.txbf_phase_cal = phase_cal;
+	}
+
+	if (!dev->test.txbf_pfmu_data) {
+		/* allocate max size for 5x5 pfmu data */
+		pfmu_data = devm_kzalloc(dev->mt76.dev,
+					 MT7996_TXBF_PFMU_DATA_LEN_5X5,
+					 GFP_KERNEL);
+		if (!pfmu_data)
+			return -ENOMEM;
+
+		dev->test.txbf_pfmu_data = pfmu_data;
+	}
+
+	if (!dev->test.txbf_pfmu_tag) {
+		pfmu_tag = devm_kzalloc(dev->mt76.dev,
+					sizeof(struct mt7996_pfmu_tag), GFP_KERNEL);
+		if (!pfmu_tag)
+			return -ENOMEM;
+
+		dev->test.txbf_pfmu_tag = pfmu_tag;
+	}
+
+	td->bf_en = true;
+	dev->ibf = td->ibf;
+	memcpy(td->addr[0], peer_addrs, ETH_ALEN);
+	memcpy(td->addr[1], addr, ETH_ALEN);
+	memcpy(td->addr[2], bssid, ETH_ALEN);
+	memcpy(phy->monitor_vif->addr, addr, ETH_ALEN);
+	mt7996_tm_set_mac_addr(dev, td->addr[0], SET_ID(DA));
+	mt7996_tm_set_mac_addr(dev, td->addr[1], SET_ID(SA));
+	mt7996_tm_set_mac_addr(dev, td->addr[2], SET_ID(BSSID));
+
+	/* bss idx & omac idx should be set to band idx for ibf cal */
+	mvif->deflink.mt76.idx = band_idx;
+	dev->mt76.vif_mask |= BIT_ULL(mvif->deflink.mt76.idx);
+	mvif->deflink.mt76.omac_idx = band_idx;
+	phy->omac_mask |= BIT_ULL(mvif->deflink.mt76.omac_idx);
+
+	mt7996_mcu_add_dev_info(phy, &phy->monitor_vif->bss_conf, &mvif->deflink, true);
+	mt7996_mcu_add_bss_info(phy, &phy->monitor_vif->bss_conf, &mvif->deflink, &mvif->sta.deflink, true);
+
+	if (td->ibf) {
+		if (td->is_txbf_dut) {
+			/* Enable ITxBF Capability */
+			mt7996_mcu_set_txbf(dev, BF_HW_EN_UPDATE);
+			mt7996_tm_set_trx_mac(phy, TM_TRX_MAC_TX, true);
+
+			td->tx_ipg = 999;
+			td->tx_mpdu_len = 1024;
+			td->tx_antenna_mask = phy->mt76->chainmask >> dev->chainshift[band_idx];
+			nss = hweight8(td->tx_antenna_mask);
+			if (nss > 1 && nss <= 4)
+				td->tx_rate_idx = 15 + 8 * (nss - 2);
+			else
+				td->tx_rate_idx = 31;
+		} else {
+			td->tx_antenna_mask = 1;
+			td->tx_mpdu_len = 1024;
+			td->tx_rate_idx = 0;
+			mt76_set(dev, EBF_BBP_RX_OFFSET, EBF_BBP_RX_ENABLE);
+			dev_info(dev->mt76.dev, "Set BBP RX CR = %x\n",
+				 mt76_rr(dev, EBF_BBP_RX_OFFSET));
+		}
+
+		td->tx_rate_mode = MT76_TM_TX_MODE_HT;
+		td->tx_rate_sgi = 0;
+		/* 5T5R ibf */
+		if (nss == 5) {
+			td->tx_rate_mode = MT76_TM_TX_MODE_VHT;
+			td->tx_rate_idx = 7;
+			td->tx_rate_nss = 4;
+		}
+	} else {
+		if (td->is_txbf_dut) {
+			/* Enable ETxBF Capability */
+			mt7996_mcu_set_txbf(dev, BF_HW_EN_UPDATE);
+			td->tx_antenna_mask = phy->mt76->chainmask >> dev->chainshift[band_idx];
+			td->tx_spe_idx = 24 + phy->mt76->band_idx;
+			if (td->tx_rate_mode == MT76_TM_TX_MODE_VHT ||
+			    td->tx_rate_mode == MT76_TM_TX_MODE_HE_SU)
+				mt7996_tm_set(dev, SET_ID(NSS), td->tx_rate_nss);
+
+			mt7996_tm_set(dev, SET_ID(ENCODE_MODE), td->tx_rate_ldpc);
+			mt7996_tm_set(dev, SET_ID(TX_COUNT), td->tx_count);
+		} else {
+			/* Turn On BBP CR for RX */
+			mt76_set(dev, EBF_BBP_RX_OFFSET, EBF_BBP_RX_ENABLE);
+			dev_info(dev->mt76.dev, "Set BBP RX CR = %x\n",
+				 mt76_rr(dev, EBF_BBP_RX_OFFSET));
+
+			td->tx_antenna_mask = 1;
+		}
+		width = phy->mt76->chandef.width;
+
+		if (td->tx_rate_mode == MT76_TM_TX_MODE_EHT_MU)
+			td->tx_rate_mode = MT76_TM_TX_MODE_EHT_SU;
+	}
+	mt76_testmode_param_set(td, MT76_TM_ATTR_TX_ANTENNA);
+
+	mt7996_tm_set(dev, SET_ID(TX_MODE),
+		      mt7996_tm_rate_mapping(td->tx_rate_mode, RATE_MODE_TO_PHY));
+	mt7996_tm_set(dev, SET_ID(TX_RATE), td->tx_rate_idx);
+	mt7996_tm_set(dev, SET_ID(GI), td->tx_rate_sgi);
+	mt7996_tm_set(dev, SET_ID(CBW),
+		      mt7996_tm_bw_mapping(width, BW_MAP_NL_TO_FW));
+	mt7996_tm_set(dev, SET_ID(DBW),
+		      mt7996_tm_bw_mapping(width, BW_MAP_NL_TO_FW));
+	mt7996_tm_set_antenna(phy, SET_ID(TX_PATH));
+	mt7996_tm_set_antenna(phy, SET_ID(RX_PATH));
+	mt7996_tm_set(dev, SET_ID(IPG), td->tx_ipg);
+	mt7996_tm_set(dev, SET_ID(TX_LEN), td->tx_mpdu_len);
+	mt7996_tm_set(dev, SET_ID(TX_TIME), 0);
+	mt7996_tm_set(dev, SET_ID(COMMAND), RF_CMD(TX_COMMIT));
+
+	return 0;
+}
+
+static inline void
+mt7996_tm_txbf_phase_copy(struct mt7996_dev *dev, void *des, void *src, int group)
+{
+	int phase_size;
+
+	if (group && get_ibf_version(dev) == IBF_VER_1)
+		phase_size = sizeof(struct mt7996_txbf_phase_info_5g);
+	else if (get_ibf_version(dev) == IBF_VER_1)
+		phase_size = sizeof(struct mt7996_txbf_phase_info_2g);
+	else if (group)
+		phase_size = sizeof(struct mt7992_txbf_phase_info_5g);
+	else
+		phase_size = sizeof(struct mt7992_txbf_phase_info_2g);
+
+	memcpy(des, src, phase_size);
+}
+
+static int
+mt7996_tm_txbf_phase_comp(struct mt7996_phy *phy, u16 *val)
+{
+	struct mt7996_dev *dev = phy->dev;
+	struct mt7996_tm_bf_req req = {
+		.phase_comp = {
+			.tag = cpu_to_le16(BF_IBF_PHASE_COMP),
+			.len = cpu_to_le16(sizeof(req.phase_comp)),
+			.bw = val[0],
+			.jp_band = (val[2] == 1) ? 1 : 0,
+			.band_idx = phy->mt76->band_idx,
+			.read_from_e2p = val[3],
+			.disable = val[4],
+			.group = val[2],
+		}
+	};
+	struct mt7996_txbf_phase *phase = (struct mt7996_txbf_phase *)dev->test.txbf_phase_cal;
+	int group = val[2];
+
+	wait_event_timeout(dev->mt76.tx_wait, phase[group].status != 0, HZ);
+	mt7996_tm_txbf_phase_copy(dev, req.phase_comp.buf, phase[group].buf, group);
+
+	pr_info("ibf cal process: phase comp info\n");
+	print_hex_dump(KERN_INFO, "", DUMP_PREFIX_NONE, 16, 1,
+		       &req, sizeof(req), 0);
+
+	return mt76_mcu_send_msg(&dev->mt76, MCU_WM_UNI_CMD(BF), &req,
+				 sizeof(req), false);
+}
+
+static int
+mt7996_tm_txbf_profile_tag_write(struct mt7996_phy *phy, u8 pfmu_idx, struct mt7996_pfmu_tag *tag)
+{
+	struct mt7996_dev *dev = phy->dev;
+	struct mt7996_tm_bf_req req = {
+		.pfmu_tag = {
+			.tag = cpu_to_le16(BF_PFMU_TAG_WRITE),
+			.len = cpu_to_le16(sizeof(req.pfmu_tag)),
+			.pfmu_id = pfmu_idx,
+			.bfer = true,
+			.band_idx = phy->mt76->band_idx,
+		}
+	};
+
+	memcpy(req.pfmu_tag.buf, tag, sizeof(*tag));
+	wait_event_timeout(dev->mt76.tx_wait, tag->t1.pfmu_idx != 0, HZ);
+
+	return mt76_mcu_send_msg(&dev->mt76, MCU_WM_UNI_CMD(BF), &req,
+				 sizeof(req), false);
+}
+
+static int
+mt7996_tm_add_txbf_sta(struct mt7996_phy *phy, u8 pfmu_idx, u8 nr, u8 nc, bool ebf)
+{
+	struct mt7996_dev *dev = phy->dev;
+	struct mt76_testmode_data *td = &phy->mt76->test;
+	struct {
+		struct sta_req_hdr hdr;
+		struct sta_rec_bf bf;
+	} __packed req = {
+		.hdr = {
+			.bss_idx = phy->mt76->band_idx,
+			.wlan_idx_lo = to_wcid_lo(phy->mt76->band_idx + 1),
+			.tlv_num = 1,
+			.is_tlv_append = 1,
+			.muar_idx = 0,
+			.wlan_idx_hi = to_wcid_hi(phy->mt76->band_idx + 1),
+		},
+		.bf = {
+			.tag = cpu_to_le16(STA_REC_BF),
+			.len = cpu_to_le16(sizeof(req.bf)),
+			.pfmu = cpu_to_le16(pfmu_idx),
+			.sounding_phy = 1,
+			.bf_cap = ebf,
+			.ncol = nc,
+			.nrow = nr,
+			.ibf_timeout = 0xff,
+			.tx_mode = mt7996_tm_rate_mapping(td->tx_rate_mode, RATE_MODE_TO_PHY),
+		},
+	};
+	u8 ndp_rate, ndpa_rate, rept_poll_rate, bf_bw;
+
+	if ((td->tx_rate_mode == MT76_TM_TX_MODE_HE_SU ||
+	     td->tx_rate_mode == MT76_TM_TX_MODE_EHT_SU) && !td->ibf) {
+		rept_poll_rate = 0x49;
+		ndpa_rate = 0x49;
+		ndp_rate = 0;
+	} else if (td->tx_rate_mode == MT76_TM_TX_MODE_VHT && !td->ibf) {
+		rept_poll_rate = 0x9;
+		ndpa_rate = 0x9;
+		ndp_rate = 0;
+	} else {
+		rept_poll_rate = 0;
+		ndpa_rate = 0;
+		if (nr == 1)
+			ndp_rate = 8;
+		else if (nr == 2)
+			ndp_rate = 16;
+		else if (nr == 4)
+			ndp_rate = 32;
+		else
+			ndp_rate = 24;
+
+		/* 5T5R ebf profile for ibf cal */
+		if (nr == 4 && td->ibf && ebf) {
+			ndp_rate = 0;
+			ndpa_rate = 11;
+		}
+	}
+
+	bf_bw = mt7996_tm_bw_mapping(phy->mt76->chandef.width, BW_MAP_NL_TO_BF);
+	req.bf.ndp_rate = ndp_rate;
+	req.bf.ndpa_rate = ndpa_rate;
+	req.bf.rept_poll_rate = rept_poll_rate;
+	req.bf.bw = bf_bw;
+	req.bf.tx_mode = (td->tx_rate_mode == MT76_TM_TX_MODE_EHT_SU) ? 0xf : req.bf.tx_mode;
+
+	if (ebf) {
+		req.bf.mem[0].row = 0;
+		req.bf.mem[1].row = 1;
+		req.bf.mem[2].row = 2;
+		req.bf.mem[3].row = 3;
+	} else {
+		req.bf.mem[0].row = 4;
+		req.bf.mem[1].row = 5;
+		req.bf.mem[2].row = 6;
+		req.bf.mem[3].row = 7;
+	}
+
+	return mt76_mcu_send_msg(&dev->mt76, MCU_WMWA_UNI_CMD(STA_REC_UPDATE), &req,
+				 sizeof(req), true);
+}
+
+static int
+mt7996_tm_txbf_profile_update(struct mt7996_phy *phy, u16 *val, bool ebf)
+{
+#define MT_ARB_IBF_ENABLE			(BIT(0) | GENMASK(9, 8))
+	struct mt76_testmode_data *td = &phy->mt76->test;
+	struct mt7996_dev *dev = phy->dev;
+	struct mt7996_pfmu_tag *tag = dev->test.txbf_pfmu_tag;
+	u8 rate, pfmu_idx = val[0], nc = val[2], nr;
+	int ret;
+	bool is_atenl = val[5];
+
+	if (td->tx_antenna_mask == 3)
+		nr = 1;
+	else if (td->tx_antenna_mask == 7)
+		nr = 2;
+	else if (td->tx_antenna_mask == 31)
+		nr = 4;
+	else
+		nr = 3;
+
+	memset(tag, 0, sizeof(*tag));
+	tag->t1.pfmu_idx = pfmu_idx;
+	tag->t1.ebf = ebf;
+	tag->t1.nr = nr;
+	tag->t1.nc = nc;
+	tag->t1.invalid_prof = true;
+	tag->t1.data_bw = mt7996_tm_bw_mapping(phy->mt76->chandef.width, BW_MAP_NL_TO_BF);
+	tag->t2.se_idx = td->tx_spe_idx;
+
+	if (ebf) {
+		tag->t1.row_id1 = 0;
+		tag->t1.row_id2 = 1;
+		tag->t1.row_id3 = 2;
+		tag->t1.row_id4 = 3;
+		tag->t1.lm = mt7996_tm_rate_mapping(td->tx_rate_mode, RATE_MODE_TO_LM);
+	} else {
+		tag->t1.row_id1 = 4;
+		tag->t1.row_id2 = 5;
+		tag->t1.row_id3 = 6;
+		tag->t1.row_id4 = 7;
+		rate = nr == 4 ? td->tx_rate_mode : MT76_TM_TX_MODE_OFDM;
+		tag->t1.lm = mt7996_tm_rate_mapping(rate, RATE_MODE_TO_LM);
+
+		tag->t2.ibf_timeout = 0xff;
+		tag->t2.ibf_nr = nr;
+		tag->t2.ibf_nc = nc;
+	}
+
+	ret = mt7996_tm_txbf_profile_tag_write(phy, pfmu_idx, tag);
+	if (ret)
+		return ret;
+
+	ret = mt7996_tm_add_txbf_sta(phy, pfmu_idx, nr, nc, ebf);
+	if (ret)
+		return ret;
+
+	if (!is_atenl && !td->ibf) {
+		mt76_set(dev, MT_ARB_TQSAXM0(phy->mt76->band_idx), MT_ARB_TQSAXM_ALTX_START_MASK);
+		dev_info(dev->mt76.dev, "Set TX queue start CR for AX management (0x%x) = 0x%x\n",
+			 MT_ARB_TQSAXM0(phy->mt76->band_idx),
+			 mt76_rr(dev, MT_ARB_TQSAXM0(phy->mt76->band_idx)));
+	} else if (!is_atenl && td->ibf && ebf) {
+		/* iBF's ebf profile update */
+		mt76_set(dev, MT_ARB_TQSAXM0(phy->mt76->band_idx), MT_ARB_IBF_ENABLE);
+		dev_info(dev->mt76.dev, "Set TX queue start CR for AX management (0x%x) = 0x%x\n",
+			 MT_ARB_TQSAXM0(phy->mt76->band_idx),
+			 mt76_rr(dev, MT_ARB_TQSAXM0(phy->mt76->band_idx)));
+	}
+
+	if (!ebf && is_atenl)
+		return mt7996_tm_txbf_apply_tx(phy, 1, false, true, true);
+
+	return 0;
+}
+
+static int
+mt7996_tm_txbf_phase_cal(struct mt7996_phy *phy, u16 *val)
+{
+	struct mt7996_dev *dev = phy->dev;
+	struct mt7996_tm_bf_req req = {
+		.phase_cal = {
+			.tag = cpu_to_le16(BF_PHASE_CALIBRATION),
+			.len = cpu_to_le16(sizeof(req.phase_cal)),
+			.group = val[0],
+			.group_l_m_n = val[1],
+			.sx2 = val[2],
+			.cal_type = val[3],
+			.lna_gain_level = val[4],
+			.band_idx = phy->mt76->band_idx,
+			.version = val[5],
+		},
+	};
+	struct mt7996_txbf_phase *phase = (struct mt7996_txbf_phase *)dev->test.txbf_phase_cal;
+
+	/* reset phase status before update phase cal data */
+	phase[req.phase_cal.group].status = 0;
+
+	return mt76_mcu_send_msg(&dev->mt76, MCU_WM_UNI_CMD(BF), &req,
+				 sizeof(req), false);
+}
+
+static int
+mt7996_tm_txbf_profile_update_all(struct mt7996_phy *phy, u16 *val)
+{
+	struct mt7996_dev *dev = phy->dev;
+	u8 nss = hweight16(phy->mt76->chainmask);
+	u16 pfmu_idx = val[0];
+	u16 subc_id = val[1];
+	u16 angle11 = val[2];
+	u16 angle21 = val[3];
+	u16 angle31 = val[4];
+	u16 angle41 = val[5];
+	u16 angle51 = val[6];
+	s16 phi11 = 0, phi21 = 0, phi31 = 0, phi41 = 0;
+	s16 *pfmu_data;
+	int offs = subc_id * sizeof(struct mt7996_pfmu_data) / sizeof(*pfmu_data);
+
+	if (subc_id > MT7996_TXBF_SUBCAR_NUM - 1)
+		return -EINVAL;
+
+	if (nss == 2) {
+		phi11 = (s16)(angle21 - angle11);
+	} else if (nss == 3) {
+		phi11 = (s16)(angle31 - angle11);
+		phi21 = (s16)(angle31 - angle21);
+	} else if (nss == 5) {
+		phi11 = (s16)(angle51 - angle11);
+		phi21 = (s16)(angle51 - angle21);
+		phi31 = (s16)(angle51 - angle31);
+		phi41 = (s16)(angle51 - angle41);
+		offs = subc_id * sizeof(struct mt7996_pfmu_data_5x5) / sizeof(*pfmu_data);
+	} else {
+		phi11 = (s16)(angle41 - angle11);
+		phi21 = (s16)(angle41 - angle21);
+		phi31 = (s16)(angle41 - angle31);
+	}
+
+	pfmu_data = (s16 *)dev->test.txbf_pfmu_data;
+	pfmu_data += offs;
+
+	if (subc_id < 32)
+		pfmu_data[0] = cpu_to_le16(subc_id + 224);
+	else
+		pfmu_data[0] = cpu_to_le16(subc_id - 32);
+
+	pfmu_data[1] = cpu_to_le16(phi11);
+	pfmu_data[2] = cpu_to_le16(phi21);
+	pfmu_data[3] = cpu_to_le16(phi31);
+	if (nss == 5)
+		pfmu_data[4] = cpu_to_le16(phi41);
+
+	if (subc_id == MT7996_TXBF_SUBCAR_NUM - 1) {
+		struct mt7996_tm_bf_req req = {
+			.pfmu_data_all = {
+				.tag = cpu_to_le16(BF_PROFILE_WRITE_20M_ALL_5X5),
+				.len = cpu_to_le16(sizeof(req.pfmu_data_all)),
+				.pfmu_id = pfmu_idx,
+				.band_idx = phy->mt76->band_idx,
+			},
+		};
+		int size = MT7996_TXBF_PFMU_DATA_LEN_5X5;
+
+		if (nss != 5) {
+			size = MT7996_TXBF_PFMU_DATA_LEN;
+			req.pfmu_data_all.tag = cpu_to_le16(BF_PROFILE_WRITE_20M_ALL);
+			req.pfmu_data_all.len = cpu_to_le16(sizeof(req.pfmu_data_all) -
+							    MT7996_TXBF_PFMU_DATA_LEN_5X5 + size);
+		}
+		memcpy(req.pfmu_data_all.buf, dev->test.txbf_pfmu_data, size);
+
+		return mt76_mcu_send_msg(&dev->mt76, MCU_WM_UNI_CMD(BF),
+					 &req, sizeof(req), true);
+	}
+
+	return 0;
+}
+
+static int
+mt7996_tm_txbf_e2p_update(struct mt7996_phy *phy)
+{
+#define TXBF_PHASE_EEPROM_START_OFFSET		0xc00
+#define TXBF_PHASE_GROUP_EEPROM_OFFSET_VER_1	46
+#define TXBF_PHASE_G0_EEPROM_OFFSET_VER_2	29
+#define TXBF_PHASE_GX_EEPROM_OFFSET_VER_2	sizeof(struct mt7992_txbf_phase_info_5g)
+	struct mt7996_txbf_phase *phase, *p;
+	struct mt7996_dev *dev = phy->dev;
+	u8 *eeprom = dev->mt76.eeprom.data;
+	u16 offset;
+	int i;
+
+	offset = TXBF_PHASE_EEPROM_START_OFFSET;
+	phase = (struct mt7996_txbf_phase *)dev->test.txbf_phase_cal;
+	for (i = 0; i < MAX_PHASE_GROUP_NUM; i++) {
+		p = &phase[i];
+
+		if (!p->status)
+			continue;
+
+		/* copy phase cal data to eeprom */
+		mt7996_tm_txbf_phase_copy(dev, eeprom + offset, p->buf, i);
+		if (get_ibf_version(dev) == IBF_VER_1)
+			offset += TXBF_PHASE_GROUP_EEPROM_OFFSET_VER_1;
+		else
+			offset += i ? TXBF_PHASE_GX_EEPROM_OFFSET_VER_2 :
+				      TXBF_PHASE_G0_EEPROM_OFFSET_VER_2;
+	}
+
+	return 0;
+}
+
+static int
+mt7996_tm_txbf_apply_tx(struct mt7996_phy *phy, u16 wlan_idx, bool ebf,
+			bool ibf, bool phase_cal)
+{
+	struct mt7996_dev *dev = phy->dev;
+	struct mt7996_tm_bf_req req = {
+		.tx_apply = {
+			.tag = cpu_to_le16(BF_DATA_PACKET_APPLY),
+			.len = cpu_to_le16(sizeof(req.tx_apply)),
+			.wlan_idx = cpu_to_le16(wlan_idx),
+			.ebf = ebf,
+			.ibf = ibf,
+			.phase_cal = phase_cal,
+		},
+	};
+
+	return mt76_mcu_send_msg(&dev->mt76, MCU_WM_UNI_CMD(BF), &req, sizeof(req), false);
+}
+
+static int
+mt7996_tm_txbf_set_tx(struct mt7996_phy *phy, u16 *val)
+{
+	bool bf_on = val[0], update = val[3];
+	struct mt7996_dev *dev = phy->dev;
+	struct mt7996_pfmu_tag *tag = dev->test.txbf_pfmu_tag;
+	struct mt76_testmode_data *td = &phy->mt76->test;
+
+	if (bf_on) {
+		mt7996_tm_set_rx_frames(phy, false);
+		mt7996_tm_set_tx_frames(phy, false);
+		mt7996_mcu_set_txbf_internal(phy, BF_PFMU_TAG_READ, 2, true);
+		tag->t1.invalid_prof = false;
+		mt7996_tm_txbf_profile_tag_write(phy, 2, tag);
+		td->bf_ever_en = true;
+
+		if (update)
+			mt7996_tm_txbf_apply_tx(phy, 1, 0, 1, 1);
+	} else {
+		if (!td->bf_ever_en) {
+			mt7996_tm_set_rx_frames(phy, false);
+			mt7996_tm_set_tx_frames(phy, false);
+
+			if (update)
+				mt7996_tm_txbf_apply_tx(phy, 1, 0, 0, 0);
+		} else {
+			td->bf_ever_en = false;
+
+			mt7996_mcu_set_txbf_internal(phy, BF_PFMU_TAG_READ, 2, true);
+			tag->t1.invalid_prof = true;
+			mt7996_tm_txbf_profile_tag_write(phy, 2, tag);
+		}
+	}
+
+	return 0;
+}
+
+static int
+mt7996_tm_trigger_sounding(struct mt7996_phy *phy, u16 *val, bool en)
+{
+	struct mt7996_dev *dev = phy->dev;
+	u8 sounding_mode = val[0];
+	u8 sta_num = val[1];
+	u32 sounding_interval = (u32)val[2] << 2;	/* input unit: 4ms */
+	u16 tag = en ? BF_SOUNDING_ON : BF_SOUNDING_OFF;
+	struct mt7996_tm_bf_req req = {
+		.sounding = {
+			.tag = cpu_to_le16(tag),
+			.len = cpu_to_le16(sizeof(req.sounding)),
+			.snd_mode = sounding_mode,
+			.sta_num = sta_num,
+			.wlan_id = {
+				cpu_to_le16(val[3]),
+				cpu_to_le16(val[4]),
+				cpu_to_le16(val[5]),
+				cpu_to_le16(val[6])
+			},
+			.snd_period = cpu_to_le32(sounding_interval),
+		},
+	};
+
+	if (sounding_mode > SOUNDING_MODE_MAX)
+		return -EINVAL;
+
+	return mt76_mcu_send_msg(&dev->mt76, MCU_WM_UNI_CMD(BF),
+				 &req, sizeof(req), false);
+}
+
+static int
+mt7996_tm_txbf_txcmd(struct mt7996_phy *phy, u16 *val)
+{
+	struct mt7996_dev *dev = phy->dev;
+	struct mt7996_tm_bf_req req = {
+		.txcmd = {
+			.tag = cpu_to_le16(BF_CMD_TXCMD),
+			.len = cpu_to_le16(sizeof(req.txcmd)),
+			.action = val[0],
+			.bf_manual = val[1],
+			.bf_bit = val[2],
+		},
+	};
+
+	return mt76_mcu_send_msg(&dev->mt76, MCU_WM_UNI_CMD(BF), &req, sizeof(req), false);
+}
+
+static int
+mt7996_tm_set_txbf(struct mt7996_phy *phy)
+{
+#define TXBF_IS_DUT_MASK	BIT(0)
+#define TXBF_IBF_MASK		BIT(1)
+	struct mt76_testmode_data *td = &phy->mt76->test;
+	u16 *val = td->txbf_param;
+
+	dev_info(phy->dev->mt76.dev,
+		 "ibf cal process: act = %u, val = %u, %u, %u, %u, %u, %u, %u, %u\n",
+		 td->txbf_act, val[0], val[1], val[2], val[3], val[4], val[5], val[6], val[7]);
+
+	switch (td->txbf_act) {
+	case MT76_TM_TXBF_ACT_GOLDEN_INIT:
+	case MT76_TM_TXBF_ACT_INIT:
+	case MT76_TM_TX_EBF_ACT_GOLDEN_INIT:
+	case MT76_TM_TX_EBF_ACT_INIT:
+		td->ibf = !u32_get_bits(td->txbf_act, TXBF_IBF_MASK);
+		td->ebf = true;
+		td->is_txbf_dut = !!u32_get_bits(td->txbf_act, TXBF_IS_DUT_MASK);
+		return mt7996_tm_txbf_init(phy, val);
+	case MT76_TM_TXBF_ACT_UPDATE_CH:
+		mt7996_tm_update_channel(phy);
+		break;
+	case MT76_TM_TXBF_ACT_PHASE_COMP:
+		return mt7996_tm_txbf_phase_comp(phy, val);
+	case MT76_TM_TXBF_ACT_TX_PREP:
+		return mt7996_tm_txbf_set_tx(phy, val);
+	case MT76_TM_TXBF_ACT_IBF_PROF_UPDATE:
+		return mt7996_tm_txbf_profile_update(phy, val, false);
+	case MT76_TM_TXBF_ACT_EBF_PROF_UPDATE:
+		return mt7996_tm_txbf_profile_update(phy, val, true);
+	case MT76_TM_TXBF_ACT_PHASE_CAL:
+		return mt7996_tm_txbf_phase_cal(phy, val);
+	case MT76_TM_TXBF_ACT_PROF_UPDATE_ALL_CMD:
+	case MT76_TM_TXBF_ACT_PROF_UPDATE_ALL:
+		return mt7996_tm_txbf_profile_update_all(phy, val);
+	case MT76_TM_TXBF_ACT_E2P_UPDATE:
+		return mt7996_tm_txbf_e2p_update(phy);
+	case MT76_TM_TXBF_ACT_APPLY_TX: {
+		u16 wlan_idx = val[0];
+		bool ebf = !!val[1], ibf = !!val[2], phase_cal = !!val[4];
+
+		return mt7996_tm_txbf_apply_tx(phy, wlan_idx, ebf, ibf, phase_cal);
+	}
+	case MT76_TM_TXBF_ACT_TRIGGER_SOUNDING:
+		return mt7996_tm_trigger_sounding(phy, val, true);
+	case MT76_TM_TXBF_ACT_STOP_SOUNDING:
+		memset(val, 0, sizeof(td->txbf_param));
+		return mt7996_tm_trigger_sounding(phy, val, false);
+	case MT76_TM_TXBF_ACT_PROFILE_TAG_READ:
+	case MT76_TM_TXBF_ACT_PROFILE_TAG_WRITE:
+	case MT76_TM_TXBF_ACT_PROFILE_TAG_INVALID: {
+		u8 pfmu_idx = val[0];
+		bool bfer = !!val[1];
+		struct mt7996_dev *dev = phy->dev;
+		struct mt7996_pfmu_tag *tag = dev->test.txbf_pfmu_tag;
+
+		if (!tag) {
+			dev_err(dev->mt76.dev,
+				"pfmu tag is not initialized!\n");
+			return 0;
+		}
+
+		if (td->txbf_act == MT76_TM_TXBF_ACT_PROFILE_TAG_WRITE)
+			return mt7996_tm_txbf_profile_tag_write(phy, pfmu_idx, tag);
+		else if (td->txbf_act == MT76_TM_TXBF_ACT_PROFILE_TAG_READ)
+			return mt7996_mcu_set_txbf_internal(phy, BF_PFMU_TAG_READ, pfmu_idx, bfer);
+
+		tag->t1.invalid_prof = !!val[0];
+
+		return 0;
+	}
+	case MT76_TM_TXBF_ACT_STA_REC_READ:
+		return mt7996_mcu_set_txbf_internal(phy, BF_STA_REC_READ, val[0], 0);
+	case MT76_TM_TXBF_ACT_TXCMD:
+		return mt7996_tm_txbf_txcmd(phy, val);
+	default:
+		break;
+	};
+
+	return 0;
+}
+
+static void
+mt7996_tm_update_params(struct mt7996_phy *phy, u32 changed)
+{
+	struct mt76_testmode_data *td = &phy->mt76->test;
+	struct mt7996_dev *dev = phy->dev;
+
+	if (changed & BIT(TM_CHANGED_FREQ_OFFSET)) {
+		mt7996_tm_set(dev, SET_ID(FREQ_OFFSET), td->freq_offset);
+		mt7996_tm_set(dev, SET_ID(FREQ_OFFSET_C2), td->freq_offset);
+	}
+	if (changed & BIT(TM_CHANGED_TXPOWER))
+		mt7996_tm_set(dev, SET_ID(POWER), td->tx_power[0]);
+	if (changed & BIT(TM_CHANGED_SKU_EN)) {
+		mt7996_tm_update_channel(phy);
+		mt7996_mcu_set_tx_power_ctrl(phy, POWER_CTRL(SKU_POWER_LIMIT), td->sku_en);
+		mt7996_mcu_set_tx_power_ctrl(phy, POWER_CTRL(BACKOFF_POWER_LIMIT), td->sku_en);
+		mt7996_mcu_set_txpower_sku(phy, &phy->monitor_vif->bss_conf);
+	}
+	if (changed & BIT(TM_CHANGED_TX_LENGTH)) {
+		mt7996_tm_set(dev, SET_ID(TX_LEN), td->tx_mpdu_len);
+		mt7996_tm_set(dev, SET_ID(TX_TIME), 0);
+	}
+	if (changed & BIT(TM_CHANGED_TX_TIME)) {
+		mt7996_tm_set(dev, SET_ID(TX_LEN), 0);
+		mt7996_tm_set(dev, SET_ID(TX_TIME), td->tx_time);
+	}
+	if (changed & BIT(TM_CHANGED_CFG)) {
+		u32 func_idx = td->cfg.enable ? SET_ID(CFG_ON) : SET_ID(CFG_OFF);
+
+		mt7996_tm_set(dev, func_idx, td->cfg.type);
+	}
+	if ((changed & BIT(TM_CHANGED_OFF_CHAN_CH)) &&
+	    (changed & BIT(TM_CHANGED_OFF_CHAN_BW)))
+		mt7996_tm_set_offchan(phy, !(changed & BIT(TM_CHANGED_OFF_CHAN_CENTER_CH)));
+	if ((changed & BIT(TM_CHANGED_IPI_THRESHOLD)) &&
+	    (changed & BIT(TM_CHANGED_IPI_PERIOD)))
+		mt7996_tm_set_ipi(phy);
+	if (changed & BIT(TM_CHANGED_IPI_RESET))
+		mt7996_tm_ipi_hist_ctrl(phy, NULL, RDD_SET_IPI_HIST_RESET);
+	if (changed & BIT(TM_CHANGED_TXBF_ACT))
+		mt7996_tm_set_txbf(phy);
+	if (changed & BIT(TM_CHANGED_TX_ANTENNA)) {
+		mt7996_tm_set_antenna(phy, SET_ID(TX_PATH));
+		mt7996_tm_set_antenna(phy, SET_ID(RX_PATH));
+	}
+	if (changed & BIT(TM_CHANGED_TX_RATE_NSS))
+		mt7996_tm_set(dev, SET_ID(NSS), td->tx_rate_nss);
+	if (changed & BIT(TM_CHANGED_TX_RATE_IDX))
+		mt7996_tm_set(dev, SET_ID(TX_RATE), td->tx_rate_idx);
+}
+
+static int
+mt7996_tm_set_state(struct mt76_phy *mphy, enum mt76_testmode_state state)
+{
+	struct mt76_testmode_data *td = &mphy->test;
+	struct mt7996_phy *phy = mphy->priv;
+	struct mt7996_dev *dev = phy->dev;
+	enum mt76_testmode_state prev_state = td->state;
+
+	if (!dev->testmode_enable)
+		return -EPERM;
+
+	mphy->test.state = state;
+
+	if (prev_state != MT76_TM_STATE_OFF)
+		mt7996_tm_set(dev, SET_ID(BAND_IDX), mphy->band_idx);
+
+	if (prev_state == MT76_TM_STATE_TX_FRAMES ||
+	    state == MT76_TM_STATE_TX_FRAMES)
+		mt7996_tm_set_tx_frames(phy, state == MT76_TM_STATE_TX_FRAMES);
+	else if (prev_state == MT76_TM_STATE_RX_FRAMES ||
+		 state == MT76_TM_STATE_RX_FRAMES)
+		mt7996_tm_set_rx_frames(phy, state == MT76_TM_STATE_RX_FRAMES);
+	else if (prev_state == MT76_TM_STATE_TX_CONT ||
+		 state == MT76_TM_STATE_TX_CONT)
+		mt7996_tm_set_tx_cont(phy, state == MT76_TM_STATE_TX_CONT);
+	else if (prev_state == MT76_TM_STATE_OFF ||
+		 state == MT76_TM_STATE_OFF)
+		mt7996_tm_init(phy, !(state == MT76_TM_STATE_OFF));
+	else if (state >= MT76_TM_STATE_GROUP_PREK && state <= MT76_TM_STATE_GROUP_PREK_CLEAN)
+		return mt7996_tm_group_prek(phy, state);
+	else if (state >= MT76_TM_STATE_DPD_2G && state <= MT76_TM_STATE_DPD_CLEAN)
+		return mt7996_tm_dpd_prek(phy, state);
+
+	if ((state == MT76_TM_STATE_IDLE &&
+	     prev_state == MT76_TM_STATE_OFF) ||
+	    (state == MT76_TM_STATE_OFF &&
+	     prev_state == MT76_TM_STATE_IDLE)) {
+		u32 changed = 0;
+		int i, ret;
+
+		for (i = 0; i < ARRAY_SIZE(tm_change_map); i++) {
+			u16 cur = tm_change_map[i];
+
+			if (mt76_testmode_param_present(td, cur))
+				changed |= BIT(i);
+		}
+
+		ret = mt7996_tm_check_antenna(phy);
+		if (ret)
+			return ret;
+
+		mt7996_tm_update_params(phy, changed);
+	}
+
+	return 0;
+}
+
+static int
+mt7996_tm_set_params(struct mt76_phy *mphy, struct nlattr **tb,
+		     enum mt76_testmode_state new_state)
+{
+	struct mt76_testmode_data *td = &mphy->test;
+	struct mt7996_phy *phy = mphy->priv;
+	struct mt7996_dev *dev = phy->dev;
+	u32 changed = 0;
+	int i, ret;
+
+	BUILD_BUG_ON(NUM_TM_CHANGED >= 32);
+
+	if (new_state == MT76_TM_STATE_OFF ||
+	    td->state == MT76_TM_STATE_OFF)
+		return 0;
+
+	ret = mt7996_tm_check_antenna(phy);
+	if (ret)
+		return ret;
+
+	for (i = 0; i < ARRAY_SIZE(tm_change_map); i++) {
+		if (tb[tm_change_map[i]])
+			changed |= BIT(i);
+	}
+
+	mt7996_tm_set(dev, SET_ID(BAND_IDX), mphy->band_idx);
+	mt7996_tm_update_params(phy, changed);
+
+	return 0;
+}
+
+static int
+mt7996_tm_get_rx_stats(struct mt7996_phy *phy)
+{
+	struct mt7996_dev *dev = phy->dev;
+	struct mt7996_tm_rx_req req = {
+		.band = phy->mt76->band_idx,
+		.rx_stat_all = {
+			.tag = cpu_to_le16(UNI_TM_RX_STAT_GET_ALL_V2),
+			.len = cpu_to_le16(sizeof(req.rx_stat_all)),
+			.band_idx = phy->mt76->band_idx,
+		},
+	};
+	struct mt76_testmode_data *td = &phy->mt76->test;
+	struct mt7996_tm_rx_event *rx_stats;
+	struct mt7996_tm_rx_event_stat_all *rx_stats_all;
+	struct sk_buff *skb;
+	enum mt76_rxq_id qid;
+	int i, ret = 0;
+	u32 mac_rx_mdrdy_cnt;
+	u16 mac_rx_len_mismatch, fcs_err_count;
+
+	if (td->state != MT76_TM_STATE_RX_FRAMES)
+		return 0;
+
+	ret = mt76_mcu_send_and_get_msg(&dev->mt76, MCU_WM_UNI_CMD_QUERY(TESTMODE_RX_STAT),
+					&req, sizeof(req), true, &skb);
+
+	if (ret)
+		return ret;
+
+	rx_stats = (struct mt7996_tm_rx_event *)skb->data;
+	rx_stats_all = &rx_stats->rx_stat_all;
+
+	phy->test.last_freq_offset = le32_to_cpu(rx_stats_all->user_info[0].freq_offset);
+	phy->test.last_snr = le32_to_cpu(rx_stats_all->user_info[0].snr);
+	for (i = 0; i < ARRAY_SIZE(phy->test.last_rcpi); i++) {
+		phy->test.last_rcpi[i] = le16_to_cpu(rx_stats_all->rxv_info[i].rcpi);
+		phy->test.last_rssi[i] = le16_to_cpu(rx_stats_all->rxv_info[i].rssi);
+		phy->test.last_ib_rssi[i] = rx_stats_all->fagc[i].ib_rssi;
+		phy->test.last_wb_rssi[i] = rx_stats_all->fagc[i].wb_rssi;
+	}
+
+	if (phy->mt76->band_idx == 2)
+		qid = MT_RXQ_BAND2;
+	else if (phy->mt76->band_idx == 1)
+		qid = MT_RXQ_BAND1;
+	else
+		qid = MT_RXQ_MAIN;
+
+	fcs_err_count = le16_to_cpu(rx_stats_all->band_info.mac_rx_fcs_err_cnt);
+	mac_rx_len_mismatch = le16_to_cpu(rx_stats_all->band_info.mac_rx_len_mismatch);
+	mac_rx_mdrdy_cnt = le32_to_cpu(rx_stats_all->band_info.mac_rx_mdrdy_cnt);
+	td->rx_stats.packets[qid] += mac_rx_mdrdy_cnt;
+	td->rx_stats.packets[qid] += fcs_err_count;
+	td->rx_stats.fcs_error[qid] += fcs_err_count;
+	td->rx_stats.len_mismatch += mac_rx_len_mismatch;
+
+	dev_kfree_skb(skb);
+
+	return ret;
+}
+
+static void
+mt7996_tm_reset_trx_stats(struct mt76_phy *mphy)
+{
+	struct mt7996_phy *phy = mphy->priv;
+	struct mt7996_dev *dev = phy->dev;
+
+	memset(&mphy->test.rx_stats, 0, sizeof(mphy->test.rx_stats));
+	mt7996_tm_set(dev, SET_ID(TRX_COUNTER_RESET), 0);
+}
+
+static int
+mt7996_tm_get_tx_stats(struct mt7996_phy *phy)
+{
+	struct mt7996_dev *dev = phy->dev;
+	struct mt76_testmode_data *td = &phy->mt76->test;
+	int ret;
+
+	if (td->state != MT76_TM_STATE_TX_FRAMES)
+		return 0;
+
+	ret = mt7996_tm_get(dev, GET_ID(TXED_COUNT), 0, &td->tx_done);
+	if (ret)
+		return ret;
+
+	td->tx_pending = td->tx_count - td->tx_done;
+
+	return ret;
+}
+
+static int
+mt7996_tm_dump_stats(struct mt76_phy *mphy, struct sk_buff *msg)
+{
+	struct mt7996_phy *phy = mphy->priv;
+	void *rx, *rssi;
+	int i;
+
+	mt7996_tm_set(phy->dev, SET_ID(BAND_IDX), mphy->band_idx);
+	mt7996_tm_get_rx_stats(phy);
+	mt7996_tm_get_tx_stats(phy);
+
+	rx = nla_nest_start(msg, MT76_TM_STATS_ATTR_LAST_RX);
+	if (!rx)
+		return -ENOMEM;
+
+	if (nla_put_s32(msg, MT76_TM_RX_ATTR_FREQ_OFFSET, phy->test.last_freq_offset))
+		return -ENOMEM;
+
+	rssi = nla_nest_start(msg, MT76_TM_RX_ATTR_RCPI);
+	if (!rssi)
+		return -ENOMEM;
+
+	for (i = 0; i < ARRAY_SIZE(phy->test.last_rcpi); i++)
+		if (nla_put_u8(msg, i, phy->test.last_rcpi[i]))
+			return -ENOMEM;
+
+	nla_nest_end(msg, rssi);
+
+	rssi = nla_nest_start(msg, MT76_TM_RX_ATTR_RSSI);
+	if (!rssi)
+		return -ENOMEM;
+
+	for (i = 0; i < ARRAY_SIZE(phy->test.last_rssi); i++)
+		if (nla_put_s8(msg, i, phy->test.last_rssi[i]))
+			return -ENOMEM;
+
+	nla_nest_end(msg, rssi);
+
+	rssi = nla_nest_start(msg, MT76_TM_RX_ATTR_IB_RSSI);
+	if (!rssi)
+		return -ENOMEM;
+
+	for (i = 0; i < ARRAY_SIZE(phy->test.last_ib_rssi); i++)
+		if (nla_put_s8(msg, i, phy->test.last_ib_rssi[i]))
+			return -ENOMEM;
+
+	nla_nest_end(msg, rssi);
+
+	rssi = nla_nest_start(msg, MT76_TM_RX_ATTR_WB_RSSI);
+	if (!rssi)
+		return -ENOMEM;
+
+	for (i = 0; i < ARRAY_SIZE(phy->test.last_wb_rssi); i++)
+		if (nla_put_s8(msg, i, phy->test.last_wb_rssi[i]))
+			return -ENOMEM;
+
+	nla_nest_end(msg, rssi);
+
+	if (nla_put_u8(msg, MT76_TM_RX_ATTR_SNR, phy->test.last_snr))
+		return -ENOMEM;
+
+	nla_nest_end(msg, rx);
+
+	return 0;
+}
+
+static int
+mt7996_tm_write_back_to_efuse(struct mt7996_dev *dev)
+{
+	struct mt7996_mcu_eeprom_info req = {
+		.tag = cpu_to_le16(UNI_EFUSE_ACCESS),
+		.len = cpu_to_le16(sizeof(req) - 4),
+	};
+	u8 read_buf[MT76_TM_EEPROM_BLOCK_SIZE], *eeprom = dev->mt76.eeprom.data;
+	int i, ret = -EINVAL;
+
+	/* prevent from damaging chip id in efuse */
+	if (mt76_chip(&dev->mt76) != get_unaligned_le16(eeprom))
+		goto out;
+
+	for (i = 0; i < MT7996_EEPROM_SIZE; i += MT76_TM_EEPROM_BLOCK_SIZE) {
+		req.addr = cpu_to_le32(i);
+		memcpy(req.data, eeprom + i, MT76_TM_EEPROM_BLOCK_SIZE);
+
+		ret = mt7996_mcu_get_eeprom(dev, i, read_buf, sizeof(read_buf));
+		if (ret) {
+			if (ret != -EINVAL)
+				return ret;
+
+			memset(read_buf, 0, MT76_TM_EEPROM_BLOCK_SIZE);
+		}
+
+		if (!memcmp(req.data, read_buf, MT76_TM_EEPROM_BLOCK_SIZE))
+			continue;
+
+		ret = mt76_mcu_send_msg(&dev->mt76, MCU_WM_UNI_CMD(EFUSE_CTRL),
+					&req, sizeof(req), true);
+		if (ret)
+			return ret;
+	}
+
+out:
+	return ret;
+}
+
+static int
+mt7996_tm_set_eeprom(struct mt76_phy *mphy, u32 offset, u8 *val, u8 action)
+{
+	struct mt7996_phy *phy = mphy->priv;
+	struct mt7996_dev *dev = phy->dev;
+	u8 *eeprom = dev->mt76.eeprom.data;
+	int ret = 0;
+
+	if (offset >= MT7996_EEPROM_SIZE)
+		return -EINVAL;
+
+	switch (action) {
+	case MT76_TM_EEPROM_ACTION_UPDATE_DATA:
+		memcpy(eeprom + offset, val, MT76_TM_EEPROM_BLOCK_SIZE);
+		break;
+	case MT76_TM_EEPROM_ACTION_UPDATE_BUFFER_MODE:
+		ret = mt7996_mcu_set_eeprom(dev);
+		break;
+	case MT76_TM_EEPROM_ACTION_WRITE_TO_EFUSE:
+		ret = mt7996_tm_write_back_to_efuse(dev);
+		break;
+	default:
+		break;
+	}
+
+	return ret;
+}
+
+const struct mt76_testmode_ops mt7996_testmode_ops = {
+	.set_state = mt7996_tm_set_state,
+	.set_params = mt7996_tm_set_params,
+	.dump_stats = mt7996_tm_dump_stats,
+	.reset_rx_stats = mt7996_tm_reset_trx_stats,
+	.tx_stop = mt7996_tm_tx_stop,
+	.set_eeprom = mt7996_tm_set_eeprom,
+	.dump_precal = mt7996_tm_dump_precal,
+};
diff --git a/mt7996/testmode.h b/mt7996/testmode.h
new file mode 100644
index 00000000..ba1767ae
--- /dev/null
+++ b/mt7996/testmode.h
@@ -0,0 +1,378 @@
+/* SPDX-License-Identifier: ISC */
+/* Copyright (C) 2020 MediaTek Inc. */
+
+#ifndef __MT7996_TESTMODE_H
+#define __MT7996_TESTMODE_H
+
+enum {
+	TM_CBW_20MHZ,
+	TM_CBW_40MHZ,
+	TM_CBW_80MHZ,
+	TM_CBW_10MHZ,
+	TM_CBW_5MHZ,
+	TM_CBW_160MHZ,
+	TM_CBW_8080MHZ,
+	TM_CBW_320MHZ = 12,
+};
+
+/* BW defined in FW hal_cal_flow_rom.h */
+enum {
+	FW_CDBW_20MHZ,
+	FW_CDBW_40MHZ,
+	FW_CDBW_80MHZ,
+	FW_CDBW_160MHZ,
+	FW_CDBW_320MHZ,
+	FW_CDBW_5MHZ,
+	FW_CDBW_10MHZ,
+	FW_CDBW_8080MHZ,
+};
+
+enum {
+	BF_CDBW_20MHZ,
+	BF_CDBW_40MHZ,
+	BF_CDBW_80MHZ,
+	BF_CDBW_160MHZ,
+	BF_CDBW_320MHZ,
+	BF_CDBW_10MHZ = BF_CDBW_320MHZ,
+	BF_CDBW_5MHZ,
+	BF_CDBW_8080MHZ,
+};
+
+#define FIRST_CONTROL_CHAN_BITMAP_BW40		2
+#define FIRST_CONTROL_CHAN_BITMAP_BW80		4
+#define FIRST_CONTROL_CHAN_BITMAP_BW160		0x10010101
+
+enum bw_mapping_method {
+	BW_MAP_NL_TO_FW,
+	BW_MAP_NL_TO_TM,
+	BW_MAP_NL_TO_BF,
+	BW_MAP_NL_TO_MHZ,
+	BW_MAP_NL_TO_CONTROL_BITMAP_5G,
+
+	NUM_BW_MAP,
+};
+
+enum rate_mapping_type {
+	RATE_MODE_TO_PHY,
+	RATE_MODE_TO_LM,
+
+	NUM_RATE_MAP,
+};
+
+struct tm_cal_param {
+	__le32 func_data;
+	u8 band_idx;
+	u8 rsv[3];
+};
+
+struct mt7996_tm_rf_test {
+	__le16 tag;
+	__le16 len;
+
+	u8 action;
+	u8 icap_len;
+	u8 _rsv[2];
+	union {
+		__le32 op_mode;
+		__le32 freq;
+
+		struct {
+			__le32 func_idx;
+			union {
+				__le32 func_data;
+				__le32 cal_dump;
+				struct tm_cal_param cal_param;
+				u8 _pad[80];
+			} param;
+		} rf;
+	} op;
+} __packed;
+
+struct mt7996_tm_req {
+	u8 _rsv[4];
+
+	struct mt7996_tm_rf_test rf_test;
+} __packed;
+
+struct mt7996_tm_rf_test_data {
+	__le32 cal_idx;
+	__le32 cal_type;
+	u8 cal_data[0];
+} __packed;
+
+struct mt7996_tm_rf_test_result {
+	__le32 func_idx;
+	__le32 payload_length;
+	u8 data[0];
+};
+
+struct mt7996_tm_event {
+	u8 _rsv[4];
+
+	__le16 tag;
+	__le16 len;
+	struct mt7996_tm_rf_test_result result;
+} __packed;
+
+#define RF_TEST_RE_CAL		0x01
+
+enum {
+	RF_ACTION_SWITCH_TO_RF_TEST,
+	RF_ACTION_IN_RF_TEST,
+	RF_ACTION_SET = 3,
+	RF_ACTION_GET,
+};
+
+#define RF_TEST_ICAP_LEN	120
+
+enum {
+	RF_OPER_NORMAL,
+	RF_OPER_RF_TEST,
+	RF_OPER_ICAP,
+	RF_OPER_ICAP_OVERLAP,
+	RF_OPER_WIFI_SPECTRUM,
+};
+
+enum {
+	UNI_RF_TEST_CTRL,
+};
+
+#define RF_CMD(cmd)		RF_TEST_CMD_##cmd
+
+enum {
+	RF_TEST_CMD_STOP_TEST = 0,
+	RF_TEST_CMD_START_TX = 1,
+	RF_TEST_CMD_START_RX = 2,
+	RF_TEST_CMD_CONT_WAVE = 10,
+	RF_TEST_CMD_TX_COMMIT = 18,
+	RF_TEST_CMD_RX_COMMIT = 19,
+};
+
+#define SET_ID(id)		RF_TEST_ID_SET_##id
+#define GET_ID(id)		RF_TEST_ID_GET_##id
+
+enum {
+	RF_TEST_ID_SET_COMMAND = 1,
+	RF_TEST_ID_SET_POWER = 2,
+	RF_TEST_ID_SET_TX_RATE = 3,
+	RF_TEST_ID_SET_TX_MODE = 4,
+	RF_TEST_ID_SET_TX_LEN = 6,
+	RF_TEST_ID_SET_TX_COUNT = 7,
+	RF_TEST_ID_SET_IPG = 8,
+	RF_TEST_ID_SET_GI = 16,
+	RF_TEST_ID_SET_STBC = 17,
+	RF_TEST_ID_SET_CHAN_FREQ = 18,
+	RF_TEST_ID_GET_TXED_COUNT = 32,
+	RF_TEST_ID_SET_CONT_WAVE_MODE = 65,
+	RF_TEST_ID_SET_DA = 68,
+	RF_TEST_ID_SET_SA = 69,
+	RF_TEST_ID_SET_CBW = 71,
+	RF_TEST_ID_SET_DBW = 72,
+	RF_TEST_ID_SET_PRIMARY_CH = 73,
+	RF_TEST_ID_SET_ENCODE_MODE = 74,
+	RF_TEST_ID_SET_BAND = 90,
+	RF_TEST_ID_SET_TRX_COUNTER_RESET = 91,
+	RF_TEST_ID_SET_MAC_HEADER = 101,
+	RF_TEST_ID_SET_SEQ_CTRL = 102,
+	RF_TEST_ID_SET_PAYLOAD = 103,
+	RF_TEST_ID_SET_BAND_IDX = 104,
+	RF_TEST_ID_SET_RX_PATH = 106,
+	RF_TEST_ID_SET_FREQ_OFFSET = 107,
+	RF_TEST_ID_GET_FREQ_OFFSET = 108,
+	RF_TEST_ID_SET_TX_PATH = 113,
+	RF_TEST_ID_SET_NSS = 114,
+	RF_TEST_ID_SET_ANT_MASK = 115,
+	RF_TEST_ID_SET_IBF_ENABLE = 126,
+	RF_TEST_ID_SET_EBF_ENABLE = 127,
+	RF_TEST_ID_GET_TX_POWER = 136,
+	RF_TEST_ID_SET_RX_MU_AID = 157,
+	RF_TEST_ID_SET_HW_TX_MODE = 167,
+	RF_TEST_ID_SET_PUNCTURE = 168,
+	RF_TEST_ID_SET_FREQ_OFFSET_C2 = 171,
+	RF_TEST_ID_GET_FREQ_OFFSET_C2 = 172,
+	RF_TEST_ID_SET_CFG_ON = 176,
+	RF_TEST_ID_SET_CFG_OFF = 177,
+	RF_TEST_ID_SET_BSSID = 189,
+	RF_TEST_ID_SET_TX_TIME = 190,
+	RF_TEST_ID_SET_MAX_PE = 191,
+	RF_TEST_ID_SET_AID_OFFSET = 204,
+};
+
+#define POWER_CTRL(type)	UNI_TXPOWER_##type##_CTRL
+
+struct mt7996_tm_rx_stat_user_ctrl {
+	__le16 tag;
+	__le16 len;
+
+	u8 band_idx;
+	u8 rsv;
+	__le16 user_idx;
+} __packed;
+
+struct mt7996_tm_rx_stat_all {
+	__le16 tag;
+	__le16 len;
+
+	u8 band_idx;
+	u8 rsv[3];
+} __packed;
+
+struct mt7996_tm_rx_req {
+	u8 band;
+	u8 _rsv[3];
+
+	union {
+		struct mt7996_tm_rx_stat_user_ctrl user_ctrl;
+		struct mt7996_tm_rx_stat_all rx_stat_all;
+	};
+} __packed;
+
+enum {
+	UNI_TM_RX_STAT_SET_USER_CTRL = 7,
+	UNI_TM_RX_STAT_GET_ALL_V2 = 9,
+};
+
+struct rx_band_info {
+	/* mac part */
+	__le16 mac_rx_fcs_err_cnt;
+	__le16 mac_rx_len_mismatch;
+	__le16 mac_rx_fcs_ok_cnt;
+	u8 rsv1[2];
+	__le32 mac_rx_mdrdy_cnt;
+
+	/* phy part */
+	__le16 phy_rx_fcs_err_cnt_cck;
+	__le16 phy_rx_fcs_err_cnt_ofdm;
+	__le16 phy_rx_pd_cck;
+	__le16 phy_rx_pd_ofdm;
+	__le16 phy_rx_sig_err_cck;
+	__le16 phy_rx_sfd_err_cck;
+	__le16 phy_rx_sig_err_ofdm;
+	__le16 phy_rx_tag_err_ofdm;
+	__le16 phy_rx_mdrdy_cnt_cck;
+	__le16 phy_rx_mdrdy_cnt_ofdm;
+} __packed;
+
+struct rx_band_info_ext {
+	/* mac part */
+	__le32 mac_rx_mpdu_cnt;
+
+	/* phy part */
+	u8 rsv[4];
+} __packed;
+
+struct rx_common_info {
+	__le16 rx_fifo_full;
+	u8 rsv[2];
+	__le32 aci_hit_low;
+	__le32 aci_hit_high;
+} __packed;
+
+struct rx_common_info_ext {
+	__le32 driver_rx_count;
+	__le32 sinr;
+	__le32 mu_pkt_count;
+
+	/* mac part */
+	u8 _rsv[4];
+
+	/* phy part */
+	u8 sig_mcs;
+	u8 rsv[3];
+} __packed;
+
+struct rx_rxv_info {
+	__le16 rcpi;
+	s16 rssi;
+	s16 snr;
+	s16 adc_rssi;
+} __packed;
+
+struct rx_rssi_info {
+	s8 ib_rssi;
+	s8 wb_rssi;
+	u8 rsv[2];
+} __packed;
+
+struct rx_user_info {
+	s32 freq_offset;
+	s32 snr;
+	__le32 fcs_err_count;
+} __packed;
+
+struct rx_user_info_ext {
+	s8 ne_var_db_all_user;
+	u8 rsv[3];
+} __packed;
+
+#define MAX_ANTENNA_NUM		8
+#define MAX_USER_NUM		16
+
+struct mt7996_tm_rx_event_stat_all {
+	__le16 tag;
+	__le16 len;
+
+	struct rx_band_info band_info;
+	struct rx_band_info_ext band_info_ext;
+	struct rx_common_info common_info;
+	struct rx_common_info_ext common_info_ext;
+
+	/* RXV info */
+	struct rx_rxv_info rxv_info[MAX_ANTENNA_NUM];
+
+	/* RSSI info */
+	struct rx_rssi_info fagc[MAX_ANTENNA_NUM];
+	struct rx_rssi_info inst[MAX_ANTENNA_NUM];
+
+	/* User info */
+	struct rx_user_info user_info[MAX_USER_NUM];
+	struct rx_user_info_ext user_info_ext[MAX_USER_NUM];
+} __packed;
+
+struct mt7996_tm_rx_event {
+	u8 _rsv[4];
+
+	union {
+		struct mt7996_tm_rx_event_stat_all rx_stat_all;
+	};
+} __packed;
+
+enum {
+	RDD_SET_IPI_CR_INIT,		/* CR initialization */
+	RDD_SET_IPI_HIST_RESET,		/* Reset IPI histogram counter */
+	RDD_SET_IDLE_POWER,		/* Idle power info */
+	RDD_SET_IPI_HIST_NUM
+};
+
+enum {
+	RDD_IPI_HIST_0,			/* IPI count for power <= -92 (dBm) */
+	RDD_IPI_HIST_1,			/* IPI count for -92 < power <= -89 (dBm) */
+	RDD_IPI_HIST_2,			/* IPI count for -89 < power <= -86 (dBm) */
+	RDD_IPI_HIST_3,			/* IPI count for -86 < power <= -83 (dBm) */
+	RDD_IPI_HIST_4,			/* IPI count for -83 < power <= -80 (dBm) */
+	RDD_IPI_HIST_5,			/* IPI count for -80 < power <= -75 (dBm) */
+	RDD_IPI_HIST_6,			/* IPI count for -75 < power <= -70 (dBm) */
+	RDD_IPI_HIST_7,			/* IPI count for -70 < power <= -65 (dBm) */
+	RDD_IPI_HIST_8,			/* IPI count for -65 < power <= -60 (dBm) */
+	RDD_IPI_HIST_9,			/* IPI count for -60 < power <= -55 (dBm) */
+	RDD_IPI_HIST_10,		/* IPI count for -55 < power        (dBm) */
+	RDD_IPI_FREE_RUN_CNT,		/* IPI count for counter++ per 8 us */
+	RDD_IPI_HIST_ALL_CNT,		/* Get all IPI */
+	RDD_IPI_HIST_0_TO_10_CNT,	/* Get IPI histogram 0 to 10 */
+	RDD_IPI_HIST_2_TO_10_CNT,	/* Get IPI histogram 2 to 10 */
+	RDD_TX_ASSERT_TIME,		/* Get band 1 TX assert time */
+	RDD_IPI_HIST_NUM
+};
+
+#define POWER_INDICATE_HIST_MAX		RDD_IPI_FREE_RUN_CNT
+#define IPI_HIST_TYPE_NUM		(POWER_INDICATE_HIST_MAX + 1)
+
+struct mt7996_tm_rdd_ipi_ctrl {
+	u8 ipi_hist_idx;
+	u8 band_idx;
+	u8 rsv[2];
+	__le32 ipi_hist_val[IPI_HIST_TYPE_NUM];
+	__le32 tx_assert_time;		/* unit: us */
+} __packed;
+
+#endif
diff --git a/mt7996/trace.c b/mt7996/trace.c
new file mode 100644
index 00000000..ba36f79a
--- /dev/null
+++ b/mt7996/trace.c
@@ -0,0 +1,12 @@
+/* SPDX-License-Identifier: ISC */
+/*
+ * Copyright (C) 2022 MediaTek Inc.
+ */
+
+#include <linux/module.h>
+
+#ifndef __CHECKER__
+#define CREATE_TRACE_POINTS
+#include "mt7996_trace.h"
+
+#endif
diff --git a/mt7996/vendor.c b/mt7996/vendor.c
new file mode 100644
index 00000000..84b50ab2
--- /dev/null
+++ b/mt7996/vendor.c
@@ -0,0 +1,1388 @@
+// SPDX-License-Identifier: ISC
+/*
+ * Copyright (C) 2020, MediaTek Inc. All rights reserved.
+ */
+
+#include <net/netlink.h>
+
+#include "mt7996.h"
+#include "mcu.h"
+#include "vendor.h"
+#include "mtk_mcu.h"
+
+#ifdef CONFIG_MTK_VENDOR
+static const struct nla_policy
+mu_ctrl_policy[NUM_MTK_VENDOR_ATTRS_MU_CTRL] = {
+	[MTK_VENDOR_ATTR_MU_CTRL_ONOFF] = {.type = NLA_U8 },
+	[MTK_VENDOR_ATTR_MU_CTRL_DUMP] = {.type = NLA_U8 },
+	[MTK_VENDOR_ATTR_MU_CTRL_STRUCT] = {.type = NLA_BINARY },
+	[MTK_VENDOR_ATTR_MU_CTRL_BAND_IDX] = {.type = NLA_U8 },
+};
+
+static const struct nla_policy
+wireless_ctrl_policy[NUM_MTK_VENDOR_ATTRS_WIRELESS_CTRL] = {
+	[MTK_VENDOR_ATTR_WIRELESS_CTRL_AMSDU] = {.type = NLA_U8 },
+	[MTK_VENDOR_ATTR_WIRELESS_CTRL_AMPDU] = {.type = NLA_U8 },
+	[MTK_VENDOR_ATTR_WIRELESS_CTRL_CERT] = {.type = NLA_U8 },
+	[MTK_VENDOR_ATTR_WIRELESS_CTRL_RTS_SIGTA] = {.type = NLA_U8 },
+	[MTK_VENDOR_ATTR_WIRELESS_CTRL_FIXED_MCS] = {.type = NLA_U8 },
+	[MTK_VENDOR_ATTR_WIRELESS_CTRL_OFDMA] = {.type = NLA_U8 },
+	[MTK_VENDOR_ATTR_WIRELESS_CTRL_PPDU_TX_TYPE] = {.type = NLA_U8 },
+	[MTK_VENDOR_ATTR_WIRELESS_CTRL_NUSERS_OFDMA] = {.type = NLA_U8 },
+	[MTK_VENDOR_ATTR_WIRELESS_CTRL_MIMO] = {.type = NLA_U8 },
+	[MTK_VENDOR_ATTR_WIRELESS_CTRL_BA_BUFFER_SIZE] = {.type = NLA_U16 },
+};
+
+static const struct nla_policy
+wireless_dump_policy[NUM_MTK_VENDOR_ATTRS_WIRELESS_DUMP] = {
+	[MTK_VENDOR_ATTR_WIRELESS_DUMP_AMSDU] = { .type = NLA_U8 },
+};
+
+static const struct nla_policy
+amnt_ctrl_policy[NUM_MTK_VENDOR_ATTRS_AMNT_CTRL] = {
+	[MTK_VENDOR_ATTR_AMNT_CTRL_SET] = {.type = NLA_NESTED },
+	[MTK_VENDOR_ATTR_AMNT_CTRL_DUMP] = { .type = NLA_NESTED },
+};
+
+static const struct nla_policy
+amnt_set_policy[NUM_MTK_VENDOR_ATTRS_AMNT_SET] = {
+	[MTK_VENDOR_ATTR_AMNT_SET_INDEX] = {.type = NLA_U8 },
+	[MTK_VENDOR_ATTR_AMNT_SET_MACADDR] = NLA_POLICY_EXACT_LEN_WARN(ETH_ALEN),
+};
+
+static const struct nla_policy
+amnt_dump_policy[NUM_MTK_VENDOR_ATTRS_AMNT_DUMP] = {
+	[MTK_VENDOR_ATTR_AMNT_DUMP_INDEX] = {.type = NLA_U8 },
+	[MTK_VENDOR_ATTR_AMNT_DUMP_LEN] = { .type = NLA_U8 },
+	[MTK_VENDOR_ATTR_AMNT_DUMP_RESULT] = { .type = NLA_NESTED },
+};
+
+static struct nla_policy
+bss_color_ctrl_policy[NUM_MTK_VENDOR_ATTRS_BSS_COLOR_CTRL] = {
+	[MTK_VENDOR_ATTR_AVAL_BSS_COLOR_BMP] = { .type = NLA_U64 },
+};
+
+static const struct nla_policy
+edcca_ctrl_policy[NUM_MTK_VENDOR_ATTRS_EDCCA_CTRL] = {
+	[MTK_VENDOR_ATTR_EDCCA_CTRL_MODE] = { .type = NLA_U8 },
+	[MTK_VENDOR_ATTR_EDCCA_CTRL_PRI20_VAL] = { .type = NLA_U8 },
+	[MTK_VENDOR_ATTR_EDCCA_CTRL_SEC20_VAL] = { .type = NLA_U8 },
+	[MTK_VENDOR_ATTR_EDCCA_CTRL_SEC40_VAL] = { .type = NLA_U8 },
+	[MTK_VENDOR_ATTR_EDCCA_CTRL_SEC80_VAL] = { .type = NLA_U8 },
+	[MTK_VENDOR_ATTR_EDCCA_CTRL_COMPENSATE] = { .type = NLA_S8 },
+	[MTK_VENDOR_ATTR_EDCCA_CTRL_SEC160_VAL] = { .type = NLA_U8 },
+};
+
+static const struct nla_policy
+edcca_dump_policy[NUM_MTK_VENDOR_ATTRS_EDCCA_DUMP] = {
+	[MTK_VENDOR_ATTR_EDCCA_DUMP_MODE] = { .type = NLA_U8 },
+	[MTK_VENDOR_ATTR_EDCCA_DUMP_PRI20_VAL] = { .type = NLA_U8 },
+	[MTK_VENDOR_ATTR_EDCCA_DUMP_SEC40_VAL] = { .type = NLA_U8 },
+	[MTK_VENDOR_ATTR_EDCCA_DUMP_SEC80_VAL] = { .type = NLA_U8 },
+	[MTK_VENDOR_ATTR_EDCCA_DUMP_SEC160_VAL] = { .type = NLA_U8 },
+};
+
+static const struct nla_policy
+three_wire_ctrl_policy[NUM_MTK_VENDOR_ATTRS_3WIRE_CTRL] = {
+	[MTK_VENDOR_ATTR_3WIRE_CTRL_MODE] = {.type = NLA_U8 },
+};
+
+static const struct nla_policy
+ibf_ctrl_policy[NUM_MTK_VENDOR_ATTRS_IBF_CTRL] = {
+	[MTK_VENDOR_ATTR_IBF_CTRL_ENABLE] = { .type = NLA_U8 },
+};
+
+static struct nla_policy
+pp_ctrl_policy[NUM_MTK_VENDOR_ATTRS_PP_CTRL] = {
+	[MTK_VENDOR_ATTR_PP_MODE] = { .type = NLA_U8 },
+	[MTK_VENDOR_ATTR_PP_BAND_IDX] = { .type = NLA_U8 },
+};
+
+static const struct nla_policy
+rfeature_ctrl_policy[NUM_MTK_VENDOR_ATTRS_RFEATURE_CTRL] = {
+	[MTK_VENDOR_ATTR_RFEATURE_CTRL_HE_GI] = {.type = NLA_U8 },
+	[MTK_VENDOR_ATTR_RFEATURE_CTRL_HE_LTF] = { .type = NLA_U8 },
+	[MTK_VENDOR_ATTR_RFEATURE_CTRL_TRIG_TYPE_CFG] = { .type = NLA_NESTED },
+	[MTK_VENDOR_ATTR_RFEATURE_CTRL_TRIG_TYPE_EN] = { .type = NLA_U8 },
+	[MTK_VENDOR_ATTR_RFEATURE_CTRL_TRIG_TYPE] = { .type = NLA_U8 },
+	[MTK_VENDOR_ATTR_RFEATURE_CTRL_ACK_PLCY] = { .type = NLA_U8 },
+	[MTK_VENDOR_ATTR_RFEATURE_CTRL_TRIG_TXBF] = { .type = NLA_U8 },
+};
+
+static const struct nla_policy
+background_radar_ctrl_policy[NUM_MTK_VENDOR_ATTRS_BACKGROUND_RADAR_CTRL] = {
+	[MTK_VENDOR_ATTR_BACKGROUND_RADAR_CTRL_MODE] = {.type = NLA_U8 },
+};
+
+static const struct nla_policy
+beacon_ctrl_policy[NUM_MTK_VENDOR_ATTRS_BEACON_CTRL] = {
+	[MTK_VENDOR_ATTR_BEACON_CTRL_MODE] = { .type = NLA_U8 },
+};
+
+static const struct nla_policy
+csi_ctrl_policy[NUM_MTK_VENDOR_ATTRS_CSI_CTRL] = {
+	[MTK_VENDOR_ATTR_CSI_CTRL_BAND_IDX] = { .type = NLA_U8 },
+	[MTK_VENDOR_ATTR_CSI_CTRL_CFG] = {.type = NLA_NESTED },
+	[MTK_VENDOR_ATTR_CSI_CTRL_CFG_MODE] = { .type = NLA_U8 },
+	[MTK_VENDOR_ATTR_CSI_CTRL_CFG_TYPE] = { .type = NLA_U8 },
+	[MTK_VENDOR_ATTR_CSI_CTRL_CFG_VAL1] = { .type = NLA_U8 },
+	[MTK_VENDOR_ATTR_CSI_CTRL_CFG_VAL2] = { .type = NLA_U32 },
+	[MTK_VENDOR_ATTR_CSI_CTRL_MAC_ADDR] = { .type = NLA_NESTED },
+	[MTK_VENDOR_ATTR_CSI_CTRL_DUMP_NUM] = { .type = NLA_U16 },
+	[MTK_VENDOR_ATTR_CSI_CTRL_DATA] = { .type = NLA_NESTED },
+};
+
+struct mt7996_amnt_data {
+	u8 idx;
+	u8 addr[ETH_ALEN];
+	s8 rssi[4];
+	u32 last_seen;
+};
+
+static int mt7996_vendor_mu_ctrl(struct wiphy *wiphy,
+				 struct wireless_dev *wdev,
+				 const void *data,
+				 int data_len)
+{
+	struct ieee80211_hw *hw = wiphy_to_ieee80211_hw(wiphy);
+	struct nlattr *tb[NUM_MTK_VENDOR_ATTRS_MU_CTRL];
+	struct mt7996_phy *phy = mt7996_hw_phy(hw);
+	struct mt7996_muru *muru;
+	int err;
+	u8 val8, band_idx;
+	u32 val32 = 0;
+
+	err = nla_parse(tb, MTK_VENDOR_ATTR_MU_CTRL_MAX, data, data_len,
+			mu_ctrl_policy, NULL);
+	if (err)
+		return err;
+
+	if (tb[MTK_VENDOR_ATTR_MU_CTRL_ONOFF] &&
+	    tb[MTK_VENDOR_ATTR_MU_CTRL_BAND_IDX]) {
+		val8 = nla_get_u8(tb[MTK_VENDOR_ATTR_MU_CTRL_ONOFF]);
+		band_idx = nla_get_u8(tb[MTK_VENDOR_ATTR_MU_CTRL_BAND_IDX]);
+		val32 |= FIELD_PREP(RATE_CFG_MODE, RATE_PARAM_AUTO_MU) |
+			 FIELD_PREP(RATE_CFG_VAL, val8) |
+			 FIELD_PREP(RATE_CFG_BAND_IDX, band_idx);
+		ieee80211_iterate_active_interfaces_atomic(hw, IEEE80211_IFACE_ITER_RESUME_ALL,
+							   mt7996_set_wireless_vif, &val32);
+	} else if (tb[MTK_VENDOR_ATTR_MU_CTRL_STRUCT]) {
+		muru = kzalloc(sizeof(struct mt7996_muru), GFP_KERNEL);
+
+		nla_memcpy(muru, tb[MTK_VENDOR_ATTR_MU_CTRL_STRUCT],
+			   sizeof(struct mt7996_muru));
+
+		err = mt7996_mcu_set_muru_cfg(phy, muru);
+		kfree(muru);
+	}
+
+	return err;
+}
+
+static int
+mt7996_vendor_mu_ctrl_dump(struct wiphy *wiphy, struct wireless_dev *wdev,
+			   struct sk_buff *skb, const void *data, int data_len,
+			   unsigned long *storage)
+{
+	struct ieee80211_hw *hw = wiphy_to_ieee80211_hw(wiphy);
+	struct mt7996_dev *dev = mt7996_hw_dev(hw);
+	struct mt7996_phy *phy;
+	struct mt76_phy *mphy;
+	struct nlattr *tb[NUM_MTK_VENDOR_ATTRS_MU_CTRL];
+	int len = 0, err;
+	u8 band_idx;
+
+	if (*storage == 1)
+		return -ENOENT;
+	*storage = 1;
+
+	err = nla_parse(tb, MTK_VENDOR_ATTR_MU_CTRL_MAX, data, data_len,
+			mu_ctrl_policy, NULL);
+	if (err)
+		return err;
+
+	if (!tb[MTK_VENDOR_ATTR_MU_CTRL_BAND_IDX])
+		return -EINVAL;
+
+	band_idx = nla_get_u8(tb[MTK_VENDOR_ATTR_MU_CTRL_BAND_IDX]);
+	if (!mt7996_band_valid(dev, band_idx))
+		goto error;
+
+	mphy = dev->mt76.phys[band_idx];
+	if (!mphy)
+		goto error;
+
+	phy = (struct mt7996_phy *)mphy->priv;
+
+	if (nla_put_u8(skb, MTK_VENDOR_ATTR_MU_CTRL_DUMP, phy->muru_onoff))
+		return -ENOMEM;
+	len += 1;
+
+	return len;
+
+error:
+	dev_err(dev->mt76.dev, "Invalid band idx to dump\n");
+	return -EINVAL;
+}
+
+void mt7996_set_wireless_rts_sigta(struct ieee80211_hw *hw, u8 value) {
+	struct mt7996_phy *phy = mt7996_hw_phy(hw);
+
+	switch (value) {
+	case BW_SIGNALING_STATIC:
+	case BW_SIGNALING_DYNAMIC:
+		mt7996_mcu_set_band_confg(phy, UNI_BAND_CONFIG_RTS_SIGTA_EN, true);
+		mt7996_mcu_set_band_confg(phy, UNI_BAND_CONFIG_DIS_SECCH_CCA_DET, false);
+		break;
+	default:
+		value = BW_SIGNALING_DISABLE;
+		mt7996_mcu_set_band_confg(phy, UNI_BAND_CONFIG_RTS_SIGTA_EN, false);
+		mt7996_mcu_set_band_confg(phy, UNI_BAND_CONFIG_DIS_SECCH_CCA_DET, true);
+		break;
+      }
+
+	phy->rts_bw_sig = value;
+
+	/* Set RTS Threshold to a lower Value */
+	mt7996_mcu_set_rts_thresh(phy, 500);
+}
+
+static int
+mt7996_vendor_wireless_ctrl_dump(struct wiphy *wiphy, struct wireless_dev *wdev,
+				 struct sk_buff *skb, const void *data, int data_len,
+				 unsigned long *storage)
+{
+	struct ieee80211_hw *hw = wiphy_to_ieee80211_hw(wiphy);
+	int len = 0;
+
+	if (*storage == 1)
+		return -ENOENT;
+	*storage = 1;
+
+	if (nla_put_u8(skb, MTK_VENDOR_ATTR_WIRELESS_DUMP_AMSDU,
+		       ieee80211_hw_check(hw, SUPPORTS_AMSDU_IN_AMPDU)))
+	return -ENOMEM;
+	len += 1;
+
+	return len;
+ }
+
+void mt7996_vendor_amnt_fill_rx(struct mt7996_phy *phy, struct sk_buff *skb)
+{
+	struct mt76_rx_status *status = (struct mt76_rx_status *)skb->cb;
+	struct mt7996_air_monitor_ctrl *ctrl = &phy->amnt_ctrl;
+	struct ieee80211_hdr *hdr = mt76_skb_get_hdr(skb);
+	__le16 fc = hdr->frame_control;
+	u8 addr[ETH_ALEN];
+	int i;
+
+	if (!ieee80211_has_fromds(fc))
+		ether_addr_copy(addr, hdr->addr2);
+	else if (ieee80211_has_tods(fc))
+		ether_addr_copy(addr, hdr->addr4);
+	else
+		ether_addr_copy(addr, hdr->addr3);
+
+	spin_lock_bh(&phy->amnt_lock);
+	for (i = 0; i < MT7996_AIR_MONITOR_MAX_ENTRY; i++) {
+		struct mt7996_air_monitor_entry *entry;
+
+		if (ether_addr_equal(addr, ctrl->entry[i].addr)) {
+			entry = &ctrl->entry[i];
+			entry->rssi[0] = status->chain_signal[0];
+			entry->rssi[1] = status->chain_signal[1];
+			entry->rssi[2] = status->chain_signal[2];
+			entry->rssi[3] = status->chain_signal[3];
+			entry->last_seen = jiffies;
+			break;
+		}
+	}
+	spin_unlock_bh(&phy->amnt_lock);
+}
+
+static int
+mt7996_vendor_smesh_ctrl(struct mt7996_phy *phy, u8 write,
+			 u8 enable, u8 *value)
+{
+#define UNI_CMD_SMESH_PARAM  0
+	struct mt7996_dev *dev = phy->dev;
+	struct smesh_param {
+		__le16 tag;
+		__le16 length;
+
+		u8 enable;
+		bool a2;
+		bool a1;
+		bool data;
+		bool mgnt;
+		bool ctrl;
+		u8 padding[2];
+	} req = {
+		.tag = cpu_to_le16(UNI_CMD_SMESH_PARAM),
+		.length = cpu_to_le16(sizeof(req) - 4),
+
+		.enable = enable,
+		.a2 = true,
+		.a1 = true,
+		.data = true,
+		.mgnt = false,
+		.ctrl = false,
+	};
+	struct smesh_param *res;
+	struct sk_buff *skb;
+	int ret = 0;
+
+	if (!value)
+		return -EINVAL;
+
+	ret = mt76_mcu_send_and_get_msg(&dev->mt76, MCU_WM_UNI_CMD(CFG_SMESH),
+					&req, sizeof(req), !write, &skb);
+
+	if (ret || write)
+		return ret;
+
+	res = (struct smesh_param *) skb->data;
+
+	*value = res->enable;
+
+	dev_kfree_skb(skb);
+
+	return 0;
+}
+
+static int
+mt7996_vendor_amnt_muar(struct mt7996_phy *phy, u8 muar_idx, u8 *addr)
+{
+#define UNI_CMD_MUAR_ENTRY  2
+	struct mt7996_dev *dev = phy->dev;
+	struct muar_entry {
+		__le16 tag;
+		__le16 length;
+
+		bool smesh;
+		u8 hw_bss_index;
+		u8 muar_idx;
+		u8 entry_add;
+		u8 mac_addr[6];
+		u8 padding[2];
+	} __packed req = {
+		.tag = cpu_to_le16(UNI_CMD_MUAR_ENTRY),
+		.length = cpu_to_le16(sizeof(req) - 4),
+
+		.smesh = true,
+		.hw_bss_index = phy != &dev->phy,
+		.muar_idx = muar_idx,
+		.entry_add = 1,
+	};
+
+	ether_addr_copy(req.mac_addr, addr);
+	return mt76_mcu_send_msg(&dev->mt76, MCU_WM_UNI_CMD(REPT_MUAR), &req,
+				 sizeof(req), true);
+}
+
+static int
+mt7996_vendor_amnt_set_en(struct mt7996_phy *phy, u8 enable)
+{
+	u8 status;
+	int ret;
+
+	ret = mt7996_vendor_smesh_ctrl(phy, 0, enable, &status);
+	if (ret)
+		return ret;
+
+	if (status == enable)
+		return 0;
+
+	ret = mt7996_vendor_smesh_ctrl(phy, 1, enable, &status);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+static int
+mt7996_vendor_amnt_set_addr(struct mt7996_phy *phy, u8 index, u8 *addr)
+{
+	struct mt7996_air_monitor_ctrl *amnt_ctrl = &phy->amnt_ctrl;
+	struct mt7996_air_monitor_group *group;
+	struct mt7996_air_monitor_entry *entry;
+	int ret, i, j;
+
+	if (index >= MT7996_AIR_MONITOR_MAX_ENTRY)
+		return -1;
+
+	spin_lock_bh(&phy->amnt_lock);
+	entry = &amnt_ctrl->entry[index];
+	if (!is_zero_ether_addr(addr)) {
+		if (entry->enable == false) {
+			for (i = 0; i < MT7996_AIR_MONITOR_MAX_GROUP; i++) {
+				group = &(amnt_ctrl->group[i]);
+				if (group->used[0] == false)
+					j = 0;
+				else if (group->used[1] == false)
+					j = 1;
+				else
+					continue;
+
+				group->enable = true;
+				group->used[j] = true;
+				entry->enable = true;
+				entry->group_idx = i;
+				entry->group_used_idx = j;
+				entry->muar_idx = 32 + 4 * i + 2 * j;
+				break;
+			}
+		}
+	} else {
+		group = &(amnt_ctrl->group[entry->group_idx]);
+
+		group->used[entry->group_used_idx] = false;
+		if (group->used[0] == false && group->used[1] == false)
+			group->enable = false;
+
+		entry->enable = false;
+	}
+	ether_addr_copy(entry->addr, addr);
+	amnt_ctrl->enable &= ~(1 << entry->group_idx);
+	amnt_ctrl->enable |= entry->enable << entry->group_idx;
+	spin_unlock_bh(&phy->amnt_lock);
+
+	ret = mt7996_vendor_amnt_muar(phy, entry->muar_idx, addr);
+	if (ret)
+		return ret;
+
+	return mt7996_vendor_amnt_set_en(phy, amnt_ctrl->enable);
+}
+
+static int
+mt7966_vendor_amnt_ctrl(struct wiphy *wiphy, struct wireless_dev *wdev,
+			const void *data, int data_len)
+{
+	struct ieee80211_hw *hw = wiphy_to_ieee80211_hw(wiphy);
+	struct mt7996_phy *phy = mt7996_hw_phy(hw);
+	struct nlattr *tb1[NUM_MTK_VENDOR_ATTRS_AMNT_CTRL];
+	struct nlattr *tb2[NUM_MTK_VENDOR_ATTRS_AMNT_SET];
+	u8 index = 0;
+	u8 mac_addr[ETH_ALEN];
+	int err;
+
+	err = nla_parse(tb1, MTK_VENDOR_ATTR_AMNT_CTRL_MAX, data, data_len,
+			amnt_ctrl_policy, NULL);
+	if (err)
+		return err;
+
+	if (!tb1[MTK_VENDOR_ATTR_AMNT_CTRL_SET])
+		return -EINVAL;
+
+	err = nla_parse_nested(tb2, MTK_VENDOR_ATTR_AMNT_SET_MAX,
+		tb1[MTK_VENDOR_ATTR_AMNT_CTRL_SET], amnt_set_policy, NULL);
+
+	if (!tb2[MTK_VENDOR_ATTR_AMNT_SET_INDEX] ||
+		!tb2[MTK_VENDOR_ATTR_AMNT_SET_MACADDR])
+		return -EINVAL;
+
+	index = nla_get_u8(tb2[MTK_VENDOR_ATTR_AMNT_SET_INDEX]);
+	memcpy(mac_addr, nla_data(tb2[MTK_VENDOR_ATTR_AMNT_SET_MACADDR]), ETH_ALEN);
+
+	return mt7996_vendor_amnt_set_addr(phy, index, mac_addr);
+}
+
+int mt7996_vendor_amnt_sta_remove(struct mt7996_phy *phy,
+				  struct ieee80211_sta *sta)
+{
+	u8 zero[ETH_ALEN] = {};
+	int i;
+
+	if (!phy->amnt_ctrl.enable)
+		return 0;
+
+	for (i = 0; i < MT7996_AIR_MONITOR_MAX_ENTRY; i++)
+		if (ether_addr_equal(sta->addr, phy->amnt_ctrl.entry[i].addr))
+			return mt7996_vendor_amnt_set_addr(phy, i, zero);
+	return 0;
+}
+
+static int
+mt7996_amnt_dump(struct mt7996_phy *phy, struct sk_buff *skb,
+		 u8 amnt_idx, int *attrtype)
+{
+	struct mt7996_air_monitor_entry *entry;
+	struct mt7996_amnt_data data;
+	u32 last_seen = 0;
+
+	spin_lock_bh(&phy->amnt_lock);
+	entry = &phy->amnt_ctrl.entry[amnt_idx];
+	if (entry->enable == 0) {
+		spin_unlock_bh(&phy->amnt_lock);
+		return 0;
+	}
+
+	last_seen = jiffies_to_msecs(jiffies - entry->last_seen);
+	ether_addr_copy(data.addr, entry->addr);
+	data.rssi[0] = entry->rssi[0];
+	data.rssi[1] = entry->rssi[1];
+	data.rssi[2] = entry->rssi[2];
+	data.rssi[3] = entry->rssi[3];
+	spin_unlock_bh(&phy->amnt_lock);
+
+	data.idx = amnt_idx;
+	data.last_seen = last_seen;
+
+	nla_put(skb, (*attrtype)++, sizeof(struct mt7996_amnt_data), &data);
+
+	return 1;
+}
+
+static int
+mt7966_vendor_amnt_ctrl_dump(struct wiphy *wiphy, struct wireless_dev *wdev,
+			     struct sk_buff *skb, const void *data, int data_len,
+			     unsigned long *storage)
+{
+	struct ieee80211_hw *hw = wiphy_to_ieee80211_hw(wiphy);
+	struct mt7996_phy *phy = mt7996_hw_phy(hw);
+	struct nlattr *tb1[NUM_MTK_VENDOR_ATTRS_AMNT_CTRL];
+	struct nlattr *tb2[NUM_MTK_VENDOR_ATTRS_AMNT_DUMP];
+	void *a, *b;
+	int err = 0, attrtype = 0, i, len = 0;
+	u8 amnt_idx;
+
+	if (*storage == 1)
+		return -ENOENT;
+	*storage = 1;
+
+	err = nla_parse(tb1, MTK_VENDOR_ATTR_AMNT_CTRL_MAX, data, data_len,
+			amnt_ctrl_policy, NULL);
+	if (err)
+		return err;
+
+	if (!tb1[MTK_VENDOR_ATTR_AMNT_CTRL_DUMP])
+		return -EINVAL;
+
+	err = nla_parse_nested(tb2, MTK_VENDOR_ATTR_AMNT_DUMP_MAX,
+			       tb1[MTK_VENDOR_ATTR_AMNT_CTRL_DUMP],
+			       amnt_dump_policy, NULL);
+	if (err)
+		return err;
+
+	if (!tb2[MTK_VENDOR_ATTR_AMNT_DUMP_INDEX])
+		return -EINVAL;
+
+	amnt_idx = nla_get_u8(tb2[MTK_VENDOR_ATTR_AMNT_DUMP_INDEX]);
+
+	a = nla_nest_start(skb, MTK_VENDOR_ATTR_AMNT_CTRL_DUMP);
+	b = nla_nest_start(skb, MTK_VENDOR_ATTR_AMNT_DUMP_RESULT);
+
+	if (amnt_idx != 0xff) {
+		len += mt7996_amnt_dump(phy, skb, amnt_idx, &attrtype);
+	} else {
+		for (i = 0; i < MT7996_AIR_MONITOR_MAX_ENTRY; i++)
+			len += mt7996_amnt_dump(phy, skb, i, &attrtype);
+	}
+
+	nla_nest_end(skb, b);
+
+	nla_put_u8(skb, MTK_VENDOR_ATTR_AMNT_DUMP_LEN, len);
+
+	nla_nest_end(skb, a);
+
+	return len + 1;
+}
+
+static int
+mt7996_vendor_bss_color_ctrl_dump(struct wiphy *wiphy, struct wireless_dev *wdev,
+				  struct sk_buff *skb, const void *data, int data_len,
+				  unsigned long *storage)
+{
+	struct ieee80211_vif *vif = wdev_to_ieee80211_vif(wdev);
+	struct ieee80211_bss_conf *bss_conf = &vif->bss_conf;
+	int len = 0;
+
+	if (*storage == 1)
+		return -ENOENT;
+	*storage = 1;
+
+	if (nla_put_u64_64bit(skb, MTK_VENDOR_ATTR_AVAL_BSS_COLOR_BMP,
+			      ~bss_conf->used_color_bitmap, NL80211_ATTR_PAD))
+		return -ENOMEM;
+	len += 1;
+
+	return len;
+}
+
+static int mt7996_vendor_edcca_ctrl(struct wiphy *wiphy, struct wireless_dev *wdev,
+				    const void *data, int data_len)
+{
+	struct ieee80211_hw *hw = wiphy_to_ieee80211_hw(wiphy);
+	struct mt7996_phy *phy = mt7996_hw_phy(hw);
+	struct nlattr *tb[NUM_MTK_VENDOR_ATTRS_EDCCA_CTRL];
+	int err;
+	u8 edcca_mode;
+	u8 edcca_value[EDCCA_MAX_BW_NUM];
+
+	err = nla_parse(tb, MTK_VENDOR_ATTR_EDCCA_CTRL_MAX, data, data_len,
+			edcca_ctrl_policy, NULL);
+	if (err)
+		return err;
+
+	if (!tb[MTK_VENDOR_ATTR_EDCCA_CTRL_MODE])
+		return -EINVAL;
+
+	edcca_mode = nla_get_u8(tb[MTK_VENDOR_ATTR_EDCCA_CTRL_MODE]);
+	if (edcca_mode == EDCCA_CTRL_SET_EN) {
+		if (!tb[MTK_VENDOR_ATTR_EDCCA_CTRL_PRI20_VAL])
+			return -EINVAL;
+
+		edcca_value[0] =
+			nla_get_u8(tb[MTK_VENDOR_ATTR_EDCCA_CTRL_PRI20_VAL]);
+
+		err = mt7996_mcu_edcca_enable(phy, !!edcca_value[0]);
+		if (err)
+			return err;
+	} else if (edcca_mode == EDCCA_CTRL_SET_THRES) {
+		if (!tb[MTK_VENDOR_ATTR_EDCCA_CTRL_PRI20_VAL] ||
+		    !tb[MTK_VENDOR_ATTR_EDCCA_CTRL_SEC40_VAL] ||
+		    !tb[MTK_VENDOR_ATTR_EDCCA_CTRL_SEC80_VAL] ||
+		    !tb[MTK_VENDOR_ATTR_EDCCA_CTRL_SEC160_VAL]) {
+			return -EINVAL;
+		}
+		edcca_value[EDCCA_BW_20] =
+			nla_get_u8(tb[MTK_VENDOR_ATTR_EDCCA_CTRL_PRI20_VAL]);
+		edcca_value[EDCCA_BW_40] =
+			nla_get_u8(tb[MTK_VENDOR_ATTR_EDCCA_CTRL_SEC40_VAL]);
+		edcca_value[EDCCA_BW_80] =
+			nla_get_u8(tb[MTK_VENDOR_ATTR_EDCCA_CTRL_SEC80_VAL]);
+		edcca_value[EDCCA_BW_160] =
+			nla_get_u8(tb[MTK_VENDOR_ATTR_EDCCA_CTRL_SEC160_VAL]);
+
+		err = mt7996_mcu_edcca_threshold_ctrl(phy, edcca_value, true);
+
+		if (err)
+			return err;
+	} else {
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+
+static int
+mt7996_vendor_edcca_ctrl_dump(struct wiphy *wiphy, struct wireless_dev *wdev,
+			     struct sk_buff *skb, const void *data, int data_len,
+			     unsigned long *storage)
+{
+	struct ieee80211_hw *hw = wiphy_to_ieee80211_hw(wiphy);
+	struct mt7996_phy *phy = mt7996_hw_phy(hw);
+	struct nlattr *tb[NUM_MTK_VENDOR_ATTRS_EDCCA_CTRL];
+	int err;
+	u8 edcca_mode;
+	u8 value[EDCCA_MAX_BW_NUM];
+
+	if (*storage == 1)
+		return -ENOENT;
+	*storage = 1;
+
+	err = nla_parse(tb, MTK_VENDOR_ATTR_EDCCA_CTRL_MAX, data, data_len,
+			edcca_ctrl_policy, NULL);
+	if (err)
+		return err;
+
+	if (!tb[MTK_VENDOR_ATTR_EDCCA_CTRL_MODE])
+		return -EINVAL;
+
+	edcca_mode = nla_get_u8(tb[MTK_VENDOR_ATTR_EDCCA_CTRL_MODE]);
+
+	if (edcca_mode != EDCCA_CTRL_GET_THRES)
+		return -EINVAL;
+
+	err = mt7996_mcu_edcca_threshold_ctrl(phy, value, false);
+
+	if (err)
+		return err;
+
+	if (nla_put_u8(skb, MTK_VENDOR_ATTR_EDCCA_DUMP_PRI20_VAL, value[EDCCA_BW_20]) ||
+	    nla_put_u8(skb, MTK_VENDOR_ATTR_EDCCA_DUMP_SEC40_VAL, value[EDCCA_BW_40]) ||
+	    nla_put_u8(skb, MTK_VENDOR_ATTR_EDCCA_DUMP_SEC80_VAL, value[EDCCA_BW_80]) ||
+	    nla_put_u8(skb, MTK_VENDOR_ATTR_EDCCA_DUMP_SEC160_VAL, value[EDCCA_BW_160]))
+		return -ENOMEM;
+
+	return EDCCA_MAX_BW_NUM;
+}
+
+static int mt7996_vendor_3wire_ctrl(struct wiphy *wiphy, struct wireless_dev *wdev,
+				    const void *data, int data_len)
+{
+#define UNI_3WIRE_EXT_EN	0
+	struct ieee80211_hw *hw = wiphy_to_ieee80211_hw(wiphy);
+	struct mt7996_dev *dev = mt7996_hw_dev(hw);
+	struct nlattr *tb[NUM_MTK_VENDOR_ATTRS_3WIRE_CTRL];
+	struct {
+		u8 __rsv1[4];
+
+		__le16 tag;
+		__le16 len;
+		u8 three_wire_mode;
+	} __packed req = {
+		.tag = cpu_to_le16(UNI_3WIRE_EXT_EN),
+		.len = cpu_to_le16(sizeof(req) - 4),
+	};
+	int err;
+
+	err = nla_parse(tb, MTK_VENDOR_ATTR_3WIRE_CTRL_MAX, data, data_len,
+			three_wire_ctrl_policy, NULL);
+	if (err)
+		return err;
+
+	if (!tb[MTK_VENDOR_ATTR_3WIRE_CTRL_MODE])
+		return -EINVAL;
+
+	req.three_wire_mode = nla_get_u8(tb[MTK_VENDOR_ATTR_3WIRE_CTRL_MODE]);
+
+	return mt76_mcu_send_msg(&dev->mt76, MCU_WM_UNI_CMD(PTA_3WIRE_CTRL), &req,
+				 sizeof(req), false);
+}
+
+static int mt7996_vendor_ibf_ctrl(struct wiphy *wiphy,
+				  struct wireless_dev *wdev,
+				  const void *data,
+				  int data_len)
+{
+	struct ieee80211_hw *hw = wiphy_to_ieee80211_hw(wiphy);
+	struct mt7996_phy *phy = mt7996_hw_phy(hw);
+	struct mt7996_dev *dev = phy->dev;
+	struct nlattr *tb[NUM_MTK_VENDOR_ATTRS_IBF_CTRL];
+	int err;
+	u8 val;
+
+	err = nla_parse(tb, MTK_VENDOR_ATTR_IBF_CTRL_MAX, data, data_len,
+			ibf_ctrl_policy, NULL);
+	if (err)
+		return err;
+
+	if (tb[MTK_VENDOR_ATTR_IBF_CTRL_ENABLE]) {
+		val = nla_get_u8(tb[MTK_VENDOR_ATTR_IBF_CTRL_ENABLE]);
+
+		dev->ibf = !!val;
+
+		err = mt7996_mcu_set_txbf(dev, BF_HW_EN_UPDATE);
+		if (err)
+			return err;
+	}
+	return 0;
+}
+
+static int
+mt7996_vendor_ibf_ctrl_dump(struct wiphy *wiphy, struct wireless_dev *wdev,
+			    struct sk_buff *skb, const void *data, int data_len,
+			    unsigned long *storage)
+{
+	struct ieee80211_hw *hw = wiphy_to_ieee80211_hw(wiphy);
+	struct mt7996_phy *phy = mt7996_hw_phy(hw);
+	struct mt7996_dev *dev = phy->dev;
+
+	if (*storage == 1)
+		return -ENOENT;
+	*storage = 1;
+
+	if (nla_put_u8(skb, MTK_VENDOR_ATTR_IBF_DUMP_ENABLE, dev->ibf))
+		return -ENOMEM;
+
+	return 1;
+}
+
+static int mt7996_vendor_pp_ctrl(struct wiphy *wiphy, struct wireless_dev *wdev,
+				 const void *data, int data_len)
+{
+	struct ieee80211_hw *hw = wiphy_to_ieee80211_hw(wiphy);
+	struct nlattr *tb[NUM_MTK_VENDOR_ATTRS_PP_CTRL];
+	struct mt7996_dev *dev = mt7996_hw_dev(hw);
+	struct mt7996_phy *phy;
+	struct mt76_phy *mphy;
+	struct cfg80211_chan_def *chandef;
+	int err;
+	u8 val8, band_idx = 0;
+
+	err = nla_parse(tb, MTK_VENDOR_ATTR_PP_CTRL_MAX, data, data_len,
+			pp_ctrl_policy, NULL);
+
+	if (tb[MTK_VENDOR_ATTR_PP_BAND_IDX]) {
+		band_idx = nla_get_u8(tb[MTK_VENDOR_ATTR_PP_BAND_IDX]);
+	}
+
+	if (!mt7996_band_valid(dev, band_idx))
+		goto error;
+
+	mphy = dev->mt76.phys[band_idx];
+	if (!mphy)
+		goto error;
+
+	phy = (struct mt7996_phy *)mphy->priv;
+	if (!phy)
+		goto error;
+
+	chandef = &phy->chanctx->chandef;
+	if (!chandef)
+		goto error;
+
+	if (chandef->chan->band == NL80211_BAND_2GHZ)
+		return 0;
+
+	if (tb[MTK_VENDOR_ATTR_PP_MODE]) {
+		val8 = nla_get_u8(tb[MTK_VENDOR_ATTR_PP_MODE]);
+		switch (val8) {
+		case PP_DISABLE:
+		case PP_FW_MODE:
+			err = mt7996_mcu_set_pp_en(phy, val8, 0);
+			break;
+		case PP_USR_MODE:
+			/* handled by add_chanctx */
+			err = 0;
+			break;
+		default:
+			err = -EINVAL;
+		}
+	}
+
+	return err;
+error:
+	dev_err(dev->mt76.dev, "Invalid band idx: %d\n", band_idx);
+	return -EINVAL;
+}
+
+static int mt7996_vendor_rfeature_ctrl(struct wiphy *wiphy,
+				       struct wireless_dev *wdev,
+				       const void *data,
+				       int data_len)
+{
+	struct ieee80211_hw *hw = wiphy_to_ieee80211_hw(wiphy);
+	struct mt7996_phy *phy = mt7996_hw_phy(hw);
+	struct mt7996_dev *dev = phy->dev;
+	struct nlattr *tb[NUM_MTK_VENDOR_ATTRS_RFEATURE_CTRL];
+	int err;
+	u32 val;
+
+	err = nla_parse(tb, MTK_VENDOR_ATTR_RFEATURE_CTRL_MAX, data, data_len,
+			rfeature_ctrl_policy, NULL);
+	if (err)
+		return err;
+
+	val = CAPI_RFEATURE_CHANGED;
+
+	if (tb[MTK_VENDOR_ATTR_RFEATURE_CTRL_TRIG_TYPE_CFG]) {
+		u8 enable, trig_type;
+		int rem;
+		struct nlattr *cur;
+
+		nla_for_each_nested(cur, tb[MTK_VENDOR_ATTR_RFEATURE_CTRL_TRIG_TYPE_CFG], rem) {
+			switch (nla_type(cur)) {
+			case MTK_VENDOR_ATTR_RFEATURE_CTRL_TRIG_TYPE_EN:
+				enable = nla_get_u8(cur);
+				break;
+			case MTK_VENDOR_ATTR_RFEATURE_CTRL_TRIG_TYPE:
+				trig_type = nla_get_u8(cur);
+				break;
+			default:
+				return -EINVAL;
+			};
+		}
+
+		err = mt7996_mcu_set_rfeature_trig_type(phy, enable, trig_type);
+		if (err)
+			return err;
+	} else if (tb[MTK_VENDOR_ATTR_RFEATURE_CTRL_ACK_PLCY]) {
+		u8 ack_policy;
+
+		ack_policy = nla_get_u8(tb[MTK_VENDOR_ATTR_RFEATURE_CTRL_ACK_PLCY]);
+		switch (ack_policy) {
+		case MU_DL_ACK_POLICY_TF_FOR_ACK:
+			return mt7996_mcu_set_muru_cmd(dev, UNI_CMD_MURU_SET_MUDL_ACK_POLICY,
+						       ack_policy);
+		default:
+			return 0;
+		}
+	}
+
+	return 0;
+}
+
+static int mt7996_vendor_wireless_ctrl(struct wiphy *wiphy,
+				       struct wireless_dev *wdev,
+				       const void *data,
+				       int data_len)
+{
+	struct ieee80211_hw *hw = wiphy_to_ieee80211_hw(wiphy);
+	struct mt7996_phy *phy = mt7996_hw_phy(hw);
+	struct mt7996_dev *dev = phy->dev;
+	struct nlattr *tb[NUM_MTK_VENDOR_ATTRS_WIRELESS_CTRL];
+	int err;
+	u8 val8;
+	u16 val16;
+	u32 val32;
+
+	err = nla_parse(tb, MTK_VENDOR_ATTR_WIRELESS_CTRL_MAX, data, data_len,
+			wireless_ctrl_policy, NULL);
+	if (err)
+		return err;
+
+	val32 = CAPI_WIRELESS_CHANGED;
+
+	if (tb[MTK_VENDOR_ATTR_WIRELESS_CTRL_OFDMA]) {
+		val8 = nla_get_u8(tb[MTK_VENDOR_ATTR_WIRELESS_CTRL_OFDMA]);
+		val32 |= FIELD_PREP(RATE_CFG_MODE, RATE_PARAM_FIXED_OFDMA) |
+			 FIELD_PREP(RATE_CFG_VAL, val8);
+		ieee80211_iterate_active_interfaces_atomic(hw, IEEE80211_IFACE_ITER_RESUME_ALL,
+			mt7996_set_wireless_vif, &val32);
+		if (val8 == 3) /* DL20and80 */
+			mt7996_mcu_set_muru_cmd(dev, UNI_CMD_MURU_SET_20M_DYN_ALGO, 1);
+	} else if (tb[MTK_VENDOR_ATTR_WIRELESS_CTRL_BA_BUFFER_SIZE]) {
+		val16 = nla_get_u16(tb[MTK_VENDOR_ATTR_WIRELESS_CTRL_BA_BUFFER_SIZE]);
+		hw->max_tx_aggregation_subframes = val16;
+		hw->max_rx_aggregation_subframes = val16;
+	} else if (tb[MTK_VENDOR_ATTR_WIRELESS_CTRL_PPDU_TX_TYPE]) {
+		val8 = nla_get_u8(tb[MTK_VENDOR_ATTR_WIRELESS_CTRL_PPDU_TX_TYPE]);
+		mt7996_mcu_set_ppdu_tx_type(phy, val8);
+	} else if (tb[MTK_VENDOR_ATTR_WIRELESS_CTRL_NUSERS_OFDMA]) {
+		val8 = nla_get_u8(tb[MTK_VENDOR_ATTR_WIRELESS_CTRL_NUSERS_OFDMA]);
+		if (phy->muru_onoff & OFDMA_UL)
+			mt7996_mcu_set_nusers_ofdma(phy, MU_CTRL_UL_USER_CNT, val8);
+		else
+			mt7996_mcu_set_nusers_ofdma(phy, MU_CTRL_DL_USER_CNT, val8);
+	} else if (tb[MTK_VENDOR_ATTR_WIRELESS_CTRL_MIMO]) {
+		val8 = nla_get_u8(tb[MTK_VENDOR_ATTR_WIRELESS_CTRL_MIMO]);
+		val32 |= FIELD_PREP(RATE_CFG_MODE, RATE_PARAM_FIXED_MIMO) |
+			 FIELD_PREP(RATE_CFG_VAL, val8);
+		ieee80211_iterate_active_interfaces_atomic(hw, IEEE80211_IFACE_ITER_RESUME_ALL,
+			mt7996_set_wireless_vif, &val32);
+	} else if (tb[MTK_VENDOR_ATTR_WIRELESS_CTRL_CERT]) {
+		val8 = nla_get_u8(tb[MTK_VENDOR_ATTR_WIRELESS_CTRL_CERT]);
+		dev->cert_mode = val8;
+		mt7996_mcu_set_cert(phy, val8);
+		mt7996_mcu_set_bypass_smthint(phy, val8);
+	} else if (tb[MTK_VENDOR_ATTR_WIRELESS_CTRL_AMSDU]) {
+		val8 = nla_get_u8(tb[MTK_VENDOR_ATTR_WIRELESS_CTRL_AMSDU]);
+		mt7996_set_wireless_amsdu(hw, val8);
+	} else if (tb[MTK_VENDOR_ATTR_WIRELESS_CTRL_RTS_SIGTA]) {
+		val8 = nla_get_u8(tb[MTK_VENDOR_ATTR_WIRELESS_CTRL_RTS_SIGTA]);
+		mt7996_set_wireless_rts_sigta(hw, val8);
+	}
+
+	return 0;
+}
+
+static int mt7996_vendor_background_radar_mode_ctrl(struct wiphy *wiphy,
+						    struct wireless_dev *wdev,
+						    const void *data,
+						    int data_len)
+{
+	struct ieee80211_hw *hw = wiphy_to_ieee80211_hw(wiphy);
+	struct mt7996_dev *dev = mt7996_hw_dev(hw);
+	struct nlattr *tb[NUM_MTK_VENDOR_ATTRS_BACKGROUND_RADAR_CTRL];
+	int err;
+	u8 background_radar_mode;
+
+	err = nla_parse(tb, MTK_VENDOR_ATTR_BACKGROUND_RADAR_CTRL_MAX, data, data_len,
+			background_radar_ctrl_policy, NULL);
+	if (err)
+		return err;
+
+	background_radar_mode = nla_get_u8(tb[MTK_VENDOR_ATTR_BACKGROUND_RADAR_CTRL_MODE]);
+
+	return mt7996_mcu_rdd_background_disable_timer(dev, !!background_radar_mode);
+}
+
+static int mt7996_vendor_beacon_ctrl(struct wiphy *wiphy,
+				     struct wireless_dev *wdev,
+				     const void *data,
+				     int data_len)
+{
+	struct ieee80211_hw *hw = wiphy_to_ieee80211_hw(wiphy);
+	struct nlattr *tb[NUM_MTK_VENDOR_ATTRS_BEACON_CTRL];
+	int err;
+	u8 val8;
+
+	err = nla_parse(tb, MTK_VENDOR_ATTR_BEACON_CTRL_MAX, data, data_len,
+			beacon_ctrl_policy, NULL);
+	if (err)
+		return err;
+
+	if (tb[MTK_VENDOR_ATTR_BEACON_CTRL_MODE]) {
+		val8 = nla_get_u8(tb[MTK_VENDOR_ATTR_BEACON_CTRL_MODE]);
+		ieee80211_iterate_active_interfaces_atomic(hw, IEEE80211_IFACE_ITER_RESUME_ALL,
+				mt7996_set_beacon_vif, &val8);
+	}
+
+	return 0;
+}
+static int mt7996_vendor_csi_ctrl(struct wiphy *wiphy,
+				  struct wireless_dev *wdev,
+				  const void *data,
+				  int data_len)
+{
+	struct ieee80211_hw *hw = wiphy_to_ieee80211_hw(wiphy);
+	struct mt7996_dev *dev = mt7996_hw_dev(hw);
+	struct mt7996_phy *phy;
+	struct mt76_phy *mphy;
+	struct nlattr *tb[NUM_MTK_VENDOR_ATTRS_CSI_CTRL];
+	u8 band_idx = 0;
+	int err;
+
+	err = nla_parse(tb, MTK_VENDOR_ATTR_CSI_CTRL_MAX, data, data_len,
+			csi_ctrl_policy, NULL);
+	if (err)
+		return err;
+
+	if (tb[MTK_VENDOR_ATTR_CSI_CTRL_BAND_IDX])
+		band_idx = nla_get_u8(tb[MTK_VENDOR_ATTR_CSI_CTRL_BAND_IDX]);
+
+	if (!mt7996_band_valid(dev, band_idx))
+		goto error;
+
+	mphy = dev->mt76.phys[band_idx];
+	if (!mphy)
+		goto error;
+
+	phy = (struct mt7996_phy *)mphy->priv;
+	if (!phy)
+		goto error;
+
+	if (tb[MTK_VENDOR_ATTR_CSI_CTRL_CFG]) {
+		u8 mode = 0, type = 0, v1 = 0;
+		u32 v2 = 0;
+		u8 mac_addr[ETH_ALEN] = {};
+		struct nlattr *cur;
+		int rem;
+
+		nla_for_each_nested(cur, tb[MTK_VENDOR_ATTR_CSI_CTRL_CFG], rem) {
+			switch (nla_type(cur)) {
+			case MTK_VENDOR_ATTR_CSI_CTRL_CFG_MODE:
+				mode = nla_get_u8(cur);
+				break;
+			case MTK_VENDOR_ATTR_CSI_CTRL_CFG_TYPE:
+				type = nla_get_u8(cur);
+				break;
+			case MTK_VENDOR_ATTR_CSI_CTRL_CFG_VAL1:
+				v1 = nla_get_u8(cur);
+				break;
+			case MTK_VENDOR_ATTR_CSI_CTRL_CFG_VAL2:
+				v2 = nla_get_u32(cur);
+				break;
+			default:
+				return -EINVAL;
+			};
+		}
+
+		if (tb[MTK_VENDOR_ATTR_CSI_CTRL_MAC_ADDR]) {
+			u8 idx = 0;
+
+			nla_for_each_nested(cur, tb[MTK_VENDOR_ATTR_CSI_CTRL_MAC_ADDR], rem) {
+				mac_addr[idx++] = nla_get_u8(cur);
+			}
+		}
+
+		err = mt7996_mcu_set_csi(phy, mode, type, v1, v2, mac_addr);
+		if (err < 0)
+			return err;
+
+		spin_lock_bh(&phy->csi.lock);
+
+		phy->csi.enable = !!mode;
+
+		/* clean up old csi stats */
+		if ((mode == CSI_CONTROL_MODE_STOP || mode == CSI_CONTROL_MODE_SET)
+			&& !list_empty(&phy->csi.list)) {
+			struct csi_data *c, *tmp_c;
+
+			list_for_each_entry_safe(c, tmp_c, &phy->csi.list, node) {
+				list_del(&c->node);
+				kfree(c);
+				phy->csi.count--;
+			}
+		} else if (mode == CSI_CONTROL_MODE_START) {
+			phy->csi.last_record = 0;
+		}
+
+		spin_unlock_bh(&phy->csi.lock);
+
+		if (mode == CSI_CONTROL_MODE_SET && type == CSI_CONFIG_STA_FILTER && v1 == 2)
+			phy->csi.interval = v2;
+	}
+
+	return 0;
+
+error:
+	dev_err(dev->mt76.dev, "Invalid band idx: %d\n", band_idx);
+	return -EINVAL;
+}
+
+static int
+mt7996_vendor_csi_ctrl_dump(struct wiphy *wiphy, struct wireless_dev *wdev,
+			    struct sk_buff *skb, const void *data, int data_len,
+			    unsigned long *storage)
+{
+#define RESERVED_SET	BIT(31)
+	struct ieee80211_hw *hw = wiphy_to_ieee80211_hw(wiphy);
+	struct mt7996_dev *dev = mt7996_hw_dev(hw);
+	struct mt7996_phy *phy;
+	struct mt76_phy *mphy;
+	struct nlattr *tb[NUM_MTK_VENDOR_ATTRS_CSI_CTRL] = {0};
+	u8 band_idx = 0;
+	int err = 0;
+
+	if (*storage & RESERVED_SET) {
+		if ((*storage & GENMASK(15, 0)) == 0)
+			return -ENOENT;
+		(*storage)--;
+	}
+
+	if (data) {
+		err = nla_parse(tb, MTK_VENDOR_ATTR_CSI_CTRL_MAX, data, data_len,
+				csi_ctrl_policy, NULL);
+		if (err)
+			return err;
+	}
+
+	if (tb[MTK_VENDOR_ATTR_CSI_CTRL_BAND_IDX])
+		band_idx = nla_get_u8(tb[MTK_VENDOR_ATTR_CSI_CTRL_BAND_IDX]);
+
+	if (!mt7996_band_valid(dev, band_idx))
+		return -EINVAL;
+
+	mphy = dev->mt76.phys[band_idx];
+	if (!mphy)
+		return -EINVAL;
+
+	phy = (struct mt7996_phy *)mphy->priv;
+	if (!phy)
+		return -EINVAL;
+
+	if (!(*storage & RESERVED_SET) && tb[MTK_VENDOR_ATTR_CSI_CTRL_DUMP_NUM]) {
+		*storage = nla_get_u16(tb[MTK_VENDOR_ATTR_CSI_CTRL_DUMP_NUM]);
+		*storage |= RESERVED_SET;
+	}
+
+	spin_lock_bh(&phy->csi.lock);
+
+	if (!list_empty(&phy->csi.list)) {
+		struct csi_data *csi;
+		void *a, *b;
+		int i;
+
+		csi = list_first_entry(&phy->csi.list, struct csi_data, node);
+
+		a = nla_nest_start(skb, MTK_VENDOR_ATTR_CSI_CTRL_DATA);
+		if (!a)
+			goto out;
+
+		if (nla_put_u8(skb, MTK_VENDOR_ATTR_CSI_DATA_VER, 1) ||
+		    nla_put_u8(skb, MTK_VENDOR_ATTR_CSI_DATA_RSSI, csi->rssi) ||
+		    nla_put_u8(skb, MTK_VENDOR_ATTR_CSI_DATA_SNR, csi->snr) ||
+		    nla_put_u8(skb, MTK_VENDOR_ATTR_CSI_DATA_BW, csi->data_bw) ||
+		    nla_put_u8(skb, MTK_VENDOR_ATTR_CSI_DATA_CH_IDX, csi->pri_ch_idx) ||
+		    nla_put_u8(skb, MTK_VENDOR_ATTR_CSI_DATA_MODE, csi->rx_mode))
+			goto out;
+
+		if (nla_put_u16(skb, MTK_VENDOR_ATTR_CSI_DATA_TX_ANT, csi->tx_idx) ||
+		    nla_put_u16(skb, MTK_VENDOR_ATTR_CSI_DATA_RX_ANT, csi->rx_idx))
+			goto out;
+
+		if (nla_put_u32(skb, MTK_VENDOR_ATTR_CSI_DATA_INFO, csi->ext_info) ||
+		    nla_put_u32(skb, MTK_VENDOR_ATTR_CSI_DATA_CHAIN_INFO, csi->chain_info) ||
+		    nla_put_u32(skb, MTK_VENDOR_ATTR_CSI_DATA_TS, csi->ts))
+			goto out;
+
+		b = nla_nest_start(skb, MTK_VENDOR_ATTR_CSI_DATA_TA);
+		if (!b)
+			goto out;
+
+		for (i = 0; i < ARRAY_SIZE(csi->ta); i++)
+			if (nla_put_u8(skb, i, csi->ta[i]))
+				goto out;
+		nla_nest_end(skb, b);
+
+		if (nla_put_u32(skb, MTK_VENDOR_ATTR_CSI_DATA_NUM, csi->data_num))
+			goto out;
+
+		b = nla_nest_start(skb, MTK_VENDOR_ATTR_CSI_DATA_I);
+		if (!b)
+			goto out;
+
+		for (i = 0; i < csi->data_num; i++)
+			if (nla_put_u16(skb, i, csi->data_i[i]))
+				goto out;
+		nla_nest_end(skb, b);
+
+		b = nla_nest_start(skb, MTK_VENDOR_ATTR_CSI_DATA_Q);
+		if (!b)
+			goto out;
+
+		for (i = 0; i < csi->data_num; i++)
+			if (nla_put_u16(skb, i, csi->data_q[i]))
+				goto out;
+		nla_nest_end(skb, b);
+
+		nla_nest_end(skb, a);
+
+		list_del(&csi->node);
+		kfree(csi);
+		phy->csi.count--;
+
+		err = phy->csi.count;
+	}
+out:
+	spin_unlock_bh(&phy->csi.lock);
+
+	return err;
+}
+
+static const struct wiphy_vendor_command mt7996_vendor_commands[] = {
+	{
+		.info = {
+			.vendor_id = MTK_NL80211_VENDOR_ID,
+			.subcmd = MTK_NL80211_VENDOR_SUBCMD_MU_CTRL,
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_NETDEV |
+			 WIPHY_VENDOR_CMD_NEED_RUNNING,
+		.doit = mt7996_vendor_mu_ctrl,
+		.dumpit = mt7996_vendor_mu_ctrl_dump,
+		.policy = mu_ctrl_policy,
+		.maxattr = MTK_VENDOR_ATTR_MU_CTRL_MAX,
+	},
+	{
+		.info = {
+		        .vendor_id = MTK_NL80211_VENDOR_ID,
+		        .subcmd = MTK_NL80211_VENDOR_SUBCMD_WIRELESS_CTRL,
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_NETDEV |
+		        WIPHY_VENDOR_CMD_NEED_RUNNING,
+		.doit = mt7996_vendor_wireless_ctrl,
+		.dumpit = mt7996_vendor_wireless_ctrl_dump,
+		.policy = wireless_ctrl_policy,
+		.maxattr = MTK_VENDOR_ATTR_WIRELESS_CTRL_MAX,
+	},
+	{
+		.info = {
+			.vendor_id = MTK_NL80211_VENDOR_ID,
+			.subcmd = MTK_NL80211_VENDOR_SUBCMD_AMNT_CTRL,
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_NETDEV |
+			 WIPHY_VENDOR_CMD_NEED_RUNNING,
+		.doit = mt7966_vendor_amnt_ctrl,
+		.dumpit = mt7966_vendor_amnt_ctrl_dump,
+		.policy = amnt_ctrl_policy,
+		.maxattr = MTK_VENDOR_ATTR_AMNT_CTRL_MAX,
+	},
+	{
+		.info = {
+			.vendor_id = MTK_NL80211_VENDOR_ID,
+			.subcmd = MTK_NL80211_VENDOR_SUBCMD_BSS_COLOR_CTRL,
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_NETDEV |
+			WIPHY_VENDOR_CMD_NEED_RUNNING,
+		.dumpit = mt7996_vendor_bss_color_ctrl_dump,
+		.policy = bss_color_ctrl_policy,
+		.maxattr = MTK_VENDOR_ATTR_BSS_COLOR_CTRL_MAX,
+	},
+	{
+		.info = {
+			.vendor_id = MTK_NL80211_VENDOR_ID,
+			.subcmd = MTK_NL80211_VENDOR_SUBCMD_EDCCA_CTRL,
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_NETDEV |
+			 WIPHY_VENDOR_CMD_NEED_RUNNING,
+		.doit = mt7996_vendor_edcca_ctrl,
+		.dumpit = mt7996_vendor_edcca_ctrl_dump,
+		.policy = edcca_ctrl_policy,
+		.maxattr = MTK_VENDOR_ATTR_EDCCA_CTRL_MAX,
+	},
+	{
+		.info = {
+			.vendor_id = MTK_NL80211_VENDOR_ID,
+			.subcmd = MTK_NL80211_VENDOR_SUBCMD_3WIRE_CTRL,
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_NETDEV |
+			 WIPHY_VENDOR_CMD_NEED_RUNNING,
+		.doit = mt7996_vendor_3wire_ctrl,
+		.policy = three_wire_ctrl_policy,
+		.maxattr = MTK_VENDOR_ATTR_3WIRE_CTRL_MAX,
+	},
+	{
+		.info = {
+			.vendor_id = MTK_NL80211_VENDOR_ID,
+			.subcmd = MTK_NL80211_VENDOR_SUBCMD_IBF_CTRL,
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_NETDEV |
+			WIPHY_VENDOR_CMD_NEED_RUNNING,
+		.doit = mt7996_vendor_ibf_ctrl,
+		.dumpit = mt7996_vendor_ibf_ctrl_dump,
+		.policy = ibf_ctrl_policy,
+		.maxattr = MTK_VENDOR_ATTR_IBF_CTRL_MAX,
+	},
+	{
+		.info = {
+			.vendor_id = MTK_NL80211_VENDOR_ID,
+			.subcmd = MTK_NL80211_VENDOR_SUBCMD_PP_CTRL,
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_NETDEV |
+			WIPHY_VENDOR_CMD_NEED_RUNNING,
+		.doit = mt7996_vendor_pp_ctrl,
+		.policy = pp_ctrl_policy,
+		.maxattr = MTK_VENDOR_ATTR_PP_CTRL_MAX,
+	},
+	{
+		.info = {
+			.vendor_id = MTK_NL80211_VENDOR_ID,
+			.subcmd = MTK_NL80211_VENDOR_SUBCMD_RFEATURE_CTRL,
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_NETDEV |
+			WIPHY_VENDOR_CMD_NEED_RUNNING,
+		.doit = mt7996_vendor_rfeature_ctrl,
+		.policy = rfeature_ctrl_policy,
+		.maxattr = MTK_VENDOR_ATTR_RFEATURE_CTRL_MAX,
+	},
+	{
+		.info = {
+			.vendor_id = MTK_NL80211_VENDOR_ID,
+			.subcmd = MTK_NL80211_VENDOR_SUBCMD_BACKGROUND_RADAR_CTRL,
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_NETDEV |
+			WIPHY_VENDOR_CMD_NEED_RUNNING,
+		.doit = mt7996_vendor_background_radar_mode_ctrl,
+		.policy = background_radar_ctrl_policy,
+		.maxattr = MTK_VENDOR_ATTR_BACKGROUND_RADAR_CTRL_MAX,
+	},
+	{
+		.info = {
+			.vendor_id = MTK_NL80211_VENDOR_ID,
+			.subcmd = MTK_NL80211_VENDOR_SUBCMD_BEACON_CTRL,
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_NETDEV |
+			 WIPHY_VENDOR_CMD_NEED_RUNNING,
+		.doit = mt7996_vendor_beacon_ctrl,
+		.policy = beacon_ctrl_policy,
+		.maxattr = MTK_VENDOR_ATTR_BEACON_CTRL_MAX,
+	},
+	{
+		.info = {
+			.vendor_id = MTK_NL80211_VENDOR_ID,
+			.subcmd = MTK_NL80211_VENDOR_SUBCMD_CSI_CTRL,
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_NETDEV |
+			 WIPHY_VENDOR_CMD_NEED_RUNNING,
+		.doit = mt7996_vendor_csi_ctrl,
+		.dumpit = mt7996_vendor_csi_ctrl_dump,
+		.policy = csi_ctrl_policy,
+		.maxattr = MTK_VENDOR_ATTR_CSI_CTRL_MAX,
+	},
+};
+
+void mt7996_vendor_register(struct mt7996_phy *phy)
+{
+	phy->mt76->hw->wiphy->vendor_commands = mt7996_vendor_commands;
+	phy->mt76->hw->wiphy->n_vendor_commands = ARRAY_SIZE(mt7996_vendor_commands);
+
+	INIT_LIST_HEAD(&phy->csi.list);
+	spin_lock_init(&phy->csi.lock);
+
+	spin_lock_init(&phy->amnt_lock);
+}
+#endif
diff --git a/mt7996/vendor.h b/mt7996/vendor.h
new file mode 100644
index 00000000..834b3d08
--- /dev/null
+++ b/mt7996/vendor.h
@@ -0,0 +1,297 @@
+#ifndef __MT7996_VENDOR_H
+#define __MT7996_VENDOR_H
+
+#define MTK_NL80211_VENDOR_ID	0x0ce7
+
+#ifdef CONFIG_MTK_VENDOR
+
+enum mtk_nl80211_vendor_subcmds {
+	MTK_NL80211_VENDOR_SUBCMD_AMNT_CTRL = 0xae,
+	MTK_NL80211_VENDOR_SUBCMD_CSI_CTRL = 0xc2,
+	MTK_NL80211_VENDOR_SUBCMD_RFEATURE_CTRL = 0xc3,
+	MTK_NL80211_VENDOR_SUBCMD_WIRELESS_CTRL = 0xc4,
+	MTK_NL80211_VENDOR_SUBCMD_MU_CTRL = 0xc5,
+	MTK_NL80211_VENDOR_SUBCMD_EDCCA_CTRL = 0xc7,
+	MTK_NL80211_VENDOR_SUBCMD_3WIRE_CTRL = 0xc8,
+	MTK_NL80211_VENDOR_SUBCMD_IBF_CTRL = 0xc9,
+	MTK_NL80211_VENDOR_SUBCMD_BSS_COLOR_CTRL = 0xca,
+	MTK_NL80211_VENDOR_SUBCMD_BACKGROUND_RADAR_CTRL = 0xcb,
+	MTK_NL80211_VENDOR_SUBCMD_PP_CTRL = 0xcc,
+	MTK_NL80211_VENDOR_SUBCMD_BEACON_CTRL = 0xcd,
+};
+
+enum mtk_vendor_attr_edcca_ctrl {
+	MTK_VENDOR_ATTR_EDCCA_THRESHOLD_INVALID = 0,
+
+	MTK_VENDOR_ATTR_EDCCA_CTRL_MODE,
+	MTK_VENDOR_ATTR_EDCCA_CTRL_PRI20_VAL,
+	MTK_VENDOR_ATTR_EDCCA_CTRL_SEC20_VAL,
+	MTK_VENDOR_ATTR_EDCCA_CTRL_SEC40_VAL,
+	MTK_VENDOR_ATTR_EDCCA_CTRL_SEC80_VAL,
+	MTK_VENDOR_ATTR_EDCCA_CTRL_COMPENSATE,
+	MTK_VENDOR_ATTR_EDCCA_CTRL_SEC160_VAL,
+
+	/* keep last */
+	NUM_MTK_VENDOR_ATTRS_EDCCA_CTRL,
+	MTK_VENDOR_ATTR_EDCCA_CTRL_MAX =
+		NUM_MTK_VENDOR_ATTRS_EDCCA_CTRL - 1
+};
+
+enum mtk_vendor_attr_edcca_dump {
+	MTK_VENDOR_ATTR_EDCCA_DUMP_UNSPEC = 0,
+
+	MTK_VENDOR_ATTR_EDCCA_DUMP_MODE,
+	MTK_VENDOR_ATTR_EDCCA_DUMP_PRI20_VAL,
+	MTK_VENDOR_ATTR_EDCCA_DUMP_SEC40_VAL,
+	MTK_VENDOR_ATTR_EDCCA_DUMP_SEC80_VAL,
+	MTK_VENDOR_ATTR_EDCCA_DUMP_SEC160_VAL,
+
+	/* keep last */
+	NUM_MTK_VENDOR_ATTRS_EDCCA_DUMP,
+	MTK_VENDOR_ATTR_EDCCA_DUMP_MAX =
+		NUM_MTK_VENDOR_ATTRS_EDCCA_DUMP - 1
+};
+
+enum mtk_vendor_attr_3wire_ctrl {
+	MTK_VENDOR_ATTR_3WIRE_CTRL_UNSPEC,
+
+	MTK_VENDOR_ATTR_3WIRE_CTRL_MODE,
+
+	/* keep last */
+	NUM_MTK_VENDOR_ATTRS_3WIRE_CTRL,
+	MTK_VENDOR_ATTR_3WIRE_CTRL_MAX =
+		NUM_MTK_VENDOR_ATTRS_3WIRE_CTRL - 1
+};
+
+enum mtk_vendor_attr_mu_ctrl {
+	MTK_VENDOR_ATTR_MU_CTRL_UNSPEC,
+
+	MTK_VENDOR_ATTR_MU_CTRL_ONOFF,
+	MTK_VENDOR_ATTR_MU_CTRL_DUMP,
+	MTK_VENDOR_ATTR_MU_CTRL_STRUCT,
+	MTK_VENDOR_ATTR_MU_CTRL_BAND_IDX,
+
+	/* keep last */
+	NUM_MTK_VENDOR_ATTRS_MU_CTRL,
+	MTK_VENDOR_ATTR_MU_CTRL_MAX =
+		NUM_MTK_VENDOR_ATTRS_MU_CTRL - 1
+};
+
+enum mtk_capi_control_changed {
+	CAPI_RFEATURE_CHANGED = BIT(16),
+	CAPI_WIRELESS_CHANGED = BIT(17),
+};
+
+enum mtk_vendor_attr_rfeature_ctrl {
+	MTK_VENDOR_ATTR_RFEATURE_CTRL_UNSPEC,
+
+	MTK_VENDOR_ATTR_RFEATURE_CTRL_HE_GI,
+	MTK_VENDOR_ATTR_RFEATURE_CTRL_HE_LTF,
+	MTK_VENDOR_ATTR_RFEATURE_CTRL_TRIG_TYPE_CFG,
+	MTK_VENDOR_ATTR_RFEATURE_CTRL_TRIG_TYPE_EN,
+	MTK_VENDOR_ATTR_RFEATURE_CTRL_TRIG_TYPE,
+	MTK_VENDOR_ATTR_RFEATURE_CTRL_ACK_PLCY,
+	MTK_VENDOR_ATTR_RFEATURE_CTRL_TRIG_TXBF,
+
+	/* keep last */
+	NUM_MTK_VENDOR_ATTRS_RFEATURE_CTRL,
+	MTK_VENDOR_ATTR_RFEATURE_CTRL_MAX =
+	NUM_MTK_VENDOR_ATTRS_RFEATURE_CTRL - 1
+};
+
+enum mtk_vendor_attr_wireless_ctrl {
+	MTK_VENDOR_ATTR_WIRELESS_CTRL_UNSPEC,
+
+	MTK_VENDOR_ATTR_WIRELESS_CTRL_FIXED_MCS,
+	MTK_VENDOR_ATTR_WIRELESS_CTRL_OFDMA,
+	MTK_VENDOR_ATTR_WIRELESS_CTRL_PPDU_TX_TYPE,
+	MTK_VENDOR_ATTR_WIRELESS_CTRL_NUSERS_OFDMA,
+	MTK_VENDOR_ATTR_WIRELESS_CTRL_BA_BUFFER_SIZE,
+	MTK_VENDOR_ATTR_WIRELESS_CTRL_MIMO,
+	MTK_VENDOR_ATTR_WIRELESS_CTRL_AMSDU,
+	MTK_VENDOR_ATTR_WIRELESS_CTRL_AMPDU,
+	MTK_VENDOR_ATTR_WIRELESS_CTRL_CERT = 9,
+	MTK_VENDOR_ATTR_WIRELESS_CTRL_RTS_SIGTA,
+	MTK_VENDOR_ATTR_WIRELESS_CTRL_MU_EDCA, /* reserve */
+
+	/* keep last */
+	NUM_MTK_VENDOR_ATTRS_WIRELESS_CTRL,
+	MTK_VENDOR_ATTR_WIRELESS_CTRL_MAX =
+		NUM_MTK_VENDOR_ATTRS_WIRELESS_CTRL - 1
+};
+
+enum mtk_vendor_attr_wireless_dump {
+	MTK_VENDOR_ATTR_WIRELESS_DUMP_UNSPEC,
+
+	MTK_VENDOR_ATTR_WIRELESS_DUMP_AMSDU,
+
+	/* keep last */
+	NUM_MTK_VENDOR_ATTRS_WIRELESS_DUMP,
+	MTK_VENDOR_ATTR_WIRELESS_DUMP_MAX =
+		NUM_MTK_VENDOR_ATTRS_WIRELESS_DUMP - 1
+};
+
+enum mtk_vendor_attr_background_radar_ctrl {
+	MTK_VENDOR_ATTR_BACKGROUND_RADAR_CTRL_UNSPEC,
+
+	MTK_VENDOR_ATTR_BACKGROUND_RADAR_CTRL_MODE,
+
+	/* keep last */
+	NUM_MTK_VENDOR_ATTRS_BACKGROUND_RADAR_CTRL,
+	MTK_VENDOR_ATTR_BACKGROUND_RADAR_CTRL_MAX =
+		NUM_MTK_VENDOR_ATTRS_BACKGROUND_RADAR_CTRL - 1
+};
+
+enum bw_sig {
+	BW_SIGNALING_DISABLE,
+	BW_SIGNALING_STATIC,
+	BW_SIGNALING_DYNAMIC
+};
+
+enum mtk_vendor_attr_mnt_ctrl {
+	MTK_VENDOR_ATTR_AMNT_CTRL_UNSPEC,
+
+	MTK_VENDOR_ATTR_AMNT_CTRL_SET,
+	MTK_VENDOR_ATTR_AMNT_CTRL_DUMP,
+
+	/* keep last */
+	NUM_MTK_VENDOR_ATTRS_AMNT_CTRL,
+	MTK_VENDOR_ATTR_AMNT_CTRL_MAX =
+		NUM_MTK_VENDOR_ATTRS_AMNT_CTRL - 1
+};
+
+enum mtk_vendor_attr_mnt_set {
+	MTK_VENDOR_ATTR_AMNT_SET_UNSPEC,
+
+	MTK_VENDOR_ATTR_AMNT_SET_INDEX,
+	MTK_VENDOR_ATTR_AMNT_SET_MACADDR,
+
+	/* keep last */
+	NUM_MTK_VENDOR_ATTRS_AMNT_SET,
+	MTK_VENDOR_ATTR_AMNT_SET_MAX =
+		NUM_MTK_VENDOR_ATTRS_AMNT_SET - 1
+};
+
+enum mtk_vendor_attr_mnt_dump {
+	MTK_VENDOR_ATTR_AMNT_DUMP_UNSPEC,
+
+	MTK_VENDOR_ATTR_AMNT_DUMP_INDEX,
+	MTK_VENDOR_ATTR_AMNT_DUMP_LEN,
+	MTK_VENDOR_ATTR_AMNT_DUMP_RESULT,
+
+	/* keep last */
+	NUM_MTK_VENDOR_ATTRS_AMNT_DUMP,
+	MTK_VENDOR_ATTR_AMNT_DUMP_MAX =
+		NUM_MTK_VENDOR_ATTRS_AMNT_DUMP - 1
+};
+
+enum mtk_vendor_attr_bss_color_ctrl {
+	MTK_VENDOR_ATTR_BSS_COLOR_CTRL_UNSPEC,
+
+	MTK_VENDOR_ATTR_AVAL_BSS_COLOR_BMP,
+
+	/* keep last */
+	NUM_MTK_VENDOR_ATTRS_BSS_COLOR_CTRL,
+	MTK_VENDOR_ATTR_BSS_COLOR_CTRL_MAX =
+		NUM_MTK_VENDOR_ATTRS_BSS_COLOR_CTRL - 1
+};
+
+enum mtk_vendor_attr_ibf_ctrl {
+	MTK_VENDOR_ATTR_IBF_CTRL_UNSPEC,
+
+	MTK_VENDOR_ATTR_IBF_CTRL_ENABLE,
+
+	/* keep last */
+	NUM_MTK_VENDOR_ATTRS_IBF_CTRL,
+	MTK_VENDOR_ATTR_IBF_CTRL_MAX =
+		NUM_MTK_VENDOR_ATTRS_IBF_CTRL - 1
+};
+
+enum mtk_vendor_attr_ibf_dump {
+	MTK_VENDOR_ATTR_IBF_DUMP_UNSPEC,
+
+	MTK_VENDOR_ATTR_IBF_DUMP_ENABLE,
+
+	/* keep last */
+	NUM_MTK_VENDOR_ATTRS_IBF_DUMP,
+	MTK_VENDOR_ATTR_IBF_DUMP_MAX =
+		NUM_MTK_VENDOR_ATTRS_IBF_DUMP - 1
+};
+
+enum mtk_vendor_attr_pp_ctrl {
+	MTK_VENDOR_ATTR_PP_CTRL_UNSPEC,
+
+	MTK_VENDOR_ATTR_PP_MODE,
+	MTK_VENDOR_ATTR_PP_BAND_IDX,
+
+	/* keep last */
+	NUM_MTK_VENDOR_ATTRS_PP_CTRL,
+	MTK_VENDOR_ATTR_PP_CTRL_MAX =
+		NUM_MTK_VENDOR_ATTRS_PP_CTRL - 1
+};
+
+enum mtk_vendor_attr_beacon_ctrl {
+	MTK_VENDOR_ATTR_BEACON_CTRL_UNSPEC,
+
+	MTK_VENDOR_ATTR_BEACON_CTRL_MODE,
+
+	/* keep last */
+	NUM_MTK_VENDOR_ATTRS_BEACON_CTRL,
+	MTK_VENDOR_ATTR_BEACON_CTRL_MAX =
+		NUM_MTK_VENDOR_ATTRS_BEACON_CTRL - 1
+};
+
+enum mtk_vendor_attr_csi_ctrl {
+	MTK_VENDOR_ATTR_CSI_CTRL_UNSPEC,
+
+	MTK_VENDOR_ATTR_CSI_CTRL_CFG,
+	MTK_VENDOR_ATTR_CSI_CTRL_CFG_MODE,
+	MTK_VENDOR_ATTR_CSI_CTRL_CFG_TYPE,
+	MTK_VENDOR_ATTR_CSI_CTRL_CFG_VAL1,
+	MTK_VENDOR_ATTR_CSI_CTRL_CFG_VAL2,
+	MTK_VENDOR_ATTR_CSI_CTRL_MAC_ADDR,
+
+	MTK_VENDOR_ATTR_CSI_CTRL_DUMP_NUM,
+
+	MTK_VENDOR_ATTR_CSI_CTRL_DATA,
+
+	MTK_VENDOR_ATTR_CSI_CTRL_BAND_IDX,
+
+	/* keep last */
+	NUM_MTK_VENDOR_ATTRS_CSI_CTRL,
+	MTK_VENDOR_ATTR_CSI_CTRL_MAX =
+		NUM_MTK_VENDOR_ATTRS_CSI_CTRL - 1
+};
+
+enum mtk_vendor_attr_csi_data {
+	MTK_VENDOR_ATTR_CSI_DATA_UNSPEC,
+	MTK_VENDOR_ATTR_CSI_DATA_PAD,
+
+	MTK_VENDOR_ATTR_CSI_DATA_VER,
+	MTK_VENDOR_ATTR_CSI_DATA_TS,
+	MTK_VENDOR_ATTR_CSI_DATA_RSSI,
+	MTK_VENDOR_ATTR_CSI_DATA_SNR,
+	MTK_VENDOR_ATTR_CSI_DATA_BW,
+	MTK_VENDOR_ATTR_CSI_DATA_CH_IDX,
+	MTK_VENDOR_ATTR_CSI_DATA_TA,
+	MTK_VENDOR_ATTR_CSI_DATA_NUM,
+	MTK_VENDOR_ATTR_CSI_DATA_I,
+	MTK_VENDOR_ATTR_CSI_DATA_Q,
+	MTK_VENDOR_ATTR_CSI_DATA_INFO,
+	MTK_VENDOR_ATTR_CSI_DATA_RSVD1,
+	MTK_VENDOR_ATTR_CSI_DATA_RSVD2,
+	MTK_VENDOR_ATTR_CSI_DATA_RSVD3,
+	MTK_VENDOR_ATTR_CSI_DATA_RSVD4,
+	MTK_VENDOR_ATTR_CSI_DATA_TX_ANT,
+	MTK_VENDOR_ATTR_CSI_DATA_RX_ANT,
+	MTK_VENDOR_ATTR_CSI_DATA_MODE,
+	MTK_VENDOR_ATTR_CSI_DATA_CHAIN_INFO,
+
+	/* keep last */
+	NUM_MTK_VENDOR_ATTRS_CSI_DATA,
+	MTK_VENDOR_ATTR_CSI_DATA_MAX =
+		NUM_MTK_VENDOR_ATTRS_CSI_DATA - 1
+};
+#endif
+
+#endif
diff --git a/testmode.c b/testmode.c
index ca4feccf..8192b98b 100644
--- a/testmode.c
+++ b/testmode.c
@@ -2,11 +2,13 @@
 /* Copyright (C) 2020 Felix Fietkau <nbd@nbd.name> */
 
 #include <linux/random.h>
+#include "mt76_connac.h"
 #include "mt76.h"
 
 const struct nla_policy mt76_tm_policy[NUM_MT76_TM_ATTRS] = {
 	[MT76_TM_ATTR_RESET] = { .type = NLA_FLAG },
 	[MT76_TM_ATTR_STATE] = { .type = NLA_U8 },
+	[MT76_TM_ATTR_SKU_EN] = { .type = NLA_U8 },
 	[MT76_TM_ATTR_TX_COUNT] = { .type = NLA_U32 },
 	[MT76_TM_ATTR_TX_LENGTH] = { .type = NLA_U32 },
 	[MT76_TM_ATTR_TX_RATE_MODE] = { .type = NLA_U8 },
@@ -25,9 +27,21 @@ const struct nla_policy mt76_tm_policy[NUM_MT76_TM_ATTRS] = {
 	[MT76_TM_ATTR_TX_TIME] = { .type = NLA_U32 },
 	[MT76_TM_ATTR_FREQ_OFFSET] = { .type = NLA_U32 },
 	[MT76_TM_ATTR_DRV_DATA] = { .type = NLA_NESTED },
+	[MT76_TM_ATTR_OFF_CH_SCAN_CH] = { .type = NLA_U8 },
+	[MT76_TM_ATTR_OFF_CH_SCAN_CENTER_CH] = { .type = NLA_U8 },
+	[MT76_TM_ATTR_OFF_CH_SCAN_BW] = { .type = NLA_U8 },
+	[MT76_TM_ATTR_OFF_CH_SCAN_PATH] = { .type = NLA_U8 },
+	[MT76_TM_ATTR_IPI_THRESHOLD] = { .type = NLA_U8 },
+	[MT76_TM_ATTR_IPI_PERIOD] = { .type = NLA_U32 },
+	[MT76_TM_ATTR_IPI_RESET] = { .type = NLA_U8 },
 };
 EXPORT_SYMBOL_GPL(mt76_tm_policy);
 
+static inline bool mt76_testmode_offload(struct mt76_dev *dev)
+{
+	return is_mt7996(dev) || is_mt7992(dev);
+}
+
 void mt76_testmode_tx_pending(struct mt76_phy *phy)
 {
 	struct mt76_testmode_data *td = &phy->test;
@@ -82,6 +96,11 @@ mt76_testmode_max_mpdu_len(struct mt76_phy *phy, u8 tx_rate_mode)
 		    IEEE80211_VHT_CAP_MAX_MPDU_LENGTH_7991)
 			return IEEE80211_MAX_MPDU_LEN_VHT_7991;
 		return IEEE80211_MAX_MPDU_LEN_VHT_11454;
+	case MT76_TM_TX_MODE_EHT_SU:
+	case MT76_TM_TX_MODE_EHT_TRIG:
+	case MT76_TM_TX_MODE_EHT_MU:
+		/* TODO: check the limit */
+		return UINT_MAX;
 	case MT76_TM_TX_MODE_CCK:
 	case MT76_TM_TX_MODE_OFDM:
 	default:
@@ -174,6 +193,114 @@ int mt76_testmode_alloc_skb(struct mt76_phy *phy, u32 len)
 }
 EXPORT_SYMBOL(mt76_testmode_alloc_skb);
 
+static int
+mt76_testmode_tx_config_check(struct mt76_phy *phy)
+{
+	struct mt76_dev *dev = phy->dev;
+	struct mt76_testmode_data *td = &phy->test;
+	struct cfg80211_chan_def *chandef = &phy->chandef;
+	u8 max_nss = hweight8(phy->antenna_mask);
+	enum invalid_type {
+		INVALID_TYPE_TX_LEN,
+		INVALID_TYPE_RATE_MODE,
+		INVALID_TYPE_RATE_IDX,
+		INVALID_TYPE_RATE_NSS,
+		INVALID_TYPE_LDPC,
+	} type;
+	static const char * const invalid_msg[] = {
+		[INVALID_TYPE_TX_LEN] = "tx length",
+		[INVALID_TYPE_RATE_MODE] = "tx rate mode",
+		[INVALID_TYPE_RATE_IDX] = "tx rate idx",
+		[INVALID_TYPE_RATE_NSS] = "tx rate nss",
+		[INVALID_TYPE_LDPC] = "tx rate ldpc",
+	};
+	u32 max_tx_len;
+
+	max_tx_len = mt76_testmode_max_mpdu_len(phy, td->tx_rate_mode);
+	if (max_tx_len < td->tx_mpdu_len ||
+	    sizeof(struct ieee80211_hdr) > td->tx_mpdu_len) {
+		type = INVALID_TYPE_TX_LEN;
+		goto fail;
+	}
+
+	if (td->tx_antenna_mask)
+		max_nss = min_t(u8, max_nss, hweight8(td->tx_antenna_mask));
+
+	switch (td->tx_rate_mode) {
+	case MT76_TM_TX_MODE_CCK:
+		if (chandef->chan->band != NL80211_BAND_2GHZ) {
+			type = INVALID_TYPE_RATE_MODE;
+			goto fail;
+		}
+		if (td->tx_rate_idx > 3) {
+			type = INVALID_TYPE_RATE_IDX;
+			goto fail;
+		}
+		break;
+	case MT76_TM_TX_MODE_OFDM:
+		if (td->tx_rate_idx > 7) {
+			type = INVALID_TYPE_RATE_IDX;
+			goto fail;
+		}
+		break;
+	case MT76_TM_TX_MODE_HT:
+		if (td->tx_rate_idx > 8 * max_nss - 1) {
+			type = INVALID_TYPE_RATE_IDX;
+			goto fail;
+		}
+		break;
+	case MT76_TM_TX_MODE_VHT:
+		if (td->tx_rate_nss > max_nss) {
+			type = INVALID_TYPE_RATE_IDX;
+			goto fail;
+		}
+		if (td->tx_rate_idx > 9) {
+			type = INVALID_TYPE_RATE_IDX;
+			goto fail;
+		}
+		break;
+	case MT76_TM_TX_MODE_HE_SU:
+	case MT76_TM_TX_MODE_HE_EXT_SU:
+	case MT76_TM_TX_MODE_HE_TB:
+	case MT76_TM_TX_MODE_HE_MU:
+		if (td->tx_rate_nss > max_nss) {
+			type = INVALID_TYPE_RATE_IDX;
+			goto fail;
+		}
+		if (td->tx_rate_idx > 11) {
+			type = INVALID_TYPE_RATE_IDX;
+			goto fail;
+		}
+		if (chandef->width > NL80211_CHAN_WIDTH_20 &&
+		    !td->tx_rate_ldpc) {
+			type = INVALID_TYPE_LDPC;
+			goto fail;
+		}
+		break;
+	case MT76_TM_TX_MODE_EHT_SU:
+	case MT76_TM_TX_MODE_EHT_TRIG:
+	case MT76_TM_TX_MODE_EHT_MU:
+		if (td->tx_rate_idx > 15) {
+			type = INVALID_TYPE_RATE_IDX;
+			goto fail;
+		}
+		if (chandef->width > NL80211_CHAN_WIDTH_20 &&
+		    !td->tx_rate_ldpc) {
+			type = INVALID_TYPE_LDPC;
+			goto fail;
+		}
+		break;
+	default:
+		type = INVALID_TYPE_RATE_MODE;
+		goto fail;
+	}
+
+	return 0;
+fail:
+	dev_err(dev->dev, "Invalid %s\n", invalid_msg[type]);
+	return -EINVAL;
+}
+
 static int
 mt76_testmode_tx_init(struct mt76_phy *phy)
 {
@@ -183,6 +310,13 @@ mt76_testmode_tx_init(struct mt76_phy *phy)
 	u8 max_nss = hweight8(phy->antenna_mask);
 	int ret;
 
+	ret = mt76_testmode_tx_config_check(phy);
+	if (ret)
+		return ret;
+
+	if (mt76_testmode_offload(phy->dev))
+		return 0;
+
 	ret = mt76_testmode_alloc_skb(phy, td->tx_mpdu_len);
 	if (ret)
 		return ret;
@@ -200,36 +334,17 @@ mt76_testmode_tx_init(struct mt76_phy *phy)
 
 	switch (td->tx_rate_mode) {
 	case MT76_TM_TX_MODE_CCK:
-		if (phy->chandef.chan->band != NL80211_BAND_2GHZ)
-			return -EINVAL;
-
-		if (rate->idx > 4)
-			return -EINVAL;
 		break;
 	case MT76_TM_TX_MODE_OFDM:
 		if (phy->chandef.chan->band != NL80211_BAND_2GHZ)
 			break;
 
-		if (rate->idx > 8)
-			return -EINVAL;
-
 		rate->idx += 4;
 		break;
 	case MT76_TM_TX_MODE_HT:
-		if (rate->idx > 8 * max_nss &&
-			!(rate->idx == 32 &&
-			  phy->chandef.width >= NL80211_CHAN_WIDTH_40))
-			return -EINVAL;
-
 		rate->flags |= IEEE80211_TX_RC_MCS;
 		break;
 	case MT76_TM_TX_MODE_VHT:
-		if (rate->idx > 9)
-			return -EINVAL;
-
-		if (td->tx_rate_nss > max_nss)
-			return -EINVAL;
-
 		ieee80211_rate_set_vht(rate, td->tx_rate_idx, td->tx_rate_nss);
 		rate->flags |= IEEE80211_TX_RC_VHT_MCS;
 		break;
@@ -275,7 +390,9 @@ mt76_testmode_tx_start(struct mt76_phy *phy)
 	td->tx_queued = 0;
 	td->tx_done = 0;
 	td->tx_pending = td->tx_count;
-	mt76_worker_schedule(&dev->tx_worker);
+
+	if (!mt76_testmode_offload(dev))
+		mt76_worker_schedule(&dev->tx_worker);
 }
 
 static void
@@ -284,6 +401,11 @@ mt76_testmode_tx_stop(struct mt76_phy *phy)
 	struct mt76_testmode_data *td = &phy->test;
 	struct mt76_dev *dev = phy->dev;
 
+	if (mt76_testmode_offload(dev) && dev->test_ops->tx_stop) {
+		dev->test_ops->tx_stop(phy);
+		return;
+	}
+
 	mt76_worker_disable(&dev->tx_worker);
 
 	td->tx_pending = 0;
@@ -296,22 +418,11 @@ mt76_testmode_tx_stop(struct mt76_phy *phy)
 	mt76_testmode_free_skb(phy);
 }
 
-static inline void
-mt76_testmode_param_set(struct mt76_testmode_data *td, u16 idx)
-{
-	td->param_set[idx / 32] |= BIT(idx % 32);
-}
-
-static inline bool
-mt76_testmode_param_present(struct mt76_testmode_data *td, u16 idx)
-{
-	return td->param_set[idx / 32] & BIT(idx % 32);
-}
-
 static void
 mt76_testmode_init_defaults(struct mt76_phy *phy)
 {
 	struct mt76_testmode_data *td = &phy->test;
+	u8 addr[ETH_ALEN] = {phy->band_idx, 0x11, 0x22, 0xaa, 0xbb, 0xcc};
 
 	if (td->tx_mpdu_len > 0)
 		return;
@@ -319,11 +430,18 @@ mt76_testmode_init_defaults(struct mt76_phy *phy)
 	td->tx_mpdu_len = 1024;
 	td->tx_count = 1;
 	td->tx_rate_mode = MT76_TM_TX_MODE_OFDM;
+	td->tx_rate_idx = 7;
 	td->tx_rate_nss = 1;
+	/* 0xffff for OFDMA no puncture */
+	td->tx_preamble_puncture = ~(td->tx_preamble_puncture & 0);
+	td->tx_ipg = 50;
+
+	/* rx stat user config */
+	td->aid = 1;
 
-	memcpy(td->addr[0], phy->macaddr, ETH_ALEN);
-	memcpy(td->addr[1], phy->macaddr, ETH_ALEN);
-	memcpy(td->addr[2], phy->macaddr, ETH_ALEN);
+	memcpy(td->addr[0], addr, ETH_ALEN);
+	memcpy(td->addr[1], addr, ETH_ALEN);
+	memcpy(td->addr[2], addr, ETH_ALEN);
 }
 
 static int
@@ -353,7 +471,7 @@ __mt76_testmode_set_state(struct mt76_phy *phy, enum mt76_testmode_state state)
 	if (state == MT76_TM_STATE_TX_FRAMES)
 		mt76_testmode_tx_start(phy);
 	else if (state == MT76_TM_STATE_RX_FRAMES) {
-		memset(&phy->test.rx_stats, 0, sizeof(phy->test.rx_stats));
+		dev->test_ops->reset_rx_stats(phy);
 	}
 
 	phy->test.state = state;
@@ -404,6 +522,82 @@ mt76_tm_get_u8(struct nlattr *attr, u8 *dest, u8 min, u8 max)
 	return 0;
 }
 
+static int
+mt76_testmode_set_eeprom(struct mt76_phy *phy, struct nlattr **tb)
+{
+	struct mt76_dev *dev = phy->dev;
+	u8 action, val[MT76_TM_EEPROM_BLOCK_SIZE];
+	u32 offset = 0;
+	int err = -EINVAL;
+
+	if (!dev->test_ops->set_eeprom)
+		return -EOPNOTSUPP;
+
+	if (mt76_tm_get_u8(tb[MT76_TM_ATTR_EEPROM_ACTION], &action,
+			   0, MT76_TM_EEPROM_ACTION_MAX))
+		goto out;
+
+	if (tb[MT76_TM_ATTR_EEPROM_OFFSET]) {
+		struct nlattr *cur;
+		int rem, idx = 0;
+
+		offset = nla_get_u32(tb[MT76_TM_ATTR_EEPROM_OFFSET]);
+		if (!!(offset % MT76_TM_EEPROM_BLOCK_SIZE) ||
+		    !tb[MT76_TM_ATTR_EEPROM_VAL])
+			goto out;
+
+		nla_for_each_nested(cur, tb[MT76_TM_ATTR_EEPROM_VAL], rem) {
+			if (nla_len(cur) != 1 || idx >= ARRAY_SIZE(val))
+				goto out;
+
+			val[idx++] = nla_get_u8(cur);
+		}
+	}
+
+	err = dev->test_ops->set_eeprom(phy, offset, val, action);
+
+out:
+	return err;
+}
+
+static int
+mt76_testmode_txbf_profile_update_all_cmd(struct mt76_phy *phy, struct nlattr **tb, u32 state)
+{
+#define PARAM_UNIT	5
+#define PARAM_UNIT_5X5	6
+	static u8 pfmu_idx;
+	struct mt76_testmode_data *td = &phy->test;
+	struct mt76_dev *dev = phy->dev;
+	struct nlattr *cur;
+	u16 tmp_val[PARAM_UNIT_5X5], *val = td->txbf_param;
+	int idx, rem, ret, i = 0;
+	int param_len = hweight16(phy->chainmask) == 5 ? PARAM_UNIT_5X5 : PARAM_UNIT;
+
+	memset(td->txbf_param, 0, sizeof(td->txbf_param));
+	nla_for_each_nested(cur, tb[MT76_TM_ATTR_TXBF_PARAM], rem) {
+		if (nla_len(cur) != 2)
+			return -EINVAL;
+		idx = i % param_len;
+		tmp_val[idx] = nla_get_u16(cur);
+		if (idx == 1 && (tmp_val[idx] == 0xf0 || tmp_val[idx] == 0xff)) {
+			pfmu_idx = tmp_val[0];
+			return 0;
+		}
+		if (idx == param_len - 1) {
+			val[0] = pfmu_idx;
+			memcpy(val + 1, tmp_val, param_len * sizeof(u16));
+			if (dev->test_ops->set_params) {
+				ret = dev->test_ops->set_params(phy, tb, state);
+				if (ret)
+					return ret;
+			}
+		}
+		i++;
+	}
+
+	return 0;
+}
+
 int mt76_testmode_cmd(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 		      void *data, int len)
 {
@@ -427,6 +621,11 @@ int mt76_testmode_cmd(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 
 	mutex_lock(&dev->mutex);
 
+	if (tb[MT76_TM_ATTR_EEPROM_ACTION]) {
+		err = mt76_testmode_set_eeprom(phy, tb);
+		goto out;
+	}
+
 	if (tb[MT76_TM_ATTR_RESET]) {
 		mt76_testmode_set_state(phy, MT76_TM_STATE_OFF);
 		memset(td, 0, sizeof(*td));
@@ -434,12 +633,18 @@ int mt76_testmode_cmd(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 
 	mt76_testmode_init_defaults(phy);
 
+	if (tb[MT76_TM_ATTR_SKU_EN])
+		td->sku_en = nla_get_u8(tb[MT76_TM_ATTR_SKU_EN]);
+
 	if (tb[MT76_TM_ATTR_TX_COUNT])
 		td->tx_count = nla_get_u32(tb[MT76_TM_ATTR_TX_COUNT]);
 
 	if (tb[MT76_TM_ATTR_TX_RATE_IDX])
 		td->tx_rate_idx = nla_get_u8(tb[MT76_TM_ATTR_TX_RATE_IDX]);
 
+	if (tb[MT76_TM_ATTR_IPI_PERIOD])
+		td->ipi_period = nla_get_u32(tb[MT76_TM_ATTR_IPI_PERIOD]);
+
 	if (mt76_tm_get_u8(tb[MT76_TM_ATTR_TX_RATE_MODE], &td->tx_rate_mode,
 			   0, MT76_TM_TX_MODE_MAX) ||
 	    mt76_tm_get_u8(tb[MT76_TM_ATTR_TX_RATE_NSS], &td->tx_rate_nss,
@@ -454,7 +659,15 @@ int mt76_testmode_cmd(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 	    mt76_tm_get_u8(tb[MT76_TM_ATTR_TX_DUTY_CYCLE],
 			   &td->tx_duty_cycle, 0, 99) ||
 	    mt76_tm_get_u8(tb[MT76_TM_ATTR_TX_POWER_CONTROL],
-			   &td->tx_power_control, 0, 1))
+			   &td->tx_power_control, 0, 1) ||
+	    mt76_tm_get_u8(tb[MT76_TM_ATTR_AID], &td->aid, 0, 16) ||
+	    mt76_tm_get_u8(tb[MT76_TM_ATTR_OFF_CH_SCAN_CH], &td->offchan_ch, 36, 196) ||
+	    mt76_tm_get_u8(tb[MT76_TM_ATTR_OFF_CH_SCAN_CENTER_CH], &td->offchan_center_ch,
+			   36, 196) ||
+	    mt76_tm_get_u8(tb[MT76_TM_ATTR_OFF_CH_SCAN_BW],
+			   &td->offchan_bw, NL80211_CHAN_WIDTH_20_NOHT, NL80211_CHAN_WIDTH_160) ||
+	    mt76_tm_get_u8(tb[MT76_TM_ATTR_IPI_THRESHOLD], &td->ipi_threshold, 0, 10) ||
+	    mt76_tm_get_u8(tb[MT76_TM_ATTR_IPI_RESET], &td->ipi_reset, 0, 1))
 		goto out;
 
 	if (tb[MT76_TM_ATTR_TX_LENGTH]) {
@@ -494,7 +707,9 @@ int mt76_testmode_cmd(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 			    idx >= ARRAY_SIZE(td->tx_power))
 				goto out;
 
-			td->tx_power[idx++] = nla_get_u8(cur);
+			err = mt76_tm_get_u8(cur, &td->tx_power[idx++], 0, 63);
+			if (err)
+				return err;
 		}
 	}
 
@@ -512,6 +727,46 @@ int mt76_testmode_cmd(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 		}
 	}
 
+	if (tb[MT76_TM_ATTR_CFG]) {
+		struct nlattr *cur;
+		int rem, idx = 0;
+
+		nla_for_each_nested(cur, tb[MT76_TM_ATTR_CFG], rem) {
+			if (nla_len(cur) != 1 || idx >= 2)
+				goto out;
+
+			if (idx == 0)
+				td->cfg.type = nla_get_u8(cur);
+			else
+				td->cfg.enable = nla_get_u8(cur);
+			idx++;
+		}
+	}
+
+	if (tb[MT76_TM_ATTR_TXBF_ACT]) {
+		struct nlattr *cur;
+		int rem, idx = 0;
+
+		if (!tb[MT76_TM_ATTR_TXBF_PARAM] ||
+		    mt76_tm_get_u8(tb[MT76_TM_ATTR_TXBF_ACT], &td->txbf_act,
+				   0, MT76_TM_TXBF_ACT_MAX))
+			goto out;
+
+		if (td->txbf_act == MT76_TM_TXBF_ACT_PROF_UPDATE_ALL_CMD) {
+			err = mt76_testmode_txbf_profile_update_all_cmd(phy, tb, state);
+			goto out;
+		}
+
+		memset(td->txbf_param, 0, sizeof(td->txbf_param));
+		nla_for_each_nested(cur, tb[MT76_TM_ATTR_TXBF_PARAM], rem) {
+			if (nla_len(cur) != 2 ||
+			    idx >= ARRAY_SIZE(td->txbf_param))
+				goto out;
+
+			td->txbf_param[idx++] = nla_get_u16(cur);
+		}
+	}
+
 	if (dev->test_ops->set_params) {
 		err = dev->test_ops->set_params(phy, tb, state);
 		if (err)
@@ -561,6 +816,9 @@ mt76_testmode_dump_stats(struct mt76_phy *phy, struct sk_buff *msg)
 	    nla_put_u64_64bit(msg, MT76_TM_STATS_ATTR_RX_PACKETS, rx_packets,
 			      MT76_TM_STATS_ATTR_PAD) ||
 	    nla_put_u64_64bit(msg, MT76_TM_STATS_ATTR_RX_FCS_ERROR, rx_fcs_error,
+			      MT76_TM_STATS_ATTR_PAD) ||
+	    nla_put_u64_64bit(msg, MT76_TM_STATS_ATTR_RX_LEN_MISMATCH,
+			      td->rx_stats.len_mismatch,
 			      MT76_TM_STATS_ATTR_PAD))
 		return -EMSGSIZE;
 
@@ -593,6 +851,18 @@ int mt76_testmode_dump(struct ieee80211_hw *hw, struct sk_buff *msg,
 
 	mutex_lock(&dev->mutex);
 
+	if (tb[MT76_TM_ATTR_PRECAL] || tb[MT76_TM_ATTR_PRECAL_INFO]) {
+		int flag, type;
+
+		err = -EINVAL;
+		flag = tb[MT76_TM_ATTR_PRECAL] ? 1 : 0;
+		type = flag ? nla_get_u8(tb[MT76_TM_ATTR_PRECAL_INFO]) : 0;
+		if (dev->test_ops->dump_precal)
+			err = dev->test_ops->dump_precal(phy, msg, flag, type);
+
+		goto out;
+	}
+
 	if (tb[MT76_TM_ATTR_STATS]) {
 		err = -EINVAL;
 
@@ -611,6 +881,9 @@ int mt76_testmode_dump(struct ieee80211_hw *hw, struct sk_buff *msg,
 	if (nla_put_u32(msg, MT76_TM_ATTR_STATE, td->state))
 		goto out;
 
+	if (nla_put_u8(msg, MT76_TM_ATTR_BAND_IDX, phy->band_idx))
+		goto out;
+
 	if (dev->test_mtd.name &&
 	    (nla_put_string(msg, MT76_TM_ATTR_MTD_PART, dev->test_mtd.name) ||
 	     nla_put_u32(msg, MT76_TM_ATTR_MTD_OFFSET, dev->test_mtd.offset)))
@@ -624,6 +897,11 @@ int mt76_testmode_dump(struct ieee80211_hw *hw, struct sk_buff *msg,
 	    nla_put_u8(msg, MT76_TM_ATTR_TX_RATE_SGI, td->tx_rate_sgi) ||
 	    nla_put_u8(msg, MT76_TM_ATTR_TX_RATE_LDPC, td->tx_rate_ldpc) ||
 	    nla_put_u8(msg, MT76_TM_ATTR_TX_RATE_STBC, td->tx_rate_stbc) ||
+	    nla_put_u8(msg, MT76_TM_ATTR_SKU_EN, td->sku_en) ||
+	    nla_put_u8(msg, MT76_TM_ATTR_AID, td->aid) ||
+	    nla_put_u8(msg, MT76_TM_ATTR_OFF_CH_SCAN_CH, td->offchan_ch) ||
+	    nla_put_u8(msg, MT76_TM_ATTR_OFF_CH_SCAN_CENTER_CH, td->offchan_center_ch) ||
+	    nla_put_u8(msg, MT76_TM_ATTR_OFF_CH_SCAN_BW, td->offchan_bw) ||
 	    (mt76_testmode_param_present(td, MT76_TM_ATTR_TX_LTF) &&
 	     nla_put_u8(msg, MT76_TM_ATTR_TX_LTF, td->tx_ltf)) ||
 	    (mt76_testmode_param_present(td, MT76_TM_ATTR_TX_ANTENNA) &&
@@ -639,7 +917,7 @@ int mt76_testmode_dump(struct ieee80211_hw *hw, struct sk_buff *msg,
 	    (mt76_testmode_param_present(td, MT76_TM_ATTR_TX_POWER_CONTROL) &&
 	     nla_put_u8(msg, MT76_TM_ATTR_TX_POWER_CONTROL, td->tx_power_control)) ||
 	    (mt76_testmode_param_present(td, MT76_TM_ATTR_FREQ_OFFSET) &&
-	     nla_put_u8(msg, MT76_TM_ATTR_FREQ_OFFSET, td->freq_offset)))
+	     nla_put_u32(msg, MT76_TM_ATTR_FREQ_OFFSET, td->freq_offset)))
 		goto out;
 
 	if (mt76_testmode_param_present(td, MT76_TM_ATTR_TX_POWER)) {
diff --git a/testmode.h b/testmode.h
index 1b0bcae8..794a74f9 100644
--- a/testmode.h
+++ b/testmode.h
@@ -5,7 +5,8 @@
 #ifndef __MT76_TESTMODE_H
 #define __MT76_TESTMODE_H
 
-#define MT76_TM_TIMEOUT	10
+#define MT76_TM_TIMEOUT			10
+#define MT76_TM_EEPROM_BLOCK_SIZE	16
 
 /**
  * enum mt76_testmode_attr - testmode attributes inside NL80211_ATTR_TESTDATA
@@ -15,9 +16,11 @@
  * @MT76_TM_ATTR_RESET: reset parameters to default (flag)
  * @MT76_TM_ATTR_STATE: test state (u32), see &enum mt76_testmode_state
  *
- * @MT76_TM_ATTR_MTD_PART: mtd partition used for eeprom data (string)
+ * @MT76_TM_ATTR_MTD_PART: mtd partition or binfile used for eeprom data (string)
  * @MT76_TM_ATTR_MTD_OFFSET: offset of eeprom data within the partition (u32)
+ * @MT76_TM_ATTR_BAND_IDX: band idx of the chip (u8)
  *
+ * @MT76_TM_ATTR_SKU_EN: config txpower sku is enabled or disabled in testmode (u8)
  * @MT76_TM_ATTR_TX_COUNT: configured number of frames to send when setting
  *	state to MT76_TM_STATE_TX_FRAMES (u32)
  * @MT76_TM_ATTR_TX_PENDING: pending frames during MT76_TM_STATE_TX_FRAMES (u32)
@@ -38,6 +41,11 @@
  *
  * @MT76_TM_ATTR_STATS: statistics (nested, see &enum mt76_testmode_stats_attr)
  *
+ * @MT76_TM_ATTR_PRECAL: Pre-cal data (u8)
+ * @MT76_TM_ATTR_PRECAL_INFO: group size, dpd size, dpd_info, transmit size,
+ *                            eeprom cal indicator (u32),
+ *                            dpd_info = [dpd_per_chan_size, chan_num_2g,
+ *                                        chan_num_5g, chan_num_6g]
  * @MT76_TM_ATTR_TX_SPE_IDX: tx spatial extension index (u8)
  *
  * @MT76_TM_ATTR_TX_DUTY_CYCLE: packet tx duty cycle (u8)
@@ -47,6 +55,29 @@
  * @MT76_TM_ATTR_DRV_DATA: driver specific netlink attrs (nested)
  *
  * @MT76_TM_ATTR_MAC_ADDRS: array of nested MAC addresses (nested)
+ *
+ * @MT76_TM_ATTR_EEPROM_ACTION: eeprom setting actions
+ *	(u8, see &enum mt76_testmode_eeprom_action)
+ * @MT76_TM_ATTR_EEPROM_OFFSET: offset of eeprom data block for writing (u32)
+ * @MT76_TM_ATTR_EEPROM_VAL: values for writing into a 16-byte data block
+ *	(nested, u8 attrs)
+ *
+ * @MT76_TM_ATTR_CFG: config testmode rf feature (nested, see &mt76_testmode_cfg)
+ * @MT76_TM_ATTR_TXBF_ACT: txbf setting actions (u8)
+ * @MT76_TM_ATTR_TXBF_PARAM: txbf parameters (nested)
+ *
+ * @MT76_TM_ATTR_OFF_CH_SCAN_CH: config the channel of background chain (ZWDFS) (u8)
+ * @MT76_TM_ATTR_OFF_CH_SCAN_CENTER_CH: config the center channel of background chain (ZWDFS) (u8)
+ * @MT76_TM_ATTR_OFF_CH_SCAN_BW: config the bandwidth of background chain (ZWDFS) (u8)
+ * @MT76_TM_ATTR_OFF_CH_SCAN_PATH: config the tx path of background chain (ZWDFS) (u8)
+ *
+ * @MT76_TM_ATTR_IPI_THRESHOLD: config the IPI index you want to read (u8)
+ * @MT76_TM_ATTR_IPI_PERIOD: config the time period for reading
+ *			     the histogram of specific IPI index (u8)
+ * @MT76_TM_ATTR_IPI_ANTENNA_INDEX: config the antenna index for reading
+ *				    the histogram of specific IPI index (u8)
+ * @MT76_TM_ATTR_IPI_RESET: Reset the IPI counter
+ *
  */
 enum mt76_testmode_attr {
 	MT76_TM_ATTR_UNSPEC,
@@ -56,7 +87,9 @@ enum mt76_testmode_attr {
 
 	MT76_TM_ATTR_MTD_PART,
 	MT76_TM_ATTR_MTD_OFFSET,
+	MT76_TM_ATTR_BAND_IDX,
 
+	MT76_TM_ATTR_SKU_EN,
 	MT76_TM_ATTR_TX_COUNT,
 	MT76_TM_ATTR_TX_LENGTH,
 	MT76_TM_ATTR_TX_RATE_MODE,
@@ -74,6 +107,8 @@ enum mt76_testmode_attr {
 	MT76_TM_ATTR_FREQ_OFFSET,
 
 	MT76_TM_ATTR_STATS,
+	MT76_TM_ATTR_PRECAL,
+	MT76_TM_ATTR_PRECAL_INFO,
 
 	MT76_TM_ATTR_TX_SPE_IDX,
 
@@ -84,6 +119,27 @@ enum mt76_testmode_attr {
 	MT76_TM_ATTR_DRV_DATA,
 
 	MT76_TM_ATTR_MAC_ADDRS,
+	MT76_TM_ATTR_AID,
+	MT76_TM_ATTR_RU_ALLOC,
+	MT76_TM_ATTR_RU_IDX,
+
+	MT76_TM_ATTR_EEPROM_ACTION,
+	MT76_TM_ATTR_EEPROM_OFFSET,
+	MT76_TM_ATTR_EEPROM_VAL,
+
+	MT76_TM_ATTR_CFG,
+	MT76_TM_ATTR_TXBF_ACT,
+	MT76_TM_ATTR_TXBF_PARAM,
+
+	MT76_TM_ATTR_OFF_CH_SCAN_CH,
+	MT76_TM_ATTR_OFF_CH_SCAN_CENTER_CH,
+	MT76_TM_ATTR_OFF_CH_SCAN_BW,
+	MT76_TM_ATTR_OFF_CH_SCAN_PATH,
+
+	MT76_TM_ATTR_IPI_THRESHOLD,
+	MT76_TM_ATTR_IPI_PERIOD,
+	MT76_TM_ATTR_IPI_ANTENNA_INDEX,
+	MT76_TM_ATTR_IPI_RESET,
 
 	/* keep last */
 	NUM_MT76_TM_ATTRS,
@@ -101,6 +157,8 @@ enum mt76_testmode_attr {
  * @MT76_TM_STATS_ATTR_RX_FCS_ERROR: number of rx packets with FCS error (u64)
  * @MT76_TM_STATS_ATTR_LAST_RX: information about the last received packet
  *	see &enum mt76_testmode_rx_attr
+ * @MT76_TM_STATS_ATTR_RX_LEN_MISMATCH: number of rx packets with length
+ *	mismatch error (u64)
  */
 enum mt76_testmode_stats_attr {
 	MT76_TM_STATS_ATTR_UNSPEC,
@@ -113,6 +171,7 @@ enum mt76_testmode_stats_attr {
 	MT76_TM_STATS_ATTR_RX_PACKETS,
 	MT76_TM_STATS_ATTR_RX_FCS_ERROR,
 	MT76_TM_STATS_ATTR_LAST_RX,
+	MT76_TM_STATS_ATTR_RX_LEN_MISMATCH,
 
 	/* keep last */
 	NUM_MT76_TM_STATS_ATTRS,
@@ -125,6 +184,7 @@ enum mt76_testmode_stats_attr {
  *
  * @MT76_TM_RX_ATTR_FREQ_OFFSET: frequency offset (s32)
  * @MT76_TM_RX_ATTR_RCPI: received channel power indicator (array, u8)
+ * @MT76_TM_RX_ATTR_RSSI: received signal strength indicator (array, s8)
  * @MT76_TM_RX_ATTR_IB_RSSI: internal inband RSSI (array, s8)
  * @MT76_TM_RX_ATTR_WB_RSSI: internal wideband RSSI (array, s8)
  * @MT76_TM_RX_ATTR_SNR: signal-to-noise ratio (u8)
@@ -134,6 +194,7 @@ enum mt76_testmode_rx_attr {
 
 	MT76_TM_RX_ATTR_FREQ_OFFSET,
 	MT76_TM_RX_ATTR_RCPI,
+	MT76_TM_RX_ATTR_RSSI,
 	MT76_TM_RX_ATTR_IB_RSSI,
 	MT76_TM_RX_ATTR_WB_RSSI,
 	MT76_TM_RX_ATTR_SNR,
@@ -159,6 +220,14 @@ enum mt76_testmode_state {
 	MT76_TM_STATE_TX_FRAMES,
 	MT76_TM_STATE_RX_FRAMES,
 	MT76_TM_STATE_TX_CONT,
+	MT76_TM_STATE_GROUP_PREK,
+	MT76_TM_STATE_GROUP_PREK_DUMP,
+	MT76_TM_STATE_GROUP_PREK_CLEAN,
+	MT76_TM_STATE_DPD_2G,
+	MT76_TM_STATE_DPD_5G,
+	MT76_TM_STATE_DPD_6G,
+	MT76_TM_STATE_DPD_DUMP,
+	MT76_TM_STATE_DPD_CLEAN,
 	MT76_TM_STATE_ON,
 
 	/* keep last */
@@ -177,6 +246,9 @@ enum mt76_testmode_state {
  * @MT76_TM_TX_MODE_HE_EXT_SU: 802.11ax extended-range SU
  * @MT76_TM_TX_MODE_HE_TB: 802.11ax trigger-based
  * @MT76_TM_TX_MODE_HE_MU: 802.11ax multi-user MIMO
+ * @MT76_TM_TX_MODE_EHT_SU: 802.11be single-user MIMO
+ * @MT76_TM_TX_MODE_EHT_TRIG: 802.11be trigger-based
+ * @MT76_TM_TX_MODE_EHT_MU: 802.11be multi-user MIMO
  */
 enum mt76_testmode_tx_mode {
 	MT76_TM_TX_MODE_CCK,
@@ -187,10 +259,84 @@ enum mt76_testmode_tx_mode {
 	MT76_TM_TX_MODE_HE_EXT_SU,
 	MT76_TM_TX_MODE_HE_TB,
 	MT76_TM_TX_MODE_HE_MU,
+	MT76_TM_TX_MODE_EHT_SU,
+	MT76_TM_TX_MODE_EHT_TRIG,
+	MT76_TM_TX_MODE_EHT_MU,
 
 	/* keep last */
 	NUM_MT76_TM_TX_MODES,
 	MT76_TM_TX_MODE_MAX = NUM_MT76_TM_TX_MODES - 1,
 };
 
+/**
+ * enum mt76_testmode_eeprom_action - eeprom setting actions
+ *
+ * @MT76_TM_EEPROM_ACTION_UPDATE_DATA: update rf values to specific
+ *	eeprom data block
+ * @MT76_TM_EEPROM_ACTION_UPDATE_BUFFER_MODE: send updated eeprom data to fw
+ * @MT76_TM_EEPROM_ACTION_WRITE_TO_EFUSE: write eeprom data back to efuse
+ */
+enum mt76_testmode_eeprom_action {
+	MT76_TM_EEPROM_ACTION_UPDATE_DATA,
+	MT76_TM_EEPROM_ACTION_UPDATE_BUFFER_MODE,
+	MT76_TM_EEPROM_ACTION_WRITE_TO_EFUSE,
+
+	/* keep last */
+	NUM_MT76_TM_EEPROM_ACTION,
+	MT76_TM_EEPROM_ACTION_MAX = NUM_MT76_TM_EEPROM_ACTION - 1,
+};
+
+/**
+ * enum mt76_testmode_txbf_act - txbf action
+ *
+ * @MT76_TM_TXBF_ACT_GOLDEN_INIT: init ibf setting for golden device
+ * @MT76_TM_TXBF_ACT_INIT: init ibf setting for DUT
+ * @MT76_TM_TX_EBF_ACT_GOLDEN_INIT: init ebf setting for golden device
+ * @MT76_TM_TX_EBF_ACT_INIT: init ebf setting for DUT
+ * @MT76_TM_TXBF_ACT_UPDATE_CH: update channel info
+ * @MT76_TM_TXBF_ACT_PHASE_COMP: txbf phase compensation
+ * @MT76_TM_TXBF_ACT_TX_PREP: TX preparation for txbf
+ * @MT76_TM_TXBF_ACT_IBF_PROF_UPDATE: update ibf profile (pfmu tag, bf sta record)
+ * @MT76_TM_TXBF_ACT_EBF_PROF_UPDATE: update ebf profile
+ * @MT76_TM_TXBF_ACT_APPLY_TX: apply TX setting for txbf
+ * @MT76_TM_TXBF_ACT_PHASE_CAL: perform txbf phase calibration
+ * @MT76_TM_TXBF_ACT_PROF_UPDATE_ALL: update bf profile via instrument
+ * @MT76_TM_TXBF_ACT_PROF_UPDATE_ALL_CMD: update bf profile via instrument
+ * @MT76_TM_TXBF_ACT_E2P_UPDATE: write back txbf calibration result to eeprom
+ * @MT76_TM_TXBF_ACT_TRIGGER_SOUNDING: trigger beamformer to send sounding packet
+ * @MT76_TM_TXBF_ACT_STOP_SOUNDING: stop sending sounding packet
+ * @MT76_TM_TXBF_ACT_PROFILE_TAG_READ: read pfmu tag
+ * @MT76_TM_TXBF_ACT_PROFILE_TAG_WRITE: update pfmu tag
+ * @MT76_TM_TXBF_ACT_PROFILE_TAG_INVALID: invalidate pfmu tag
+ * @MT76_TM_TXBF_ACT_STA_REC_READ: read bf sta record
+ * @MT76_TM_TXBF_ACT_TXCMD: configure txcmd bf bit manually
+ */
+enum mt76_testmode_txbf_act {
+	MT76_TM_TXBF_ACT_GOLDEN_INIT,
+	MT76_TM_TXBF_ACT_INIT,
+	MT76_TM_TX_EBF_ACT_GOLDEN_INIT,
+	MT76_TM_TX_EBF_ACT_INIT,
+	MT76_TM_TXBF_ACT_UPDATE_CH,
+	MT76_TM_TXBF_ACT_PHASE_COMP,
+	MT76_TM_TXBF_ACT_TX_PREP,
+	MT76_TM_TXBF_ACT_IBF_PROF_UPDATE,
+	MT76_TM_TXBF_ACT_EBF_PROF_UPDATE,
+	MT76_TM_TXBF_ACT_APPLY_TX,
+	MT76_TM_TXBF_ACT_PHASE_CAL,
+	MT76_TM_TXBF_ACT_PROF_UPDATE_ALL,
+	MT76_TM_TXBF_ACT_PROF_UPDATE_ALL_CMD,
+	MT76_TM_TXBF_ACT_E2P_UPDATE,
+	MT76_TM_TXBF_ACT_TRIGGER_SOUNDING,
+	MT76_TM_TXBF_ACT_STOP_SOUNDING,
+	MT76_TM_TXBF_ACT_PROFILE_TAG_READ,
+	MT76_TM_TXBF_ACT_PROFILE_TAG_WRITE,
+	MT76_TM_TXBF_ACT_PROFILE_TAG_INVALID,
+	MT76_TM_TXBF_ACT_STA_REC_READ,
+	MT76_TM_TXBF_ACT_TXCMD,
+
+	/* keep last */
+	NUM_MT76_TM_TXBF_ACT,
+	MT76_TM_TXBF_ACT_MAX = NUM_MT76_TM_TXBF_ACT - 1,
+};
+
 #endif
diff --git a/tools/CMakeLists.txt b/tools/CMakeLists.txt
index 3a83e34d..6599c444 100644
--- a/tools/CMakeLists.txt
+++ b/tools/CMakeLists.txt
@@ -3,6 +3,13 @@ cmake_minimum_required(VERSION 2.8)
 PROJECT(mt76-test C)
 ADD_DEFINITIONS(-Os -Wall -Werror --std=gnu99 -g3)
 
+UNSET(backports_dir CACHE)
+FIND_PATH(
+	backports_dir
+	NAMES "mac80211/uapi/linux"
+)
+INCLUDE_DIRECTORIES("${backports_dir}/mac80211/uapi")
+
 ADD_EXECUTABLE(mt76-test main.c fields.c eeprom.c fwlog.c)
 TARGET_LINK_LIBRARIES(mt76-test nl-tiny)
 
diff --git a/tools/fields.c b/tools/fields.c
index e3f69089..f793d1a5 100644
--- a/tools/fields.c
+++ b/tools/fields.c
@@ -10,6 +10,15 @@ static const char * const testmode_state[] = {
 	[MT76_TM_STATE_IDLE] = "idle",
 	[MT76_TM_STATE_TX_FRAMES] = "tx_frames",
 	[MT76_TM_STATE_RX_FRAMES] = "rx_frames",
+	[MT76_TM_STATE_TX_CONT] = "tx_cont",
+	[MT76_TM_STATE_GROUP_PREK] = "group_prek",
+	[MT76_TM_STATE_GROUP_PREK_DUMP] = "group_prek_dump",
+	[MT76_TM_STATE_GROUP_PREK_CLEAN] = "group_prek_clean",
+	[MT76_TM_STATE_DPD_2G] = "dpd_2g",
+	[MT76_TM_STATE_DPD_5G] = "dpd_5g",
+	[MT76_TM_STATE_DPD_6G] = "dpd_6g",
+	[MT76_TM_STATE_DPD_DUMP] = "dpd_dump",
+	[MT76_TM_STATE_DPD_CLEAN] = "dpd_clean",
 };
 
 static const char * const testmode_tx_mode[] = {
@@ -21,6 +30,42 @@ static const char * const testmode_tx_mode[] = {
 	[MT76_TM_TX_MODE_HE_EXT_SU] = "he_ext_su",
 	[MT76_TM_TX_MODE_HE_TB] = "he_tb",
 	[MT76_TM_TX_MODE_HE_MU] = "he_mu",
+	[MT76_TM_TX_MODE_EHT_SU] = "eht_su",
+	[MT76_TM_TX_MODE_EHT_TRIG] = "eht_tb",
+	[MT76_TM_TX_MODE_EHT_MU] = "eht_mu",
+};
+
+static const char * const testmode_offchan_bw[] = {
+	[NL80211_CHAN_WIDTH_20_NOHT] = "NOHT",
+	[NL80211_CHAN_WIDTH_20] = "20",
+	[NL80211_CHAN_WIDTH_40] = "40",
+	[NL80211_CHAN_WIDTH_80] = "80",
+	[NL80211_CHAN_WIDTH_80P80] = "80p80",
+	[NL80211_CHAN_WIDTH_160] = "160",
+};
+
+static const char * const testmode_txbf_act[] = {
+	[MT76_TM_TXBF_ACT_GOLDEN_INIT] = "golden_init",
+	[MT76_TM_TXBF_ACT_INIT] = "init",
+	[MT76_TM_TX_EBF_ACT_GOLDEN_INIT] = "ebf_golden_init",
+	[MT76_TM_TX_EBF_ACT_INIT] = "ebf_init",
+	[MT76_TM_TXBF_ACT_UPDATE_CH] = "update_ch",
+	[MT76_TM_TXBF_ACT_PHASE_COMP] = "phase_comp",
+	[MT76_TM_TXBF_ACT_TX_PREP] = "tx_prep",
+	[MT76_TM_TXBF_ACT_IBF_PROF_UPDATE] = "ibf_prof_update",
+	[MT76_TM_TXBF_ACT_EBF_PROF_UPDATE] = "ebf_prof_update",
+	[MT76_TM_TXBF_ACT_APPLY_TX] = "apply_tx",
+	[MT76_TM_TXBF_ACT_PHASE_CAL] = "phase_cal",
+	[MT76_TM_TXBF_ACT_PROF_UPDATE_ALL] = "prof_update",
+	[MT76_TM_TXBF_ACT_PROF_UPDATE_ALL_CMD] = "prof_update_all",
+	[MT76_TM_TXBF_ACT_E2P_UPDATE] = "e2p_update",
+	[MT76_TM_TXBF_ACT_TRIGGER_SOUNDING] = "trigger_sounding",
+	[MT76_TM_TXBF_ACT_STOP_SOUNDING] = "stop_sounding",
+	[MT76_TM_TXBF_ACT_PROFILE_TAG_READ] = "pfmu_tag_read",
+	[MT76_TM_TXBF_ACT_PROFILE_TAG_WRITE] = "pfmu_tag_write",
+	[MT76_TM_TXBF_ACT_PROFILE_TAG_INVALID] = "set_invalid_prof",
+	[MT76_TM_TXBF_ACT_STA_REC_READ] = "sta_rec_read",
+	[MT76_TM_TXBF_ACT_TXCMD] = "txcmd",
 };
 
 static void print_enum(const struct tm_field *field, struct nlattr *attr)
@@ -65,7 +110,7 @@ static bool parse_u8(const struct tm_field *field, int idx,
 
 static void print_u8(const struct tm_field *field, struct nlattr *attr)
 {
-	printf("%d", nla_get_u8(attr));
+	printf("%u", nla_get_u8(attr));
 }
 
 static void print_s8(const struct tm_field *field, struct nlattr *attr)
@@ -73,6 +118,17 @@ static void print_s8(const struct tm_field *field, struct nlattr *attr)
 	printf("%d", (int8_t)nla_get_u8(attr));
 }
 
+static bool parse_u16_hex(const struct tm_field *field, int idx,
+			  struct nl_msg *msg, const char *val)
+{
+	return !nla_put_u16(msg, idx, strtoul(val, NULL, 16));
+}
+
+static void print_u16_hex(const struct tm_field *field, struct nlattr *attr)
+{
+	printf("%d", nla_get_u16(attr));
+}
+
 static bool parse_u32(const struct tm_field *field, int idx,
 		      struct nl_msg *msg, const char *val)
 {
@@ -86,12 +142,12 @@ static void print_s32(const struct tm_field *field, struct nlattr *attr)
 
 static void print_u32(const struct tm_field *field, struct nlattr *attr)
 {
-	printf("%d", nla_get_u32(attr));
+	printf("%u", nla_get_u32(attr));
 }
 
 static void print_u64(const struct tm_field *field, struct nlattr *attr)
 {
-	printf("%lld", (unsigned long long)nla_get_u64(attr));
+	printf("%llu", (unsigned long long)nla_get_u64(attr));
 }
 
 static bool parse_flag(const struct tm_field *field, int idx,
@@ -201,6 +257,62 @@ static void print_extra_stats(const struct tm_field *field, struct nlattr **tb)
 	printf("%srx_per=%.02f%%\n", prefix, 100 * failed / total);
 }
 
+static bool parse_mac(const struct tm_field *field, int idx,
+		      struct nl_msg *msg, const char *val)
+{
+#define ETH_ALEN	6
+	bool ret = true;
+	char *str, *cur, *ap;
+	void *a;
+
+	str = strdup(val);
+	ap = str;
+
+	a = nla_nest_start(msg, idx);
+
+	idx = 0;
+	while ((cur = strsep(&ap, ",")) != NULL) {
+		unsigned char addr[ETH_ALEN];
+		char *val, *tmp = cur;
+		int i = 0;
+
+		while ((val = strsep(&tmp, ":")) != NULL) {
+			if (i >= ETH_ALEN)
+				break;
+
+			addr[i++] = strtoul(val, NULL, 16);
+		}
+
+		nla_put(msg, idx, ETH_ALEN, addr);
+
+		idx++;
+	}
+
+	nla_nest_end(msg, a);
+
+	free(str);
+
+	return ret;
+}
+
+static void print_mac(const struct tm_field *field, struct nlattr *attr)
+{
+#define MAC2STR(a) (a)[0], (a)[1], (a)[2], (a)[3], (a)[4], (a)[5]
+#define MACSTR "%02x:%02x:%02x:%02x:%02x:%02x"
+	unsigned char addr[3][6];
+	struct nlattr *cur;
+	int idx = 0;
+	int rem;
+
+	nla_for_each_nested(cur, attr, rem) {
+		if (nla_len(cur) != 6)
+			continue;
+		memcpy(addr[idx++], nla_data(cur), 6);
+	}
+
+	printf("" MACSTR "," MACSTR "," MACSTR "",
+	       MAC2STR(addr[0]), MAC2STR(addr[1]), MAC2STR(addr[2]));
+}
 
 #define FIELD_GENERIC(_field, _name, ...)	\
 	[FIELD_NAME(_field)] = {			\
@@ -250,10 +362,18 @@ static void print_extra_stats(const struct tm_field *field, struct nlattr **tb)
 		 ##__VA_ARGS__				\
 	)
 
+#define FIELD_MAC(_field, _name)			\
+	[FIELD_NAME(_field)] = {			\
+		.name = _name,				\
+		.parse = parse_mac,			\
+		.print = print_mac			\
+	}
+
 #define FIELD_NAME(_field) MT76_TM_RX_ATTR_##_field
 static const struct tm_field rx_fields[NUM_MT76_TM_RX_ATTRS] = {
 	FIELD_RO(s32, FREQ_OFFSET, "freq_offset"),
 	FIELD_ARRAY_RO(u8, RCPI, "rcpi"),
+	FIELD_ARRAY_RO(s8, RSSI, "rssi"),
 	FIELD_ARRAY_RO(s8, IB_RSSI, "ib_rssi"),
 	FIELD_ARRAY_RO(s8, WB_RSSI, "wb_rssi"),
 	FIELD_RO(s8, SNR, "snr"),
@@ -261,6 +381,7 @@ static const struct tm_field rx_fields[NUM_MT76_TM_RX_ATTRS] = {
 static struct nla_policy rx_policy[NUM_MT76_TM_RX_ATTRS] = {
 	[MT76_TM_RX_ATTR_FREQ_OFFSET] = { .type = NLA_U32 },
 	[MT76_TM_RX_ATTR_RCPI] = { .type = NLA_NESTED },
+	[MT76_TM_RX_ATTR_RSSI] = { .type = NLA_NESTED },
 	[MT76_TM_RX_ATTR_IB_RSSI] = { .type = NLA_NESTED },
 	[MT76_TM_RX_ATTR_WB_RSSI] = { .type = NLA_NESTED },
 	[MT76_TM_RX_ATTR_SNR] = { .type = NLA_U8 },
@@ -274,6 +395,7 @@ static const struct tm_field stats_fields[NUM_MT76_TM_STATS_ATTRS] = {
 	FIELD_RO(u32, TX_DONE, "tx_done"),
 	FIELD_RO(u64, RX_PACKETS, "rx_packets"),
 	FIELD_RO(u64, RX_FCS_ERROR, "rx_fcs_error"),
+	FIELD_RO(u64, RX_LEN_MISMATCH, "rx_len_mismatch"),
 	FIELD_NESTED_RO(LAST_RX, rx, "last_"),
 };
 static struct nla_policy stats_policy[NUM_MT76_TM_STATS_ATTRS] = {
@@ -282,6 +404,7 @@ static struct nla_policy stats_policy[NUM_MT76_TM_STATS_ATTRS] = {
 	[MT76_TM_STATS_ATTR_TX_DONE] = { .type = NLA_U32 },
 	[MT76_TM_STATS_ATTR_RX_PACKETS] = { .type = NLA_U64 },
 	[MT76_TM_STATS_ATTR_RX_FCS_ERROR] = { .type = NLA_U64 },
+	[MT76_TM_STATS_ATTR_RX_LEN_MISMATCH] = { .type = NLA_U64 },
 };
 #undef FIELD_NAME
 
@@ -291,6 +414,7 @@ static const struct tm_field testdata_fields[NUM_MT76_TM_ATTRS] = {
 	FIELD_ENUM(STATE, "state", testmode_state),
 	FIELD_RO(string, MTD_PART, "mtd_part"),
 	FIELD_RO(u32, MTD_OFFSET, "mtd_offset"),
+	FIELD(u8, SKU_EN, "sku_en"),
 	FIELD(u32, TX_COUNT, "tx_count"),
 	FIELD(u32, TX_LENGTH, "tx_length"),
 	FIELD_ENUM(TX_RATE_MODE, "tx_rate_mode", testmode_tx_mode),
@@ -300,12 +424,28 @@ static const struct tm_field testdata_fields[NUM_MT76_TM_ATTRS] = {
 	FIELD(u8, TX_RATE_LDPC, "tx_rate_ldpc"),
 	FIELD(u8, TX_RATE_STBC, "tx_rate_stbc"),
 	FIELD(u8, TX_LTF, "tx_ltf"),
+	FIELD(u8, TX_DUTY_CYCLE, "tx_duty_cycle"),
+	FIELD(u32, TX_IPG, "tx_ipg"),
+	FIELD(u32, TX_TIME, "tx_time"),
 	FIELD(u8, TX_POWER_CONTROL, "tx_power_control"),
 	FIELD_ARRAY(u8, TX_POWER, "tx_power"),
 	FIELD(u8, TX_ANTENNA, "tx_antenna"),
 	FIELD(u32, FREQ_OFFSET, "freq_offset"),
+	FIELD(u8, AID, "aid"),
+	FIELD(u8, RU_ALLOC, "ru_alloc"),
+	FIELD(u8, RU_IDX, "ru_idx"),
+	FIELD_ENUM(TXBF_ACT, "txbf_act", testmode_txbf_act),
+	FIELD_ARRAY(u16_hex, TXBF_PARAM, "txbf_param"),
+	FIELD(u8, OFF_CH_SCAN_CH, "offchan_ch"),
+	FIELD(u8, OFF_CH_SCAN_CENTER_CH, "offchan_center_ch"),
+	FIELD_ENUM(OFF_CH_SCAN_BW, "offchan_bw", testmode_offchan_bw),
+	FIELD(u8, IPI_THRESHOLD, "ipi_threshold"),
+	FIELD(u32, IPI_PERIOD, "ipi_period"),
+	FIELD(u8, IPI_RESET, "ipi_reset"),
+	FIELD_MAC(MAC_ADDRS, "mac_addrs"),
 	FIELD_NESTED_RO(STATS, stats, "",
 			.print_extra = print_extra_stats),
+
 };
 #undef FIELD_NAME
 
@@ -313,6 +453,7 @@ static struct nla_policy testdata_policy[NUM_MT76_TM_ATTRS] = {
 	[MT76_TM_ATTR_STATE] = { .type = NLA_U8 },
 	[MT76_TM_ATTR_MTD_PART] = { .type = NLA_STRING },
 	[MT76_TM_ATTR_MTD_OFFSET] = { .type = NLA_U32 },
+	[MT76_TM_ATTR_SKU_EN] = { .type = NLA_U8 },
 	[MT76_TM_ATTR_TX_COUNT] = { .type = NLA_U32 },
 	[MT76_TM_ATTR_TX_LENGTH] = { .type = NLA_U32 },
 	[MT76_TM_ATTR_TX_RATE_MODE] = { .type = NLA_U8 },
@@ -322,10 +463,25 @@ static struct nla_policy testdata_policy[NUM_MT76_TM_ATTRS] = {
 	[MT76_TM_ATTR_TX_RATE_LDPC] = { .type = NLA_U8 },
 	[MT76_TM_ATTR_TX_RATE_STBC] = { .type = NLA_U8 },
 	[MT76_TM_ATTR_TX_LTF] = { .type = NLA_U8 },
+	[MT76_TM_ATTR_TX_DUTY_CYCLE] = { .type = NLA_U8 },
+	[MT76_TM_ATTR_TX_IPG] = { .type = NLA_U32 },
+	[MT76_TM_ATTR_TX_TIME] = { .type = NLA_U32 },
 	[MT76_TM_ATTR_TX_POWER_CONTROL] = { .type = NLA_U8 },
 	[MT76_TM_ATTR_TX_ANTENNA] = { .type = NLA_U8 },
+	[MT76_TM_ATTR_TX_SPE_IDX] = { .type = NLA_U8 },
 	[MT76_TM_ATTR_FREQ_OFFSET] = { .type = NLA_U32 },
+	[MT76_TM_ATTR_AID] = { .type = NLA_U8 },
+	[MT76_TM_ATTR_RU_ALLOC] = { .type = NLA_U8 },
+	[MT76_TM_ATTR_RU_IDX] = { .type = NLA_U8 },
 	[MT76_TM_ATTR_STATS] = { .type = NLA_NESTED },
+	[MT76_TM_ATTR_TXBF_ACT] = { .type = NLA_U8 },
+	[MT76_TM_ATTR_OFF_CH_SCAN_CH] = { .type = NLA_U8 },
+	[MT76_TM_ATTR_OFF_CH_SCAN_CENTER_CH] = { .type = NLA_U8 },
+	[MT76_TM_ATTR_OFF_CH_SCAN_BW] = { .type = NLA_U8 },
+	[MT76_TM_ATTR_IPI_THRESHOLD] = { .type = NLA_U8 },
+	[MT76_TM_ATTR_IPI_PERIOD] = { .type = NLA_U32 },
+	[MT76_TM_ATTR_IPI_ANTENNA_INDEX] = { .type = NLA_U8 },
+	[MT76_TM_ATTR_IPI_RESET] = { .type = NLA_U8 },
 };
 
 const struct tm_field msg_field = {
diff --git a/tools/fwlog.c b/tools/fwlog.c
index e5d4a105..8d163e1d 100644
--- a/tools/fwlog.c
+++ b/tools/fwlog.c
@@ -26,16 +26,36 @@ static const char *debugfs_path(const char *phyname, const char *file)
 	return path;
 }
 
-static int mt76_set_fwlog_en(const char *phyname, bool en)
+static int mt76_set_fwlog_en(const char *phyname, bool en, char *val)
 {
 	FILE *f = fopen(debugfs_path(phyname, "fw_debug_bin"), "w");
+	if (!f) {
+		perror("fopen");
+		return -1;
+	}
+
+	if (en && val)
+		fprintf(f, "%s", val);
+	else if (en)
+		fprintf(f, "7");
+	else
+		fprintf(f, "0");
+
+	fclose(f);
+
+	return 0;
+}
 
+static int mt76_set_idxlog_enable(const char *phyname, bool enable)
+{
+	FILE *f = fopen(debugfs_path(phyname, "idxlog_enable"), "w");
 	if (!f) {
-		fprintf(stderr, "Could not open fw_debug_bin file\n");
-		return 1;
+		perror("fopen");
+		return -1;
 	}
 
-	fprintf(f, "7");
+	fprintf(f, "%hhu", enable);
+
 	fclose(f);
 
 	return 0;
@@ -74,104 +94,215 @@ static void handle_signal(int sig)
 	done = true;
 }
 
-int mt76_fwlog(const char *phyname, int argc, char **argv)
+static int mt76_log_socket(struct sockaddr_in *remote, char *ip, unsigned short port)
 {
 	struct sockaddr_in local = {
 		.sin_family = AF_INET,
 		.sin_addr.s_addr = INADDR_ANY,
 	};
-	struct sockaddr_in remote = {
-		.sin_family = AF_INET,
-		.sin_port = htons(55688),
-	};
-	char buf[1504];
-	int ret = 0;
-	int yes = 1;
-	int s, fd;
-
-	if (argc < 1) {
-		fprintf(stderr, "need destination address\n");
-		return 1;
-	}
+	int s, ret;
 
-	if (!inet_aton(argv[0], &remote.sin_addr)) {
-		fprintf(stderr, "invalid destination address\n");
-		return 1;
+	remote->sin_family = AF_INET;
+	remote->sin_port = htons(port);
+	if (!inet_aton(ip, &remote->sin_addr)) {
+		fprintf(stderr, "Invalid destination IP address: %s\n", ip);
+		return -EINVAL;
 	}
 
 	s = socket(PF_INET, SOCK_DGRAM, IPPROTO_UDP);
 	if (s < 0) {
 		perror("socket");
-		return 1;
+		return s;
 	}
 
-	setsockopt(s, SOL_SOCKET, SO_BROADCAST, &yes, sizeof(yes));
-	if (bind(s, (struct sockaddr *)&local, sizeof(local)) < 0) {
+	ret = bind(s, (struct sockaddr *)&local, sizeof(local));
+	if (ret) {
 		perror("bind");
-		return 1;
+		close(s);
+		return ret;
 	}
 
-	if (mt76_set_fwlog_en(phyname, true))
-		return 1;
+	return s;
+}
+
+static int mt76_log_relay(int in_fd, int out_fd, struct sockaddr_in *remote)
+{
+	char *buf = malloc(FWLOG_BUF_SIZE);
+	int ret = 0;
 
-	fd = open(debugfs_path(phyname, "fwlog_data"), O_RDONLY);
-	if (fd < 0) {
-		fprintf(stderr, "Could not open fwlog_data file: %s\n", strerror(errno));
-		ret = 1;
-		goto out;
+	if (!buf) {
+		perror("malloc");
+		return -ENOMEM;
 	}
 
 	signal(SIGTERM, handle_signal);
 	signal(SIGINT, handle_signal);
 	signal(SIGQUIT, handle_signal);
 
-	while (1) {
+	while (!done) {
 		struct pollfd pfd = {
-			.fd = fd,
-			.events = POLLIN | POLLHUP | POLLERR,
+			.fd = in_fd,
+			.events = POLLIN,
 		};
 		uint32_t len;
-		int r;
-
-		if (done)
-			break;
+		int rc;
 
 		poll(&pfd, 1, -1);
 
-		r = read_retry(fd, &len, sizeof(len));
-		if (r < 0)
+		rc = read_retry(in_fd, &len, sizeof(len));
+		if (rc < 0) {
+			if (!done) {
+				fprintf(stderr, "Failed to read relay file.\n");
+				ret = -1;
+			}
 			break;
-
-		if (!r)
+		}
+		if (!rc)
 			continue;
 
-		if (len > sizeof(buf)) {
-			fprintf(stderr, "Length error: %d > %d\n", len, (int)sizeof(buf));
-			ret = 1;
+		if (len > FWLOG_BUF_SIZE) {
+			fprintf(stderr, "Log size was too large: %u bytes\n", len);
+			ret = -ENOMEM;
 			break;
 		}
 
-		if (done)
+		rc = read_retry(in_fd, buf, len);
+		if (rc < 0) {
+			if (!done) {
+				fprintf(stderr, "Failed to read relay file.\n");
+				ret = -1;
+			}
 			break;
-
-		r = read_retry(fd, buf, len);
-		if (done)
+		}
+		if (rc != len) {
+			fprintf(stderr, "Expected log size: %u bytes\n", len);
+			fprintf(stderr, "Read log size: %u bytes\n", rc);
+			ret = -EIO;
 			break;
+		}
 
-		if (r != len) {
-			fprintf(stderr, "Short read: %d < %d\n", r, len);
-			ret = 1;
+		if (remote)
+			rc = sendto(out_fd, buf, len, 0, (struct sockaddr *)remote, sizeof(*remote));
+		else
+			rc = write(out_fd, buf, len);
+		if (rc < 0) {
+			perror("sendto/write");
+			ret = -1;
 			break;
 		}
+	}
+
+	free(buf);
+
+	return ret;
+}
 
-		/* send buf */
-		sendto(s, buf, len, 0, (struct sockaddr *)&remote, sizeof(remote));
+int mt76_fwlog(const char *phyname, int argc, char **argv)
+{
+	struct sockaddr_in remote;
+	int in_fd, out_fd, ret;
+	char dev_ip[16] = {};
+	unsigned short port;
+
+	if (argc < 2) {
+		fprintf(stderr, "need destination address and fw_debug_bin\n");
+		return -EINVAL;
 	}
 
-	close(fd);
 
-out:
-	mt76_set_fwlog_en(phyname, false);
+	if (argc == 2) {
+		/* support ip:port format */
+		if (strchr(argv[0], ':')) {
+			sscanf(argv[0], "%[^:]:%hu", dev_ip, &port);
+		} else {
+			strncpy(dev_ip, argv[0], sizeof(dev_ip));
+			port = 55688;
+		}
+
+		out_fd = mt76_log_socket(&remote, dev_ip, port);
+		if (out_fd < 0)
+			return out_fd;
+	} else if (argc == 3) {
+		out_fd = open(argv[2], O_WRONLY | O_CREAT | O_TRUNC, S_IRUSR);
+		if (out_fd < 0) {
+			perror("open");
+			return out_fd;
+		}
+	} else {
+		fprintf(stderr, "Too many arguments.\n");
+		return -EINVAL;
+	}
+
+	ret = mt76_set_fwlog_en(phyname, true, argv[1]);
+	if (ret)
+		goto close;
+
+	in_fd = open(debugfs_path(phyname, "fwlog_data"), O_RDONLY);
+	if (in_fd < 0) {
+		perror("open");
+		goto disable;
+	}
+
+	if (mt76_log_relay(in_fd, out_fd, argc == 3 ? NULL : &remote))
+		fprintf(stderr, "Failed to relay FW log.\n");
+
+	close(in_fd);
+disable:
+	ret = mt76_set_fwlog_en(phyname, false, NULL);
+close:
+	close(out_fd);
+
+	return ret;
+}
+
+int mt76_idxlog(const char *phyname, int argc, char **argv)
+{
+#define IDXLOG_FILE_PATH	"/tmp/log/WIFI_FW.clog"
+	struct sockaddr_in remote;
+	int in_fd, out_fd, ret;
+
+	if (argc) {
+		out_fd = mt76_log_socket(&remote, argv[0], 55688);
+		if (out_fd < 0)
+			return out_fd;
+	} else {
+		out_fd = open(IDXLOG_FILE_PATH, O_WRONLY | O_CREAT | O_TRUNC, S_IRUSR);
+		if (out_fd < 0) {
+			perror("open");
+			return -1;
+		}
+	}
+
+	ret = mt76_set_idxlog_enable(phyname, true);
+	if (ret)
+		goto close;
+
+	in_fd = open(debugfs_path(phyname, "idxlog_data"), O_RDONLY);
+	if (in_fd < 0) {
+		perror("open");
+		goto disable;
+	}
+
+	if (mt76_log_relay(in_fd, out_fd, argc ? &remote : NULL))
+		fprintf(stderr, "Failed to relay index log.\n");
+
+	close(in_fd);
+disable:
+	ret = mt76_set_idxlog_enable(phyname, false);
+close:
+	close(out_fd);
+
+	if (argc)
+		system("timestamp=$(date +\"%y%m%d_%H%M%S\");"
+		       "clog_dir=/tmp/log/clog_${timestamp};"
+		       "mkdir ${clog_dir};"
+		       "dmesg > ${clog_dir}/WIFI_KERNEL_${timestamp}.clog");
+	else
+		system("timestamp=$(date +\"%y%m%d_%H%M%S\");"
+		       "clog_dir=/tmp/log/clog_${timestamp};"
+		       "mkdir ${clog_dir};"
+		       "mv /tmp/log/WIFI_FW.clog ${clog_dir}/WIFI_FW_${timestamp}.clog;"
+		       "dmesg > ${clog_dir}/WIFI_KERNEL_${timestamp}.clog");
 
 	return ret;
 }
diff --git a/tools/main.c b/tools/main.c
index 699a9eea..aaa17f85 100644
--- a/tools/main.c
+++ b/tools/main.c
@@ -13,6 +13,7 @@
 #include <poll.h>
 #include <fcntl.h>
 #include <signal.h>
+#include <net/if.h>
 #include "mt76-test.h"
 
 struct unl unl;
@@ -25,6 +26,7 @@ static int phy_lookup_idx(const char *name)
 	FILE *f;
 	int len;
 
+	/* TODO: Handle single wiphy radio index */
 	snprintf(buf, sizeof(buf), "/sys/class/ieee80211/%s/index", name);
 	f = fopen(buf, "r");
 	if (!f)
@@ -43,12 +45,15 @@ static int phy_lookup_idx(const char *name)
 void usage(void)
 {
 	static const char *const commands[] = {
+		"add <interface>",
+		"del <interface>",
 		"set <var>=<val> [...]",
 		"dump [stats]",
 		"eeprom file",
 		"eeprom set <addr>=<val> [...]",
 		"eeprom changes",
 		"eeprom reset",
+		"fwlog <ip> <fw_debug_bin input> <fwlog name>",
 	};
 	int i;
 
@@ -164,6 +169,122 @@ static int mt76_set(int phy, int argc, char **argv)
 	return ret;
 }
 
+static int mt76_set_state(int phy, char *state)
+{
+	const struct tm_field *fields = msg_field.fields;
+	struct nl_msg *msg;
+	void *data;
+	int ret, i;
+
+	msg = unl_genl_msg(&unl, NL80211_CMD_TESTMODE, false);
+	nla_put_u32(msg, NL80211_ATTR_WIPHY, phy);
+
+	data = nla_nest_start(msg, NL80211_ATTR_TESTDATA);
+	for (i = 0; i < msg_field.len; i++) {
+		if (!fields[i].parse)
+			continue;
+
+		if (!strcmp(fields[i].name, "state"))
+			break;
+	}
+
+	if (!fields[i].parse(&fields[i], i, msg, state))
+		return 1;
+
+	tm_set_changed(i);
+	nla_nest_end(msg, data);
+
+	ret = unl_genl_request(&unl, msg, NULL, NULL);
+	if (ret)
+		fprintf(stderr, "Failed to set state %s: %s\n", state, strerror(-ret));
+
+	return ret;
+}
+
+static void mt76_set_tm_reg(void)
+{
+	struct nl_msg *msg;
+	char reg[3] = "VV\0";
+	int ret;
+
+	msg = unl_genl_msg(&unl, NL80211_CMD_REQ_SET_REG, false);
+	nla_put_string(msg, NL80211_ATTR_REG_ALPHA2, reg);
+
+	ret = unl_genl_request(&unl, msg, NULL, NULL);
+	if (ret)
+		fprintf(stderr, "Failed to set reg %s: %s\n", reg, strerror(-ret));
+}
+
+static int mt76_add_iface(int phy, int argc, char **argv)
+{
+	struct nl_msg *msg;
+	char *name, cmd[64];
+	int ret;
+
+	mt76_set_tm_reg();
+
+	if (argc < 1)
+		return 1;
+
+	name = argv[0];
+	msg = unl_genl_msg(&unl, NL80211_CMD_NEW_INTERFACE, false);
+	/* TODO: Handle single wiphy radio index */
+	nla_put_u32(msg, NL80211_ATTR_WIPHY, phy);
+	nla_put_u32(msg, NL80211_ATTR_IFTYPE, NL80211_IFTYPE_MONITOR);
+	nla_put_string(msg, NL80211_ATTR_IFNAME, name);
+
+	ret = unl_genl_request(&unl, msg, NULL, NULL);
+	if (ret) {
+		fprintf(stderr, "nl80211 call failed: %s\n", strerror(-ret));
+		return ret;
+	}
+
+	sprintf(cmd, "ifconfig %s up", name);
+	system(cmd);
+
+	/* turn on testmode */
+	ret = mt76_set_state(phy, "idle");
+	return ret;
+}
+
+static int mt76_delete_iface(int phy, int argc, char **argv)
+{
+	unsigned int devidx;
+	struct nl_msg *msg;
+	char *name, cmd[64];
+	int ret;
+
+	if (argc < 1)
+		return 1;
+
+	name = argv[0];
+	devidx = if_nametoindex(name);
+	if (!devidx) {
+		fprintf(stderr, "Failed to find ifindex for %s: %s\n",
+			name, strerror(errno));
+		return 2;
+	}
+
+	/* turn off testmode before deleting interface */
+	ret = mt76_set_state(phy, "off");
+	if (ret)
+		return ret;
+
+	sprintf(cmd, "ifconfig %s down", name);
+	system(cmd);
+
+	/* delete interface */
+	msg = unl_genl_msg(&unl, NL80211_CMD_DEL_INTERFACE, false);
+	nla_put_u32(msg, NL80211_ATTR_WIPHY, phy);
+	nla_put_u32(msg, NL80211_ATTR_IFINDEX, devidx);
+
+	ret = unl_genl_request(&unl, msg, NULL, NULL);
+	if (ret)
+		fprintf(stderr, "nl80211 call failed: %s\n", strerror(-ret));
+
+	return ret;
+}
+
 int main(int argc, char **argv)
 {
 	const char *cmd, *phyname;
@@ -194,10 +315,16 @@ int main(int argc, char **argv)
 		ret = mt76_dump(phy, argc, argv);
 	else if (!strcmp(cmd, "set"))
 		ret = mt76_set(phy, argc, argv);
+	else if (!strcmp(cmd, "add"))
+		ret = mt76_add_iface(phy, argc, argv);
+	else if (!strcmp(cmd, "del"))
+		ret = mt76_delete_iface(phy, argc, argv);
 	else if (!strcmp(cmd, "eeprom"))
 		ret = mt76_eeprom(phy, argc, argv);
 	else if (!strcmp(cmd, "fwlog"))
 		ret = mt76_fwlog(phyname, argc, argv);
+	else if (!strcmp(cmd, "idxlog"))
+		ret = mt76_idxlog(phyname, argc, argv);
 	else
 		usage();
 
diff --git a/tools/mt76-test.h b/tools/mt76-test.h
index d2fafa86..b9d508c5 100644
--- a/tools/mt76-test.h
+++ b/tools/mt76-test.h
@@ -22,6 +22,8 @@
 #define EEPROM_FILE_PATH_FMT	"/tmp/mt76-test-%s"
 #define EEPROM_PART_SIZE	20480
 
+#define FWLOG_BUF_SIZE	1504
+
 struct nl_msg;
 struct nlattr;
 
@@ -61,5 +63,6 @@ extern unsigned char *eeprom_data;
 void usage(void);
 int mt76_eeprom(int phy, int argc, char **argv);
 int mt76_fwlog(const char *phyname, int argc, char **argv);
+int mt76_idxlog(const char *phyname, int argc, char **argv);
 
 #endif
diff --git a/trace.h b/trace.h
index c3d0ef8e..57c94c6b 100644
--- a/trace.h
+++ b/trace.h
@@ -101,6 +101,64 @@ DEFINE_EVENT(dev_txid_evt, mac_txdone,
 	TP_ARGS(dev, wcid, pktid)
 );
 
+TRACE_EVENT(mt76_rx_complete,
+	TP_PROTO(struct mt76_dev *dev, struct mt76_rx_status *status, bool sub),
+	TP_ARGS(dev, status, sub),
+
+	TP_STRUCT__entry(
+		DEV_ENTRY
+		__field(u16, seqno)
+		__field(u16, wcid)
+		__field(u8, first_amsdu)
+		__field(bool, sub)
+	),
+
+	TP_fast_assign(
+		strlcpy(__entry->wiphy_name,
+			wiphy_name(mt76_dev_phy(dev, status->phy_idx)->hw->wiphy),
+			MAXNAME);
+		__entry->seqno = status->seqno;
+		__entry->wcid = status->wcid ? status->wcid->idx : 0;
+		__entry->first_amsdu = status->first_amsdu;
+		__entry->sub = sub;
+	),
+
+	TP_printk(
+		DEV_PR_FMT " seqno: %u, wcid: %u, first_amsdu: %x, sub: %d",
+		DEV_PR_ARG, __entry->seqno, __entry->wcid, __entry->first_amsdu,
+		__entry->sub
+	)
+);
+
+TRACE_EVENT(mt76_rx_aggr_reorder,
+	TP_PROTO(struct mt76_dev *dev, struct mt76_wcid *wcid, u16 _head, u16 seqno, bool sn_less),
+	TP_ARGS(dev, wcid, _head, seqno, sn_less),
+
+	TP_STRUCT__entry(
+		DEV_ENTRY
+		__field(u16, wcid)
+		__field(u16, _head)
+		__field(u16, seqno)
+		__field(bool, sn_less)
+	),
+
+	TP_fast_assign(
+		strlcpy(__entry->wiphy_name,
+			wiphy_name(dev->phys[wcid->phy_idx]->hw->wiphy),
+			MAXNAME);
+		__entry->wcid = wcid->idx;
+		__entry->_head = _head;
+		__entry->seqno = seqno;
+		__entry->sn_less = sn_less;
+	),
+
+	TP_printk(
+		DEV_PR_FMT " wcid: %u, head: %u, seqno: %u, sn_less: %d",
+		DEV_PR_ARG, __entry->wcid, __entry->_head, __entry->seqno,
+		__entry->sn_less
+	)
+);
+
 #endif
 
 #undef TRACE_INCLUDE_PATH
diff --git a/tx.c b/tx.c
index af0c50c9..0a427d54 100644
--- a/tx.c
+++ b/tx.c
@@ -335,8 +335,14 @@ mt76_tx(struct mt76_phy *phy, struct ieee80211_sta *sta,
 	struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);
 	struct sk_buff_head *head;
 
+	spin_lock_bh(&phy->tx_dbg_stats.lock);
+	phy->tx_dbg_stats.tx_from_mac80211++;
+	spin_unlock_bh(&phy->tx_dbg_stats.lock);
 	if (mt76_testmode_enabled(phy)) {
 		ieee80211_free_txskb(phy->hw, skb);
+		spin_lock_bh(&phy->tx_dbg_stats.lock);
+		phy->tx_dbg_stats.tx_drop[MT_TX_DROP_IN_TESTMODE]++;
+		spin_unlock_bh(&phy->tx_dbg_stats.lock);
 		return;
 	}
 
@@ -352,8 +358,19 @@ mt76_tx(struct mt76_phy *phy, struct ieee80211_sta *sta,
 	if ((info->flags & IEEE80211_TX_CTL_TX_OFFCHAN) ||
 	    (info->control.flags & IEEE80211_TX_CTRL_DONT_USE_RATE_MASK))
 		head = &wcid->tx_offchannel;
-	else
+	else {
+		if (!wcid->tx_pending.prev || !wcid->tx_pending.next) {
+			dev_warn(phy->dev->dev, "Un-initialized STA %pM wcid %d in mt76_tx\n",
+				 sta->addr, wcid->idx);
+
+			spin_lock_bh(&phy->tx_dbg_stats.lock);
+			phy->tx_dbg_stats.tx_drop[MT_TX_DROP_WCID_NOT_INIT]++;
+			spin_unlock_bh(&phy->tx_dbg_stats.lock);
+			ieee80211_free_txskb(phy->hw, skb);
+			return;
+		}
 		head = &wcid->tx_pending;
+	}
 
 	spin_lock_bh(&head->lock);
 	__skb_queue_tail(head, skb);
@@ -382,6 +399,8 @@ mt76_txq_dequeue(struct mt76_phy *phy, struct mt76_txq *mtxq)
 	info = IEEE80211_SKB_CB(skb);
 	info->hw_queue |= FIELD_PREP(MT_TX_HW_QUEUE_PHY, phy->band_idx);
 
+	phy->dev->tx_dbg_stats.tx_from_mac80211++;
+
 	return skb;
 }
 
@@ -489,7 +508,7 @@ mt76_txq_send_burst(struct mt76_phy *phy, struct mt76_queue *q,
 
 	do {
 		if (test_bit(MT76_RESET, &phy->state) || phy->offchannel)
-			break;
+			return -EBUSY;
 
 		if (stop || mt76_txq_stopped(q))
 			break;
@@ -522,16 +541,24 @@ mt76_txq_send_burst(struct mt76_phy *phy, struct mt76_queue *q,
 static int
 mt76_txq_schedule_list(struct mt76_phy *phy, enum mt76_txq_id qid)
 {
+	struct mt76_queue *q = phy->q_tx[qid];
 	struct mt76_dev *dev = phy->dev;
 	struct ieee80211_txq *txq;
 	struct mt76_txq *mtxq;
 	struct mt76_wcid *wcid;
-	struct mt76_queue *q;
 	int ret = 0;
 
 	while (1) {
 		int n_frames = 0;
 
+		if (test_bit(MT76_RESET, &phy->state) || phy->offchannel)
+			return -EBUSY;
+
+		if (dev->queue_ops->tx_cleanup &&
+		    q->queued + 2 * MT_TXQ_FREE_THR >= q->ndesc) {
+			dev->queue_ops->tx_cleanup(dev, q, false);
+		}
+
 		txq = ieee80211_next_txq(phy->hw, qid);
 		if (!txq)
 			break;
@@ -541,16 +568,6 @@ mt76_txq_schedule_list(struct mt76_phy *phy, enum mt76_txq_id qid)
 		if (!wcid || test_bit(MT_WCID_FLAG_PS, &wcid->flags))
 			continue;
 
-		phy = mt76_dev_phy(dev, wcid->phy_idx);
-		if (test_bit(MT76_RESET, &phy->state) || phy->offchannel)
-			continue;
-
-		q = phy->q_tx[qid];
-		if (dev->queue_ops->tx_cleanup &&
-		    q->queued + 2 * MT_TXQ_FREE_THR >= q->ndesc) {
-			dev->queue_ops->tx_cleanup(dev, q, false);
-		}
-
 		if (mtxq->send_bar && mtxq->aggr) {
 			struct ieee80211_txq *txq = mtxq_to_txq(mtxq);
 			struct ieee80211_sta *sta = txq->sta;
@@ -580,7 +597,7 @@ void mt76_txq_schedule(struct mt76_phy *phy, enum mt76_txq_id qid)
 {
 	int len;
 
-	if (qid >= 4)
+	if (qid >= 4 || phy->offchannel)
 		return;
 
 	local_bh_disable();
@@ -622,6 +639,7 @@ mt76_txq_schedule_pending_wcid(struct mt76_phy *phy, struct mt76_wcid *wcid,
 		q = phy->q_tx[qid];
 		if (mt76_txq_stopped(q) || test_bit(MT76_RESET, &phy->state)) {
 			ret = -1;
+			phy->tx_dbg_stats.tx_drop[MT_TX_DROP_STOPPED_QUEUE]++;
 			break;
 		}
 
@@ -682,14 +700,9 @@ static void mt76_txq_schedule_pending(struct mt76_phy *phy)
 
 void mt76_txq_schedule_all(struct mt76_phy *phy)
 {
-	struct mt76_phy *main_phy = &phy->dev->phy;
 	int i;
 
 	mt76_txq_schedule_pending(phy);
-
-	if (phy != main_phy && phy->hw == main_phy->hw)
-		return;
-
 	for (i = 0; i <= MT_TXQ_BK; i++)
 		mt76_txq_schedule(phy, i);
 }
@@ -700,7 +713,6 @@ void mt76_tx_worker_run(struct mt76_dev *dev)
 	struct mt76_phy *phy;
 	int i;
 
-	mt76_txq_schedule_all(&dev->phy);
 	for (i = 0; i < ARRAY_SIZE(dev->phys); i++) {
 		phy = dev->phys[i];
 		if (!phy)
@@ -756,6 +768,9 @@ void mt76_wake_tx_queue(struct ieee80211_hw *hw, struct ieee80211_txq *txq)
 	struct mt76_phy *phy = hw->priv;
 	struct mt76_dev *dev = phy->dev;
 
+	if (!test_bit(MT76_STATE_RUNNING, &phy->state))
+		return;
+
 	mt76_worker_schedule(&dev->tx_worker);
 }
 EXPORT_SYMBOL_GPL(mt76_wake_tx_queue);
@@ -842,12 +857,16 @@ EXPORT_SYMBOL_GPL(__mt76_set_tx_blocked);
 
 int mt76_token_consume(struct mt76_dev *dev, struct mt76_txwi_cache **ptxwi)
 {
-	int token;
+	int token, start = 0;
+
+	if (mtk_wed_device_active(&dev->mmio.wed))
+		start = dev->mmio.wed.wlan.nbuf;
 
 	spin_lock_bh(&dev->token_lock);
 
-	token = idr_alloc(&dev->token, *ptxwi, 0, dev->token_size, GFP_ATOMIC);
-	if (token >= 0)
+	token = idr_alloc(&dev->token, *ptxwi, start, start + dev->token_size,
+			  GFP_ATOMIC);
+	if (token >= start)
 		dev->token_count++;
 
 #ifdef CONFIG_NET_MEDIATEK_SOC_WED
@@ -866,16 +885,16 @@ int mt76_token_consume(struct mt76_dev *dev, struct mt76_txwi_cache **ptxwi)
 EXPORT_SYMBOL_GPL(mt76_token_consume);
 
 int mt76_rx_token_consume(struct mt76_dev *dev, void *ptr,
-			  struct mt76_txwi_cache *t, dma_addr_t phys)
+			  struct mt76_rxwi_cache *r, dma_addr_t phys)
 {
 	int token;
 
 	spin_lock_bh(&dev->rx_token_lock);
-	token = idr_alloc(&dev->rx_token, t, 0, dev->rx_token_size,
+	token = idr_alloc(&dev->rx_token, r, 0, dev->rx_token_size,
 			  GFP_ATOMIC);
 	if (token >= 0) {
-		t->ptr = ptr;
-		t->dma_addr = phys;
+		r->ptr = ptr;
+		r->dma_addr = phys;
 	}
 	spin_unlock_bh(&dev->rx_token_lock);
 
@@ -912,15 +931,15 @@ mt76_token_release(struct mt76_dev *dev, int token, bool *wake)
 }
 EXPORT_SYMBOL_GPL(mt76_token_release);
 
-struct mt76_txwi_cache *
+struct mt76_rxwi_cache *
 mt76_rx_token_release(struct mt76_dev *dev, int token)
 {
-	struct mt76_txwi_cache *t;
+	struct mt76_rxwi_cache *r;
 
 	spin_lock_bh(&dev->rx_token_lock);
-	t = idr_remove(&dev->rx_token, token);
+	r = idr_remove(&dev->rx_token, token);
 	spin_unlock_bh(&dev->rx_token_lock);
 
-	return t;
+	return r;
 }
 EXPORT_SYMBOL_GPL(mt76_rx_token_release);
diff --git a/util.c b/util.c
index 95b3dc96..d6c01a2d 100644
--- a/util.c
+++ b/util.c
@@ -64,7 +64,7 @@ int mt76_wcid_alloc(u32 *mask, int size)
 }
 EXPORT_SYMBOL_GPL(mt76_wcid_alloc);
 
-int mt76_get_min_avg_rssi(struct mt76_dev *dev, u8 phy_idx)
+int mt76_get_min_avg_rssi(struct mt76_dev *dev, bool ext_phy)
 {
 	struct mt76_wcid *wcid;
 	int i, j, min_rssi = 0;
@@ -75,16 +75,20 @@ int mt76_get_min_avg_rssi(struct mt76_dev *dev, u8 phy_idx)
 
 	for (i = 0; i < ARRAY_SIZE(dev->wcid_mask); i++) {
 		u32 mask = dev->wcid_mask[i];
+		u32 phy_mask = dev->wcid_phy_mask[i];
 
 		if (!mask)
 			continue;
 
-		for (j = i * 32; mask; j++, mask >>= 1) {
+		for (j = i * 32; mask; j++, mask >>= 1, phy_mask >>= 1) {
 			if (!(mask & 1))
 				continue;
 
+			if (!!(phy_mask & 1) != ext_phy)
+				continue;
+
 			wcid = rcu_dereference(dev->wcid[j]);
-			if (!wcid || wcid->phy_idx != phy_idx)
+			if (!wcid)
 				continue;
 
 			spin_lock(&dev->rx_lock);
diff --git a/wed.c b/wed.c
index f89e4537..9065a9a6 100644
--- a/wed.c
+++ b/wed.c
@@ -9,22 +9,43 @@
 void mt76_wed_release_rx_buf(struct mtk_wed_device *wed)
 {
 	struct mt76_dev *dev = container_of(wed, struct mt76_dev, mmio.wed);
+	struct page *page;
 	int i;
 
 	for (i = 0; i < dev->rx_token_size; i++) {
-		struct mt76_txwi_cache *t;
+		struct mt76_rxwi_cache *r;
 
-		t = mt76_rx_token_release(dev, i);
-		if (!t || !t->ptr)
+		r = mt76_rx_token_release(dev, i);
+		if (!r || !r->ptr)
 			continue;
 
-		mt76_put_page_pool_buf(t->ptr, false);
-		t->ptr = NULL;
+		mt76_put_page_pool_buf(r->ptr, false);
+		r->ptr = NULL;
 
-		mt76_put_rxwi(dev, t);
+		mt76_put_rxwi(dev, r);
 	}
 
 	mt76_free_pending_rxwi(dev);
+
+	mt76_for_each_q_rx(dev, i) {
+		struct mt76_queue *q = &dev->q_rx[i];
+
+		if (mt76_queue_is_wed_rx(q)) {
+			if (!q->rx_page.va)
+				continue;
+
+			page = virt_to_page(q->rx_page.va);
+			__page_frag_cache_drain(page, q->rx_page.pagecnt_bias);
+			memset(&q->rx_page, 0, sizeof(q->rx_page));
+		}
+	}
+
+	if (!wed->rx_buf_ring.rx_page.va)
+		return;
+
+	page = virt_to_page(wed->rx_buf_ring.rx_page.va);
+	__page_frag_cache_drain(page, wed->rx_buf_ring.rx_page.pagecnt_bias);
+	memset(&wed->rx_buf_ring.rx_page, 0, sizeof(wed->rx_buf_ring.rx_page));
 }
 EXPORT_SYMBOL_GPL(mt76_wed_release_rx_buf);
 
@@ -35,7 +56,7 @@ u32 mt76_wed_init_rx_buf(struct mtk_wed_device *wed, int size)
 	struct mtk_wed_bm_desc *desc = wed->rx_buf_ring.desc;
 	struct mt76_queue *q = &dev->q_rx[MT_RXQ_MAIN];
 	int i, len = SKB_WITH_OVERHEAD(q->buf_size);
-	struct mt76_txwi_cache *t = NULL;
+	struct mt76_rxwi_cache *r = NULL;
 
 	for (i = 0; i < size; i++) {
 		enum dma_data_direction dir;
@@ -44,8 +65,8 @@ u32 mt76_wed_init_rx_buf(struct mtk_wed_device *wed, int size)
 		int token;
 		void *buf;
 
-		t = mt76_get_rxwi(dev);
-		if (!t)
+		r = mt76_get_rxwi(dev);
+		if (!r)
 			goto unmap;
 
 		buf = mt76_get_page_pool_buf(q, &offset, q->buf_size);
@@ -57,7 +78,7 @@ u32 mt76_wed_init_rx_buf(struct mtk_wed_device *wed, int size)
 		dma_sync_single_for_device(dev->dma_dev, addr, len, dir);
 
 		desc->buf0 = cpu_to_le32(addr);
-		token = mt76_rx_token_consume(dev, buf, t, addr);
+		token = mt76_rx_token_consume(dev, buf, r, addr);
 		if (token < 0) {
 			mt76_put_page_pool_buf(buf, false);
 			goto unmap;
@@ -74,8 +95,8 @@ u32 mt76_wed_init_rx_buf(struct mtk_wed_device *wed, int size)
 	return 0;
 
 unmap:
-	if (t)
-		mt76_put_rxwi(dev, t);
+	if (r)
+		mt76_put_rxwi(dev, r);
 	mt76_wed_release_rx_buf(wed);
 
 	return -ENOMEM;
@@ -87,7 +108,7 @@ int mt76_wed_offload_enable(struct mtk_wed_device *wed)
 	struct mt76_dev *dev = container_of(wed, struct mt76_dev, mmio.wed);
 
 	spin_lock_bh(&dev->token_lock);
-	dev->token_size = wed->wlan.token_start;
+	dev->token_size = MT76_WED_SW_TOKEN_SIZE;
 	spin_unlock_bh(&dev->token_lock);
 
 	return !wait_event_timeout(dev->tx_wait, !dev->wed_token_count, HZ);
@@ -122,7 +143,7 @@ int mt76_wed_dma_setup(struct mt76_dev *dev, struct mt76_queue *q, bool reset)
 	case MT76_WED_Q_TXFREE:
 		/* WED txfree queue needs ring to be initialized before setup */
 		q->flags = 0;
-		mt76_dma_queue_reset(dev, q);
+		mt76_dma_queue_reset(dev, q, true);
 		mt76_dma_rx_fill(dev, q, false);
 
 		ret = mtk_wed_device_txfree_ring_setup(q->wed, q->regs);
@@ -151,7 +172,7 @@ int mt76_wed_dma_setup(struct mt76_dev *dev, struct mt76_queue *q, bool reset)
 		break;
 	case MT76_WED_RRO_Q_IND:
 		q->flags &= ~MT_QFLAG_WED;
-		mt76_dma_queue_reset(dev, q);
+		mt76_dma_queue_reset(dev, q, true);
 		mt76_dma_rx_fill(dev, q, false);
 		mtk_wed_device_ind_rx_ring_setup(q->wed, q->regs);
 		break;
@@ -171,7 +192,7 @@ void mt76_wed_offload_disable(struct mtk_wed_device *wed)
 	struct mt76_dev *dev = container_of(wed, struct mt76_dev, mmio.wed);
 
 	spin_lock_bh(&dev->token_lock);
-	dev->token_size = dev->drv->token_size;
+	dev->token_size = MT76_WED_SW_TOKEN_SIZE;
 	spin_unlock_bh(&dev->token_lock);
 }
 EXPORT_SYMBOL_GPL(mt76_wed_offload_disable);
-- 
2.45.2

