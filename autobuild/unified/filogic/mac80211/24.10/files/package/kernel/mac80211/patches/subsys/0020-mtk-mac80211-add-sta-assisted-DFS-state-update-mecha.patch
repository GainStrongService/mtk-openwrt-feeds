From 23366c1c8615d302c9a66133472a19048357d5e3 Mon Sep 17 00:00:00 2001
From: StanleyYP Wang <StanleyYP.Wang@mediatek.com>
Date: Mon, 20 Feb 2023 14:25:24 +0800
Subject: [PATCH 020/107] mtk: mac80211: add sta-assisted DFS state update
 mechanism

Signed-off-by: StanleyYP Wang <StanleyYP.Wang@mediatek.com>

Add cfg80211_any_wiphy_oper_chan check before clearing dfs state.
This avoids STA clearing the dfs state of the channel, which still has
APs/offchain operating on the it.

If the CSA countdown time > REG_PRE_CAC_EXPIRY_GRACE_MS (2 sec), then
the the DFS state set by the STA might expire when the AP calls
cfg80211_sched_dfs_chan_update to update the state.
This leads to the extender AP starting CAC after switching to DFS
channel, while the root AP has already complete the CAC.
Therefore, this fixup updates the dfs_state_last_available to the time
when CSA is completed to avoid the state from expiring.

Signed-off-by: StanleyYP Wang <StanleyYP.Wang@mediatek.com>
---
 include/net/cfg80211.h       | 16 +++++++
 include/uapi/linux/nl80211.h |  6 +++
 net/mac80211/mlme.c          | 15 +++++++
 net/wireless/ap.c            |  3 +-
 net/wireless/chan.c          | 86 +++++++++++++++++++++++++++++++++++-
 net/wireless/core.h          |  3 +-
 6 files changed, 125 insertions(+), 4 deletions(-)

diff --git a/include/net/cfg80211.h b/include/net/cfg80211.h
index fc58df6d..5181d050 100644
--- a/include/net/cfg80211.h
+++ b/include/net/cfg80211.h
@@ -8891,6 +8891,22 @@ void cfg80211_cac_event(struct net_device *netdev,
 			enum nl80211_radar_event event, gfp_t gfp,
 			unsigned int link_id);
 
+/**
+ * cfg80211_sta_update_dfs_state - Update channel's DFS state during STA channel switch,
+ *				   association, and disassociation
+ * @wdev: the wireless device
+ * @bss_chandef: the current BSS channel definition
+ * @csa_chandef: the CSA channel definition
+ * @csa_time: the expected CSA countdown complete time
+ * @associated: whether STA is during association or disassociation process
+ *
+ */
+void cfg80211_sta_update_dfs_state(struct wireless_dev *wdev,
+				   const struct cfg80211_chan_def *bss_chandef,
+				   const struct cfg80211_chan_def *csa_chandef,
+				   unsigned long csa_time,
+				   bool associated);
+
 /**
  * cfg80211_background_cac_abort - Channel Availability Check offchan abort event
  * @wiphy: the wiphy
diff --git a/include/uapi/linux/nl80211.h b/include/uapi/linux/nl80211.h
index ddcc4cda..e73b9f25 100644
--- a/include/uapi/linux/nl80211.h
+++ b/include/uapi/linux/nl80211.h
@@ -6892,6 +6892,10 @@ enum nl80211_smps_mode {
  *	applicable for ETSI dfs domain where pre-CAC is valid for ever.
  * @NL80211_RADAR_CAC_STARTED: Channel Availability Check has been started,
  *	should be generated by HW if NL80211_EXT_FEATURE_DFS_OFFLOAD is enabled.
+ * @NL80211_RADAR_STA_CAC_SKIPPED: STA set the DFS state to available
+ *	when receiving CSA/assoc resp
+ * @NL80211_RADAR_STA_CAC_EXPIRED: STA set the DFS state to usable
+ *	when STA is disconnected or leaving the channel
  */
 enum nl80211_radar_event {
 	NL80211_RADAR_DETECTED,
@@ -6900,6 +6904,8 @@ enum nl80211_radar_event {
 	NL80211_RADAR_NOP_FINISHED,
 	NL80211_RADAR_PRE_CAC_EXPIRED,
 	NL80211_RADAR_CAC_STARTED,
+	NL80211_RADAR_STA_CAC_SKIPPED,
+	NL80211_RADAR_STA_CAC_EXPIRED,
 };
 
 /**
diff --git a/net/mac80211/mlme.c b/net/mac80211/mlme.c
index 75209369..ae16e63d 100644
--- a/net/mac80211/mlme.c
+++ b/net/mac80211/mlme.c
@@ -2889,6 +2889,12 @@ ieee80211_sta_process_chanswitch(struct ieee80211_link_data *link,
 			       TU_TO_JIFFIES((max_t(int, csa_ie.count, 1) - 1) *
 					     link->conf->beacon_int);
 
+	cfg80211_sta_update_dfs_state(&sdata->wdev,
+				      &link->conf->chanreq.oper,
+				      &link->csa.chanreq.oper,
+				      link->u.mgd.csa.time,
+				      sdata->vif.cfg.assoc);
+
 	if (ieee80211_vif_link_active(&sdata->vif, link->link_id) &&
 	    local->ops->channel_switch) {
 		/*
@@ -4116,6 +4122,10 @@ static void ieee80211_set_disassoc(struct ieee80211_sub_if_data *sdata,
 		link = sdata_dereference(sdata->link[link_id], sdata);
 		if (!link)
 			continue;
+
+		cfg80211_sta_update_dfs_state(&sdata->wdev,
+					      &link->conf->chanreq.oper,
+					      NULL, 0, sdata->vif.cfg.assoc);
 		ieee80211_link_release_channel(link);
 	}
 
@@ -6446,6 +6456,11 @@ static void ieee80211_rx_mgmt_assoc_resp(struct ieee80211_sub_if_data *sdata,
 		for (ac = 0; ac < IEEE80211_NUM_ACS; ac++)
 			if (link->tx_conf[ac].uapsd)
 				resp.uapsd_queues |= ieee80211_ac_to_qos_mask[ac];
+
+		if (status_code == WLAN_STATUS_SUCCESS)
+			cfg80211_sta_update_dfs_state(&sdata->wdev,
+						      &link->conf->chanreq.oper,
+						      NULL, 0, sdata->vif.cfg.assoc);
 	}
 
 	if (ieee80211_vif_is_mld(&sdata->vif)) {
diff --git a/net/wireless/ap.c b/net/wireless/ap.c
index 9cd0ab4d..e4f06e93 100644
--- a/net/wireless/ap.c
+++ b/net/wireless/ap.c
@@ -31,7 +31,8 @@ static int ___cfg80211_stop_ap(struct cfg80211_registered_device *rdev,
 		return -ENOENT;
 
 	cfg80211_update_last_available(wdev->wiphy,
-				       &wdev->links[link_id].ap.chandef);
+				       &wdev->links[link_id].ap.chandef,
+				       0);
 
 	err = rdev_stop_ap(rdev, dev, link_id);
 	if (!err) {
diff --git a/net/wireless/chan.c b/net/wireless/chan.c
index 45a921a2..9aa8b715 100644
--- a/net/wireless/chan.c
+++ b/net/wireless/chan.c
@@ -14,6 +14,7 @@
 #include <net/cfg80211.h>
 #include "core.h"
 #include "rdev-ops.h"
+#include "nl80211.h"
 
 static bool cfg80211_valid_60g_freq(u32 freq)
 {
@@ -1032,7 +1033,8 @@ static bool cfg80211_chandef_dfs_available(struct wiphy *wiphy,
 }
 
 void cfg80211_update_last_available(struct wiphy *wiphy,
-				    const struct cfg80211_chan_def *chandef)
+				    const struct cfg80211_chan_def *chandef,
+				    unsigned long csa_time)
 {
 	struct ieee80211_channel *c;
 	int width;
@@ -1042,11 +1044,15 @@ void cfg80211_update_last_available(struct wiphy *wiphy,
 		return;
 
 	for_each_subchan(chandef, freq, cf) {
+		unsigned long time = jiffies;
+
 		c = ieee80211_get_channel_khz(wiphy, freq);
 		if (!c)
 			continue;
 
-		c->dfs_state_last_available = jiffies;
+		if (csa_time)
+			time = csa_time;
+		c->dfs_state_last_available = time;
 	}
 }
 
@@ -1574,6 +1580,82 @@ bool cfg80211_any_usable_channels(struct wiphy *wiphy,
 }
 EXPORT_SYMBOL(cfg80211_any_usable_channels);
 
+static void cfg80211_sta_radar_notify(struct wiphy *wiphy,
+				      const struct cfg80211_chan_def *chandef,
+				      enum nl80211_radar_event event)
+{
+	struct wireless_dev *wdev;
+
+	list_for_each_entry(wdev, &wiphy->wdev_list, list) {
+		if (cfg80211_chandef_dfs_required(wiphy, chandef, wdev->iftype) > 0) {
+			nl80211_radar_notify(wiphy_to_rdev(wiphy), chandef,
+					     event, wdev->netdev, GFP_KERNEL);
+			return;
+		}
+	}
+}
+
+void cfg80211_sta_update_dfs_state(struct wireless_dev *wdev,
+				   const struct cfg80211_chan_def *bss_chandef,
+				   const struct cfg80211_chan_def *csa_chandef,
+				   unsigned long csa_time,
+				   bool associated)
+{
+	struct wiphy *wiphy = wdev->wiphy;
+	struct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);
+	bool csa_active = !!csa_chandef;
+	enum nl80211_dfs_state dfs_state = NL80211_DFS_USABLE;
+	enum nl80211_radar_event event = NL80211_RADAR_STA_CAC_EXPIRED;
+
+	lockdep_assert_wiphy(wdev->wiphy);
+
+	if (!bss_chandef || !bss_chandef->chan ||
+	    bss_chandef->chan->band != NL80211_BAND_5GHZ)
+		return;
+
+	/* assume csa channel is cac completed */
+	if (csa_active &&
+	    (cfg80211_chandef_dfs_usable(wiphy, csa_chandef) ||
+	    cfg80211_chandef_dfs_available(wiphy, csa_chandef))) {
+		cfg80211_set_dfs_state(wiphy, csa_chandef, NL80211_DFS_AVAILABLE);
+		/* avoid the dfs state from expired during csa countdown */
+		cfg80211_update_last_available(wiphy, csa_chandef, csa_time);
+		nl80211_radar_notify(rdev, csa_chandef,
+				     NL80211_RADAR_STA_CAC_SKIPPED, GFP_KERNEL);
+		netdev_info(wdev->netdev, "Set CSA channel's DFS state to available\n");
+	}
+
+	/* avoid updating the dfs state during nop */
+	if (!cfg80211_chandef_dfs_usable(wdev->wiphy, bss_chandef) &&
+	    !cfg80211_chandef_dfs_available(wdev->wiphy, bss_chandef))
+		return;
+
+	if (associated && !csa_active) {
+		dfs_state = NL80211_DFS_AVAILABLE;
+		event = NL80211_RADAR_STA_CAC_SKIPPED;
+	}
+
+	/* avoid setting the dfs state to usable
+	 * when other interfaces still operate on this channel
+	 */
+	if (dfs_state == NL80211_DFS_USABLE &&
+	    (cfg80211_is_wiphy_oper_chan(wdev->wiphy, bss_chandef->chan) ||
+	     cfg80211_offchan_chain_is_active(wiphy_to_rdev(wdev->wiphy),
+					      bss_chandef->chan)))
+		return;
+
+	cfg80211_set_dfs_state(wdev->wiphy, bss_chandef, dfs_state);
+	cfg80211_sta_radar_notify(wdev->wiphy, bss_chandef, event);
+
+	if (csa_active)
+		netdev_info(wdev->netdev, "Set origin channel's DFS state to usable\n");
+	else
+		netdev_info(wdev->netdev, "Set BSS channel's DFS state to %s due to %s\n",
+			    (dfs_state == NL80211_DFS_USABLE) ? "usable" : "available",
+			    associated ? "association" : "disassociation");
+}
+EXPORT_SYMBOL(cfg80211_sta_update_dfs_state);
+
 struct cfg80211_chan_def *wdev_chandef(struct wireless_dev *wdev,
 				       unsigned int link_id)
 {
diff --git a/net/wireless/core.h b/net/wireless/core.h
index ef6ac445..f3e2ec60 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -478,7 +478,8 @@ void cfg80211_set_dfs_state(struct wiphy *wiphy,
 
 void cfg80211_dfs_channels_update_work(struct work_struct *work);
 void cfg80211_update_last_available(struct wiphy *wiphy,
-				    const struct cfg80211_chan_def *chandef);
+				    const struct cfg80211_chan_def *chandef,
+				    unsigned long csa_time);
 
 void cfg80211_sched_dfs_chan_update(struct cfg80211_registered_device *rdev);
 
-- 
2.45.2

