From c449f7d8570b4783d2bb79228a374627dc2201c8 Mon Sep 17 00:00:00 2001
From: Peter Chiu <chui-hao.chiu@mediatek.com>
Date: Tue, 27 Aug 2024 18:05:37 +0800
Subject: [PATCH 129/146] mtk: mt76: mt7990: use device id macro in internal
 debug file

This is a preliminary patch to support mt7990 chipset.

Signed-off-by: Peter Chiu <chui-hao.chiu@mediatek.com>

mtk: mt76: mt7990: add new device id for mt7990 chipset

Signed-off-by: Peter Chiu <chui-hao.chiu@mediatek.com>

mtk: mt76: mt7990: enable TX/RX for MT7990

Support TXD assignment for MT7990.

Signed-off-by: Benjamin Lin <benjamin-jw.lin@mediatek.com>

mtk: mt76: mt7990: add fw/eeprom/sku support

1. Add mt7990 fw/eeprom definition
2. Add mt7990 sku/part number parsing
3. Add mt7990 efuse FT merge support

Signed-off-by: StanleyYP Wang <StanleyYP.Wang@mediatek.com>

mtk: mt76: mt7990: add fwdl support

Add mt7990 fwdl support

Signed-off-by: StanleyYP Wang <StanleyYP.Wang@mediatek.com>

mtk: mt76: mt7990: Increase pp auto mode listen time

Add the time is prevent for 5g link doing channel switch triggered by fw
event before 6g link setup is not finished. The case makes hostapd couldn't
setup mld successfully.

Change pp detection theshold align for 5 seconds timer.

Signed-off-by: Allen Ye <allen.ye@mediatek.com>

mtk: mt76: mt7990: add CR for mt7990

Add CR for mt7990
1. mt7990_offs is checked and revised
2. mt7996_reg_base is identical in both mt7990 and mt7996/mt7992.
3. mt7996_reg_map is checked and revised
4. The CRs in mt7996_mac_init_band are identical
5. The CRs in mt7996_configure_filter are identical
6. The flow & CRs of l1/l2/cbtop remapping are checked and revised

Signed-off-by: StanleyYP Wang <StanleyYP.Wang@mediatek.com>

mtk: mt76: mt7990: add testmode support

mt7990 does not support mem dpd cal, so refactor prek flow to support
both of the following cases.
1. mt7996/mt7992: has mem dpd cal
2. mt7990: no mem dpd cal, use legacy dpd cal for BW > 20 instead

Signed-off-by: StanleyYP Wang <StanleyYP.Wang@mediatek.com>

mtk: mt76: mt7990: modify mcu command to support mt7990 chipset

The mt7990 does not have WA so send command to wm directly and
change wa commands to wm command.

Although WA is removed from mt7990, the WM still use mcu command destination
to check whether handle command or not.
Fix the mcu command by the following rules.
- If it was handled by WM only, use macro MCU_WM_UNI_CMD.
- If it was handled by WA only, use macro MCU_WA_UNI_CMD.
- If it was handled by both WA and WM, use macro MCU_WMWA_UNI_CMD.

Above rules should be followed by mt7996 and mt7992 so this patch is
compatible to mt7996 and mt7992.

Signed-off-by: Peter Chiu <chui-hao.chiu@mediatek.com>

mtk: mt76: mt7990: modify dma ring for removing wa

Modify dma ring for removing wa
Avoid setting wa mcu command

Signed-off-by: StanleyYP Wang <StanleyYP.Wang@mediatek.com>

mtk: mt76: mt7990: add mt7990 support for debugfs

Revise the following debugfs
1. tr_info
2. ple_info
3. pse_info
4. mib_info

Signed-off-by: StanleyYP Wang <StanleyYP.Wang@mediatek.com>

mtk: mt76: mt7990: revise txfree format for mt7990

In mt7990, a new txfree format (ver7) is used.
The differences between ver5 (used by mt7996/mt7992) and ver7 are listed below.
1. Add TID(bit 11..8) and PID(bit 7..0) in DW2.
2. An additional DW is added for TXD release timestamp, TXD release period from
queue head, and PPDU RTS TX count. This DW also sets the Pair bit(bit 31), so skip
it temporarily to avoid misparsing.

Signed-off-by: StanleyYP Wang <StanleyYP.Wang@mediatek.com>

mtk: mt76: mt7990: add unicmd for removing WA

Add the following commands
1. MCU_WA_PARAM_CMD(QUERY) => SDO command, tag UNI_CMD_SDO_QUERY
2. MCU_WA_PARAM_CMD(SET) => SDO command, tag UNI_CMD_SDO_SET
3. QUERY MCU_WA_PARAM_BSS_ACQ_PKT_CNT => SDO command, tag UNI_CMD_SDO_GET_BSS_ACQ_PKT_NUM
4. MCU_EXT_EVENT_BSS_ACQ_PKT_CNT => SDO event, tag UNI_EVENT_SDO_BSS_ACQ_PKT_CNT
5. MCU_WA_EXT_CMD(CP_SUPPORT) => SDO command, tag UNI_CMD_SDO_CP_MODE
6. MCU_WA_EXT_CMD(SET_QOS_MAP) => SDO command, tag UNI_CMD_SDO_SET_QOS_MAP

Signed-off-by: Peter Chiu <chui-hao.chiu@mediatek.com>

mtk: mt76: mt7990: refactor platfrom related configuration

1. Use enum to represent txfree path.
1. Use enum to represent bypass rro option.
3. Add some debug logs.

Signed-off-by: Peter Chiu <chui-hao.chiu@mediatek.com>

mtk: mt76: mt7990: add DMA ring for TxFree

Signed-off-by: Peter Chiu <chui-hao.chiu@mediatek.com>

mtk: mt76: mt7990: modify wtbl CRs for MT7990

Signed-off-by: Peter Chiu <chui-hao.chiu@mediatek.com>

mtk: mt76: mt7990: rename MT_RXQ_BAND1_CTRL to MT_RXQ_EXT_CTRL

The MT_RXQ_EXT_CTRL is ring extension control register for prefetch which
is unrelated to the band. Use MT_RXQ_EXT_CTRL instead of
MT_RXQ_BAND1_CTRL to avoid confusion.

Signed-off-by: Peter Chiu <chui-hao.chiu@mediatek.com>

mtk: mt76: mt7990: modify wtbl debug CRs for mt7990

This patch is based on the following commit:
https://gerrit.mediatek.inc/c/gateway/WiFi7/mac80211/mt76/+/9698501

Signed-off-by: StanleyYP Wang <StanleyYP.Wang@mediatek.com>

mtk: mt76: mt7990: refactor prefetch

The mt7996 different prefetch value with mt7992 and mt7990.
Set the correct prefetch size for each chip.

Signed-off-by: Peter Chiu <chui-hao.chiu@mediatek.com>

mtk: mt76: mt7990: add configuration to suppot wed and rro

Signed-off-by: Peter Chiu <chui-hao.chiu@mediatek.com>

mtk: mt76: mt7990: set specific data frames as management frame

The SDO would drop all non-mgmt packets before authorized so the EAPOL
and 4 address null func cannot be sent. Set these frames as management
frame to prevent SDO dropping it.

mtk: mt76: mt7990: change hw capability for mt7990

Signed-off-by: Peter Chiu <chui-hao.chiu@mediatek.com>
---
 mt76_connac.h        |   7 +-
 mt76_connac3_mac.h   |   1 +
 mt76_connac_mcu.c    |   3 +-
 mt76_connac_mcu.h    |   2 +
 mt7996/coredump.c    |   2 +
 mt7996/dma.c         | 200 +++++++++++++--------
 mt7996/eeprom.c      |  21 ++-
 mt7996/eeprom.h      |  17 +-
 mt7996/init.c        |  85 +++++----
 mt7996/mac.c         |  49 +++++-
 mt7996/main.c        |   5 +-
 mt7996/mcu.c         | 410 ++++++++++++++++++++++++++++++++++---------
 mt7996/mcu.h         |  40 ++++-
 mt7996/mmio.c        | 238 +++++++++++++++++++++----
 mt7996/mt7996.h      |  44 ++++-
 mt7996/mtk_debug.h   | 146 +++++++++++++--
 mt7996/mtk_debugfs.c | 304 ++++++++++++++++++++++----------
 mt7996/mtk_mcu.c     |   2 +-
 mt7996/mtk_mcu.h     |   4 +-
 mt7996/pci.c         |  15 +-
 mt7996/regs.h        |  52 ++++--
 mt7996/testmode.c    |  28 ++-
 mt7996/vendor.c      |  10 +-
 testmode.c           |   2 +-
 24 files changed, 1321 insertions(+), 366 deletions(-)

diff --git a/mt76_connac.h b/mt76_connac.h
index 45597947..192dcc37 100644
--- a/mt76_connac.h
+++ b/mt76_connac.h
@@ -232,9 +232,14 @@ static inline bool is_mt7992(struct mt76_dev *dev)
 	return mt76_chip(dev) == 0x7992;
 }
 
+static inline bool is_mt7990(struct mt76_dev *dev)
+{
+	return mt76_chip(dev) == 0x7993;
+}
+
 static inline bool is_mt799x(struct mt76_dev *dev)
 {
-	return is_mt7996(dev) || is_mt7992(dev);
+	return is_mt7996(dev) || is_mt7992(dev) || is_mt7990(dev);
 }
 
 static inline bool is_mt7622(struct mt76_dev *dev)
diff --git a/mt76_connac3_mac.h b/mt76_connac3_mac.h
index 4e8d64a9..3f34c47b 100644
--- a/mt76_connac3_mac.h
+++ b/mt76_connac3_mac.h
@@ -290,6 +290,7 @@ enum {
 #define MT_TXD6_TX_RATE			GENMASK(21, 16)
 #define MT_TXD6_TIMESTAMP_OFS_EN	BIT(15)
 #define MT_TXD6_TIMESTAMP_OFS_IDX	GENMASK(14, 10)
+#define MT_TXD6_TID_ADDBA		GENMASK(10, 8)
 #define MT_TXD6_MSDU_CNT		GENMASK(9, 4)
 #define MT_TXD6_MSDU_CNT_V2		GENMASK(15, 10)
 #define MT_TXD6_DIS_MAT			BIT(3)
diff --git a/mt76_connac_mcu.c b/mt76_connac_mcu.c
index d33bb61f..5094d821 100644
--- a/mt76_connac_mcu.c
+++ b/mt76_connac_mcu.c
@@ -67,8 +67,7 @@ int mt76_connac_mcu_init_download(struct mt76_dev *dev, u32 addr, u32 len,
 	if ((!is_connac_v1(dev) && addr == MCU_PATCH_ADDRESS) ||
 	    (is_mt7921(dev) && addr == 0x900000) ||
 	    (is_mt7925(dev) && (addr == 0x900000 || addr == 0xe0002800)) ||
-	    (is_mt7996(dev) && addr == 0x900000) ||
-	    (is_mt7992(dev) && addr == 0x900000))
+	    (is_mt799x(dev) && addr == 0x900000))
 		cmd = MCU_CMD(PATCH_START_REQ);
 	else
 		cmd = MCU_CMD(TARGET_ADDRESS_LEN_REQ);
diff --git a/mt76_connac_mcu.h b/mt76_connac_mcu.h
index acb56d27..8bfc1688 100644
--- a/mt76_connac_mcu.h
+++ b/mt76_connac_mcu.h
@@ -1082,6 +1082,7 @@ enum {
 	MCU_UNI_EVENT_ALL_STA_INFO = 0x6e,
 	MCU_UNI_EVENT_BSS_INFO = 0x74,
 	MCU_UNI_EVENT_MLD = 0x81,
+	MCU_UNI_EVENT_SDO = 0x83,
 };
 
 #define MCU_UNI_CMD_EVENT			BIT(1)
@@ -1330,6 +1331,7 @@ enum {
 	MCU_UNI_CMD_PTA_3WIRE_CTRL = 0x78,
 	MCU_UNI_CMD_MLD = 0x82,
 	MCU_UNI_CMD_PEER_MLD = 0x83,
+	MCU_UNI_CMD_SDO = 0x88,
 };
 
 enum {
diff --git a/mt7996/coredump.c b/mt7996/coredump.c
index 9f4b14ce..a724f4fc 100644
--- a/mt7996/coredump.c
+++ b/mt7996/coredump.c
@@ -126,6 +126,8 @@ mt7996_coredump_get_mem_layout(struct mt7996_dev *dev, u8 type, u32 *num)
 		}
 		*num = ARRAY_SIZE(mt7992_wm_mem_regions);
 		return &mt7992_wm_mem_regions[0];
+	case MT7990_DEVICE_ID:
+		/* Todo: add mt7990 support */
 	default:
 		return NULL;
 	}
diff --git a/mt7996/dma.c b/mt7996/dma.c
index 66ced49c..61e5da75 100644
--- a/mt7996/dma.c
+++ b/mt7996/dma.c
@@ -63,20 +63,31 @@ static void mt7996_dma_config(struct mt7996_dev *dev)
 
 	/* rx queue */
 	RXQ_CONFIG(MT_RXQ_MCU, WFDMA0, MT_INT_RX_DONE_WM, MT7996_RXQ_MCU_WM);
+	/* In griffin, rx ring 1 is for SDO instead */
 	RXQ_CONFIG(MT_RXQ_MCU_WA, WFDMA0, MT_INT_RX_DONE_WA, MT7996_RXQ_MCU_WA);
-
-	/* mt7996: band0 and band1, mt7992: band0 */
 	RXQ_CONFIG(MT_RXQ_MAIN, WFDMA0, MT_INT_RX_DONE_BAND0, MT7996_RXQ_BAND0);
-	RXQ_CONFIG(MT_RXQ_MAIN_WA, WFDMA0, MT_INT_RX_DONE_WA_MAIN, MT7996_RXQ_MCU_WA_MAIN);
 
-	if (is_mt7996(&dev->mt76)) {
+	switch (mt76_chip(&dev->mt76)) {
+	case MT7992_DEVICE_ID:
+		RXQ_CONFIG(MT_RXQ_MAIN_WA, WFDMA0, MT_INT_RX_DONE_WA_MAIN, MT7996_RXQ_MCU_WA_MAIN);
+		RXQ_CONFIG(MT_RXQ_BAND1_WA, WFDMA0, MT_INT_RX_DONE_WA_EXT, MT7996_RXQ_MCU_WA_EXT);
+		RXQ_CONFIG(MT_RXQ_BAND1, WFDMA0, MT_INT_RX_DONE_BAND1, MT7996_RXQ_BAND1);
+		break;
+	case MT7990_DEVICE_ID:
+		RXQ_CONFIG(MT_RXQ_BAND1, WFDMA0, MT_INT_RX_DONE_BAND1, MT7996_RXQ_BAND1);
+		RXQ_CONFIG(MT_RXQ_TXFREE_BAND0, WFDMA0,
+			   MT_INT_RX_TXFREE_BAND0_MT7990, MT7990_RXQ_TXFREE0);
+		if (dev->hif2)
+			RXQ_CONFIG(MT_RXQ_TXFREE_BAND1, WFDMA0,
+				   MT_INT_RX_TXFREE_BAND1_MT7990, MT7990_RXQ_TXFREE1);
+		break;
+	case MT7996_DEVICE_ID:
+	default:
+		RXQ_CONFIG(MT_RXQ_MAIN_WA, WFDMA0, MT_INT_RX_DONE_WA_MAIN, MT7996_RXQ_MCU_WA_MAIN);
 		/* mt7996 band2 */
-		RXQ_CONFIG(MT_RXQ_BAND2, WFDMA0, MT_INT_RX_DONE_BAND2, MT7996_RXQ_BAND2);
 		RXQ_CONFIG(MT_RXQ_BAND2_WA, WFDMA0, MT_INT_RX_DONE_WA_TRI, MT7996_RXQ_MCU_WA_TRI);
-	} else {
-		/* mt7992 band1 */
-		RXQ_CONFIG(MT_RXQ_BAND1, WFDMA0, MT_INT_RX_DONE_BAND1, MT7996_RXQ_BAND1);
-		RXQ_CONFIG(MT_RXQ_BAND1_WA, WFDMA0, MT_INT_RX_DONE_WA_EXT, MT7996_RXQ_MCU_WA_EXT);
+		RXQ_CONFIG(MT_RXQ_BAND2, WFDMA0, MT_INT_RX_DONE_BAND2, MT7996_RXQ_BAND2);
+		break;
 	}
 
 	if (dev->has_rro) {
@@ -138,7 +149,8 @@ static void mt7996_dma_config(struct mt7996_dev *dev)
 
 	/* mcu tx queue */
 	MCUQ_CONFIG(MT_MCUQ_WM, WFDMA0, MT_INT_TX_DONE_MCU_WM, MT7996_TXQ_MCU_WM);
-	MCUQ_CONFIG(MT_MCUQ_WA, WFDMA0, MT_INT_TX_DONE_MCU_WA, MT7996_TXQ_MCU_WA);
+	if (mt7996_has_wa(dev))
+		MCUQ_CONFIG(MT_MCUQ_WA, WFDMA0, MT_INT_TX_DONE_MCU_WA, MT7996_TXQ_MCU_WA);
 	MCUQ_CONFIG(MT_MCUQ_FWDL, WFDMA0, MT_INT_TX_DONE_FWDL, MT7996_TXQ_FWDL);
 }
 
@@ -154,48 +166,63 @@ static u32 __mt7996_dma_prefetch_base(u16 *base, u8 depth)
 static void __mt7996_dma_prefetch(struct mt7996_dev *dev, u32 ofs)
 {
 	u16 base = 0;
-	u8 queue;
+	u8 queue, val;
 
 #define PREFETCH(_depth)	(__mt7996_dma_prefetch_base(&base, (_depth)))
 	/* prefetch SRAM wrapping boundary for tx/rx ring. */
-	mt76_wr(dev, MT_MCUQ_EXT_CTRL(MT_MCUQ_FWDL) + ofs, PREFETCH(0x2));
-	mt76_wr(dev, MT_MCUQ_EXT_CTRL(MT_MCUQ_WM) + ofs, PREFETCH(0x2));
-	mt76_wr(dev, MT_TXQ_EXT_CTRL(0) + ofs, PREFETCH(0x8));
-	mt76_wr(dev, MT_TXQ_EXT_CTRL(1) + ofs, PREFETCH(0x8));
-	mt76_wr(dev, MT_MCUQ_EXT_CTRL(MT_MCUQ_WA) + ofs, PREFETCH(0x2));
-	mt76_wr(dev, MT_TXQ_EXT_CTRL(2) + ofs, PREFETCH(0x8));
-	mt76_wr(dev, MT_RXQ_BAND1_CTRL(MT_RXQ_MCU) + ofs, PREFETCH(0x2));
-	mt76_wr(dev, MT_RXQ_BAND1_CTRL(MT_RXQ_MCU_WA) + ofs, PREFETCH(0x2));
-	mt76_wr(dev, MT_RXQ_BAND1_CTRL(MT_RXQ_MAIN_WA) + ofs, PREFETCH(0x2));
 
-	queue = is_mt7996(&dev->mt76) ? MT_RXQ_BAND2_WA : MT_RXQ_BAND1_WA;
-	mt76_wr(dev, MT_RXQ_BAND1_CTRL(queue) + ofs, PREFETCH(0x2));
+	/* Tx Command Rings */
+	val = is_mt7996(&dev->mt76) ? 2 : 4;
+	mt76_wr(dev, MT_MCUQ_EXT_CTRL(MT_MCUQ_FWDL) + ofs, PREFETCH(val));
+	mt76_wr(dev, MT_MCUQ_EXT_CTRL(MT_MCUQ_WM) + ofs, PREFETCH(val));
+	if (mt7996_has_wa(dev))
+		mt76_wr(dev, MT_MCUQ_EXT_CTRL(MT_MCUQ_WA) + ofs, PREFETCH(val));
 
-	mt76_wr(dev, MT_RXQ_BAND1_CTRL(MT_RXQ_MAIN) + ofs, PREFETCH(0x10));
+	/* Tx Data Rings */
+	mt76_wr(dev, MT_TXQ_EXT_CTRL(0) + ofs, PREFETCH(0x8));
+	if (!is_mt7996(&dev->mt76) || dev->hif2)
+		mt76_wr(dev, MT_TXQ_EXT_CTRL(1) + ofs, PREFETCH(0x8));
+	if (is_mt7996(&dev->mt76))
+		mt76_wr(dev, MT_TXQ_EXT_CTRL(2) + ofs, PREFETCH(0x8));
+
+	/* Rx Event Rings */
+	mt76_wr(dev, MT_RXQ_EXT_CTRL(MT_RXQ_MCU) + ofs, PREFETCH(val));
+	mt76_wr(dev, MT_RXQ_EXT_CTRL(MT_RXQ_MCU_WA) + ofs, PREFETCH(val));
+
+	/* Rx TxFreeDone From WA Rings */
+	if (mt7996_has_wa(dev)) {
+		mt76_wr(dev, MT_RXQ_EXT_CTRL(MT_RXQ_MAIN_WA) + ofs, PREFETCH(val));
+		queue = is_mt7996(&dev->mt76) ? MT_RXQ_BAND2_WA : MT_RXQ_BAND1_WA;
+		mt76_wr(dev, MT_RXQ_EXT_CTRL(queue) + ofs, PREFETCH(val));
+	}
 
+	/* Rx TxFreeDone From MAC Rings */
+	val = is_mt7996(&dev->mt76) ? 4 : 8;
+	if (is_mt7990(&dev->mt76) || (is_mt7996(&dev->mt76) && dev->has_rro))
+		mt76_wr(dev, MT_RXQ_EXT_CTRL(MT_RXQ_TXFREE_BAND0) + ofs, PREFETCH(val));
+	if (is_mt7990(&dev->mt76) && dev->hif2)
+		mt76_wr(dev, MT_RXQ_EXT_CTRL(MT_RXQ_TXFREE_BAND1) + ofs, PREFETCH(val));
+	else if (is_mt7996(&dev->mt76) && dev->has_rro)
+		mt76_wr(dev, MT_RXQ_EXT_CTRL(MT_RXQ_TXFREE_BAND2) + ofs, PREFETCH(val));
+
+	/* Rx Data Rings */
+	mt76_wr(dev, MT_RXQ_EXT_CTRL(MT_RXQ_MAIN) + ofs, PREFETCH(0x10));
 	queue = is_mt7996(&dev->mt76) ? MT_RXQ_BAND2 : MT_RXQ_BAND1;
-	mt76_wr(dev, MT_RXQ_BAND1_CTRL(queue) + ofs, PREFETCH(0x10));
+	mt76_wr(dev, MT_RXQ_EXT_CTRL(queue) + ofs, PREFETCH(0x10));
 
+	/* Rx RRO Rings */
 	if (dev->has_rro) {
-		mt76_wr(dev, MT_RXQ_BAND1_CTRL(MT_RXQ_RRO_BAND0) + ofs,
-			PREFETCH(0x10));
-		if (is_mt7996(&dev->mt76))
-			mt76_wr(dev, MT_RXQ_BAND1_CTRL(MT_RXQ_RRO_BAND2) + ofs,
-				PREFETCH(0x10));
-		else
-			mt76_wr(dev, MT_RXQ_BAND1_CTRL(MT_RXQ_RRO_BAND1) + ofs,
-				PREFETCH(0x10));
-
-		mt76_wr(dev, MT_RXQ_BAND1_CTRL(MT_RXQ_MSDU_PAGE_BAND0) + ofs,
-			PREFETCH(0x4));
-		mt76_wr(dev, MT_RXQ_BAND1_CTRL(MT_RXQ_MSDU_PAGE_BAND1) + ofs,
-			PREFETCH(0x4));
-		mt76_wr(dev, MT_RXQ_BAND1_CTRL(MT_RXQ_MSDU_PAGE_BAND2) + ofs,
-			PREFETCH(0x4));
-		mt76_wr(dev, MT_RXQ_BAND1_CTRL(MT_RXQ_TXFREE_BAND0) + ofs,
-			PREFETCH(0x4));
-		mt76_wr(dev, MT_RXQ_BAND1_CTRL(MT_RXQ_TXFREE_BAND2) + ofs,
-			PREFETCH(0x4));
+		mt76_wr(dev, MT_RXQ_EXT_CTRL(MT_RXQ_RRO_BAND0) + ofs, PREFETCH(0x10));
+		queue = is_mt7996(&dev->mt76) ? MT_RXQ_RRO_BAND2 : MT_RXQ_RRO_BAND1;
+		mt76_wr(dev, MT_RXQ_EXT_CTRL(queue) + ofs, PREFETCH(0x10));
+
+		mt76_wr(dev, MT_RXQ_EXT_CTRL(MT_RXQ_MSDU_PAGE_BAND0) + ofs, PREFETCH(val));
+		if (is_mt7996(&dev->mt76)) {
+			mt76_wr(dev, MT_RXQ_EXT_CTRL(MT_RXQ_MSDU_PAGE_BAND1) + ofs,
+				PREFETCH(val));
+			mt76_wr(dev, MT_RXQ_EXT_CTRL(MT_RXQ_MSDU_PAGE_BAND2) + ofs,
+				PREFETCH(val));
+		}
 	}
 #undef PREFETCH
 
@@ -310,6 +337,9 @@ void mt7996_dma_start(struct mt7996_dev *dev, bool reset, bool wed_reset)
 		mtk_wed_device_start(wed, wed_irq_mask);
 	}
 
+	if (!mt7996_has_wa(dev))
+		irq_mask &= ~(MT_INT_RX(MT_RXQ_MAIN_WA) | MT_INT_RX(MT_RXQ_BAND1_WA));
+
 	irq_mask = reset ? MT_INT_MCU_CMD : irq_mask;
 
 	mt7996_irq_enable(dev, irq_mask);
@@ -593,12 +623,14 @@ int mt7996_dma_init(struct mt7996_dev *dev)
 		return ret;
 
 	/* command to WA */
-	ret = mt76_init_mcu_queue(&dev->mt76, MT_MCUQ_WA,
-				  MT_MCUQ_ID(MT_MCUQ_WA),
-				  MT7996_TX_MCU_RING_SIZE,
-				  MT_MCUQ_RING_BASE(MT_MCUQ_WA));
-	if (ret)
-		return ret;
+	if (mt7996_has_wa(dev)) {
+		ret = mt76_init_mcu_queue(&dev->mt76, MT_MCUQ_WA,
+					  MT_MCUQ_ID(MT_MCUQ_WA),
+					  MT7996_TX_MCU_RING_SIZE,
+					  MT_MCUQ_RING_BASE(MT_MCUQ_WA));
+		if (ret)
+			return ret;
+	}
 
 	/* firmware download */
 	ret = mt76_init_mcu_queue(&dev->mt76, MT_MCUQ_FWDL,
@@ -617,7 +649,7 @@ int mt7996_dma_init(struct mt7996_dev *dev)
 	if (ret)
 		return ret;
 
-	/* event from WA */
+	/* event from WA (SDO for griffin) */
 	ret = mt76_queue_alloc(dev, &dev->mt76.q_rx[MT_RXQ_MCU_WA],
 			       MT_RXQ_ID(MT_RXQ_MCU_WA),
 			       MT7996_RX_MCU_RING_SIZE_WA,
@@ -648,13 +680,41 @@ int mt7996_dma_init(struct mt7996_dev *dev)
 		dev->mt76.q_rx[MT_RXQ_MAIN_WA].wed = wed;
 	}
 
-	ret = mt76_queue_alloc(dev, &dev->mt76.q_rx[MT_RXQ_MAIN_WA],
-			       MT_RXQ_ID(MT_RXQ_MAIN_WA),
-			       MT7996_RX_MCU_RING_SIZE,
-			       MT_RX_BUF_SIZE,
-			       MT_RXQ_RING_BASE(MT_RXQ_MAIN_WA));
-	if (ret)
-		return ret;
+	if (mt7996_has_wa(dev)) {
+		ret = mt76_queue_alloc(dev, &dev->mt76.q_rx[MT_RXQ_MAIN_WA],
+				       MT_RXQ_ID(MT_RXQ_MAIN_WA),
+				       MT7996_RX_MCU_RING_SIZE,
+				       MT_RX_BUF_SIZE,
+				       MT_RXQ_RING_BASE(MT_RXQ_MAIN_WA));
+		if (ret)
+			return ret;
+	} else {
+		if (mtk_wed_device_active(wed)) {
+			dev->mt76.q_rx[MT_RXQ_TXFREE_BAND0].flags = MT_WED_Q_TXFREE;
+			dev->mt76.q_rx[MT_RXQ_TXFREE_BAND0].wed = wed;
+		}
+		ret = mt76_queue_alloc(dev, &dev->mt76.q_rx[MT_RXQ_TXFREE_BAND0],
+				       MT_RXQ_ID(MT_RXQ_TXFREE_BAND0),
+				       MT7996_RX_MCU_RING_SIZE,
+				       MT7996_RX_BUF_SIZE,
+				       MT_RXQ_RING_BASE(MT_RXQ_TXFREE_BAND0));
+		if (ret)
+			return ret;
+	}
+
+	if (!mt7996_has_wa(dev) && dev->hif2) {
+		if (mtk_wed_device_active(wed)) {
+			dev->mt76.q_rx[MT_RXQ_TXFREE_BAND1].flags = MT_WED_Q_TXFREE;
+			dev->mt76.q_rx[MT_RXQ_TXFREE_BAND1].wed = wed;
+		}
+		ret = mt76_queue_alloc(dev, &dev->mt76.q_rx[MT_RXQ_TXFREE_BAND1],
+				       MT_RXQ_ID(MT_RXQ_TXFREE_BAND1),
+				       MT7996_RX_MCU_RING_SIZE,
+				       MT7996_RX_BUF_SIZE,
+				       MT_RXQ_RING_BASE(MT_RXQ_TXFREE_BAND1));
+		if (ret)
+			return ret;
+	}
 
 	if (mt7996_band_valid(dev, MT_BAND2)) {
 		/* rx data queue for mt7996 band2 */
@@ -703,18 +763,20 @@ int mt7996_dma_init(struct mt7996_dev *dev)
 			return ret;
 
 		/* tx free notify event from WA for mt7992 band1 */
-		rx_base = MT_RXQ_RING_BASE(MT_RXQ_BAND1_WA) + hif1_ofs;
-		if (mtk_wed_device_active(wed_hif2)) {
-			dev->mt76.q_rx[MT_RXQ_BAND1_WA].flags = MT_WED_Q_TXFREE;
-			dev->mt76.q_rx[MT_RXQ_BAND1_WA].wed = wed_hif2;
+		if (mt7996_has_wa(dev)) {
+			rx_base = MT_RXQ_RING_BASE(MT_RXQ_BAND1_WA) + hif1_ofs;
+			if (mtk_wed_device_active(wed_hif2)) {
+				dev->mt76.q_rx[MT_RXQ_BAND1_WA].flags = MT_WED_Q_TXFREE;
+				dev->mt76.q_rx[MT_RXQ_BAND1_WA].wed = wed_hif2;
+			}
+			ret = mt76_queue_alloc(dev, &dev->mt76.q_rx[MT_RXQ_BAND1_WA],
+					       MT_RXQ_ID(MT_RXQ_BAND1_WA),
+					       MT7996_RX_MCU_RING_SIZE,
+					       MT_RX_BUF_SIZE,
+					       rx_base);
+			if (ret)
+				return ret;
 		}
-		ret = mt76_queue_alloc(dev, &dev->mt76.q_rx[MT_RXQ_BAND1_WA],
-				       MT_RXQ_ID(MT_RXQ_BAND1_WA),
-				       MT7996_RX_MCU_RING_SIZE,
-				       MT_RX_BUF_SIZE,
-				       rx_base);
-		if (ret)
-			return ret;
 	}
 
 	if (dev->has_rro) {
@@ -731,7 +793,7 @@ int mt7996_dma_init(struct mt7996_dev *dev)
 		if (ret)
 			return ret;
 
-		if (is_mt7992(&dev->mt76)) {
+		if (!is_mt7996(&dev->mt76)) {
 			dev->mt76.q_rx[MT_RXQ_RRO_BAND1].flags =
 				MT_WED_RRO_Q_DATA(1) | MT_QFLAG_WED_RRO_EN;
 			if (mtk_wed_device_active(wed) && mtk_wed_get_rx_capa(wed))
diff --git a/mt7996/eeprom.c b/mt7996/eeprom.c
index d5781658..57ea445b 100644
--- a/mt7996/eeprom.c
+++ b/mt7996/eeprom.c
@@ -91,6 +91,8 @@ static int mt7996_check_eeprom(struct mt7996_dev *dev)
 		return is_mt7996(&dev->mt76) ? 0 : -EINVAL;
 	case MT7992_DEVICE_ID:
 		return is_mt7992(&dev->mt76) ? 0 : -EINVAL;
+	case MT7990_DEVICE_ID:
+		return is_mt7990(&dev->mt76) ? 0 : -EINVAL;
 	default:
 		return -EINVAL;
 	}
@@ -115,6 +117,11 @@ const char *mt7996_eeprom_name(struct mt7996_dev *dev)
 				return MT7992_EEPROM_DEFAULT_MIX;
 			return MT7992_EEPROM_DEFAULT;
 		}
+		return MT7992_EEPROM_DEFAULT_24;
+	case MT7990_DEVICE_ID:
+		if (dev->var.fem == MT7996_FEM_INT)
+			return MT7990_EEPROM_DEFAULT_INT;
+		return MT7990_EEPROM_DEFAULT;
 	case MT7996_DEVICE_ID:
 	default:
 		switch (dev->var.type) {
@@ -371,6 +378,8 @@ static int mt7996_eeprom_parse_efuse_hw_cap(struct mt7996_phy *phy,
 					    u8 *path, u8 *rx_path, u8 *nss)
 {
 #define MODE_HE_ONLY		BIT(0)
+#define FIPS_CAP		BIT(7)
+#define PWR_BOOST_CAP		BIT(8)
 #define WTBL_SIZE_GROUP		GENMASK(31, 28)
 #define STREAM_CAP(_offs)	((cap & (0x7 << (_offs))) >> (_offs))
 	struct mt7996_dev *dev = phy->dev;
@@ -391,6 +400,11 @@ static int mt7996_eeprom_parse_efuse_hw_cap(struct mt7996_phy *phy,
 		*nss = min_t(u8, *nss, STREAM_CAP(1 + band_offs));
 		*path = min_t(u8, *path, STREAM_CAP(10 + band_offs));
 		*rx_path = min_t(u8, *rx_path, STREAM_CAP(19 + band_offs));
+
+		if (is_mt7990(&dev->mt76)) {
+			dev->fips_cap = !!(cap & FIPS_CAP);
+			dev->pwr_boost_cap = !!(cap & PWR_BOOST_CAP);
+		}
 	}
 
 	if (dev->wtbl_size_group < 2 || dev->wtbl_size_group > 4)
@@ -517,15 +531,18 @@ static void mt7996_eeprom_init_precal(struct mt7996_dev *dev)
 		dev->prek.dpd_ch_num[DPD_CH_NUM_BW320_6G] = ARRAY_SIZE(dpd_6g_ch_list_bw320);
 		break;
 	case MT7992_DEVICE_ID:
-		dev->prek.rev  = mt7992_prek_rev;
+		dev->prek.rev = mt7992_prek_rev;
 		dev->prek.dpd_ch_num[DPD_CH_NUM_BW80_5G] = ARRAY_SIZE(dpd_5g_ch_list_bw80);
 		/* 6g is not used in current sku */
 		dev->prek.dpd_ch_num[DPD_CH_NUM_BW20_6G] = 0;
 		dev->prek.dpd_ch_num[DPD_CH_NUM_BW80_6G] = 0;
 		dev->prek.dpd_ch_num[DPD_CH_NUM_BW160_6G] = 0;
 		break;
+	case MT7990_DEVICE_ID:
+		dev->prek.rev = mt7990_prek_rev;
+		break;
 	default:
-		dev->prek.rev  = mt7996_prek_rev;
+		dev->prek.rev = mt7996_prek_rev;
 		break;
 	}
 }
diff --git a/mt7996/eeprom.h b/mt7996/eeprom.h
index 15b6620d..e286a58b 100644
--- a/mt7996/eeprom.h
+++ b/mt7996/eeprom.h
@@ -95,6 +95,19 @@ static const u32 mt7992_prek_rev[] = {
 	[DPD_OTFG0_SIZE] =			2 * MT_EE_CAL_UNIT,
 };
 
+static const u32 mt7990_prek_rev[] = {
+	[GROUP_SIZE_2G] =			4 * MT_EE_CAL_UNIT,
+	[GROUP_SIZE_5G] =			45 * MT_EE_CAL_UNIT,
+	[GROUP_SIZE_6G] =			90 * MT_EE_CAL_UNIT,
+	[ADCDCOC_SIZE_2G] =			4 * 2,
+	[ADCDCOC_SIZE_5G] =			4 * 3,
+	[ADCDCOC_SIZE_6G] =			4 * 3,
+	[DPD_LEGACY_SIZE] =			5 * MT_EE_CAL_UNIT,
+	/* no mem dpd cal for griffin, use legacy dpd cal instead */
+	[DPD_MEM_SIZE] =			0,
+	[DPD_OTFG0_SIZE] =			2 * MT_EE_CAL_UNIT,
+};
+
 extern const struct ieee80211_channel dpd_2g_ch_list_bw20[];
 extern const struct ieee80211_channel dpd_5g_skip_ch_list[];
 extern const struct ieee80211_channel dpd_5g_ch_list_bw80[];
@@ -109,7 +122,9 @@ extern const struct ieee80211_channel dpd_6g_ch_list_bw320[];
 						 PREK(GROUP_SIZE_6G) + PREK(ADCDCOC_SIZE_2G) + \
 						 PREK(ADCDCOC_SIZE_5G) + PREK(ADCDCOC_SIZE_6G))
 #define DPD_PER_CH_BW20_SIZE			(PREK(DPD_LEGACY_SIZE) + PREK(DPD_OTFG0_SIZE))
-#define DPD_PER_CH_GT_BW20_SIZE			(PREK(DPD_MEM_SIZE) + PREK(DPD_OTFG0_SIZE))
+#define DPD_PER_CH_GT_BW20_SIZE			(PREK(DPD_MEM_SIZE) ? PREK(DPD_MEM_SIZE) + \
+								      PREK(DPD_OTFG0_SIZE) : \
+								      DPD_PER_CH_BW20_SIZE)
 #define MT_EE_CAL_DPD_SIZE_2G			(DPD_CH_NUM(BW20_2G) * DPD_PER_CH_BW20_SIZE)
 #define MT_EE_CAL_DPD_SIZE_5G			(DPD_CH_NUM(BW20_5G) * DPD_PER_CH_BW20_SIZE + \
 						 DPD_CH_NUM(BW80_5G) * DPD_PER_CH_GT_BW20_SIZE + \
diff --git a/mt7996/init.c b/mt7996/init.c
index 6a4798df..bb01a246 100644
--- a/mt7996/init.c
+++ b/mt7996/init.c
@@ -506,8 +506,7 @@ mt7996_init_wiphy(struct ieee80211_hw *hw, struct mtk_wed_device *wed)
 	struct mt7996_dev *dev = mt7996_hw_dev(hw);
 	struct mt76_dev *mdev = &dev->mt76;
 	struct wiphy *wiphy = hw->wiphy;
-	u16 max_subframes = phy->dev->has_eht ? IEEE80211_MAX_AMPDU_BUF_EHT :
-						IEEE80211_MAX_AMPDU_BUF_HE;
+	u16 max_subframes;
 
 	hw->queues = 4;
 
@@ -627,7 +626,6 @@ mt7996_mac_init_band(struct mt7996_dev *dev, u8 band)
 	 */
 	mt76_set(dev, MT_AGG_ACR4(band), MT_AGG_ACR_PPDU_TXS2H);
 
-
 	if (!is_mt7996(&dev->mt76))
 		mt7996_mcu_set_bssid_mapping_addr(&dev->mt76, band);
 }
@@ -663,47 +661,65 @@ void mt7996_mac_init(struct mt7996_dev *dev)
 		mt76_rmw_field(dev, i, MT_LED_GPIO_SEL_MASK, 4);
 	}
 
-	/* rro module init */
-	rx_path_type = is_mt7996(&dev->mt76) ? 2 : 7;
-	rro_bypass = is_mt7996(&dev->mt76) ? 1 : 2;
-	txfree_path = is_mt7996(&dev->mt76) ? 0: 1;
+	/* rro module init, 2pcie */
+	switch (mt76_chip(&dev->mt76)) {
+	case MT7992_DEVICE_ID:
+		rx_path_type = 7;
+		rro_bypass = MT7996_RRO_BMC_BYPASS_UC_BASED_ON_WTBL;
+		txfree_path = MT7996_TXFREE_FROM_WA;
+		break;
+	case MT7990_DEVICE_ID:
+		rx_path_type = 7;
+		rro_bypass = MT7996_RRO_BMC_BYPASS_UC_BASED_ON_WTBL;
+		txfree_path = MT7996_TXFREE_FROM_MAC;
+		break;
+	case MT7996_DEVICE_ID:
+	default:
+		rx_path_type = 2;
+		rro_bypass = MT7996_RRO_ALL_NOT_BYPASS;
+		txfree_path = MT7996_TXFREE_FROM_MAC;
+		break;
+	}
 
 	switch (dev->option_type) {
 	case 2:
-		if (is_mt7996(&dev->mt76)) {
-			/* eagle + 7988d */
+		/* eagle + 7988d */
+		if (is_mt7996(&dev->mt76))
 			rx_path_type = 3;
-			rro_bypass = 1;
-			txfree_path = 0;
-		}
 		break;
 	case 3:
 		/* Airoha */
-		if (is_mt7996(&dev->mt76)) {
+		if (is_mt7996(&dev->mt76))
 			rx_path_type = 6;
-			rro_bypass = 1;
-			txfree_path = 0;
-		} else {
+		else
 			rx_path_type = 8;
-			rro_bypass = 2;
-			txfree_path = 1;
-		}
 		break;
 	case 4:
 		if (is_mt7996(&dev->mt76)) {
 			/* Bollinger */
 			rx_path_type = 2;
-			rro_bypass = 1;
-			txfree_path = 0;
+			rro_bypass = MT7996_RRO_ALL_NOT_BYPASS;
+			txfree_path = MT7996_TXFREE_FROM_MAC;
 		}
 		break;
 	default:
 		break;
 	}
 
-	mt7996_mcu_set_rro(dev, UNI_RRO_SET_PLATFORM_TYPE, dev->hif2 ? rx_path_type : 0);
-	mt7996_mcu_set_rro(dev, UNI_RRO_SET_BYPASS_MODE, dev->has_rro ? rro_bypass : 3);
-	mt7996_mcu_set_rro(dev, UNI_RRO_SET_TXFREE_PATH, dev->has_rro ? txfree_path : 1);
+	/* griffin does not have WA */
+	if (!dev->has_rro && mt7996_has_wa(dev))
+		txfree_path = MT7996_TXFREE_FROM_WA;
+
+	rx_path_type = dev->hif2 ? rx_path_type : 0;
+	rro_bypass = dev->has_rro ? rro_bypass : MT7996_RRO_ALL_BYPASS;
+
+	mt7996_mcu_set_rro(dev, UNI_RRO_SET_PLATFORM_TYPE, rx_path_type);
+	mt7996_mcu_set_rro(dev, UNI_RRO_SET_BYPASS_MODE, rro_bypass);
+	mt7996_mcu_set_rro(dev, UNI_RRO_SET_TXFREE_PATH, txfree_path);
+
+	dev_info(dev->mt76.dev,
+		"Platform_type = %d, bypass_rro = %d, txfree_path = %d\n",
+		rx_path_type, rro_bypass, txfree_path);
 
 	if (dev->has_rro) {
 		u16 timeout;
@@ -952,7 +968,7 @@ void mt7996_rro_hw_init(struct mt7996_dev *dev)
 	for (i = 0; i < MT7996_RRO_MSDU_PG_HASH_SIZE; i++)
 		INIT_LIST_HEAD(&dev->wed_rro.pg_hash_head[i]);
 
-	if (is_mt7992(&dev->mt76)) {
+	if (!is_mt7996(&dev->mt76)) {
 		/* set emul 3.0 function */
 		mt76_wr(dev, MT_RRO_3_0_EMU_CONF,
 			MT_RRO_3_0_EMU_CONF_EN_MASK);
@@ -1005,7 +1021,7 @@ void mt7996_rro_hw_init(struct mt7996_dev *dev)
 	/* use max session idx + 1 as particular session id */
 	mt76_wr(dev, MT_RRO_PARTICULAR_CFG0, dev->wed_rro.session.phy_addr);
 
-	if (is_mt7992(&dev->mt76)) {
+	if (!is_mt7996(&dev->mt76)) {
 		reg = MT_RRO_MSDU_PG_SEG_ADDR0;
 
 		mt76_set(dev, MT_RRO_3_1_GLOBAL_CONFIG,
@@ -1219,6 +1235,9 @@ static int mt7996_variant_type_init(struct mt7996_dev *dev)
 		else
 			var_type = MT7992_VAR_TYPE_24;
 		break;
+	case MT7990_DEVICE_ID:
+		dev->var.type = MT7990_VAR_TYPE_23;
+		break;
 	default:
 		return -EINVAL;
 	}
@@ -1351,10 +1370,10 @@ void mt7996_set_stream_vht_txbf_caps(struct mt7996_phy *phy)
 	*cap |= IEEE80211_VHT_CAP_SU_BEAMFORMEE_CAPABLE |
 		IEEE80211_VHT_CAP_MU_BEAMFORMEE_CAPABLE;
 
-	if (is_mt7996(phy->mt76->dev))
-		*cap |= FIELD_PREP(IEEE80211_VHT_CAP_BEAMFORMEE_STS_MASK, 3);
-	else
+	if (is_mt7992(phy->mt76->dev))
 		*cap |= FIELD_PREP(IEEE80211_VHT_CAP_BEAMFORMEE_STS_MASK, 4);
+	else
+		*cap |= FIELD_PREP(IEEE80211_VHT_CAP_BEAMFORMEE_STS_MASK, 3);
 
 	*cap &= ~(IEEE80211_VHT_CAP_SOUNDING_DIMENSIONS_MASK |
 		  IEEE80211_VHT_CAP_SU_BEAMFORMER_CAPABLE |
@@ -1402,12 +1421,12 @@ mt7996_set_stream_he_txbf_caps(struct mt7996_phy *phy,
 
 	c = IEEE80211_HE_PHY_CAP4_SU_BEAMFORMEE;
 
-	c |= is_mt7996(phy->mt76->dev) ? IEEE80211_HE_PHY_CAP4_BEAMFORMEE_MAX_STS_UNDER_80MHZ_4
-				       : IEEE80211_HE_PHY_CAP4_BEAMFORMEE_MAX_STS_UNDER_80MHZ_5;
+	c |= is_mt7992(phy->mt76->dev) ? IEEE80211_HE_PHY_CAP4_BEAMFORMEE_MAX_STS_UNDER_80MHZ_5
+				       : IEEE80211_HE_PHY_CAP4_BEAMFORMEE_MAX_STS_UNDER_80MHZ_4;
 
 	if (band != NL80211_BAND_2GHZ)
-		c |= is_mt7996(phy->mt76->dev) ? IEEE80211_HE_PHY_CAP4_BEAMFORMEE_MAX_STS_ABOVE_80MHZ_4
-					       : IEEE80211_HE_PHY_CAP4_BEAMFORMEE_MAX_STS_ABOVE_80MHZ_5;
+		c |= is_mt7992(phy->mt76->dev) ? IEEE80211_HE_PHY_CAP4_BEAMFORMEE_MAX_STS_ABOVE_80MHZ_5
+					       : IEEE80211_HE_PHY_CAP4_BEAMFORMEE_MAX_STS_ABOVE_80MHZ_4;
 
 	elem->phy_cap_info[4] |= c;
 
diff --git a/mt7996/mac.c b/mt7996/mac.c
index 67bdb5ee..df0d8b82 100644
--- a/mt7996/mac.c
+++ b/mt7996/mac.c
@@ -703,9 +703,12 @@ mt7996_mac_write_txwi_80211(struct mt7996_dev *dev, __le32 *txwi,
 
 	if (ieee80211_is_action(fc) &&
 	    mgmt->u.action.category == WLAN_CATEGORY_BACK &&
-	    mgmt->u.action.u.addba_req.action_code == WLAN_ACTION_ADDBA_REQ)
+	    mgmt->u.action.u.addba_req.action_code == WLAN_ACTION_ADDBA_REQ) {
+		if (is_mt7990(&dev->mt76))
+			txwi[6] |= cpu_to_le32(FIELD_PREP(MT_TXD6_TID_ADDBA, tid));
+
 		tid = MT_TX_ADDBA;
-	else if (ieee80211_is_mgmt(hdr->frame_control))
+	} else if (ieee80211_is_mgmt(hdr->frame_control))
 		tid = MT_TX_NORMAL;
 
 	val = FIELD_PREP(MT_TXD1_HDR_FORMAT, MT_HDR_FORMAT_802_11) |
@@ -869,6 +872,7 @@ void mt7996_mac_write_txwi(struct mt7996_dev *dev, __le32 *txwi,
 		val |= FIELD_PREP(MT_TXD6_MSDU_CNT, 1);
 		break;
 	case MT7992_DEVICE_ID:
+	case MT7990_DEVICE_ID:
 		if (is_8023 || !ieee80211_is_mgmt(hdr->frame_control))
 			val |= FIELD_PREP(MT_TXD6_MSDU_CNT_V2, 1);
 		break;
@@ -910,6 +914,27 @@ void mt7996_mac_write_txwi(struct mt7996_dev *dev, __le32 *txwi,
 	}
 }
 
+static bool
+mt7996_should_set_mgmt_frame(struct mt7996_dev *dev, struct sk_buff *skb)
+{
+	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;
+
+	if (ieee80211_is_mgmt(hdr->frame_control))
+		return true;
+
+	/* for SDO to bypass specific data frame */
+	if (!mt7996_has_wa(dev)) {
+		if (unlikely(skb->protocol == cpu_to_be16(ETH_P_PAE)))
+			return true;
+
+		if (ieee80211_has_a4(hdr->frame_control) &&
+		    !ieee80211_is_data_present(hdr->frame_control))
+			return true;
+	}
+
+	return false;
+}
+
 int mt7996_tx_prepare_skb(struct mt76_dev *mdev, void *txwi_ptr,
 			  enum mt76_txq_id qid, struct mt76_wcid *wcid,
 			  struct ieee80211_sta *sta,
@@ -1048,7 +1073,7 @@ int mt7996_tx_prepare_skb(struct mt76_dev *mdev, void *txwi_ptr,
 	if (!key)
 		txp->fw.flags |= cpu_to_le16(MT_CT_INFO_NONE_CIPHER_FRAME);
 
-	if (!is_8023 && ieee80211_is_mgmt(hdr->frame_control))
+	if (!is_8023 && mt7996_should_set_mgmt_frame(dev, tx_info->skb))
 		txp->fw.flags |= cpu_to_le16(MT_CT_INFO_MGMT_FRAME);
 
 	txp->fw.bss_idx = mconf->mt76.idx;
@@ -1186,6 +1211,7 @@ mt7996_mac_tx_free(struct mt7996_dev *dev, void *data, int len)
 	void *end = data + len;
 	bool wake = false;
 	u16 total, count = 0;
+	u8 version;
 
 	/* clean DMA queues and unmap buffers first */
 	mt76_queue_tx_cleanup(dev, dev->mphy.q_tx[MT_TXQ_PSD], false);
@@ -1199,7 +1225,8 @@ mt7996_mac_tx_free(struct mt7996_dev *dev, void *data, int len)
 		mt76_queue_tx_cleanup(dev, phy3->q_tx[MT_TXQ_BE], false);
 	}
 
-	if (WARN_ON_ONCE(le32_get_bits(tx_free[1], MT_TXFREE1_VER) < 5))
+	version = le32_get_bits(tx_free[1], MT_TXFREE1_VER);
+	if (WARN_ON_ONCE(version < 5))
 		return;
 
 	total = le32_get_bits(tx_free[0], MT_TXFREE0_MSDU_CNT);
@@ -1217,13 +1244,14 @@ mt7996_mac_tx_free(struct mt7996_dev *dev, void *data, int len)
 			struct mt7996_sta *msta;
 			unsigned long valid_links;
 			unsigned int link_id;
+			u32 next_info;
 			u16 idx;
 
 			idx = FIELD_GET(MT_TXFREE_INFO_WLAN_ID, info);
 			wcid = rcu_dereference(dev->mt76.wcid[idx]);
 			sta = wcid_to_sta(wcid);
 			if (!sta)
-				continue;
+				goto next;
 
 			valid_links = sta->valid_links ?: BIT(0);
 			msta = (struct mt7996_sta *)sta->drv_priv;
@@ -1237,6 +1265,13 @@ mt7996_mac_tx_free(struct mt7996_dev *dev, void *data, int len)
 					list_add_tail(&mlink->wcid.poll_list, &mdev->sta_poll_list);
 			}
 			spin_unlock_bh(&mdev->sta_poll_lock);
+next:
+			/* In version 7, an additional DW with pair = 1 is added. Just skip it here.
+			 * TODO: parse txd release timestamp, PPDU RTS TX count if required.
+			 */
+			next_info = (void *)(cur_info + 1) < end ? le32_to_cpu(*(cur_info + 1)) : 0;
+			if (version == 7 && (next_info & MT_TXFREE_INFO_PAIR))
+				cur_info++;
 			continue;
 		} else if (info & MT_TXFREE_INFO_HEADER) {
 			if (!wcid)
@@ -2899,9 +2934,7 @@ void mt7996_mac_work(struct work_struct *work)
 				// }
 				mt7996_mcu_get_all_sta_info(mdev, UNI_ALL_STA_RX_MPDU_COUNT);
 
-				if (mt7996_mcu_wa_cmd(phy->dev, MCU_WA_PARAM_CMD(QUERY), MCU_WA_PARAM_BSS_ACQ_PKT_CNT,
-				                      BSS_ACQ_PKT_CNT_BSS_BITMAP_ALL | BSS_ACQ_PKT_CNT_READ_CLR, 0))
-					dev_err(mdev->dev, "Failed to query per-AC-queue packet counts.\n");
+				mt7996_mcu_get_bss_acq_pkt_cnt(phy->dev);
 
 				if (mphy->mac_work_count == 100) {
 					if (phy->dev->idxlog_enable && mt7996_mcu_fw_time_sync(mdev))
diff --git a/mt7996/main.c b/mt7996/main.c
index 1879879a..598efb15 100644
--- a/mt7996/main.c
+++ b/mt7996/main.c
@@ -2441,6 +2441,7 @@ mt7996_background_radar_handle_7975_ifem(struct ieee80211_hw *hw,
 		is_ifem_adie = dev->var.type == MT7992_VAR_TYPE_44 &&
 			       dev->var.fem != MT7996_FEM_EXT;
 		break;
+	case MT7990_DEVICE_ID:
 	default:
 		return;
 	}
@@ -2968,10 +2969,6 @@ mt7996_add_chanctx(struct ieee80211_hw *hw, struct ieee80211_chanctx_conf *conf)
 	if (ret)
 		return ret;
 
-	ret = mt7996_mcu_set_pp_alg_ctrl(phy, PP_ALG_SET_TIMER);
-	if (ret)
-		return ret;
-
 	return mt7996_config_channel(phy, &ctx->chandef);
 }
 
diff --git a/mt7996/mcu.c b/mt7996/mcu.c
index 8ef6f373..7b5af86b 100644
--- a/mt7996/mcu.c
+++ b/mt7996/mcu.c
@@ -27,6 +27,9 @@
 			_fw = MT7992_##name;			\
 		}						\
 		break;						\
+	case MT7990_DEVICE_ID:					\
+		_fw = MT7990_##name;				\
+		break;						\
 	case MT7996_DEVICE_ID:						\
 	default:						\
 		switch ((_dev)->var.type) {			\
@@ -278,7 +281,7 @@ mt7996_mcu_send_message(struct mt76_dev *mdev, struct sk_buff *skb,
 
 	txd_len = cmd & __MCU_CMD_FIELD_UNI ? sizeof(*uni_txd) : sizeof(*mcu_txd);
 	txd = (__le32 *)skb_push(skb, txd_len);
-	if (test_bit(MT76_STATE_MCU_RUNNING, &dev->mphy.state))
+	if (test_bit(MT76_STATE_MCU_RUNNING, &dev->mphy.state) && mt7996_has_wa(dev))
 		qid = MT_MCUQ_WA;
 	else
 		qid = MT_MCUQ_WM;
@@ -357,8 +360,13 @@ exit:
 int mt7996_mcu_wa_cmd(struct mt7996_dev *dev, int cmd, u32 a1, u32 a2, u32 a3)
 {
 	struct {
+		u8 _rsv[4];
+
+		__le16 tag;
+		__le16 len;
 		__le32 args[3];
-	} req = {
+	} __packed req = {
+		.len = cpu_to_le16(sizeof(req) - 4),
 		.args = {
 			cpu_to_le32(a1),
 			cpu_to_le32(a2),
@@ -366,7 +374,16 @@ int mt7996_mcu_wa_cmd(struct mt7996_dev *dev, int cmd, u32 a1, u32 a2, u32 a3)
 		},
 	};
 
-	return mt76_mcu_send_msg(&dev->mt76, cmd, &req, sizeof(req), false);
+	if (cmd == MCU_WA_PARAM_CMD(QUERY))
+		req.tag = cpu_to_le16(UNI_CMD_SDO_QUERY);
+	else
+		req.tag = cpu_to_le16(UNI_CMD_SDO_SET);
+
+	if (!mt7996_has_wa(dev))
+		return mt76_mcu_send_msg(&dev->mt76, MCU_WA_UNI_CMD(SDO),
+					 &req, sizeof(req), true);
+
+	return mt76_mcu_send_msg(&dev->mt76, cmd, &req.args, sizeof(req.args), false);
 }
 
 static void
@@ -1118,38 +1135,53 @@ void mt7996_mcu_wmm_pbc_work(struct work_struct *work)
 #define WMM_PBC_LOW_BOUND_BK	900
 #define WMM_PBC_LOW_BOUND_MGMT	32
 	struct mt7996_dev *dev = container_of(work, struct mt7996_dev, wmm_pbc_work);
+
 	struct {
-		u8 bss_idx;
-		u8 queue_num;
-		__le16 wlan_idx;
-		u8 band_idx;
-		u8 __rsv[3];
+		u8 _rsv[4];
+
+		__le16 tag;
+		__le16 len;
+
 		struct {
-			__le16 low;
-			__le16 up;
-		} __packed bound[WMM_PBC_QUEUE_NUM];
+			u8 bss_idx;
+			u8 queue_num;
+			__le16 wlan_idx;
+			u8 band_idx;
+			u8 __rsv[3];
+			struct {
+				__le16 low;
+				__le16 up;
+			} __packed bound[WMM_PBC_QUEUE_NUM];
+		} __packed data;
 	} __packed req = {
-		.bss_idx = WMM_PBC_BSS_ALL,
-		.queue_num = WMM_PBC_QUEUE_NUM,
-		.wlan_idx = cpu_to_le16(WMM_PBC_WLAN_IDX_ALL),
-		.band_idx = dev->mphy.band_idx,
+		.tag = cpu_to_le16(UNI_CMD_SDO_PKT_BUDGET_CTRL_CFG),
+		.len = cpu_to_le16(sizeof(req) - 4),
+		.data.bss_idx = WMM_PBC_BSS_ALL,
+		.data.queue_num = WMM_PBC_QUEUE_NUM,
+		.data.wlan_idx = cpu_to_le16(WMM_PBC_WLAN_IDX_ALL),
+		.data.band_idx = dev->mphy.band_idx,
 	};
 	int i, ret;
 
-#define pbc_acq_low_bound_config(_ac, _bound)								\
-	req.bound[mt76_connac_lmac_mapping(_ac)].low = dev->wmm_pbc_enable ? cpu_to_le16(_bound) : 0
+#define pbc_acq_low_bound_config(_ac, _bound)						\
+	req.data.bound[mt76_connac_lmac_mapping(_ac)].low = dev->wmm_pbc_enable ?	\
+							    cpu_to_le16(_bound) : 0
 	pbc_acq_low_bound_config(IEEE80211_AC_VO, WMM_PBC_LOW_BOUND_VO);
 	pbc_acq_low_bound_config(IEEE80211_AC_VI, WMM_PBC_LOW_BOUND_VI);
 	pbc_acq_low_bound_config(IEEE80211_AC_BE, WMM_PBC_LOW_BOUND_BE);
 	pbc_acq_low_bound_config(IEEE80211_AC_BK, WMM_PBC_LOW_BOUND_BK);
-	req.bound[4].low = dev->wmm_pbc_enable
-	                   ? cpu_to_le16(WMM_PBC_LOW_BOUND_MGMT) : 0;
+	req.data.bound[4].low = dev->wmm_pbc_enable ?
+				cpu_to_le16(WMM_PBC_LOW_BOUND_MGMT) : 0;
 
 	for (i = 0; i < WMM_PBC_QUEUE_NUM; ++i)
-		req.bound[i].up = cpu_to_le16(WMM_PBC_BOUND_DEFAULT);
+		req.data.bound[i].up = cpu_to_le16(WMM_PBC_BOUND_DEFAULT);
 
-	ret = mt76_mcu_send_msg(&dev->mt76, MCU_WA_EXT_CMD(PKT_BUDGET_CTRL),
-	                        &req, sizeof(req), true);
+	if (is_mt7990(&dev->mt76))
+		ret = mt76_mcu_send_msg(&dev->mt76, MCU_WA_UNI_CMD(SDO),
+					 &req, sizeof(req), true);
+	else
+		ret = mt76_mcu_send_msg(&dev->mt76, MCU_WA_EXT_CMD(PKT_BUDGET_CTRL),
+					&req.data, sizeof(req.data), true);
 	if (ret)
 		dev_err(dev->mt76.dev, "Failed to configure WMM PBC.\n");
 }
@@ -1414,6 +1446,60 @@ mt7996_mcu_mld_event(struct mt7996_dev *dev, struct sk_buff *skb)
 	}
 }
 
+static void
+mt7996_mcu_uni_bss_acq_pkt_cnt(struct mt7996_dev *dev, struct tlv *tlv)
+{
+	struct mt7996_mld_sdo_bss_acq_pkt_cnt *data =
+		(struct mt7996_mld_sdo_bss_acq_pkt_cnt *)tlv->data;
+	u64 sum[IEEE80211_NUM_ACS] = {0};
+	u8 ac_cnt = 0;
+	int i, j;
+
+	for (i = 0; i < UNI_CMD_SDO_CFG_BSS_NUM; i++) {
+		for (j = IEEE80211_AC_VO; j < IEEE80211_NUM_ACS; j++)
+			sum[j] += le32_to_cpu(data->pkt_cnt[i][mt76_connac_lmac_mapping(j)]);
+	}
+
+	for (i = IEEE80211_AC_VO; i < IEEE80211_NUM_ACS; i++) {
+		if (sum[i] > WMM_PKT_THRESHOLD)
+			ac_cnt++;
+	}
+
+	if (ac_cnt > 1 && !dev->wmm_pbc_enable) {
+		dev->wmm_pbc_enable = true;
+		queue_work(dev->mt76.wq, &dev->wmm_pbc_work);
+	} else if (ac_cnt <= 1 && dev->wmm_pbc_enable) {
+		dev->wmm_pbc_enable = false;
+		queue_work(dev->mt76.wq, &dev->wmm_pbc_work);
+	}
+}
+
+static void
+mt7996_mcu_sdo_event(struct mt7996_dev *dev, struct sk_buff *skb)
+{
+	struct mt7996_mcu_sdo_event *event = (void *)skb->data;
+	struct tlv *tlv;
+	int len;
+
+	skb_pull(skb, sizeof(*event));
+	tlv = (struct tlv *)skb->data;
+	len = skb->len;
+
+	while (len > 0 && le16_to_cpu(tlv->len) <= len) {
+		switch (le16_to_cpu(tlv->tag)) {
+		case UNI_EVENT_SDO_BSS_ACQ_PKT_CNT:
+			mt7996_mcu_uni_bss_acq_pkt_cnt(dev, tlv);
+			break;
+		default:
+			break;
+		}
+
+		len -= le16_to_cpu(tlv->len);
+		tlv = (struct tlv *)((u8 *)(tlv) + le16_to_cpu(tlv->len));
+	}
+
+}
+
 static void
 mt7996_mcu_bss_bcn_crit_finish(void *priv, u8 *mac, struct ieee80211_vif *vif)
 {
@@ -1493,6 +1579,9 @@ mt7996_mcu_uni_rx_unsolicited_event(struct mt7996_dev *dev, struct sk_buff *skb)
 	case MCU_UNI_EVENT_MLD:
 		mt7996_mcu_mld_event(dev, skb);
 		break;
+	case MCU_UNI_EVENT_SDO:
+		mt7996_mcu_sdo_event(dev, skb);
+		break;
 	case MCU_UNI_EVENT_BSS_INFO:
 		mt7996_mcu_bss_event(dev, skb);
 		break;
@@ -1948,7 +2037,7 @@ int mt7996_mcu_set_timing(struct mt7996_phy *phy, struct mt7996_bss_conf *mconf)
 	mt7996_mcu_bss_ifs_timing_tlv(skb, phy);
 
 	return mt76_mcu_skb_send_msg(&dev->mt76, skb,
-				     MCU_WMWA_UNI_CMD(BSS_INFO_UPDATE), true);
+				     MCU_WM_UNI_CMD(BSS_INFO_UPDATE), true);
 }
 
 static int
@@ -1999,7 +2088,7 @@ mt7996_mcu_sta_tx_cap(struct mt7996_dev *dev, struct mt76_vif *mvif,
 	tx_cap->ampdu_limit_en = true;
 
 	return mt76_mcu_skb_send_msg(&dev->mt76, skb,
-				     MCU_WMWA_UNI_CMD(STA_REC_UPDATE), true);
+				     MCU_WM_UNI_CMD(STA_REC_UPDATE), true);
 }
 
 static bool mt7996_check_limit_ampdu_en(struct ieee80211_ampdu_params *params) {
@@ -4226,7 +4315,7 @@ int mt7996_mcu_beacon_inband_discov(struct mt7996_dev *dev,
 	dev_kfree_skb(skb);
 
 	return mt76_mcu_skb_send_msg(&dev->mt76, rskb,
-				     MCU_WMWA_UNI_CMD(BSS_INFO_UPDATE), true);
+				     MCU_WM_UNI_CMD(BSS_INFO_UPDATE), true);
 }
 
 static int mt7996_driver_own(struct mt7996_dev *dev, u8 band)
@@ -4455,6 +4544,9 @@ static int mt7996_load_ram(struct mt7996_dev *dev)
 	if (ret)
 		return ret;
 
+	if (!mt7996_has_wa(dev))
+		return 0;
+
 	ret = __mt7996_load_ram(dev, "DSP", fw_name(dev, FIRMWARE_DSP),
 				MT7996_RAM_TYPE_DSP);
 	if (ret)
@@ -4465,10 +4557,9 @@ static int mt7996_load_ram(struct mt7996_dev *dev)
 }
 
 static int
-mt7996_firmware_state(struct mt7996_dev *dev, bool wa)
+mt7996_firmware_state(struct mt7996_dev *dev, u8 fw_state)
 {
-	u32 state = FIELD_PREP(MT_TOP_MISC_FW_STATE,
-			       wa ? FW_STATE_RDY : FW_STATE_FW_DOWNLOAD);
+	u32 state = FIELD_PREP(MT_TOP_MISC_FW_STATE, fw_state);
 
 	if (!mt76_poll_msec(dev, MT_TOP_MISC, MT_TOP_MISC_FW_STATE,
 			    state, 1000)) {
@@ -4501,12 +4592,13 @@ mt7996_mcu_restart(struct mt76_dev *dev)
 static int mt7996_load_firmware(struct mt7996_dev *dev)
 {
 	int ret;
+	u8 fw_state;
 
 	/* make sure fw is download state */
-	if (mt7996_firmware_state(dev, false)) {
+	if (mt7996_firmware_state(dev, FW_STATE_FW_DOWNLOAD)) {
 		/* restart firmware once */
 		mt7996_mcu_restart(&dev->mt76);
-		ret = mt7996_firmware_state(dev, false);
+		ret = mt7996_firmware_state(dev, FW_STATE_FW_DOWNLOAD);
 		if (ret) {
 			dev_err(dev->mt76.dev,
 				"Firmware is not ready for download\n");
@@ -4522,7 +4614,8 @@ static int mt7996_load_firmware(struct mt7996_dev *dev)
 	if (ret)
 		return ret;
 
-	ret = mt7996_firmware_state(dev, true);
+	fw_state = mt7996_has_wa(dev) ? FW_STATE_RDY : FW_STATE_NORMAL_TRX;
+	ret = mt7996_firmware_state(dev, fw_state);
 	if (ret)
 		return ret;
 
@@ -4549,7 +4642,7 @@ int mt7996_mcu_fw_log_2_host(struct mt7996_dev *dev, u8 type, u8 ctrl)
 		.ctrl = ctrl,
 	};
 
-	if (type == MCU_FW_LOG_WA)
+	if (type == MCU_FW_LOG_WA && mt7996_has_wa(dev))
 		return mt76_mcu_send_msg(&dev->mt76, MCU_WA_UNI_CMD(WSYS_CONFIG),
 					 &data, sizeof(data), true);
 
@@ -4690,13 +4783,15 @@ int mt7996_mcu_init_firmware(struct mt7996_dev *dev)
 	if (ret)
 		return ret;
 
-	ret = mt7996_mcu_fw_log_2_host(dev, MCU_FW_LOG_WA, 1);
-	if (ret)
-		return ret;
+	if (mt7996_has_wa(dev)) {
+		ret = mt7996_mcu_fw_log_2_host(dev, MCU_FW_LOG_WA, 1);
+		if (ret)
+			return ret;
 
-	ret = mt7996_mcu_set_mwds(dev, 1);
-	if (ret)
-		return ret;
+		ret = mt7996_mcu_set_mwds(dev, 1);
+		if (ret)
+			return ret;
+	}
 
 	ret = mt7996_mcu_init_rx_airtime(dev);
 	if (ret)
@@ -4723,7 +4818,7 @@ int mt7996_mcu_init(struct mt7996_dev *dev)
 void mt7996_mcu_exit(struct mt7996_dev *dev)
 {
 	mt7996_mcu_restart(&dev->mt76);
-	if (mt7996_firmware_state(dev, false)) {
+	if (mt7996_firmware_state(dev, FW_STATE_FW_DOWNLOAD)) {
 		dev_err(dev->mt76.dev, "Failed to exit mcu\n");
 		goto out;
 	}
@@ -4738,13 +4833,21 @@ out:
 
 static int mt7996_mcu_wa_red_config(struct mt7996_dev *dev)
 {
-#define RED_TOKEN_SRC_CNT	4
 #define RED_TOKEN_CONFIG	2
-	struct {
-		__le32 arg0;
-		__le32 arg1;
-		__le32 arg2;
+#define RED_TOKEN_SRC_CNT	4
+#define RED_MAX_BAND_CNT	4
+
+	struct mt7996_wa_params {
+		__le32 arg[3];
+	} __packed;
 
+	struct mt7996_red_config_hdr {
+		u8 rsv[4];
+		__le16 tag;
+		__le16 len;
+	} __packed;
+
+	struct mt7996_red_config {
 		u8 mode;
 		u8 version;
 		u8 _rsv[4];
@@ -4754,30 +4857,53 @@ static int mt7996_mcu_wa_red_config(struct mt7996_dev *dev)
 		__le16 priority_offset;
 		__le16 token_per_src[RED_TOKEN_SRC_CNT];
 		__le16 token_thr_per_src[RED_TOKEN_SRC_CNT];
+	} __packed;
+	struct mt7996_red_config *req;
+	void *data;
+	int ret, len = sizeof(struct mt7996_red_config);
+	u8 i;
 
-		u8 _rsv2[604];
-	} __packed req = {
-		.arg0 = cpu_to_le32(MCU_WA_PARAM_RED_CONFIG),
+	len += is_mt7990(&dev->mt76) ?
+		sizeof(struct mt7996_red_config_hdr) + 1120 :
+		sizeof(struct mt7996_wa_params) + 604;
 
-		.mode = RED_TOKEN_CONFIG,
-		.len = cpu_to_le16(sizeof(req) - sizeof(__le32) * 3),
+	data = kzalloc(len, GFP_KERNEL);
 
-		.tcp_offset = cpu_to_le16(200),
-		.priority_offset = cpu_to_le16(255),
-	};
-	u8 i;
+	if (is_mt7990(&dev->mt76)) {
+		struct mt7996_red_config_hdr *hdr = (struct mt7996_red_config_hdr *)data;
 
+		hdr->tag = cpu_to_le16(UNI_CMD_SDO_RED_SETTING);
+		hdr->len = cpu_to_le16(len - 4);
+		req = (struct mt7996_red_config *)(data + sizeof(*hdr));
+		req->len = cpu_to_le16(len - sizeof(*hdr));
+	} else {
+		struct mt7996_wa_params *param = (struct mt7996_wa_params *)data;
+
+		param->arg[0] = cpu_to_le32(MCU_WA_PARAM_RED_CONFIG);
+		req = (struct mt7996_red_config *)(data + sizeof(*param));
+		req->len = cpu_to_le16(len - sizeof(*param));
+	}
+
+	req->mode = RED_TOKEN_CONFIG;
+	req->tcp_offset = cpu_to_le16(200);
+	req->priority_offset = cpu_to_le16(255);
 	for (i = 0; i < RED_TOKEN_SRC_CNT; i++) {
-		req.token_per_src[i] = cpu_to_le16(MT7996_TOKEN_SIZE);
-		req.token_thr_per_src[i] = cpu_to_le16(MT7996_TOKEN_SIZE);
+		req->token_per_src[i] = cpu_to_le16(MT7996_TOKEN_SIZE);
+		req->token_thr_per_src[i] = cpu_to_le16(MT7996_TOKEN_SIZE);
 	}
 
-	if (!mtk_wed_device_active(&dev->mt76.mmio.wed))
-		req.token_per_src[RED_TOKEN_SRC_CNT - 1] =
-			cpu_to_le16(MT7996_SW_TOKEN_SIZE);
+	req->token_per_src[RED_TOKEN_SRC_CNT - 1] = dev->mt76.token_size;
 
-	return mt76_mcu_send_msg(&dev->mt76, MCU_WA_PARAM_CMD(SET),
-				 &req, sizeof(req), false);
+	if (is_mt7990(&dev->mt76))
+		ret = mt76_mcu_send_msg(&dev->mt76, MCU_WA_UNI_CMD(SDO), data,
+					len, true);
+	else
+		ret = mt76_mcu_send_msg(&dev->mt76, MCU_WA_PARAM_CMD(SET), data,
+					len, false);
+
+	kfree(data);
+
+	return ret;
 }
 
 int mt7996_mcu_red_config(struct mt7996_dev *dev, bool enable)
@@ -5229,6 +5355,9 @@ static int mt7996_mcu_set_cal_free_data(struct mt7996_dev *dev)
 	static const u16 adie_base_7992[] = {
 		EFUSE_BASE_OFFS_ADIE0, EFUSE_BASE_OFFS_ADIE1_7992, 0x0
 	};
+	static const u16 adie_base_7990[] = {
+		EFUSE_BASE_OFFS_ADIE0, 0x0, 0x0
+	};
 	static const u16 *adie_offs[__MT_MAX_BAND];
 	static const u16 *eep_offs[__MT_MAX_BAND];
 	static const u16 *adie_base;
@@ -5279,6 +5408,13 @@ static int mt7996_mcu_set_cal_free_data(struct mt7996_dev *dev)
 		adie_offs[1] = adie_offs_list[adie_id];
 		eep_offs[1] = eep_offs_list[adie_id];
 		break;
+	case MT7990_DEVICE_ID:
+		adie_base = adie_base_7990;
+		/* adie 0 */
+		adie_id = ADIE_7976;
+		adie_offs[0] = adie_offs_list[adie_id];
+		eep_offs[0] = eep_offs_list[adie_id];
+		break;
 	default:
 		return -EINVAL;
 	}
@@ -6494,7 +6630,7 @@ int mt7996_mcu_wtbl_update_hdr_trans(struct mt7996_dev *dev,
 	/* starec hdr trans */
 	mt7996_mcu_sta_hdr_trans_tlv(dev, skb, vif, mlink);
 	return mt76_mcu_skb_send_msg(&dev->mt76, skb,
-				     MCU_WMWA_UNI_CMD(STA_REC_UPDATE), true);
+				     MCU_WM_UNI_CMD(STA_REC_UPDATE), true);
 }
 
 int mt7996_mcu_ps_leave(struct mt7996_dev *dev, struct mt7996_bss_conf *mconf,
@@ -6765,6 +6901,33 @@ int mt7996_mcu_get_all_sta_info(struct mt76_dev *dev, u16 tag)
 				 &req, sizeof(req), false);
 }
 
+int mt7996_mcu_get_bss_acq_pkt_cnt(struct mt7996_dev *dev)
+{
+	struct {
+		u8 _rsv[4];
+
+		__le16 tag;
+		__le16 len;
+
+		__le32 bitmap[UNI_CMD_SDO_CFG_BSS_MAP_WORDLEN];
+	} __packed req = {
+		.tag = cpu_to_le16(UNI_CMD_SDO_GET_BSS_ACQ_PKT_NUM),
+		.len = cpu_to_le16(sizeof(req) - 4),
+	};
+	int i = 0;
+
+	if (mt7996_has_wa(dev))
+		return mt7996_mcu_wa_cmd(dev, MCU_WA_PARAM_CMD(QUERY),
+			MCU_WA_PARAM_BSS_ACQ_PKT_CNT,
+			BSS_ACQ_PKT_CNT_BSS_BITMAP_ALL | BSS_ACQ_PKT_CNT_READ_CLR, 0);
+
+	for (i = 0; i < UNI_CMD_SDO_CFG_BSS_MAP_WORDLEN; i++)
+		req.bitmap[i] = cpu_to_le32(~0);
+
+	return mt76_mcu_send_msg(&dev->mt76, MCU_WA_UNI_CMD(SDO), &req,
+				 sizeof(req), true);
+}
+
 int mt7996_mcu_wed_rro_reset_sessions(struct mt7996_dev *dev, u16 id)
 {
 	struct {
@@ -7197,13 +7360,30 @@ void mt7996_free_afc_table(struct mt7996_dev *dev)
 
 int mt7996_mcu_cp_support(struct mt7996_dev *dev, u8 mode)
 {
+	struct {
+		u8 _rsv[4];
+
+		__le16 tag;
+		__le16 len;
+		u8 cp_mode;
+		u8 rsv[3];
+	} __packed req = {
+		.tag = cpu_to_le16(UNI_CMD_SDO_CP_MODE),
+		.len = cpu_to_le16(sizeof(req) - 4),
+		.cp_mode = mode,
+	};
 	__le32 cp_mode;
 
 	if (mode < mt76_connac_lmac_mapping(IEEE80211_AC_BE) ||
 	    mode > mt76_connac_lmac_mapping(IEEE80211_AC_VO))
 		return -EINVAL;
 
+	if (!mt7996_has_wa(dev))
+		return mt76_mcu_send_msg(&dev->mt76, MCU_WA_UNI_CMD(SDO),
+					 &req, sizeof(req), true);
+
 	cp_mode = cpu_to_le32(mode);
+
 	return mt76_mcu_send_msg(&dev->mt76, MCU_WA_EXT_CMD(CP_SUPPORT),
 				 &cp_mode, sizeof(cp_mode), true);
 }
@@ -7327,7 +7507,20 @@ int mt7996_mcu_set_pp_alg_ctrl(struct mt7996_phy *phy, u8 action)
 		__le16 len;
 
 		__le32 pp_timer_intv;
-		__le32 rsv2[14];
+		__le32 thr_x2_value;
+		__le32 thr_x2_shift;
+		__le32 thr_x3_value;
+		__le32 thr_x3_shift;
+		__le32 thr_x4_value;
+		__le32 thr_x4_shift;
+		__le32 thr_x5_value;
+		__le32 thr_x5_shift;
+		__le32 thr_x6_value;
+		__le32 thr_x6_shift;
+		__le32 thr_x7_value;
+		__le32 thr_x7_shift;
+		__le32 thr_x8_value;
+		__le32 thr_x8_shift;
 		u8 band_idx;
 		u8 pp_action;
 		u8 reset;
@@ -7336,12 +7529,53 @@ int mt7996_mcu_set_pp_alg_ctrl(struct mt7996_phy *phy, u8 action)
 		.tag = cpu_to_le16(UNI_CMD_PP_ALG_CTRL),
 		.len = cpu_to_le16(sizeof(req) - 4),
 
-		.pp_timer_intv = action == PP_ALG_SET_TIMER ? 2000 : 0,
+		.pp_timer_intv = 0,
+		.thr_x2_value = 0,
+		.thr_x2_shift = 0,
+		.thr_x3_value = 0,
+		.thr_x3_shift = 0,
+		.thr_x4_value = 0,
+		.thr_x4_shift = 0,
+		.thr_x5_value = 0,
+		.thr_x5_shift = 0,
+		.thr_x6_value = 0,
+		.thr_x6_shift = 0,
+		.thr_x7_value = 0,
+		.thr_x7_shift = 0,
+		.thr_x8_value = 0,
+		.thr_x8_shift = 0,
 		.band_idx = phy->mt76->band_idx,
 		.pp_action = action,
 		.reset = 0,
 	};
 
+	switch (action)
+	{
+	case PP_ALG_SET_TIMER:
+		req.pp_timer_intv = 5000;
+		break;
+	case PP_ALG_SET_THR:
+		req.thr_x2_value = 1;
+		req.thr_x2_shift = 0;
+		req.thr_x3_value = 5000000;
+		req.thr_x3_shift = 3;
+		req.thr_x4_value = 1;
+		req.thr_x4_shift = 1;
+		req.thr_x5_value = 1;
+		req.thr_x5_shift = 0;
+		req.thr_x6_value = 1;
+		req.thr_x6_shift = 3;
+		req.thr_x7_value = 1;
+		req.thr_x7_shift = 0;
+		req.thr_x8_value = 5000000;
+		req.thr_x8_shift = 2;
+		break;
+	case PP_ALG_GET_STATISTICS:
+		break;
+	default:
+		return 0;
+	}
+
 	return mt76_mcu_send_msg(&dev->mt76, MCU_WM_UNI_CMD(PP),
 				 &req, sizeof(req), false);
 }
@@ -8028,13 +8262,22 @@ int mt7996_mcu_set_qos_map(struct mt7996_dev *dev, struct mt7996_bss_conf *mconf
 			   struct cfg80211_qos_map *usr_qos_map)
 {
 	struct {
-		u8 bss_idx;
-		u8 qos_map_enable;
-		u8 __rsv[2];
-		s8 qos_map[IP_DSCP_NUM];
+		u8 _rsv[4];
+
+		__le16 tag;
+		__le16 len;
+
+		struct {
+			u8 bss_idx;
+			u8 qos_map_enable;
+			u8 __rsv[2];
+			s8 qos_map[IP_DSCP_NUM];
+		} data;
 	} __packed req = {
-		.bss_idx = mconf->mt76.idx,
-		.qos_map_enable = true,
+		.tag = cpu_to_le16(UNI_CMD_SDO_SET_QOS_MAP),
+		.len = cpu_to_le16(sizeof(req) - 4),
+		.data.bss_idx = mconf->mt76.idx,
+		.data.qos_map_enable = true,
 	};
 	s8 i;
 
@@ -8042,17 +8285,18 @@ int mt7996_mcu_set_qos_map(struct mt7996_dev *dev, struct mt7996_bss_conf *mconf
 	 * Three most significant bits of DSCP are used as UP.
 	 */
 	for (i = 0; i < IP_DSCP_NUM; ++i)
-		req.qos_map[i] = i >> 3;
+		req.data.qos_map[i] = i >> 3;
 
 	/* Recommended QoS map, defined in section 4 of RFC8325.
 	 * Used in cfg80211_classify8021d since kernel v6.8.
 	 */
-	req.qos_map[10] = req.qos_map[12] = req.qos_map[14] = req.qos_map[16] = 0;
-	req.qos_map[18] = req.qos_map[20] = req.qos_map[22] = 3;
-	req.qos_map[24] = 4;
-	req.qos_map[40] = 5;
-	req.qos_map[44] = req.qos_map[46] = 6;
-	req.qos_map[48] = 7;
+	req.data.qos_map[10] = req.data.qos_map[12] =
+			       req.data.qos_map[14] = req.data.qos_map[16] = 0;
+	req.data.qos_map[18] = req.data.qos_map[20] = req.data.qos_map[22] = 3;
+	req.data.qos_map[24] = 4;
+	req.data.qos_map[40] = 5;
+	req.data.qos_map[44] = req.data.qos_map[46] = 6;
+	req.data.qos_map[48] = 7;
 
 	/* User-defined QoS map */
 	if (usr_qos_map) {
@@ -8061,7 +8305,7 @@ int mt7996_mcu_set_qos_map(struct mt7996_dev *dev, struct mt7996_bss_conf *mconf
 			u8 high = usr_qos_map->up[i].high;
 
 			if (low < IP_DSCP_NUM && high < IP_DSCP_NUM && low <= high)
-				memset(req.qos_map + low, i, high - low + 1);
+				memset(req.data.qos_map + low, i, high - low + 1);
 		}
 
 		for (i = 0; i < usr_qos_map->num_des; ++i) {
@@ -8069,13 +8313,17 @@ int mt7996_mcu_set_qos_map(struct mt7996_dev *dev, struct mt7996_bss_conf *mconf
 			u8 up = usr_qos_map->dscp_exception[i].up;
 
 			if (dscp < IP_DSCP_NUM && up < IEEE80211_NUM_UPS)
-				req.qos_map[dscp] = up;
+				req.data.qos_map[dscp] = up;
 		}
 	}
 
-	memcpy(mconf->vif->qos_map, req.qos_map, IP_DSCP_NUM);
+	memcpy(mconf->vif->qos_map, req.data.qos_map, IP_DSCP_NUM);
 
-	return mt76_mcu_send_msg(&dev->mt76, MCU_WA_EXT_CMD(SET_QOS_MAP), &req,
-				 sizeof(req), false);
+	if (!mt7996_has_wa(dev))
+		return mt76_mcu_send_msg(&dev->mt76, MCU_WA_UNI_CMD(SDO),
+					 &req, sizeof(req), true);
+
+	return mt76_mcu_send_msg(&dev->mt76, MCU_WA_EXT_CMD(SET_QOS_MAP), &req.data,
+				 sizeof(req.data), false);
 }
 #endif
diff --git a/mt7996/mcu.h b/mt7996/mcu.h
index ac699b91..adf31bac 100644
--- a/mt7996/mcu.h
+++ b/mt7996/mcu.h
@@ -1244,6 +1244,30 @@ struct mt7996_mld_event_data {
 	u8 *data;
 };
 
+struct mt7996_mcu_sdo_event {
+	struct mt7996_mcu_rxd rxd;
+
+	/* fixed field */
+	u8 rsv[4];
+	/* tlv */
+	u8 buf[];
+} __packed;
+
+#define UNI_CMD_SDO_CFG_BSS_NUM 96
+#define UNI_CMD_SDO_CFG_BSS_MAP_WORDLEN ((UNI_CMD_SDO_CFG_BSS_NUM) / 32)
+
+struct mt7996_mld_sdo_bss_acq_pkt_cnt {
+	__le16 tag;
+	__le16 len;
+
+	__le32 bitmap[UNI_CMD_SDO_CFG_BSS_MAP_WORDLEN];
+	__le32 pkt_cnt[UNI_CMD_SDO_CFG_BSS_NUM][IEEE80211_NUM_ACS];
+};
+
+enum {
+	UNI_EVENT_SDO_BSS_ACQ_PKT_CNT,
+};
+
 struct mt7996_mcu_mld_attlm_resp_event {
 	__le16 tag;
 	__le16 len;
@@ -1538,7 +1562,8 @@ enum pp_mode {
 
 enum pp_alg_action {
 	PP_ALG_SET_TIMER,
-	PP_ALG_GET_STATISTICS = 2,
+	PP_ALG_SET_THR,
+	PP_ALG_GET_STATISTICS,
 };
 
 enum {
@@ -1632,6 +1657,19 @@ struct mt7996_mlo_agc_set {
 	__le16 mgf;
 } __packed;
 
+enum {
+	UNI_CMD_SDO_SET = 1,
+	UNI_CMD_SDO_QUERY,
+	UNI_CMD_SDO_AUTO_BA,
+	UNI_CMD_SDO_SET_QOS_MAP,
+	UNI_CMD_SDO_HOTSPOT,
+	UNI_CMD_SDO_CP_MODE,
+	UNI_CMD_SDO_RED_SETTING,
+	UNI_CMD_SDO_PKT_BUDGET_CTRL_CFG,
+	UNI_CMD_SDO_GET_BSS_ACQ_PKT_NUM,
+	UNI_CMD_SDO_OVERRIDE_CTRL
+};
+
 #define MT7996_PATCH_SEC		GENMASK(31, 24)
 #define MT7996_PATCH_SCRAMBLE_KEY	GENMASK(15, 8)
 #define MT7996_PATCH_AES_KEY		GENMASK(7, 0)
diff --git a/mt7996/mmio.c b/mt7996/mmio.c
index 6a7a6280..04c988cf 100644
--- a/mt7996/mmio.c
+++ b/mt7996/mmio.c
@@ -54,6 +54,17 @@ static const u32 mt7996_offs[] = {
 	[MIB_BSCR7]		= 0x9e8,
 	[MIB_BSCR17]		= 0xa10,
 	[MIB_TRDR1]		= 0xa28,
+	[HIF_REMAP_L1]		= 0x24,
+	[HIF_REMAP_BASE_L1]	= 0x130000,
+	[HIF_REMAP_L2]		= 0x1b4,
+	[HIF_REMAP_BASE_L2]	= 0x1000,
+	[CBTOP1_PHY_END]	= 0x77ffffff,
+	[INFRA_MCU_END]		= 0x7c3fffff,
+	[WTBLON_WDUCR]		= 0x370,
+	[WTBL_UPDATE]		= 0x380,
+	[WTBL_ITCR]		= 0x3b0,
+	[WTBL_ITCR0]		= 0x3b8,
+	[WTBL_ITCR1]		= 0x3bc,
 };
 
 static const u32 mt7992_offs[] = {
@@ -80,6 +91,54 @@ static const u32 mt7992_offs[] = {
 	[MIB_BSCR7]		= 0xae4,
 	[MIB_BSCR17]		= 0xb0c,
 	[MIB_TRDR1]		= 0xb24,
+	[HIF_REMAP_L1]		= 0x8,
+	[HIF_REMAP_BASE_L1]	= 0x40000,
+	[HIF_REMAP_L2]		= 0x1b4,
+	[HIF_REMAP_BASE_L2]	= 0x1000,
+	[CBTOP1_PHY_END]	= 0x77ffffff,
+	[INFRA_MCU_END]		= 0x7c3fffff,
+	[WTBLON_WDUCR]		= 0x370,
+	[WTBL_UPDATE]		= 0x380,
+	[WTBL_ITCR]		= 0x3b0,
+	[WTBL_ITCR0]		= 0x3b8,
+	[WTBL_ITCR1]		= 0x3bc,
+};
+
+static const u32 mt7990_offs[] = {
+	[MIB_RVSR0]		= 0x800,
+	[MIB_RVSR1]		= 0x804,
+	[MIB_BTSCR5]		= 0x868,
+	[MIB_BTSCR6]		= 0x878,
+	[MIB_RSCR1]		= 0x890,
+	[MIB_RSCR27]		= 0xa38,
+	[MIB_RSCR28]		= 0xa3c,
+	[MIB_RSCR29]		= 0xa40,
+	[MIB_RSCR30]		= 0xa44,
+	[MIB_RSCR31]		= 0xa48,
+	[MIB_RSCR33]		= 0xa50,
+	[MIB_RSCR35]		= 0xa58,
+	[MIB_RSCR36]		= 0xa5c,
+	[MIB_BSCR0]		= 0xbb8,
+	[MIB_BSCR1]		= 0xbbc,
+	[MIB_BSCR2]		= 0xbc0,
+	[MIB_BSCR3]		= 0xbc4,
+	[MIB_BSCR4]		= 0xbc8,
+	[MIB_BSCR5]		= 0xbcc,
+	[MIB_BSCR6]		= 0xbd0,
+	[MIB_BSCR7]		= 0xbd4,
+	[MIB_BSCR17]		= 0xbfc,
+	[MIB_TRDR1]		= 0xc14,
+	[HIF_REMAP_L1]		= 0x8,
+	[HIF_REMAP_BASE_L1]	= 0x40000,
+	[HIF_REMAP_L2]		= 0x1b8,
+	[HIF_REMAP_BASE_L2]	= 0x110000,
+	[CBTOP1_PHY_END]	= 0x7fffffff,
+	[INFRA_MCU_END]		= 0x7cffffff,
+	[WTBLON_WDUCR]		= 0x400,
+	[WTBL_UPDATE]		= 0x410,
+	[WTBL_ITCR]		= 0x440,
+	[WTBL_ITCR0]		= 0x448,
+	[WTBL_ITCR1]		= 0x44c,
 };
 
 static const struct __map mt7996_reg_map[] = {
@@ -135,14 +194,82 @@ static const struct __map mt7996_reg_map[] = {
 	{ 0x0, 0x0, 0x0 }, /* imply end of search */
 };
 
+static const struct __map mt7990_reg_map[] = {
+	{0x54000000, 0x02000, 0x1000}, /* WFDMA_0 (PCIE0 MCU DMA0) */
+	{0x55000000, 0x03000, 0x1000}, /* WFDMA_1 (PCIE0 MCU DMA1) */
+	{0x56000000, 0x04000, 0x1000}, /* WFDMA_2 (Reserved) */
+	{0x57000000, 0x05000, 0x1000}, /* WFDMA_3 (MCU wrap CR) */
+	{0x58000000, 0x06000, 0x1000}, /* WFDMA_4 (PCIE1 MCU DMA0 (MEM_DMA)) */
+	{0x59000000, 0x07000, 0x1000}, /* WFDMA_5 (PCIE1 MCU DMA1) */
+	{0x820c0000, 0x08000, 0x4000}, /* WF_UMAC_TOP (PLE) */
+	{0x820c8000, 0x0c000, 0x2000}, /* WF_UMAC_TOP (PSE) */
+	{0x820cc000, 0x0e000, 0x2000}, /* WF_UMAC_TOP (PP) */
+	{0x820e0000, 0x20000, 0x0400}, /* WF_LMAC_TOP BN0 (WF_CFG) */
+	{0x820e1000, 0x20400, 0x0200}, /* WF_LMAC_TOP BN0 (WF_TRB) */
+	{0x820e2000, 0x20800, 0x0400}, /* WF_LMAC_TOP BN0 (WF_AGG) */
+	{0x820e3000, 0x20c00, 0x0400}, /* WF_LMAC_TOP BN0 (WF_ARB) */
+	{0x820e4000, 0x21000, 0x0400}, /* WF_LMAC_TOP BN0 (WF_TMAC) */
+	{0x820e5000, 0x21400, 0x0800}, /* WF_LMAC_TOP BN0 (WF_RMAC) */
+	{0x820ce000, 0x21c00, 0x0200}, /* WF_LMAC_TOP (WF_SEC) */
+	{0x820e7000, 0x21e00, 0x0200}, /* WF_LMAC_TOP BN0 (WF_DMA) */
+	{0x820cf000, 0x22000, 0x1000}, /* WF_LMAC_TOP (WF_PF) */
+	{0x820e9000, 0x23400, 0x0200}, /* WF_LMAC_TOP BN0 (WF_WTBLOFF) */
+	{0x820ea000, 0x24000, 0x0200}, /* WF_LMAC_TOP BN0 (WF_ETBF) */
+	{0x820eb000, 0x24200, 0x0400}, /* WF_LMAC_TOP BN0 (WF_LPON) */
+	{0x820ec000, 0x24600, 0x0200}, /* WF_LMAC_TOP BN0 (WF_INT) */
+	{0x820ed000, 0x24800, 0x0800}, /* WF_LMAC_TOP BN0 (WF_MIB) */
+	{0x820ca000, 0x26000, 0x2000}, /* WF_LMAC_TOP BN0 (WF_MUCOP) */
+	{0x820d0000, 0x30000, 0x10000}, /* WF_LMAC_TOP (WF_WTBLON) */
+	{0x00400000, 0x80000, 0x10000}, /* WF_MCU_SYSRAM */
+	{0x820f0000, 0xa0000, 0x0400}, /* WF_LMAC_TOP BN1 (WF_CFG) */
+	{0x820f1000, 0xa0600, 0x0200}, /* WF_LMAC_TOP BN1 (WF_TRB) */
+	{0x820f2000, 0xa0800, 0x0400}, /* WF_LMAC_TOP BN1 (WF_AGG) */
+	{0x820f3000, 0xa0c00, 0x0400}, /* WF_LMAC_TOP BN1 (WF_ARB) */
+	{0x820f4000, 0xa1000, 0x0400}, /* WF_LMAC_TOP BN1 (WF_TMAC) */
+	{0x820f5000, 0xa1400, 0x0800}, /* WF_LMAC_TOP BN1 (WF_RMAC) */
+	{0x820f7000, 0xa1e00, 0x0200}, /* WF_LMAC_TOP BN1 (WF_DMA) */
+	{0x820f9000, 0xa3400, 0x0200}, /* WF_LMAC_TOP BN1 (WF_WTBLOFF) */
+	{0x820fa000, 0xa4000, 0x0200}, /* WF_LMAC_TOP BN1 (WF_ETBF) */
+	{0x820fb000, 0xa4200, 0x0400}, /* WF_LMAC_TOP BN1 (WF_LPON) */
+	{0x820fc000, 0xa4600, 0x0200}, /* WF_LMAC_TOP BN1 (WF_INT) */
+	{0x820fd000, 0xa4800, 0x0800}, /* WF_LMAC_TOP BN1 (WF_MIB) */
+	{0x820cc000, 0xa5000, 0x2000}, /* WF_LMAC_TOP BN1 (WF_MUCOP) */
+	{0x820c4000, 0xa8000, 0x4000}, /* WF_LMAC_TOP (WF_UWTBL) */
+	{0x81030000, 0xae000, 0x100}, /* WFSYS_AON part 1 */
+	{0x81031000, 0xae100, 0x100}, /* WFSYS_AON part 2 */
+	{0x81032000, 0xae200, 0x100}, /* WFSYS_AON part 3 */
+	{0x81033000, 0xae300, 0x100}, /* WFSYS_AON part 4 */
+	{0x81034000, 0xae400, 0x100}, /* WFSYS_AON part 5 */
+	{0x80020000, 0xb0000, 0x10000}, /* WF_TOP_MISC_OFF */
+	{0x81020000, 0xc0000, 0x10000}, /* WF_TOP_MISC_ON */
+	{0x81040000, 0x120000, 0x1000}, /* WF_MCU_CFG_ON */
+	{0x81050000, 0x121000, 0x1000}, /* WF_MCU_EINT */
+	{0x81060000, 0x122000, 0x1000}, /* WF_MCU_GPT */
+	{0x81070000, 0x123000, 0x1000}, /* WF_MCU_WDT */
+	{0x80010000, 0x124000, 0x1000}, /* WF_AXIDMA */
+	{0x7c020000, 0xd0000, 0x10000}, /* CONN_INFRA, wfdma for from CODA flow use */
+	{0x7c060000, 0xe0000, 0x10000}, /* CONN_INFRA, conn_host_csr_top for from CODA flow use */
+	{0x20020000, 0xd0000, 0x10000}, /* CONN_INFRA, wfdma */
+	{0x20060000, 0xe0000, 0x10000}, /* CONN_INFRA, conn_host_csr_top */
+	{0x7c000000, 0xf0000, 0x10000}, /* CONN_INFRA */
+	{0x70020000, 0x1f0000, 0x9000}, /* PCIE remapping (AP2CONN) */
+	{0x0, 0x0, 0x0}, /* imply end of search */
+};
+
 static u32 mt7996_reg_map_l1(struct mt7996_dev *dev, u32 addr)
 {
 	u32 offset = FIELD_GET(MT_HIF_REMAP_L1_OFFSET, addr);
 	u32 base = FIELD_GET(MT_HIF_REMAP_L1_BASE, addr);
+	u32 l1_mask = MT_HIF_REMAP_L1_MASK;
+	u32 val = FIELD_PREP(MT_HIF_REMAP_L1_MASK, base);
+
+	if (is_mt7996(&dev->mt76)) {
+		l1_mask = MT_HIF_REMAP_L1_MASK_7996;
+		val = FIELD_PREP(MT_HIF_REMAP_L1_MASK_7996, base);
+	}
 
 	dev->bus_ops->rmw(&dev->mt76, MT_HIF_REMAP_L1,
-			  MT_HIF_REMAP_L1_MASK,
-			  FIELD_PREP(MT_HIF_REMAP_L1_MASK, base));
+			  l1_mask, val);
 	/* use read to push write */
 	dev->bus_ops->rr(&dev->mt76, MT_HIF_REMAP_L1);
 
@@ -153,16 +280,38 @@ static u32 mt7996_reg_map_l2(struct mt7996_dev *dev, u32 addr)
 {
 	u32 offset = FIELD_GET(MT_HIF_REMAP_L2_OFFSET, addr);
 	u32 base = FIELD_GET(MT_HIF_REMAP_L2_BASE, addr);
+	u32 l2_mask = MT_HIF_REMAP_L2_MASK;
+	u32 val = FIELD_PREP(MT_HIF_REMAP_L2_MASK, base);
+
+	if (is_mt7990(&dev->mt76)) {
+		offset = FIELD_GET(MT_HIF_REMAP_L2_OFFSET_7990, addr);
+		base = FIELD_GET(MT_HIF_REMAP_L2_BASE_7990, addr);
+		l2_mask = MT_HIF_REMAP_L2_MASK_7990;
+		val = FIELD_PREP(MT_HIF_REMAP_L2_MASK_7990, base);
+	}
 
 	dev->bus_ops->rmw(&dev->mt76, MT_HIF_REMAP_L2,
-			  MT_HIF_REMAP_L2_MASK,
-			  FIELD_PREP(MT_HIF_REMAP_L2_MASK, base));
+			  l2_mask, val);
 	/* use read to push write */
 	dev->bus_ops->rr(&dev->mt76, MT_HIF_REMAP_L2);
 
 	return MT_HIF_REMAP_BASE_L2 + offset;
 }
 
+static u32 mt7996_reg_map_cbtop(struct mt7996_dev *dev, u32 addr)
+{
+	u32 offset = FIELD_GET(MT_HIF_REMAP_CBTOP_OFFSET, addr);
+	u32 base = FIELD_GET(MT_HIF_REMAP_CBTOP_BASE, addr);
+
+	dev->bus_ops->rmw(&dev->mt76, MT_HIF_REMAP_CBTOP,
+			  MT_HIF_REMAP_CBTOP_MASK,
+			  FIELD_PREP(MT_HIF_REMAP_CBTOP_MASK, base));
+	/* use read to push write */
+	dev->bus_ops->rr(&dev->mt76, MT_HIF_REMAP_CBTOP);
+
+	return MT_HIF_REMAP_BASE_CBTOP + offset;
+}
+
 static u32 __mt7996_reg_addr(struct mt7996_dev *dev, u32 addr)
 {
 	int i;
@@ -193,17 +342,20 @@ static u32 __mt7996_reg_remap_addr(struct mt7996_dev *dev, u32 addr)
 	    (addr >= MT_WFSYS1_PHY_START && addr <= MT_WFSYS1_PHY_END))
 		return mt7996_reg_map_l1(dev, addr);
 
-	if (dev_is_pci(dev->mt76.dev) &&
-	    ((addr >= MT_CBTOP1_PHY_START && addr <= MT_CBTOP1_PHY_END) ||
-	    addr >= MT_CBTOP2_PHY_START))
-		return mt7996_reg_map_l1(dev, addr);
-
 	/* CONN_INFRA: covert to phyiscal addr and use layer 1 remap */
 	if (addr >= MT_INFRA_MCU_START && addr <= MT_INFRA_MCU_END) {
 		addr = addr - MT_INFRA_MCU_START + MT_INFRA_BASE;
 		return mt7996_reg_map_l1(dev, addr);
 	}
 
+	if (dev_is_pci(dev->mt76.dev) &&
+	    ((addr >= MT_CBTOP1_PHY_START && addr <= MT_CBTOP1_PHY_END) ||
+	    addr >= MT_CBTOP2_PHY_START)) {
+		if (is_mt7990(&dev->mt76))
+			return mt7996_reg_map_cbtop(dev, addr);
+		return mt7996_reg_map_l1(dev, addr);
+	}
+
 	return mt7996_reg_map_l2(dev, addr);
 }
 
@@ -305,7 +457,7 @@ int mt7996_mmio_wed_init(struct mt7996_dev *dev, void *pdev_ptr,
 #ifdef CONFIG_NET_MEDIATEK_SOC_WED
 	struct mtk_wed_device *wed = &dev->mt76.mmio.wed;
 	struct pci_dev *pci_dev = pdev_ptr;
-	u32 hif1_ofs = 0;
+	u32 hif1_ofs = 0, intr, ring;
 
 	if (!wed_enable)
 		return 0;
@@ -335,16 +487,26 @@ int mt7996_mmio_wed_init(struct mt7996_dev *dev, void *pdev_ptr,
 					     MT_TXQ_RING_BASE(0) +
 					     MT7996_TXQ_BAND2 * MT_RING_SIZE;
 		if (dev->has_rro) {
-			u8 rxq_id = is_mt7996(&dev->mt76) ?
-				    MT7996_RXQ_TXFREE2 : MT7996_RXQ_MCU_WA_EXT;
+			switch (mt76_chip(&dev->mt76)) {
+			case MT7996_DEVICE_ID:
+				intr = MT_INT_RX_TXFREE_EXT;
+				ring = MT7996_RXQ_TXFREE2;
+				break;
+			case MT7992_DEVICE_ID:
+				intr = MT_INT_RX_TXFREE_BAND1_EXT;
+				ring = MT7996_RXQ_MCU_WA_EXT;
+				break;
+			case MT7990_DEVICE_ID:
+			default:
+				intr = MT_INT_RX_TXFREE_BAND1_MT7990;
+				ring = MT7990_RXQ_TXFREE1;
+				break;
+			}
 
+			wed->wlan.txfree_tbit = ffs(intr) - 1;
 			wed->wlan.wpdma_txfree = wed->wlan.phy_base + hif1_ofs +
 						 MT_RXQ_RING_BASE(0) +
-						 rxq_id * MT_RING_SIZE;
-			if (is_mt7996(&dev->mt76))
-				wed->wlan.txfree_tbit = ffs(MT_INT_RX_TXFREE_EXT) - 1;
-			else
-				wed->wlan.txfree_tbit = ffs(MT_INT_RX_TXFREE_BAND1_EXT) - 1;
+						 ring * MT_RING_SIZE;
 		} else {
 			wed->wlan.wpdma_txfree = wed->wlan.phy_base + hif1_ofs +
 						 MT_RXQ_RING_BASE(0) +
@@ -412,24 +574,34 @@ int mt7996_mmio_wed_init(struct mt7996_dev *dev, void *pdev_ptr,
 
 		wed->wlan.tx_tbit[0] = ffs(MT_INT_TX_DONE_BAND0) - 1;
 		wed->wlan.tx_tbit[1] = ffs(MT_INT_TX_DONE_BAND1) - 1;
-		if (is_mt7996(&dev->mt76)) {
+		switch (mt76_chip(&dev->mt76)) {
+		case MT7996_DEVICE_ID:
 			if (dev->has_rro) {
-				wed->wlan.wpdma_txfree = wed->wlan.phy_base + MT_RXQ_RING_BASE(0) +
-							 MT7996_RXQ_TXFREE0 * MT_RING_SIZE;
-				wed->wlan.txfree_tbit = ffs(MT_INT_RX_TXFREE_MAIN) - 1;
+				intr = MT_INT_RX_TXFREE_MAIN;
+				ring = MT7996_RXQ_TXFREE0;
 			} else {
-				wed->wlan.txfree_tbit = ffs(MT_INT_RX_DONE_WA_MAIN) - 1;
-				wed->wlan.wpdma_txfree = wed->wlan.phy_base + MT_RXQ_RING_BASE(0) +
-							 MT7996_RXQ_MCU_WA_MAIN * MT_RING_SIZE;
+				intr = MT_INT_RX_DONE_WA_MAIN;
+				ring = MT7996_RXQ_MCU_WA_MAIN;
 			}
-		} else {
-			wed->wlan.txfree_tbit = ffs(MT_INT_RX_DONE_WA_MAIN) - 1;
-			wed->wlan.wpdma_txfree = wed->wlan.phy_base + MT_RXQ_RING_BASE(0) +
-						 MT7996_RXQ_MCU_WA_MAIN * MT_RING_SIZE;
+			break;
+		case MT7992_DEVICE_ID:
+			intr = MT_INT_RX_DONE_WA_MAIN;
+			ring = MT7996_RXQ_MCU_WA_MAIN;
+			if (dev->hif2)
+				wed->wlan.id = MT7992_DEVICE_ID;
+			break;
+		case MT7990_DEVICE_ID:
+		default:
+			intr = MT_INT_RX_TXFREE_BAND0_MT7990;
+			ring = MT7990_RXQ_TXFREE0;
+			if (dev->hif2)
+				wed->wlan.id = MT7990_DEVICE_ID;
+			break;
 		}
+		wed->wlan.txfree_tbit = ffs(intr) - 1;
+		wed->wlan.wpdma_txfree = wed->wlan.phy_base + MT_RXQ_RING_BASE(0) +
+					 ring * MT_RING_SIZE;
 		dev->mt76.rx_token_size = MT7996_TOKEN_SIZE + wed->wlan.rx_npkt;
-		if(dev->hif2 && is_mt7992(&dev->mt76))
-			wed->wlan.id = 0x7992;
 	}
 
 	wed->wlan.nbuf = MT7996_TOKEN_SIZE;
@@ -489,6 +661,12 @@ static int mt7996_mmio_init(struct mt76_dev *mdev,
 		dev->reg.map = mt7996_reg_map;
 		dev->reg.map_size = ARRAY_SIZE(mt7996_reg_map);
 		break;
+	case MT7990_DEVICE_ID:
+		dev->reg.base = mt7996_reg_base;
+		dev->reg.offs_rev = mt7990_offs;
+		dev->reg.map = mt7990_reg_map;
+		dev->reg.map_size = ARRAY_SIZE(mt7990_reg_map);
+		break;
 	default:
 		return -EINVAL;
 	}
diff --git a/mt7996/mt7996.h b/mt7996/mt7996.h
index 8c93a3b8..5cfd597e 100644
--- a/mt7996/mt7996.h
+++ b/mt7996/mt7996.h
@@ -35,6 +35,8 @@
 #define MT7996_DEVICE_ID_2		0x7991
 #define MT7992_DEVICE_ID		0x7992
 #define MT7992_DEVICE_ID_2		0x799a
+#define MT7990_DEVICE_ID		0x7993
+#define MT7990_DEVICE_ID_2		0x799b
 
 #define MT7996_FIRMWARE_WA		"mediatek/mt7996/mt7996_wa.bin"
 #define MT7996_FIRMWARE_WM		"mediatek/mt7996/mt7996_wm.bin"
@@ -66,6 +68,12 @@
 #define MT7992_FIRMWARE_WM_TM_24	"mediatek/mt7996/mt7992_wm_tm_24.bin"
 #define MT7992_ROM_PATCH_24		"mediatek/mt7996/mt7992_rom_patch_24.bin"
 
+#define MT7990_FIRMWARE_WA		""
+#define MT7990_FIRMWARE_WM		"mediatek/mt7996/mt7990_wm.bin"
+#define MT7990_FIRMWARE_DSP		""
+#define MT7990_FIRMWARE_WM_TM		"mediatek/mt7996/mt7990_wm_tm.bin"
+#define MT7990_ROM_PATCH		"mediatek/mt7996/mt7990_rom_patch.bin"
+
 #define MT7996_EEPROM_DEFAULT		"mediatek/mt7996/mt7996_eeprom.bin"
 #define MT7996_EEPROM_DEFAULT_INT	"mediatek/mt7996/mt7996_eeprom_2i5i6i.bin"
 #define MT7996_EEPROM_DEFAULT_233	"mediatek/mt7996/mt7996_eeprom_233.bin"
@@ -79,6 +87,9 @@
 #define MT7992_EEPROM_DEFAULT_23_INT	"mediatek/mt7996/mt7992_eeprom_23_2i5i.bin"
 #define MT7992_EEPROM_DEFAULT_24	"mediatek/mt7996/mt7992_eeprom_24_2i5i.bin"
 
+#define MT7990_EEPROM_DEFAULT		"mediatek/mt7996/mt7990_eeprom.bin"
+#define MT7990_EEPROM_DEFAULT_INT	"mediatek/mt7996/mt7990_eeprom_2i5i.bin"
+
 #define MT7996_EEPROM_SIZE		7680
 #define MT7996_EEPROM_BLOCK_SIZE		16
 #define MT7996_EXT_EEPROM_BLOCK_SIZE	1024
@@ -179,6 +190,10 @@ enum mt7992_var_type {
 	MT7992_VAR_TYPE_24,
 };
 
+enum mt7990_var_type {
+	MT7990_VAR_TYPE_23,
+};
+
 enum mt7996_fem_type {
 	MT7996_FEM_EXT,
 	MT7996_FEM_INT,
@@ -196,6 +211,7 @@ enum mt7996_eeprom_mode {
 enum mt7996_ddie_type {
 	DDIE_7996,
 	DDIE_7992,
+	DDIE_7990,
 	DDIE_TYPE_NUM,
 };
 
@@ -252,6 +268,20 @@ enum mt7996_rxq_id {
 	MT7996_RXQ_TXFREE1 = 9,
 	MT7996_RXQ_TXFREE2 = 7,
 	MT7996_RXQ_RRO_IND = 0,
+	MT7990_RXQ_TXFREE0 = 6,
+	MT7990_RXQ_TXFREE1 = 7,
+};
+
+enum {
+	MT7996_TXFREE_FROM_MAC,
+	MT7996_TXFREE_FROM_WA,
+};
+
+enum {
+	MT7996_RRO_BMC_NOT_BYPASS_UC_BASED_ON_WTBL,
+	MT7996_RRO_ALL_NOT_BYPASS,
+	MT7996_RRO_BMC_BYPASS_UC_BASED_ON_WTBL,
+	MT7996_RRO_ALL_BYPASS,
 };
 
 struct mt7996_twt_flow {
@@ -813,6 +843,9 @@ struct mt7996_dev {
 	bool has_eht:1;
 	bool has_rro:1;
 
+	bool fips_cap:1;
+	bool pwr_boost_cap:1;
+
 	struct {
 		struct {
 			void *ptr;
@@ -993,7 +1026,7 @@ mt7996_phy3(struct mt7996_dev *dev)
 static inline bool
 mt7996_band_valid(struct mt7996_dev *dev, u8 band)
 {
-	if (is_mt7992(&dev->mt76))
+	if (is_mt7992(&dev->mt76) || is_mt7990(&dev->mt76))
 		return band <= MT_BAND1;
 
 	if (dev->var.type == MT7996_VAR_TYPE_404 && band == MT_BAND1)
@@ -1015,6 +1048,8 @@ mt7996_has_background_radar(struct mt7996_dev *dev)
 		    dev->var.type == MT7992_VAR_TYPE_24)
 			return false;
 		break;
+	case MT7990_DEVICE_ID:
+		break;
 	default:
 		return false;
 	}
@@ -1029,6 +1064,7 @@ mt7996_has_ext_eeprom(struct mt7996_dev *dev)
 	case MT7996_DEVICE_ID:
 		return false;
 	case MT7992_DEVICE_ID:
+	case MT7990_DEVICE_ID:
 	default:
 		return true;
 	}
@@ -1248,6 +1284,7 @@ void mt7996_mcu_exit(struct mt7996_dev *dev);
 int mt7996_mcu_get_per_sta_info(struct mt76_dev *dev, u16 tag,
 	                        u16 sta_num, u16 *sta_list);
 int mt7996_mcu_get_all_sta_info(struct mt76_dev *dev, u16 tag);
+int mt7996_mcu_get_bss_acq_pkt_cnt(struct mt7996_dev *dev);
 int mt7996_mcu_wed_rro_reset_sessions(struct mt7996_dev *dev, u16 id);
 int mt7996_mcu_set_sniffer_mode(struct mt7996_phy *phy, bool enabled);
 int mt7996_mcu_set_tx_power_ctrl(struct mt7996_phy *phy, u8 power_ctrl_id, u8 data);
@@ -1271,6 +1308,11 @@ int mt7996_mcu_mld_set_attlm(struct mt7996_dev *dev, struct ieee80211_vif *vif,
 int mt7996_mcu_peer_mld_ttlm_req(struct mt7996_dev *dev, struct ieee80211_vif *vif,
 				 u64 changed);
 
+static inline bool mt7996_has_wa(struct mt7996_dev *dev)
+{
+	return !is_mt7990(&dev->mt76);
+}
+
 static inline u8 mt7996_max_interface_num(struct mt7996_dev *dev)
 {
 	return min(MT7996_MAX_INTERFACES * (1 + mt7996_band_valid(dev, MT_BAND1) +
diff --git a/mt7996/mtk_debug.h b/mt7996/mtk_debug.h
index 82990239..d7343045 100644
--- a/mt7996/mtk_debug.h
+++ b/mt7996/mtk_debug.h
@@ -46,6 +46,17 @@ enum dbg_offs_rev {
 	MIB_MSR2,
 	MIB_MCTR5,
 	MIB_MCTR6,
+	MIB_TSCR0,
+	MIB_TSCR3,
+	MIB_TSCR4,
+	MIB_TSCR5,
+	MIB_TSCR6,
+	MIB_TSCR7,
+	MIB_TSCR8,
+	MIB_TBCR0,
+	MIB_TBCR1,
+	MIB_TBCR2,
+	MIB_TBCR3,
 	__MT_DBG_OFFS_REV_MAX,
 };
 
@@ -83,6 +94,17 @@ static const u32 mt7996_dbg_offs[] = {
 	[MIB_MSR2]		= 0xa6c,
 	[MIB_MCTR5]		= 0xa70,
 	[MIB_MCTR6]		= 0xa74,
+	[MIB_TSCR0]		= 0x6b0,
+	[MIB_TSCR3]		= 0x6bc,
+	[MIB_TSCR4]		= 0x6c0,
+	[MIB_TSCR5]		= 0x6c4,
+	[MIB_TSCR6]		= 0x6c8,
+	[MIB_TSCR7]		= 0x6d0,
+	[MIB_TSCR8]		= 0x6cc,
+	[MIB_TBCR0]		= 0x6ec,
+	[MIB_TBCR1]		= 0x6f0,
+	[MIB_TBCR2]		= 0x6f4,
+	[MIB_TBCR3]		= 0x6f8,
 };
 
 static const u32 mt7992_dbg_offs[] = {
@@ -119,6 +141,64 @@ static const u32 mt7992_dbg_offs[] = {
 	[MIB_MSR2]		= 0xb68,
 	[MIB_MCTR5]		= 0xb6c,
 	[MIB_MCTR6]		= 0xb70,
+	[MIB_TSCR0]		= 0x6b0,
+	[MIB_TSCR3]		= 0x6bc,
+	[MIB_TSCR4]		= 0x6c0,
+	[MIB_TSCR5]		= 0x6c4,
+	[MIB_TSCR6]		= 0x6c8,
+	[MIB_TSCR7]		= 0x6d0,
+	[MIB_TSCR8]		= 0x6cc,
+	[MIB_TBCR0]		= 0x6ec,
+	[MIB_TBCR1]		= 0x6f0,
+	[MIB_TBCR2]		= 0x6f4,
+	[MIB_TBCR3]		= 0x6f8,
+};
+
+static const u32 mt7990_dbg_offs[] = {
+	[AGG_AALCR2]		= 0x12c,
+	[AGG_AALCR3]		= 0x130,
+	[AGG_AALCR4]		= 0x134,
+	[AGG_AALCR5]		= 0x138,
+	[AGG_AALCR6]		= 0x13c,
+	[AGG_AALCR7]		= 0x140,
+	[MIB_TDRCR0]		= 0x808,
+	[MIB_TDRCR1]		= 0x80c,
+	[MIB_TDRCR2]		= 0x810,
+	[MIB_TDRCR3]		= 0x814,
+	[MIB_TDRCR4]		= 0x818,
+	[MIB_RSCR26]		= 0xa34,
+	[MIB_TSCR18]		= 0xc08,
+	[MIB_TRDR0]		= 0xc10,
+	[MIB_TRDR2]		= 0xc18,
+	[MIB_TRDR3]		= 0xc1c,
+	[MIB_TRDR4]		= 0xc20,
+	[MIB_TRDR5]		= 0xc24,
+	[MIB_TRDR6]		= 0xc28,
+	[MIB_TRDR7]		= 0xc2c,
+	[MIB_TRDR8]		= 0xc30,
+	[MIB_TRDR9]		= 0xc34,
+	[MIB_TRDR10]		= 0xc38,
+	[MIB_TRDR11]		= 0xc3c,
+	[MIB_TRDR12]		= 0xc40,
+	[MIB_TRDR13]		= 0xc44,
+	[MIB_TRDR14]		= 0xc48,
+	[MIB_TRDR15]		= 0xc4c,
+	[MIB_MSR0]		= 0xc50,
+	[MIB_MSR1]		= 0xc54,
+	[MIB_MSR2]		= 0xc58,
+	[MIB_MCTR5]		= 0xc5c,
+	[MIB_MCTR6]		= 0xc60,
+	[MIB_TSCR0]		= 0x750,
+	[MIB_TSCR3]		= 0x75c,
+	[MIB_TSCR4]		= 0x760,
+	[MIB_TSCR5]		= 0x764,
+	[MIB_TSCR6]		= 0x768,
+	[MIB_TSCR7]		= 0x770,
+	[MIB_TSCR8]		= 0x76c,
+	[MIB_TBCR0]		= 0x78c,
+	[MIB_TBCR1]		= 0x790,
+	[MIB_TBCR2]		= 0x794,
+	[MIB_TBCR3]		= 0x798,
 };
 
 /* used to differentiate between generations */
@@ -733,19 +813,19 @@ struct queue_desc {
 #define BN0_WF_MIB_TOP_BTCR_ADDR                               (BN0_WF_MIB_TOP_BASE + 0x5A0) // D5A0
 #define BN0_WF_MIB_TOP_RVSR0_ADDR                              (BN0_WF_MIB_TOP_BASE + __OFFS(MIB_RVSR0))
 
-#define BN0_WF_MIB_TOP_TSCR0_ADDR                              (BN0_WF_MIB_TOP_BASE + 0x6B0) // D6B0
-#define BN0_WF_MIB_TOP_TSCR3_ADDR                              (BN0_WF_MIB_TOP_BASE + 0x6BC) // D6BC
-#define BN0_WF_MIB_TOP_TSCR4_ADDR                              (BN0_WF_MIB_TOP_BASE + 0x6C0) // D6C0
-#define BN0_WF_MIB_TOP_TSCR5_ADDR                              (BN0_WF_MIB_TOP_BASE + 0x6C4) // D6C4
-#define BN0_WF_MIB_TOP_TSCR6_ADDR                              (BN0_WF_MIB_TOP_BASE + 0x6C8) // D6C8
-#define BN0_WF_MIB_TOP_TSCR7_ADDR                              (BN0_WF_MIB_TOP_BASE + 0x6D0) // D6D0
-#define BN0_WF_MIB_TOP_TSCR8_ADDR                              (BN0_WF_MIB_TOP_BASE + 0x6CC) // D6CC
+#define BN0_WF_MIB_TOP_TSCR0_ADDR                              (BN0_WF_MIB_TOP_BASE + __DBG_OFFS(MIB_TSCR0))
+#define BN0_WF_MIB_TOP_TSCR3_ADDR                              (BN0_WF_MIB_TOP_BASE + __DBG_OFFS(MIB_TSCR3))
+#define BN0_WF_MIB_TOP_TSCR4_ADDR                              (BN0_WF_MIB_TOP_BASE + __DBG_OFFS(MIB_TSCR4))
+#define BN0_WF_MIB_TOP_TSCR5_ADDR                              (BN0_WF_MIB_TOP_BASE + __DBG_OFFS(MIB_TSCR5))
+#define BN0_WF_MIB_TOP_TSCR6_ADDR                              (BN0_WF_MIB_TOP_BASE + __DBG_OFFS(MIB_TSCR6))
+#define BN0_WF_MIB_TOP_TSCR7_ADDR                              (BN0_WF_MIB_TOP_BASE + __DBG_OFFS(MIB_TSCR7))
+#define BN0_WF_MIB_TOP_TSCR8_ADDR                              (BN0_WF_MIB_TOP_BASE + __DBG_OFFS(MIB_TSCR8))
 
-#define BN0_WF_MIB_TOP_TBCR0_ADDR                              (BN0_WF_MIB_TOP_BASE + 0x6EC) // D6EC
-#define BN0_WF_MIB_TOP_TBCR1_ADDR                              (BN0_WF_MIB_TOP_BASE + 0x6F0) // D6F0
-#define BN0_WF_MIB_TOP_TBCR2_ADDR                              (BN0_WF_MIB_TOP_BASE + 0x6F4) // D6F4
-#define BN0_WF_MIB_TOP_TBCR3_ADDR                              (BN0_WF_MIB_TOP_BASE + 0x6F8) // D6F8
-#define BN0_WF_MIB_TOP_TBCR4_ADDR                              (BN0_WF_MIB_TOP_BASE + 0x6FC) // D6FC
+#define BN0_WF_MIB_TOP_TBCR0_ADDR                              (BN0_WF_MIB_TOP_BASE + __DBG_OFFS(MIB_TBCR0))
+#define BN0_WF_MIB_TOP_TBCR1_ADDR                              (BN0_WF_MIB_TOP_BASE + __DBG_OFFS(MIB_TBCR1))
+#define BN0_WF_MIB_TOP_TBCR2_ADDR                              (BN0_WF_MIB_TOP_BASE + __DBG_OFFS(MIB_TBCR2))
+#define BN0_WF_MIB_TOP_TBCR3_ADDR                              (BN0_WF_MIB_TOP_BASE + __DBG_OFFS(MIB_TBCR3))
+#define BN0_WF_MIB_TOP_TBCR4_ADDR                              (BN0_WF_MIB_TOP_BASE + 0x6FC) // D6FC, only for 7996
 
 #define BN0_WF_MIB_TOP_TDRCR0_ADDR                             (BN0_WF_MIB_TOP_BASE + __DBG_OFFS(MIB_TDRCR0))
 #define BN0_WF_MIB_TOP_TDRCR1_ADDR                             (BN0_WF_MIB_TOP_BASE + __DBG_OFFS(MIB_TDRCR1))
@@ -960,14 +1040,13 @@ enum cipher_suit {
 
 #define MT_DBG_WTBL_BASE		0x820D8000
 
-#define MT_DBG_WTBLON_TOP_BASE		0x820d4000
-#define MT_DBG_WTBLON_TOP_WDUCR_ADDR	(MT_DBG_WTBLON_TOP_BASE + 0x0370) // 4370
-#define MT_DBG_WTBLON_TOP_WDUCR_GROUP	GENMASK(4, 0)
-
 #define MT_DBG_UWTBL_TOP_BASE		0x820c4000
 #define MT_DBG_UWTBL_TOP_WDUCR_ADDR	(MT_DBG_UWTBL_TOP_BASE + 0x0104) // 4104
 #define MT_DBG_UWTBL_TOP_WDUCR_GROUP	GENMASK(5, 0)
 #define MT_DBG_UWTBL_TOP_WDUCR_TARGET	BIT(31)
+/* for 7990 */
+#define MT_DBG_UWTBL_TOP_KDUCR_ADDR	(MT_DBG_UWTBL_TOP_BASE + 0x010c) // 410c
+#define MT_DBG_UWTBL_TOP_KDUCR_GROUP	GENMASK(6, 0)
 
 #define LWTBL_IDX2BASE_ID		GENMASK(14, 8)
 #define LWTBL_IDX2BASE_DW		GENMASK(7, 2)
@@ -986,6 +1065,10 @@ enum cipher_suit {
 #define KEYTBL_IDX2BASE(_key, _dw)	(MT_DBG_UWTBL_TOP_BASE | 0x2000 | \
 					FIELD_PREP(KEYTBL_IDX2BASE_KEY, _key) | \
 					FIELD_PREP(KEYTBL_IDX2BASE_DW, _dw))
+#define KEYTBL_IDX2BASE_KEY_7990	GENMASK(11, 6)
+#define KEYTBL_IDX2BASE_7990(_key, _dw)	(MT_DBG_UWTBL_TOP_BASE | 0x1000 | \
+					FIELD_PREP(KEYTBL_IDX2BASE_KEY_7990, _key) | \
+					FIELD_PREP(KEYTBL_IDX2BASE_DW, _dw))
 
 // UMAC WTBL
 // DW0
@@ -1089,6 +1172,10 @@ enum cipher_suit {
 #define WF_UWTBL_SEC_ADDR_MODE_ADDR                                 32
 #define WF_UWTBL_SEC_ADDR_MODE_MASK                                 0x00300000 // 21-20
 #define WF_UWTBL_SEC_ADDR_MODE_SHIFT                                20
+#define WF_UWTBL_AAD_OM_DW                                          8
+#define WF_UWTBL_AAD_OM_ADDR                                        32
+#define WF_UWTBL_AAD_OM_MASK                                        0x01000000 // 24-24
+#define WF_UWTBL_AAD_OM_SHIFT                                       24
 #define WF_UWTBL_WMM_Q_DW                                           8
 #define WF_UWTBL_WMM_Q_ADDR                                         32
 #define WF_UWTBL_WMM_Q_MASK                                         0x06000000 // 26-25
@@ -2154,6 +2241,20 @@ enum cipher_suit {
 	0x00fc0000 // 23-18
 #define WF_LWTBL_SNR_RX3_SHIFT                                      18
 
+/* for 7992 & 7990 */
+#define WF_LWTBL_SNR_RX0_MASK_7992  \
+	0x000000ff //  7- 0
+#define WF_LWTBL_SNR_RX0_SHIFT_7992                                 0
+#define WF_LWTBL_SNR_RX1_MASK_7992 \
+	0x0000ff00 // 15- 8
+#define WF_LWTBL_SNR_RX1_SHIFT_7992                                 8
+#define WF_LWTBL_SNR_RX2_MASK_7992 \
+	0x00ff0000 // 23-16
+#define WF_LWTBL_SNR_RX2_SHIFT_7992                                 16
+#define WF_LWTBL_SNR_RX3_MASK_7992 \
+	0xff000000 // 31-24
+#define WF_LWTBL_SNR_RX3_SHIFT_7992                                 24
+
 /* WTBL Group - Packet Number */
 /* DW 2 */
 #define WTBL_PN0_MASK                   BITS(0, 7)
@@ -2324,6 +2425,10 @@ enum umac_ple_ctrl_port3_queue_idx {
 /* PSE PLE QUEUE */
 #define CR_NUM_OF_AC_MT7996	34
 #define CR_NUM_OF_AC_MT7992	17
+
+#define CR_NUM_OF_TWT_MT7996	34
+#define CR_NUM_OF_TWT_MT7992	17
+#define CR_NUM_OF_TWT_MT7990	18
 struct bmac_queue_info {
 	char *QueueName;
 	u32 Portid;
@@ -2672,6 +2777,15 @@ struct bmac_queue_info_t {
 #define WF_PSE_TOP_QUEUE_EMPTY_CPU_Q0_EMPTY_MASK               0x00000001                // CPU_Q0_EMPTY[0]
 #define WF_PSE_TOP_QUEUE_EMPTY_CPU_Q0_EMPTY_SHFT               0
 
+#define WF_PSE_TOP_QUEUE_EMPTY_1_HIF_16_EMPTY_ADDR             WF_PSE_TOP_QUEUE_EMPTY_1_ADDR
+#define WF_PSE_TOP_QUEUE_EMPTY_1_HIF_16_EMPTY_MASK             0x00001000
+#define WF_PSE_TOP_QUEUE_EMPTY_1_HIF_16_EMPTY_SHFT             12
+#define WF_PSE_TOP_QUEUE_EMPTY_1_HIF_15_EMPTY_ADDR             WF_PSE_TOP_QUEUE_EMPTY_1_ADDR
+#define WF_PSE_TOP_QUEUE_EMPTY_1_HIF_15_EMPTY_MASK             0x80000000                // HIF_15_EMPTY[31]
+#define WF_PSE_TOP_QUEUE_EMPTY_1_HIF_15_EMPTY_SHFT             31
+#define WF_PSE_TOP_QUEUE_EMPTY_1_HIF_14_EMPTY_ADDR             WF_PSE_TOP_QUEUE_EMPTY_1_ADDR
+#define WF_PSE_TOP_QUEUE_EMPTY_1_HIF_14_EMPTY_MASK             0x40000000                // HIF_14_EMPTY[30]
+#define WF_PSE_TOP_QUEUE_EMPTY_1_HIF_14_EMPTY_SHFT             30
 #define WF_PSE_TOP_QUEUE_EMPTY_1_HIF_13_EMPTY_ADDR             WF_PSE_TOP_QUEUE_EMPTY_1_ADDR
 #define WF_PSE_TOP_QUEUE_EMPTY_1_HIF_13_EMPTY_MASK             0x20000000                // HIF_13_EMPTY[29]
 #define WF_PSE_TOP_QUEUE_EMPTY_1_HIF_13_EMPTY_SHFT             29
diff --git a/mt7996/mtk_debugfs.c b/mt7996/mtk_debugfs.c
index dfe6804d..7bb32418 100644
--- a/mt7996/mtk_debugfs.c
+++ b/mt7996/mtk_debugfs.c
@@ -532,26 +532,48 @@ mt7996_show_dma_info(struct seq_file *s, struct mt7996_dev *dev)
 		WF_WFDMA_HOST_DMA0_WPDMA_TX_RING16_CTRL0_ADDR);
 	dump_dma_tx_ring_info(s, dev, "T17:Cmd(H2WM)", "Both",
 		WF_WFDMA_HOST_DMA0_WPDMA_TX_RING17_CTRL0_ADDR);
-	dump_dma_tx_ring_info(s, dev, "T18:TXD0(H2WA)", "AP",
-		WF_WFDMA_HOST_DMA0_WPDMA_TX_RING18_CTRL0_ADDR);
-	dump_dma_tx_ring_info(s, dev, "T19:TXD1(H2WA)", "AP",
-		WF_WFDMA_HOST_DMA0_WPDMA_TX_RING19_CTRL0_ADDR);
-	dump_dma_tx_ring_info(s, dev, "T20:Cmd(H2WA)", "AP",
-		WF_WFDMA_HOST_DMA0_WPDMA_TX_RING20_CTRL0_ADDR);
-	dump_dma_tx_ring_info(s, dev, "T21:TXD2(H2WA)", "AP",
-		WF_WFDMA_HOST_DMA0_WPDMA_TX_RING21_CTRL0_ADDR);
-	dump_dma_tx_ring_info(s, dev, "T22:TXD3(H2WA)", "AP",
-		WF_WFDMA_HOST_DMA0_WPDMA_TX_RING22_CTRL0_ADDR);
+	if (mt7996_has_wa(dev)) {
+		dump_dma_tx_ring_info(s, dev, "T18:TXD0(H2WA)", "AP",
+			WF_WFDMA_HOST_DMA0_WPDMA_TX_RING18_CTRL0_ADDR);
+		dump_dma_tx_ring_info(s, dev, "T19:TXD1(H2WA)", "AP",
+			WF_WFDMA_HOST_DMA0_WPDMA_TX_RING19_CTRL0_ADDR);
+		dump_dma_tx_ring_info(s, dev, "T20:Cmd(H2WA)", "AP",
+			WF_WFDMA_HOST_DMA0_WPDMA_TX_RING20_CTRL0_ADDR);
+		dump_dma_tx_ring_info(s, dev, "T21:TXD2(H2WA)", "AP",
+			WF_WFDMA_HOST_DMA0_WPDMA_TX_RING21_CTRL0_ADDR);
+		dump_dma_tx_ring_info(s, dev, "T22:TXD3(H2WA)", "AP",
+			WF_WFDMA_HOST_DMA0_WPDMA_TX_RING22_CTRL0_ADDR);
+	} else {
+		dump_dma_tx_ring_info(s, dev, "T18:TXD0(H2SDO)", "AP",
+			WF_WFDMA_HOST_DMA0_WPDMA_TX_RING18_CTRL0_ADDR);
+		dump_dma_tx_ring_info(s, dev, "T19:TXD1(H2SDO)", "AP",
+			WF_WFDMA_HOST_DMA0_WPDMA_TX_RING19_CTRL0_ADDR);
+		dump_dma_tx_ring_info(s, dev, "T20:Reserved", "AP",
+			WF_WFDMA_HOST_DMA0_WPDMA_TX_RING20_CTRL0_ADDR);
+		dump_dma_tx_ring_info(s, dev, "T21:TXD2(H2SDO)", "AP",
+			WF_WFDMA_HOST_DMA0_WPDMA_TX_RING21_CTRL0_ADDR);
+		dump_dma_tx_ring_info(s, dev, "T22:TXD3(H2SDO)", "AP",
+			WF_WFDMA_HOST_DMA0_WPDMA_TX_RING22_CTRL0_ADDR);
+	}
 
 
 	dump_dma_rx_ring_info(s, dev, "R0:Event(WM2H)", "Both",
 		WF_WFDMA_HOST_DMA0_WPDMA_RX_RING0_CTRL0_ADDR);
-	dump_dma_rx_ring_info(s, dev, "R1:Event(WA2H)", "AP",
-		WF_WFDMA_HOST_DMA0_WPDMA_RX_RING1_CTRL0_ADDR);
-	dump_dma_rx_ring_info(s, dev, "R2:TxDone0(WA2H)", "AP",
-		WF_WFDMA_HOST_DMA0_WPDMA_RX_RING2_CTRL0_ADDR);
-	dump_dma_rx_ring_info(s, dev, "R3:TxDone1(WA2H)", "AP",
-		WF_WFDMA_HOST_DMA0_WPDMA_RX_RING3_CTRL0_ADDR);
+	if (mt7996_has_wa(dev)) {
+		dump_dma_rx_ring_info(s, dev, "R1:Event(WA2H)", "AP",
+			WF_WFDMA_HOST_DMA0_WPDMA_RX_RING1_CTRL0_ADDR);
+		dump_dma_rx_ring_info(s, dev, "R2:TxDone0(WA2H)", "AP",
+			WF_WFDMA_HOST_DMA0_WPDMA_RX_RING2_CTRL0_ADDR);
+		dump_dma_rx_ring_info(s, dev, "R3:TxDone1(WA2H)", "AP",
+			WF_WFDMA_HOST_DMA0_WPDMA_RX_RING3_CTRL0_ADDR);
+	} else {
+		dump_dma_rx_ring_info(s, dev, "R1:Event(SDO2H)", "AP",
+			WF_WFDMA_HOST_DMA0_WPDMA_RX_RING1_CTRL0_ADDR);
+		dump_dma_rx_ring_info(s, dev, "R2:Reserved", "AP",
+			WF_WFDMA_HOST_DMA0_WPDMA_RX_RING2_CTRL0_ADDR);
+		dump_dma_rx_ring_info(s, dev, "R3:Reserved", "AP",
+			WF_WFDMA_HOST_DMA0_WPDMA_RX_RING3_CTRL0_ADDR);
+	}
 	dump_dma_rx_ring_info(s, dev, "R4:Data0(MAC2H)", "Both",
 		WF_WFDMA_HOST_DMA0_WPDMA_RX_RING4_CTRL0_ADDR);
 	dump_dma_rx_ring_info(s, dev, "R5:Data1(MAC2H)", "Both",
@@ -562,8 +584,12 @@ mt7996_show_dma_info(struct seq_file *s, struct mt7996_dev *dev)
 	else
 		dump_dma_rx_ring_info(s, dev, "R6:TxDone0(MAC2H)", "Both",
 			WF_WFDMA_HOST_DMA0_WPDMA_RX_RING6_CTRL0_ADDR);
-	dump_dma_rx_ring_info(s, dev, "R7:TxDone1(MAC2H)", "Both",
-		WF_WFDMA_HOST_DMA0_WPDMA_RX_RING7_CTRL0_ADDR);
+	if (is_mt7990(&dev->mt76))
+		dump_dma_rx_ring_info(s, dev, "R7:Reserved)", "Both",
+			WF_WFDMA_HOST_DMA0_WPDMA_RX_RING7_CTRL0_ADDR);
+	else
+		dump_dma_rx_ring_info(s, dev, "R7:TxDone1(MAC2H)", "Both",
+			WF_WFDMA_HOST_DMA0_WPDMA_RX_RING7_CTRL0_ADDR);
 	dump_dma_rx_ring_info(s, dev, "R8:BUF0(MAC2H)", "Both",
 		WF_WFDMA_HOST_DMA0_WPDMA_RX_RING8_CTRL0_ADDR);
 	if (is_mt7996(&dev->mt76))
@@ -585,12 +611,21 @@ mt7996_show_dma_info(struct seq_file *s, struct mt7996_dev *dev)
 		seq_printf(s, "HOST_DMA0 PCIe1 Ring Configuration\n");
 		seq_printf(s, "%20s %6s %10s %15s %10s %10s %10s\n",
 			"Name", "Used", "Base", "Ctrl1(Cnt)", "CIDX", "DIDX", "QCnt");
-		dump_dma_tx_ring_info(s, dev, "T21:TXD2(H2WA)", "AP",
-			WF_WFDMA_HOST_DMA0_PCIE1_WPDMA_TX_RING21_CTRL0_ADDR);
-		dump_dma_tx_ring_info(s, dev, "T22:TXD?(H2WA)", "AP",
-			WF_WFDMA_HOST_DMA0_PCIE1_WPDMA_TX_RING22_CTRL0_ADDR);
-		dump_dma_rx_ring_info(s, dev, "R3:TxDone1(WA2H)", "AP",
-			WF_WFDMA_HOST_DMA0_PCIE1_WPDMA_RX_RING3_CTRL0_ADDR);
+		if (mt7996_has_wa(dev)) {
+			dump_dma_tx_ring_info(s, dev, "T21:TXD2(H2WA)", "AP",
+				WF_WFDMA_HOST_DMA0_PCIE1_WPDMA_TX_RING21_CTRL0_ADDR);
+			dump_dma_tx_ring_info(s, dev, "T22:TXD?(H2WA)", "AP",
+				WF_WFDMA_HOST_DMA0_PCIE1_WPDMA_TX_RING22_CTRL0_ADDR);
+			dump_dma_rx_ring_info(s, dev, "R3:TxDone1(WA2H)", "AP",
+				WF_WFDMA_HOST_DMA0_PCIE1_WPDMA_RX_RING3_CTRL0_ADDR);
+		} else {
+			dump_dma_tx_ring_info(s, dev, "T21:TXD2(H2SDO)", "AP",
+				WF_WFDMA_HOST_DMA0_PCIE1_WPDMA_TX_RING21_CTRL0_ADDR);
+			dump_dma_tx_ring_info(s, dev, "T22:TXD?(H2SDO)", "AP",
+				WF_WFDMA_HOST_DMA0_PCIE1_WPDMA_TX_RING22_CTRL0_ADDR);
+			dump_dma_rx_ring_info(s, dev, "R3:Reserved", "AP",
+				WF_WFDMA_HOST_DMA0_PCIE1_WPDMA_RX_RING3_CTRL0_ADDR);
+		}
 		dump_dma_rx_ring_info(s, dev, "R5:Data1(MAC2H)", "Both",
 			WF_WFDMA_HOST_DMA0_PCIE1_WPDMA_RX_RING5_CTRL0_ADDR);
 		if (is_mt7996(&dev->mt76))
@@ -598,7 +633,7 @@ mt7996_show_dma_info(struct seq_file *s, struct mt7996_dev *dev)
 				WF_WFDMA_HOST_DMA0_PCIE1_WPDMA_RX_RING6_CTRL0_ADDR);
 		dump_dma_rx_ring_info(s, dev, "R7:TxDone1(MAC2H)", "Both",
 			WF_WFDMA_HOST_DMA0_PCIE1_WPDMA_RX_RING7_CTRL0_ADDR);
-		if (is_mt7992(&dev->mt76))
+		if (is_mt7992(&dev->mt76) || is_mt7990(&dev->mt76))
 			dump_dma_rx_ring_info(s, dev, "R9:BUF1(MAC2H)", "Both",
 				WF_WFDMA_HOST_DMA0_PCIE1_WPDMA_RX_RING9_CTRL0_ADDR);
 	}
@@ -627,36 +662,62 @@ mt7996_show_dma_info(struct seq_file *s, struct mt7996_dev *dev)
 		"Name", "Used", "Base", "Cnt", "CIDX", "DIDX", "QCnt");
 	dump_dma_tx_ring_info(s, dev, "T0:Event(WM2H)", "Both",
 		WF_WFDMA_MCU_DMA0_WPDMA_TX_RING0_CTRL0_ADDR);
-	dump_dma_tx_ring_info(s, dev, "T1:Event(WA2H)", "AP",
-		WF_WFDMA_MCU_DMA0_WPDMA_TX_RING1_CTRL0_ADDR);
-	dump_dma_tx_ring_info(s, dev, "T2:TxDone0(WA2H)", "AP",
-		WF_WFDMA_MCU_DMA0_WPDMA_TX_RING2_CTRL0_ADDR);
-	dump_dma_tx_ring_info(s, dev, "T3:TxDone1(WA2H)", "AP",
-		WF_WFDMA_MCU_DMA0_WPDMA_TX_RING3_CTRL0_ADDR);
+	if (mt7996_has_wa(dev)) {
+		dump_dma_tx_ring_info(s, dev, "T1:Event(WA2H)", "AP",
+			WF_WFDMA_MCU_DMA0_WPDMA_TX_RING1_CTRL0_ADDR);
+		dump_dma_tx_ring_info(s, dev, "T2:TxDone0(WA2H)", "AP",
+			WF_WFDMA_MCU_DMA0_WPDMA_TX_RING2_CTRL0_ADDR);
+		dump_dma_tx_ring_info(s, dev, "T3:TxDone1(WA2H)", "AP",
+			WF_WFDMA_MCU_DMA0_WPDMA_TX_RING3_CTRL0_ADDR);
+	} else {
+		dump_dma_tx_ring_info(s, dev, "T1:Event(SDO2H)", "AP",
+			WF_WFDMA_MCU_DMA0_WPDMA_TX_RING1_CTRL0_ADDR);
+		dump_dma_tx_ring_info(s, dev, "T2:Reserved", "AP",
+			WF_WFDMA_MCU_DMA0_WPDMA_TX_RING2_CTRL0_ADDR);
+		dump_dma_tx_ring_info(s, dev, "T3:Reserved", "AP",
+			WF_WFDMA_MCU_DMA0_WPDMA_TX_RING3_CTRL0_ADDR);
+	}
 	dump_dma_tx_ring_info(s, dev, "T4:TXD(WM2MAC)", "Both",
 		WF_WFDMA_MCU_DMA0_WPDMA_TX_RING4_CTRL0_ADDR);
 	dump_dma_tx_ring_info(s, dev, "T5:TXCMD(WM2MAC)", "Both",
 		WF_WFDMA_MCU_DMA0_WPDMA_TX_RING5_CTRL0_ADDR);
-	dump_dma_tx_ring_info(s, dev, "T6:TXD(WA2MAC)", "AP",
-		WF_WFDMA_MCU_DMA0_WPDMA_TX_RING6_CTRL0_ADDR);
+	if (mt7996_has_wa(dev))
+		dump_dma_tx_ring_info(s, dev, "T6:TXD(WA2MAC)", "AP",
+			WF_WFDMA_MCU_DMA0_WPDMA_TX_RING6_CTRL0_ADDR);
+	else
+		dump_dma_tx_ring_info(s, dev, "T6:TXD(SDO2MAC)", "AP",
+			WF_WFDMA_MCU_DMA0_WPDMA_TX_RING6_CTRL0_ADDR);
 	dump_dma_rx_ring_info(s, dev, "R0:FWDL", "Both",
 		WF_WFDMA_MCU_DMA0_WPDMA_RX_RING0_CTRL0_ADDR);
 	dump_dma_rx_ring_info(s, dev, "R1:Cmd(H2WM)", "Both",
 		WF_WFDMA_MCU_DMA0_WPDMA_RX_RING1_CTRL0_ADDR);
-	dump_dma_rx_ring_info(s, dev, "R2:TXD0(H2WA)", "AP",
-		WF_WFDMA_MCU_DMA0_WPDMA_RX_RING2_CTRL0_ADDR);
-	dump_dma_rx_ring_info(s, dev, "R3:TXD1(H2WA)", "AP",
-		WF_WFDMA_MCU_DMA0_WPDMA_RX_RING3_CTRL0_ADDR);
-	dump_dma_rx_ring_info(s, dev, "R4:Cmd(H2WA)", "AP",
-		WF_WFDMA_MCU_DMA0_WPDMA_RX_RING4_CTRL0_ADDR);
+	if (mt7996_has_wa(dev)) {
+		dump_dma_rx_ring_info(s, dev, "R2:TXD0(H2WA)", "AP",
+			WF_WFDMA_MCU_DMA0_WPDMA_RX_RING2_CTRL0_ADDR);
+		dump_dma_rx_ring_info(s, dev, "R3:TXD1(H2WA)", "AP",
+			WF_WFDMA_MCU_DMA0_WPDMA_RX_RING3_CTRL0_ADDR);
+		dump_dma_rx_ring_info(s, dev, "R4:Cmd(H2WA)", "AP",
+			WF_WFDMA_MCU_DMA0_WPDMA_RX_RING4_CTRL0_ADDR);
+	} else {
+		dump_dma_rx_ring_info(s, dev, "R2:TXD0(H2SDO)", "AP",
+			WF_WFDMA_MCU_DMA0_WPDMA_RX_RING2_CTRL0_ADDR);
+		dump_dma_rx_ring_info(s, dev, "R3:TXD1(H2SDO)", "AP",
+			WF_WFDMA_MCU_DMA0_WPDMA_RX_RING3_CTRL0_ADDR);
+		dump_dma_rx_ring_info(s, dev, "R4:Reserved", "AP",
+			WF_WFDMA_MCU_DMA0_WPDMA_RX_RING4_CTRL0_ADDR);
+	}
 	dump_dma_rx_ring_info(s, dev, "R5:Data0(MAC2WM)", "Both",
 		WF_WFDMA_MCU_DMA0_WPDMA_RX_RING5_CTRL0_ADDR);
 	dump_dma_rx_ring_info(s, dev, "R6:TxDone(MAC2WM)", "Both",
 		WF_WFDMA_MCU_DMA0_WPDMA_RX_RING6_CTRL0_ADDR);
 	dump_dma_rx_ring_info(s, dev, "R7:SPL/RPT(MAC2WM)", "Both",
 		WF_WFDMA_MCU_DMA0_WPDMA_RX_RING7_CTRL0_ADDR);
-	dump_dma_rx_ring_info(s, dev, "R8:TxDone(MAC2WA)", "AP",
-		WF_WFDMA_MCU_DMA0_WPDMA_RX_RING8_CTRL0_ADDR);
+	if (mt7996_has_wa(dev))
+		dump_dma_rx_ring_info(s, dev, "R8:TxDone(MAC2WA)", "AP",
+			WF_WFDMA_MCU_DMA0_WPDMA_RX_RING8_CTRL0_ADDR);
+	else
+		dump_dma_rx_ring_info(s, dev, "R8:Reserved", "AP",
+			WF_WFDMA_MCU_DMA0_WPDMA_RX_RING8_CTRL0_ADDR);
 	dump_dma_rx_ring_info(s, dev, "R9:Data1(MAC2WM)", "Both",
 		WF_WFDMA_MCU_DMA0_WPDMA_RX_RING9_CTRL0_ADDR);
 	dump_dma_rx_ring_info(s, dev, "R10:TXD2(H2WA)", "AP",
@@ -799,7 +860,7 @@ static int mt7996_mibinfo_show(struct seq_file *s, void *data)
 	tbcr3 = mt76_rr(dev, BN0_WF_MIB_TOP_TBCR3_ADDR + band_offset);
 	seq_printf(s, "\tTx 160MHz Cnt=0x%x\n",
 		tbcr3 & BN0_WF_MIB_TOP_TBCR3_TX_160MHZ_CNT_MASK);
-	tbcr4 = mt76_rr(dev, BN0_WF_MIB_TOP_TBCR4_ADDR + band_offset);
+	tbcr4 = is_mt7996(&dev->mt76) ? mt76_rr(dev, BN0_WF_MIB_TOP_TBCR4_ADDR + band_offset) : 0;
 	seq_printf(s, "\tTx 320MHz Cnt=0x%x\n",
 		tbcr4 & BN0_WF_MIB_TOP_TBCR4_TX_320MHZ_CNT_MASK);
 	seq_printf(s, "\tAMPDU Cnt=0x%x\n", ampdu_cnt[0]);
@@ -936,18 +997,25 @@ mt7996_wtbl_read_raw(struct mt7996_dev *dev, u16 idx,
 		return 0xFF;
 
 	if (type == WTBL_TYPE_LMAC) {
-		mt76_wr(dev, MT_DBG_WTBLON_TOP_WDUCR_ADDR,
-			FIELD_PREP(MT_DBG_WTBLON_TOP_WDUCR_GROUP, (idx >> 7)));
+		mt76_wr(dev, MT_WTBLON_TOP_WDUCR,
+			FIELD_PREP(MT_WTBLON_TOP_WDUCR_GROUP, (idx >> 7)));
 		src = LWTBL_IDX2BASE(idx, start_dw);
 	} else if (type == WTBL_TYPE_UMAC) {
 		mt76_wr(dev,  MT_DBG_UWTBL_TOP_WDUCR_ADDR,
 			FIELD_PREP(MT_DBG_UWTBL_TOP_WDUCR_GROUP, (idx >> 7)));
 		src = UWTBL_IDX2BASE(idx, start_dw);
 	} else if (type == WTBL_TYPE_KEY) {
-		mt76_wr(dev,  MT_DBG_UWTBL_TOP_WDUCR_ADDR,
-			MT_DBG_UWTBL_TOP_WDUCR_TARGET |
-			FIELD_PREP(MT_DBG_UWTBL_TOP_WDUCR_GROUP, (idx >> 7)));
-		src = KEYTBL_IDX2BASE(idx, start_dw);
+		if (is_mt7990(&dev->mt76)) {
+			mt76_wr(dev,  MT_DBG_UWTBL_TOP_KDUCR_ADDR,
+				FIELD_PREP(MT_DBG_UWTBL_TOP_KDUCR_GROUP, (idx >> 6)));
+			src = KEYTBL_IDX2BASE_7990(idx, start_dw);
+		} else {
+			mt76_wr(dev,  MT_DBG_UWTBL_TOP_WDUCR_ADDR,
+				MT_DBG_UWTBL_TOP_WDUCR_TARGET |
+				FIELD_PREP(MT_DBG_UWTBL_TOP_WDUCR_GROUP, (idx >> 7)));
+			src = KEYTBL_IDX2BASE(idx, start_dw);
+		}
+
 	}
 
 	while (size_dw--) {
@@ -967,8 +1035,8 @@ mt7996_wtbl_write_raw(struct mt7996_dev *dev, u16 idx,
 	u32 addr = 0;
 
 	if (type == WTBL_TYPE_LMAC) {
-		mt76_wr(dev, MT_DBG_WTBLON_TOP_WDUCR_ADDR,
-			FIELD_PREP(MT_DBG_WTBLON_TOP_WDUCR_GROUP, (idx >> 7)));
+		mt76_wr(dev, MT_WTBLON_TOP_WDUCR,
+			FIELD_PREP(MT_WTBLON_TOP_WDUCR_GROUP, (idx >> 7)));
 		addr = LWTBL_IDX2BASE(idx, start_dw);
 	} else if (type == WTBL_TYPE_UMAC) {
 		mt76_wr(dev, MT_DBG_UWTBL_TOP_WDUCR_ADDR,
@@ -1593,7 +1661,7 @@ static void parse_fmac_lwtbl_dw14(struct seq_file *s, u8 *lwtbl)
 		== MUAR_INDEX_OWN_MAC_ADDR_BC_MC) {
 		/* LMAC WTBL DW 14 */
 		seq_printf(s, "\t\n");
-		seq_printf(s, "LWTBL DW 14\n");
+		seq_printf(s, "LWTBL DW 14_BMC\n");
 		addr = (u32 *)&(lwtbl[WF_LWTBL_CIPHER_SUIT_IGTK_DW*4]);
 		dw_value = *addr;
 
@@ -1769,10 +1837,12 @@ static void parse_fmac_lwtbl_dw31(struct seq_file *s, u8 *lwtbl)
 }
 
 static const struct berse_wtbl_parse WTBL_LMAC_DW32[] = {
-	{"OM_INFO",			WF_LWTBL_OM_INFO_MASK,			WF_LWTBL_OM_INFO_SHIFT,		false},
-	{"OM_INFO_EHT",         WF_LWTBL_OM_INFO_EHT_MASK,         WF_LWTBL_OM_INFO_EHT_SHIFT,  false},
-	{"RXD_DUP_FOR_OM_CHG",		WF_LWTBL_RXD_DUP_FOR_OM_CHG_MASK,	NO_SHIFT_DEFINE,		false},
+	{"OM_INFO",		WF_LWTBL_OM_INFO_MASK,			WF_LWTBL_OM_INFO_SHIFT,			false},
+	{"OM_INFO_EHT",		WF_LWTBL_OM_INFO_EHT_MASK,		WF_LWTBL_OM_INFO_EHT_SHIFT,		false},
+	{"RXD_DUP_FOR_OM_CHG",	WF_LWTBL_RXD_DUP_FOR_OM_CHG_MASK,	NO_SHIFT_DEFINE,			false},
 	{"RXD_DUP_WHITE_LIST",	WF_LWTBL_RXD_DUP_WHITE_LIST_MASK,	WF_LWTBL_RXD_DUP_WHITE_LIST_SHIFT,	false},
+	{"RXD_DUP_MODE",	WF_LWTBL_RXD_DUP_MODE_MASK,		WF_LWTBL_RXD_DUP_MODE_SHIFT,		false},
+	{"ACK_EN",		WF_LWTBL_ACK_EN_MASK,			NO_SHIFT_DEFINE,			true},
 	{NULL,}
 };
 
@@ -1866,7 +1936,8 @@ static void parse_fmac_lwtbl_dw34(struct seq_file *s, u8 *lwtbl)
 	}
 }
 
-static const struct berse_wtbl_parse WTBL_LMAC_DW35[] = {
+static const struct berse_wtbl_parse *WTBL_LMAC_DW35;
+static const struct berse_wtbl_parse WTBL_LMAC_DW35_7996[] = {
 	{"SNR 0",	WF_LWTBL_SNR_RX0_MASK,		WF_LWTBL_SNR_RX0_SHIFT,		false},
 	{"SNR 1",	WF_LWTBL_SNR_RX1_MASK,		WF_LWTBL_SNR_RX1_SHIFT,		false},
 	{"SNR 2",	WF_LWTBL_SNR_RX2_MASK,		WF_LWTBL_SNR_RX2_SHIFT,		false},
@@ -1874,6 +1945,14 @@ static const struct berse_wtbl_parse WTBL_LMAC_DW35[] = {
 	{NULL,}
 };
 
+static const struct berse_wtbl_parse WTBL_LMAC_DW35_7992[] = {
+	{"SNR 0",	WF_LWTBL_SNR_RX0_MASK_7992,	WF_LWTBL_SNR_RX0_SHIFT_7992,	false},
+	{"SNR 1",	WF_LWTBL_SNR_RX1_MASK_7992,	WF_LWTBL_SNR_RX1_SHIFT_7992,	false},
+	{"SNR 2",	WF_LWTBL_SNR_RX2_MASK_7992,	WF_LWTBL_SNR_RX2_SHIFT_7992,	false},
+	{"SNR 3",	WF_LWTBL_SNR_RX3_MASK_7992,	WF_LWTBL_SNR_RX3_SHIFT_7992,	true},
+	{NULL,}
+};
+
 static void parse_fmac_lwtbl_dw35(struct seq_file *s, u8 *lwtbl)
 {
 	u32 *addr = 0;
@@ -2137,16 +2216,21 @@ static void dump_key_table(
 	seq_printf(s, "\t\n");
 	seq_printf(s, "\t%s:%d\n", "keyloc0", keyloc0);
 	if (keyloc0 != INVALID_KEY_ENTRY) {
-
 		/* Don't swap below two lines, halWtblReadRaw will
 		* write new value WF_WTBLON_TOP_WDUCR_ADDR
 		*/
 		mt7996_wtbl_read_raw(dev, keyloc0,
 			WTBL_TYPE_KEY, 0, ONE_KEY_ENTRY_LEN_IN_DW, keytbl);
-		seq_printf(s, "\t\tKEY WTBL Addr: group:0x%x=0x%x addr: 0x%lx\n",
-			MT_DBG_UWTBL_TOP_WDUCR_ADDR,
-			mt76_rr(dev, MT_DBG_UWTBL_TOP_WDUCR_ADDR),
-			KEYTBL_IDX2BASE(keyloc0, 0));
+		if (is_mt7990(&dev->mt76))
+			seq_printf(s, "\t\tKEY WTBL Addr: group:0x%x=0x%x addr: 0x%lx\n",
+				MT_DBG_UWTBL_TOP_KDUCR_ADDR,
+				mt76_rr(dev, MT_DBG_UWTBL_TOP_KDUCR_ADDR),
+				KEYTBL_IDX2BASE_7990(keyloc0, 0));
+		else
+			seq_printf(s, "\t\tKEY WTBL Addr: group:0x%x=0x%x addr: 0x%lx\n",
+				MT_DBG_UWTBL_TOP_WDUCR_ADDR,
+				mt76_rr(dev, MT_DBG_UWTBL_TOP_WDUCR_ADDR),
+				KEYTBL_IDX2BASE(keyloc0, 0));
 		for (x = 0; x < ONE_KEY_ENTRY_LEN_IN_DW; x++) {
 			seq_printf(s, "\t\tDW%02d: %02x %02x %02x %02x\n",
 				x,
@@ -2164,10 +2248,16 @@ static void dump_key_table(
 		*/
 		mt7996_wtbl_read_raw(dev, keyloc1,
 			WTBL_TYPE_KEY, 0, ONE_KEY_ENTRY_LEN_IN_DW, keytbl);
-		seq_printf(s, "\t\tKEY WTBL Addr: group:0x%x=0x%x addr: 0x%lx\n",
-			MT_DBG_UWTBL_TOP_WDUCR_ADDR,
-			mt76_rr(dev, MT_DBG_UWTBL_TOP_WDUCR_ADDR),
-			KEYTBL_IDX2BASE(keyloc1, 0));
+		if (is_mt7990(&dev->mt76))
+			seq_printf(s, "\t\tKEY WTBL Addr: group:0x%x=0x%x addr: 0x%lx\n",
+				MT_DBG_UWTBL_TOP_KDUCR_ADDR,
+				mt76_rr(dev, MT_DBG_UWTBL_TOP_KDUCR_ADDR),
+				KEYTBL_IDX2BASE_7990(keyloc1, 0));
+		else
+			seq_printf(s, "\t\tKEY WTBL Addr: group:0x%x=0x%x addr: 0x%lx\n",
+				MT_DBG_UWTBL_TOP_WDUCR_ADDR,
+				mt76_rr(dev, MT_DBG_UWTBL_TOP_WDUCR_ADDR),
+				KEYTBL_IDX2BASE(keyloc1, 0));
 		for (x = 0; x < ONE_KEY_ENTRY_LEN_IN_DW; x++) {
 			seq_printf(s, "\t\tDW%02d: %02x %02x %02x %02x\n",
 				x,
@@ -2185,10 +2275,16 @@ static void dump_key_table(
 		*/
 		mt7996_wtbl_read_raw(dev, keyloc2,
 			WTBL_TYPE_KEY, 0, ONE_KEY_ENTRY_LEN_IN_DW, keytbl);
-		seq_printf(s, "\t\tKEY WTBL Addr: group:0x%x=0x%x addr: 0x%lx\n",
-			MT_DBG_UWTBL_TOP_WDUCR_ADDR,
-			mt76_rr(dev, MT_DBG_UWTBL_TOP_WDUCR_ADDR),
-			KEYTBL_IDX2BASE(keyloc2, 0));
+		if (is_mt7990(&dev->mt76))
+			seq_printf(s, "\t\tKEY WTBL Addr: group:0x%x=0x%x addr: 0x%lx\n",
+				MT_DBG_UWTBL_TOP_KDUCR_ADDR,
+				mt76_rr(dev, MT_DBG_UWTBL_TOP_KDUCR_ADDR),
+				KEYTBL_IDX2BASE_7990(keyloc2, 0));
+		else
+			seq_printf(s, "\t\tKEY WTBL Addr: group:0x%x=0x%x addr: 0x%lx\n",
+				MT_DBG_UWTBL_TOP_WDUCR_ADDR,
+				mt76_rr(dev, MT_DBG_UWTBL_TOP_WDUCR_ADDR),
+				KEYTBL_IDX2BASE(keyloc2, 0));
 		for (x = 0; x < ONE_KEY_ENTRY_LEN_IN_DW; x++) {
 			seq_printf(s, "\t\tDW%02d: %02x %02x %02x %02x\n",
 				x,
@@ -2237,6 +2333,7 @@ static const struct berse_wtbl_parse WTBL_UMAC_DW8[] = {
 	{"UWTBL_QOS",		WF_UWTBL_QOS_MASK,		NO_SHIFT_DEFINE,	false},
 	{"UWTBL_HT_VHT_HE",	WF_UWTBL_HT_MASK,		NO_SHIFT_DEFINE,	false},
 	{"UWTBL_HDRT_MODE",	WF_UWTBL_HDRT_MODE_MASK,	NO_SHIFT_DEFINE,	true},
+	{"UWTBL_AAD_OM",	WF_UWTBL_AAD_OM_MASK,		WF_UWTBL_AAD_OM_SHIFT,	true},
 	{NULL,}
 };
 
@@ -2317,8 +2414,8 @@ static int mt7996_wtbl_read(struct seq_file *s, void *data)
 				 LWTBL_LEN_IN_DW, lwtbl);
 	seq_printf(s, "Dump WTBL info of WLAN_IDX:%d\n", dev->wlan_idx);
 	seq_printf(s, "LMAC WTBL Addr: group:0x%x=0x%x addr: 0x%lx\n",
-		   MT_DBG_WTBLON_TOP_WDUCR_ADDR,
-		   mt76_rr(dev, MT_DBG_WTBLON_TOP_WDUCR_ADDR),
+		   MT_WTBLON_TOP_WDUCR,
+		   mt76_rr(dev, MT_WTBLON_TOP_WDUCR),
 		   LWTBL_IDX2BASE(dev->wlan_idx, 0));
 	for (x = 0; x < LWTBL_LEN_IN_DW; x++) {
 		seq_printf(s, "DW%02d: %02x %02x %02x %02x\n",
@@ -3614,7 +3711,7 @@ mt7996_pseinfo_read(struct seq_file *s, void *data)
 			  ((pse_stat[0] & WF_PSE_TOP_QUEUE_EMPTY_CPU_Q2_EMPTY_MASK) >> WF_PSE_TOP_QUEUE_EMPTY_CPU_Q2_EMPTY_SHFT),
 			  ((pse_stat[0] & WF_PSE_TOP_QUEUE_EMPTY_CPU_Q3_EMPTY_MASK) >> WF_PSE_TOP_QUEUE_EMPTY_CPU_Q3_EMPTY_SHFT),
 			  ((pse_stat[0] & WF_PSE_TOP_QUEUE_EMPTY_CPU_Q4_EMPTY_MASK) >> WF_PSE_TOP_QUEUE_EMPTY_CPU_Q4_EMPTY_SHFT));
-	seq_printf(s, "\t\tHIF Q0/1/2/3/4/5/6/7/8/9/10/11/12/13 empty=%d/%d/%d/%d/%d/%d/%d/%d/%d/%d/%d/%d/%d/%d\n",
+	seq_printf(s, "\t\tHIF Q0/1/2/3/4/5/6/7/8 empty=%d/%d/%d/%d/%d/%d/%d/%d/%d\n",
 			  ((pse_stat[1] & WF_PSE_TOP_QUEUE_EMPTY_1_HIF_0_EMPTY_MASK) >> WF_PSE_TOP_QUEUE_EMPTY_1_HIF_0_EMPTY_SHFT),
 			  ((pse_stat[1] & WF_PSE_TOP_QUEUE_EMPTY_1_HIF_1_EMPTY_MASK) >> WF_PSE_TOP_QUEUE_EMPTY_1_HIF_1_EMPTY_SHFT),
 			  ((pse_stat[1] & WF_PSE_TOP_QUEUE_EMPTY_1_HIF_2_EMPTY_MASK) >> WF_PSE_TOP_QUEUE_EMPTY_1_HIF_2_EMPTY_SHFT),
@@ -3623,12 +3720,16 @@ mt7996_pseinfo_read(struct seq_file *s, void *data)
 			  ((pse_stat[1] & WF_PSE_TOP_QUEUE_EMPTY_1_HIF_5_EMPTY_MASK) >> WF_PSE_TOP_QUEUE_EMPTY_1_HIF_5_EMPTY_SHFT),
 			  ((pse_stat[1] & WF_PSE_TOP_QUEUE_EMPTY_1_HIF_6_EMPTY_MASK) >> WF_PSE_TOP_QUEUE_EMPTY_1_HIF_6_EMPTY_SHFT),
 			  ((pse_stat[1] & WF_PSE_TOP_QUEUE_EMPTY_1_HIF_7_EMPTY_MASK) >> WF_PSE_TOP_QUEUE_EMPTY_1_HIF_7_EMPTY_SHFT),
-			  ((pse_stat[1] & WF_PSE_TOP_QUEUE_EMPTY_1_HIF_8_EMPTY_MASK) >> WF_PSE_TOP_QUEUE_EMPTY_1_HIF_8_EMPTY_SHFT),
+			  ((pse_stat[1] & WF_PSE_TOP_QUEUE_EMPTY_1_HIF_8_EMPTY_MASK) >> WF_PSE_TOP_QUEUE_EMPTY_1_HIF_8_EMPTY_SHFT));
+	seq_printf(s, "\t\tHIF Q9/10/11/12/13/14/15/16 empty=%d/%d/%d/%d/%d/%d/%d/%d\n",
 			  ((pse_stat[1] & WF_PSE_TOP_QUEUE_EMPTY_1_HIF_9_EMPTY_MASK) >> WF_PSE_TOP_QUEUE_EMPTY_1_HIF_9_EMPTY_SHFT),
 			  ((pse_stat[1] & WF_PSE_TOP_QUEUE_EMPTY_1_HIF_10_EMPTY_MASK) >> WF_PSE_TOP_QUEUE_EMPTY_1_HIF_10_EMPTY_SHFT),
 			  ((pse_stat[1] & WF_PSE_TOP_QUEUE_EMPTY_1_HIF_11_EMPTY_MASK) >> WF_PSE_TOP_QUEUE_EMPTY_1_HIF_11_EMPTY_SHFT),
 			  ((pse_stat[1] & WF_PSE_TOP_QUEUE_EMPTY_1_HIF_12_EMPTY_MASK) >> WF_PSE_TOP_QUEUE_EMPTY_1_HIF_12_EMPTY_SHFT),
-			  ((pse_stat[1] & WF_PSE_TOP_QUEUE_EMPTY_1_HIF_13_EMPTY_MASK) >> WF_PSE_TOP_QUEUE_EMPTY_1_HIF_13_EMPTY_SHFT));
+			  ((pse_stat[1] & WF_PSE_TOP_QUEUE_EMPTY_1_HIF_13_EMPTY_MASK) >> WF_PSE_TOP_QUEUE_EMPTY_1_HIF_13_EMPTY_SHFT),
+			  ((pse_stat[1] & WF_PSE_TOP_QUEUE_EMPTY_1_HIF_14_EMPTY_MASK) >> WF_PSE_TOP_QUEUE_EMPTY_1_HIF_14_EMPTY_SHFT),
+			  ((pse_stat[1] & WF_PSE_TOP_QUEUE_EMPTY_1_HIF_15_EMPTY_MASK) >> WF_PSE_TOP_QUEUE_EMPTY_1_HIF_15_EMPTY_SHFT),
+			  ((pse_stat[1] & WF_PSE_TOP_QUEUE_EMPTY_1_HIF_16_EMPTY_MASK) >> WF_PSE_TOP_QUEUE_EMPTY_1_HIF_16_EMPTY_SHFT));
 	seq_printf(s, "\t\tLMAC TX Q empty=%d\n",
 			  ((pse_stat[0] & WF_PSE_TOP_QUEUE_EMPTY_LMAC_TX_QUEUE_EMPTY_MASK) >> WF_PSE_TOP_QUEUE_EMPTY_LMAC_TX_QUEUE_EMPTY_SHFT));
 	seq_printf(s, "\t\tMDP TX Q0/Q1/Q2/RX Q empty=%d/%d/%d/%d\n",
@@ -3819,14 +3920,29 @@ static size_t
 ple_cr_num_of_ac(struct mt76_dev *dev)
 {
 	switch (mt76_chip(dev)) {
-	case 0x7990:
+	case MT7996_DEVICE_ID:
 		return CR_NUM_OF_AC_MT7996;
-	case 0x7992:
+	case MT7992_DEVICE_ID:
+	case MT7990_DEVICE_ID:
 	default:
 		return CR_NUM_OF_AC_MT7992;
 	}
 }
 
+static size_t
+ple_cr_num_of_twt(struct mt76_dev *dev)
+{
+	switch (mt76_chip(dev)) {
+	case MT7996_DEVICE_ID:
+		return CR_NUM_OF_TWT_MT7996;
+	case MT7990_DEVICE_ID:
+		return CR_NUM_OF_TWT_MT7990;
+	case MT7992_DEVICE_ID:
+	default:
+		return CR_NUM_OF_TWT_MT7992;
+	}
+}
+
 static void
 mt7996_show_ple_pg_info(struct mt7996_dev *dev, struct seq_file *s)
 {
@@ -3907,13 +4023,14 @@ mt7996_get_ple_acq_stat(struct mt7996_dev *dev, unsigned long *ple_stat)
 {
 	u32 i, addr;
 	size_t cr_num_of_ac = ple_cr_num_of_ac(&dev->mt76);
+	bool has_ext = is_mt7992(&dev->mt76) || is_mt7990(&dev->mt76);
 
 	ple_stat[0] = mt76_rr(dev, WF_PLE_TOP_QUEUE_EMPTY_ADDR);
 
 	/* Legacy */
 	addr = WF_PLE_TOP_AC0_QUEUE_EMPTY0_ADDR;
 	for (i = 1; i <= cr_num_of_ac; i++, addr += 4) {
-		if (i == cr_num_of_ac && is_mt7992(&dev->mt76))
+		if (i == cr_num_of_ac && has_ext)
 			ple_stat[i] = mt76_rr(dev, WF_PLE_TOP_AC0_QUEUE_EMPTY_EXT0_ADDR);
 		else
 			ple_stat[i] = mt76_rr(dev, addr);
@@ -3921,7 +4038,7 @@ mt7996_get_ple_acq_stat(struct mt7996_dev *dev, unsigned long *ple_stat)
 
 	addr = WF_PLE_TOP_AC1_QUEUE_EMPTY0_ADDR;
 	for (; i <= cr_num_of_ac * 2; i++, addr += 4) {
-		if (i == cr_num_of_ac * 2 && is_mt7992(&dev->mt76))
+		if (i == cr_num_of_ac * 2 && has_ext)
 			ple_stat[i] = mt76_rr(dev, WF_PLE_TOP_AC1_QUEUE_EMPTY_EXT0_ADDR);
 		else
 			ple_stat[i] = mt76_rr(dev, addr);
@@ -3929,7 +4046,7 @@ mt7996_get_ple_acq_stat(struct mt7996_dev *dev, unsigned long *ple_stat)
 
 	addr = WF_PLE_TOP_AC2_QUEUE_EMPTY0_ADDR;
 	for (; i <= cr_num_of_ac * 3; i++, addr += 4) {
-		if (i == cr_num_of_ac * 3 && is_mt7992(&dev->mt76))
+		if (i == cr_num_of_ac * 3 && has_ext)
 			ple_stat[i] = mt76_rr(dev, WF_PLE_TOP_AC2_QUEUE_EMPTY_EXT0_ADDR);
 		else
 			ple_stat[i] = mt76_rr(dev, addr);
@@ -3937,7 +4054,7 @@ mt7996_get_ple_acq_stat(struct mt7996_dev *dev, unsigned long *ple_stat)
 
 	addr = WF_PLE_TOP_AC3_QUEUE_EMPTY0_ADDR;
 	for (; i <= cr_num_of_ac * 4; i++, addr += 4) {
-		if (i == cr_num_of_ac * 4 && is_mt7992(&dev->mt76))
+		if (i == cr_num_of_ac * 4 && has_ext)
 			ple_stat[i] = mt76_rr(dev, WF_PLE_TOP_AC3_QUEUE_EMPTY_EXT0_ADDR);
 		else
 			ple_stat[i] = mt76_rr(dev, addr);
@@ -3949,6 +4066,8 @@ mt7996_get_sta_pause(struct mt7996_dev *dev, u8 band, u32 *sta_pause, u32 *twt_p
 {
 	u32 i, addr;
 	size_t cr_num_of_ac = ple_cr_num_of_ac(&dev->mt76);
+	size_t cr_num_of_twt = ple_cr_num_of_twt(&dev->mt76);
+	bool has_ext = is_mt7992(&dev->mt76) || is_mt7990(&dev->mt76);
 
 	/* switch to target band */
 	mt76_wr(dev, WF_DRR_TOP_SBRR_ADDR, u32_encode_bits(band, WF_DRR_TOP_SBRR_TARGET_BAND_MASK));
@@ -3956,7 +4075,7 @@ mt7996_get_sta_pause(struct mt7996_dev *dev, u8 band, u32 *sta_pause, u32 *twt_p
 	/* Legacy */
 	addr = WF_DRR_TOP_AC0_STATION_PAUSE00_ADDR;
 	for (i = 0; i < cr_num_of_ac; i++, addr += 4) {
-		if (i == cr_num_of_ac - 1 && is_mt7992(&dev->mt76))
+		if (i == cr_num_of_ac - 1 && has_ext)
 			sta_pause[i] = mt76_rr(dev, WF_DRR_TOP_AC0_STATION_PAUSE_EXT_00_ADDR);
 		else
 			sta_pause[i] = mt76_rr(dev, addr);
@@ -3964,7 +4083,7 @@ mt7996_get_sta_pause(struct mt7996_dev *dev, u8 band, u32 *sta_pause, u32 *twt_p
 
 	addr = WF_DRR_TOP_AC1_STATION_PAUSE00_ADDR;
 	for (; i < cr_num_of_ac * 2; i++, addr += 4) {
-		if (i == cr_num_of_ac * 2 - 1 && is_mt7992(&dev->mt76))
+		if (i == cr_num_of_ac * 2 - 1 && has_ext)
 			sta_pause[i] = mt76_rr(dev, WF_DRR_TOP_AC1_STATION_PAUSE_EXT_00_ADDR);
 		else
 			sta_pause[i] = mt76_rr(dev, addr);
@@ -3972,7 +4091,7 @@ mt7996_get_sta_pause(struct mt7996_dev *dev, u8 band, u32 *sta_pause, u32 *twt_p
 
 	addr = WF_DRR_TOP_AC2_STATION_PAUSE00_ADDR;
 	for (; i < cr_num_of_ac * 3; i++, addr += 4) {
-		if (i == cr_num_of_ac * 3 - 1 && is_mt7992(&dev->mt76))
+		if (i == cr_num_of_ac * 3 - 1 && has_ext)
 			sta_pause[i] = mt76_rr(dev, WF_DRR_TOP_AC2_STATION_PAUSE_EXT_00_ADDR);
 		else
 			sta_pause[i] = mt76_rr(dev, addr);
@@ -3980,7 +4099,7 @@ mt7996_get_sta_pause(struct mt7996_dev *dev, u8 band, u32 *sta_pause, u32 *twt_p
 
 	addr = WF_DRR_TOP_AC3_STATION_PAUSE00_ADDR;
 	for (; i < cr_num_of_ac * 4; i++, addr += 4) {
-		if (i == cr_num_of_ac * 4 - 1 && is_mt7992(&dev->mt76))
+		if (i == cr_num_of_ac * 4 - 1 && has_ext)
 			sta_pause[i] = mt76_rr(dev, WF_DRR_TOP_AC3_STATION_PAUSE_EXT_00_ADDR);
 		else
 			sta_pause[i] = mt76_rr(dev, addr);
@@ -3988,8 +4107,8 @@ mt7996_get_sta_pause(struct mt7996_dev *dev, u8 band, u32 *sta_pause, u32 *twt_p
 
 	/* TWT */
 	addr = WF_DRR_TOP_TWT_STA_MAP00_ADDR;
-	for (i = 0; i < cr_num_of_ac; i++, addr += 4) {
-		if (i == cr_num_of_ac - 1 && is_mt7992(&dev->mt76))
+	for (i = 0; i < cr_num_of_twt; i++, addr += 4) {
+		if (i == cr_num_of_twt - 1 && has_ext)
 			twt_pause[i] = mt76_rr(dev, WF_DRR_TOP_TWT_STA_MAP_EXT_00_ADDR);
 		else
 			twt_pause[i] = mt76_rr(dev, addr);
@@ -4022,6 +4141,7 @@ mt7996_show_sta_acq_info(struct seq_file *s, unsigned long *ple_stat,
 	struct mt7996_dev *dev = dev_get_drvdata(s->private);
 	size_t cr_num_of_ac = ple_cr_num_of_ac(&dev->mt76);
 	size_t cr_num_of_all_ac = cr_num_of_ac * IEEE80211_NUM_ACS;
+	size_t cr_num_of_twt = ple_cr_num_of_twt(&dev->mt76);
 	int i, j;
 
 	for (j = 0; j < cr_num_of_all_ac; j++) { /* show AC Q info */
@@ -4055,7 +4175,7 @@ mt7996_show_sta_acq_info(struct seq_file *s, unsigned long *ple_stat,
 				if (sta_pause[idx] & BIT(i))
 					ctrl = 2;
 
-				idx = wcid->phy_idx * cr_num_of_ac + j % cr_num_of_ac;
+				idx = wcid->phy_idx * cr_num_of_twt + j % cr_num_of_twt;
 				if (twt_sta_pause[idx] & BIT(i))
 					ctrl = 3;
 
@@ -4117,6 +4237,7 @@ mt7996_pleinfo_read(struct seq_file *s, void *data)
 	struct mt7996_dev *dev = dev_get_drvdata(s->private);
 	size_t cr_num_of_ac = ple_cr_num_of_ac(&dev->mt76);
 	size_t cr_num_of_all_ac = cr_num_of_ac * IEEE80211_NUM_ACS;
+	size_t cr_num_of_twt = ple_cr_num_of_twt(&dev->mt76);
 	u32 *sta_pause, *twt_sta_pause;
 	unsigned long *ple_stat;
 	int i, j, ret = 0;
@@ -4131,7 +4252,7 @@ mt7996_pleinfo_read(struct seq_file *s, void *data)
 		goto out;
 	}
 
-	twt_sta_pause = kzalloc(__MT_MAX_BAND * cr_num_of_ac * sizeof(u32), GFP_KERNEL);
+	twt_sta_pause = kzalloc(__MT_MAX_BAND * cr_num_of_twt * sizeof(u32), GFP_KERNEL);
 	if (!twt_sta_pause) {
 		ret = -ENOMEM;
 		goto out;
@@ -4144,7 +4265,7 @@ mt7996_pleinfo_read(struct seq_file *s, void *data)
 		if (dev->mt76.phys[i])
 			mt7996_get_sta_pause(dev, i,
 					     sta_pause + i * cr_num_of_all_ac,
-					     twt_sta_pause + i * cr_num_of_ac);
+					     twt_sta_pause + i * cr_num_of_twt);
 	}
 
 	if ((ple_stat[0] & WF_PLE_TOP_QUEUE_EMPTY_ALL_AC_EMPTY_MASK) == 0) {
@@ -4467,8 +4588,9 @@ void mt7996_mtk_init_dev_debugfs(struct mt7996_dev *dev, struct dentry *dir)
 	u32 device_id = (dev->mt76.rev) >> 16;
 	int i = 0;
 	static const struct mt7996_dbg_reg_desc dbg_reg_s[] = {
-		{ 0x7990, mt7996_dbg_offs },
-		{ 0x7992, mt7992_dbg_offs },
+		{ MT7996_DEVICE_ID, mt7996_dbg_offs },
+		{ MT7992_DEVICE_ID, mt7992_dbg_offs },
+		{ MT7990_DEVICE_ID, mt7990_dbg_offs },
 	};
 
 	for (i = 0; i < ARRAY_SIZE(dbg_reg_s); i++) {
@@ -4482,10 +4604,12 @@ void mt7996_mtk_init_dev_debugfs(struct mt7996_dev *dev, struct dentry *dir)
 		WTBL_LMAC_DW2 = WTBL_LMAC_DW2_7996;
 		WTBL_LMAC_DW5 = WTBL_LMAC_DW5_7996;
 		WTBL_LMAC_DW9 = WTBL_LMAC_DW9_7996;
+		WTBL_LMAC_DW35 = WTBL_LMAC_DW35_7996;
 	} else {
 		WTBL_LMAC_DW2 = WTBL_LMAC_DW2_7992;
 		WTBL_LMAC_DW5 = WTBL_LMAC_DW5_7992;
 		WTBL_LMAC_DW9 = WTBL_LMAC_DW9_7992;
+		WTBL_LMAC_DW35 = WTBL_LMAC_DW35_7992;
 	}
 
 	/* amsdu */
diff --git a/mt7996/mtk_mcu.c b/mt7996/mtk_mcu.c
index e120a41e..ff4af090 100644
--- a/mt7996/mtk_mcu.c
+++ b/mt7996/mtk_mcu.c
@@ -1474,7 +1474,7 @@ int mt7996_mcu_set_muru_qos_cfg(struct mt7996_dev *dev, u16 wlan_idx, u8 dir,
 		return -EINVAL;
 	}
 
-	return mt76_mcu_send_msg(&dev->mt76, MCU_WM_UNI_CMD(MURU), &req,
+	return mt76_mcu_send_msg(&dev->mt76, MCU_WMWA_UNI_CMD(MURU), &req,
 				 sizeof(req), true);
 }
 #endif
diff --git a/mt7996/mtk_mcu.h b/mt7996/mtk_mcu.h
index 711903e0..df4e6c1e 100644
--- a/mt7996/mtk_mcu.h
+++ b/mt7996/mtk_mcu.h
@@ -819,9 +819,9 @@ enum ibf_version {
 static inline int get_ibf_version(struct mt7996_dev *dev)
 {
 	switch (mt76_chip(&dev->mt76)) {
-	case 0x7990:
+	case MT7996_DEVICE_ID:
 		return IBF_VER_1;
-	case 0x7992:
+	case MT7992_DEVICE_ID:
 	default:
 		return IBF_VER_2;
 	}
diff --git a/mt7996/pci.c b/mt7996/pci.c
index 38c1cb12..1abd5741 100644
--- a/mt7996/pci.c
+++ b/mt7996/pci.c
@@ -23,12 +23,14 @@ static u32 hif_idx;
 static const struct pci_device_id mt7996_pci_device_table[] = {
 	{ PCI_DEVICE(PCI_VENDOR_ID_MEDIATEK, MT7996_DEVICE_ID) },
 	{ PCI_DEVICE(PCI_VENDOR_ID_MEDIATEK, MT7992_DEVICE_ID) },
+	{ PCI_DEVICE(PCI_VENDOR_ID_MEDIATEK, MT7990_DEVICE_ID) },
 	{ },
 };
 
 static const struct pci_device_id mt7996_hif_device_table[] = {
 	{ PCI_DEVICE(PCI_VENDOR_ID_MEDIATEK, MT7996_DEVICE_ID_2) },
 	{ PCI_DEVICE(PCI_VENDOR_ID_MEDIATEK, MT7992_DEVICE_ID_2) },
+	{ PCI_DEVICE(PCI_VENDOR_ID_MEDIATEK, MT7990_DEVICE_ID_2) },
 	{ },
 };
 
@@ -72,7 +74,8 @@ static struct mt7996_hif *mt7996_pci_init_hif2(struct pci_dev *pdev)
 		return NULL;
 
 	if (!pci_get_device(PCI_VENDOR_ID_MEDIATEK, MT7996_DEVICE_ID_2, NULL) &&
-	    !pci_get_device(PCI_VENDOR_ID_MEDIATEK, MT7992_DEVICE_ID_2, NULL))
+	    !pci_get_device(PCI_VENDOR_ID_MEDIATEK, MT7992_DEVICE_ID_2, NULL) &&
+	    !pci_get_device(PCI_VENDOR_ID_MEDIATEK, MT7990_DEVICE_ID_2, NULL))
 		return NULL;
 
 	writel(hif_idx | MT_PCIE_RECOG_ID_SEM,
@@ -113,7 +116,10 @@ static int mt7996_pci_probe(struct pci_dev *pdev,
 	int irq, ret;
 	struct mt76_dev *mdev;
 
-	hif2_enable |= (id->device == 0x7990 || id->device == 0x7991 || id->device == 0x799a);
+	hif2_enable |= (id->device == MT7996_DEVICE_ID ||
+			id->device == MT7996_DEVICE_ID_2 ||
+			id->device == MT7992_DEVICE_ID_2 ||
+			id->device == MT7990_DEVICE_ID_2);
 
 	ret = pcim_enable_device(pdev);
 	if (ret)
@@ -136,7 +142,8 @@ static int mt7996_pci_probe(struct pci_dev *pdev,
 	mt76_pci_disable_aspm(pdev);
 
 	if (id->device == MT7996_DEVICE_ID_2 ||
-	    id->device == MT7992_DEVICE_ID_2)
+	    id->device == MT7992_DEVICE_ID_2 ||
+	    id->device == MT7990_DEVICE_ID_2)
 		return mt7996_pci_hif2_probe(pdev);
 
 	dev = mt7996_mmio_probe(&pdev->dev, pcim_iomap_table(pdev)[0],
@@ -276,3 +283,5 @@ MODULE_FIRMWARE(MT7992_FIRMWARE_WA);
 MODULE_FIRMWARE(MT7992_FIRMWARE_WM);
 MODULE_FIRMWARE(MT7992_FIRMWARE_DSP);
 MODULE_FIRMWARE(MT7992_ROM_PATCH);
+MODULE_FIRMWARE(MT7990_FIRMWARE_WM);
+MODULE_FIRMWARE(MT7990_ROM_PATCH);
diff --git a/mt7996/regs.h b/mt7996/regs.h
index e86d5df3..0c47269e 100644
--- a/mt7996/regs.h
+++ b/mt7996/regs.h
@@ -64,6 +64,17 @@ enum offs_rev {
 	MIB_BSCR7,
 	MIB_BSCR17,
 	MIB_TRDR1,
+	HIF_REMAP_L1,
+	HIF_REMAP_BASE_L1,
+	HIF_REMAP_L2,
+	HIF_REMAP_BASE_L2,
+	CBTOP1_PHY_END,
+	INFRA_MCU_END,
+	WTBLON_WDUCR,
+	WTBL_UPDATE,
+	WTBL_ITCR,
+	WTBL_ITCR0,
+	WTBL_ITCR1,
 	__MT_OFFS_MAX,
 };
 
@@ -300,19 +311,19 @@ enum offs_rev {
 /* WTBLON TOP */
 #define MT_WTBLON_TOP_BASE			0x820d4000
 #define MT_WTBLON_TOP(ofs)			(MT_WTBLON_TOP_BASE + (ofs))
-#define MT_WTBLON_TOP_WDUCR			MT_WTBLON_TOP(0x370)
+#define MT_WTBLON_TOP_WDUCR			MT_WTBLON_TOP(__OFFS(WTBLON_WDUCR))
 #define MT_WTBLON_TOP_WDUCR_GROUP		GENMASK(4, 0)
 
-#define MT_WTBL_UPDATE				MT_WTBLON_TOP(0x380)
+#define MT_WTBL_UPDATE				MT_WTBLON_TOP(__OFFS(WTBL_UPDATE))
 #define MT_WTBL_UPDATE_WLAN_IDX			GENMASK(11, 0)
 #define MT_WTBL_UPDATE_ADM_COUNT_CLEAR		BIT(14)
 #define MT_WTBL_UPDATE_BUSY			BIT(31)
 
-#define MT_WTBL_ITCR				MT_WTBLON_TOP(0x3b0)
+#define MT_WTBL_ITCR				MT_WTBLON_TOP(__OFFS(WTBL_ITCR))
 #define MT_WTBL_ITCR_WR				BIT(16)
 #define MT_WTBL_ITCR_EXEC			BIT(31)
-#define MT_WTBL_ITDR0				MT_WTBLON_TOP(0x3b8)
-#define MT_WTBL_ITDR1				MT_WTBLON_TOP(0x3bc)
+#define MT_WTBL_ITDR0				MT_WTBLON_TOP(__OFFS(WTBL_ITCR0))
+#define MT_WTBL_ITDR1				MT_WTBLON_TOP(__OFFS(WTBL_ITCR1))
 #define MT_WTBL_SPE_IDX_SEL			BIT(6)
 
 /* WTBL */
@@ -503,7 +514,7 @@ enum offs_rev {
 
 #define MT_MCUQ_EXT_CTRL(q)			(MT_Q_BASE(q) +	0x600 +	\
 						 MT_MCUQ_ID(q) * 0x4)
-#define MT_RXQ_BAND1_CTRL(q)			(MT_Q_BASE(__RXQ(q)) + 0x680 +	\
+#define MT_RXQ_EXT_CTRL(q)			(MT_Q_BASE(__RXQ(q)) + 0x680 +	\
 						 MT_RXQ_ID(q) * 0x4)
 #define MT_TXQ_EXT_CTRL(q)			(MT_Q_BASE(__TXQ(q)) + 0x600 +	\
 						 MT_TXQ_ID(q) * 0x4)
@@ -526,6 +537,8 @@ enum offs_rev {
 #define MT_INT_RX_TXFREE_BAND1			BIT(15)
 #define MT_INT_RX_TXFREE_TRI			BIT(15)
 #define MT_INT_RX_TXFREE_BAND1_EXT		BIT(19) /* for mt7992 two PCIE*/
+#define MT_INT_RX_TXFREE_BAND0_MT7990		BIT(14)
+#define MT_INT_RX_TXFREE_BAND1_MT7990		BIT(15)
 #define MT_INT_RX_DONE_BAND2_EXT		BIT(23)
 #define MT_INT_RX_TXFREE_EXT			BIT(26)
 #define MT_INT_MCU_CMD				BIT(29)
@@ -599,27 +612,40 @@ enum offs_rev {
 #define MT_MCU_CMD_WDT_MASK			GENMASK(31, 30)
 
 /* l1/l2 remap */
-#define MT_HIF_REMAP_L1				0x155024
-#define MT_HIF_REMAP_L1_MASK			GENMASK(31, 16)
+
+#define CONN_BUS_CR_VON_BASE			0x155000
+#define MT_HIF_REMAP_L1				(CONN_BUS_CR_VON_BASE + __OFFS(HIF_REMAP_L1))
+#define MT_HIF_REMAP_L1_MASK_7996		GENMASK(31, 16)
+#define MT_HIF_REMAP_L1_MASK			GENMASK(15, 0)
 #define MT_HIF_REMAP_L1_OFFSET			GENMASK(15, 0)
 #define MT_HIF_REMAP_L1_BASE			GENMASK(31, 16)
-#define MT_HIF_REMAP_BASE_L1			0x130000
+#define MT_HIF_REMAP_BASE_L1			__OFFS(HIF_REMAP_BASE_L1)
 
-#define MT_HIF_REMAP_L2				0x1b4
+#define MT_HIF_REMAP_L2				__OFFS(HIF_REMAP_L2)
 #define MT_HIF_REMAP_L2_MASK			GENMASK(19, 0)
 #define MT_HIF_REMAP_L2_OFFSET			GENMASK(11, 0)
 #define MT_HIF_REMAP_L2_BASE			GENMASK(31, 12)
-#define MT_HIF_REMAP_BASE_L2			0x1000
+#define MT_HIF_REMAP_L2_MASK_7990		GENMASK(15, 0)
+#define MT_HIF_REMAP_L2_OFFSET_7990		GENMASK(15, 0)
+#define MT_HIF_REMAP_L2_BASE_7990		GENMASK(31, 16)
+#define MT_HIF_REMAP_BASE_L2			__OFFS(HIF_REMAP_BASE_L2)
+
+/* for griffin only */
+#define MT_HIF_REMAP_CBTOP			0x1f6554
+#define MT_HIF_REMAP_CBTOP_MASK			GENMASK(15, 0)
+#define MT_HIF_REMAP_CBTOP_OFFSET		GENMASK(15, 0)
+#define MT_HIF_REMAP_CBTOP_BASE			GENMASK(31, 16)
+#define MT_HIF_REMAP_BASE_CBTOP			0x1c0000
 
 #define MT_INFRA_BASE				0x18000000
 #define MT_WFSYS0_PHY_START			0x18400000
 #define MT_WFSYS1_PHY_START			0x18800000
 #define MT_WFSYS1_PHY_END			0x18bfffff
 #define MT_CBTOP1_PHY_START			0x70000000
-#define MT_CBTOP1_PHY_END			0x77ffffff
+#define MT_CBTOP1_PHY_END			__OFFS(CBTOP1_PHY_END)
 #define MT_CBTOP2_PHY_START			0xf0000000
 #define MT_INFRA_MCU_START			0x7c000000
-#define MT_INFRA_MCU_END			0x7c3fffff
+#define MT_INFRA_MCU_END			__OFFS(INFRA_MCU_END)
 
 /* FW MODE SYNC */
 #define MT_FW_ASSERT_CNT			0x02208274
diff --git a/mt7996/testmode.c b/mt7996/testmode.c
index da4b193b..6893a4d2 100644
--- a/mt7996/testmode.c
+++ b/mt7996/testmode.c
@@ -611,7 +611,7 @@ mt7996_tm_dpd_prek(struct mt7996_phy *phy, enum mt76_testmode_state state)
 		},
 	};
 	u32 i, j, group_size, dpd_size, size, offs, *pre_cal;
-	u32 wait_on_prek_offset = 0;
+	u32 func_data, wait_on_prek_offset = 0;
 	u8 do_precal, *eeprom;
 	int ret = 0;
 
@@ -655,10 +655,13 @@ mt7996_tm_dpd_prek(struct mt7996_phy *phy, enum mt76_testmode_state state)
 		wait_event_timeout(mdev->mcu.wait, dev->cur_prek_offset == wait_on_prek_offset,
 				   30 * HZ);
 
+		/* griffin does not support mem dpd cal */
+		func_data = PREK(DPD_MEM_SIZE) ? RF_DPD_FLAT_5G_MEM_CAL : RF_DPD_FLAT_5G_CAL;
+
 		/* 5g channel bw80 calibration */
 		ret = mt7996_tm_dpd_prek_send_req(phy, &req, dpd_5g_ch_list_bw80,
 						  DPD_CH_NUM(BW80_5G),
-						  NL80211_CHAN_WIDTH_80, RF_DPD_FLAT_5G_MEM_CAL);
+						  NL80211_CHAN_WIDTH_80, func_data);
 		if (ret)
 			return ret;
 		wait_on_prek_offset += DPD_CH_NUM(BW80_5G) * DPD_PER_CH_GT_BW20_SIZE;
@@ -668,7 +671,7 @@ mt7996_tm_dpd_prek(struct mt7996_phy *phy, enum mt76_testmode_state state)
 		/* 5g channel bw160 calibration */
 		ret = mt7996_tm_dpd_prek_send_req(phy, &req, dpd_5g_ch_list_bw160,
 						  DPD_CH_NUM(BW160_5G),
-						  NL80211_CHAN_WIDTH_160, RF_DPD_FLAT_5G_MEM_CAL);
+						  NL80211_CHAN_WIDTH_160, func_data);
 		wait_on_prek_offset += DPD_CH_NUM(BW160_5G) * DPD_PER_CH_GT_BW20_SIZE;
 		wait_event_timeout(mdev->mcu.wait, dev->cur_prek_offset == wait_on_prek_offset,
 				   30 * HZ);
@@ -686,10 +689,13 @@ mt7996_tm_dpd_prek(struct mt7996_phy *phy, enum mt76_testmode_state state)
 		wait_event_timeout(mdev->mcu.wait, dev->cur_prek_offset == wait_on_prek_offset,
 				   30 * HZ);
 
+		/* griffin does not support mem dpd cal */
+		func_data = PREK(DPD_MEM_SIZE) ? RF_DPD_FLAT_6G_MEM_CAL : RF_DPD_FLAT_6G_CAL;
+
 		/* 6g channel bw80 calibration */
 		ret = mt7996_tm_dpd_prek_send_req(phy, &req, dpd_6g_ch_list_bw80,
 						  DPD_CH_NUM(BW80_6G),
-						  NL80211_CHAN_WIDTH_80, RF_DPD_FLAT_6G_MEM_CAL);
+						  NL80211_CHAN_WIDTH_80, func_data);
 		if (ret)
 			return ret;
 		wait_on_prek_offset += DPD_CH_NUM(BW80_6G) * DPD_PER_CH_GT_BW20_SIZE;
@@ -699,7 +705,7 @@ mt7996_tm_dpd_prek(struct mt7996_phy *phy, enum mt76_testmode_state state)
 		/* 6g channel bw160 calibration */
 		ret = mt7996_tm_dpd_prek_send_req(phy, &req, dpd_6g_ch_list_bw160,
 						  DPD_CH_NUM(BW160_6G),
-						  NL80211_CHAN_WIDTH_160, RF_DPD_FLAT_6G_MEM_CAL);
+						  NL80211_CHAN_WIDTH_160, func_data);
 		if (ret)
 			return ret;
 		wait_on_prek_offset += DPD_CH_NUM(BW160_6G) * DPD_PER_CH_GT_BW20_SIZE;
@@ -709,7 +715,7 @@ mt7996_tm_dpd_prek(struct mt7996_phy *phy, enum mt76_testmode_state state)
 		/* 6g channel bw320 calibration */
 		ret = mt7996_tm_dpd_prek_send_req(phy, &req, dpd_6g_ch_list_bw320,
 						  DPD_CH_NUM(BW320_6G),
-						  NL80211_CHAN_WIDTH_320, RF_DPD_FLAT_6G_MEM_CAL);
+						  NL80211_CHAN_WIDTH_320, func_data);
 		wait_on_prek_offset += DPD_CH_NUM(BW320_6G) * DPD_PER_CH_GT_BW20_SIZE;
 		wait_event_timeout(mdev->mcu.wait, dev->cur_prek_offset == wait_on_prek_offset,
 				   30 * HZ);
@@ -2157,6 +2163,9 @@ mt7996_tm_efuse_update_is_valid(struct mt7996_dev *dev, u32 offset, u8 *write_bu
 		[DDIE_7992] = {{.start = 0x10, .end = 0x18f, .prot_mask = -1},
 			       {.start = 0x1b0, .end = 0x3ff, .prot_mask = -1},
 			       {.start = -1}},
+		[DDIE_7990] = {{.start = 0x10, .end = 0x18f, .prot_mask = -1},
+			       {.start = 0x1b0, .end = 0x3ff, .prot_mask = -1},
+			       {.start = -1}},
 	};
 	static const struct efuse_region adie_prot_offs[][PROT_OFFS_MAX_SIZE] = {
 		[ADIE_7975] = {{.start = 0x5c0, .end = 0x62f, .prot_mask = -1},
@@ -2227,6 +2236,13 @@ mt7996_tm_efuse_update_is_valid(struct mt7996_dev *dev, u32 offset, u8 *write_bu
 		base = EFUSE_BASE_OFFS_DDIE;
 		prot_offs = ddie_prot_offs[DDIE_7992];
 		break;
+	case MT7990_DEVICE_ID:
+		/* block all the adie region in efuse for griffin */
+		if (offset >= EFUSE_BASE_OFFS_ADIE0)
+			return false;
+		base = EFUSE_BASE_OFFS_DDIE;
+		prot_offs = ddie_prot_offs[DDIE_7990];
+		break;
 	default:
 		return false;
 	}
diff --git a/mt7996/vendor.c b/mt7996/vendor.c
index 5f2faee9..ece8fabf 100644
--- a/mt7996/vendor.c
+++ b/mt7996/vendor.c
@@ -875,11 +875,19 @@ static int mt7996_vendor_pp_ctrl(struct wiphy *wiphy, struct wireless_dev *wdev,
 		return 0;
 
 	switch (mode) {
+	case PP_FW_MODE:
+		err = mt7996_mcu_set_pp_alg_ctrl(phy, PP_ALG_SET_TIMER);
+		if (err)
+			return err;
+
+		err = mt7996_mcu_set_pp_alg_ctrl(phy, PP_ALG_SET_THR);
+		if (err)
+			return err;
+		fallthrough;
 	case PP_USR_MODE:
 		if (tb[MTK_VENDOR_ATTR_PP_BITMAP])
 			punct_bitmap = nla_get_u16(tb[MTK_VENDOR_ATTR_PP_BITMAP]);
 		fallthrough;
-	case PP_FW_MODE:
 	case PP_DISABLE:
 		err = mt7996_mcu_set_pp_en(phy, mode, punct_bitmap);
 		break;
diff --git a/testmode.c b/testmode.c
index a85be184..8ac85844 100644
--- a/testmode.c
+++ b/testmode.c
@@ -41,7 +41,7 @@ EXPORT_SYMBOL_GPL(mt76_tm_policy);
 
 static inline bool mt76_testmode_offload(struct mt76_dev *dev)
 {
-	return is_mt7996(dev) || is_mt7992(dev);
+	return is_mt799x(dev);
 }
 
 void mt76_testmode_tx_pending(struct mt76_phy *phy)
-- 
2.45.2

