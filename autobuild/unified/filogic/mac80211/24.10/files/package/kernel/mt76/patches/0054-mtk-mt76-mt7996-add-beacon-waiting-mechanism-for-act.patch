From 7d2cb6d20db06b621e1686c9e145b81ed0fd5a3c Mon Sep 17 00:00:00 2001
From: StanleyYP Wang <StanleyYP.Wang@mediatek.com>
Date: Wed, 4 Dec 2024 17:54:39 +0800
Subject: [PATCH 54/75] mtk: mt76: mt7996: add beacon waiting mechanism for
 active scanning on radar channel

For radar/no-IR channels, the scan defaults to passive scanning.
However, if beacons/probe resps are received on this channel, then
the scan can be upgraded to active scanning.
This helps the STA scan for the hidden root AP on DFS channels.

Clear MT76_SCANNING_WAIT_BEACON & MT76_SCANNING_BEACON_DONE flag if
scanning is completed

Signed-off-by: StanleyYP Wang <StanleyYP.Wang@mediatek.com>
---
 mt76.h         |  2 ++
 mt7996/debug.h |  1 +
 mt7996/mac.c   | 64 +++++++++++++++++++++++++++++++++++++++++++-------
 mt7996/main.c  |  2 ++
 4 files changed, 61 insertions(+), 8 deletions(-)

diff --git a/mt76.h b/mt76.h
index 31674b4f..1585d78b 100644
--- a/mt76.h
+++ b/mt76.h
@@ -555,6 +555,8 @@ enum {
 	MT76_STATE_ROC,
 	MT76_STATE_PM,
 	MT76_STATE_WED_RESET,
+	MT76_SCANNING_WAIT_BEACON,
+	MT76_SCANNING_BEACON_DONE,
 };
 
 enum mt76_sta_event {
diff --git a/mt7996/debug.h b/mt7996/debug.h
index c9454567..750bed6a 100644
--- a/mt7996/debug.h
+++ b/mt7996/debug.h
@@ -14,6 +14,7 @@ enum mt7996_debug_mask {
 	MT7996_DBG_CHAN = BIT(3),
 	MT7996_DBG_MLD = BIT(4),
 	MT7996_DBG_TXRX = BIT(5),
+	MT7996_DBG_SCAN = BIT(6),
 
 	MT7996_DBG_ALL = 0xffffffff,
 };
diff --git a/mt7996/mac.c b/mt7996/mac.c
index 131b4668..61c8a6a2 100644
--- a/mt7996/mac.c
+++ b/mt7996/mac.c
@@ -12,6 +12,7 @@
 #include "mcu.h"
 #include "vendor.h"
 #include "mt7996_trace.h"
+#include "debug.h"
 
 static const struct mt7996_dfs_radar_spec etsi_radar_specs = {
 	.pulse_th = { 110, -10, -80, 40, 5200, 128, 5200 },
@@ -52,6 +53,8 @@ static const struct mt7996_dfs_radar_spec jp_radar_specs = {
 	},
 };
 
+static void mt7996_scan_rx(struct mt7996_phy *phy);
+
 bool mt7996_mac_wtbl_update(struct mt7996_dev *dev, int idx, u32 mask)
 {
 	mt76_rmw(dev, MT_WTBL_UPDATE, MT_WTBL_UPDATE_WLAN_IDX,
@@ -561,6 +564,10 @@ mt7996_mac_fill_rx(struct mt7996_dev *dev, enum mt76_rxq_id q,
 
 		hdr = mt76_skb_get_hdr(skb);
 		fc = hdr->frame_control;
+
+		if (unlikely(ieee80211_is_probe_resp(fc) || ieee80211_is_beacon(fc)))
+			mt7996_scan_rx(phy);
+
 		if (ieee80211_is_data_qos(fc)) {
 			u8 *qos = ieee80211_get_qos_ctl(hdr);
 
@@ -3422,6 +3429,33 @@ static void mt7996_scan_check_sta(void *data, struct ieee80211_sta *sta)
 	*has_sta = true;
 }
 
+static void mt7996_active_scan(struct mt7996_phy *phy)
+{
+	struct cfg80211_scan_request *req = phy->scan_req;
+	int i;
+
+	mutex_lock(&phy->dev->mt76.mutex);
+	for (i = 0; i < req->n_ssids; i++)
+		mt7996_scan_send_probe(phy, &req->ssids[i], req->bssid);
+	mutex_unlock(&phy->dev->mt76.mutex);
+}
+
+static void mt7996_scan_rx(struct mt7996_phy *phy)
+{
+	struct ieee80211_vif *vif = phy->scan_vif;
+	struct mt7996_vif *mvif;
+
+	if (!vif || !test_bit(MT76_SCANNING, &phy->mt76->state))
+		return;
+
+	if (test_and_clear_bit(MT76_SCANNING_WAIT_BEACON, &phy->mt76->state)) {
+		mvif = (struct mt7996_vif *)vif->drv_priv;
+		set_bit(MT76_SCANNING_BEACON_DONE, &phy->mt76->state);
+		cancel_delayed_work(&phy->scan_work);
+		ieee80211_queue_delayed_work(phy->mt76->hw, &phy->scan_work, 0);
+	}
+}
+
 void mt7996_scan_work(struct work_struct *work)
 {
 	struct mt7996_phy *phy = container_of(work, struct mt7996_phy, scan_work.work);
@@ -3433,6 +3467,8 @@ void mt7996_scan_work(struct work_struct *work)
 
 	mutex_lock(&phy->dev->mt76.mutex);
 
+	clear_bit(MT76_SCANNING_WAIT_BEACON, &phy->mt76->state);
+
 	if (phy->scan_chan_idx >= req->n_channels) {
 		mt7996_scan_complete(phy, false);
 		mutex_unlock(&phy->dev->mt76.mutex);
@@ -3445,6 +3481,19 @@ void mt7996_scan_work(struct work_struct *work)
 		return;
 	}
 
+	/* move to active scan for the current scanning channel */
+	if (test_and_clear_bit(MT76_SCANNING_BEACON_DONE, &phy->mt76->state)) {
+		mutex_unlock(&phy->dev->mt76.mutex);
+
+		mt7996_active_scan(phy);
+		ieee80211_queue_delayed_work(hw, &phy->scan_work, HZ / 16);
+		mt7996_dbg(phy->dev, MT7996_DBG_SCAN,
+			   "%s: move to active scan on channel %d\n",
+			   __func__, phy->chanctx ? phy->chanctx->chandef.center_freq1 :
+						    phy->mt76->chandef.center_freq1);
+		return;
+	}
+
 	ieee80211_iterate_stations_atomic(hw, mt7996_scan_check_sta, &has_sta);
 
 	/* go back to operating channel */
@@ -3467,6 +3516,11 @@ void mt7996_scan_work(struct work_struct *work)
 	if (!req->n_ssids ||
 	    (phy->scan_chan->flags & (IEEE80211_CHAN_NO_IR |
 				      IEEE80211_CHAN_RADAR))) {
+		/* allow active scan on radar/no-IR channels
+		 * if beacons from other APs are received
+		 */
+		if (req->n_ssids)
+			set_bit(MT76_SCANNING_WAIT_BEACON, &phy->mt76->state);
 		duration = HZ / 9; /* ~110 ms */
 	} else {
 		duration = HZ / 16; /* ~60 ms */
@@ -3478,14 +3532,8 @@ void mt7996_scan_work(struct work_struct *work)
 
 	mt7996_config_channel(phy, &chandef);
 
-	if (active_scan) {
-		int i;
-
-		mutex_lock(&phy->dev->mt76.mutex);
-		for (i = 0; i < req->n_ssids; i++)
-			mt7996_scan_send_probe(phy, &req->ssids[i], req->bssid);
-		mutex_unlock(&phy->dev->mt76.mutex);
-	}
+	if (active_scan)
+		mt7996_active_scan(phy);
 
 	ieee80211_queue_delayed_work(hw, &phy->scan_work, duration);
 }
diff --git a/mt7996/main.c b/mt7996/main.c
index 59512690..623a9521 100644
--- a/mt7996/main.c
+++ b/mt7996/main.c
@@ -2639,6 +2639,8 @@ void mt7996_scan_complete(struct mt7996_phy *phy, bool aborted)
 	phy->scan_req = NULL;
 	phy->scan_vif = NULL;
 	clear_bit(MT76_SCANNING, &phy->mt76->state);
+	clear_bit(MT76_SCANNING_WAIT_BEACON, &phy->mt76->state);
+	clear_bit(MT76_SCANNING_BEACON_DONE, &phy->mt76->state);
 }
 
 static int
-- 
2.45.2

