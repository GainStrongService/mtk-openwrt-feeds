From a567ea41952ca526cfd4948b76205eaccdd70a0b Mon Sep 17 00:00:00 2001
From: Rex Lu <rex.lu@mediatek.com>
Date: Wed, 4 Feb 2026 15:10:48 +0800
Subject: [PATCH 3/4] mtk: wifi: mt76: mt7996: Refactor L0.5 recovery

cherry-pick from
1. https://gerrit.mediatek.inc/c/gateway/WiFi7/mac80211/mt76/+/11491343
2. https://github.com/openwrt/mt76/commit/ffda4432654d08f51b468a9dddaf118407a2460c
3. https://github.com/openwrt/mt76/commit/d17519baab7709dcb706729e3269da022fa75ebb
4. https://github.com/openwrt/mt76/commit/6745cece7a0717d5f70946c07889bc86b02d5791
5. https://github.com/openwrt/mt76/commit/d4a79d50ffc607cf42606b11aa5157ab7b3e8d07

Signed-off-by: Rex Lu <rex.lu@mediatek.com>
---
 mac80211.c      |   2 +
 mt7996/init.c   |  42 +++++++++--
 mt7996/mac.c    | 193 +++++++++++++++++++++++++-----------------------
 mt7996/main.c   |  18 +++++
 mt7996/mt7996.h |   1 +
 mt7996/regs.h   |   9 ++-
 6 files changed, 165 insertions(+), 100 deletions(-)

diff --git a/mac80211.c b/mac80211.c
index 646fdc0f1..36d35b271 100644
--- a/mac80211.c
+++ b/mac80211.c
@@ -813,6 +813,8 @@ static void mt76_reset_phy(struct mt76_phy *phy)
 		return;
 
 	INIT_LIST_HEAD(&phy->tx_list);
+	phy->num_sta = 0;
+	phy->chanctx = NULL;
 }
 
 void mt76_reset_device(struct mt76_dev *dev)
diff --git a/mt7996/init.c b/mt7996/init.c
index 190c39cdc..adfa23e96 100644
--- a/mt7996/init.c
+++ b/mt7996/init.c
@@ -1005,11 +1005,8 @@ static void mt7996_low_power_config(struct mt7996_dev *dev)
 	mt7996_mcu_set_pst(dev, 0xff, 0, !!(lp_ctrl & BIT(LOW_POWER_TX_PST)));
 }
 
-static void mt7996_init_work(struct work_struct *work)
+void mt7996_init_work_reset(struct mt7996_dev *dev)
 {
-	struct mt7996_dev *dev = container_of(work, struct mt7996_dev,
-				 init_work);
-
 	mt7996_mcu_set_eeprom(dev);
 	mt7996_mac_init(dev);
 	mt7996_txbf_init(dev);
@@ -1023,13 +1020,44 @@ static void mt7996_init_work(struct work_struct *work)
 	mt7996_mcu_ba_trigger_enable(dev, true);
 }
 
+static void mt7996_init_work(struct work_struct *work)
+{
+	struct mt7996_dev *dev = container_of(work, struct mt7996_dev,
+				 init_work);
+
+	mt7996_init_work_reset(dev);
+}
+
 void mt7996_wfsys_reset(struct mt7996_dev *dev)
 {
-	mt76_set(dev, MT_WF_SUBSYS_RST, 0x1);
-	msleep(20);
+	if (!is_mt7990(&dev->mt76)) {
+		mt76_set(dev, MT_WF_SUBSYS_RST, 0x1);
+		msleep(20);
+
+		mt76_clear(dev, MT_WF_SUBSYS_RST, 0x1);
+		msleep(20);
+
+		return;
+	}
 
-	mt76_clear(dev, MT_WF_SUBSYS_RST, 0x1);
+	if (!dev->recovery.hw_full_reset)
+		return;
+
+	mt76_set(dev, MT_WF_SUBSYS_RST,
+		 MT_WF_SUBSYS_RST_WHOLE_PATH_RST_REVERT |
+		 MT_WF_SUBSYS_RST_BYPASS_WFDMA_SLP_PROT |
+		 MT_WF_SUBSYS_RST_BYPASS_WFDMA2_SLP_PROT);
+	mt76_rmw(dev, MT_WF_SUBSYS_RST,
+		 MT_WF_SUBSYS_RST_WHOLE_PATH_RST_REVERT_CYCLE,
+		 u32_encode_bits(0x20, MT_WF_SUBSYS_RST_WHOLE_PATH_RST_REVERT_CYCLE));
+	mt76_clear(dev, MT_WF_L05_RST, MT_WF_L05_RST_WF_RST_MASK);
+	mt76_set(dev, MT_WF_SUBSYS_RST, MT_WF_SUBSYS_RST_WHOLE_PATH_RST);
 	msleep(20);
+
+	if (mt76_poll(dev, MT_WF_L05_RST, MT_WF_L05_RST_WF_RST_MASK, 0x1a, 1000))
+		return;
+
+	dev_err(dev->mt76.dev, "wfsys reset fail\n");
 }
 
 static void mt7996_rro_v3_hw_init(struct mt7996_dev *dev)
diff --git a/mt7996/mac.c b/mt7996/mac.c
index 00fc68fac..39f34b467 100644
--- a/mt7996/mac.c
+++ b/mt7996/mac.c
@@ -2500,13 +2500,10 @@ void mt7996_tx_token_put(struct mt7996_dev *dev)
 static int
 mt7996_mac_restart(struct mt7996_dev *dev)
 {
-	struct mt7996_phy *phy2, *phy3;
 	struct mt76_dev *mdev = &dev->mt76;
+	struct mt7996_phy *phy;
 	int i, ret;
 
-	phy2 = mt7996_phy2(dev);
-	phy3 = mt7996_phy3(dev);
-
 	if (dev->hif2) {
 		mt76_wr(dev, MT_INT1_MASK_CSR, 0x0);
 		mt76_wr(dev, MT_INT1_SOURCE_CSR, ~0);
@@ -2518,20 +2515,14 @@ mt7996_mac_restart(struct mt7996_dev *dev)
 			mt76_wr(dev, MT_PCIE1_MAC_INT_ENABLE, 0x0);
 	}
 
-	set_bit(MT76_RESET, &dev->mphy.state);
 	set_bit(MT76_MCU_RESET, &dev->mphy.state);
+	mt7996_for_each_phy(dev, phy)
+		set_bit(MT76_RESET, &phy->mt76->state);
 	wake_up(&dev->mt76.mcu.wait);
-	if (phy2)
-		set_bit(MT76_RESET, &phy2->mt76->state);
-	if (phy3)
-		set_bit(MT76_RESET, &phy3->mt76->state);
 
 	/* lock/unlock all queues to ensure that no tx is pending */
-	mt76_txq_schedule_all(&dev->mphy);
-	if (phy2)
-		mt76_txq_schedule_all(phy2->mt76);
-	if (phy3)
-		mt76_txq_schedule_all(phy3->mt76);
+	mt7996_for_each_phy(dev, phy)
+		mt76_txq_schedule_all(phy->mt76);
 
 	/* disable all tx/rx napi */
 	mt76_worker_disable(&dev->mt76.tx_worker);
@@ -2609,41 +2600,16 @@ mt7996_mac_restart(struct mt7996_dev *dev)
 	}
 
 	/* set the necessary init items */
-	ret = mt7996_mcu_set_eeprom(dev);
-	if (ret)
-		goto out;
-
-	mt7996_mac_init(dev);
-	mt7996_init_txpower(&dev->phy);
-	mt7996_init_txpower(phy2);
-	mt7996_init_txpower(phy3);
-	ret = mt7996_txbf_init(dev);
+	mt7996_init_work_reset(dev);
 
-	if (test_bit(MT76_STATE_RUNNING, &dev->mphy.state)) {
-		ret = mt7996_run(&dev->phy);
-		if (ret)
-			goto out;
-	}
-
-	if (phy2 && test_bit(MT76_STATE_RUNNING, &phy2->mt76->state)) {
-		ret = mt7996_run(phy2);
-		if (ret)
-			goto out;
-	}
-
-	if (phy3 && test_bit(MT76_STATE_RUNNING, &phy3->mt76->state)) {
-		ret = mt7996_run(phy3);
-		if (ret)
-			goto out;
-	}
+	/* Clear running state for subsequent mt7996_run to reset it again */
+	mt7996_for_each_phy(dev, phy)
+		clear_bit(MT76_STATE_RUNNING, &phy->mt76->state);
 
 out:
 	/* reset done */
-	clear_bit(MT76_RESET, &dev->mphy.state);
-	if (phy2)
-		clear_bit(MT76_RESET, &phy2->mt76->state);
-	if (phy3)
-		clear_bit(MT76_RESET, &phy3->mt76->state);
+	mt7996_for_each_phy(dev, phy)
+		clear_bit(MT76_RESET, &phy->mt76->state);
 
 	napi_enable(&dev->mt76.tx_napi);
 	local_bh_disable();
@@ -2655,76 +2621,119 @@ out:
 }
 
 static void
-mt7996_mac_full_reset(struct mt7996_dev *dev)
+mt7996_mac_reset_sta_iter(void *data, struct ieee80211_sta *sta)
 {
-	struct mt7996_phy *phy2, *phy3;
+	struct mt7996_sta *msta = (struct mt7996_sta *)sta->drv_priv;
+	struct mt7996_dev *dev = data;
 	int i;
 
-	phy2 = mt7996_phy2(dev);
-	phy3 = mt7996_phy3(dev);
-	dev->recovery.hw_full_reset = true;
+	for (i = 0; i < ARRAY_SIZE(msta->link); i++) {
+		struct mt7996_sta_link *msta_link = NULL;
 
-	ieee80211_stop_queues(mt76_hw(dev));
-	if (phy2)
-		ieee80211_stop_queues(phy2->mt76->hw);
-	if (phy3)
-		ieee80211_stop_queues(phy3->mt76->hw);
+		msta_link = rcu_replace_pointer(msta->link[i], msta_link,
+						lockdep_is_held(&dev->mt76.mutex));
+		if (!msta_link)
+			continue;
 
-	set_bit(MT76_RESET, &dev->mphy.state);
-	set_bit(MT76_MCU_RESET, &dev->mphy.state);
-	wake_up(&dev->mt76.mcu.wait);
-	if (phy2) {
-		set_bit(MT76_RESET, &phy2->mt76->state);
-		set_bit(MT76_MCU_RESET, &phy2->mt76->state);
+		spin_lock_bh(&dev->mt76.sta_poll_lock);
+		if (!list_empty(&msta_link->wcid.poll_list))
+			list_del_init(&msta_link->wcid.poll_list);
+		if (!list_empty(&msta_link->rc_list))
+			list_del_init(&msta_link->rc_list);
+		spin_unlock_bh(&dev->mt76.sta_poll_lock);
+
+		mt76_wcid_cleanup(&dev->mt76, &msta_link->wcid);
+		mt76_wcid_mask_clear(dev->mt76.wcid_mask, msta_link->wcid.idx);
+
+		if (msta->deflink_id == i) {
+			msta->deflink_id = IEEE80211_LINK_UNSPECIFIED;
+			continue;
+		}
+
+		kfree_rcu(msta_link, rcu_head);
 	}
-	if (phy3) {
-		set_bit(MT76_RESET, &phy3->mt76->state);
-		set_bit(MT76_MCU_RESET, &phy3->mt76->state);
+}
+
+static void
+mt7996_mac_reset_vif_iter(void *data, u8 *mac, struct ieee80211_vif *vif)
+{
+	struct mt76_vif_link *mlink = (struct mt76_vif_link *)vif->drv_priv;
+	struct mt76_vif_data *mvif = mlink->mvif;
+	struct mt7996_dev *dev = data;
+	struct mt7996_vif_link *mconf;
+	int link_id;
+	unsigned long rem;
+
+	/* remove all links and fallback to non-MLO interface */
+	rem = mvif->valid_links;
+	for_each_set_bit(link_id, &rem, IEEE80211_MLD_MAX_NUM_LINKS) {
+		mconf = mt7996_vif_link(dev, vif, link_id);
+		if (!mconf || !mconf->phy)
+			continue;
+
+		mt7996_vif_link_remove(mconf->phy->mt76, vif, NULL, &mconf->mt76);
 	}
+}
+
+static void
+mt7996_mac_full_reset(struct mt7996_dev *dev)
+{
+	struct ieee80211_hw *hw = mt76_hw(dev);
+	struct mt7996_phy *phy;
+	LIST_HEAD(list);
+	int i;
+
+	dev->recovery.hw_full_reset = true;
+
+	wake_up(&dev->mt76.mcu.wait);
+	ieee80211_stop_queues(hw);
 
 	cancel_work_sync(&dev->wed_rro.work);
-	cancel_delayed_work_sync(&dev->mphy.mac_work);
-	if (phy2)
-		cancel_delayed_work_sync(&phy2->mt76->mac_work);
-	if (phy3)
-		cancel_delayed_work_sync(&phy3->mt76->mac_work);
 	cancel_delayed_work_sync(&dev->scs_work);
+	mt7996_for_each_phy(dev, phy)
+		cancel_delayed_work_sync(&phy->mt76->mac_work);
 
 	mutex_lock(&dev->mt76.mutex);
 	for (i = 0; i < 10; i++) {
 		if (!mt7996_mac_restart(dev))
 			break;
 	}
-	mutex_unlock(&dev->mt76.mutex);
 
 	if (i == 10)
 		dev_err(dev->mt76.dev, "chip full reset failed\n");
 
-	ieee80211_restart_hw(mt76_hw(dev));
-	if (phy2)
-		ieee80211_restart_hw(phy2->mt76->hw);
-	if (phy3)
-		ieee80211_restart_hw(phy3->mt76->hw);
+	mt7996_for_each_phy(dev, phy)
+		phy->omac_mask = 0;
 
-	ieee80211_wake_queues(mt76_hw(dev));
-	if (phy2)
-		ieee80211_wake_queues(phy2->mt76->hw);
-	if (phy3)
-		ieee80211_wake_queues(phy3->mt76->hw);
+	ieee80211_iterate_stations_atomic(hw, mt7996_mac_reset_sta_iter, dev);
+	ieee80211_iterate_active_interfaces_atomic(hw,
+						   IEEE80211_IFACE_SKIP_SDATA_NOT_IN_DRIVER,
+						   mt7996_mac_reset_vif_iter, dev);
+	mt76_reset_device(&dev->mt76);
+
+	INIT_LIST_HEAD(&dev->sta_rc_list);
+	INIT_LIST_HEAD(&dev->twt_list);
+
+	spin_lock_bh(&dev->wed_rro.lock);
+	list_splice_init(&dev->wed_rro.poll_list, &list);
+	spin_unlock_bh(&dev->wed_rro.lock);
 
+	while (!list_empty(&list)) {
+		struct mt7996_wed_rro_session_id *e;
+
+		e = list_first_entry(&list, struct mt7996_wed_rro_session_id,
+				     list);
+		list_del_init(&e->list);
+		kfree(e);
+	}
+
+	i = mt76_wcid_alloc(dev->mt76.wcid_mask, MT7996_WTBL_STA);
+	dev->mt76.global_wcid.idx = i;
 	dev->recovery.hw_full_reset = false;
-	ieee80211_queue_delayed_work(mt76_hw(dev),
-				     &dev->mphy.mac_work,
-				     MT7996_WATCHDOG_TIME);
-	if (phy2)
-		ieee80211_queue_delayed_work(phy2->mt76->hw,
-					     &phy2->mt76->mac_work,
-					     MT7996_WATCHDOG_TIME);
-	if (phy3)
-		ieee80211_queue_delayed_work(phy3->mt76->hw,
-					     &phy3->mt76->mac_work,
-					     MT7996_WATCHDOG_TIME);
-	ieee80211_queue_delayed_work(mt76_hw(dev), &dev->scs_work, HZ);
+
+	mutex_unlock(&dev->mt76.mutex);
+
+	ieee80211_restart_hw(mt76_hw(dev));
 }
 
 void mt7996_mac_reset_work(struct work_struct *work)
diff --git a/mt7996/main.c b/mt7996/main.c
index db961dca1..297f7fca5 100644
--- a/mt7996/main.c
+++ b/mt7996/main.c
@@ -398,11 +398,15 @@ void mt7996_vif_link_remove(struct mt76_phy *mphy, struct ieee80211_vif *vif,
 
 	cancel_delayed_work(&link->sta_chsw_work);
 
+	if (dev->recovery.hw_full_reset)
+		goto cleanup;
+
 	mt7996_mcu_add_sta(dev, vif, link_conf, NULL, link, NULL,
 			   CONN_STATE_DISCONNECT, false);
 	mt7996_mcu_add_bss_info(phy, vif, link_conf, mlink, msta_link, false);
 	mt7996_mcu_add_dev_info(phy, vif, link_conf, mlink, false);
 
+cleanup:
 	rcu_assign_pointer(dev->mt76.wcid[idx], NULL);
 	rcu_assign_pointer(mvif->mt76.link[link_id], NULL);
 	rcu_assign_pointer(mvif->sta.link[link_id], NULL);
@@ -2992,6 +2996,19 @@ mt7996_can_neg_ttlm(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 	return vif->adv_ttlm.active ? NEG_TTLM_RES_REJECT : NEG_TTLM_RES_ACCEPT;
 }
 
+static void
+mt7996_reconfig_complete(struct ieee80211_hw *hw,
+			 enum ieee80211_reconfig_type reconfig_type)
+{
+	struct mt7996_dev *dev = mt7996_hw_dev(hw);
+	struct mt7996_phy *phy;
+
+	ieee80211_wake_queues(hw);
+	mt7996_for_each_phy(dev, phy)
+		ieee80211_queue_delayed_work(hw, &phy->mt76->mac_work,
+					     MT7996_WATCHDOG_TIME);
+}
+
 static void
 mt7996_event_callback(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 		      const struct ieee80211_event *event)
@@ -3191,6 +3208,7 @@ const struct ieee80211_ops mt7996_ops = {
 	.event_callback = mt7996_event_callback,
 	.change_vif_links = mt7996_change_vif_links,
 	.change_sta_links = mt7996_mac_sta_change_links,
+	.reconfig_complete = mt7996_reconfig_complete,
 	.set_qos_map = mt7996_set_qos_map,
 	.set_attlm = mt7996_set_attlm,
 	.set_sta_ttlm = mt7996_set_sta_ttlm,
diff --git a/mt7996/mt7996.h b/mt7996/mt7996.h
index 9bfb2b61f..0b2f74b3d 100644
--- a/mt7996/mt7996.h
+++ b/mt7996/mt7996.h
@@ -1202,6 +1202,7 @@ extern const struct mt76_testmode_ops mt7996_testmode_ops;
 struct mt7996_dev *mt7996_mmio_probe(struct device *pdev,
 				     void __iomem *mem_base, u32 device_id);
 void mt7996_wfsys_reset(struct mt7996_dev *dev);
+void mt7996_init_work_reset(struct mt7996_dev *dev);
 void mt7996_rro_hw_init(struct mt7996_dev *dev);
 irqreturn_t mt7996_irq_handler(int irq, void *dev_instance);
 u64 __mt7996_get_tsf(struct ieee80211_hw *hw, struct mt7996_vif_link *link);
diff --git a/mt7996/regs.h b/mt7996/regs.h
index 42e0f8507..dae87c7ea 100644
--- a/mt7996/regs.h
+++ b/mt7996/regs.h
@@ -752,8 +752,15 @@ enum offs_rev {
 #define MT_HW_REV				0x70010204
 #define MT_HW_REV1				0x8a00
 
-#define MT_WF_SUBSYS_RST			0x70028600
+#define MT_WF_L05_RST				0x70028550
+#define MT_WF_L05_RST_WF_RST_MASK		GENMASK(4, 0)
 
+#define MT_WF_SUBSYS_RST			0x70028600
+#define MT_WF_SUBSYS_RST_WHOLE_PATH_RST		BIT(0)
+#define MT_WF_SUBSYS_RST_WHOLE_PATH_RST_REVERT	BIT(5)
+#define MT_WF_SUBSYS_RST_BYPASS_WFDMA_SLP_PROT	BIT(6)
+#define MT_WF_SUBSYS_RST_BYPASS_WFDMA2_SLP_PROT	BIT(16)
+#define MT_WF_SUBSYS_RST_WHOLE_PATH_RST_REVERT_CYCLE	GENMASK(15, 8)
 /* PCIE MAC */
 #define MT_PCIE_MAC_BASE			0x74030000
 #define MT_PCIE_MAC(ofs)			(MT_PCIE_MAC_BASE + (ofs))
-- 
2.45.2

