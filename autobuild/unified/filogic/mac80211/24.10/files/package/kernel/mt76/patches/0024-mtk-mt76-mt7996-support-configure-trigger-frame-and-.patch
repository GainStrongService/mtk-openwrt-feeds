From ff479fc2aa981160275ccb4ec460c5f1a9056f9a Mon Sep 17 00:00:00 2001
From: Howard Hsu <howard-yh.hsu@mediatek.com>
Date: Tue, 7 May 2024 10:00:09 +0800
Subject: [PATCH 24/75] mtk: mt76: mt7996: support configure trigger frame and
 coding type

mtk: mt76: mt7996: support configure trigger frame type

Support receiving an nl80211 subcmd
MTK_VENDOR_ATTR_RFEATURE_CTRL_TRIG_VARIANT_TYPE, which is used to
configure the trigger frame type by sending mcu commands. The input
value can be 0 or 1. The former is for HE variant trigger frame and the
latter is for EHT variant trigger frame.

The purpose of this commit is for WiFi 7 R1 cert UL-RU and UL-MU test
cases.

mtk: mt76: mt7996: support configure coding type for wifi7 r1 cert

This commit includes two changes for WiFi7 cert fix rate test cases.
First, support receiving an nl80211 subcmd
MTK_VENDOR_ATTR_RFEATURE_CTRL_CODING_TYPE, which is used to
configure the encoding type by sending mcu commands. The input
value can be 0, 1 or 8.

Second, if we fix partial rate by two different user space commands,
the first command will be useless due to the design of mcu commands.
Some mcu commands could not be sent when we run several user space
commands to fix partial rate. To address this issue, we utilize variable
cert_mode to determine whether we are currently using multiple user
space commands to fix the partial rate.

mtk: mt76: mt7996: support find the mt7996_phy by link_id for vendor command

Add support to find the corresponding phy by link_id. This commit is for
the wifi7 r1 cert UL OFDMA case. If we want to force sending trigger
frame on the specific band, we need to fill band idx in the mcu cmd.
That is why we need link id to find the corresponding phy.

Fix the way to find the band_idx if WiFi7 AP is non-MLD mode.

mtk: mt76: mt7996: support handle link_id in ap_wireless vendor cmd

Add support handle link_id in ap_wireless vendor command. The link_id is
used to find the corresponding phy and its band_idx. The band_idx is the
critical information required by some mcu commands.

This commit also refactor some functions, changing the parameter from
phy to dev since phy is not required.

mtk: mt76: mt7996: return -EINVAL on not getting band_idx for specific
vendor commands

Some vendor commands need the band_idx, while others do not.
Returning -EINVAL when unsuccessfully getting band_idx for those do not
need a band_idx is unnecessary.

Signed-off-by: Howard Hsu <howard-yh.hsu@mediatek.com>
---
 mt7996/mac.c         |  10 ++++
 mt7996/mcu.c         |   7 +++
 mt7996/mcu.h         |   1 +
 mt7996/mt7996.h      |  22 ++++----
 mt7996/mtk_debugfs.c |   2 +-
 mt7996/mtk_mcu.c     | 116 ++++++++++++++++++++++++++++++++-----------
 mt7996/mtk_mcu.h     |   1 +
 mt7996/vendor.c      |  90 ++++++++++++++++++++++++++-------
 mt7996/vendor.h      |   9 ++--
 9 files changed, 197 insertions(+), 61 deletions(-)

diff --git a/mt7996/mac.c b/mt7996/mac.c
index abb5cb6e..0d403b02 100644
--- a/mt7996/mac.c
+++ b/mt7996/mac.c
@@ -2415,6 +2415,16 @@ void mt7996_mac_sta_rc_work(struct work_struct *work)
 		if (changed & IEEE80211_RC_SMPS_CHANGED)
 			mt7996_mcu_set_fixed_field(dev, mconf, link_sta, mlink, NULL,
 						   RATE_PARAM_MMPS_UPDATE);
+#ifdef CONFIG_MTK_VENDOR
+		if (changed & IEEE80211_RC_CODING_TYPE_CHANGED) {
+			struct sta_phy_uni phy = {
+				.ldpc = dev->coding_type,
+			};
+
+			mt7996_mcu_set_fixed_field(dev, mconf, link_sta, mlink, &phy,
+						   RATE_PARAM_FIXED_ENCODING);
+		}
+#endif
 
 		spin_lock_bh(&dev->mt76.sta_poll_lock);
 	}
diff --git a/mt7996/mcu.c b/mt7996/mcu.c
index f4f2ac21..9a832277 100644
--- a/mt7996/mcu.c
+++ b/mt7996/mcu.c
@@ -2683,6 +2683,7 @@ int mt7996_mcu_set_fixed_field(struct mt7996_dev *dev,
 	case RATE_PARAM_FIXED_MCS:
 	case RATE_PARAM_FIXED_GI:
 	case RATE_PARAM_FIXED_HE_LTF:
+	case RATE_PARAM_FIXED_ENCODING:
 		if (phy)
 			ra->phy = *phy;
 		break;
@@ -2908,6 +2909,12 @@ int mt7996_mcu_add_rate_ctrl(struct mt7996_dev *dev,
 	if (IS_ERR(skb))
 		return PTR_ERR(skb);
 
+#ifdef CONFIG_MTK_VENDOR
+	if (changed && dev->cert_mode == 2)
+		return mt7996_mcu_add_rate_ctrl_fixed(dev, conf, mconf,
+						      link_sta, mlink);
+#endif
+
 	/* firmware rc algorithm refers to sta_rec_he for HE control.
 	 * once dev->rc_work changes the settings driver should also
 	 * update sta_rec_he here.
diff --git a/mt7996/mcu.h b/mt7996/mcu.h
index 3aee186e..ebc3bd41 100644
--- a/mt7996/mcu.h
+++ b/mt7996/mcu.h
@@ -924,6 +924,7 @@ enum {
 	RATE_PARAM_FIXED_HE_LTF = 7,
 	RATE_PARAM_FIXED_MCS,
 	RATE_PARAM_FIXED_GI = 11,
+	RATE_PARAM_FIXED_ENCODING,
 	RATE_PARAM_AUTO = 20,
 #ifdef CONFIG_MTK_VENDOR
 	RATE_PARAM_FIXED_MIMO = 30,
diff --git a/mt7996/mt7996.h b/mt7996/mt7996.h
index e18ee744..94617e0c 100644
--- a/mt7996/mt7996.h
+++ b/mt7996/mt7996.h
@@ -534,6 +534,8 @@ struct csi_data {
 
 	struct list_head node;
 };
+
+int mt7996_set_coding_type(struct ieee80211_hw *hw, u8 coding_type, u8 link_id);
 #endif
 
 struct mt7996_rro_ba_session {
@@ -813,7 +815,8 @@ struct mt7996_dev {
 	const struct mt7996_dbg_reg_desc *dbg_reg;
 #endif
 #ifdef CONFIG_MTK_VENDOR
-	bool cert_mode;
+	u8 cert_mode;
+	u8 coding_type;
 #endif
 
 #if defined CONFIG_NL80211_TESTMODE || defined CONFIG_MTK_DEBUG
@@ -1296,8 +1299,8 @@ int mt7996_vendor_amnt_sta_remove(struct mt7996_phy *phy,
 				  struct ieee80211_sta *sta);
 void mt7996_set_wireless_amsdu(struct ieee80211_hw *hw, u8 en);
 void mt7996_mcu_set_mimo(struct mt7996_phy *phy);
-int mt7996_set_muru_cfg(struct mt7996_phy *phy, u8 action, u8 val);
-int mt7996_mcu_set_muru_cfg(struct mt7996_phy *phy, void *data);
+int mt7996_set_muru_cfg(struct mt7996_dev *dev, u8 action, u8 val);
+int mt7996_mcu_set_muru_cfg(struct mt7996_dev *dev, void *data);
 void mt7996_set_beacon_vif(void *data, u8 *mac, struct ieee80211_vif *vif);
 int mt7996_mcu_set_csi(struct mt7996_phy *phy, u8 mode,
 		       u8 cfg, u8 v1, u32 v2, u8 *mac_addr);
@@ -1325,14 +1328,15 @@ int mt7996_mcu_set_txbf_internal(struct mt7996_phy *phy, u8 action, int idx, boo
 void mt7996_mcu_rx_bf_event(struct mt7996_dev *dev, struct sk_buff *skb);
 int mt7996_mcu_set_muru_fixed_rate_enable(struct mt7996_dev *dev, u8 action, int val);
 int mt7996_mcu_set_muru_fixed_rate_parameter(struct mt7996_dev *dev, u8 action, void *para);
-int mt7996_mcu_set_txbf_snd_info(struct mt7996_phy *phy, void *para);
+int mt7996_mcu_set_txbf_snd_info(struct mt7996_dev *dev, void *para);
 int mt7996_mcu_set_muru_cmd(struct mt7996_dev *dev, u16 action, int val);
 int mt7996_mcu_muru_set_prot_frame_thr(struct mt7996_dev *dev, u32 val);
-int mt7996_mcu_set_bypass_smthint(struct mt7996_phy *phy, u8 val);
-int mt7996_mcu_set_rfeature_trig_type(struct mt7996_phy *phy, u8 enable, u8 trig_type);
-void mt7996_mcu_set_ppdu_tx_type(struct mt7996_phy *phy, u8 ppdu_type);
-void mt7996_mcu_set_nusers_ofdma(struct mt7996_phy *phy, u8 type, u8 ofdma_user_cnt);
-void mt7996_mcu_set_cert(struct mt7996_phy *phy, u8 type);
+int mt7996_mcu_set_bypass_smthint(struct mt7996_dev *dev, u8 band_idx, u8 val);
+int mt7996_mcu_set_rfeature_trig_type(struct mt7996_dev *dev, u8 band_idx,
+				      u8 enable, u8 trig_type);
+void mt7996_mcu_set_ppdu_tx_type(struct mt7996_dev *dev, u8 ppdu_type);
+void mt7996_mcu_set_nusers_ofdma(struct mt7996_dev *dev, u8 band_idx, u8 ofdma_user_cnt);
+void mt7996_mcu_set_cert(struct mt7996_dev *dev);
 void mt7996_tm_update_channel(struct mt7996_phy *phy);
 
 int mt7996_mcu_set_vow_drr_dbg(struct mt7996_dev *dev, u32 val);
diff --git a/mt7996/mtk_debugfs.c b/mt7996/mtk_debugfs.c
index f01242de..b6bdd68a 100644
--- a/mt7996/mtk_debugfs.c
+++ b/mt7996/mtk_debugfs.c
@@ -2936,7 +2936,7 @@ mt7996_bf_txsnd_info_set(struct file *file,
 	else
 		buf[count] = '\0';
 
-	ret = mt7996_mcu_set_txbf_snd_info(phy, buf);
+	ret = mt7996_mcu_set_txbf_snd_info(phy->dev, buf);
 
 	if (ret) return -EFAULT;
 
diff --git a/mt7996/mtk_mcu.c b/mt7996/mtk_mcu.c
index 82e3f721..22bf6d98 100644
--- a/mt7996/mtk_mcu.c
+++ b/mt7996/mtk_mcu.c
@@ -352,7 +352,7 @@ int mt7996_mcu_set_txbf_internal(struct mt7996_phy *phy, u8 action, int idx, boo
 	return mt76_mcu_skb_send_msg(&phy->dev->mt76, skb, MCU_WM_UNI_CMD(BF), false);
 }
 
-int mt7996_mcu_set_txbf_snd_info(struct mt7996_phy *phy, void *para)
+int mt7996_mcu_set_txbf_snd_info(struct mt7996_dev *dev, void *para)
 {
 	char *buf = (char *)para;
 	__le16 input[5] = {0};
@@ -365,7 +365,7 @@ int mt7996_mcu_set_txbf_snd_info(struct mt7996_phy *phy, void *para)
 
 	memset(&hdr, 0, sizeof(hdr));
 
-	skb = mt76_mcu_msg_alloc(&phy->dev->mt76, NULL, len);
+	skb = mt76_mcu_msg_alloc(&dev->mt76, NULL, len);
 	if (!skb)
 		return -ENOMEM;
 
@@ -428,7 +428,7 @@ int mt7996_mcu_set_txbf_snd_info(struct mt7996_phy *phy, void *para)
 		return -EINVAL;
 	}
 
-	return mt76_mcu_skb_send_msg(&phy->dev->mt76, skb, MCU_WM_UNI_CMD(BF), false);
+	return mt76_mcu_skb_send_msg(&dev->mt76, skb, MCU_WM_UNI_CMD(BF), false);
 }
 
 static inline void
@@ -1041,6 +1041,7 @@ error:
  * SET_TRIG_TYPE (0xC9)
  * SET_20M_DYN_ALGO (0xCA)
  * SET_CERT_MU_EDCA_OVERRIDE (0xCD)
+ * SET_TRIG_VARIANT (0xD5)
  */
 int mt7996_mcu_set_muru_cmd(struct mt7996_dev *dev, u16 action, int val)
 {
@@ -1081,11 +1082,10 @@ int mt7996_mcu_muru_set_prot_frame_thr(struct mt7996_dev *dev, u32 val)
 				 false);
 }
 
-int mt7996_mcu_set_bypass_smthint(struct mt7996_phy *phy, u8 val)
+int mt7996_mcu_set_bypass_smthint(struct mt7996_dev *dev, u8 band_idx, u8 val)
 {
 #define BF_PHY_SMTH_INT_BYPASS 0
 #define BYPASS_VAL 1
-	struct mt7996_dev *dev = phy->dev;
 	struct {
 		u8 _rsv[4];
 
@@ -1100,21 +1100,20 @@ int mt7996_mcu_set_bypass_smthint(struct mt7996_phy *phy, u8 val)
 		.tag = cpu_to_le16(BF_CFG_PHY),
 		.len = cpu_to_le16(sizeof(data) - 4),
 		.action = BF_PHY_SMTH_INT_BYPASS,
-		.band_idx = phy->mt76->band_idx,
+		.band_idx = band_idx,
 		.smthintbypass = val,
 	};
 
-	if (val != BYPASS_VAL)
+	if (val != BYPASS_VAL || !mt7996_band_valid(dev, band_idx))
 		return -EINVAL;
 
 	return mt76_mcu_send_msg(&dev->mt76, MCU_WM_UNI_CMD(BF), &data, sizeof(data),
 				 true);
 }
 
-int mt7996_mcu_set_bsrp_ctrl(struct mt7996_phy *phy, u16 interval,
+int mt7996_mcu_set_bsrp_ctrl(struct mt7996_dev *dev, u8 band_idx, u16 interval,
 			     u16 ru_alloc, u32 trig_type, u8 trig_flow, u8 ext_cmd)
 {
-	struct mt7996_dev *dev = phy->dev;
 	struct {
 		u8 _rsv[4];
 
@@ -1140,13 +1139,16 @@ int mt7996_mcu_set_bsrp_ctrl(struct mt7996_phy *phy, u16 interval,
 			       GENMASK(2, 0) : GENMASK(1, 0),
 	};
 
+	if (!mt7996_band_valid(dev, band_idx))
+		return -EINVAL;
+
 	return mt76_mcu_send_msg(&dev->mt76, MCU_WM_UNI_CMD(MURU), &req,
 				 sizeof(req), false);
 }
 
-int mt7996_mcu_set_rfeature_trig_type(struct mt7996_phy *phy, u8 enable, u8 trig_type)
+int mt7996_mcu_set_rfeature_trig_type(struct mt7996_dev *dev, u8 band_idx,
+				      u8 enable, u8 trig_type)
 {
-	struct mt7996_dev *dev = phy->dev;
 	int ret = 0;
 	char buf[] = "01:00:00:1B";
 
@@ -1158,22 +1160,21 @@ int mt7996_mcu_set_rfeature_trig_type(struct mt7996_phy *phy, u8 enable, u8 trig
 
 	switch (trig_type) {
 	case CAPI_BASIC:
-		return mt7996_mcu_set_bsrp_ctrl(phy, 5, 67, 0, 0, enable);
+		return mt7996_mcu_set_bsrp_ctrl(dev, band_idx, 5, 67, 0, 0, enable);
 	case CAPI_BRP:
-		return mt7996_mcu_set_txbf_snd_info(phy, buf);
+		return mt7996_mcu_set_txbf_snd_info(dev, buf);
 	case CAPI_MU_BAR:
 		return mt7996_mcu_set_muru_cmd(dev, UNI_CMD_MURU_SET_MUDL_ACK_POLICY,
 					       MU_DL_ACK_POLICY_MU_BAR);
 	case CAPI_BSRP:
-		return mt7996_mcu_set_bsrp_ctrl(phy, 5, 67, 4, 0, enable);
+		return mt7996_mcu_set_bsrp_ctrl(dev, band_idx, 5, 67, 4, 0, enable);
 	default:
 		return 0;
 	}
 }
 
-int mt7996_mcu_set_muru_cfg(struct mt7996_phy *phy, void *data)
+int mt7996_mcu_set_muru_cfg(struct mt7996_dev *dev, void *data)
 {
-	struct mt7996_dev *dev = phy->dev;
 	struct mt7996_muru *muru;
 	struct {
 		u8 _rsv[4];
@@ -1199,7 +1200,7 @@ int mt7996_mcu_set_muru_cfg(struct mt7996_phy *phy, void *data)
 				 sizeof(req), false);
 }
 
-int mt7996_set_muru_cfg(struct mt7996_phy *phy, u8 action, u8 val)
+int mt7996_set_muru_cfg(struct mt7996_dev *dev, u8 action, u8 val)
 {
 	struct mt7996_muru *muru;
 	struct mt7996_muru_dl *dl;
@@ -1219,7 +1220,7 @@ int mt7996_set_muru_cfg(struct mt7996_phy *phy, u8 action, u8 val)
 		comm->sch_type = MURU_OFDMA_SCH_TYPE_DL;
 		muru->cfg_comm = cpu_to_le32(MURU_COMM_SET);
 		muru->cfg_dl = cpu_to_le32(MURU_FIXED_DL_TOTAL_USER_CNT);
-		ret = mt7996_mcu_set_muru_cfg(phy, muru);
+		ret = mt7996_mcu_set_muru_cfg(dev, muru);
 		break;
 	case MU_CTRL_UL_USER_CNT:
 		ul->user_num = val;
@@ -1227,7 +1228,7 @@ int mt7996_set_muru_cfg(struct mt7996_phy *phy, u8 action, u8 val)
 		comm->sch_type = MURU_OFDMA_SCH_TYPE_UL;
 		muru->cfg_comm = cpu_to_le32(MURU_COMM_SET);
 		muru->cfg_ul = cpu_to_le32(MURU_FIXED_UL_TOTAL_USER_CNT);
-		ret = mt7996_mcu_set_muru_cfg(phy, muru);
+		ret = mt7996_mcu_set_muru_cfg(dev, muru);
 		break;
 	default:
 		break;
@@ -1237,16 +1238,15 @@ int mt7996_set_muru_cfg(struct mt7996_phy *phy, u8 action, u8 val)
 	return ret;
 }
 
-void mt7996_mcu_set_ppdu_tx_type(struct mt7996_phy *phy, u8 ppdu_type)
+void mt7996_mcu_set_ppdu_tx_type(struct mt7996_dev *dev, u8 ppdu_type)
 {
-	struct mt7996_dev *dev = phy->dev;
 	int enable_su;
 
 	switch (ppdu_type) {
 	case CAPI_SU:
 		enable_su = 1;
 		mt7996_mcu_set_muru_cmd(dev, UNI_CMD_MURU_SUTX_CTRL, enable_su);
-		mt7996_set_muru_cfg(phy, MU_CTRL_DL_USER_CNT, 0);
+		mt7996_set_muru_cfg(dev, MU_CTRL_DL_USER_CNT, 0);
 		break;
 	case CAPI_MU:
 		enable_su = 0;
@@ -1257,16 +1257,35 @@ void mt7996_mcu_set_ppdu_tx_type(struct mt7996_phy *phy, u8 ppdu_type)
 	}
 }
 
-void mt7996_mcu_set_nusers_ofdma(struct mt7996_phy *phy, u8 type, u8 user_cnt)
+void mt7996_mcu_set_nusers_ofdma(struct mt7996_dev *dev, u8 band_idx, u8 user_cnt)
 {
-	struct mt7996_dev *dev = phy->dev;
+	struct mt76_phy *mphy;
+	struct mt7996_phy *phy;
 	int enable_su = 0;
+	u8 type;
+
+	if (!mt7996_band_valid(dev, band_idx)) {
+		dev_err(dev->mt76.dev, "Invalid band_idx\n");
+		return;
+	}
+
+	mphy = dev->mt76.phys[band_idx];
+	if (!mphy)
+		return;
+
+	phy = (struct mt7996_phy *)mphy->priv;
 
 	mt7996_mcu_set_muru_cmd(dev, UNI_CMD_MURU_SUTX_CTRL, enable_su);
-	mt7996_mcu_set_muru_cmd(dev, UNI_CMD_MURU_SET_MUDL_ACK_POLICY, MU_DL_ACK_POLICY_SU_BAR);
+	mt7996_mcu_set_muru_cmd(dev, UNI_CMD_MURU_SET_MUDL_ACK_POLICY,
+				MU_DL_ACK_POLICY_SU_BAR);
 	mt7996_mcu_muru_set_prot_frame_thr(dev, 9999);
 
-	mt7996_set_muru_cfg(phy, type, user_cnt);
+	if (phy->muru_onoff & OFDMA_UL)
+		type = MU_CTRL_UL_USER_CNT;
+	else
+		type = MU_CTRL_DL_USER_CNT;
+
+	mt7996_set_muru_cfg(dev, type, user_cnt);
 }
 
 void mt7996_mcu_set_mimo(struct mt7996_phy *phy)
@@ -1297,9 +1316,8 @@ void mt7996_mcu_set_mimo(struct mt7996_phy *phy)
 	mt7996_mcu_set_muru_cmd(dev, UNI_CMD_MURU_SET_FORCE_MU, force_mu);
 }
 
-void mt7996_mcu_set_cert(struct mt7996_phy *phy, u8 type)
+void mt7996_mcu_set_cert(struct mt7996_dev *dev)
 {
-	struct mt7996_dev *dev = phy->dev;
 	struct {
 		u8 _rsv[4];
 
@@ -1310,7 +1328,7 @@ void mt7996_mcu_set_cert(struct mt7996_phy *phy, u8 type)
 	} __packed req = {
 		.tag = cpu_to_le16(UNI_CMD_CERT_CFG),
 		.len = cpu_to_le16(sizeof(req) - 4),
-		.action = type, /* 1: CAPI Enable */
+		.action = !!dev->cert_mode, /* 1: CAPI Enable */
 	};
 
 	mt76_mcu_send_msg(&dev->mt76, MCU_WM_UNI_CMD(WSYS_CONFIG), &req,
@@ -1371,3 +1389,43 @@ int mt7996_mcu_mlo_agc(struct mt7996_dev *dev, const void *data, int len)
 	                        len, true);
 }
 #endif
+
+#ifdef CONFIG_MTK_VENDOR
+
+static void mt7996_sta_coding_type_work(void *data, struct ieee80211_sta *sta)
+{
+	struct mt7996_sta *msta = (struct mt7996_sta *)sta->drv_priv;
+	struct mt7996_link_sta *mlink;
+	struct mt7996_dev *dev = msta->vif->dev;
+	u8 *link_id = data;
+
+	rcu_read_lock();
+	mlink = rcu_dereference(msta->link[*link_id]);
+
+	if (!mlink)
+		goto unlock;
+
+	spin_lock_bh(&dev->mt76.sta_poll_lock);
+	mlink->changed |= IEEE80211_RC_CODING_TYPE_CHANGED;
+	if (list_empty(&mlink->rc_list))
+		list_add_tail(&mlink->rc_list, &dev->sta_rc_list);
+
+	spin_unlock_bh(&dev->mt76.sta_poll_lock);
+
+unlock:
+	rcu_read_unlock();
+}
+
+int mt7996_set_coding_type(struct ieee80211_hw *hw, u8 coding_type, u8 link_id)
+{
+	struct mt7996_dev *dev = mt7996_hw_dev(hw);
+
+	dev->coding_type = coding_type;
+
+	/* Not support set all stations under different MLD interface */
+	ieee80211_iterate_stations_atomic(hw, mt7996_sta_coding_type_work, &link_id);
+	ieee80211_queue_work(hw, &dev->rc_work);
+
+	return 0;
+}
+#endif
diff --git a/mt7996/mtk_mcu.h b/mt7996/mtk_mcu.h
index 2cffc893..8ba261a7 100644
--- a/mt7996/mtk_mcu.h
+++ b/mt7996/mtk_mcu.h
@@ -133,6 +133,7 @@ enum {
 	UNI_CMD_MURU_SET_20M_DYN_ALGO = 0xCA,
 	UNI_CMD_MURU_PROT_FRAME_THR = 0xCC,
 	UNI_CMD_MURU_SET_CERT_MU_EDCA_OVERRIDE,
+	UNI_CMD_MURU_SET_TRIG_VARIANT = 0xD5,
 };
 
 struct bf_pfmu_tag {
diff --git a/mt7996/vendor.c b/mt7996/vendor.c
index 585c4e28..158f6855 100644
--- a/mt7996/vendor.c
+++ b/mt7996/vendor.c
@@ -31,6 +31,7 @@ wireless_ctrl_policy[NUM_MTK_VENDOR_ATTRS_WIRELESS_CTRL] = {
 	[MTK_VENDOR_ATTR_WIRELESS_CTRL_NUSERS_OFDMA] = {.type = NLA_U8 },
 	[MTK_VENDOR_ATTR_WIRELESS_CTRL_MIMO] = {.type = NLA_U8 },
 	[MTK_VENDOR_ATTR_WIRELESS_CTRL_BA_BUFFER_SIZE] = {.type = NLA_U16 },
+	[MTK_VENDOR_ATTR_WIRELESS_CTRL_LINK_ID] = {.type = NLA_U8 },
 };
 
 static const struct nla_policy
@@ -107,6 +108,9 @@ rfeature_ctrl_policy[NUM_MTK_VENDOR_ATTRS_RFEATURE_CTRL] = {
 	[MTK_VENDOR_ATTR_RFEATURE_CTRL_TRIG_TYPE] = { .type = NLA_U8 },
 	[MTK_VENDOR_ATTR_RFEATURE_CTRL_ACK_PLCY] = { .type = NLA_U8 },
 	[MTK_VENDOR_ATTR_RFEATURE_CTRL_TRIG_TXBF] = { .type = NLA_U8 },
+	[MTK_VENDOR_ATTR_RFEATURE_CTRL_TRIG_VARIANT_TYPE] = { .type = NLA_U8 },
+	[MTK_VENDOR_ATTR_RFEATURE_CTRL_CODING_TYPE] = { .type = NLA_U8 },
+	[MTK_VENDOR_ATTR_RFEATURE_CTRL_LINK_ID] = { .type = NLA_U8 },
 };
 
 static const struct nla_policy
@@ -179,7 +183,7 @@ static int mt7996_vendor_mu_ctrl(struct wiphy *wiphy,
 		nla_memcpy(muru, tb[MTK_VENDOR_ATTR_MU_CTRL_STRUCT],
 			   sizeof(struct mt7996_muru));
 
-		err = mt7996_mcu_set_muru_cfg(phy, muru);
+		err = mt7996_mcu_set_muru_cfg(phy->dev, muru);
 		kfree(muru);
 	}
 
@@ -864,16 +868,33 @@ static int mt7996_vendor_rfeature_ctrl(struct wiphy *wiphy,
 	struct ieee80211_hw *hw = wiphy_to_ieee80211_hw(wiphy);
 	struct mt7996_phy *phy = mt7996_hw_phy(hw);
 	struct mt7996_dev *dev = phy->dev;
+	struct ieee80211_vif *vif = wdev_to_ieee80211_vif(wdev);
+	struct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;
+	struct mt7996_bss_conf *mconf;
 	struct nlattr *tb[NUM_MTK_VENDOR_ATTRS_RFEATURE_CTRL];
 	int err;
-	u32 val;
+	u8 band_idx, link_id = 0;
 
 	err = nla_parse(tb, MTK_VENDOR_ATTR_RFEATURE_CTRL_MAX, data, data_len,
 			rfeature_ctrl_policy, NULL);
 	if (err)
 		return err;
 
-	val = CAPI_RFEATURE_CHANGED;
+	if (ieee80211_vif_is_mld(vif) && tb[MTK_VENDOR_ATTR_RFEATURE_CTRL_LINK_ID]) {
+		link_id = nla_get_u8(tb[MTK_VENDOR_ATTR_RFEATURE_CTRL_LINK_ID]);
+		if (link_id >= IEEE80211_LINK_UNSPECIFIED)
+			return -EINVAL;
+	}
+
+	rcu_read_lock();
+	mconf = rcu_dereference(mvif->link[link_id]);
+	if (!mconf || !mconf->phy) {
+		rcu_read_unlock();
+		return -EINVAL;
+	}
+
+	band_idx = mconf->phy->mt76->band_idx;
+	rcu_read_unlock();
 
 	if (tb[MTK_VENDOR_ATTR_RFEATURE_CTRL_TRIG_TYPE_CFG]) {
 		u8 enable, trig_type;
@@ -893,7 +914,7 @@ static int mt7996_vendor_rfeature_ctrl(struct wiphy *wiphy,
 			};
 		}
 
-		err = mt7996_mcu_set_rfeature_trig_type(phy, enable, trig_type);
+		err = mt7996_mcu_set_rfeature_trig_type(dev, band_idx, enable, trig_type);
 		if (err)
 			return err;
 	} else if (tb[MTK_VENDOR_ATTR_RFEATURE_CTRL_ACK_PLCY]) {
@@ -907,6 +928,19 @@ static int mt7996_vendor_rfeature_ctrl(struct wiphy *wiphy,
 		default:
 			return 0;
 		}
+	} else if (tb[MTK_VENDOR_ATTR_RFEATURE_CTRL_TRIG_VARIANT_TYPE]) {
+		u8 trig_var;
+
+		trig_var = nla_get_u8(tb[MTK_VENDOR_ATTR_RFEATURE_CTRL_TRIG_VARIANT_TYPE]);
+
+		return mt7996_mcu_set_muru_cmd(dev, UNI_CMD_MURU_SET_TRIG_VARIANT,
+					       trig_var);
+	} else if (tb[MTK_VENDOR_ATTR_RFEATURE_CTRL_CODING_TYPE]) {
+		u8 coding_type;
+
+		coding_type = nla_get_u8(tb[MTK_VENDOR_ATTR_RFEATURE_CTRL_CODING_TYPE]);
+
+		return mt7996_set_coding_type(hw, coding_type, link_id);
 	}
 
 	return 0;
@@ -920,23 +954,47 @@ static int mt7996_vendor_wireless_ctrl(struct wiphy *wiphy,
 	struct ieee80211_hw *hw = wiphy_to_ieee80211_hw(wiphy);
 	struct mt7996_phy *phy = mt7996_hw_phy(hw);
 	struct mt7996_dev *dev = phy->dev;
+	struct ieee80211_vif *vif = wdev_to_ieee80211_vif(wdev);
+	struct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;
+	struct mt7996_bss_conf *mconf;
 	struct nlattr *tb[NUM_MTK_VENDOR_ATTRS_WIRELESS_CTRL];
 	int err;
-	u8 val8;
+	u8 val8, band_idx, link_id = 0;
 	u16 val16;
 	u32 val32;
+	bool band_idx_get = false;
 
 	err = nla_parse(tb, MTK_VENDOR_ATTR_WIRELESS_CTRL_MAX, data, data_len,
 			wireless_ctrl_policy, NULL);
 	if (err)
 		return err;
 
-	val32 = CAPI_WIRELESS_CHANGED;
+	if (ieee80211_vif_is_mld(vif) && tb[MTK_VENDOR_ATTR_WIRELESS_CTRL_LINK_ID]) {
+		link_id = nla_get_u8(tb[MTK_VENDOR_ATTR_WIRELESS_CTRL_LINK_ID]);
+
+		if (link_id >= IEEE80211_LINK_UNSPECIFIED)
+			return -EINVAL;
+	}
+
+	rcu_read_lock();
+	mconf = rcu_dereference(mvif->link[link_id]);
+	if (mconf && mconf->phy) {
+		band_idx = mconf->phy->mt76->band_idx;
+		band_idx_get = true;
+	}
+	rcu_read_unlock();
+
+	if (!band_idx_get && (tb[MTK_VENDOR_ATTR_WIRELESS_CTRL_OFDMA] ||
+	    tb[MTK_VENDOR_ATTR_WIRELESS_CTRL_NUSERS_OFDMA] ||
+	    tb[MTK_VENDOR_ATTR_WIRELESS_CTRL_MIMO] ||
+	    tb[MTK_VENDOR_ATTR_WIRELESS_CTRL_CERT]))
+		return -EINVAL;
 
 	if (tb[MTK_VENDOR_ATTR_WIRELESS_CTRL_OFDMA]) {
 		val8 = nla_get_u8(tb[MTK_VENDOR_ATTR_WIRELESS_CTRL_OFDMA]);
-		val32 |= FIELD_PREP(RATE_CFG_MODE, RATE_PARAM_FIXED_OFDMA) |
-			 FIELD_PREP(RATE_CFG_VAL, val8);
+		val32 = FIELD_PREP(RATE_CFG_MODE, RATE_PARAM_FIXED_OFDMA) |
+			FIELD_PREP(RATE_CFG_VAL, val8) |
+			FIELD_PREP(RATE_CFG_BAND_IDX, band_idx);
 		ieee80211_iterate_active_interfaces_atomic(hw, IEEE80211_IFACE_ITER_RESUME_ALL,
 			mt7996_set_wireless_vif, &val32);
 		if (val8 == 3) /* DL20and80 */
@@ -947,24 +1005,22 @@ static int mt7996_vendor_wireless_ctrl(struct wiphy *wiphy,
 		hw->max_rx_aggregation_subframes = val16;
 	} else if (tb[MTK_VENDOR_ATTR_WIRELESS_CTRL_PPDU_TX_TYPE]) {
 		val8 = nla_get_u8(tb[MTK_VENDOR_ATTR_WIRELESS_CTRL_PPDU_TX_TYPE]);
-		mt7996_mcu_set_ppdu_tx_type(phy, val8);
+		mt7996_mcu_set_ppdu_tx_type(dev, val8);
 	} else if (tb[MTK_VENDOR_ATTR_WIRELESS_CTRL_NUSERS_OFDMA]) {
 		val8 = nla_get_u8(tb[MTK_VENDOR_ATTR_WIRELESS_CTRL_NUSERS_OFDMA]);
-		if (phy->muru_onoff & OFDMA_UL)
-			mt7996_mcu_set_nusers_ofdma(phy, MU_CTRL_UL_USER_CNT, val8);
-		else
-			mt7996_mcu_set_nusers_ofdma(phy, MU_CTRL_DL_USER_CNT, val8);
+		mt7996_mcu_set_nusers_ofdma(dev, band_idx, val8);
 	} else if (tb[MTK_VENDOR_ATTR_WIRELESS_CTRL_MIMO]) {
 		val8 = nla_get_u8(tb[MTK_VENDOR_ATTR_WIRELESS_CTRL_MIMO]);
-		val32 |= FIELD_PREP(RATE_CFG_MODE, RATE_PARAM_FIXED_MIMO) |
-			 FIELD_PREP(RATE_CFG_VAL, val8);
+		val32 = FIELD_PREP(RATE_CFG_MODE, RATE_PARAM_FIXED_MIMO) |
+			FIELD_PREP(RATE_CFG_VAL, val8) |
+			FIELD_PREP(RATE_CFG_BAND_IDX, band_idx);
 		ieee80211_iterate_active_interfaces_atomic(hw, IEEE80211_IFACE_ITER_RESUME_ALL,
 			mt7996_set_wireless_vif, &val32);
 	} else if (tb[MTK_VENDOR_ATTR_WIRELESS_CTRL_CERT]) {
 		val8 = nla_get_u8(tb[MTK_VENDOR_ATTR_WIRELESS_CTRL_CERT]);
 		dev->cert_mode = val8;
-		mt7996_mcu_set_cert(phy, val8);
-		mt7996_mcu_set_bypass_smthint(phy, val8);
+		mt7996_mcu_set_cert(dev);
+		mt7996_mcu_set_bypass_smthint(dev, band_idx, val8);
 	} else if (tb[MTK_VENDOR_ATTR_WIRELESS_CTRL_AMSDU]) {
 		val8 = nla_get_u8(tb[MTK_VENDOR_ATTR_WIRELESS_CTRL_AMSDU]);
 		mt7996_set_wireless_amsdu(hw, val8);
diff --git a/mt7996/vendor.h b/mt7996/vendor.h
index f6fcb623..714f0b3e 100644
--- a/mt7996/vendor.h
+++ b/mt7996/vendor.h
@@ -78,11 +78,6 @@ enum mtk_vendor_attr_mu_ctrl {
 		NUM_MTK_VENDOR_ATTRS_MU_CTRL - 1
 };
 
-enum mtk_capi_control_changed {
-	CAPI_RFEATURE_CHANGED = BIT(16),
-	CAPI_WIRELESS_CHANGED = BIT(17),
-};
-
 enum mtk_vendor_attr_rfeature_ctrl {
 	MTK_VENDOR_ATTR_RFEATURE_CTRL_UNSPEC,
 
@@ -93,6 +88,9 @@ enum mtk_vendor_attr_rfeature_ctrl {
 	MTK_VENDOR_ATTR_RFEATURE_CTRL_TRIG_TYPE,
 	MTK_VENDOR_ATTR_RFEATURE_CTRL_ACK_PLCY,
 	MTK_VENDOR_ATTR_RFEATURE_CTRL_TRIG_TXBF,
+	MTK_VENDOR_ATTR_RFEATURE_CTRL_TRIG_VARIANT_TYPE,
+	MTK_VENDOR_ATTR_RFEATURE_CTRL_CODING_TYPE,
+	MTK_VENDOR_ATTR_RFEATURE_CTRL_LINK_ID,
 
 	/* keep last */
 	NUM_MTK_VENDOR_ATTRS_RFEATURE_CTRL,
@@ -114,6 +112,7 @@ enum mtk_vendor_attr_wireless_ctrl {
 	MTK_VENDOR_ATTR_WIRELESS_CTRL_CERT = 9,
 	MTK_VENDOR_ATTR_WIRELESS_CTRL_RTS_SIGTA,
 	MTK_VENDOR_ATTR_WIRELESS_CTRL_MU_EDCA, /* reserve */
+	MTK_VENDOR_ATTR_WIRELESS_CTRL_LINK_ID,
 
 	/* keep last */
 	NUM_MTK_VENDOR_ATTRS_WIRELESS_CTRL,
-- 
2.45.2

