From 20e4f8f5363c5cdb30cc3ac693654669c0d6c7b7 Mon Sep 17 00:00:00 2001
From: Muna Sinada <muna.sinada@oss.qualcomm.com>
Date: Tue, 25 Mar 2025 14:31:24 -0700
Subject: [PATCH 011/115] Revert: wifi: mac80211: Create separate links for
 VLAN interfaces

Currently, MLD links for an AP_VLAN interface type is not fully
supported.

Add allocation of separate links for each VLAN interface and copy
chanctx and chandef of AP bss to VLAN where necessary. Separate
links are created because for Dynamic VLAN each link will have its own
default_multicast_key.

Signed-off-by: Muna Sinada <muna.sinada@oss.qualcomm.com>
Link: https://patch.msgid.link/20250325213125.1509362-3-muna.sinada@oss.qualcomm.com
Signed-off-by: Johannes Berg <johannes.berg@intel.com>
---
 net/mac80211/chan.c        |  3 --
 net/mac80211/ieee80211_i.h |  3 --
 net/mac80211/iface.c       | 12 +-----
 net/mac80211/link.c        | 81 --------------------------------------
 4 files changed, 1 insertion(+), 98 deletions(-)

diff --git a/net/mac80211/chan.c b/net/mac80211/chan.c
index c9cea0e7..d9e35fc5 100644
--- a/net/mac80211/chan.c
+++ b/net/mac80211/chan.c
@@ -2156,9 +2156,6 @@ void ieee80211_link_release_channel(struct ieee80211_link_data *link)
 {
 	struct ieee80211_sub_if_data *sdata = link->sdata;
 
-	if (sdata->vif.type == NL80211_IFTYPE_AP_VLAN)
-		return;
-
 	lockdep_assert_wiphy(sdata->local->hw.wiphy);
 
 	if (rcu_access_pointer(link->conf->chanctx_conf))
diff --git a/net/mac80211/ieee80211_i.h b/net/mac80211/ieee80211_i.h
index 9de9371a..b6f2afb1 100644
--- a/net/mac80211/ieee80211_i.h
+++ b/net/mac80211/ieee80211_i.h
@@ -2134,9 +2134,6 @@ static inline void ieee80211_vif_clear_links(struct ieee80211_sub_if_data *sdata
 	ieee80211_vif_set_links(sdata, 0, 0);
 }
 
-void ieee80211_apvlan_link_setup(struct ieee80211_sub_if_data *sdata);
-void ieee80211_apvlan_link_clear(struct ieee80211_sub_if_data *sdata);
-
 /* tx handling */
 void ieee80211_clear_tx_pending(struct ieee80211_local *local);
 void ieee80211_tx_pending(struct tasklet_struct *t);
diff --git a/net/mac80211/iface.c b/net/mac80211/iface.c
index 83f2d3ea..0ed04d06 100644
--- a/net/mac80211/iface.c
+++ b/net/mac80211/iface.c
@@ -485,9 +485,6 @@ static void ieee80211_do_stop(struct ieee80211_sub_if_data *sdata, bool going_do
 	case NL80211_IFTYPE_MONITOR:
 		list_del_rcu(&sdata->u.mntr.list);
 		break;
-	case NL80211_IFTYPE_AP_VLAN:
-		ieee80211_apvlan_link_clear(sdata);
-		break;
 	default:
 		break;
 	}
@@ -1323,8 +1320,6 @@ int ieee80211_do_open(struct wireless_dev *wdev, bool coming_up)
 		sdata->crypto_tx_tailroom_needed_cnt +=
 			master->crypto_tx_tailroom_needed_cnt;
 
-		ieee80211_apvlan_link_setup(sdata);
-
 		break;
 		}
 	case NL80211_IFTYPE_AP:
@@ -1381,12 +1376,7 @@ int ieee80211_do_open(struct wireless_dev *wdev, bool coming_up)
 	case NL80211_IFTYPE_AP_VLAN:
 		/* no need to tell driver, but set carrier and chanctx */
 		if (sdata->bss->active) {
-			struct ieee80211_link_data *link;
-
-			for_each_link_data(sdata, link) {
-				ieee80211_link_vlan_copy_chanctx(link);
-			}
-
+			ieee80211_link_vlan_copy_chanctx(&sdata->deflink);
 			netif_carrier_on(dev);
 			ieee80211_set_vif_encap_ops(sdata);
 		} else {
diff --git a/net/mac80211/link.c b/net/mac80211/link.c
index d71eabe5..2d491d04 100644
--- a/net/mac80211/link.c
+++ b/net/mac80211/link.c
@@ -12,71 +12,6 @@
 #include "key.h"
 #include "debugfs_netdev.h"
 
-static void ieee80211_update_apvlan_links(struct ieee80211_sub_if_data *sdata)
-{
-	struct ieee80211_sub_if_data *vlan;
-	struct ieee80211_link_data *link;
-	u16 ap_bss_links = sdata->vif.valid_links;
-	u16 new_links, vlan_links;
-	unsigned long add;
-
-	list_for_each_entry(vlan, &sdata->u.ap.vlans, u.vlan.list) {
-		int link_id;
-
-		if (!vlan)
-			continue;
-
-		/* No support for 4addr with MLO yet */
-		if (vlan->wdev.use_4addr)
-			return;
-
-		vlan_links = vlan->vif.valid_links;
-
-		new_links = ap_bss_links;
-
-		add = new_links & ~vlan_links;
-		if (!add)
-			continue;
-
-		ieee80211_vif_set_links(vlan, add, 0);
-
-		for_each_set_bit(link_id, &add, IEEE80211_MLD_MAX_NUM_LINKS) {
-			link = sdata_dereference(vlan->link[link_id], vlan);
-			ieee80211_link_vlan_copy_chanctx(link);
-		}
-	}
-}
-
-void ieee80211_apvlan_link_setup(struct ieee80211_sub_if_data *sdata)
-{
-	struct ieee80211_sub_if_data *ap_bss = container_of(sdata->bss,
-					    struct ieee80211_sub_if_data, u.ap);
-	u16 new_links = ap_bss->vif.valid_links;
-	unsigned long add;
-	int link_id;
-
-	if (!ap_bss->vif.valid_links)
-		return;
-
-	add = new_links;
-	for_each_set_bit(link_id, &add, IEEE80211_MLD_MAX_NUM_LINKS) {
-		sdata->wdev.valid_links |= BIT(link_id);
-		ether_addr_copy(sdata->wdev.links[link_id].addr,
-				ap_bss->wdev.links[link_id].addr);
-	}
-
-	ieee80211_vif_set_links(sdata, new_links, 0);
-}
-
-void ieee80211_apvlan_link_clear(struct ieee80211_sub_if_data *sdata)
-{
-	if (!sdata->wdev.valid_links)
-		return;
-
-	sdata->wdev.valid_links = 0;
-	ieee80211_vif_clear_links(sdata);
-}
-
 void ieee80211_link_setup(struct ieee80211_link_data *link)
 {
 	if (link->sdata->vif.type == NL80211_IFTYPE_STATION)
@@ -93,17 +28,6 @@ void ieee80211_link_init(struct ieee80211_sub_if_data *sdata,
 	if (link_id < 0)
 		link_id = 0;
 
-	if (sdata->vif.type == NL80211_IFTYPE_AP_VLAN) {
-		struct ieee80211_sub_if_data *ap_bss;
-		struct ieee80211_bss_conf *ap_bss_conf;
-
-		ap_bss = container_of(sdata->bss,
-				      struct ieee80211_sub_if_data, u.ap);
-		ap_bss_conf = sdata_dereference(ap_bss->vif.link_conf[link_id],
-						ap_bss);
-		memcpy(link_conf, ap_bss_conf, sizeof(*link_conf));
-	}
-
 	link->sdata = sdata;
 	link->link_id = link_id;
 	link->conf = link_conf;
@@ -127,7 +51,6 @@ void ieee80211_link_init(struct ieee80211_sub_if_data *sdata,
 	if (!deflink) {
 		switch (sdata->vif.type) {
 		case NL80211_IFTYPE_AP:
-		case NL80211_IFTYPE_AP_VLAN:
 			ether_addr_copy(link_conf->addr,
 					sdata->wdev.links[link_id].addr);
 			link_conf->bssid = link_conf->addr;
@@ -254,7 +177,6 @@ static void ieee80211_set_vif_links_bitmaps(struct ieee80211_sub_if_data *sdata,
 
 	switch (sdata->vif.type) {
 	case NL80211_IFTYPE_AP:
-	case NL80211_IFTYPE_AP_VLAN:
 		/* in an AP all links are always active */
 		sdata->vif.active_links = valid_links;
 
@@ -363,9 +285,6 @@ static int ieee80211_vif_update_links(struct ieee80211_sub_if_data *sdata,
 						   old);
 		if (!new_links)
 			ieee80211_debugfs_recreate_netdev(sdata, false);
-
-		if (sdata->vif.type == NL80211_IFTYPE_AP)
-			ieee80211_update_apvlan_links(sdata);
 	}
 
 	/*
-- 
2.45.2

