From 14ec126e0503757d9b9eeadb92549faa8fed2834 Mon Sep 17 00:00:00 2001
From: MeiChia Chiu <MeiChia.Chiu@mediatek.com>
Date: Thu, 9 May 2024 15:41:18 +0800
Subject: [PATCH 083/149] mtk: hostapd: add support for emlsr

1. Processing the EML capability IE in the association request,
and sending the value of EML field to the kernel.

2. Processing the EML Operating Mode Notification frame,
and sending the EML Operating Mode Notification frame if eml_resp is
true.

Command Usage:
eml_resp -
hostapd_cli -i <interface> eml_resp <enable>

Processing the EML capability IE in the association request,
and sending the value of EML field to the kernel.

The original flow send the mcu command to the firmware using the WCID of
the primary link. Therefore, a  is passed in the hostapd layer
to ensure that the EML OMN is processed and sent to the firmware using
the WCID of the receiving link.

Add a check for the station's EML capabilities.
If the station does not support EMLSR,
do not process the EML OMN frame sent by the station.

Signed-off-by: MeiChia Chiu <MeiChia.Chiu@mediatek.com>
---
 hostapd/config_file.c             |   4 +
 hostapd/ctrl_iface.c              |  36 ++++++++
 hostapd/hostapd.conf              |  10 +++
 hostapd/hostapd_cli.c             |   8 ++
 src/ap/ap_config.h                |   2 +
 src/ap/ap_drv_ops.c               |  20 ++++-
 src/ap/ap_drv_ops.h               |   4 +-
 src/ap/apup.c                     |   4 +-
 src/ap/ieee802_11.c               |   8 +-
 src/ap/ieee802_11.h               |   4 +-
 src/ap/ieee802_11_eht.c           | 141 ++++++++++++++++++++++++++++--
 src/ap/sta_info.c                 |   2 +-
 src/common/ieee802_11_defs.h      |  34 +++++++
 src/common/mtk_vendor.h           |  15 ++++
 src/drivers/driver.h              |  12 +++
 src/drivers/driver_nl80211.c      |  53 +++++++++++
 src/drivers/driver_nl80211.h      |   1 +
 src/drivers/driver_nl80211_capa.c |   3 +
 18 files changed, 348 insertions(+), 13 deletions(-)

diff --git a/hostapd/config_file.c b/hostapd/config_file.c
index 206055b75..38273a4f2 100644
--- a/hostapd/config_file.c
+++ b/hostapd/config_file.c
@@ -5477,6 +5477,10 @@ static int hostapd_config_fill(struct hostapd_config *conf,
 		}
 	} else if (os_strcmp(buf, "eht_bw320_offset") == 0) {
 		conf->eht_bw320_offset = atoi(pos);
+	} else if (os_strcmp(buf, "eml_disable") == 0) {
+		conf->eml_disable = atoi(pos);
+	} else if (os_strcmp(buf, "eml_resp") == 0) {
+		conf->eml_resp = atoi(pos);
 #ifdef CONFIG_TESTING_OPTIONS
 	} else if (os_strcmp(buf, "eht_oper_puncturing_override") == 0) {
 		if (get_u16(pos, line, &bss->eht_oper_puncturing_override))
diff --git a/hostapd/ctrl_iface.c b/hostapd/ctrl_iface.c
index 0abb7a8b3..fd5d41da2 100644
--- a/hostapd/ctrl_iface.c
+++ b/hostapd/ctrl_iface.c
@@ -5157,6 +5157,40 @@ hostapd_ctrl_iface_disable_beacon(struct hostapd_data *hapd, char *value,
 
 }
 
+static int
+hostapd_ctrl_iface_set_eml_resp(struct hostapd_data *hapd, char *value,
+				char *buf, size_t buflen)
+{
+	struct hostapd_data *link;
+	int cnt = 0;
+	u16 *val;
+
+	if (!hostapd_is_mld_ap(hapd))
+		return -1;
+
+	cnt = hostapd_parse_argument_helper(value, &val);
+	if (cnt == -1)
+		goto fail;
+	if (cnt != 1 || val[0] < 0)
+		goto para_fail;
+
+	for_each_mld_link(link, hapd) {
+		link->iconf->eml_resp = val[0];
+		wpa_printf(MSG_ERROR, "Link:%d, Response EML:%d\n",
+			   link->iconf->band_idx, link->iconf->eml_resp);
+	}
+
+	os_free(val);
+
+	return os_snprintf(buf, buflen, "OK\n");
+
+para_fail:
+	os_free(val);
+	wpa_printf(MSG_ERROR, "Input number or value is incorrect\n");
+fail:
+	return os_snprintf(buf, buflen, "FAIL\n");
+}
+
 static int
 hostapd_ctrl_iface_set_csi(struct hostapd_data *hapd, char *cmd,
 					char *buf, size_t buflen)
@@ -6087,6 +6121,8 @@ static int hostapd_ctrl_iface_receive_process(struct hostapd_data *hapd,
 	} else if (os_strncmp(buf, "WMM", 3) == 0) {
 		reply_len = hostapd_ctrl_iface_wmm(hapd, buf + 4,
 						   reply, reply_size);
+	} else if (os_strncmp(buf, "EML_RESP ", 9) == 0) {
+		reply_len = hostapd_ctrl_iface_set_eml_resp(hapd, buf + 9, reply, reply_size);
 	} else {
 		os_memcpy(reply, "UNKNOWN COMMAND\n", 16);
 		reply_len = 16;
diff --git a/hostapd/hostapd.conf b/hostapd/hostapd.conf
index 118754800..d0830eecd 100644
--- a/hostapd/hostapd.conf
+++ b/hostapd/hostapd.conf
@@ -1149,6 +1149,16 @@ wmm_ac_vo_acm=0
 # will be used as the AP MLD MAC address.
 #mld_addr=02:03:04:05:06:07
 
+# EML Capabilities
+# 0 = Enable EML capabilities in Multi-Link Control subfield
+# 1 = Disable EML capabilitites in Multi-Link Control subfield
+#eml_disable=0
+
+# EML Operating Mode Notification frame
+# 0 = AP does not send EML Operating Mode Notification frame to the station
+# 1 = AP sends EML Operating Mode Notification frame to the station
+#eml_resp=1
+
 ##### IEEE 802.1X-2004 related configuration ##################################
 
 # Require IEEE 802.1X authorization
diff --git a/hostapd/hostapd_cli.c b/hostapd/hostapd_cli.c
index 54606770f..62e22ccbf 100644
--- a/hostapd/hostapd_cli.c
+++ b/hostapd/hostapd_cli.c
@@ -1487,6 +1487,12 @@ static int hostapd_cli_cmd_disable_beacon(struct wpa_ctrl *ctrl, int argc,
 	return hostapd_cli_cmd(ctrl, "NO_BEACON", 1, argc, argv);
 }
 
+static int hostapd_cli_cmd_set_eml_resp(struct wpa_ctrl *ctrl, int argc,
+					char *argv[])
+{
+	return hostapd_cli_cmd(ctrl, "EML_RESP", 1, argc, argv);
+}
+
 #ifdef CONFIG_DPP
 
 static int hostapd_cli_cmd_dpp_qr_code(struct wpa_ctrl *ctrl, int argc,
@@ -1936,6 +1942,8 @@ static const struct hostapd_cli_cmd hostapd_cli_commands[] = {
 		" = show mu onoff value in 0-15 bitmap"},
 	{ "no_beacon", hostapd_cli_cmd_disable_beacon, NULL,
 		"<value> 0: Enable beacon, 1: Disable beacon"},
+	{ "eml_resp", hostapd_cli_cmd_set_eml_resp, NULL,
+		"<value> 0: AP does not send EML Operating Mode Notification frame, 1: AP sends EML OMN frame"},
 #ifdef CONFIG_DPP
 	{ "dpp_qr_code", hostapd_cli_cmd_dpp_qr_code, NULL,
 	  "report a scanned DPP URI from a QR Code" },
diff --git a/src/ap/ap_config.h b/src/ap/ap_config.h
index 15b66ca30..9c3a28cf4 100644
--- a/src/ap/ap_config.h
+++ b/src/ap/ap_config.h
@@ -1281,6 +1281,8 @@ struct hostapd_config {
 	u8 punct_acs_threshold;
 	u8 eht_default_pe_duration;
 	u8 eht_bw320_offset;
+	u8 eml_disable;
+	u8 eml_resp;
 #endif /* CONFIG_IEEE80211BE */
 
 	/* EHT enable/disable config from CHAN_SWITCH */
diff --git a/src/ap/ap_drv_ops.c b/src/ap/ap_drv_ops.c
index ff68b2e52..ecfad53f7 100644
--- a/src/ap/ap_drv_ops.c
+++ b/src/ap/ap_drv_ops.c
@@ -496,7 +496,8 @@ int hostapd_sta_add(struct hostapd_data *hapd,
 		    size_t eht_capab_len,
 		    const struct ieee80211_he_6ghz_band_cap *he_6ghz_capab,
 		    u32 flags, u8 qosinfo, u8 vht_opmode, int supp_p2p_ps,
-		    int set, const u8 *link_addr, bool mld_link_sta)
+		    int set, const u8 *link_addr, bool mld_link_sta,
+		    u16 eml_capa)
 {
 	struct hostapd_sta_add_params params;
 
@@ -536,6 +537,7 @@ int hostapd_sta_add(struct hostapd_data *hapd,
 		params.mld_link_id = hapd->mld_link_id;
 		params.mld_link_addr = link_addr;
 		params.mld_link_sta = mld_link_sta;
+		params.eml_capa = eml_capa;
 	}
 #endif /* CONFIG_IEEE80211BE */
 
@@ -1488,6 +1490,22 @@ int hostapd_drv_beacon_ctrl(struct hostapd_data *hapd, u8 beacon_mode)
 	return hapd->driver->beacon_ctrl(hapd->drv_priv, beacon_mode);
 }
 
+int hostapd_drv_set_eml_omn(struct hostapd_data *hapd, u8 *mac,
+			    struct eml_omn_element *omn_ie)
+{
+	u8 link_id;
+
+	if (!hapd->driver || !hapd->driver->set_eml_omn)
+		return 0;
+
+	if (!hapd->conf->mld_ap)
+		return 0;
+
+	link_id = hapd->mld_link_id;
+
+	return hapd->driver->set_eml_omn(hapd->drv_priv, link_id, mac, omn_ie);
+}
+
 int hostapd_drv_csi_set(struct hostapd_data *hapd, u8 mode, u8 cfg, u8 v1, u32 v2, u8 *mac)
 {
 	if (!hapd->driver || !hapd->driver->csi_set)
diff --git a/src/ap/ap_drv_ops.h b/src/ap/ap_drv_ops.h
index 39f21c899..472a9d725 100644
--- a/src/ap/ap_drv_ops.h
+++ b/src/ap/ap_drv_ops.h
@@ -52,7 +52,8 @@ int hostapd_sta_add(struct hostapd_data *hapd,
 		    size_t eht_capab_len,
 		    const struct ieee80211_he_6ghz_band_cap *he_6ghz_capab,
 		    u32 flags, u8 qosinfo, u8 vht_opmode, int supp_p2p_ps,
-		    int set, const u8 *link_addr, bool mld_link_sta);
+		    int set, const u8 *link_addr, bool mld_link_sta,
+		    u16 eml_capa);
 int hostapd_set_privacy(struct hostapd_data *hapd, int enabled);
 int hostapd_set_generic_elem(struct hostapd_data *hapd, const u8 *elem,
 			     size_t elem_len);
@@ -179,6 +180,7 @@ int hostapd_drv_amnt_dump(struct hostapd_data *hapd, u8 amnt_idx, u8 *amnt_dump_
 int hostapd_drv_background_radar_mode(struct hostapd_data *hapd);
 int hostapd_drv_pp_mode_set(struct hostapd_data *hapd);
 int hostapd_drv_beacon_ctrl(struct hostapd_data *hapd, u8 beacon_mode);
+int hostapd_drv_set_eml_omn(struct hostapd_data *hapd, u8 *mac, struct eml_omn_element *omn_ie);
 int hostapd_drv_csi_set(struct hostapd_data *hapd, u8 mode, u8 cfg, u8 v1, u32 v2, u8 *mac);
 int hostapd_drv_csi_dump(struct hostapd_data *hapd, void *dump_buf);
 
diff --git a/src/ap/apup.c b/src/ap/apup.c
index f736ddc8e..cb0264e9e 100644
--- a/src/ap/apup.c
+++ b/src/ap/apup.c
@@ -67,7 +67,7 @@ void apup_process_beacon(struct hostapd_data *hapd,
 	            NULL, 0, 0, NULL, NULL, NULL, 0, NULL, 0, NULL,
 	            sta_ret->flags, 0, 0, 0,
 	            0, // 0 add, 1 set
-	            mld_link_addr, mld_link_sta);
+	            mld_link_addr, mld_link_sta, 0);
 
 	sta_ret->flags |= WLAN_STA_AUTH;
 	wpa_auth_sm_event(sta_ret->wpa_sm, WPA_AUTH);
@@ -141,7 +141,7 @@ void apup_process_beacon(struct hostapd_data *hapd,
 	            sta_ret->vht_opmode,
 	            0, // int supp_p2p_ps
 	            1, // 0 add, 1 set
-	            mld_link_addr, mld_link_sta);
+	            mld_link_addr, mld_link_sta, 0);
 
 	ap_sta_set_authorized(hapd, sta_ret, 1);
 	hostapd_set_sta_flags(hapd, sta_ret);
diff --git a/src/ap/ieee802_11.c b/src/ap/ieee802_11.c
index a4381522e..6ee5f6c56 100644
--- a/src/ap/ieee802_11.c
+++ b/src/ap/ieee802_11.c
@@ -4790,6 +4790,7 @@ static int add_associated_sta(struct hostapd_data *hapd,
 	int set = 1;
 	const u8 *mld_link_addr = NULL;
 	bool mld_link_sta = false;
+	u16 eml_capa = 0;
 
 #ifdef CONFIG_IEEE80211BE
 	if (ap_sta_is_mld(hapd, sta)) {
@@ -4800,6 +4801,8 @@ static int add_associated_sta(struct hostapd_data *hapd,
 
 		if (hapd->mld_link_id != sta->mld_assoc_link_id)
 			set = 0;
+
+		eml_capa = sta->mld_info.common_info.eml_capa;
 	}
 #endif /* CONFIG_IEEE80211BE */
 
@@ -4888,7 +4891,7 @@ static int add_associated_sta(struct hostapd_data *hapd,
 			    sta->he_6ghz_capab,
 			    sta->flags | WLAN_STA_ASSOC, sta->qosinfo,
 			    sta->vht_opmode, sta->p2p_ie ? 1 : 0,
-			    set, mld_link_addr, mld_link_sta)) {
+			    set, mld_link_addr, mld_link_sta, eml_capa)) {
 		hostapd_logger(hapd, sta->addr,
 			       HOSTAPD_MODULE_IEEE80211, HOSTAPD_LEVEL_NOTICE,
 			       "Could not %s STA to kernel driver",
@@ -6252,6 +6255,9 @@ static int handle_action(struct hostapd_data *hapd,
 		if (hapd->public_action_cb || hapd->public_action_cb2)
 			return 1;
 		break;
+	case WLAN_ACTION_PROTECTED_EHT:
+		ieee802_11_rx_prot_eht(hapd, mgmt, len);
+		return 1;
 	case WLAN_ACTION_VENDOR_SPECIFIC:
 		if (hapd->vendor_action_cb) {
 			if (hapd->vendor_action_cb(hapd->vendor_action_cb_ctx,
diff --git a/src/ap/ieee802_11.h b/src/ap/ieee802_11.h
index 834531121..34943fa78 100644
--- a/src/ap/ieee802_11.h
+++ b/src/ap/ieee802_11.h
@@ -265,5 +265,7 @@ int hostapd_process_assoc_ml_info(struct hostapd_data *hapd,
 				  const u8 *ies, size_t ies_len,
 				  bool reassoc, int tx_link_status,
 				  bool offload);
-
+void ieee802_11_rx_prot_eht(struct hostapd_data *hapd,
+			    const struct ieee80211_mgmt *mgmt,
+			    size_t len);
 #endif /* IEEE802_11_H */
diff --git a/src/ap/ieee802_11_eht.c b/src/ap/ieee802_11_eht.c
index 9b8511cb6..fe9f227e8 100644
--- a/src/ap/ieee802_11_eht.c
+++ b/src/ap/ieee802_11_eht.c
@@ -465,9 +465,11 @@ static u8 * hostapd_eid_eht_basic_ml_common(struct hostapd_data *hapd,
 	control = MULTI_LINK_CONTROL_TYPE_BASIC |
 		BASIC_MULTI_LINK_CTRL_PRES_LINK_ID |
 		BASIC_MULTI_LINK_CTRL_PRES_BSS_PARAM_CH_COUNT |
-		BASIC_MULTI_LINK_CTRL_PRES_EML_CAPA |
 		BASIC_MULTI_LINK_CTRL_PRES_MLD_CAPA;
 
+	if (!hapd->iconf->eml_disable)
+		control |= BASIC_MULTI_LINK_CTRL_PRES_EML_CAPA;
+
 	/*
 	 * Set the basic Multi-Link common information. Hard code the common
 	 * info length to 13 based on the length of the present fields:
@@ -478,6 +480,9 @@ static u8 * hostapd_eid_eht_basic_ml_common(struct hostapd_data *hapd,
 #define EHT_ML_COMMON_INFO_LEN 13
 	common_info_len = EHT_ML_COMMON_INFO_LEN;
 
+	if (hapd->iconf->eml_disable)
+		common_info_len -= 2; /* EML Capabilities (2) */
+
 	if (include_mld_id) {
 		/* AP MLD ID */
 		control |= BASIC_MULTI_LINK_CTRL_PRES_AP_MLD_ID;
@@ -497,9 +502,11 @@ static u8 * hostapd_eid_eht_basic_ml_common(struct hostapd_data *hapd,
 	/* Currently hard code the BSS Parameters Change Count to 0x1 */
 	wpabuf_put_u8(buf, hapd->eht_mld_bss_param_change);
 
-	wpa_printf(MSG_DEBUG, "MLD: EML Capabilities=0x%x",
-		   hapd->iface->mld_eml_capa);
-	wpabuf_put_le16(buf, hapd->iface->mld_eml_capa);
+	if (!hapd->iconf->eml_disable) {
+		wpa_printf(MSG_DEBUG, "MLD: EML Capabilities=0x%x",
+			   hapd->iface->mld_eml_capa);
+		wpabuf_put_le16(buf, hapd->iface->mld_eml_capa);
+	}
 
 	mld_cap = hapd->iface->mld_mld_capa;
 	max_simul_links = mld_cap & EHT_ML_MLD_CAPA_MAX_NUM_SIM_LINKS_MASK;
@@ -744,12 +751,16 @@ static u8 * hostapd_eid_eht_reconf_ml(struct hostapd_data *hapd, u8 *eid)
 
 
 static size_t hostapd_eid_eht_ml_len(struct mld_info *info,
-				     bool include_mld_id)
+				     bool include_mld_id,
+				     u8 eml_disable)
 {
 	size_t len = 0;
 	size_t eht_ml_len = 2 + EHT_ML_COMMON_INFO_LEN;
 	u8 link_id;
 
+	if (eml_disable)
+		eht_ml_len -= 2; /* EML Capabilities (2) */
+
 	if (include_mld_id)
 		eht_ml_len++;
 
@@ -811,7 +822,8 @@ size_t hostapd_eid_eht_ml_beacon_len(struct hostapd_data *hapd,
 				     struct mld_info *info,
 				     bool include_mld_id)
 {
-	return hostapd_eid_eht_ml_len(info, include_mld_id);
+	return hostapd_eid_eht_ml_len(info, include_mld_id,
+				      hapd->iconf->eml_disable);
 }
 
 
@@ -1434,3 +1446,120 @@ out:
 
 	return WLAN_STATUS_SUCCESS;
 }
+
+static void ieee802_11_send_eml_omn(struct hostapd_data *hapd,
+				    const u8 *addr,
+				    struct eml_omn_element *omn_ie,
+				    size_t len)
+{
+	struct wpabuf *buf;
+
+	buf = wpabuf_alloc(2 + len);
+	if (!buf)
+		return;
+
+	wpabuf_put_u8(buf, WLAN_ACTION_PROTECTED_EHT);
+	wpabuf_put_u8(buf, WLAN_PROTECTED_EHT_ACTION_EML_OMN);
+	wpabuf_put_data(buf, omn_ie, len);
+
+	hostapd_drv_send_action(hapd, hapd->iface->freq, 0, addr,
+				wpabuf_head(buf), wpabuf_len(buf));
+
+	wpabuf_free(buf);
+}
+
+static void ieee802_11_rx_eml_omn(struct hostapd_data *hapd,
+				  const u8 *addr, const u8 *frm,
+				  size_t len)
+{
+	struct eml_omn_element *omn_ie;
+
+	if (hapd->iconf->eml_disable) {
+		wpa_printf(MSG_ERROR,
+			   "Ignore EML Operating Mode Notification from "
+			   MACSTR
+			   " since EML Capabilities is disabled",
+			   MAC2STR(addr));
+		return;
+	}
+
+	/* EML Operating Mode Notification IE */
+	omn_ie = os_zalloc(sizeof(struct eml_omn_element));
+	if (omn_ie == NULL)
+		return;
+
+	os_memcpy(omn_ie, frm, len);
+
+	if (omn_ie->control & EHT_EML_OMN_CONTROL_EMLMR_MODE) {
+		wpa_printf(MSG_ERROR,
+			   "EML: Ignore EML Operating Mode Fotification from "
+			   MACSTR
+			   " since doesn't support EMLMR",
+			   MAC2STR(addr));
+		goto out;
+	}
+
+	hostapd_drv_set_eml_omn(hapd, addr, omn_ie);
+
+	omn_ie->control &= ~(EHT_EML_OMN_CONTROL_EMLSR_PARA_UPDATE_COUNT |
+			     EHT_EML_OMN_CONTROL_INDEV_COEX_ACTIVITIES);
+
+	if (hapd->iconf->eml_resp) {
+		ieee802_11_send_eml_omn(hapd, addr, omn_ie, len);
+		wpa_printf(MSG_ERROR, "EML: AP send EML Operating Mode Fotification to "
+				       MACSTR,
+				       MAC2STR(addr));
+	}
+out:
+	os_free(omn_ie);
+	return;
+}
+
+void ieee802_11_rx_prot_eht(struct hostapd_data *hapd,
+			    const struct ieee80211_mgmt *mgmt,
+			    size_t len)
+{
+	struct sta_info *sta;
+	struct mld_info *info;
+	u8 action;
+	const u8 *payload;
+	size_t plen;
+
+	if (!hapd->conf->mld_ap)
+		return;
+
+	if (len < IEEE80211_HDRLEN + 2)
+		return;
+
+	sta = ap_get_sta(hapd, mgmt->sa);
+	if (!sta) {
+		wpa_printf(MSG_DEBUG, "EHT: Station " MACSTR,
+			   " not found for received Protected EHT Action",
+			   MAC2STR(mgmt->sa));
+		return;
+	}
+
+	info = &sta->mld_info;
+
+	payload = mgmt->u.action.u.eht_prot.variable;
+	action = mgmt->u.action.u.eht_prot.action;
+	plen = len - IEEE80211_HDRLEN - 2;
+
+	switch (action) {
+	case WLAN_PROTECTED_EHT_ACTION_EML_OMN:
+		if (!info->common_info.eml_capa & EHT_ML_EML_CAPA_EMLSR_SUPP) {
+			wpa_printf(MSG_ERROR, "EHT: Fail, Station does not support EMLSR!");
+			return;
+		}
+
+		ieee802_11_rx_eml_omn(hapd, mgmt->sa, payload, plen);
+		return;
+	}
+
+	wpa_printf(MSG_ERROR, "EHT: Unsupported Protected EHT Action %u from " MACSTR,
+		   action, MAC2STR(mgmt->sa));
+
+	return;
+
+}
+
diff --git a/src/ap/sta_info.c b/src/ap/sta_info.c
index af3f286bd..b2a702364 100644
--- a/src/ap/sta_info.c
+++ b/src/ap/sta_info.c
@@ -1902,7 +1902,7 @@ int ap_sta_re_add(struct hostapd_data *hapd, struct sta_info *sta)
 			    sta->supported_rates_len,
 			    0, NULL, NULL, NULL, 0, NULL, 0, NULL,
 			    sta->flags, 0, 0, 0, 0,
-			    mld_link_addr, mld_link_sta)) {
+			    mld_link_addr, mld_link_sta, 0)) {
 		hostapd_logger(hapd, sta->addr,
 			       HOSTAPD_MODULE_IEEE80211,
 			       HOSTAPD_LEVEL_NOTICE,
diff --git a/src/common/ieee802_11_defs.h b/src/common/ieee802_11_defs.h
index e1ad9efe0..cd15ff1b2 100644
--- a/src/common/ieee802_11_defs.h
+++ b/src/common/ieee802_11_defs.h
@@ -778,6 +778,36 @@
 #define WLAN_PROT_FTM 2
 #define WLAN_PROT_FTM_REPORT 3
 
+/* Protected EHT action codes */
+#define WLAN_PROTECTED_EHT_ACTION_EML_OMN 6
+
+/* EML Operating Mode Notification frame */
+#define EHT_EML_OMN_CONTROL_EMLSR_MODE 0x1
+#define EHT_EML_OMN_CONTROL_EMLMR_MODE 0x2
+#define EHT_EML_OMN_CONTROL_EMLSR_PARA_UPDATE_COUNT 0x4
+#define EHT_EML_OMN_CONTROL_INDEV_COEX_ACTIVITIES 0x8
+
+/* EMLSR Parameter Update field */
+#define EHT_EML_OMN_EMLSR_PADDING_DELAY_MASK 0x07
+#define EHT_EML_OMN_EMLSR_TRANSITION_DELAY_MASK 0x38
+
+struct eml_omn_element {
+	u8 dialog_token;
+	u8 control;
+	le16 bitmap;
+	union {
+		struct {
+			u8 emlsr_para_update;
+		} STRUCT_PACKED emlsr_info;
+		struct {
+			u8 mcs_map_count_control;
+			u8 mcs_map_bw80[3];
+			u8 mcs_map_bw160[3];
+			u8 mcs_map_bw320[3];
+		} STRUCT_PACKED emlmr_info;
+	} u;
+} STRUCT_PACKED;
+
 /* Radio Measurement capabilities (from RM Enabled Capabilities element)
  * IEEE Std 802.11-2020, 9.4.2.44, Table 9-179 */
 /* byte 1 (out of 5) */
@@ -1164,6 +1194,10 @@ struct ieee80211_mgmt {
 					u8 dialog_token;
 					u8 variable[];
 				} STRUCT_PACKED rrm;
+				struct {
+					u8 action;
+					u8 variable[];
+				} STRUCT_PACKED eht_prot;
 			} u;
 		} STRUCT_PACKED action;
 	} u;
diff --git a/src/common/mtk_vendor.h b/src/common/mtk_vendor.h
index be516e017..c6de8862b 100644
--- a/src/common/mtk_vendor.h
+++ b/src/common/mtk_vendor.h
@@ -19,6 +19,7 @@ enum mtk_nl80211_vendor_subcmds {
 	MTK_NL80211_VENDOR_SUBCMD_BACKGROUND_RADAR_CTRL = 0xcb,
 	MTK_NL80211_VENDOR_SUBCMD_PP_CTRL = 0xcc,
 	MTK_NL80211_VENDOR_SUBCMD_BEACON_CTRL = 0xcd,
+	MTK_NL80211_VENDOR_SUBCMD_EML_CTRL = 0xd3,
 };
 
 enum mtk_vendor_attr_edcca_ctrl {
@@ -287,6 +288,20 @@ enum mtk_vendor_attr_beacon_ctrl {
 		NUM_MTK_VENDOR_ATTRS_BEACON_CTRL - 1
 };
 
+enum mtk_vendor_attr_eml_ctrl {
+
+	MTK_VENDOR_ATTR_EML_CTRL_UNSPEC,
+
+	MTK_VENDOR_ATTR_EML_LINK_ID,
+	MTK_VENDOR_ATTR_EML_STA_ADDR,
+	MTK_VENDOR_ATTR_EML_CTRL_STRUCT,
+
+	/* keep last */
+	NUM_MTK_VENDOR_ATTRS_EML_CTRL,
+	MTK_VENDOR_ATTR_EML_CTRL_MAX =
+		NUM_MTK_VENDOR_ATTRS_EML_CTRL -1
+};
+
 #define CSI_BW20_DATA_COUNT	64
 #define CSI_BW40_DATA_COUNT	128
 #define CSI_BW80_DATA_COUNT	256
diff --git a/src/drivers/driver.h b/src/drivers/driver.h
index 6eace6bae..2edc60fff 100644
--- a/src/drivers/driver.h
+++ b/src/drivers/driver.h
@@ -2608,6 +2608,7 @@ struct hostapd_sta_add_params {
 	bool mld_link_sta;
 	s8 mld_link_id;
 	const u8 *mld_link_addr;
+	u16 eml_capa;
 };
 
 struct mac_address {
@@ -5402,6 +5403,17 @@ struct wpa_driver_ops {
 	 */
 	int (*beacon_ctrl)(void *priv, u8 beacon_mode);
 
+	/**
+	 * set eml omn - Send the EML Operating Mode
+	 * 		 Notification content to driver
+	 * @priv: Private driver interface data
+	 * @link_id: MLD link id
+	 * @addr: MLD STA address
+	 * @omn_ie: EML OMN content sent by the MLD STA
+	 */
+	int (*set_eml_omn)(void *priv, u8 link_id,
+			   u8 *addr, struct eml_omn_element *omn_ie);
+
 	/**
 	 * three_wire_ctrl - set three_wire_ctrl mode
 	 * @priv: Private driver interface data
diff --git a/src/drivers/driver_nl80211.c b/src/drivers/driver_nl80211.c
index 6aef4a4e3..8eed3a59c 100644
--- a/src/drivers/driver_nl80211.c
+++ b/src/drivers/driver_nl80211.c
@@ -2895,6 +2895,9 @@ static int nl80211_action_subscribe_ap(struct i802_bss *bss)
 	if (nl80211_register_action_frame(bss, (u8 *) "\x12", 1) < 0)
 		ret = -1;
 #endif /* CONFIG_FST */
+	/* Protected EHT */
+	if (nl80211_register_action_frame(bss, (u8 *) "\x25", 1) < 0)
+		ret = -1;
 	/* Vendor-specific */
 	if (nl80211_register_action_frame(bss, (u8 *) "\x7f", 1) < 0)
 		ret = -1;
@@ -5999,6 +6002,14 @@ static int wpa_driver_nl80211_sta_add(void *priv,
 			goto fail;
 	}
 
+	if (params->eml_capa) {
+		wpa_printf(MSG_DEBUG, "  * eml_capa=%u",
+			   params->eml_capa);
+		if (nla_put_u16(msg, NL80211_ATTR_EML_CAPABILITY,
+				params->eml_capa))
+			goto fail;
+	}
+
 	ret = send_and_recv_cmd(drv, msg);
 	msg = NULL;
 	if (ret)
@@ -15734,6 +15745,47 @@ static int nl80211_get_mld_addr(void *priv, u8 *addr)
 
 	return 0;
 }
+
+static int nl80211_set_eml_omn(void *priv, u8 link_id, u8 *addr,
+			       struct eml_omn_element *omn_ie)
+{
+	struct i802_bss *bss = priv;
+	struct wpa_driver_nl80211_data *drv = bss->drv;
+	struct nl_msg *msg;
+	struct nlattr *data;
+	int ret = -ENOBUFS;
+
+	if (!drv->mtk_eml_vendor_cmd_avail) {
+		wpa_printf(MSG_ERROR,
+			   "nl80211: Driver does not support setting EML control");
+		return 0;
+	}
+
+	if (!(msg = nl80211_drv_msg(drv, 0, NL80211_CMD_VENDOR)) ||
+	    nla_put_u32(msg, NL80211_ATTR_VENDOR_ID, OUI_MTK) ||
+	    nla_put_u32(msg, NL80211_ATTR_VENDOR_SUBCMD,
+			MTK_NL80211_VENDOR_SUBCMD_EML_CTRL) ||
+	    !(data = nla_nest_start(msg, NL80211_ATTR_VENDOR_DATA)) ||
+	    nla_put_u8(msg, MTK_VENDOR_ATTR_EML_LINK_ID, link_id) ||
+	    nla_put(msg, MTK_VENDOR_ATTR_EML_STA_ADDR, ETH_ALEN, addr) ||
+	    nla_put(msg, MTK_VENDOR_ATTR_EML_CTRL_STRUCT,
+		    sizeof(struct eml_omn_element), omn_ie))
+		goto fail;
+
+
+	nla_nest_end(msg, data);
+	ret = send_and_recv_cmd(drv, msg);
+
+	if (ret)
+		wpa_printf(MSG_ERROR, "Failed to set EML OMN ctrl. ret = %d (%s)",
+			   ret, strerror(-ret));
+
+	return ret;
+
+fail:
+	nlmsg_free(msg);
+	return ret;
+}
 #endif
 
 static int
@@ -16100,6 +16152,7 @@ const struct wpa_driver_ops wpa_driver_nl80211_ops = {
 	.mu_ctrl = nl80211_mu_ctrl,
 	.mu_dump = nl80211_mu_dump,
 	.beacon_ctrl = nl80211_beacon_ctrl,
+	.set_eml_omn = nl80211_set_eml_omn,
 #ifdef CONFIG_DPP
 	.dpp_listen = nl80211_dpp_listen,
 #endif /* CONFIG_DPP */
diff --git a/src/drivers/driver_nl80211.h b/src/drivers/driver_nl80211.h
index 5714b2c84..f19120d7f 100644
--- a/src/drivers/driver_nl80211.h
+++ b/src/drivers/driver_nl80211.h
@@ -214,6 +214,7 @@ struct wpa_driver_nl80211_data {
 	unsigned int mtk_pp_vendor_cmd_avail:1;
 	unsigned int mtk_beacon_ctrl_vendor_cmd_avail:1;
 	unsigned int mtk_csi_vendor_cmd_avail:1;
+	unsigned int mtk_eml_vendor_cmd_avail:1;
 
 	u32 ignore_next_local_disconnect;
 	u32 ignore_next_local_deauth;
diff --git a/src/drivers/driver_nl80211_capa.c b/src/drivers/driver_nl80211_capa.c
index d81797046..a755ede8c 100644
--- a/src/drivers/driver_nl80211_capa.c
+++ b/src/drivers/driver_nl80211_capa.c
@@ -1179,6 +1179,9 @@ static int wiphy_info_handler(struct nl_msg *msg, void *arg)
 				case MTK_NL80211_VENDOR_SUBCMD_CSI_CTRL:
 					drv->mtk_csi_vendor_cmd_avail = 1;
 					break;
+				case MTK_NL80211_VENDOR_SUBCMD_EML_CTRL:
+					drv->mtk_eml_vendor_cmd_avail = 1;
+					break;
 				}
 			}
 
-- 
2.45.2

