From 849b8c4facd518cdde2119bd42fe8b1d32198655 Mon Sep 17 00:00:00 2001
From: Allen Ye <allen.ye@mediatek.com>
Date: Thu, 29 May 2025 16:37:06 +0800
Subject: [PATCH 206/236] mtk: hostapd: Add BSS Transition Candidate Preference
 subelement in BTM req and query resp

Add BSS Transition Candidate Preference subelement in BTM request for qt
10378 and 10379 BTM frame check.
The commit append the subelement when hostapd using the rnr ie from neighbor
cache of each link. The cache can be enabled by the config
rrm_neighbor_report, which is used in QT test.

Sigma uses the cmd "hostapd_cli bss_tm_req neighbor=[...]" to specify the
rnr ie content instead of the neighbor cache, so this path will not be
affected.

Fix duplicate preference subelement by check whether the subelement
does exist and give the default 255 value.
If the AP sould like to disassoc STA that should be specify by
disassoc_imminent parameter.

Signed-off-by: Allen Ye <allen.ye@mediatek.com>
---
 src/ap/ctrl_iface_ap.c |  7 ++++++-
 src/ap/neighbor_db.c   | 17 ++++++++++++++++-
 2 files changed, 22 insertions(+), 2 deletions(-)

diff --git a/src/ap/ctrl_iface_ap.c b/src/ap/ctrl_iface_ap.c
index 2328d42e9..1222feae3 100644
--- a/src/ap/ctrl_iface_ap.c
+++ b/src/ap/ctrl_iface_ap.c
@@ -1418,6 +1418,7 @@ int hostapd_ctrl_iface_bss_tm_req(struct hostapd_data *hapd,
 	u8 mbo[10];
 	size_t mbo_len = 0;
 	u8 mbo_cert = 0;
+	bool is_excluded_bss = false;
 
 	if (hwaddr_aton(cmd, addr)) {
 		wpa_printf(MSG_DEBUG, "Invalid STA MAC address");
@@ -1473,6 +1474,7 @@ int hostapd_ctrl_iface_bss_tm_req(struct hostapd_data *hapd,
 
 		end++;
 		WPA_PUT_LE16(&bss_term_dur[10], atoi(end));
+		is_excluded_bss = true;
 	}
 
 	nei_len = ieee802_11_parse_candidate_list(cmd, nei_rep,
@@ -1518,11 +1520,14 @@ int hostapd_ctrl_iface_bss_tm_req(struct hostapd_data *hapd,
 		req_mode |= WNM_BSS_TM_REQ_DISASSOC_IMMINENT;
 		if (mbo_cert == 1)
 			/* Set own BSS neighbor report preference value as 0 */
-			hostapd_neighbor_set_own_report_pref(hapd, nei_rep, nei_len, 0);
+			is_excluded_bss = true;
 	}
 	if (os_strstr(cmd, " link_removal_imminent=1"))
 		req_mode |= WNM_BSS_TM_REQ_LINK_REMOVAL_IMMINENT;
 
+	if (is_excluded_bss)
+		hostapd_neighbor_set_own_report_pref(hapd, nei_rep, nei_len, 0);
+
 #ifdef CONFIG_MBO
 	hostapd_neighbor_set_pref_by_non_pref_chan(hapd, sta, nei_rep, nei_len);
 
diff --git a/src/ap/neighbor_db.c b/src/ap/neighbor_db.c
index 635319101..638919bbe 100644
--- a/src/ap/neighbor_db.c
+++ b/src/ap/neighbor_db.c
@@ -103,18 +103,33 @@ int hostapd_neighbor_count(struct hostapd_data *hapd)
 
 
 int hostapd_neighbor_insert_buffer(struct hostapd_data *hapd, char *buf,
-        size_t buflen)
+				   size_t buflen)
 {
 	struct hostapd_neighbor_entry *nr;
 	char *pos = buf;
 
 	dl_list_for_each(nr, &hapd->nr_db, struct hostapd_neighbor_entry,
 			 list) {
+		struct neighbor_report_element *nre;
+		struct element *preference_subelem;
+
+		nre = (struct neighbor_report_element *)pos;
 		/* For neighbor report IE, we only need bssid and nr*/
 		*pos++ = WLAN_EID_NEIGHBOR_REPORT;
 		*pos++ = wpabuf_len(nr->nr);
 		os_memcpy(pos, wpabuf_head(nr->nr), wpabuf_len(nr->nr));
 		pos += wpabuf_len(nr->nr);
+
+		preference_subelem = (struct element *)
+			get_ie(nre->variable,
+			       nre->len - (6 + 4 + 1 + 1 + 1),
+			       WNM_NEIGHBOR_BSS_TRANSITION_CANDIDATE);
+		if (!preference_subelem) {
+			nre->len += 3;
+			*pos++ = WNM_NEIGHBOR_BSS_TRANSITION_CANDIDATE;
+			*pos++ = 1;
+			*pos++ = 0xff;
+		}
 	}
 
 	return pos - buf;
-- 
2.45.2

