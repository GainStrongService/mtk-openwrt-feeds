From 81018af77a92368d5bce406bc245a3a2cb21200c Mon Sep 17 00:00:00 2001
From: Jouni Malinen <jouni.malinen@oss.qualcomm.com>
Date: Tue, 27 May 2025 23:12:33 +0300
Subject: [PATCH 001/236] jump to hostapd 2025-06-19 version
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

DPP: Enable GAS server in hostapd without CONFIG_INTERWORKING=y

CONFIG_DPP=y was sufficient to include the GAS server functionality into
the hostapd build, but a couple of the calls did not cover the
possibility of CONFIG_DPP=y being used without CONFIG_INTERWORKING=y. In
practice, this prevented hostapd from operating as the DPP Configurator
without CONFIG_INTERWORKING=y.

Fix this by enabling GAS server if either CONFIG_INTERWORKING or
CONFIG_DPP have been defined consistently.

Signed-off-by: Jouni Malinen <jouni.malinen@oss.qualcomm.com>

P2P2: Include the requested method in the bootstrap response notification

In the bootstrap response indication, send the requested bootstrap
method by the device to align with config method indicated in P2P-R1
provision discovery indication to the applications.

Signed-off-by: Vinay Gannevaram <quic_vganneva@quicinc.com>

dbus: Update D-Bus interface description for bootstrapping indications

Update the description of D-Bus interface for bootstrapping indications
to match the implementation change as this has not yet been used and is
a recently added parameter.

Signed-off-by: Vinay Gannevaram <quic_vganneva@quicinc.com>

P2P2: Enable support for setting PMKSA in P2P Client mode

When a device does not support separate group interface creation for the
group role, the existing P2P interface mode is switched from device mode
to client mode before invoking wpa_driver_nl80211_connect().
Additionally, drivers only permit configuring PMKSA in P2P client mode.
Therefore, PMKSA should be set in wpas_start_assoc_cb() for drivers that
offload SME from wpa_supplicant.

Signed-off-by: Vinay Gannevaram <quic_vganneva@quicinc.com>

P2P2: Set p2p_mode to WPA_P2P_MODE_WFD_R2 upon receiving PASN Auth

This is required during P2P2 verification on the responder side where
p2p_mode may not be initialized to WFD_R2 by default. Ensure the mode is
set correctly when PASN Auth RX is received to support P2P2 operation.

Signed-off-by: Shivani Baranwal <quic_shivbara@quicinc.com>

MLO: Link reconfiguration message definitions

Define identifiers and structures for link reconfiguration.

Reviewed-by: Rohan Dutta <quic_drohan@quicinc.com>
Signed-off-by: Pooventhiran G <quic_pooventh@quicinc.com>

MLD STA: Add SETUP_LINK_RECONFIG control interface command

Add support for SETUP_LINK_RECONFIG control interface command
that allows users to add new setup links and/or remove existing
ones for the current MLO connection in STA mode.

Signed-off-by: Kavita Kavita <quic_kkavita@quicinc.com>

MLD: Handle link reconfiguration updates from the driver

Processess the NL80211_CMD_ASSOC_MLO_RECONF event from the driver. This
event includes information about added links and the link
reconfiguration response frame from the AP MLD. The event can be
triggered by either wpa_supplicant or driver-initiated link
reconfiguration updates.

Also install group keys (e.g., GTK, IGTK, BIGTK, etc.) received with the
link reconfiguration response frame for the newly added links.

For removed links, the existing NL80211_CMD_LINKS_REMOVED event is used,
requiring no additional changes in wpa_supplicant for both
wpa_supplicant and driver-initiated link reconfiguration updates.

Signed-off-by: Kavita Kavita <quic_kkavita@quicinc.com>

MLD: Clear group keys for removed links

For AP link removal case, group keys (e.g., GTK, IGTK, BIGTK, etc.) were
not cleared for links that were removed in the NL80211_CMD_LINKS_REMOVED
event. Since the links are already removed, we should clear the keys
associated with these links for proper cleanup.

This functionality was missing in the current implementation, so address
this by clearing group keys for the removed links.

Signed-off-by: Kavita Kavita <quic_kkavita@quicinc.com>

Do not add Channel Switch Wrapper element without VHT/HE/EHT

Only include the Channel Switch Wrapper element in Beacon and Probe
Response frames when at least one of the PHY modes IEEE 802.11ac, IEEE
802.11ax, or IEEE 802.11be is enabled and not explicitly disabled in the
configuration.

This avoids unnecessary inclusion of the Channel Switch Wrapper element
when none of these modes are active, ensuring better compliance with the
capabilities advertised by the AP.

Signed-off-by: Aloka Dixit <aloka.dixit@oss.qualcomm.com>
Signed-off-by: Muna Sinada <muna.sinada@oss.qualcomm.com>
Signed-off-by: Maharaja Kennadyrajan <maharaja.kennadyrajan@oss.qualcomm.com>

AP MLD: Correct link handling for MLO Disassociation

When transmitting a Disassociation frame, MLD link_id was not
considered, default value of -1 sent. Because of this, the first link
was always used to send Disassociation frames.

Address this by sending the corressponding 'mld_link_id' to the driver
if the Disassociation frame is sent by an AP MLD.

Signed-off-by: Manish Dharanenthiran <manish.dharanenthiran@oss.qualcomm.com>

AP MLD: Validate mld_ap configuration

Currently, hostapd tries to access MLO related functions and structures
even when 'ieee80211be' is unset, as 'mld_ap' is set. This is wrong and
at times, it leads to unexpected issues.

Address this by rejecting the configuration when mld_ap is set, while
'ieee80211be' is unset or disable_11be is set.

While at it, clear the mld_ap while disable_11be flag is modified during
configuration validation.

Signed-off-by: Aditya Kumar Singh <aditya.kumar.singh@oss.qualcomm.com>
Co-developed-by: Manish Dharanenthiran <manish.dharanenthiran@oss.qualcomm.com>
Signed-off-by: Manish Dharanenthiran <manish.dharanenthiran@oss.qualcomm.com>

P2P: Allow upgrade to 160 MHz if 80 MHz allowed and AUTO_BW flag is set

Upgrade to 160 MHz when AUTO_BW flag is set in contiguous frequency
range. This is needed to allow regdb rules for 160 MHz channels to be
used correctly when some of the differences between the 80 MHz parts of
the full channel has resulted in AUTO_BW flag being used.

Signed-off-by: Chenming Huang <chenhuan@oss.qualcomm.com>

AP MLD: Use hostapd-based ACL for MLO cases

Currently NL80211_CMD_SET_MAC_ACL is not supported for MLO cases.
Since this command has no upstream driver support, further extension
might not be accepted and this command itself may be removed in the
future, too.

To support the same ACL setting from hostapd control interface, use
hostapd-based ACL instead when comes to MLO case. In addition, verify
both the link addresses and MLD MAC addresses of the non-AP MLD.

Signed-off-by: Chenming Huang <chenhuan@qti.qualcomm.com>

Fix QCA vendor attribute documentation

Fix the list of valid values for the attribute
QCA_WLAN_VENDOR_ATTR_TWT_NUDGE_NEXT_TWT_SIZE in the comment section.
This was not supposed to be a bitmap, but a consecutive sequence of
integers. The previously defined value has not been used.

Signed-off-by: nakul kachhwaha <nkachhwa@qti.qualcomm.com>

Add new QCA vendor command to set P2P NoA

Add QCA_NL80211_VENDOR_SUBCMD_P2P_SET_NOA to set P2P Notice of Absence
as group owner.

Signed-off-by: Jay Shukla <jayshukl@qti.qualcomm.com>

hostapd: Allow channel switch between hw_modes

Commit 3e2758b19a75 ("hostapd: Avoid channel selection across underlying
hardware index") enforcing target channel to be present in the current
hw_mode even though the hostapd_iface can support multiple hw_modes. Due
to this channel switch request between different hw_modes getting
rejected always.

To fix this, determine the target hw_mode of the channel switch request
and use it for validating against current underlying hardware index.

Fixes: 3e2758b19a75 ("hostapd: Avoid channel selection across underlying hardware index")
Signed-off-by: Kavita Kavita <kkavita@qti.qualcomm.com>

SAE: Fix AKM suite selector for external authentication compatibility

Kernel commit 4f4d8be6dc37 ("wifi: nl80211: force WLAN_AKM_SUITE_SAE in
big endian in NL80211_CMD_EXTERNAL_AUTH") enforces WLAN_AKM_SUITE_SAE to
be passed in big-endian format in NL80211_CMD_EXTERNAL_AUTH for all
drivers. This is causing issues for cross-AKM roaming cases (e.g.,
roaming from SAE-EXT-KEY AP to SAE AP) with current wpa_supplicant
implementation since it is considering the connected AP AKM as the
target AP AKM when WLAN_AKM_SUITE_SAE is indicated in big-endian format
in NL80211_CMD_EXTERNAL_AUTH.

To fix this, always set external authentication AKM as
WLAN_AKM_SUITE_SAE when WLAN_AKM_SUITE_SAE indicated in big endian
format in NL80211_CMD_EXTERNAL_AUTH.

This change is still compatible with old drivers since there is no
change in SAE authentication procedure when the target AP AKM is SAE or
FT-SAE.

Signed-off-by: Ainy Kumari <ainykuma@qti.qualcomm.com>

Delete PMKID from driver when PMKSA entry is freed in Authenticator

For SME-in-driver, external SAE authentication (i.e., the driver
offloading SAE processing to hostapd) the PMKID is configured to the
driver on successful completion, but this is not cleared when hostapd
frees its PMKSA entry. This causes the driver and hostapd to get out of
sync.

This can result in the driver accepting an association with an unknown
(to hostapd) PMKID, but hostapd ending up using Deauthentication frame
due to that unknown PMKID. iPhone as a client seems to only clear its
PMKSA entry based on with asssociation rejection and thus, it might
retry again and again with the same unknown-to-hostapd PMKID.

Remove the PMKID from the driver when the matching PMKSA is remove from
hostapd to avoid this.

Signed-off-by: Jouni Malinen <jouni.malinen@oss.qualcomm.com>

WNM: Disassociate STA only when Link Removal Imminent is 0 in BTM Request frame

When BSS Transition Management (BTM) Request frame is sent by an AP MLD
with disassociation timer set, it is expected to arm disassociation
timer for the STA and eventually disassociate it once the timer expires.

The current code avoids this by assuming that the ML association is not
being terminated and only the link is being removed. However, link
removal is scheduled only when Link Removal Imminent field is set in BTM
request, as per IEEE P802.11be/D7.0 - 9.6.13.9 (BSS Transition
Management Request frame format). If the Link Removal Imminent field in
the Request Mode field is set to 1, the BSS Termination Included field
indicates that the BSS, whose AP transmits this BSS Transition
Management Request frame, is shutting down. In this case, the STA
associated with the AP or the non-AP MLD that has set up only this link
will be disassociated and the non-AP MLD that has set up more than this
link remains associated to the AP MLD with the remaining setup link(s).

Hence, schedule disassociation for STA unless Link Removal Imminent bit
is set to 1 in the BTM Request frame.

Signed-off-by: Yuvarani V <yuvarani@qti.qualcomm.com>

nl80211: Set to AP mode before adding to bridge during AP interface addition

Commit dd1587c91541 ("hostapd: Allow reuse of existing interface for AP
MLD") added support to change mode to AP if it is already not while
adding the interface. However, this is currently done after bridge
addition is done. Now, in a few systems, bridge addition fails with
following:

nl80211: Driver for phy phy0 already exist
nl80211: Create interface iftype 3 (AP)
Failed to create interface wlan0: -23 (Too many open files in system)
nl80211: Continue using existing interface wlan0
nl80211: Adding interface wlan0 into bridge br-lan
Could not add interface wlan0 into bridge br-lan: Not supported
nl80211: Failed to add interface wlan0 into bridge br-lan: Not supported
nl80211: Set mode ifindex 17 iftype 3 (AP)
nl80211: Failed to set interface 17 to mode 3: -16 (Resource busy)
Failed to add BSS (BSSID=AA:BB:CC:DD:EE:FF)

Hence, to avoid this issue, move logic to set mode to AP before adding
to bridge. Since BSS needs to be partially initialized before attempting
to set mode, move the certain assignments as well above it.

Signed-off-by: Aditya Kumar Singh <aditya.kumar.singh@oss.qualcomm.com>

AP MLD: Process Link Reconfiguration Request frame for ML Setup links

A non-AP MLD can change the ML setup links (adding a new link or
removing an existing link) by using the Link Reconfiguration to Setup
Links procedure, as per IEEE P802.11be/D7.0.

Add support for an AP MLD to parse the Link Reconfiguration Request
frame and set up context with necessary information.

Reviewed-by: Rohan Dutta <quic_drohan@quicinc.com>
Signed-off-by: Pooventhiran G <quic_pooventh@quicinc.com>

AP MLD: Validate Link Reconfiguration Request frame after parsing

When a Link Reconfiguration Request frame is successfully parsed and set
up with context, validate the request to verify links requested for
operation(s) are valid.

While at it, if accepting the request after current validation tends to
leave the ML Setup with no remaining links, recover from the situation
by rejecting a "delete" link request. Currently, the "delete" link
request with the lowest link ID will be rejected.

Reviewed-by: Rohan Dutta <quic_drohan@quicinc.com>
Signed-off-by: Pooventhiran G <quic_pooventh@quicinc.com>

AP MLD: Send Link Reconfiguration Response after validation

If a Link Reconfiguration Request is parsed and validated, send the
response frame to indicate success or failure for each operation
requested.

As long as one "add" request is accepted, Group KDEs and Basic MLE with
Per-STA profile for accepted links, and OCE element are added.

Reviewed-by: Rohan Dutta <quic_drohan@quicinc.com>
Signed-off-by: Pooventhiran G <quic_pooventh@quicinc.com>

AP MLD: Process TX status for Link Reconfiguration Response frame

When a Link Reconfiguration Response frame is ACK-ed, the AP MLD can
complete reconfiguration operations. Process the accepted del-link
requests, and if the link that is removed is the association link,
assign a new (soft) association link to maintain ML setup and APIs.

Reviewed-by: Rohan Dutta <quic_drohan@quicinc.com>
Signed-off-by: Pooventhiran G <quic_pooventh@quicinc.com>

AP MLD: Check if non-AP STA in reconfig add-request already exists

As per IEEE P802.11be/D7.0, the non-AP STA requested in ML Setup link
reconfiguration for "add" operation should not have the (link) MAC address
associated to any non-AP STA which is either affiliated or not to a
non-AP MLD on the corresponding AP link affiliated with the AP MLD.

Enforce this condition and reject the operation otherwise.

Reviewed-by: Rohan Dutta <quic_drohan@quicinc.com>
Signed-off-by: Pooventhiran G <quic_pooventh@quicinc.com>

AP MLD: Advertise support for ML Setup Link Reconfiguration

While preparing the Basic Multi-Link element, advertise support for
ML Setup Link Reconfiguration in MLD Capabilities and Operations
subfield.

Reviewed-by: Rohan Dutta <quic_drohan@quicinc.com>
Signed-off-by: Pooventhiran G <quic_pooventh@quicinc.com>

nl80211: Register for Link Reconfiguration Request frame

This is needed for the AP MLD implementation of link reconfiguration for
MLO that was added in the prior commits.

Reviewed-by: Rohan Dutta <quic_drohan@quicinc.com>
Signed-off-by: Pooventhiran G <quic_pooventh@quicinc.com>

AP MLD: Control interface events for ML Setup Link Reconfiguration

Add control interface events in hostapd for link STA removal and
addition operations from link reconfiguration.

Co-developed-by: Pooventhiran G <quic_pooventh@quicinc.com>
Signed-off-by: Pooventhiran G <quic_pooventh@quicinc.com>
Signed-off-by: Mohan Kumar G <quic_mkumarg@quicinc.com>

tests: ML Setup Link Reconfiguration

Add a test case to connect AP and STA in two links and perform ML Setup
Link Reconfiguration to remove a link and add the link back.

Co-developed-by: Pooventhiran G <quic_pooventh@quicinc.com>
Signed-off-by: Pooventhiran G <quic_pooventh@quicinc.com>
Signed-off-by: Mohan Kumar G <quic_mkumarg@quicinc.com>

tests: Enable CONFIG_IEEE80211BE for hwsim wpa_supplicant

Enable CONFIG_IEEE80211BE option for wpa_supplicant in hwsim to run
EHT-specific tests.

Signed-off-by: Pooventhiran G <quic_pooventh@quicinc.com>

AP MLD: Remove Link STA on Group KDE length check failure

If accepting an add-request in Link Reconfiguration causes the Group KDE
Length subfield to exceed max length, the request is rejected, but the
link STA will already have been added to the kernel driver.

Hence, remove the link STA on max length check failure.

Fixes: 60b3884948c6 ("AP MLD: Validate Link Reconfiguration Request frame after parsing")
Signed-off-by: Pooventhiran G <pooventh@qti.qualcomm.com>

BSD: Handle systems without legacy IP support

Currently, wpa_supplicant fails to operate when legacy IP support is
disabled (i.e., the system is built with WITHOUT_INET and the kernel is
configured with nooptions INET). Address the issue by enabling
wpa_supplicant to run and connect to wireless networks even in the
absence of AF_INET, as long as AF_INET6 is available.

Signed-off-by: Marek Zarychta <zarychtam@plan-b.pwste.edu.pl>

AP MLD: Ensure hostapd_deinit_driver() is called when driver_init() fails

Ensure hostapd_deinit_driver() is called when driver_init() fails in
both hostapd_enable_iface() and hostapd_add_iface().

When initializing an AP MLD interface, driver_init() first assigns a
valid private driver interface data pointer (drv_priv) to the
hostapd_iface structure. It then attempts to add a link by calling
hostapd_drv_link_add(). This call may fail under certain conditions,
such as ENETDOWN, EALREADY, or other transient errors.

In such failure cases, the hostapd interface retains a valid drv_priv
pointer, but no cleanup is performed. This results in an untracked
reference to the private driver interface data. While the memory backing
drv_priv will eventually be freed when the last interface sharing it is
deinitialized, the lack of cleanup in early failure paths can lead to
invalid memory access, potentially resulting in a segmentation fault.

Ensure that hostapd_deinit_driver() is invoked in both failure paths to
properly release driver resources and maintain consistency across
interface initialization routines.

Signed-off-by: Richard Yu <richard.yu@mitrastar.com.tw>

DPP: Conditionally add cipher support based on driver capabilities

By default, wpa_supplicant sets the pairwise and group ciphers to CCMP
(or CCMP+TKIP) when provisioning a network via DPP. As a result,
DPP-provisioned clients are unable to connect to networks that require
GCMP or GCMP-256 ciphers due to cipher mismatch. This issue does not
affect manually-configured network profiles, where supported cipher
suites can be explicitly specified.

Addresse the issue by conditionally enabling the appropriate cipher
suites in the DPP-generated network profile, based on driver
capabilities.

Tested on various chipsets with different cipher capabilities:

| Test ID | Wi-Fi Chipset     | Cipher Support     | AP Cipher | Result    |
|---------|-------------------|--------------------|-----------|-----------|
| TC-01   | Intel AX211       | GCMP-256, CCMP-128 | GCMP-256  | Success   |
| TC-02   | Legacy chipset    |           CCMP-128 | GCMP-256  | Failure   |
| TC-03   | Intel AX211       | GCMP-256, CCMP-128 | CCMP-128  | Success   |
| TC-04   | Legacy chipset    |           CCMP-128 | CCMP-128  | Success   |

Signed-off-by: Yan Zihan <zihan.yan10@gmail.com>

ACS: Fix using 20 MHz channels in 6 GHz

When configured to use ACS with 20 MHz channels, hostapd incorrectly
rejects half of the available channels with an error messages "Channel
XX: not allowed as primary channel for 40 MHz bandwidth." This includes
all PSC channels.

Signed-off-by: Matěj Vrba <matej.vrba@advantech.cz>
Reviewed-by: Nicolas Escande <nico.escande@gmail.com>

nl80211: Accept a global nl80211 event to a bridged interface

Global events originating/directed toward a bridged (i.e., WDS) station
are ignored by hostapd. These events are currently considered 'foreign'
and are dropped.

This problem was initially discovered while testing the configuration
parameter 'disassoc_low_ack=1' for bridged stations. It was observed
that the event 'STATION_LOW_ACK', communicated in
'NL80211_CMD_NOTIFY_CQM', would be ignored and the AP would fail to
disassociate the low ack station from the BSS.

Signed-off-by: Andrew Pope <andrew.pope@morsemicro.com>

dbus: Expose P2P auto_join behavior

It's useful, without it you need multiple tries to join an existing
group.

Signed-off-by: Emilio Cobos Álvarez <emilio@crisal.io>

RADIUS: Fix long extended type encoding

Using wpa_psk_radius=3 can lead to malformed RADIUS packets that do not
conform to the standard for "Long Extended Type" as defined in RFC 6929.

This was observed when using wpa_psk_radius=3 in conjunction with
wpa_key_mgmt=WPA-PSK FT-PSK that resulted in a RADIUS attribute for
245.26.11344.2 that was 256 octets in size. The expected outcome was two
fragments containing data sizes of 251 and 5 octets, but hostapd instead
created a fragment of 256 octets (exceeded the size limit) followed by a
fragment of 5 octets.

Fix the fragments preceding the final fragment to have the correct data
size by using alen instead of data_len when calling wpabuf_put_data().

Fixes: 24763e3cd0a5 ("RADIUS: Attributes with Extended Types (RFC 6929)")
Signed-off-by: Kellen Gattis <k3113n6@gmail.com>

ctrl_iface: Report all TBTT info elements from RNR

The existing code would only report the first TBTT entry of the first
RNR element. Add the code to first iterate all RNR elements and then
also iterate all TBTT entries for each AP information block.

Fixes: e3e68668c1f6 ("ctrl_iface: Report RNR and ML in BSS command")
Signed-off-by: Benjamin Berg <benjamin.berg@intel.com>
Reviewed-by: Andrei Otcheretianski <andrei.otcheretianski@intel.com>

tests: Verify RNR reporting in EHT discovery test

Add a bit more verification of the RNR that is reported by the
supplicant in the EHT discovery test.

Signed-off-by: Benjamin Berg <benjamin.berg@intel.com>
Reviewed-by: Andrei Otcheretianski <andrei.otcheretianski@intel.com>

tests: Try next tshark filter for UnknownFieldsException

The intention in commit cc35ed3e257a ("tests: Permit passing multiple
valid tshark filters") was to permit passing multiple filters in order
to permit compatibility with older tshark versions. However, this did
not work as expected for the UnknownFieldsException.

Fix that by storing it in last_exception as for other errors. This fixes
running some EHT tests with older tshark versions.

Signed-off-by: Benjamin Berg <benjamin.berg@intel.com>

tests: Fix pasn_sae_driver to clear PTKSA cache after first PASN exchange

The test pasn_sae_driver triggers PASN for the same peers twice. In the
current implementation, when PASN succeeds, the keys generated are
stored in the PTKSA cache.

The function wpas_pasn_configure_next_peer() shows an issue where it
does not reuse keys from a previous PASN exchange, even when those keys
are available in the cache. Instead, it initiates a new PASN exchange
unnecessarily.

Fix the test case by deleting the keys from the cache after the first
PASN attempt. This ensures a full PASN exchange can occur again. A
subsequent commit will address the API behavior to reuse keys from the
cache when available.

Signed-off-by: Peddolla Harshavardhan Reddy <peddolla@qti.qualcomm.com>

PASN: Reuse existing PTKSA cache keys instead of redoing PASN

When a successful PASN exchange has already occurred with a peer,
the derived keys are stored in the PTKSA cache. If another PASN
request is received for the same peer, these cached keys should
be reused. However, the cache was previously bypassed due to the
incorrect pairwise cipher argument.

Ensure the correct parameters are set in advance, from the RSNE data
allowing the cache to be used when appropriate.

Signed-off-by: Peddolla Harshavardhan Reddy <peddolla@qti.qualcomm.com>

nl80211: Provide AKM and cipher suite to PASN command

This is a step towards allowing the driver to initiate PASN
Authentication using user-preferred AKMP and cipher for secure ranging.

Signed-off-by: Peddolla Harshavardhan Reddy <peddolla@qti.qualcomm.com>

hostapd: Refactor usage of length macro(s)

For calculation ML STA profile, currently there are two macros,
EHT_ML_STA_INFO_LEN and EHT_ML_STA_INFO_LENGTH. Both points to same
length, hence remove the later and use EHT_ML_STA_INFO_LEN macro length
definition only.

Signed-off-by: Manish Dharanenthiran <manish.dharanenthiran@oss.qualcomm.com>

AP MLD: Include BPCC only in (Re)Associtiation Response frames

Currently in ML Probe response, the per-STA Profile STA control has BSS
Parameters Change Count (BPCC) present by default for all frames.

As per IEEE P802.11be/D7.0, 9.4.2.322.2.4, AP sets this field to 1 in
(Re)Association Response frame and sets to 0 in other frames.

Hence, update this by including the BPCC present bitmask and BPCC value
in STA Info field for ML (Re)Association Response frames only. However,
since this seems to break interoperability with the current mac80211
implementation for processing Link Reconfiguration Response frames,
leave BPCC present in the Basic MLE in those frames as a workaround for
now.

Signed-off-by: Mohan Kumar G <mkumarg@qti.qualcomm.com>
Signed-off-by: Yuvarani V <yuvarani@qti.qualcomm.com>
Signed-off-by: Manish Dharanenthiran <manish.dharanenthiran@oss.qualcomm.com>
---
 doc/dbus.doxygen                            |    1 +
 hostapd/ctrl_iface.c                        |   45 +-
 src/ap/acs.c                                |   25 +-
 src/ap/ap_config.c                          |    7 +
 src/ap/ap_drv_ops.c                         |   29 +-
 src/ap/ap_drv_ops.h                         |    2 +
 src/ap/beacon.c                             |    5 +-
 src/ap/ctrl_iface_ap.c                      |   23 +
 src/ap/drv_callbacks.c                      |   51 +-
 src/ap/hostapd.c                            |   29 +-
 src/ap/hostapd.h                            |    2 +
 src/ap/ieee802_11.c                         |  140 +-
 src/ap/ieee802_11.h                         |   52 +-
 src/ap/ieee802_11_eht.c                     | 1317 ++++++++++++++++++-
 src/ap/sta_info.c                           |    5 +-
 src/ap/sta_info.h                           |    1 +
 src/ap/wnm_ap.c                             |    8 +-
 src/ap/wpa_auth.c                           |   24 +-
 src/ap/wpa_auth.h                           |    8 +
 src/ap/wpa_auth_glue.c                      |   10 +
 src/common/ieee802_11_defs.h                |   45 +
 src/common/qca-vendor.h                     |   45 +-
 src/common/wpa_common.c                     |    4 +
 src/common/wpa_ctrl.h                       |    4 +
 src/drivers/driver.h                        |   45 +-
 src/drivers/driver_atheros.c                |    2 +-
 src/drivers/driver_bsd.c                    |   21 +-
 src/drivers/driver_common.c                 |    1 +
 src/drivers/driver_hostap.c                 |    2 +-
 src/drivers/driver_nl80211.c                |  198 ++-
 src/drivers/driver_nl80211.h                |    5 +
 src/drivers/driver_nl80211_capa.c           |   13 +-
 src/drivers/driver_nl80211_event.c          |  111 +-
 src/p2p/p2p_pd.c                            |   27 +-
 src/radius/radius.c                         |    2 +-
 src/rsn_supp/wpa.c                          |   96 ++
 src/rsn_supp/wpa.h                          |    2 +
 tests/hwsim/example-wpa_supplicant.config   |    2 +
 tests/hwsim/test_eht.py                     |  100 +-
 tests/hwsim/test_pasn.py                    |    4 +
 tests/hwsim/tshark.py                       |    8 +-
 wpa_supplicant/ctrl_iface.c                 |  230 +++-
 wpa_supplicant/dbus/dbus_new.c              |    2 +-
 wpa_supplicant/dbus/dbus_new_handlers_p2p.c |    7 +-
 wpa_supplicant/dpp_supplicant.c             |   15 +
 wpa_supplicant/driver_i.h                   |   10 +
 wpa_supplicant/events.c                     |   74 ++
 wpa_supplicant/op_classes.c                 |    3 +-
 wpa_supplicant/p2p_supplicant.c             |   19 +-
 wpa_supplicant/pasn_supplicant.c            |   12 +-
 wpa_supplicant/sme.c                        |   13 +-
 wpa_supplicant/wpa_cli.c                    |   10 +
 wpa_supplicant/wpa_supplicant.c             |   14 +
 wpa_supplicant/wpa_supplicant_i.h           |    1 +
 54 files changed, 2695 insertions(+), 236 deletions(-)

diff --git a/doc/dbus.doxygen b/doc/dbus.doxygen
index 473603a1f..2af405f2c 100644
--- a/doc/dbus.doxygen
+++ b/doc/dbus.doxygen
@@ -1806,6 +1806,7 @@ Interface for performing P2P (Wi-Fi Peer-to-Peer) P2P Device operations.
 	<tr><td>peer</td><td>o</td><td></td><td>yes</td></tr>
 	<tr><td>persistent</td><td>b</td><td>Whether to form a persistent group.</td><td>no</td></tr>
 	<tr><td>join</td><td>b</td><td>Whether to join an already operating group instead of forming a new group.</td><td>no</td></tr>
+	<tr><td>auto_join</td><td>b</td><td>Automatically choose between joining an already operating group or forming a new group.</td><td>no</td></tr>
 	<tr><td>authorize_only</td><td>b</td><td>Whether to authorize a peer to initiate GO Negotiation instead of initiating immediately.</td><td>no</td></tr>
 	<tr><td>frequency</td><td>i</td><td>Operating frequency in MHz</td><td>no</td></tr>
 	<tr><td>go_intent</td><td>i</td><td>GO intent 0-15</td><td>no</td></tr>
diff --git a/hostapd/ctrl_iface.c b/hostapd/ctrl_iface.c
index 2edce5ae3..3b410ac77 100644
--- a/hostapd/ctrl_iface.c
+++ b/hostapd/ctrl_iface.c
@@ -2431,10 +2431,36 @@ static int hostapd_ctrl_register_frame(struct hostapd_data *hapd,
 
 #ifdef NEED_AP_MLME
 
+static struct hostapd_hw_modes * get_target_hw_mode(struct hostapd_iface *iface,
+						    int freq)
+{
+	int i;
+	enum hostapd_hw_mode target_mode;
+	bool is_6ghz = is_6ghz_freq(freq);
+
+	if (freq < 4000)
+		target_mode = HOSTAPD_MODE_IEEE80211G;
+	else if (freq > 50000)
+		target_mode = HOSTAPD_MODE_IEEE80211AD;
+	else
+		target_mode = HOSTAPD_MODE_IEEE80211A;
+
+	for (i = 0; i < iface->num_hw_features; i++) {
+		struct hostapd_hw_modes *mode;
+
+		mode = &iface->hw_features[i];
+		if (mode->mode == target_mode && mode->is_6ghz == is_6ghz)
+			return mode;
+	}
+
+	return NULL;
+}
+
+
 static bool
-hostapd_ctrl_is_freq_in_cmode(struct hostapd_hw_modes *mode,
-			      struct hostapd_multi_hw_info *current_hw_info,
-			      int freq)
+hostapd_ctrl_is_freq_in_mode(struct hostapd_hw_modes *mode,
+			     struct hostapd_multi_hw_info *current_hw_info,
+			     int freq)
 {
 	struct hostapd_channel_data *chan;
 	int i;
@@ -2651,6 +2677,7 @@ static int hostapd_ctrl_iface_chan_switch(struct hostapd_iface *iface,
 {
 #ifdef NEED_AP_MLME
 	struct csa_settings settings;
+	struct hostapd_hw_modes *target_mode;
 	int ret;
 	int dfs_range = 0;
 	unsigned int i;
@@ -2669,10 +2696,16 @@ static int hostapd_ctrl_iface_chan_switch(struct hostapd_iface *iface,
 		settings.link_id = iface->bss[0]->mld_link_id;
 #endif /* CONFIG_IEEE80211BE */
 
+	target_mode = get_target_hw_mode(iface, settings.freq_params.freq);
+	if (!target_mode) {
+		wpa_printf(MSG_DEBUG,
+			   "chanswitch: Invalid frequency settings provided for hw mode");
+		return -1;
+	}
+
 	if (iface->num_hw_features > 1 &&
-	    !hostapd_ctrl_is_freq_in_cmode(iface->current_mode,
-					   iface->current_hw_info,
-					   settings.freq_params.freq)) {
+	    !hostapd_ctrl_is_freq_in_mode(target_mode, iface->current_hw_info,
+					  settings.freq_params.freq)) {
 		wpa_printf(MSG_INFO,
 			   "chanswitch: Invalid frequency settings provided for multi band phy");
 		return -1;
diff --git a/src/ap/acs.c b/src/ap/acs.c
index 44d083684..5dd57225c 100644
--- a/src/ap/acs.c
+++ b/src/ap/acs.c
@@ -889,10 +889,9 @@ acs_find_ideal_chan_mode(struct hostapd_iface *iface,
 
 		/* HT40 on 5 GHz has a limited set of primary channels as per
 		 * 11n Annex J */
-		if (mode->mode == HOSTAPD_MODE_IEEE80211A &&
-		    ((iface->conf->ieee80211n &&
-		      iface->conf->secondary_channel) ||
-		     is_6ghz_freq(chan->freq)) &&
+		if (bw == 40 &&
+		    mode->mode == HOSTAPD_MODE_IEEE80211A &&
+		    iface->conf->ieee80211n &&
 		    !acs_usable_bw_chan(chan, ACS_BW40)) {
 			wpa_printf(MSG_DEBUG,
 				   "ACS: Channel %d: not allowed as primary channel for 40 MHz bandwidth",
@@ -903,18 +902,14 @@ acs_find_ideal_chan_mode(struct hostapd_iface *iface,
 		if (mode->mode == HOSTAPD_MODE_IEEE80211A &&
 		    (iface->conf->ieee80211ac || iface->conf->ieee80211ax ||
 		     iface->conf->ieee80211be)) {
-			if (hostapd_get_oper_chwidth(iface->conf) ==
-			    CONF_OPER_CHWIDTH_80MHZ &&
-			    !acs_usable_bw_chan(chan, ACS_BW80)) {
+			if (bw == 80 && !acs_usable_bw_chan(chan, ACS_BW80)) {
 				wpa_printf(MSG_DEBUG,
 					   "ACS: Channel %d: not allowed as primary channel for 80 MHz bandwidth",
 					   chan->chan);
 				continue;
 			}
 
-			if (hostapd_get_oper_chwidth(iface->conf) ==
-			    CONF_OPER_CHWIDTH_160MHZ &&
-			    !acs_usable_bw_chan(chan, ACS_BW160)) {
+			if (bw == 160 && !acs_usable_bw_chan(chan, ACS_BW160)) {
 				wpa_printf(MSG_DEBUG,
 					   "ACS: Channel %d: not allowed as primary channel for 160 MHz bandwidth",
 					   chan->chan);
@@ -924,10 +919,14 @@ acs_find_ideal_chan_mode(struct hostapd_iface *iface,
 
 		if (mode->mode == HOSTAPD_MODE_IEEE80211A &&
 		    iface->conf->ieee80211be) {
-			if (hostapd_get_oper_chwidth(iface->conf) ==
-			    CONF_OPER_CHWIDTH_320MHZ &&
-			    !acs_usable_bw320_chan(iface, chan, &bw320_offset))
+			if (bw == 320 &&
+			    !acs_usable_bw320_chan(iface, chan,
+						   &bw320_offset)) {
+				wpa_printf(MSG_DEBUG,
+					   "ACS: Channel %d: not allowed as primary channel for 320 MHz bandwidth",
+					   chan->chan);
 				continue;
+			}
 		}
 
 		factor = 0;
diff --git a/src/ap/ap_config.c b/src/ap/ap_config.c
index bbf8a7ba8..5b47f7da0 100644
--- a/src/ap/ap_config.c
+++ b/src/ap/ap_config.c
@@ -1485,6 +1485,7 @@ static int hostapd_config_check_bss(struct hostapd_bss_config *bss,
 #ifdef CONFIG_IEEE80211BE
 	if (full_config && !bss->disable_11be && bss->disable_11ax) {
 		bss->disable_11be = true;
+		bss->mld_ap = 0;
 		wpa_printf(MSG_INFO,
 			   "Disabling IEEE 802.11be as IEEE 802.11ax is disabled for this BSS");
 	}
@@ -1495,6 +1496,12 @@ static int hostapd_config_check_bss(struct hostapd_bss_config *bss,
 		wpa_printf(MSG_INFO,
 			   "Enabling beacon protection as IEEE 802.11be is enabled for this BSS");
 	}
+
+	if ((!conf->ieee80211be || bss->disable_11be) && bss->mld_ap) {
+		wpa_printf(MSG_INFO,
+			   "Cannot enable mld_ap when IEEE 802.11be is disabled");
+		return -1;
+	}
 #endif /* CONFIG_IEEE80211BE */
 
 	if (full_config && bss->ignore_broadcast_ssid && conf->mbssid) {
diff --git a/src/ap/ap_drv_ops.c b/src/ap/ap_drv_ops.c
index b2e930de9..aeae0af20 100644
--- a/src/ap/ap_drv_ops.c
+++ b/src/ap/ap_drv_ops.c
@@ -924,20 +924,23 @@ int hostapd_drv_sta_disassoc(struct hostapd_data *hapd,
 			     const u8 *addr, int reason)
 {
 	const u8 *own_addr = hapd->own_addr;
+	int link_id = -1;
 
 #ifdef CONFIG_IEEE80211BE
 	if (hapd->conf->mld_ap) {
 		struct sta_info *sta = ap_get_sta(hapd, addr);
 
-		if (ap_sta_is_mld(hapd, sta))
+		if (ap_sta_is_mld(hapd, sta)) {
 			own_addr = hapd->mld->mld_addr;
+			link_id = hapd->mld_link_id;
+		}
 	}
 #endif /* CONFIG_IEEE80211BE */
 
 	if (!hapd->driver || !hapd->driver->sta_disassoc || !hapd->drv_priv)
 		return 0;
 	return hapd->driver->sta_disassoc(hapd->drv_priv, own_addr, addr,
-					  reason);
+					  reason, link_id);
 }
 
 
@@ -1389,3 +1392,25 @@ int hostapd_add_pmkid(struct hostapd_data *hapd, const u8 *bssid, const u8 *pmk,
 
 	return hostapd_drv_add_pmkid(hapd, &params);
 }
+
+
+static int hostapd_drv_remove_pmkid(struct hostapd_data *hapd,
+				    struct wpa_pmkid_params *params)
+{
+	if (!hapd->driver || !hapd->driver->remove_pmkid || !hapd->drv_priv)
+		return 0;
+	return hapd->driver->remove_pmkid(hapd->drv_priv, params);
+}
+
+
+int hostapd_remove_pmkid(struct hostapd_data *hapd, const u8 *sta_addr,
+			 const u8 *pmkid)
+{
+	struct wpa_pmkid_params params;
+
+	os_memset(&params, 0, sizeof(params));
+	params.bssid = sta_addr;
+	params.pmkid = pmkid;
+
+	return hostapd_drv_remove_pmkid(hapd, &params);
+}
diff --git a/src/ap/ap_drv_ops.h b/src/ap/ap_drv_ops.h
index b52763628..1468697ed 100644
--- a/src/ap/ap_drv_ops.h
+++ b/src/ap/ap_drv_ops.h
@@ -492,5 +492,7 @@ int hostapd_drv_add_pmkid(struct hostapd_data *hapd,
 			  struct wpa_pmkid_params *params);
 int hostapd_add_pmkid(struct hostapd_data *hapd, const u8 *bssid, const u8 *pmk,
 		      size_t pmk_len, const u8 *pmkid, int akmp);
+int hostapd_remove_pmkid(struct hostapd_data *hapd, const u8 *sta_addr,
+			 const u8 *pmkid);
 
 #endif /* AP_DRV_OPS */
diff --git a/src/ap/beacon.c b/src/ap/beacon.c
index 3bff0ae36..fd88ec93e 100644
--- a/src/ap/beacon.c
+++ b/src/ap/beacon.c
@@ -791,7 +791,8 @@ static size_t hostapd_probe_resp_elems_len(struct hostapd_data *hapd,
 
 		if (hapd_probed != hapd && hapd_probed->conf->mld_ap)
 			buflen += hostapd_eid_eht_basic_ml_len(hapd_probed,
-							       NULL, true);
+							       NULL, true,
+							       false);
 	}
 #endif /* CONFIG_IEEE80211BE */
 
@@ -957,7 +958,7 @@ static u8 * hostapd_probe_resp_fill_elems(struct hostapd_data *hapd,
 
 	if (hapd_probed != hapd && hapd_probed->conf->mld_ap)
 		pos = hostapd_eid_eht_basic_ml_common(hapd_probed, pos, NULL,
-						      true);
+						      true, false);
 #endif /* CONFIG_IEEE80211BE */
 
 #ifdef CONFIG_IEEE80211AC
diff --git a/src/ap/ctrl_iface_ap.c b/src/ap/ctrl_iface_ap.c
index 441995bcb..799aff765 100644
--- a/src/ap/ctrl_iface_ap.c
+++ b/src/ap/ctrl_iface_ap.c
@@ -1644,6 +1644,11 @@ int hostapd_disassoc_deny_mac(struct hostapd_data *hapd)
 	struct vlan_description vlan_id;
 
 	for (sta = hapd->sta_list; sta; sta = sta->next) {
+#ifdef CONFIG_IEEE80211BE
+		int link_id;
+		struct mld_link_info *info;
+#endif /* CONFIG_IEEE80211BE */
+
 		if (hostapd_maclist_found(hapd->conf->deny_mac,
 					  hapd->conf->num_deny_mac, sta->addr,
 					  &vlan_id) &&
@@ -1651,6 +1656,24 @@ int hostapd_disassoc_deny_mac(struct hostapd_data *hapd)
 		     !vlan_compare(&vlan_id, sta->vlan_desc)))
 			ap_sta_disconnect(hapd, sta, sta->addr,
 					  WLAN_REASON_UNSPECIFIED);
+#ifdef CONFIG_IEEE80211BE
+		for (link_id = 0; hapd->conf->mld_ap &&
+			     link_id < MAX_NUM_MLD_LINKS &&
+			     sta->mld_info.mld_sta; link_id++) {
+			info = &sta->mld_info.links[link_id];
+			if (!info->valid || link_id != hapd->mld_link_id)
+				continue;
+
+			if (hostapd_maclist_found(hapd->conf->deny_mac,
+						  hapd->conf->num_deny_mac,
+						  info->peer_addr,
+						  &vlan_id) &&
+			    (!vlan_id.notempty ||
+			     !vlan_compare(&vlan_id, sta->vlan_desc)))
+				ap_sta_disconnect(hapd, sta, sta->addr,
+						  WLAN_REASON_UNSPECIFIED);
+		}
+#endif /* CONFIG_IEEE80211BE */
 	}
 
 	return 0;
diff --git a/src/ap/drv_callbacks.c b/src/ap/drv_callbacks.c
index f3aeb2236..aebd52c0c 100644
--- a/src/ap/drv_callbacks.c
+++ b/src/ap/drv_callbacks.c
@@ -330,6 +330,7 @@ int hostapd_notif_assoc(struct hostapd_data *hapd, const u8 *addr,
 	struct hostapd_iface *iface = hapd->iface;
 #endif /* CONFIG_OWE */
 	bool updated = false;
+	bool driver_acl;
 
 	if (addr == NULL) {
 		/*
@@ -460,13 +461,56 @@ int hostapd_notif_assoc(struct hostapd_data *hapd, const u8 *addr,
 	 * ACL if the driver supports ACL offload to avoid potentially
 	 * conflicting ACL rules.
 	 */
-	if (hapd->iface->drv_max_acl_mac_addrs == 0 &&
+	driver_acl = hapd->iface->drv_max_acl_mac_addrs > 0;
+#ifdef CONFIG_IEEE80211BE
+	if (hapd->conf->mld_ap)
+		driver_acl = false;
+#endif /* CONFIG_IEEE80211BE */
+	if (!driver_acl &&
 	    hostapd_check_acl(hapd, addr, NULL) != HOSTAPD_ACL_ACCEPT) {
 		wpa_printf(MSG_INFO, "STA " MACSTR " not allowed to connect",
 			   MAC2STR(addr));
 		reason = WLAN_REASON_UNSPECIFIED;
 		goto fail;
 	}
+#ifdef CONFIG_IEEE80211BE
+	/*
+	 * The idea is that ACL is per link. For MLO associations, check
+	 * whether peer MLD MAC address is acceptable in all requested links.
+	 * For each peer link address, check the corresponding association
+	 * local link's ACL configuration whether it is acceptable.
+	 */
+	if (!driver_acl && hapd->conf->mld_ap && link_addr) {
+		int link_id;
+		struct mld_link_info *info;
+		struct hostapd_data *bss;
+
+		for (link_id = 0; link_id < MAX_NUM_MLD_LINKS; link_id++) {
+			info = &sta->mld_info.links[link_id];
+			if (!info->valid)
+				continue;
+
+			bss = hostapd_mld_get_link_bss(hapd, link_id);
+			if (bss != hapd &&
+			    hostapd_check_acl(bss, addr, NULL) !=
+			    HOSTAPD_ACL_ACCEPT) {
+				wpa_printf(MSG_INFO, "STA " MACSTR
+					   " not allowed to connect",
+					   MAC2STR(addr));
+				reason = WLAN_REASON_UNSPECIFIED;
+				goto fail;
+			}
+			if (hostapd_check_acl(bss, info->peer_addr, NULL) !=
+			    HOSTAPD_ACL_ACCEPT) {
+				wpa_printf(MSG_INFO, "link addr" MACSTR
+					   " not allowed to connect",
+					   MAC2STR(info->peer_addr));
+				reason = WLAN_REASON_UNSPECIFIED;
+				goto fail;
+			}
+		}
+	}
+#endif /* CONFIG_IEEE80211BE */
 
 #ifdef CONFIG_P2P
 	if (elems.p2p) {
@@ -979,9 +1023,8 @@ static void hostapd_remove_sta(struct hostapd_data *hapd, struct sta_info *sta)
 
 
 #ifdef CONFIG_IEEE80211BE
-static void hostapd_notif_disassoc_mld(struct hostapd_data *assoc_hapd,
-				       struct sta_info *sta,
-				       const u8 *addr)
+void hostapd_notif_disassoc_mld(struct hostapd_data *assoc_hapd,
+				struct sta_info *sta, const u8 *addr)
 {
 	unsigned int link_id, i;
 	struct hostapd_data *tmp_hapd;
diff --git a/src/ap/hostapd.c b/src/ap/hostapd.c
index 049777b0a..6c4513615 100644
--- a/src/ap/hostapd.c
+++ b/src/ap/hostapd.c
@@ -558,9 +558,9 @@ void hostapd_free_hapd_data(struct hostapd_data *hapd)
 	wpabuf_free(hapd->time_adv);
 	hapd->time_adv = NULL;
 
-#ifdef CONFIG_INTERWORKING
+#if defined(CONFIG_INTERWORKING) || defined(CONFIG_DPP)
 	gas_serv_deinit(hapd);
-#endif /* CONFIG_INTERWORKING */
+#endif /* CONFIG_INTERWORKING || CONFIG_DPP */
 
 	bss_load_update_deinit(hapd);
 	ndisc_snoop_deinit(hapd);
@@ -1679,12 +1679,12 @@ setup_mld:
 		return -1;
 	}
 
-#ifdef CONFIG_INTERWORKING
+#if defined(CONFIG_INTERWORKING) || defined(CONFIG_DPP)
 	if (gas_serv_init(hapd)) {
 		wpa_printf(MSG_ERROR, "GAS server initialization failed");
 		return -1;
 	}
-#endif /* CONFIG_INTERWORKING */
+#endif /* CONFIG_INTERWORKING || CONFIG_DPP */
 
 	if (conf->qos_map_set_len &&
 	    hostapd_drv_set_qos_map(hapd, conf->qos_map_set,
@@ -1809,6 +1809,14 @@ int hostapd_set_acl(struct hostapd_data *hapd)
 	if (hapd->iface->drv_max_acl_mac_addrs == 0)
 		return 0;
 
+#ifdef CONFIG_IEEE80211BE
+	if (hapd->conf->mld_ap) {
+		wpa_printf(MSG_DEBUG,
+			   "Kernel doesn't support offloaded ACL for AP MLD. Use hostapd based ACL instead.");
+		return 0;
+	}
+#endif /* CONFIG_IEEE80211BE */
+
 	if (conf->macaddr_acl == DENY_UNLESS_ACCEPTED) {
 		accept_acl = 1;
 		err = hostapd_set_acl_list(hapd, conf->accept_mac,
@@ -3596,8 +3604,12 @@ int hostapd_enable_iface(struct hostapd_iface *hapd_iface)
 
 	if (hapd_iface->interfaces == NULL ||
 	    hapd_iface->interfaces->driver_init == NULL ||
-	    hapd_iface->interfaces->driver_init(hapd_iface))
+	    hapd_iface->interfaces->driver_init(hapd_iface)) {
+		hostapd_deinit_driver(hapd_iface->bss[0]->driver,
+				      hapd_iface->bss[0]->drv_priv,
+				      hapd_iface);
 		return -1;
+	}
 
 	if (hostapd_setup_interface(hapd_iface)) {
 		hostapd_deinit_driver(hapd_iface->bss[0]->driver,
@@ -3855,8 +3867,13 @@ int hostapd_add_iface(struct hapd_interfaces *interfaces, char *buf)
 		}
 
 		if (new_iface) {
-			if (interfaces->driver_init(hapd_iface))
+			if (interfaces->driver_init(hapd_iface)) {
+				hostapd_deinit_driver(
+					hapd_iface->bss[0]->driver,
+					hapd_iface->bss[0]->drv_priv,
+					hapd_iface);
 				goto fail;
+			}
 
 			if (hostapd_setup_interface(hapd_iface)) {
 				hostapd_deinit_driver(
diff --git a/src/ap/hostapd.h b/src/ap/hostapd.h
index c96db5065..f263a6cb7 100644
--- a/src/ap/hostapd.h
+++ b/src/ap/hostapd.h
@@ -818,6 +818,8 @@ int hostapd_notif_assoc(struct hostapd_data *hapd, const u8 *addr,
 			const u8 *req_ie, size_t req_ielen, const u8 *resp_ie,
 			size_t resp_ielen, const u8 *link_addr, int reassoc);
 void hostapd_notif_disassoc(struct hostapd_data *hapd, const u8 *addr);
+void hostapd_notif_disassoc_mld(struct hostapd_data *assoc_hapd,
+				struct sta_info *sta, const u8 *addr);
 void hostapd_event_sta_low_ack(struct hostapd_data *hapd, const u8 *addr);
 void hostapd_event_connect_failed_reason(struct hostapd_data *hapd,
 					 const u8 *addr, int reason_code);
diff --git a/src/ap/ieee802_11.c b/src/ap/ieee802_11.c
index ef5b4d243..866a1c1c8 100644
--- a/src/ap/ieee802_11.c
+++ b/src/ap/ieee802_11.c
@@ -3301,6 +3301,23 @@ static void handle_auth(struct hostapd_data *hapd,
 	if (res == HOSTAPD_ACL_PENDING)
 		return;
 
+#ifdef CONFIG_IEEE80211BE
+	if (mld_sta) {
+		res = ieee802_11_allowed_address(hapd, mgmt->sa,
+						 (const u8 *) mgmt, len,
+						 &rad_info);
+		if (res == HOSTAPD_ACL_REJECT) {
+			wpa_msg(hapd->msg_ctx, MSG_DEBUG,
+				"Ignore Authentication frame from " MACSTR
+				" due to ACL reject", MAC2STR(mgmt->sa));
+			resp = WLAN_STATUS_UNSPECIFIED_FAILURE;
+			goto fail;
+		}
+		if (res == HOSTAPD_ACL_PENDING)
+			return;
+	}
+#endif /* CONFIG_IEEE80211BE */
+
 #ifdef CONFIG_SAE
 	if (auth_alg == WLAN_AUTH_SAE && !from_queue &&
 	    (auth_transaction == 1 ||
@@ -4202,8 +4219,8 @@ static bool check_sa_query(struct hostapd_data *hapd, struct sta_info *sta,
 
 static int __check_assoc_ies(struct hostapd_data *hapd, struct sta_info *sta,
 			     const u8 *ies, size_t ies_len,
-			     struct ieee802_11_elems *elems, int reassoc,
-			     bool link)
+			     struct ieee802_11_elems *elems,
+			     enum link_parse_type type, bool link)
 {
 	int resp;
 	const u8 *wpa_ie;
@@ -4212,9 +4229,12 @@ static int __check_assoc_ies(struct hostapd_data *hapd, struct sta_info *sta,
 	struct hostapd_data *assoc_hapd;
 	struct sta_info *assoc_sta = NULL;
 
-	resp = check_ssid(hapd, sta, elems->ssid, elems->ssid_len);
-	if (resp != WLAN_STATUS_SUCCESS)
-		return resp;
+	if (type != LINK_PARSE_RECONF) {
+		resp = check_ssid(hapd, sta, elems->ssid, elems->ssid_len);
+		if (resp != WLAN_STATUS_SUCCESS)
+			return resp;
+	}
+
 	resp = check_wmm(hapd, sta, elems->wmm, elems->wmm_len);
 	if (resp != WLAN_STATUS_SUCCESS)
 		return resp;
@@ -4329,6 +4349,15 @@ static int __check_assoc_ies(struct hostapd_data *hapd, struct sta_info *sta,
 	}
 #endif /* CONFIG_P2P */
 
+	/* Link Reconfiguration Request frame for add link operation will not
+	 * have RSN and other security IEs. So, skip the checks.
+	 */
+	if (type == LINK_PARSE_RECONF) {
+		wpa_printf(MSG_DEBUG,
+			   "MLD: Skip security IE checks for Link Reconfiguration request");
+		goto skip_wpa_ies;
+	}
+
 	if ((hapd->conf->wpa & WPA_PROTO_RSN) && elems->rsn_ie) {
 		wpa_ie = elems->rsn_ie;
 		wpa_ie_len = elems->rsn_ie_len;
@@ -4441,7 +4470,7 @@ static int __check_assoc_ies(struct hostapd_data *hapd, struct sta_info *sta,
 
 #ifdef CONFIG_IEEE80211R_AP
 		if (sta->auth_alg == WLAN_AUTH_FT) {
-			if (!reassoc) {
+			if (type != LINK_PARSE_REASSOC) {
 				wpa_printf(MSG_DEBUG, "FT: " MACSTR " tried "
 					   "to use association (not "
 					   "re-association) with FT auth_alg",
@@ -4560,6 +4589,8 @@ static int __check_assoc_ies(struct hostapd_data *hapd, struct sta_info *sta,
 	} else
 		wpa_auth_sta_no_wpa(sta->wpa_sm);
 
+skip_wpa_ies:
+
 #ifdef CONFIG_P2P
 	if (ies && ies_len)
 		p2p_group_notif_assoc(hapd->p2p_group, sta->addr, ies, ies_len);
@@ -4614,7 +4645,8 @@ static int __check_assoc_ies(struct hostapd_data *hapd, struct sta_info *sta,
 #endif /* CONFIG_MBO */
 
 #if defined(CONFIG_FILS) && defined(CONFIG_OCV)
-	if (wpa_auth_uses_ocv(sta->wpa_sm) &&
+	if (type != LINK_PARSE_RECONF &&
+	    wpa_auth_uses_ocv(sta->wpa_sm) &&
 	    (sta->auth_alg == WLAN_AUTH_FILS_SK ||
 	     sta->auth_alg == WLAN_AUTH_FILS_SK_PFS ||
 	     sta->auth_alg == WLAN_AUTH_FILS_PK)) {
@@ -4693,7 +4725,8 @@ static int __check_assoc_ies(struct hostapd_data *hapd, struct sta_info *sta,
 
 
 static int check_assoc_ies(struct hostapd_data *hapd, struct sta_info *sta,
-			   const u8 *ies, size_t ies_len, int reassoc)
+			   const u8 *ies, size_t ies_len,
+			   enum link_parse_type type)
 {
 	struct ieee802_11_elems elems;
 
@@ -4704,15 +4737,14 @@ static int check_assoc_ies(struct hostapd_data *hapd, struct sta_info *sta,
 		return WLAN_STATUS_UNSPECIFIED_FAILURE;
 	}
 
-	return __check_assoc_ies(hapd, sta, ies, ies_len, &elems, reassoc,
-				 false);
+	return __check_assoc_ies(hapd, sta, ies, ies_len, &elems, type, false);
 }
 
 
 #ifdef CONFIG_IEEE80211BE
 
-static void ieee80211_ml_build_assoc_resp(struct hostapd_data *hapd,
-					  struct mld_link_info *link)
+void ieee80211_ml_build_assoc_resp(struct hostapd_data *hapd,
+				   struct mld_link_info *link)
 {
 	u8 buf[EHT_ML_MAX_STA_PROF_LEN];
 	u8 *p = buf;
@@ -4772,11 +4804,11 @@ out:
 }
 
 
-static int ieee80211_ml_process_link(struct hostapd_data *hapd,
-				     struct sta_info *origin_sta,
-				     struct mld_link_info *link,
-				     const u8 *ies, size_t ies_len,
-				     bool reassoc, bool offload)
+int ieee80211_ml_process_link(struct hostapd_data *hapd,
+			      struct sta_info *origin_sta,
+			      struct mld_link_info *link,
+			      const u8 *ies, size_t ies_len,
+			      enum link_parse_type type, bool offload)
 {
 	struct ieee802_11_elems elems;
 	struct wpabuf *mlbuf = NULL;
@@ -4808,23 +4840,27 @@ static int ieee80211_ml_process_link(struct hostapd_data *hapd,
 		goto out;
 	}
 
-	mlbuf = ieee802_11_defrag(elems.basic_mle, elems.basic_mle_len, true);
-	if (!mlbuf)
-		goto out;
+	if (type != LINK_PARSE_RECONF) {
+		mlbuf = ieee802_11_defrag(elems.basic_mle, elems.basic_mle_len,
+					  true);
+		if (!mlbuf)
+			goto out;
 
-	if (ieee802_11_parse_link_assoc_req(&elems, mlbuf, hapd->mld_link_id,
-					    true) == ParseFailed) {
-		wpa_printf(MSG_DEBUG,
-			   "MLD: link: Failed to parse association request Multi-Link element");
-		status = WLAN_STATUS_UNSPECIFIED_FAILURE;
-		goto out;
+		if (ieee802_11_parse_link_assoc_req(&elems, mlbuf,
+						    hapd->mld_link_id, true) ==
+		    ParseFailed) {
+			wpa_printf(MSG_DEBUG,
+				   "MLD: link: Failed to parse association request Multi-Link element");
+			status = WLAN_STATUS_UNSPECIFIED_FAILURE;
+			goto out;
+		}
 	}
 
 	sta->flags |= origin_sta->flags | WLAN_STA_ASSOC_REQ_OK;
 	sta->mld_assoc_link_id = origin_sta->mld_assoc_link_id;
 	ap_sta_set_mld(sta, true);
 
-	status = __check_assoc_ies(hapd, sta, NULL, 0, &elems, reassoc, true);
+	status = __check_assoc_ies(hapd, sta, NULL, 0, &elems, type, true);
 	if (status != WLAN_STATUS_SUCCESS) {
 		wpa_printf(MSG_DEBUG, "MLD: link: Element check failed");
 		goto out;
@@ -4836,6 +4872,11 @@ static int ieee80211_ml_process_link(struct hostapd_data *hapd,
 
 		li->resp_sta_profile = NULL;
 		li->resp_sta_profile_len = 0;
+
+		if (type == LINK_PARSE_RECONF && i == hapd->mld_link_id) {
+			os_memcpy(li->local_addr, hapd->own_addr, ETH_ALEN);
+			os_memcpy(li->peer_addr, link->peer_addr, ETH_ALEN);
+		}
 	}
 
 	if (!offload) {
@@ -4874,13 +4915,14 @@ static int ieee80211_ml_process_link(struct hostapd_data *hapd,
 
 	/* TODO: What other processing is required? */
 
-	if (!offload && add_associated_sta(hapd, sta, reassoc))
+	if (!offload &&
+	    add_associated_sta(hapd, sta, type == LINK_PARSE_REASSOC))
 		status = WLAN_STATUS_AP_UNABLE_TO_HANDLE_NEW_STA;
 out:
 	wpabuf_free(mlbuf);
 	link->status = status;
 
-	if (!offload)
+	if (!offload && type != LINK_PARSE_RECONF)
 		ieee80211_ml_build_assoc_resp(hapd, link);
 
 	wpa_printf(MSG_DEBUG, "MLD: link: status=%u", status);
@@ -4956,9 +4998,10 @@ int hostapd_process_assoc_ml_info(struct hostapd_data *hapd,
 			if (!offload)
 				ieee80211_ml_build_assoc_resp(hapd, link);
 		} else {
-			if (ieee80211_ml_process_link(bss, sta, link,
-						      ies, ies_len, reassoc,
-						      offload))
+			if (ieee80211_ml_process_link(
+				    bss, sta, link, ies, ies_len,
+				    reassoc ? LINK_PARSE_REASSOC :
+				    LINK_PARSE_ASSOC, offload))
 				ret = -1;
 		}
 	}
@@ -5853,7 +5896,8 @@ static void handle_assoc(struct hostapd_data *hapd,
 
 	/* followed by SSID and Supported rates; and HT capabilities if 802.11n
 	 * is used */
-	resp = check_assoc_ies(hapd, sta, pos, left, reassoc);
+	resp = check_assoc_ies(hapd, sta, pos, left,
+			       reassoc ? LINK_PARSE_REASSOC : LINK_PARSE_ASSOC);
 	if (resp != WLAN_STATUS_SUCCESS)
 		goto fail;
 #ifdef CONFIG_IEEE80211R_AP
@@ -6480,6 +6524,11 @@ static int handle_action(struct hostapd_data *hapd,
 		hostapd_handle_radio_measurement(hapd, (const u8 *) mgmt, len);
 		return 1;
 #endif /* CONFIG_NO_RRM */
+#ifdef CONFIG_IEEE80211BE
+	case WLAN_ACTION_PROTECTED_EHT:
+		ieee802_11_rx_protected_eht_action(hapd, mgmt, len);
+		return 1;
+#endif /* CONFIG_IEEE80211BE */
 	}
 
 	hostapd_logger(hapd, mgmt->sa, HOSTAPD_MODULE_IEEE80211,
@@ -7126,6 +7175,19 @@ static void handle_action_cb(struct hostapd_data *hapd,
 	}
 #endif /* CONFIG_HS20 */
 
+#ifdef CONFIG_IEEE80211BE
+	/* Frame header (24B) + Category (1B) + Action code (1B) +
+	 * Dialog token (1B) + Count (1B) + Status list (count * 3B)
+	 */
+	if (len >= IEEE80211_HDRLEN + 3 + 1 + 3 &&
+	    mgmt->u.action.category == WLAN_ACTION_PROTECTED_EHT &&
+	    mgmt->u.action.u.link_reconf_resp.action ==
+	    WLAN_PROT_EHT_LINK_RECONFIG_RESPONSE) {
+		hostapd_link_reconf_resp_tx_status(hapd, sta, mgmt, len, ok);
+		return;
+	}
+#endif /* CONFIG_IEEE80211BE */
+
 #ifndef CONFIG_NO_RRM
 	if (len < 24 + 5 + sizeof(*report))
 		return;
@@ -7675,6 +7737,11 @@ u8 * hostapd_eid_chsw_wrapper(struct hostapd_data *hapd, u8 *eid)
 	u8 *eid_len_offset;
 	int freq1;
 
+	if (!(hapd->iconf->ieee80211ac && !hapd->conf->disable_11ac) &&
+	    !(hapd->iconf->ieee80211ax && !hapd->conf->disable_11ax) &&
+	    !(hapd->iconf->ieee80211be && !hapd->conf->disable_11be))
+		return eid;
+
 	if (!hapd->cs_freq_params.channel ||
 	    (!hapd->cs_freq_params.vht_enabled &&
 	     !hapd->cs_freq_params.he_enabled &&
@@ -8500,9 +8567,8 @@ static size_t hostapd_eid_mbssid_elem_len(struct hostapd_data *hapd,
 		 * be in the frame body */
 		if (bss->conf->mld_ap &&
 		    (bss != hapd || frame_type != WLAN_FC_STYPE_PROBE_RESP))
-			nontx_profile_len += hostapd_eid_eht_basic_ml_len(bss,
-									  NULL,
-									  true);
+			nontx_profile_len += hostapd_eid_eht_basic_ml_len(
+				bss, NULL, true, false);
 #endif /* CONFIG_IEEE80211BE */
 
 		if (ie_count)
@@ -8677,7 +8743,7 @@ static u8 * hostapd_eid_mbssid_elem(struct hostapd_data *hapd, u8 *eid, u8 *end,
 		if (bss->conf->mld_ap &&
 		    (bss != hapd || frame_type != WLAN_FC_STYPE_PROBE_RESP))
 			eid = hostapd_eid_eht_basic_ml_common(bss, eid, NULL,
-							      true);
+							      true, false);
 #endif /* CONFIG_IEEE80211BE */
 		if (ie_count) {
 			*eid++ = WLAN_EID_EXTENSION;
diff --git a/src/ap/ieee802_11.h b/src/ap/ieee802_11.h
index da97c25e3..f1230da34 100644
--- a/src/ap/ieee802_11.h
+++ b/src/ap/ieee802_11.h
@@ -9,6 +9,8 @@
 #ifndef IEEE802_11_H
 #define IEEE802_11_H
 
+#include "utils/list.h"
+
 struct hostapd_iface;
 struct hostapd_data;
 struct sta_info;
@@ -24,6 +26,35 @@ struct sae_pk;
 struct sae_pt;
 struct sae_password_entry;
 struct mld_info;
+struct mld_link_info;
+
+enum link_parse_type {
+	LINK_PARSE_ASSOC,
+	LINK_PARSE_REASSOC,
+	LINK_PARSE_RECONF,
+};
+
+#define LINK_RECONF_GROUP_KDE_MAX_LEN 255
+
+struct link_reconf_req_info {
+	struct dl_list list;
+	u16 status;
+	u8 link_id;
+	u8 local_addr[ETH_ALEN];
+	u8 peer_addr[ETH_ALEN];
+	size_t sta_prof_len;
+	u8 sta_prof[];
+};
+
+struct link_reconf_req_list {
+	u8 sta_mld_addr[ETH_ALEN];
+	u8 dialog_token;
+	u16 links_add_ok;
+	u16 links_del_ok;
+	u16 new_valid_links;
+	struct dl_list del_req; /* list of struct link_reconf_req_info */
+	struct dl_list add_req; /* list of struct link_reconf_req_info */
+};
 
 int ieee802_11_mgmt(struct hostapd_data *hapd, const u8 *buf, size_t len,
 		    struct hostapd_frame_info *fi);
@@ -96,10 +127,10 @@ u8 * hostapd_eid_eht_ml_assoc(struct hostapd_data *hapd, struct sta_info *info,
 			      u8 *eid);
 u8 * hostapd_eid_eht_basic_ml_common(struct hostapd_data *hapd,
 				     u8 *eid, struct mld_info *mld_info,
-				     bool include_mld_id);
+				     bool include_mld_id, bool include_bpcc);
 size_t hostapd_eid_eht_basic_ml_len(struct hostapd_data *hapd,
 				    struct sta_info *info,
-				    bool include_mld_id);
+				    bool include_mld_id, bool include_pbcc);
 size_t hostapd_eid_eht_ml_beacon_len(struct hostapd_data *hapd,
 				     struct mld_info *info,
 				     bool include_mld_id);
@@ -272,4 +303,21 @@ int hostapd_process_assoc_ml_info(struct hostapd_data *hapd,
 				  bool reassoc, int tx_link_status,
 				  bool offload);
 
+void ml_deinit_link_reconf_req(struct link_reconf_req_list **req_list_ptr);
+int ieee80211_ml_process_link(struct hostapd_data *hapd,
+			      struct sta_info *origin_sta,
+			      struct mld_link_info *link,
+			      const u8 *ies, size_t ies_len,
+			      enum link_parse_type type, bool offload);
+void ieee80211_ml_build_assoc_resp(struct hostapd_data *hapd,
+				   struct mld_link_info *link);
+
+void ieee802_11_rx_protected_eht_action(struct hostapd_data *hapd,
+					const struct ieee80211_mgmt *mgmt,
+					size_t len);
+void hostapd_link_reconf_resp_tx_status(struct hostapd_data *hapd,
+					struct sta_info *sta,
+					const struct ieee80211_mgmt *mgmt,
+					size_t len, int ok);
+
 #endif /* IEEE802_11_H */
diff --git a/src/ap/ieee802_11_eht.c b/src/ap/ieee802_11_eht.c
index fe4d0ce56..6b844e4bf 100644
--- a/src/ap/ieee802_11_eht.c
+++ b/src/ap/ieee802_11_eht.c
@@ -8,10 +8,14 @@
 
 #include "utils/includes.h"
 #include "utils/common.h"
+#include "common/ocv.h"
+#include "common/wpa_ctrl.h"
 #include "crypto/crypto.h"
 #include "crypto/dh_groups.h"
 #include "hostapd.h"
 #include "sta_info.h"
+#include "ap_drv_ops.h"
+#include "wpa_auth.h"
 #include "ieee802_11.h"
 
 
@@ -445,9 +449,14 @@ void hostapd_get_eht_capab(struct hostapd_data *hapd,
  * EML Capabilities (2) + MLD Capabilities (2)
  */
 #define EHT_ML_COMMON_INFO_LEN 13
+/*
+ * control (2) + station info length (1) + MAC address (6) +
+ * beacon interval (2) + TSF offset (8) + DTIM info (2)
+ */
+#define EHT_ML_STA_INFO_LEN 21
 u8 * hostapd_eid_eht_basic_ml_common(struct hostapd_data *hapd,
 				     u8 *eid, struct mld_info *mld_info,
-				     bool include_mld_id)
+				     bool include_mld_id, bool include_bpcc)
 {
 	struct wpabuf *buf;
 	u16 control;
@@ -523,6 +532,8 @@ u8 * hostapd_eid_eht_basic_ml_common(struct hostapd_data *hapd,
 	/* TODO: Advertise T2LM based on driver support as well */
 	mld_cap &= ~EHT_ML_MLD_CAPA_TID_TO_LINK_MAP_NEG_SUPP_MSK;
 
+	mld_cap |= EHT_ML_MLD_CAPA_LINK_RECONF_OP_SUPPORT;
+
 	wpa_printf(MSG_DEBUG, "MLD: MLD Capabilities and Operations=0x%x",
 		   mld_cap);
 	wpabuf_put_le16(buf, mld_cap);
@@ -539,16 +550,9 @@ u8 * hostapd_eid_eht_basic_ml_common(struct hostapd_data *hapd,
 	/* Add link info for the other links */
 	for (link_id = 0; link_id < MAX_NUM_MLD_LINKS; link_id++) {
 		struct mld_link_info *link = &mld_info->links[link_id];
+		size_t sta_info_len = EHT_ML_STA_INFO_LEN;
 		struct hostapd_data *link_bss;
-
-		/*
-		 * control (2) + station info length (1) + MAC address (6) +
-		 * beacon interval (2) + TSF offset (8) + DTIM info (2) + BSS
-		 * parameters change counter (1) + station profile length.
-		 */
-#define EHT_ML_STA_INFO_LEN 22
-		size_t total_len = EHT_ML_STA_INFO_LEN +
-			link->resp_sta_profile_len;
+		size_t total_len;
 
 		/* Skip the local one */
 		if (link_id == hapd->mld_link_id || !link->valid)
@@ -561,6 +565,13 @@ u8 * hostapd_eid_eht_basic_ml_common(struct hostapd_data *hapd,
 			continue;
 		}
 
+		/* BSS Parameters Change Count (1) for (Re)Association Response
+		 * frames */
+		if (include_bpcc)
+			sta_info_len++;
+
+		total_len = sta_info_len + link->resp_sta_profile_len;
+
 		/* Per-STA Profile subelement */
 		wpabuf_put_u8(buf, EHT_ML_SUB_ELEM_PER_STA_PROFILE);
 
@@ -575,14 +586,17 @@ u8 * hostapd_eid_eht_basic_ml_common(struct hostapd_data *hapd,
 			EHT_PER_STA_CTRL_COMPLETE_PROFILE_MSK |
 			EHT_PER_STA_CTRL_TSF_OFFSET_PRESENT_MSK |
 			EHT_PER_STA_CTRL_BEACON_INTERVAL_PRESENT_MSK |
-			EHT_PER_STA_CTRL_DTIM_INFO_PRESENT_MSK |
-			EHT_PER_STA_CTRL_BSS_PARAM_CNT_PRESENT_MSK;
+			EHT_PER_STA_CTRL_DTIM_INFO_PRESENT_MSK;
+
+		if (include_bpcc)
+			control |= EHT_PER_STA_CTRL_BSS_PARAM_CNT_PRESENT_MSK;
+
 		wpabuf_put_le16(buf, control);
 
 		/* STA Info */
 
 		/* STA Info Length */
-		wpabuf_put_u8(buf, EHT_ML_STA_INFO_LEN - 2);
+		wpabuf_put_u8(buf, sta_info_len - 2);
 		wpabuf_put_data(buf, link->local_addr, ETH_ALEN);
 		wpabuf_put_le16(buf, link_bss->iconf->beacon_int);
 
@@ -598,7 +612,8 @@ u8 * hostapd_eid_eht_basic_ml_common(struct hostapd_data *hapd,
 		wpabuf_put_u8(buf, link_bss->conf->dtim_period);
 
 		/* BSS Parameters Change Count */
-		wpabuf_put_u8(buf, hapd->eht_mld_bss_param_change);
+		if (include_bpcc)
+			wpabuf_put_u8(buf, hapd->eht_mld_bss_param_change);
 
 		if (!link->resp_sta_profile)
 			continue;
@@ -611,7 +626,7 @@ u8 * hostapd_eid_eht_basic_ml_common(struct hostapd_data *hapd,
 			ptr = link->resp_sta_profile;
 			len = link->resp_sta_profile_len;
 
-			slice_len = 255 - EHT_ML_STA_INFO_LEN;
+			slice_len = 255 - sta_info_len;
 
 			wpabuf_put_data(buf, ptr, slice_len);
 			len -= slice_len;
@@ -672,15 +687,9 @@ out:
 }
 
 
-/*
- * control (2) + station info length (1) + MAC address (6) +
- * beacon interval (2) + TSF offset (8) + DTIM info (2) + BSS
- * parameters change counter (1)
- */
-#define EHT_ML_STA_INFO_LENGTH 22
 size_t hostapd_eid_eht_basic_ml_len(struct hostapd_data *hapd,
 				    struct sta_info *info,
-				    bool include_mld_id)
+				    bool include_mld_id, bool include_bpcc)
 {
 	int link_id;
 	size_t len, num_frags;
@@ -704,7 +713,7 @@ size_t hostapd_eid_eht_basic_ml_len(struct hostapd_data *hapd,
 	for (link_id = 0; link_id < MAX_NUM_MLD_LINKS; link_id++) {
 		struct mld_link_info *link = &info->mld_info.links[link_id];
 		struct hostapd_data *link_bss;
-		size_t sta_prof_len = EHT_ML_STA_INFO_LENGTH +
+		size_t sta_prof_len = EHT_ML_STA_INFO_LEN +
 			link->resp_sta_profile_len;
 
 		/* Skip the local one */
@@ -718,6 +727,11 @@ size_t hostapd_eid_eht_basic_ml_len(struct hostapd_data *hapd,
 			continue;
 		}
 
+		/* BSS Parameters Change Count (1) for (Re)Association Response
+		 * frames */
+		if (include_bpcc)
+			sta_prof_len++;
+
 		/* Per-STA Profile Subelement(1), Length (1) */
 		len += 2;
 		len += sta_prof_len;
@@ -816,7 +830,7 @@ static u8 * hostapd_eid_eht_reconf_ml(struct hostapd_data *hapd, u8 *eid)
 
 
 static size_t hostapd_eid_eht_ml_len(struct mld_info *info,
-				     bool include_mld_id)
+				     bool include_mld_id, bool include_bpcc)
 {
 	size_t len = 0;
 	size_t eht_ml_len = 2 + EHT_ML_COMMON_INFO_LEN;
@@ -836,6 +850,11 @@ static size_t hostapd_eid_eht_ml_len(struct mld_info *info,
 
 		sta_len += link->resp_sta_profile_len;
 
+		/* BSS Parameters Change Count (1) for (Re)Association Response
+		 * frames */
+		if (include_bpcc)
+			sta_len++;
+
 		/* Element data and (fragmentation) headers */
 		eht_ml_len += sta_len;
 		eht_ml_len += 2 + sta_len / 255 * 2;
@@ -860,7 +879,8 @@ u8 * hostapd_eid_eht_ml_beacon(struct hostapd_data *hapd,
 			       struct mld_info *info,
 			       u8 *eid, bool include_mld_id)
 {
-	eid = hostapd_eid_eht_basic_ml_common(hapd, eid, info, include_mld_id);
+	eid = hostapd_eid_eht_basic_ml_common(hapd, eid, info, include_mld_id,
+					      false);
 	return hostapd_eid_eht_reconf_ml(hapd, eid);
 }
 
@@ -873,7 +893,7 @@ u8 * hostapd_eid_eht_ml_assoc(struct hostapd_data *hapd, struct sta_info *info,
 		return eid;
 
 	eid = hostapd_eid_eht_basic_ml_common(hapd, eid, &info->mld_info,
-					      false);
+					      false, true);
 	ap_sta_free_sta_profile(&info->mld_info);
 	return hostapd_eid_eht_reconf_ml(hapd, eid);
 }
@@ -883,7 +903,7 @@ size_t hostapd_eid_eht_ml_beacon_len(struct hostapd_data *hapd,
 				     struct mld_info *info,
 				     bool include_mld_id)
 {
-	return hostapd_eid_eht_ml_len(info, include_mld_id);
+	return hostapd_eid_eht_ml_len(info, include_mld_id, false);
 }
 
 
@@ -1498,3 +1518,1246 @@ out:
 
 	return WLAN_STATUS_SUCCESS;
 }
+
+
+void ml_deinit_link_reconf_req(struct link_reconf_req_list **req_list_ptr)
+{
+	struct link_reconf_req_list *req_list;
+	struct link_reconf_req_info *info, *tmp;
+
+	if (!(*req_list_ptr))
+		return;
+
+	wpa_printf(MSG_DEBUG, "MLD: Deinit Link Reconf Request context");
+
+	req_list = *req_list_ptr;
+
+	dl_list_for_each_safe(info, tmp, &req_list->add_req,
+			      struct link_reconf_req_info, list) {
+		dl_list_del(&info->list);
+		os_free(info);
+	}
+
+	dl_list_for_each_safe(info, tmp, &req_list->del_req,
+			      struct link_reconf_req_info, list) {
+		dl_list_del(&info->list);
+		os_free(info);
+	}
+
+	os_free(req_list);
+	*req_list_ptr = NULL;
+}
+
+
+void hostapd_link_reconf_resp_tx_status(struct hostapd_data *hapd,
+					struct sta_info *sta,
+					const struct ieee80211_mgmt *mgmt,
+					size_t len, int ok)
+{
+	u8 dialog_token = mgmt->u.action.u.link_reconf_resp.dialog_token;
+	struct hostapd_data *assoc_hapd, *lhapd, *other_hapd;
+	struct sta_info *assoc_sta, *lsta, *other_sta;
+	struct link_reconf_req_list *req_list;
+	struct link_reconf_req_info *info;
+	uint8_t link_id;
+
+	wpa_printf(MSG_DEBUG,
+		   "MLD: Link Reconf Response TX status - dialog token=%u ok=%d",
+		   dialog_token, ok);
+
+	assoc_sta = hostapd_ml_get_assoc_sta(hapd, sta, &assoc_hapd);
+	if (!assoc_sta) {
+		wpa_printf(MSG_INFO, "MLD: Assoc STA not found for " MACSTR,
+			   MAC2STR(mgmt->da));
+		return;
+	}
+
+	if (!assoc_sta->reconf_req) {
+		wpa_printf(MSG_DEBUG,
+			   "MLD: Unexpected Link Reconf Request TX status");
+		return;
+	}
+
+	req_list = assoc_sta->reconf_req;
+
+	if (!ether_addr_equal(mgmt->da, req_list->sta_mld_addr)) {
+		wpa_printf(MSG_DEBUG,
+			   "MLD: Link Reconfiguration Response TX status from wrong STA");
+		return;
+	}
+
+	if (dialog_token != req_list->dialog_token) {
+		wpa_printf(MSG_DEBUG,
+			   "MLD: Link Reconfiguration session expired for %u",
+			   dialog_token);
+		return;
+	}
+
+	if (!ok) {
+		wpa_printf(MSG_INFO,
+			   "MLD: Link Reconf Response ack failed for " MACSTR
+			   "; revert link additions",
+			   MAC2STR(mgmt->da));
+
+		dl_list_for_each(info, &req_list->del_req,
+				 struct link_reconf_req_info, list) {
+			if (info->status != WLAN_STATUS_SUCCESS)
+				continue;
+
+			lhapd = NULL;
+			lsta = NULL;
+			lhapd = hostapd_mld_get_link_bss(hapd, info->link_id);
+			if (lhapd)
+				lsta = ap_get_sta(lhapd,
+						  req_list->sta_mld_addr);
+
+			if (lsta)
+				ap_free_sta(lhapd, lsta);
+		}
+		goto exit;
+	}
+
+	if (dl_list_empty(&req_list->del_req))
+		goto exit;
+
+	dl_list_for_each(info, &req_list->del_req, struct link_reconf_req_info,
+			 list) {
+		if (info->status != WLAN_STATUS_SUCCESS)
+			continue;
+
+		link_id = info->link_id;
+		lhapd = hostapd_mld_get_link_bss(hapd, link_id);
+		if (!lhapd) {
+			wpa_printf(MSG_INFO,
+				   "MLD: Link (%u) hapd cannot be NULL",
+				   link_id);
+			continue;
+		}
+
+		lsta = ap_get_sta(lhapd, mgmt->da);
+		if (!lsta) {
+			wpa_printf(MSG_INFO,
+				   "MLD: Link (%u) STA cannot be NULL",
+				   link_id);
+			continue;
+		}
+
+		/* Reassign assoc_sta to the link with lowest link ID */
+		if (!hostapd_sta_is_link_sta(lhapd, lsta) &&
+		    lsta == assoc_sta) {
+			struct mld_info *mld_info = &assoc_sta->mld_info;
+			int i;
+
+			for (i = 0; i < MAX_NUM_MLD_LINKS; i++) {
+				if (i == assoc_sta->mld_assoc_link_id ||
+				    !mld_info->links[i].valid ||
+				    req_list->links_del_ok & BIT(i)) {
+					continue;
+				}
+				break;
+			}
+
+			if (i == MAX_NUM_MLD_LINKS) {
+				wpa_printf(MSG_INFO,
+					   "MLD: No new assoc STA could be found; disconnect STA");
+				hostapd_notif_disassoc_mld(assoc_hapd, sta,
+							   sta->addr);
+				goto exit;
+			}
+			wpa_printf(MSG_DEBUG, "MLD: New assoc link=%d", i);
+
+			/* Reset wpa_auth and assoc link ID */
+			for_each_mld_link(other_hapd, lhapd) {
+				other_sta = ap_get_sta(other_hapd, mgmt->da);
+				if (other_sta)
+					other_sta->mld_assoc_link_id = i;
+			}
+
+			/* Reset reconfig request queue which will be freed
+			 * at the end */
+			assoc_sta->reconf_req = NULL;
+
+			/* assoc_sta switched */
+			assoc_sta = hostapd_ml_get_assoc_sta(lhapd, lsta,
+							     &assoc_hapd);
+
+			/* assoc_sta cannot be NULL since both AP and STA are
+			 * MLD and new valid assoc_sta is already found */
+			if (!assoc_sta)
+				goto exit;
+
+			if (assoc_hapd == lhapd) {
+				wpa_printf(MSG_ERROR,
+					   "MLD: assoc_hapd is not updated; please check");
+				goto exit;
+			}
+
+			assoc_sta->reconf_req = req_list;
+			wpa_reset_assoc_sm_info(assoc_sta->wpa_sm,
+						assoc_hapd->wpa_auth, i);
+		}
+
+		/* Free as a link STA */
+		ap_free_sta(lhapd, lsta);
+		wpa_msg(hapd->msg_ctx, MSG_INFO,
+			WPA_EVENT_LINK_STA_REMOVED "sta=" MACSTR " link_id=%u",
+			MAC2STR(lsta->addr), link_id);
+
+		for_each_mld_link(other_hapd, lhapd) {
+			struct mld_link_info *link;
+
+			other_sta = ap_get_sta(other_hapd, mgmt->da);
+			if (!other_sta)
+				continue;
+
+			link = &other_sta->mld_info.links[link_id];
+			os_free(link->resp_sta_profile);
+			link->resp_sta_profile = NULL;
+			link->resp_sta_profile_len = 0;
+			link->valid = false;
+		}
+		wpa_auth_set_ml_info(assoc_sta->wpa_sm,
+				     assoc_sta->mld_assoc_link_id,
+				     &assoc_sta->mld_info);
+	}
+
+exit:
+	ml_deinit_link_reconf_req(&req_list);
+	if (assoc_sta && assoc_sta->reconf_req)
+		assoc_sta->reconf_req = NULL;
+}
+
+
+static bool recover_from_zero_links(u16 *links_del_ok, u8 *recovery_link)
+{
+	u8 pos = 0;
+	u16 del_links;
+
+	del_links = *links_del_ok;
+
+	while (del_links) {
+		if (del_links & 1)
+			break;
+		del_links >>= 1;
+		pos++;
+	}
+
+	/* No link found */
+	if (!del_links) {
+		wpa_printf(MSG_DEBUG,
+			   "MLD: Total valid links is 0 and no del-link found to reject for recovery");
+		return false;
+	}
+
+	*recovery_link = pos;
+	*links_del_ok &= ~BIT(*recovery_link);
+	wpa_printf(MSG_INFO,
+		   "MLD: Del-link request for link (%u) rejected to recover from no remaining links",
+		   *recovery_link);
+	return true;
+}
+
+
+static u16
+hostapd_ml_process_reconf_link(struct hostapd_data *hapd,
+			       struct sta_info *assoc_sta, const u8 *ies,
+			       size_t ies_len, u8 link_id, const u8 *link_addr)
+{
+	struct hostapd_data *lhapd, *other_hapd;
+	struct mld_link_info link;
+	struct sta_info *lsta, *other_sta;
+
+	lhapd = hostapd_mld_get_link_bss(hapd, link_id);
+	if (!lhapd) /* This cannot be NULL */
+		return WLAN_STATUS_UNSPECIFIED_FAILURE;
+
+	os_memset(&link, 0, sizeof(link));
+
+	link.valid = 1;
+	os_memcpy(link.local_addr, lhapd->own_addr, ETH_ALEN);
+	os_memcpy(link.peer_addr, link_addr, ETH_ALEN);
+
+	/* Parse STA profile, check the IEs, and send ADD_LINK_STA */
+	ieee80211_ml_process_link(lhapd, assoc_sta, &link, ies, ies_len,
+				  LINK_PARSE_RECONF, false);
+	if (link.status != WLAN_STATUS_SUCCESS)
+		return link.status;
+
+	lsta = ap_get_sta(lhapd, assoc_sta->addr);
+	if (!lsta)
+		return WLAN_STATUS_AP_UNABLE_TO_HANDLE_NEW_STA;
+
+	for_each_mld_link(other_hapd, lhapd) {
+		struct mld_link_info *_link;
+
+		other_sta = ap_get_sta(other_hapd, lsta->addr);
+		if (!other_sta)
+			continue;
+
+		_link = &other_sta->mld_info.links[link_id];
+		_link->valid = true;
+		_link->status = WLAN_STATUS_SUCCESS;
+		os_memcpy(_link->local_addr, other_hapd->own_addr, ETH_ALEN);
+		os_memcpy(_link->peer_addr, link_addr, ETH_ALEN);
+	}
+	wpa_auth_set_ml_info(lsta->wpa_sm, lsta->mld_assoc_link_id,
+			     &lsta->mld_info);
+
+	return WLAN_STATUS_SUCCESS;
+}
+
+
+static int
+hostapd_reject_all_reconf_req(struct hostapd_data *hapd, u8 *pos,
+			      struct link_reconf_req_list *req_list)
+{
+	struct link_reconf_req_info *info;
+	struct hostapd_data *lhapd;
+	struct sta_info *lsta;
+	u16 status;
+	u8 *buf = pos;
+
+	dl_list_for_each(info, &req_list->add_req, struct link_reconf_req_info,
+			 list) {
+		lhapd = NULL;
+		lsta = NULL;
+		*pos++ = info->link_id;
+		status = info->status != WLAN_STATUS_SUCCESS ? info->status :
+			WLAN_STATUS_UNSPECIFIED_FAILURE;
+		WPA_PUT_LE16(pos, status);
+
+		if (info->status == WLAN_STATUS_SUCCESS) {
+			lhapd = hostapd_mld_get_link_bss(hapd, info->link_id);
+			if (lhapd)
+				lsta = ap_get_sta(lhapd,
+						  req_list->sta_mld_addr);
+
+			if (lsta)
+				ap_free_sta(lhapd, lsta);
+
+			info->status = WLAN_STATUS_UNSPECIFIED_FAILURE;
+		}
+		wpa_printf(MSG_DEBUG, "MLD: Reject add-link=%u with status=%u",
+			   info->link_id, status);
+		pos += 2;
+	}
+
+	dl_list_for_each(info, &req_list->del_req, struct link_reconf_req_info,
+			 list) {
+		*pos++ = info->link_id;
+		status = info->status != WLAN_STATUS_SUCCESS ? info->status :
+			WLAN_STATUS_UNSPECIFIED_FAILURE;
+		WPA_PUT_LE16(pos, status);
+
+		if (info->status == WLAN_STATUS_SUCCESS)
+			info->status = WLAN_STATUS_UNSPECIFIED_FAILURE;
+
+		wpa_printf(MSG_DEBUG, "MLD: Reject del-link=%u with status=%u",
+			   info->link_id, status);
+		pos += 2;
+	}
+
+	return pos - buf;
+}
+
+
+static int
+hostapd_send_link_reconf_resp(struct hostapd_data *hapd,
+			      struct sta_info *assoc_sta,
+			      struct link_reconf_req_list *req_list)
+{
+	u8 *buf, *orig_pos, *pos;
+	struct ieee80211_mgmt *mgmt;
+	struct link_reconf_req_info *info;
+	struct mld_info mld;
+	int ret;
+	unsigned int count;
+	u8 dialog_token;
+	bool reject_all = false;
+	size_t len, pos_len, kde_len, mle_len;
+
+	count = dl_list_len(&req_list->add_req) +
+		dl_list_len(&req_list->del_req);
+	if (!count)
+		return 0;
+
+	os_memset(&mld, 0, sizeof(mld));
+
+	dialog_token = req_list->dialog_token;
+
+	/*
+	 * Link Reconfiguration Response:
+	 *
+	 * IEEE80211 Header (24B) +
+	 * Category (1B) + Action code (1B) + Dialog Token (1B) +
+	 * Count (1B) + Status list (count * 3B) +
+	 * Optional: Group Key Data field (variable) +
+	 * Optional: OCI element (6B) +
+	 * Optional: Basic Multi-Link element (variable)
+	 */
+	len = IEEE80211_HDRLEN + 3 + 1 + count * 3;
+	kde_len = mle_len = 0;
+
+	if (req_list->links_add_ok) {
+		kde_len = wpa_auth_ml_group_kdes_len(
+			assoc_sta->wpa_sm, req_list->links_add_ok) + 1;
+		len += kde_len;
+
+		if (wpa_auth_uses_ocv(assoc_sta->wpa_sm))
+			len += OCV_OCI_EXTENDED_LEN;
+
+		mld.mld_sta = true;
+		dl_list_for_each(info, &req_list->add_req,
+				 struct link_reconf_req_info, list) {
+			struct mld_link_info *link = &mld.links[info->link_id];
+			struct hostapd_data *lhapd = NULL;
+
+			if (info->status != WLAN_STATUS_SUCCESS)
+				continue;
+
+			link->status = info->status;
+
+			lhapd = hostapd_mld_get_link_bss(hapd, info->link_id);
+			if (!lhapd)
+				continue;
+
+			link->valid = true;
+			ieee80211_ml_build_assoc_resp(lhapd, link);
+		}
+		/* TODO: Basic MLE is not supposed to include BPCC in Link
+		 * Reconfiguration Response, but mac80211 implementation for
+		 * processing this frame requires that to be present. For now,
+		 * include that subfield as a workaround. This should be removed
+		 * once mac80211 is fixed to match the standard (or this comment
+		 * be removed if the standard is modified to match
+		 * implementation). */
+		mle_len = hostapd_eid_eht_ml_len(&mld, false, true);
+		len += mle_len;
+	}
+
+	buf = os_zalloc(len);
+	if (!buf) {
+		wpa_printf(MSG_INFO,
+			   "MLD: Failed to allocate Link Reconf Response buffer (%zu bytes)",
+			   len);
+		return -1;
+	}
+
+	mgmt = (struct ieee80211_mgmt *) buf;
+	mgmt->frame_control = IEEE80211_FC(WLAN_FC_TYPE_MGMT,
+					   WLAN_FC_STYPE_ACTION);
+	os_memcpy(mgmt->da, assoc_sta->addr, ETH_ALEN);
+	os_memcpy(mgmt->sa, hapd->mld->mld_addr, ETH_ALEN);
+	os_memcpy(mgmt->bssid, hapd->mld->mld_addr, ETH_ALEN);
+
+	mgmt->u.action.category = WLAN_ACTION_PROTECTED_EHT;
+	mgmt->u.action.u.link_reconf_resp.action =
+		WLAN_PROT_EHT_LINK_RECONFIG_RESPONSE;
+	mgmt->u.action.u.link_reconf_resp.dialog_token = dialog_token;
+	mgmt->u.action.u.link_reconf_resp.count = count;
+
+	orig_pos = pos = mgmt->u.action.u.link_reconf_resp.variable;
+	pos_len = 28; /* IEEE80211 Header, category, code, token, count */
+
+	dl_list_for_each(info, &req_list->add_req, struct link_reconf_req_info,
+			 list) {
+		*pos++ = info->link_id;
+		WPA_PUT_LE16(pos, info->status);
+		pos += 2;
+		pos_len += 3;
+	}
+
+	dl_list_for_each(info, &req_list->del_req, struct link_reconf_req_info,
+			 list) {
+		/* Mark the status as INVALID for rejected link to recover */
+		if (!(req_list->links_del_ok & BIT(info->link_id)) &&
+		    info->status == WLAN_STATUS_SUCCESS)
+			info->status = WLAN_STATUS_UNSPECIFIED_FAILURE;
+
+		*pos++ = info->link_id;
+		WPA_PUT_LE16(pos, info->status);
+		pos += 2;
+		pos_len += 3;
+	}
+
+	if (!req_list->links_add_ok)
+		goto send_resp;
+
+	/* Key Data for add links */
+	if (kde_len) {
+		u8 *kde_pos = pos;
+
+		kde_pos = wpa_auth_ml_group_kdes(assoc_sta->wpa_sm, ++kde_pos,
+						 req_list->links_add_ok);
+		*pos = kde_pos - pos - 1;
+		if (kde_len - 1 != *pos) {
+			reject_all = true;
+			goto reject_all_req;
+		}
+
+		wpa_hexdump_key(MSG_DEBUG, "MLD: Group KDE", pos + 1, *pos);
+
+		pos += kde_len;
+		pos_len += kde_len;
+	}
+
+	/* OCI element for add links */
+	if (wpa_auth_uses_ocv(assoc_sta->wpa_sm)) {
+		struct wpa_channel_info ci;
+
+		if (hostapd_drv_channel_info(hapd, &ci)) {
+			wpa_printf(MSG_DEBUG,
+				   "MLD: Failed to fetch OCI; reject all requests");
+			reject_all = true;
+			goto reject_all_req;
+		}
+
+		if (ocv_insert_extended_oci(&ci, pos)) {
+			wpa_printf(MSG_DEBUG,
+				   "MLD: Failed to add OCI element; reject all requests");
+			reject_all = true;
+			goto reject_all_req;
+		}
+
+		pos += OCV_OCI_EXTENDED_LEN;
+		pos_len += OCV_OCI_EXTENDED_LEN;
+	}
+
+	/* Basic Multi-Link element for add links */
+	if (mle_len) {
+		u8 *mle_pos = pos;
+
+		/* TODO: Basic MLE is not supposed to include BPCC in Link
+		 * Reconfiguration Response, but mac80211 implementation for
+		 * processing this frame requires that to be present. For now,
+		 * include that subfield as a workaround. This should be removed
+		 * once mac80211 is fixed to match the standard (or this comment
+		 * be removed if the standard is modified to match
+		 * implementation). */
+		mle_pos = hostapd_eid_eht_basic_ml_common(hapd, mle_pos, &mld,
+							  false, true);
+		if ((size_t) (mle_pos - pos) != mle_len) {
+			reject_all = true;
+			goto reject_all_req;
+		}
+
+		pos += mle_len;
+		pos_len += mle_len;
+	}
+
+reject_all_req:
+	if (reject_all) {
+		pos = orig_pos;
+		pos_len = 28; /* reset pos_len */
+		pos += hostapd_reject_all_reconf_req(hapd, orig_pos, req_list);
+		pos_len += pos - orig_pos;
+
+		req_list->links_add_ok = req_list->links_del_ok = 0;
+		req_list->new_valid_links = 0;
+	}
+
+send_resp:
+	ret = hostapd_drv_send_mlme(hapd, mgmt, pos_len, 0, NULL, 0, 0);
+	os_free(buf);
+
+	if (mld.mld_sta)
+		ap_sta_free_sta_profile(&mld);
+
+	return ret;
+}
+
+
+static int
+hostapd_ml_check_sta_entry_by_link_addr_iter(struct hostapd_data *hapd,
+					     struct sta_info *sta, void *ctx)
+{
+	const u8 *link_addr = ctx;
+	struct mld_link_info li;
+
+	if (!link_addr)
+		return 0;
+
+	if (sta->mld_info.mld_sta) {
+		li = sta->mld_info.links[hapd->mld_link_id];
+		if (!li.valid || !ether_addr_equal(li.peer_addr, link_addr))
+			return 0;
+
+		wpa_printf(MSG_DEBUG, "MLD: STA with address " MACSTR
+			   " exists for AP (link_id=%u) as a non-AP STA affiliated with non-AP MLD "
+			   MACSTR, MAC2STR(link_addr),
+			   hapd->mld_link_id, MAC2STR(sta->addr));
+		return 1;
+	}
+
+	if (ether_addr_equal(sta->addr, link_addr)) {
+		wpa_printf(MSG_DEBUG, "MLD: STA with address " MACSTR
+			   " exists for AP (link_id=%u) as a legacy STA",
+			   MAC2STR(link_addr), hapd->mld_link_id);
+		return 1;
+	}
+
+	return 0;
+}
+
+
+/* Returns:
+ * 0 = successful parsing
+ * 1 = per-STA profile (subelement) skipped or rejected
+ * -1 = fail due to fatal errors
+ */
+static int
+hostapd_parse_link_reconf_req_sta_profile(struct hostapd_data *hapd,
+					    struct link_reconf_req_list *req,
+					    const u8 *buf, size_t len)
+{
+	struct link_reconf_req_info *info = NULL;
+	const struct ieee80211_eht_per_sta_profile *per_sta_prof;
+	const struct element *elem;
+	struct hostapd_data *lhapd = NULL;
+	struct sta_info *lsta;
+	size_t sta_info_len, sta_prof_len = 0;
+	u16 sta_control, reconf_type_mask;
+	u8 link_id, reconf_type;
+	const u8 *sta_info = NULL, *end;
+	u8 sta_addr[ETH_ALEN];
+	size_t nstr_bitmap_size = 0;
+	int ret = -1;
+	u16 status;
+
+	if (len < sizeof(*elem) + 2UL)
+		goto out;
+
+	elem = (const struct element *) buf;
+	end = buf + len;
+
+	os_memset(sta_addr, 0, ETH_ALEN);
+
+	if (elem->id != EHT_ML_SUB_ELEM_PER_STA_PROFILE) {
+		wpa_printf(MSG_DEBUG, "MLD: Unexpected subelement (%u) found",
+			   elem->id);
+		ret = 1; /* skip this subelement */
+		goto out;
+	}
+
+	status = WLAN_STATUS_UNSPECIFIED_FAILURE;
+
+	per_sta_prof = (const struct ieee80211_eht_per_sta_profile *)
+		elem->data;
+	sta_control = le_to_host16(per_sta_prof->sta_control);
+	sta_info_len = 1;
+
+	link_id = sta_control & EHT_PER_STA_RECONF_CTRL_LINK_ID_MSK;
+	wpa_printf(MSG_DEBUG, "MLD: Per-STA profile for link=%u", link_id);
+
+	reconf_type_mask =
+		sta_control & EHT_PER_STA_RECONF_CTRL_OP_UPDATE_TYPE_MSK;
+	reconf_type =
+		EHT_PER_STA_RECONF_CTRL_OP_UPDATE_TYPE_VAL(reconf_type_mask);
+
+	switch (reconf_type) {
+	case EHT_RECONF_TYPE_ADD_LINK:
+	case EHT_RECONF_TYPE_DELETE_LINK:
+		break;
+	default:
+		wpa_printf(MSG_ERROR,
+			   "MLD: Unsupported Reconfiguration type %u",
+			   reconf_type);
+		ret = 1; /* skip this per-STA profile */
+		goto out;
+	}
+
+	if (!(sta_control & EHT_PER_STA_RECONF_CTRL_MAC_ADDR)) {
+		wpa_printf(MSG_DEBUG,
+			   "MLD: STA MAC address not set in STA control");
+		ret = 1; /* reject this per-STA profile */
+		goto add_to_list;
+	}
+	sta_info_len += ETH_ALEN;
+
+	if (sta_control & EHT_PER_STA_RECONF_CTRL_AP_REMOVAL_TIMER) {
+		wpa_printf(MSG_DEBUG,
+			   "MLD: AP removal timer set in STA control");
+		sta_info_len += 2;
+	}
+
+	if (sta_control & EHT_PER_STA_RECONF_CTRL_OP_PARAMS) {
+		wpa_printf(MSG_DEBUG, "MLD: Op params set in STA control");
+		sta_info_len += 3;
+	}
+
+	if (!(sta_control & EHT_PER_STA_RECONF_CTRL_COMPLETE_PROFILE)) {
+		if (reconf_type == EHT_RECONF_TYPE_ADD_LINK) {
+			wpa_printf(MSG_DEBUG,
+				   "MLD: Complete profile not set in STA control");
+			ret = 1; /* reject this per-STA profile */
+			goto add_to_list;
+		}
+	} else {
+		if (reconf_type == EHT_RECONF_TYPE_DELETE_LINK)
+			wpa_printf(MSG_DEBUG,
+				   "MLD: Complete profile set in STA control");
+	}
+
+	if (sta_control & EHT_PER_STA_RECONF_CTRL_NSTR_INDICATION) {
+		nstr_bitmap_size = 1;
+		if (sta_control &
+		    EHT_PER_STA_RECONF_CTRL_NSTR_BITMAP_SIZE)
+			nstr_bitmap_size = 2;
+
+		if (reconf_type == EHT_RECONF_TYPE_DELETE_LINK)
+			wpa_printf(MSG_DEBUG,
+				   "MLD: NSTR Indication set in STA control");
+	}
+	sta_info_len += nstr_bitmap_size;
+
+	sta_info = per_sta_prof->variable;
+	if (*sta_info > end - sta_info) {
+		wpa_printf(MSG_DEBUG, "MLD: Not enough room for STA Info");
+		goto out;
+	}
+
+	if (*sta_info < sta_info_len) {
+		wpa_printf(MSG_DEBUG,
+			   "MLD: Invalid Reconf STA Info len (%u); min expected=%zu",
+			   *sta_info, sta_info_len);
+		goto out;
+	}
+
+	sta_info_len = *sta_info;
+
+	os_memcpy(sta_addr, sta_info + 1, ETH_ALEN);
+	wpa_printf(MSG_DEBUG, "MLD: Link STA addr=" MACSTR, MAC2STR(sta_addr));
+
+	sta_info += sta_info_len;
+
+	lhapd = hostapd_mld_get_link_bss(hapd, link_id);
+	if (!lhapd) {
+		wpa_printf(MSG_DEBUG, "MLD: No AP link found for link id=%u",
+			   link_id);
+		ret = 1; /* reject this per-STA profile */
+		goto add_to_list;
+	}
+
+	lsta = ap_get_sta(lhapd, req->sta_mld_addr);
+
+	if (reconf_type == EHT_RECONF_TYPE_DELETE_LINK) {
+		/* DELETE_LINK request shall not have STA profile */
+		if (len != sizeof(sta_control) + sta_info_len)
+			wpa_printf(MSG_DEBUG,
+				   "MLD: Delete link request has STA profile");
+
+		if (!lsta || !ap_sta_is_mld(lhapd, lsta) ||
+		    !lsta->mld_info.links[link_id].valid) {
+			wpa_printf(MSG_DEBUG,
+				   "MLD: STA invalid for link id=%u peer addr="
+				   MACSTR, link_id, MAC2STR(sta_addr));
+			ret = 1; /* reject this per-STA profile */
+			goto add_to_list;
+		}
+
+		if (!ether_addr_equal(lsta->mld_info.links[link_id].peer_addr,
+				      sta_addr)) {
+			wpa_printf(MSG_DEBUG,
+				   "MLD: STA invalid for addr=" MACSTR,
+				   MAC2STR(sta_addr));
+			ret = 1; /* reject this per-STA profile */
+			goto add_to_list;
+		}
+
+		status = WLAN_STATUS_SUCCESS;
+		ret = 0;
+		goto add_to_list;
+	}
+
+	/* EHT_RECONF_TYPE_ADD_LINK */
+	if (len < sizeof(sta_control) + sta_info_len + 2)
+		goto out;
+	sta_prof_len = len - sizeof(sta_control) - sta_info_len - 2;
+	if (sta_prof_len > (size_t) (end - sta_info)) {
+		wpa_printf(MSG_DEBUG, "MLD: STA Profile with excess length");
+		goto out;
+	}
+
+	if (lsta) {
+		wpa_printf(MSG_DEBUG,
+			   "MLD: STA exists for link id=%u MLD addr=" MACSTR,
+			   link_id, MAC2STR(req->sta_mld_addr));
+		ret = 1; /* reject this per-STA profile */
+		goto add_to_list;
+	}
+
+	/* Check if link address is already used by any connected legacy
+	 * non-AP STA or non-AP STA affiliated with a non-AP MLD.
+	 */
+	if (ap_for_each_sta(lhapd, hostapd_ml_check_sta_entry_by_link_addr_iter,
+			    sta_addr)) {
+		ret = 1; /* Reject this per-STA profile */
+		goto add_to_list;
+	}
+
+	status = WLAN_STATUS_SUCCESS; /* IE validations done later */
+	ret = 0;
+
+add_to_list:
+	info = os_zalloc(sizeof(struct link_reconf_req_info) + sta_prof_len);
+	if (!info) {
+		wpa_printf(MSG_DEBUG, "MLD: Failed to allocate request info");
+		ret = 1; /* skip this per-STA profile */
+		goto out;
+	}
+
+	info->link_id = link_id;
+	info->status = status;
+	os_memcpy(info->peer_addr, sta_addr, ETH_ALEN);
+	if (lhapd)
+		os_memcpy(info->local_addr, lhapd->own_addr, ETH_ALEN);
+
+	if (reconf_type == EHT_RECONF_TYPE_DELETE_LINK) {
+		dl_list_add_tail(&req->del_req, &info->list);
+	} else if (sta_info) {
+		os_memcpy(info->sta_prof, sta_info, sta_prof_len);
+		info->sta_prof_len = sta_prof_len;
+
+		dl_list_add_tail(&req->add_req, &info->list);
+	} else {
+		os_free(info);
+	}
+	wpa_printf(MSG_INFO, "MLD: Link (%d) parsed to %s request; status=%u",
+		   link_id,
+		   reconf_type == EHT_RECONF_TYPE_DELETE_LINK ? "del" : "add",
+		   status);
+
+out:
+	if (ret < 0)
+		wpa_printf(MSG_DEBUG,
+			   "MLD: Failed to parse reconf req STA profile");
+	return ret;
+}
+
+
+static int
+hostapd_parse_link_reconf_req_reconf_mle(
+		struct hostapd_data *hapd, const u8 *mle, size_t mle_len,
+		struct link_reconf_req_list **req_list_ptr)
+{
+	struct link_reconf_req_list *req_list;
+	struct wpabuf *mlbuf = NULL;
+	struct sta_info *sta;
+	const struct ieee80211_eht_ml *ml;
+	const struct eht_ml_reconf_common_info *ml_common_info;
+	size_t len, ml_common_len;
+	u16 ml_control;
+	const u8 *pos, *end;
+	int ret = -1;
+
+	mlbuf = ieee802_11_defrag(mle, mle_len, true);
+	if (!mlbuf) {
+		wpa_printf(MSG_DEBUG,
+			   "MLD: Failed to defrag Reconfiguration MLE");
+		goto fail;
+	}
+
+	ml = (const struct ieee80211_eht_ml *) wpabuf_head(mlbuf);
+	len = wpabuf_len(mlbuf);
+	end = ((const u8 *) ml) + len;
+
+	wpa_hexdump(MSG_DEBUG, "MLD: Defragged Reconfiguration MLE",
+		    (const void *) ml, len);
+
+	if (len < sizeof(*ml) + ETH_ALEN + 1UL)
+		goto fail;
+
+	ml_control = WPA_GET_LE16((const u8 *) ml) >> 4;
+	ml_common_len = 1;
+	if (!(ml_control & RECONF_MULTI_LINK_CTRL_PRES_MLD_MAC_ADDR))
+		goto fail;
+	ml_common_len += ETH_ALEN;
+
+	if (ml_control & RECONF_MULTI_LINK_CTRL_PRES_EML_CAPA)
+		ml_common_len += 2;
+
+	if (ml_control & RECONF_MULTI_LINK_CTRL_PRES_MLD_CAPA)
+		ml_common_len += 2;
+
+	if (ml_control & RECONF_MULTI_LINK_CTRL_PRES_EXT_MLD_CAP)
+		ml_common_len += 2;
+
+	ml_common_info =
+		(const struct eht_ml_reconf_common_info *) ml->variable;
+	if (len < sizeof(*ml) + ml_common_info->len) {
+		wpa_printf(MSG_DEBUG,
+			   "MLD: Unexpected Reconfiguration ML element length (%zu < %zu)",
+			   len, sizeof(*ml) + ml_common_info->len);
+		goto fail;
+	}
+
+	if (ml_common_info->len < ml_common_len) {
+		wpa_printf(MSG_DEBUG,
+			   "MLD: Invalid Reconf common info len (%u); min expected=%zu",
+			   ml_common_info->len, ml_common_len);
+		goto fail;
+	}
+
+	pos = (const u8 *) ml_common_info->variable;
+
+	sta = ap_get_sta(hapd, pos);
+	if (!sta || !ap_sta_is_mld(hapd, sta)) {
+		wpa_printf(MSG_DEBUG, "MLD: STA invalid%s for " MACSTR,
+			   sta ? "" : " (NULL)", MAC2STR(pos));
+		goto fail;
+	}
+
+	*req_list_ptr = os_zalloc(sizeof(struct link_reconf_req_list));
+	if (!(*req_list_ptr)) {
+		wpa_printf(MSG_ERROR, "MLD: Failed to allocate request list");
+		goto fail;
+	}
+	req_list = *req_list_ptr;
+
+	os_memcpy(req_list->sta_mld_addr, pos, ETH_ALEN);
+	dl_list_init(&req_list->del_req);
+	dl_list_init(&req_list->add_req);
+
+	pos = ml->variable + ml_common_info->len;
+
+	while (end - pos > 2) {
+		size_t sub_elem_len;
+		int num_frag_subelems;
+
+		num_frag_subelems =
+			ieee802_11_defrag_mle_subelem(mlbuf, pos,
+						      &sub_elem_len);
+		if (num_frag_subelems < 0) {
+			wpa_printf(MSG_DEBUG,
+				   "MLD: Failed to parse Reconfiguration MLE subelem");
+			goto fail;
+		}
+
+		len -= num_frag_subelems * 2;
+		end = ((const u8 *) ml) + len;
+
+		if (sub_elem_len + 2 > (size_t) (end - pos))
+			goto fail;
+
+		if (hostapd_parse_link_reconf_req_sta_profile(
+			    hapd, req_list, pos, sub_elem_len + 2) < 0)
+			goto fail;
+
+		pos += sub_elem_len + 2;
+	}
+
+	ret = 0;
+
+fail:
+	if (ret)
+		ml_deinit_link_reconf_req(req_list_ptr);
+
+	wpabuf_free(mlbuf);
+	return ret;
+}
+
+
+static bool
+hostapd_validate_link_reconf_req(struct hostapd_data *hapd,
+				 struct sta_info *sta,
+				 struct link_reconf_req_list *req_list)
+{
+	struct hostapd_data *assoc_hapd, *lhapd;
+	struct link_reconf_req_info *info;
+	struct sta_info *assoc_sta, *lsta;
+	struct mld_info *mld_info;
+	u8 recovery_link;
+	u16 valid_links = 0, links_add_ok = 0, links_del_ok = 0, status;
+	size_t link_kde_len, total_kde_len = 0;
+	int i;
+
+	assoc_sta = hostapd_ml_get_assoc_sta(hapd, sta, &assoc_hapd);
+	if (!assoc_sta)
+		return false;
+
+	if (dl_list_empty(&req_list->add_req) &&
+	    dl_list_empty(&req_list->del_req)) {
+		wpa_printf(MSG_DEBUG, "MLD: No add or delete request found");
+		return false;
+	}
+
+	mld_info = &assoc_sta->mld_info;
+	for (i = 0; i < MAX_NUM_MLD_LINKS; i++) {
+		if (mld_info->links[i].valid &&
+		    mld_info->links[i].status == WLAN_STATUS_SUCCESS)
+			valid_links |= BIT(i);
+	}
+
+	/* Check IEs for add-link STA profiles */
+	dl_list_for_each(info, &req_list->add_req, struct link_reconf_req_info,
+			 list) {
+		lhapd = NULL;
+		lsta = NULL;
+
+		wpa_printf(MSG_DEBUG,
+			   "MLD: Add Link Reconf STA for link id=%u status=%u",
+			   info->link_id, info->status);
+		if (info->status != WLAN_STATUS_SUCCESS ||
+		    info->sta_prof_len < 2)
+			continue;
+
+		/* Offset 2 bytes for Capabilities in STA Profile */
+		status = hostapd_ml_process_reconf_link(hapd, assoc_sta,
+							info->sta_prof + 2,
+							info->sta_prof_len - 2,
+							info->link_id,
+							info->peer_addr);
+		if (status != WLAN_STATUS_SUCCESS) {
+			wpa_printf(MSG_DEBUG,
+				   "MLD: Add link IE validation failed for link=%u",
+				   info->link_id);
+			info->status = status;
+			continue;
+		}
+
+		link_kde_len = wpa_auth_ml_group_kdes_len(assoc_sta->wpa_sm,
+							  BIT(info->link_id));
+
+		/* Since Group KDE element Length subfield is one byte,
+		 * accept as many add-link requests as can be fit.
+		 */
+		if (total_kde_len + link_kde_len >
+		    LINK_RECONF_GROUP_KDE_MAX_LEN) {
+			wpa_printf(MSG_INFO,
+				   "MLD: Group KDEs cannot fit (%zu > %u) for link=%u",
+				   total_kde_len + link_kde_len,
+				   LINK_RECONF_GROUP_KDE_MAX_LEN,
+				   info->link_id);
+			status = WLAN_STATUS_UNSPECIFIED_FAILURE;
+
+			lhapd = hostapd_mld_get_link_bss(hapd, info->link_id);
+			if (lhapd)
+				lsta = ap_get_sta(lhapd,
+						  req_list->sta_mld_addr);
+
+			if (lsta)
+				ap_free_sta(lhapd, lsta);
+		} else {
+			total_kde_len += link_kde_len;
+			links_add_ok |= BIT(info->link_id);
+			wpa_msg(hapd->msg_ctx, MSG_INFO,
+				WPA_EVENT_LINK_STA_ADDED "sta=" MACSTR
+				" link_id=%u", MAC2STR(req_list->sta_mld_addr),
+				info->link_id);
+		}
+
+		info->status = status;
+	}
+
+	dl_list_for_each(info, &req_list->del_req, struct link_reconf_req_info,
+			list) {
+		wpa_printf(MSG_DEBUG,
+			   "MLD: Del Link Reconf STA for link id=%u status=%u",
+			   info->link_id, info->status);
+		if (info->status == WLAN_STATUS_SUCCESS)
+			links_del_ok |= BIT(info->link_id);
+	}
+
+	wpa_printf(MSG_INFO, "MLD: valid_links=0x%x add_ok=0x%x del_ok=0x%x",
+		   valid_links, links_add_ok, links_del_ok);
+
+	if ((links_add_ok && (valid_links & links_add_ok)) ||
+	    (links_del_ok && !(valid_links & links_del_ok))) {
+		wpa_printf(MSG_INFO,
+			   "MLD: Links requested failed to satisfy valid links");
+		return false;
+	}
+
+	if (links_add_ok & links_del_ok) {
+		wpa_printf(MSG_INFO,
+			   "MLD: Links (0x%x) present in both valid add and delete requests",
+			   links_add_ok & links_del_ok);
+		return false;
+	}
+
+	valid_links |= links_add_ok;
+	valid_links &= ~links_del_ok;
+	if (!valid_links) {
+		if (!recover_from_zero_links(&links_del_ok, &recovery_link)) {
+			wpa_printf(MSG_INFO,
+				   "MLD: Total-links validation failed");
+			return false;
+		}
+		/* Add the recovery link back to valid_links */
+		valid_links |= BIT(recovery_link);
+	}
+
+	req_list->new_valid_links = valid_links;
+	req_list->links_add_ok = links_add_ok;
+	req_list->links_del_ok = links_del_ok;
+
+	/* TODO: Add support to handle multiple requests from the non-AP MLD */
+	assoc_sta->reconf_req = req_list;
+
+	return true;
+}
+
+
+static int
+hostapd_handle_link_reconf_req(struct hostapd_data *hapd, const u8 *buf,
+			       size_t len)
+{
+	struct ieee802_11_elems elems;
+	struct hostapd_data *assoc_hapd;
+	struct sta_info *sta, *assoc_sta = NULL;
+	u8 dialog_token;
+	const struct ieee80211_mgmt *mgmt = (const struct ieee80211_mgmt *) buf;
+	struct link_reconf_req_list *req_list = NULL;
+	const u8 *pos = NULL;
+	int ret = -1;
+
+	wpa_printf(MSG_DEBUG,
+		   "MLD: Link Reconfiguration Request frame from " MACSTR,
+		   MAC2STR(mgmt->sa));
+
+	/* Min length: IEEE80211 Header (24B) + Category (1B) + Action (1B) +
+	 *	       Dialog token (1B) +
+	 *	       Reconfiguration MLE header and extension ID (3B)
+	 */
+	if (len < IEEE80211_HDRLEN + 3 + 3) {
+		wpa_printf(MSG_DEBUG,
+			   "MLD: Invalid minimum length (%zu) for Link Reconfiguration Request",
+			   len);
+		goto out;
+	}
+
+	dialog_token = mgmt->u.action.u.link_reconf_req.dialog_token;
+	pos = mgmt->u.action.u.link_reconf_req.variable;
+
+	sta = ap_get_sta(hapd, mgmt->sa);
+	if (!sta) {
+		wpa_printf(MSG_DEBUG, "MLD: No STA found for " MACSTR
+			   "; drop Link Reconfiguration Request",
+			   MAC2STR(mgmt->sa));
+		goto out;
+	}
+
+	if (!ap_sta_is_mld(hapd, sta)) {
+		wpa_printf(MSG_DEBUG,
+			   "MLD: Not an MLD connection; drop Link Reconfiguration Request");
+		goto out;
+	}
+
+	assoc_sta = hostapd_ml_get_assoc_sta(hapd, sta, &assoc_hapd);
+	if (!assoc_sta) {
+		wpa_printf(MSG_DEBUG,
+			   "MLD: Not able to get assoc link STA; drop Link Reconfiguration Request");
+		goto out;
+	}
+
+	if (assoc_sta->reconf_req) {
+		wpa_printf(MSG_INFO,
+			   "MLD: Link Reconfiguration Request from this STA with token=%u is already in progress",
+			   assoc_sta->reconf_req->dialog_token);
+		goto out;
+	}
+
+	/* Parse Reconfiguration Multi-Link element and OCI elements */
+	if (ieee802_11_parse_elems(pos, len - (pos - buf), &elems, 1) ==
+	    ParseFailed) {
+		wpa_printf(MSG_DEBUG,
+			   "MLD: Could not parse Link Reconfiguration Request");
+		goto out;
+	}
+
+	if (!elems.reconf_mle || !elems.reconf_mle_len) {
+		wpa_printf(MSG_DEBUG, "MLD: No Reconfiguration ML element");
+		goto out;
+	}
+
+	/* Process Reconfiguration MLE */
+	if (hostapd_parse_link_reconf_req_reconf_mle(hapd, elems.reconf_mle,
+						     elems.reconf_mle_len,
+						     &req_list)) {
+		wpa_printf(MSG_INFO,
+			   "MLD: Reconfiguration MLE parsing failed; drop Link Reconfiguration Request");
+		goto out;
+	}
+
+	/* Do OCI element validation */
+	if (dl_list_empty(&req_list->add_req))
+		goto skip_oci_validation;
+
+	if (!elems.oci || !elems.oci_len) {
+		if (wpa_auth_uses_ocv(assoc_sta->wpa_sm) == 1) {
+			wpa_printf(MSG_INFO,
+				   "MLD: No OCI element present; drop Link Reconfiguration Request");
+			goto out;
+		}
+	} else {
+		struct wpa_channel_info ci;
+
+		if (!wpa_auth_uses_ocv(assoc_sta->wpa_sm)) {
+			wpa_printf(MSG_INFO,
+				   "MLD: Unexpected OCI element found; drop Link Reconfiguration Request");
+			goto out;
+		}
+
+		if (hostapd_drv_channel_info(hapd, &ci)) {
+			wpa_printf(MSG_DEBUG,
+				   "MLD: Failed to get channel info to verify OCI element");
+			goto out;
+		}
+
+		if (!ocv_verify_tx_params(elems.oci, elems.oci_len, &ci,
+					  channel_width_to_int(ci.chanwidth),
+					  ci.seg1_idx)) {
+			wpa_printf(MSG_INFO,
+				   "MLD: OCI verification failed; drop Link Reconfiguration Request");
+			goto out;
+		}
+	}
+
+skip_oci_validation:
+	/* Do STA profile validation */
+	if (!hostapd_validate_link_reconf_req(hapd, assoc_sta, req_list))
+		goto out;
+
+	req_list->dialog_token = dialog_token;
+	ret = hostapd_send_link_reconf_resp(hapd, assoc_sta, req_list);
+	if (ret)
+		wpa_printf(MSG_INFO,
+			   "MLD: Failed to send Link Reconfiguration Response (%d)",
+			   ret);
+
+out:
+	if (ret) {
+		ml_deinit_link_reconf_req(&req_list);
+		if (assoc_sta && assoc_sta->reconf_req)
+			assoc_sta->reconf_req = NULL;
+	}
+	return ret;
+}
+
+
+void ieee802_11_rx_protected_eht_action(struct hostapd_data *hapd,
+					const struct ieee80211_mgmt *mgmt,
+					size_t len)
+{
+	const u8 *payload;
+	u8 action;
+
+	if (!hapd->conf->mld_ap)
+		return;
+
+	payload = ((const u8 *) mgmt) + IEEE80211_HDRLEN + 1;
+	action = *payload++;
+
+	switch (action) {
+	case WLAN_PROT_EHT_LINK_RECONFIG_REQUEST:
+		if (hostapd_handle_link_reconf_req(hapd, (const u8 *) mgmt,
+						   len))
+			wpa_printf(MSG_INFO,
+				   "MLD: Link Reconf Request processing failed");
+		return;
+	}
+
+	wpa_printf(MSG_DEBUG,
+		   "MLD: Unsupported Protected EHT Action %u from " MACSTR
+		   " discarded", action, MAC2STR(mgmt->sa));
+}
diff --git a/src/ap/sta_info.c b/src/ap/sta_info.c
index 49f7c8984..36c321e88 100644
--- a/src/ap/sta_info.c
+++ b/src/ap/sta_info.c
@@ -394,7 +394,7 @@ void ap_free_sta(struct hostapd_data *hapd, struct sta_info *sta)
 	p2p_group_notif_disassoc(hapd->p2p_group, sta->addr);
 #endif /* CONFIG_P2P */
 
-#ifdef CONFIG_INTERWORKING
+#if defined(CONFIG_INTERWORKING) || defined(CONFIG_DPP)
 	if (sta->gas_dialog) {
 		int i;
 
@@ -402,7 +402,7 @@ void ap_free_sta(struct hostapd_data *hapd, struct sta_info *sta)
 			gas_serv_dialog_clear(&sta->gas_dialog[i]);
 		os_free(sta->gas_dialog);
 	}
-#endif /* CONFIG_INTERWORKING */
+#endif /* CONFIG_INTERWORKING || CONFIG_DPP */
 
 	wpabuf_free(sta->wps_ie);
 	wpabuf_free(sta->p2p_ie);
@@ -469,6 +469,7 @@ void ap_free_sta(struct hostapd_data *hapd, struct sta_info *sta)
 
 #ifdef CONFIG_IEEE80211BE
 	ap_sta_free_sta_profile(&sta->mld_info);
+	ml_deinit_link_reconf_req(&sta->reconf_req);
 #endif /* CONFIG_IEEE80211BE */
 
 #ifdef CONFIG_TESTING_OPTIONS
diff --git a/src/ap/sta_info.h b/src/ap/sta_info.h
index 9a8f4068a..a7f084f18 100644
--- a/src/ap/sta_info.h
+++ b/src/ap/sta_info.h
@@ -316,6 +316,7 @@ struct sta_info {
 #ifdef CONFIG_IEEE80211BE
 	struct mld_info mld_info;
 	u8 mld_assoc_link_id;
+	struct link_reconf_req_list *reconf_req;
 #endif /* CONFIG_IEEE80211BE */
 
 	u16 max_idle_period; /* if nonzero, the granted BSS max idle period in
diff --git a/src/ap/wnm_ap.c b/src/ap/wnm_ap.c
index af8cccaef..4f5356961 100644
--- a/src/ap/wnm_ap.c
+++ b/src/ap/wnm_ap.c
@@ -1030,7 +1030,13 @@ int wnm_send_bss_tm_req(struct hostapd_data *hapd, struct sta_info *sta,
 
 	if (disassoc_timer) {
 #ifdef CONFIG_IEEE80211BE
-		if (ap_sta_is_mld(hapd, sta)) {
+		/* Link removal is scheduled only when the Link Removal Imminent
+		 * field is set to 1 in BTM as per IEEE P802.11be/D7.0,
+		 * 9.6.13.9 (BSS Transition Management Request frame format);
+		 * else schedule full disconnection.
+		 */
+		if (ap_sta_is_mld(hapd, sta) &&
+		    (req_mode & WNM_BSS_TM_REQ_LINK_REMOVAL_IMMINENT)) {
 			int i;
 			unsigned int links = 0;
 
diff --git a/src/ap/wpa_auth.c b/src/ap/wpa_auth.c
index f2330bc9d..333467ce8 100644
--- a/src/ap/wpa_auth.c
+++ b/src/ap/wpa_auth.c
@@ -657,6 +657,12 @@ static void wpa_auth_pmksa_free_cb(struct rsn_pmksa_cache_entry *entry,
 {
 	struct wpa_authenticator *wpa_auth = ctx;
 	wpa_auth_for_each_sta(wpa_auth, wpa_auth_pmksa_clear_cb, entry);
+
+	/* Remove matching PMKID from the driver, if it had been added, e.g.,
+	 * by external SAE authentication */
+	if (wpa_auth->cb->remove_pmkid)
+		wpa_auth->cb->remove_pmkid(wpa_auth->cb_ctx, entry->spa,
+					   entry->pmkid);
 }
 
 
@@ -4348,8 +4354,7 @@ static void wpa_auth_get_ml_key_info(struct wpa_authenticator *wpa_auth,
 }
 
 
-static size_t wpa_auth_ml_group_kdes_len(struct wpa_state_machine *sm,
-					 u16 req_links)
+size_t wpa_auth_ml_group_kdes_len(struct wpa_state_machine *sm, u16 req_links)
 {
 	struct wpa_authenticator *wpa_auth;
 	size_t kde_len = 0;
@@ -4400,8 +4405,8 @@ static size_t wpa_auth_ml_group_kdes_len(struct wpa_state_machine *sm,
 }
 
 
-static u8 * wpa_auth_ml_group_kdes(struct wpa_state_machine *sm, u8 *pos,
-				   u16 req_links)
+u8 * wpa_auth_ml_group_kdes(struct wpa_state_machine *sm, u8 *pos,
+			    u16 req_links)
 {
 	struct wpa_auth_ml_key_info ml_key_info;
 	unsigned int i, link_id;
@@ -7676,3 +7681,14 @@ bool wpa_auth_sm_known_sta_identification(struct wpa_state_machine *sm,
 
 	return true;
 }
+
+
+void wpa_reset_assoc_sm_info(struct wpa_state_machine *assoc_sm,
+			     struct wpa_authenticator *wpa_auth,
+			     u8 mld_assoc_link_id)
+{
+#ifdef CONFIG_IEEE80211BE
+	assoc_sm->wpa_auth = wpa_auth;
+	assoc_sm->mld_assoc_link_id = mld_assoc_link_id;
+#endif /* CONFIG_IEEE80211BE */
+}
diff --git a/src/ap/wpa_auth.h b/src/ap/wpa_auth.h
index c412633cd..176ed2c44 100644
--- a/src/ap/wpa_auth.h
+++ b/src/ap/wpa_auth.h
@@ -431,6 +431,7 @@ struct wpa_auth_callbacks {
 	struct wpa_authenticator * (*next_primary_auth)(void *ctx);
 #endif /* CONFIG_IEEE80211BE */
 	int (*get_drv_flags)(void *ctx, u64 *drv_flags, u64 *drv_flags2);
+	int (*remove_pmkid)(void *ctx, const u8 *sta_addr, const u8 *pmkid);
 };
 
 struct wpa_authenticator * wpa_init(const u8 *addr,
@@ -686,6 +687,13 @@ void wpa_auth_ml_get_key_info(struct wpa_authenticator *a,
 void wpa_release_link_auth_ref(struct wpa_state_machine *sm, u8 link_id,
 			       bool rejected);
 
+size_t wpa_auth_ml_group_kdes_len(struct wpa_state_machine *sm, u16 req_links);
+u8 * wpa_auth_ml_group_kdes(struct wpa_state_machine *sm, u8 *pos,
+			    u16 req_links);
+void wpa_reset_assoc_sm_info(struct wpa_state_machine *assoc_sm,
+			     struct wpa_authenticator *wpa_auth,
+			     u8 mld_assoc_link_id);
+
 #define for_each_sm_auth(sm, link_id) \
 	for (link_id = 0; link_id < MAX_NUM_MLD_LINKS; link_id++)	\
 		if (sm->mld_links[link_id].valid &&			\
diff --git a/src/ap/wpa_auth_glue.c b/src/ap/wpa_auth_glue.c
index d30e9ef3b..519948a51 100644
--- a/src/ap/wpa_auth_glue.c
+++ b/src/ap/wpa_auth_glue.c
@@ -1663,6 +1663,15 @@ static int hostapd_wpa_auth_get_drv_flags(void *ctx,
 }
 
 
+static int hostapd_wpa_auth_remove_pmkid(void *ctx, const u8 *sta_addr,
+					 const u8 *pmkid)
+{
+	struct hostapd_data *hapd = ctx;
+
+	return hostapd_remove_pmkid(hapd, sta_addr, pmkid);
+}
+
+
 int hostapd_setup_wpa(struct hostapd_data *hapd)
 {
 	struct wpa_auth_config _conf;
@@ -1718,6 +1727,7 @@ int hostapd_setup_wpa(struct hostapd_data *hapd)
 		.next_primary_auth = hostapd_next_primary_auth,
 #endif /* CONFIG_IEEE80211BE */
 		.get_drv_flags = hostapd_wpa_auth_get_drv_flags,
+		.remove_pmkid = hostapd_wpa_auth_remove_pmkid,
 	};
 	const u8 *wpa_ie;
 	size_t wpa_ie_len;
diff --git a/src/common/ieee802_11_defs.h b/src/common/ieee802_11_defs.h
index d029cf905..6cf8b146d 100644
--- a/src/common/ieee802_11_defs.h
+++ b/src/common/ieee802_11_defs.h
@@ -1183,6 +1183,23 @@ struct ieee80211_mgmt {
 					u8 dialog_token;
 					u8 variable[];
 				} STRUCT_PACKED rrm;
+				struct {
+					u8 action; /* Protected EHT - 11 */
+					u8 dialog_token;
+					/* Reconfiguration Multi-Link element,
+					* OCI element (optional) */
+					u8 variable[];
+				} STRUCT_PACKED link_reconf_req;
+				struct {
+					u8 action; /* Protected EHT - 12 */
+					u8 dialog_token;
+					u8 count;
+					/* Reconfiguration status list,
+					 * Group Key Data (optional),
+					 * OCI element (optional),
+					 * Basic Multi-Link element (optional) */
+					u8 variable[];
+				} STRUCT_PACKED link_reconf_resp;
 			} u;
 		} STRUCT_PACKED action;
 	} u;
@@ -2849,6 +2866,7 @@ struct eht_ml_basic_common_info {
 #define EHT_ML_MLD_CAPA_AP_MLD_TYPE_IND_MASK          0x0080
 #define EHT_ML_MLD_CAPA_FREQ_SEP_FOR_STR_MASK         0x0f80
 #define EHT_ML_MLD_CAPA_AAR_SUPP                      0x1000
+#define EHT_ML_MLD_CAPA_LINK_RECONF_OP_SUPPORT        0x2000
 
 #define EHT_PER_STA_CTRL_LINK_ID_MSK                  0x000f
 #define EHT_PER_STA_CTRL_COMPLETE_PROFILE_MSK         0x0010
@@ -2902,6 +2920,8 @@ struct eht_ml_probe_req_common_info {
 #define EHT_PER_STA_RECONF_CTRL_NSTR_BITMAP_SIZE   0x1000
 #define EHT_PER_STA_RECONF_CTRL_NSTR_INDICATION    0x2000
 
+#define EHT_PER_STA_RECONF_CTRL_OP_UPDATE_TYPE_VAL(x) ((x) >> 7)
+
 /* IEEE P802.11be/D7.0, Figure 9-1074ad - Common Info field format of the
  * Reconfiguration Multi-Link element */
 struct eht_ml_reconf_common_info {
@@ -2920,6 +2940,31 @@ struct eht_ml_reconf_common_info {
 } STRUCT_PACKED;
 
 
+/* IEEE P802.11be/D7.0, Table 9-417p - Reconfiguration Operation Type subfield
+ * encoding */
+enum ieee80211_eht_reconf_mle_op_type {
+	EHT_RECONF_TYPE_AP_REMOVAL = 0,
+	EHT_RECONF_TYPE_OP_PARAM_UPDATE = 1,
+	EHT_RECONF_TYPE_ADD_LINK = 2,
+	EHT_RECONF_TYPE_DELETE_LINK = 3,
+	EHT_RECONF_TYPE_NSTR_STATUS_UPDATE = 4,
+};
+
+/* IEEE P802.11be/D7.0, Figure 9-1074ag — STA Info field format for the
+ * Reconfiguration Multi-Link element */
+struct eht_ml_reconf_sta_info {
+	u8 len;
+
+	/* Followed by optional fields based on STA control presence bitmap.
+	 *
+	 * STA MAC Address: 6 octets
+	 * AP Removal Timer: 2 octets
+	 * Operation Parameters: 3 octets
+	 * NSTR Indication Bitmap: 1 or 2 octets
+	 */
+	u8 variable[];
+} STRUCT_PACKED;
+
 /* IEEE P802.11be/D2.0, 9.4.2.312.1 - Multi-Link element / General */
 
 struct ieee80211_eht_ml {
diff --git a/src/common/qca-vendor.h b/src/common/qca-vendor.h
index 4a38dc3ba..4111fb025 100644
--- a/src/common/qca-vendor.h
+++ b/src/common/qca-vendor.h
@@ -1378,6 +1378,11 @@ enum qca_radiotap_vendor_ids {
  *
  *	The attributes used with this command/event are defined in
  *	enum qca_wlan_vendor_attr_iq_data_inference.
+ *
+ * @QCA_NL80211_VENDOR_SUBCMD_P2P_SET_NOA: Vendor subcommand used to
+ *	enable/disable Notice of Absence (NoA) as a GO in a P2P connection.
+ *	The attributes used with this command are defined in
+ *	enum qca_wlan_vendor_attr_p2p_set_noa.
  */
 enum qca_nl80211_vendor_subcmds {
 	QCA_NL80211_VENDOR_SUBCMD_UNSPEC = 0,
@@ -1622,6 +1627,7 @@ enum qca_nl80211_vendor_subcmds {
 	QCA_NL80211_VENDOR_SUBCMD_CLASSIFIED_FLOW_STATUS = 258,
 	QCA_NL80211_VENDOR_SUBCMD_RX_MCS_MAP_CONFIG = 259,
 	QCA_NL80211_VENDOR_SUBCMD_IQ_DATA_INFERENCE = 260,
+	QCA_NL80211_VENDOR_SUBCMD_P2P_SET_NOA = 261,
 };
 
 /* Compatibility defines for previously used subcmd names.
@@ -11640,7 +11646,7 @@ enum qca_wlan_vendor_attr_twt_resume {
  * @QCA_WLAN_VENDOR_ATTR_TWT_NUDGE_NEXT_TWT_SIZE: Required (u32)
  * This attribute represents the next TWT subfield size.
  * Value 0 represents 0 bits, 1 represents 32 bits, 2 for 48 bits,
- * and 4 for 64 bits.
+ * and 3 for 64 bits.
  *
  * @QCA_WLAN_VENDOR_ATTR_TWT_NUDGE_MAC_ADDR: 6-byte MAC address
  * Represents the MAC address of the peer to which TWT Suspend and Resume is
@@ -19626,4 +19632,41 @@ enum qca_wlan_vendor_iq_inference_status {
 	QCA_WLAN_VENDOR_IQ_INFERENCE_STATUS_COMPLETE = 2,
 };
 
+/**
+ * enum qca_wlan_vendor_attr_p2p_set_noa - Represents the attributes sent as a
+ * part of set NoA message. This enum is used by
+ * %QCA_NL80211_VENDOR_SUBCMD_P2P_SET_NOA.
+ *
+ * @QCA_WLAN_VENDOR_ATTR_P2P_SET_NOA_COUNT: u8 mandatory attribute.
+ * 0 - Disable NoA
+ * 1 to 254 - Number of absence periods to be scheduled during the NoA.
+ * 255 - Absence periods shall repeat until the NoA is disabled.
+ *
+ * @QCA_WLAN_VENDOR_ATTR_P2P_SET_NOA_DURATION: u32 optional attribute. This is
+ * mandatory attribute when %QCA_WLAN_VENDOR_ATTR_P2P_SET_NOA_COUNT is set to
+ * non-zero value. This specifies the duration (in TUs) of each absence period.
+ *
+ * @QCA_WLAN_VENDOR_ATTR_P2P_SET_NOA_INTERVAL: u32 optional attribute. This is
+ * mandatory attribute when %QCA_WLAN_VENDOR_ATTR_P2P_SET_NOA_COUNT is set to
+ * non-zero value. This specifies time (in TUs) between consecutive absence
+ * periods.
+ *
+ * @QCA_WLAN_VENDOR_ATTR_P2P_SET_NOA_START: u32 optional attribute. This
+ * specifies the start offset time (in milliseconds) of the first absence period
+ * after the beacon advertising the NoA. If this attribute not present, the
+ * driver will use the default start offset value.
+ */
+enum qca_wlan_vendor_attr_p2p_set_noa {
+	QCA_WLAN_VENDOR_ATTR_P2P_SET_NOA_INVALID = 0,
+	QCA_WLAN_VENDOR_ATTR_P2P_SET_NOA_COUNT = 1,
+	QCA_WLAN_VENDOR_ATTR_P2P_SET_NOA_DURATION = 2,
+	QCA_WLAN_VENDOR_ATTR_P2P_SET_NOA_INTERVAL = 3,
+	QCA_WLAN_VENDOR_ATTR_P2P_SET_NOA_START = 4,
+
+	/* keep last */
+	QCA_WLAN_VENDOR_ATTR_P2P_SET_NOA_AFTER_LAST,
+	QCA_WLAN_VENDOR_ATTR_P2P_SET_NOA_MAX =
+	QCA_WLAN_VENDOR_ATTR_P2P_SET_NOA_AFTER_LAST - 1,
+};
+
 #endif /* QCA_VENDOR_H */
diff --git a/src/common/wpa_common.c b/src/common/wpa_common.c
index 4367a227d..b01706573 100644
--- a/src/common/wpa_common.c
+++ b/src/common/wpa_common.c
@@ -2851,6 +2851,10 @@ u32 wpa_akm_to_suite(int akm)
 		return RSN_AUTH_KEY_MGMT_OWE;
 	if (akm & WPA_KEY_MGMT_DPP)
 		return RSN_AUTH_KEY_MGMT_DPP;
+#ifdef CONFIG_PASN
+	if (akm & WPA_KEY_MGMT_PASN)
+		return RSN_AUTH_KEY_MGMT_PASN;
+#endif /* CONFIG_PASN */
 	return 0;
 }
 
diff --git a/src/common/wpa_ctrl.h b/src/common/wpa_ctrl.h
index 90c67490d..ae5711aa6 100644
--- a/src/common/wpa_ctrl.h
+++ b/src/common/wpa_ctrl.h
@@ -118,6 +118,10 @@ extern "C" {
 #define WPA_EVENT_T2LM_UPDATE "CTRL-EVENT-T2LM-UPDATE "
 /** MLO link reconfiguration event */
 #define WPA_EVENT_LINK_RECONFIG "CTRL-EVENT-LINK-RECONFIG "
+/** MLO link STA removed through link reconfiguration */
+#define WPA_EVENT_LINK_STA_REMOVED "CTRL-EVENT-LINK-STA-REMOVED "
+/** MLO link STA added through link reconfiguration */
+#define WPA_EVENT_LINK_STA_ADDED "CTRL-EVENT-LINK-STA-ADDED "
 
 /** IP subnet status change notification
  *
diff --git a/src/drivers/driver.h b/src/drivers/driver.h
index 54b4a9b18..54a3b694d 100644
--- a/src/drivers/driver.h
+++ b/src/drivers/driver.h
@@ -51,6 +51,7 @@ struct nan_publish_params;
 
 #define HOSTAPD_CHAN_INDOOR_ONLY 0x00010000
 #define HOSTAPD_CHAN_GO_CONCURRENT 0x00020000
+#define HOSTAPD_CHAN_AUTO_BW 0x00040000
 
 /* Allowed bandwidth mask */
 enum hostapd_chan_width_attr {
@@ -2762,6 +2763,22 @@ struct wpa_mlo_signal_info {
 	struct wpa_signal_info links[MAX_NUM_MLD_LINKS];
 };
 
+/**
+ * struct wpa_mlo_reconfig_info - Information about user-requested add and/or
+ * remove setup links for the current MLO association.
+ *
+ * @add_links: Bitmask of links to be added
+ * @add_link_bssid: Array of BSSIDs for the links to be added
+ * @add_link_freq: Array of frequencies for the links to be added
+ * @delete_links: Bitmask of links to be removed
+ */
+struct wpa_mlo_reconfig_info {
+	u16 add_links;
+	u8 add_link_bssid[MAX_NUM_MLD_LINKS][ETH_ALEN];
+	int add_link_freq[MAX_NUM_MLD_LINKS];
+	u16 delete_links;
+};
+
 /**
  * struct wpa_channel_info - Information about the current channel
  * @frequency: Center frequency of the primary 20 MHz channel
@@ -3847,13 +3864,14 @@ struct wpa_driver_ops {
 	 * @own_addr: Source address and BSSID for the Disassociation frame
 	 * @addr: MAC address of the station to disassociate
 	 * @reason: Reason code for the Disassociation frame
+	 * @link_id: Link ID to use for Disassociation frame, or -1 if not set
 	 * Returns: 0 on success, -1 on failure
 	 *
 	 * This function requests a specific station to be disassociated and
 	 * a Disassociation frame to be sent to it.
 	 */
 	int (*sta_disassoc)(void *priv, const u8 *own_addr, const u8 *addr,
-			    u16 reason);
+			    u16 reason, int link_id);
 
 	/**
 	 * sta_remove - Remove a station entry (AP only)
@@ -4466,6 +4484,15 @@ struct wpa_driver_ops {
 	int (*mlo_signal_poll)(void *priv,
 			       struct wpa_mlo_signal_info *mlo_signal_info);
 
+	/**
+	 * setup_link_reconfig - Used to initiate Link Reconfiguration request
+	 * for the current MLO association.
+	 * @priv: Private driver interface data
+	 * @info: Link reconfiguration request info
+	 */
+	int (*setup_link_reconfig)(void *priv,
+				   struct wpa_mlo_reconfig_info *info);
+
 	/**
 	 * channel_info - Get parameters of the current operating channel
 	 * @priv: Private driver interface data
@@ -6103,6 +6130,11 @@ enum wpa_event_type {
 	 * EVENT_MLD_INTERFACE_FREED - Notification of AP MLD interface removal
 	 */
 	EVENT_MLD_INTERFACE_FREED,
+
+	/**
+	 * EVENT_SETUP_LINK_RECONFIG - Notification that new AP links added
+	 */
+	EVENT_SETUP_LINK_RECONFIG,
 };
 
 
@@ -7090,6 +7122,17 @@ union wpa_event_data {
 		u8 valid_links;
 		struct t2lm_mapping t2lmap[MAX_NUM_MLD_LINKS];
 	} t2l_map_info;
+
+	/**
+	 * struct reconfig_info - Data for EVENT_SETUP_LINK_RECONFIG
+	 */
+	struct reconfig_info {
+		u16 added_links;
+		u8 count;
+		const u8 *status_list;
+		const u8 *resp_ie; /* Starting from Group Key Data */
+		size_t resp_ie_len;
+	} reconfig_info;
 };
 
 /**
diff --git a/src/drivers/driver_atheros.c b/src/drivers/driver_atheros.c
index 8fb23a802..94db413eb 100644
--- a/src/drivers/driver_atheros.c
+++ b/src/drivers/driver_atheros.c
@@ -783,7 +783,7 @@ atheros_sta_deauth(void *priv, const u8 *own_addr, const u8 *addr,
 
 static int
 atheros_sta_disassoc(void *priv, const u8 *own_addr, const u8 *addr,
-		     u16 reason_code)
+		     u16 reason_code, int link_id)
 {
 	struct atheros_driver_data *drv = priv;
 	struct ieee80211req_mlme mlme;
diff --git a/src/drivers/driver_bsd.c b/src/drivers/driver_bsd.c
index 66155b41c..b5d2e42f1 100644
--- a/src/drivers/driver_bsd.c
+++ b/src/drivers/driver_bsd.c
@@ -987,7 +987,7 @@ bsd_sta_deauth(void *priv, const u8 *own_addr, const u8 *addr, u16 reason_code,
 
 static int
 bsd_sta_disassoc(void *priv, const u8 *own_addr, const u8 *addr,
-		 u16 reason_code)
+		 u16 reason_code, int link_id)
 {
 	return bsd_send_mlme_param(priv, IEEE80211_MLME_DISASSOC, reason_code,
 				   addr);
@@ -1684,9 +1684,22 @@ bsd_global_init(void *ctx)
 
 	global->sock = socket(PF_INET, SOCK_DGRAM | SOCK_CLOEXEC, 0);
 	if (global->sock < 0) {
-		wpa_printf(MSG_ERROR, "socket[PF_INET,SOCK_DGRAM]: %s",
-			   strerror(errno));
-		goto fail1;
+		if (errno == EAFNOSUPPORT) {
+			wpa_printf(MSG_DEBUG,
+				   "INET not supported, trying INET6...");
+			global->sock = socket(PF_INET6,
+					      SOCK_DGRAM | SOCK_CLOEXEC, 0);
+			if (global->sock < 0) {
+				wpa_printf(MSG_ERROR,
+					   "socket[PF_INET6,SOCK_DGRAM]: %s",
+					   strerror(errno));
+				goto fail1;
+			}
+		} else {
+			wpa_printf(MSG_ERROR, "socket[PF_INET,SOCK_DGRAM]: %s",
+				   strerror(errno));
+			goto fail1;
+		}
 	}
 
 	global->route = socket(PF_ROUTE,
diff --git a/src/drivers/driver_common.c b/src/drivers/driver_common.c
index 7a9f18c21..045c82967 100644
--- a/src/drivers/driver_common.c
+++ b/src/drivers/driver_common.c
@@ -101,6 +101,7 @@ const char * event_to_string(enum wpa_event_type event)
 	E2S(TID_LINK_MAP);
 	E2S(LINK_RECONFIG);
 	E2S(MLD_INTERFACE_FREED);
+	E2S(SETUP_LINK_RECONFIG);
 	}
 
 	return "UNKNOWN";
diff --git a/src/drivers/driver_hostap.c b/src/drivers/driver_hostap.c
index 74c7767ba..e2c6c198c 100644
--- a/src/drivers/driver_hostap.c
+++ b/src/drivers/driver_hostap.c
@@ -1083,7 +1083,7 @@ static int hostap_set_freq(void *priv, struct hostapd_freq_params *freq)
 
 
 static int hostap_sta_disassoc(void *priv, const u8 *own_addr, const u8 *addr,
-			       u16 reason)
+			       u16 reason, int link_id)
 {
 	struct hostap_driver_data *drv = priv;
 	struct ieee80211_mgmt mgmt;
diff --git a/src/drivers/driver_nl80211.c b/src/drivers/driver_nl80211.c
index b7c666db4..ce86b72c4 100644
--- a/src/drivers/driver_nl80211.c
+++ b/src/drivers/driver_nl80211.c
@@ -182,8 +182,6 @@ static void add_ifidx(struct wpa_driver_nl80211_data *drv, int ifidx,
 		      int ifidx_reason);
 static void del_ifidx(struct wpa_driver_nl80211_data *drv, int ifidx,
 		      int ifidx_reason);
-static int have_ifidx(struct wpa_driver_nl80211_data *drv, int ifidx,
-		      int ifidx_reason);
 
 static int nl80211_set_channel(struct i802_bss *bss,
 			       struct hostapd_freq_params *freq, int set_chan);
@@ -201,7 +199,7 @@ static int nl80211_put_mesh_config(struct nl_msg *msg,
 				   struct wpa_driver_mesh_bss_params *params);
 #endif /* CONFIG_MESH */
 static int i802_sta_disassoc(void *priv, const u8 *own_addr, const u8 *addr,
-			     u16 reason);
+			     u16 reason, int link_id);
 
 
 /* Converts nl80211_chan_width to a common format */
@@ -1130,6 +1128,19 @@ static int nl80211_get_sta_mlo_info(void *priv,
 }
 
 
+int get_sta_mlo_interface_info(struct wpa_driver_nl80211_data *drv)
+{
+	struct nl_msg *msg;
+
+	msg = nl80211_drv_msg(drv, 0, NL80211_CMD_GET_INTERFACE);
+	if (!msg ||
+	    send_and_recv_resp(drv, msg, get_mlo_info, &drv->sta_mlo_info))
+		return -1;
+
+	return 0;
+}
+
+
 static void wpa_driver_nl80211_event_newlink(
 	struct nl80211_global *global, struct wpa_driver_nl80211_data *drv,
 	int ifindex, const char *ifname)
@@ -1259,7 +1270,7 @@ nl80211_find_drv(struct nl80211_global *global, int idx, u8 *buf, size_t len,
 				*init_failed = 1;
 			return drv;
 		}
-		if (res > 0 || have_ifidx(drv, idx, IFIDX_ANY))
+		if (res > 0 || nl80211_has_ifidx(drv, idx, IFIDX_ANY))
 			return drv;
 	}
 	return NULL;
@@ -1734,6 +1745,53 @@ try_again:
 }
 
 
+const u8 * nl80211_get_assoc_bssid(struct wpa_driver_nl80211_data *drv)
+{
+	struct nl_msg *msg;
+	int ret;
+	struct nl80211_get_assoc_freq_arg arg;
+	int count = 0;
+
+try_again:
+	msg = nl80211_drv_msg(drv, NLM_F_DUMP, NL80211_CMD_GET_SCAN);
+	if (!msg)
+		return NULL;
+	os_memset(&arg, 0, sizeof(arg));
+	arg.drv = drv;
+	ret = send_and_recv_resp(drv, msg, nl80211_get_assoc_freq_handler,
+				 &arg);
+	if (ret == -EAGAIN) {
+		count++;
+		if (count >= 10) {
+			wpa_printf(MSG_INFO,
+				   "nl80211: Failed to receive consistent scan result dump for get_assoc_bssid");
+		} else {
+			wpa_printf(MSG_DEBUG,
+				   "nl80211: Failed to receive consistent scan result dump for get_assoc_bssid - try again");
+			goto try_again;
+		}
+	}
+	if (ret == 0) {
+		os_memcpy(drv->bssid, arg.assoc_bssid, ETH_ALEN);
+
+		if (drv->sta_mlo_info.valid_links) {
+			int i;
+
+			for (i = 0; i < MAX_NUM_MLD_LINKS; i++)
+				os_memcpy(drv->sta_mlo_info.links[i].bssid,
+					  arg.bssid[i], ETH_ALEN);
+		}
+
+		return drv->bssid;
+	}
+
+	wpa_printf(MSG_DEBUG, "nl80211: Scan result fetch failed: ret=%d (%s)",
+		   ret, strerror(-ret));
+
+	return NULL;
+}
+
+
 static int get_link_noise(struct nl_msg *msg, void *arg)
 {
 	struct nlattr *tb[NL80211_ATTR_MAX + 1];
@@ -2785,6 +2843,11 @@ static int nl80211_action_subscribe_ap(struct i802_bss *bss)
 	if (nl80211_register_action_frame(bss, (u8 *) "\x12", 1) < 0)
 		ret = -1;
 #endif /* CONFIG_FST */
+#ifdef CONFIG_IEEE80211BE
+	/* Protected EHT - Link Reconfiguration Request */
+	if (nl80211_register_action_frame(bss, (u8 *) "\x25\x0b", 2) < 0)
+		ret = -1;
+#endif /* CONFIG_IEEE80211BE */
 	/* Vendor-specific Protected */
 	if (nl80211_register_action_frame(bss, (u8 *) "\x7e", 1) < 0)
 		ret = -1;
@@ -8435,7 +8498,8 @@ static int i802_sta_deauth(void *priv, const u8 *own_addr, const u8 *addr,
 	    HOSTAPD_MODE_IEEE80211AD) {
 		/* Deauthentication is not used in DMG/IEEE 802.11ad;
 		 * disassociate the STA instead. */
-		return i802_sta_disassoc(priv, own_addr, addr, reason);
+		return i802_sta_disassoc(priv, own_addr, addr, reason,
+					 link_id);
 	}
 
 	if (is_mesh_interface(drv->nlmode))
@@ -8459,7 +8523,7 @@ static int i802_sta_deauth(void *priv, const u8 *own_addr, const u8 *addr,
 
 
 static int i802_sta_disassoc(void *priv, const u8 *own_addr, const u8 *addr,
-			     u16 reason)
+			     u16 reason, int link_id)
 {
 	struct i802_bss *bss = priv;
 	struct wpa_driver_nl80211_data *drv = bss->drv;
@@ -8481,7 +8545,7 @@ static int i802_sta_disassoc(void *priv, const u8 *own_addr, const u8 *addr,
 	return wpa_driver_nl80211_send_mlme(bss, (u8 *) &mgmt,
 					    IEEE80211_HDRLEN +
 					    sizeof(mgmt.u.disassoc), 0, 0, 0, 0,
-					    0, NULL, 0, 0, -1);
+					    0, NULL, 0, 0, link_id);
 }
 
 
@@ -8519,7 +8583,7 @@ static void add_ifidx(struct wpa_driver_nl80211_data *drv, int ifidx,
 	wpa_printf(MSG_DEBUG,
 		   "nl80211: Add own interface ifindex %d (ifidx_reason %d)",
 		   ifidx, ifidx_reason);
-	if (have_ifidx(drv, ifidx, ifidx_reason)) {
+	if (nl80211_has_ifidx(drv, ifidx, ifidx_reason)) {
 		wpa_printf(MSG_DEBUG, "nl80211: ifindex %d already in the list",
 			   ifidx);
 		return;
@@ -8579,7 +8643,7 @@ static void del_ifidx(struct wpa_driver_nl80211_data *drv, int ifidx,
 }
 
 
-static int have_ifidx(struct wpa_driver_nl80211_data *drv, int ifidx,
+int nl80211_has_ifidx(struct wpa_driver_nl80211_data *drv, int ifidx,
 		      int ifidx_reason)
 {
 	int i;
@@ -8686,7 +8750,7 @@ static void handle_eapol(int sock, void *eloop_ctx, void *sock_ctx)
 		return;
 	}
 
-	if (have_ifidx(drv, lladdr.sll_ifindex, IFIDX_ANY)) {
+	if (nl80211_has_ifidx(drv, lladdr.sll_ifindex, IFIDX_ANY)) {
 		for (bss = drv->first_bss; bss; bss = bss->next)
 			drv_event_eapol_rx(bss->ctx, lladdr.sll_addr, buf, len);
 	}
@@ -9069,6 +9133,20 @@ static int wpa_driver_nl80211_if_add(void *priv, enum wpa_driver_if_type type,
 			return -1;
 		}
 
+		new_bss->ifindex = ifidx;
+		new_bss->drv = drv;
+		new_bss->next = drv->first_bss->next;
+		new_bss->flink = &new_bss->links[0];
+		new_bss->valid_links = 0;
+
+		new_bss->flink->freq = drv->first_bss->flink->freq;
+		new_bss->ctx = bss_ctx;
+		new_bss->added_if = added;
+
+		/* Set interface mode to NL80211_IFTYPE_AP */
+		if (nl80211_set_mode(new_bss, nlmode))
+			return -1;
+
 		if (bridge &&
 		    i802_check_bridge(drv, new_bss, bridge, ifname) < 0) {
 			wpa_printf(MSG_ERROR, "nl80211: Failed to add the new "
@@ -9089,25 +9167,13 @@ static int wpa_driver_nl80211_if_add(void *priv, enum wpa_driver_if_type type,
 		}
 		os_strlcpy(new_bss->ifname, ifname, IFNAMSIZ);
 		os_memcpy(new_bss->addr, if_addr, ETH_ALEN);
-		new_bss->ifindex = ifidx;
-		new_bss->drv = drv;
-		new_bss->next = drv->first_bss->next;
-		new_bss->flink = &new_bss->links[0];
-		new_bss->valid_links = 0;
 		os_memcpy(new_bss->flink->addr, new_bss->addr, ETH_ALEN);
 
-		new_bss->flink->freq = drv->first_bss->flink->freq;
-		new_bss->ctx = bss_ctx;
-		new_bss->added_if = added;
 		drv->first_bss->next = new_bss;
 		if (drv_priv)
 			*drv_priv = new_bss;
 		nl80211_init_bss(new_bss);
 
-		/* Set interface mode to NL80211_IFTYPE_AP */
-		if (nl80211_set_mode(new_bss, nlmode))
-			return -1;
-
 		/* Subscribe management frames for this WPA_IF_AP_BSS */
 		if (nl80211_setup_ap(new_bss))
 			return -1;
@@ -13584,6 +13650,8 @@ static int nl80211_send_pasn_resp(void *priv, struct pasn_auth *params)
 		goto fail;
 
 	for (i = 0; i < params->num_peers; i++) {
+		int akmp, cipher;
+
 		attr1 = nla_nest_start(msg, i);
 		if (!attr1 ||
 		    nla_put(msg, QCA_WLAN_VENDOR_ATTR_PASN_PEER_SRC_ADDR,
@@ -13597,12 +13665,22 @@ static int nl80211_send_pasn_resp(void *priv, struct pasn_auth *params)
 				 QCA_WLAN_VENDOR_ATTR_PASN_PEER_STATUS_SUCCESS))
 			goto fail;
 
+		akmp = params->peer[i].akmp;
+		cipher = params->peer[i].cipher;
+		if (nla_put_u32(msg, QCA_WLAN_VENDOR_ATTR_PASN_PEER_AKM,
+				wpa_akm_to_suite(akmp)) ||
+		    nla_put_u32(msg, QCA_WLAN_VENDOR_ATTR_PASN_PEER_CIPHER,
+				wpa_cipher_to_cipher_suite(cipher)))
+			goto fail;
+
 		wpa_printf(MSG_DEBUG,
 			   "nl80211: Own address[%u]: " MACSTR
-			   " Peer address[%u]: " MACSTR " Status: %s",
+			   " Peer address[%u]: " MACSTR
+			   " Status: %s AKMP: 0x%x cipher: 0x%x",
 			   i, MAC2STR(params->peer[i].own_addr), i,
 			   MAC2STR(params->peer[i].peer_addr),
-			   params->peer[i].status ? "Fail" : "Success");
+			   params->peer[i].status ? "Fail" : "Success",
+			   akmp, cipher);
 		nla_nest_end(msg, attr1);
 	}
 
@@ -14713,6 +14791,77 @@ free_all:
 	return ret;
 }
 
+
+static int
+nl80211_send_link_reconfig_request(void *priv,
+				   struct wpa_mlo_reconfig_info *info)
+{
+	struct i802_bss *bss = priv;
+	struct wpa_driver_nl80211_data *drv = bss->drv;
+	struct nl_msg *msg;
+	struct nlattr *add_links, *attr;
+	int ret = -1;
+	u8 link_id;
+
+	if (!drv->sta_mlo_info.valid_links)
+		return -1;
+
+	wpa_printf(MSG_DEBUG, "nl80211: Send ML Link Reconfiguration Request");
+
+	if (info->add_links)
+		wpa_printf(MSG_DEBUG, "Add Setup Links Bitmask: 0x%x",
+			   info->add_links);
+
+	if (info->delete_links)
+		wpa_printf(MSG_DEBUG, "Remove Setup Links Bitmask: 0x%x",
+			   info->delete_links);
+
+	msg = nl80211_drv_msg(drv, 0, NL80211_CMD_ASSOC_MLO_RECONF);
+	if (!msg)
+		goto error;
+
+	add_links = nla_nest_start(msg, NL80211_ATTR_MLO_LINKS);
+	if (!add_links)
+		goto error;
+
+	for_each_link(info->add_links, link_id) {
+		attr = nla_nest_start(msg, 0);
+		if (!attr)
+			goto error;
+
+		if (nla_put_u8(msg, NL80211_ATTR_MLO_LINK_ID, link_id) ||
+		    nla_put(msg, NL80211_ATTR_MAC, ETH_ALEN,
+			    info->add_link_bssid[link_id]) ||
+		    nla_put_u32(msg, NL80211_ATTR_WIPHY_FREQ,
+				info->add_link_freq[link_id]))
+			goto error;
+
+		nla_nest_end(msg, attr);
+	}
+
+	nla_nest_end(msg, add_links);
+
+	if (nla_put_u16(msg, NL80211_ATTR_MLO_RECONF_REM_LINKS,
+			info->delete_links))
+		goto error;
+
+	ret = send_and_recv(drv, bss->nl_connect, msg, NULL, NULL, NULL, NULL,
+			    NULL);
+	if (ret) {
+		wpa_printf(MSG_INFO,
+			   "nl80211: Failed to send Link Reconfiguration Request err=%d (%s)",
+			   ret, strerror(-ret));
+		return ret;
+	}
+	return 0;
+
+error:
+	nlmsg_free(msg);
+	wpa_printf(MSG_ERROR,
+		   "nl80211: Could not build Link Reconfiguration Request");
+	return ret;
+}
+
 #endif /* CONFIG_IEEE80211BE */
 
 
@@ -14934,6 +15083,7 @@ const struct wpa_driver_ops wpa_driver_nl80211_ops = {
 	.is_drv_shared = nl80211_is_drv_shared,
 	.link_sta_remove = wpa_driver_nl80211_link_sta_remove,
 	.can_share_drv = wpa_driver_nl80211_can_share_drv,
+	.setup_link_reconfig = nl80211_send_link_reconfig_request,
 #endif /* CONFIG_IEEE80211BE */
 #ifdef CONFIG_TESTING_OPTIONS
 	.register_frame = testing_nl80211_register_frame,
diff --git a/src/drivers/driver_nl80211.h b/src/drivers/driver_nl80211.h
index bea87afeb..674c26a71 100644
--- a/src/drivers/driver_nl80211.h
+++ b/src/drivers/driver_nl80211.h
@@ -330,6 +330,7 @@ int nl80211_create_iface(struct wpa_driver_nl80211_data *drv,
 			 void *arg, int use_existing);
 void nl80211_remove_iface(struct wpa_driver_nl80211_data *drv, int ifidx);
 unsigned int nl80211_get_assoc_freq(struct wpa_driver_nl80211_data *drv);
+const u8 * nl80211_get_assoc_bssid(struct wpa_driver_nl80211_data *drv);
 int nl80211_get_assoc_ssid(struct wpa_driver_nl80211_data *drv, u8 *ssid);
 enum chan_width convert2width(int width);
 void nl80211_mark_disconnected(struct wpa_driver_nl80211_data *drv);
@@ -370,6 +371,8 @@ struct i802_link * nl80211_get_link(struct i802_bss *bss, s8 link_id);
 u8 nl80211_get_link_id_from_link(struct i802_bss *bss, struct i802_link *link);
 int nl80211_remove_link(struct i802_bss *bss, int link_id);
 void nl80211_update_active_links(struct i802_bss *bss, int link_id);
+int nl80211_has_ifidx(struct wpa_driver_nl80211_data *drv, int ifidx,
+		      int ifidx_reason);
 
 static inline bool nl80211_link_valid(u16 links, s8 link_id)
 {
@@ -431,4 +434,6 @@ struct hostapd_multi_hw_info *
 nl80211_get_multi_hw_info(struct i802_bss *bss, unsigned int *num_multi_hws);
 u32 get_nl80211_protocol_features(struct wpa_driver_nl80211_data *drv);
 
+int get_sta_mlo_interface_info(struct wpa_driver_nl80211_data *drv);
+
 #endif /* DRIVER_NL80211_H */
diff --git a/src/drivers/driver_nl80211_capa.c b/src/drivers/driver_nl80211_capa.c
index 670366848..88ee9e724 100644
--- a/src/drivers/driver_nl80211_capa.c
+++ b/src/drivers/driver_nl80211_capa.c
@@ -2390,7 +2390,7 @@ static void nl80211_reg_rule_sec(struct nlattr *tb[],
 
 
 static void nl80211_set_vht_mode(struct hostapd_hw_modes *mode, int start,
-				 int end, int max_bw)
+				 int end, int max_bw, u32 flags)
 {
 	int c;
 
@@ -2405,6 +2405,9 @@ static void nl80211_set_vht_mode(struct hostapd_hw_modes *mode, int start,
 
 		if (max_bw >= 160)
 			chan->flag |= HOSTAPD_CHAN_VHT_160MHZ_SUBCHANNEL;
+
+		if (flags & NL80211_RRF_AUTO_BW)
+			chan->flag |= HOSTAPD_CHAN_AUTO_BW;
 	}
 }
 
@@ -2412,7 +2415,7 @@ static void nl80211_set_vht_mode(struct hostapd_hw_modes *mode, int start,
 static void nl80211_reg_rule_vht(struct nlattr *tb[],
 				 struct phy_info_arg *results)
 {
-	u32 start, end, max_bw;
+	u32 start, end, max_bw, flags = 0;
 	u16 m;
 
 	if (tb[NL80211_ATTR_FREQ_RANGE_START] == NULL ||
@@ -2424,6 +2427,9 @@ static void nl80211_reg_rule_vht(struct nlattr *tb[],
 	end = nla_get_u32(tb[NL80211_ATTR_FREQ_RANGE_END]) / 1000;
 	max_bw = nla_get_u32(tb[NL80211_ATTR_FREQ_RANGE_MAX_BW]) / 1000;
 
+	if (tb[NL80211_ATTR_REG_RULE_FLAGS])
+		flags = nla_get_u32(tb[NL80211_ATTR_REG_RULE_FLAGS]);
+
 	if (max_bw < 80)
 		return;
 
@@ -2435,7 +2441,8 @@ static void nl80211_reg_rule_vht(struct nlattr *tb[],
 		if (!results->modes[m].vht_capab)
 			continue;
 
-		nl80211_set_vht_mode(&results->modes[m], start, end, max_bw);
+		nl80211_set_vht_mode(&results->modes[m], start, end,
+				     max_bw, flags);
 	}
 }
 
diff --git a/src/drivers/driver_nl80211_event.c b/src/drivers/driver_nl80211_event.c
index e7b67371a..b331d92d0 100644
--- a/src/drivers/driver_nl80211_event.c
+++ b/src/drivers/driver_nl80211_event.c
@@ -918,6 +918,47 @@ out:
 #endif /* CONFIG_DRIVER_NL80211_QCA */
 
 
+static void mlme_event_link_removal(struct wpa_driver_nl80211_data *drv,
+				    struct nlattr *mlo_links)
+{
+	struct nlattr *link;
+	u16 removed_links = 0;
+	int rem_links, i;
+
+	if (!mlo_links)
+		return;
+	nla_for_each_nested(link, mlo_links, rem_links) {
+		struct nlattr *tb[NL80211_ATTR_MAX + 1];
+		int link_id;
+
+		nla_parse(tb, NL80211_ATTR_MAX, nla_data(link), nla_len(link),
+			  NULL);
+
+		if (!tb[NL80211_ATTR_MLO_LINK_ID])
+			continue;
+
+		link_id = nla_get_u8(tb[NL80211_ATTR_MLO_LINK_ID]);
+		if (link_id >= MAX_NUM_MLD_LINKS)
+			continue;
+
+		removed_links |= BIT(link_id);
+	}
+
+	drv->sta_mlo_info.valid_links &= ~removed_links;
+	drv->sta_mlo_info.req_links &= ~removed_links;
+
+	for (i = 0; i < MAX_NUM_MLD_LINKS; i++) {
+		if (!(removed_links & BIT(i)))
+			continue;
+
+		os_memset(&drv->sta_mlo_info.links[i], 0,
+			  sizeof(drv->sta_mlo_info.links[i]));
+	}
+
+	wpa_supplicant_event(drv->ctx, EVENT_LINK_RECONFIG, NULL);
+}
+
+
 static void mlme_event_connect(struct wpa_driver_nl80211_data *drv,
 			       enum nl80211_commands cmd, bool qca_roam_auth,
 			       struct nlattr *status,
@@ -1657,6 +1698,69 @@ static void mlme_event_unprot_beacon(struct wpa_driver_nl80211_data *drv,
 }
 
 
+static void mlme_event_link_addition(struct wpa_driver_nl80211_data *drv,
+				     const u8 *frame, size_t len)
+{
+	const struct ieee80211_mgmt *mgmt;
+	union wpa_event_data event;
+	u16 curr_valid_links, added_links;
+	u8 count;
+	const u8 *resp_ie;
+	const u8 *end;
+
+	if (!frame) {
+		wpa_printf(MSG_DEBUG,
+			   "Link Reconfiguration Response frame is NULL - unspecified reason");
+		return;
+	}
+	wpa_hexdump(MSG_DEBUG, "JKM", frame, len);
+	end = frame + len;
+
+	os_memset(&event, 0, sizeof(event));
+
+	mgmt = (const struct ieee80211_mgmt *) frame;
+
+	if (len < 24 + 1 + sizeof(mgmt->u.action.u.link_reconf_resp)) {
+		wpa_printf(MSG_DEBUG,
+			   "nl80211: Too short Link Reconfig Response frame");
+		return;
+	}
+
+	count = mgmt->u.action.u.link_reconf_resp.count;
+	event.reconfig_info.count = count;
+	resp_ie = mgmt->u.action.u.link_reconf_resp.variable;
+	if (end - resp_ie < 3 * count) {
+		wpa_printf(MSG_DEBUG,
+			   "nl80211: Truncated Link Reconfig Response frame");
+		return;
+	}
+	event.reconfig_info.status_list = resp_ie;
+	resp_ie += 3 * count;
+	curr_valid_links = drv->sta_mlo_info.valid_links;
+
+	if (get_sta_mlo_interface_info(drv) < 0) {
+		wpa_printf(MSG_INFO, "nl80211: Failed to get STA MLO info");
+		return;
+	}
+
+	if (!nl80211_get_assoc_bssid(drv)) {
+		wpa_printf(MSG_INFO,
+			   "nl80211: Failed to get BSSID info for newly added links");
+		return;
+	}
+
+	added_links = ~curr_valid_links & drv->sta_mlo_info.valid_links;
+
+	event.reconfig_info.resp_ie = resp_ie;
+	event.reconfig_info.resp_ie_len = end - resp_ie;
+	event.reconfig_info.added_links = added_links;
+
+	drv->sta_mlo_info.req_links = drv->sta_mlo_info.valid_links;
+
+	wpa_supplicant_event(drv->ctx, EVENT_SETUP_LINK_RECONFIG, &event);
+}
+
+
 static s8
 nl80211_get_link_id_by_freq(struct i802_bss *bss, unsigned int freq)
 {
@@ -4245,7 +4349,10 @@ static void do_process_drv_event(struct i802_bss *bss, int cmd,
 		break;
 #endif /* CONFIG_IEEE80211AX */
 	case NL80211_CMD_LINKS_REMOVED:
-		wpa_supplicant_event(drv->ctx, EVENT_LINK_RECONFIG, NULL);
+		mlme_event_link_removal(drv, tb[NL80211_ATTR_MLO_LINKS]);
+		break;
+	case NL80211_CMD_ASSOC_MLO_RECONF:
+		mlme_event_link_addition(drv, nla_data(frame), nla_len(frame));
 		break;
 	default:
 		wpa_dbg(drv->ctx, MSG_DEBUG, "nl80211: Ignored unknown event "
@@ -4329,6 +4436,8 @@ int process_global_event(struct nl_msg *msg, void *arg)
 				wiphy_idx = nl80211_get_wiphy_index(bss);
 			if ((ifidx == -1 && !wiphy_idx_set && !wdev_id_set) ||
 			    ifidx == bss->ifindex ||
+			    (bss->br_ifindex > 0 &&
+			     nl80211_has_ifidx(drv, bss->br_ifindex, ifidx)) ||
 			    (wiphy_idx_set && wiphy_idx == wiphy_idx_rx) ||
 			    (wdev_id_set && bss->wdev_id_set &&
 			     wdev_id == bss->wdev_id)) {
diff --git a/src/p2p/p2p_pd.c b/src/p2p/p2p_pd.c
index f08fa0e10..b0f893e7f 100644
--- a/src/p2p/p2p_pd.c
+++ b/src/p2p/p2p_pd.c
@@ -1713,7 +1713,8 @@ static void p2p_process_prov_disc_bootstrap_resp(struct p2p_data *p2p,
 
 		if (p2p->cfg->bootstrap_rsp_rx)
 			p2p->cfg->bootstrap_rsp_rx(p2p->cfg->cb_ctx, sa, status,
-						   rx_freq, bootstrap);
+						   rx_freq,
+						   dev->req_bootstrap_method);
 		return;
 	}
 
@@ -1721,13 +1722,35 @@ static void p2p_process_prov_disc_bootstrap_resp(struct p2p_data *p2p,
 	if (msg->pbma_info_len >= 2)
 		bootstrap = WPA_GET_LE16(msg->pbma_info);
 
+	/* Overwrite the status if bootstrap method does not match */
+	if (status == P2P_SC_SUCCESS &&
+	    !(bootstrap == P2P_PBMA_PIN_CODE_DISPLAY &&
+	      dev->req_bootstrap_method == P2P_PBMA_PIN_CODE_KEYPAD) &&
+	    !(bootstrap == P2P_PBMA_PIN_CODE_KEYPAD &&
+	      dev->req_bootstrap_method == P2P_PBMA_PIN_CODE_DISPLAY) &&
+	    !(bootstrap == P2P_PBMA_PASSPHRASE_DISPLAY &&
+	      dev->req_bootstrap_method == P2P_PBMA_PASSPHRASE_KEYPAD) &&
+	    !(bootstrap == P2P_PBMA_PASSPHRASE_KEYPAD &&
+	      dev->req_bootstrap_method == P2P_PBMA_PASSPHRASE_DISPLAY) &&
+	    !(bootstrap == P2P_PBMA_NFC_TAG &&
+	      dev->req_bootstrap_method == P2P_PBMA_NFC_READER) &&
+	    !(bootstrap == P2P_PBMA_NFC_READER &&
+	      dev->req_bootstrap_method == P2P_PBMA_NFC_TAG) &&
+	    !(bootstrap == P2P_PBMA_QR_DISPLAY &&
+	      dev->req_bootstrap_method == P2P_PBMA_QR_SCAN) &&
+	    !(bootstrap == P2P_PBMA_QR_SCAN &&
+	      dev->req_bootstrap_method == P2P_PBMA_QR_DISPLAY) &&
+	    !(bootstrap == P2P_PBMA_OPPORTUNISTIC &&
+	      dev->req_bootstrap_method == P2P_PBMA_OPPORTUNISTIC))
+		status = P2P_SC_FAIL_INVALID_PARAMS;
+
 	p2p->cfg->send_action_done(p2p->cfg->cb_ctx);
 	if (dev->flags & P2P_DEV_PD_BEFORE_GO_NEG)
 		dev->flags &= ~P2P_DEV_PD_BEFORE_GO_NEG;
 
 	if (p2p->cfg->bootstrap_rsp_rx)
 		p2p->cfg->bootstrap_rsp_rx(p2p->cfg->cb_ctx, sa, status,
-					   rx_freq, bootstrap);
+					   rx_freq, dev->req_bootstrap_method);
 }
 
 
diff --git a/src/radius/radius.c b/src/radius/radius.c
index 029e6223c..40c037dcc 100644
--- a/src/radius/radius.c
+++ b/src/radius/radius.c
@@ -807,7 +807,7 @@ struct radius_attr_hdr * radius_msg_add_attr(struct radius_msg *msg, u16 type,
 			ext->length = sizeof(*ext) + 1 + alen;
 			ext->ext_type = ext_type;
 			wpabuf_put_u8(msg->buf, data_len > alen ? 0x80 : 0);
-			wpabuf_put_data(msg->buf, data, data_len);
+			wpabuf_put_data(msg->buf, data, alen);
 			data += alen;
 			data_len -= alen;
 			if (radius_msg_add_attr_to_array(
diff --git a/src/rsn_supp/wpa.c b/src/rsn_supp/wpa.c
index 49412854c..f5319c606 100644
--- a/src/rsn_supp/wpa.c
+++ b/src/rsn_supp/wpa.c
@@ -4729,14 +4729,36 @@ void wpa_sm_set_ssid(struct wpa_sm *sm, const u8 *ssid, size_t ssid_len)
 }
 
 
+static void wpa_sm_clear_mlo_group_keys(struct wpa_sm *sm, int link_id)
+{
+	if (!sm)
+		return;
+
+	os_memset(&sm->mlo.links[link_id].gtk, 0,
+		  sizeof(sm->mlo.links[link_id].gtk));
+	os_memset(&sm->mlo.links[link_id].gtk_wnm_sleep, 0,
+		  sizeof(sm->mlo.links[link_id].gtk_wnm_sleep));
+	os_memset(&sm->mlo.links[link_id].igtk, 0,
+		  sizeof(sm->mlo.links[link_id].igtk));
+	os_memset(&sm->mlo.links[link_id].igtk_wnm_sleep, 0,
+		  sizeof(sm->mlo.links[link_id].igtk_wnm_sleep));
+	os_memset(&sm->mlo.links[link_id].bigtk, 0,
+		  sizeof(sm->mlo.links[link_id].bigtk));
+	os_memset(&sm->mlo.links[link_id].bigtk_wnm_sleep, 0,
+		  sizeof(sm->mlo.links[link_id].bigtk_wnm_sleep));
+}
+
+
 int wpa_sm_set_mlo_params(struct wpa_sm *sm, const struct wpa_sm_mlo *mlo)
 {
 	int i;
+	u16 removed_links;
 
 	if (!sm)
 		return -1;
 
 	os_memcpy(sm->mlo.ap_mld_addr, mlo->ap_mld_addr, ETH_ALEN);
+	removed_links = ~mlo->valid_links & sm->mlo.valid_links;
 	sm->mlo.assoc_link_id =  mlo->assoc_link_id;
 	sm->mlo.valid_links = mlo->valid_links;
 	sm->mlo.req_links = mlo->req_links;
@@ -4865,6 +4887,13 @@ int wpa_sm_set_mlo_params(struct wpa_sm *sm, const struct wpa_sm_mlo *mlo)
 			}
 			sm->mlo.links[i].ap_rsnxoe_len = len;
 		}
+
+		if (removed_links & BIT(i)) {
+			wpa_printf(MSG_DEBUG,
+				   "RSN: Clearing MLO group keys for link[%u]",
+				   i);
+			wpa_sm_clear_mlo_group_keys(sm, i);
+		}
 	}
 
 	return 0;
@@ -7282,3 +7311,70 @@ struct wpabuf * wpa_sm_known_sta_identification(struct wpa_sm *sm, const u8 *aa,
 
 	return ie;
 }
+
+
+static int mlo_ieee80211w_set_keys_for_new_links(struct wpa_sm *sm,
+						 struct wpa_eapol_ie_parse *ie,
+						 u16 added_links_bitmap)
+{
+	int i;
+
+	if (!wpa_cipher_valid_mgmt_group(sm->mgmt_group_cipher) ||
+	    sm->mgmt_group_cipher == WPA_CIPHER_GTK_NOT_USED)
+		return 0;
+
+	for_each_link(added_links_bitmap, i) {
+		if (_mlo_ieee80211w_set_keys(sm, i, ie))
+			return -1;
+	}
+
+	return 0;
+}
+
+
+static int wpa_supplicant_install_mlo_gtk_keys(struct wpa_sm *sm,
+					       struct wpa_eapol_ie_parse *ie,
+					       u16 added_links_bitmap)
+{
+	int i;
+
+	for_each_link(added_links_bitmap, i) {
+		if (!ie->mlo_gtk[i]) {
+			wpa_msg(sm->ctx->msg_ctx, MSG_INFO,
+				"MLO RSN: GTK not found for link ID %u", i);
+			return -1;
+		}
+
+		if (wpa_supplicant_mlo_gtk(sm, i, ie->mlo_gtk[i],
+					   ie->mlo_gtk_len[i], 0))
+			return -1;
+	}
+
+	return 0;
+}
+
+
+int wpa_sm_install_mlo_group_keys(struct wpa_sm *sm, const u8 *key_data,
+				  size_t key_data_len, u16 added_links_bitmap)
+{
+	struct wpa_eapol_ie_parse ie;
+
+	if (!sm)
+		return -1;
+
+	wpa_hexdump_key(MSG_DEBUG, "RSN: IE KeyData for MLO link reconfig",
+			key_data, key_data_len);
+
+	if (wpa_supplicant_parse_ies(key_data, key_data_len, &ie) < 0)
+		return -1;
+
+	if (wpa_supplicant_install_mlo_gtk_keys(
+		    sm, &ie, added_links_bitmap) < 0)
+		return -1;
+
+	if (mlo_ieee80211w_set_keys_for_new_links(sm, &ie,
+						  added_links_bitmap) < 0)
+		return -1;
+
+	return 0;
+}
diff --git a/src/rsn_supp/wpa.h b/src/rsn_supp/wpa.h
index c011162f7..0c360bdea 100644
--- a/src/rsn_supp/wpa.h
+++ b/src/rsn_supp/wpa.h
@@ -676,5 +676,7 @@ void wpa_sm_set_cur_pmksa(struct wpa_sm *sm,
 const u8 * wpa_sm_get_auth_addr(struct wpa_sm *sm);
 struct wpabuf * wpa_sm_known_sta_identification(struct wpa_sm *sm, const u8 *aa,
 						u64 timestamp);
+int wpa_sm_install_mlo_group_keys(struct wpa_sm *sm, const u8 *key_data,
+				  size_t key_data_len, u16 added_links_bitmap);
 
 #endif /* WPA_H */
diff --git a/tests/hwsim/example-wpa_supplicant.config b/tests/hwsim/example-wpa_supplicant.config
index c7b56996d..a43bdc5ce 100644
--- a/tests/hwsim/example-wpa_supplicant.config
+++ b/tests/hwsim/example-wpa_supplicant.config
@@ -167,3 +167,5 @@ CONFIG_DPP3=y
 CONFIG_WEP=y
 CONFIG_PASN=y
 CONFIG_NAN_USD=y
+
+CONFIG_IEEE80211BE=y
diff --git a/tests/hwsim/test_eht.py b/tests/hwsim/test_eht.py
index f254d00b3..e17dfd488 100644
--- a/tests/hwsim/test_eht.py
+++ b/tests/hwsim/test_eht.py
@@ -330,9 +330,13 @@ def test_eht_mld_discovery(dev, apdev):
         link1_params = {"ssid": ssid,
                         "hw_mode": "g",
                         "channel": "2"}
+        link2_params = {"ssid": ssid,
+                        "hw_mode": "g",
+                        "channel": "3"}
 
         hapd0 = eht_mld_enable_ap(hapd_iface, 0, link0_params)
         hapd1 = eht_mld_enable_ap(hapd_iface, 1, link1_params)
+        hapd2 = eht_mld_enable_ap(hapd_iface, 2, link2_params)
 
         # Only scan link 0
         res = wpas.request("SCAN freq=2412")
@@ -349,15 +353,16 @@ def test_eht_mld_discovery(dev, apdev):
 
         logger.info("Scan done")
 
-        rnr_pattern = re.compile(".*ap_info.*, mld ID=0, link ID=",
+        rnr_pattern = re.compile("^.*ap_info.*, bssid=(.*?),.*mld ID=0, link ID=([0-9]*).*$",
                                  re.MULTILINE)
         ml_pattern = re.compile(".*multi-link:.*, MLD addr=.*", re.MULTILINE)
 
         bss = wpas.request("BSS " + hapd0.own_addr())
         logger.info("BSS 0: " + str(bss))
 
-        if rnr_pattern.search(bss) is None:
-            raise Exception("RNR element not found for first link")
+        rnr_entries = rnr_pattern.findall(bss)
+        if (hapd1.own_addr(), '1') not in rnr_entries or (hapd2.own_addr(), '2') not in rnr_entries:
+            raise Exception("RNR entries for other links not found on first link, found: " + str(rnr_pattern.findall(bss)))
 
         if ml_pattern.search(bss) is None:
             raise Exception("ML element not found for first link")
@@ -379,8 +384,9 @@ def test_eht_mld_discovery(dev, apdev):
         bss = wpas.request("BSS " + hapd1.own_addr())
         logger.info("BSS 1: " + str(bss))
 
-        if rnr_pattern.search(bss) is None:
-            raise Exception("RNR element not found for second link")
+        rnr_entries = rnr_pattern.findall(bss)
+        if (hapd0.own_addr(), '0') not in rnr_entries or (hapd2.own_addr(), '2') not in rnr_entries:
+            raise Exception("RNR entries for other links not found on second link, found: " + str(rnr_entries))
 
         if ml_pattern.search(bss) is None:
             raise Exception("ML element not found for second link")
@@ -2605,3 +2611,87 @@ def test_eht_mld_no_common_key_mgmt(dev, apdev):
 
         eht_verify_wifi_version(wpas)
         traffic_test(wpas, hapd_selected)
+
+def test_eht_ml_setup_reconfig_AB_A_AB(dev, apdev, params):
+        """EHT MLD with two links. ML Setup reconfig link removal and addition"""
+        with HWSimRadio(use_mlo=True) as (hapd_radio, hapd_iface), \
+            HWSimRadio(use_mlo=True) as (wpas_radio, wpas_iface):
+
+            wpas = WpaSupplicant(global_iface='/tmp/wpas-wlan5')
+            wpas.interface_add(wpas_iface)
+            check_sae_capab(wpas)
+
+            # Associate AP and STA in two links
+            ssid = "eht_ml_reconf"
+            passphrase = 'qwertyuiop'
+
+            ap_params = eht_mld_ap_wpa2_params(ssid, passphrase,
+                                            key_mgmt="SAE", mfp="2", pwe='1')
+            hapd0 = eht_mld_enable_ap(hapd_iface, 0, ap_params)
+
+            ap_params['channel'] = '6'
+            hapd1 = eht_mld_enable_ap(hapd_iface, 1, ap_params)
+
+            wpas.set("sae_pwe", "1")
+            wpas.connect(ssid, sae_password=passphrase, scan_freq="2412 2437",
+                         key_mgmt="SAE", ieee80211w="2")
+
+            eht_verify_status(wpas, hapd0, 2412, 20, is_ht=True, mld=True,
+                              valid_links=3, active_links=3)
+            eht_verify_wifi_version(wpas)
+            traffic_test(wpas, hapd0)
+
+            # Prepare and send ML Setup reconfig link removal for link id=1
+            link_id = '1'
+            sta = hapd0.get_sta(wpas.own_addr())
+
+            if "OK" not in wpas.request("SETUP_LINK_RECONFIG delete={}".format(link_id)):
+                raise Exception("Failed to request link reconfig removal for link={}".format(link_id))
+
+            filters = ["wlan.fc.type_subtype == 0x000d && " +
+                       "(wlan.sa == {} && wlan.da == {})".format(hapd0.own_addr(), sta['peer_addr[0]'])]
+            out = run_tshark(os.path.join(params['logdir'], 'hwsim0.pcapng'),
+                             filters, display=['frame.number'])
+            if not out.splitlines():
+                raise Exception('No Link Reconfig response frame found for removal')
+
+            ev = hapd0.wait_event(["CTRL-EVENT-LINK-STA-REMOVED"], timeout=10)
+            if ev is None:
+                raise Exception("Link STA removal event not seen")
+
+            if "sta={} link_id={}".format(wpas.own_addr(), link_id) not in ev:
+                raise Exception("Unexpected sta/link id for ML Setup reconfig link removal")
+
+            # Prepare and send ML Setup reconfig link add for link id=1
+            sta = hapd0.get_sta(wpas.own_addr())
+
+            if "OK" not in wpas.request("SETUP_LINK_RECONFIG add={}".format(link_id)):
+                raise Exception("Failed to request link reconfig add for link={}".format(link_id))
+
+            filters = ["wlan.fc.type_subtype == 0x000d && " +
+                       "(wlan.sa == {} && (wlan.da == {}))".format(hapd0.own_addr(), sta['peer_addr[0]'])]
+            out = run_tshark(os.path.join(params['logdir'], 'hwsim0.pcapng'),
+                             filters, display=['frame.number'])
+            if len(out.splitlines()) < 2:
+                raise Exception('No Link Reconfig response frame found for addition')
+
+            ev = hapd0.wait_event(["CTRL-EVENT-LINK-STA-ADDED"], timeout=10)
+            if ev is None:
+                raise Exception("Link STA addition event not seen")
+
+            if "sta={} link_id={}".format(wpas.own_addr(), link_id) not in ev:
+                raise Exception("Unexpected sta/link id for ML Setup reconfig link addition")
+
+            sta = hapd0.get_sta(wpas.own_addr())
+            try:
+                sta['peer_addr[1]']
+            except KeyError:
+                raise Exception('Link failed to add using ML Setup reconfig')
+
+            if "OK" not in hapd0.request("REKEY_GTK"):
+                raise Exception("REKEY_GTK failed")
+
+            ev = wpas.wait_event(["MLO RSN: Group rekeying completed"],
+                                 timeout=2)
+            if ev is None:
+                raise Exception("GTK rekey timed out after link addition")
diff --git a/tests/hwsim/test_pasn.py b/tests/hwsim/test_pasn.py
index 5a2ec578b..da6719373 100644
--- a/tests/hwsim/test_pasn.py
+++ b/tests/hwsim/test_pasn.py
@@ -1068,6 +1068,10 @@ def test_pasn_sae_driver(dev, apdev):
         time.sleep(1)
         dev[0].dump_monitor()
 
+        cmd2 = f"PASN_DRIVER del {bssid} {bssid2}"
+        if "OK" not in dev[0].request(cmd2):
+            raise Exception("PASN_DRIVER failed")
+
         if "OK" not in dev[0].request(cmd):
             raise Exception("PASN_DRIVER failed")
 
diff --git a/tests/hwsim/tshark.py b/tests/hwsim/tshark.py
index 73e54b6df..89ccb6104 100644
--- a/tests/hwsim/tshark.py
+++ b/tests/hwsim/tshark.py
@@ -111,8 +111,12 @@ def run_tshark(filename, filters, display=None, wait=True):
                     all_wlan_mgt = False
                     break
             if not all_wlan_mgt:
-                raise
-            return _run_tshark(filename, filter, display, wait)
+                last_exception = e
+                continue
+            try:
+                return _run_tshark(filename, filter, display, wait)
+            except Exception as e:
+                last_exception = e
 
         except AssertionError as e:
             # Catch the error (and try the next provided filter)
diff --git a/wpa_supplicant/ctrl_iface.c b/wpa_supplicant/ctrl_iface.c
index 97d9ae1f0..8c81fd549 100644
--- a/wpa_supplicant/ctrl_iface.c
+++ b/wpa_supplicant/ctrl_iface.c
@@ -5095,17 +5095,13 @@ static int print_fils_indication(struct wpa_bss *bss, char *pos, char *end)
 #endif /* CONFIG_FILS */
 
 
-static int print_rnr(struct wpa_bss *bss, char *pos, char *end)
+static int print_rnr(const u8 *ie, char *pos, char *end)
 {
 	char *start = pos;
-	const u8 *ie, *ie_end;
+	const u8 *ie_end;
 	unsigned int n = 0;
 	int ret;
 
-	ie = wpa_bss_get_ie(bss, WLAN_EID_REDUCED_NEIGHBOR_REPORT);
-	if (!ie)
-		return 0;
-
 	ie_end = ie + 2 + ie[1];
 	ie += 2;
 
@@ -5114,93 +5110,102 @@ static int print_rnr(struct wpa_bss *bss, char *pos, char *end)
 			(const struct ieee80211_neighbor_ap_info *) ie;
 		const u8 *tbtt_start;
 		size_t left = ie_end - ie;
+		unsigned int count;
+		unsigned int i;
 
 		if (left < sizeof(struct ieee80211_neighbor_ap_info))
 			return 0;
 
 		left -= sizeof(struct ieee80211_neighbor_ap_info);
-		if (left < info->tbtt_info_len)
+		count = RNR_TBTT_INFO_COUNT_VAL(info->tbtt_info_hdr) + 1;
+		if (left < count * info->tbtt_info_len)
 			return 0;
 
-		ret = os_snprintf(pos, end - pos,
-				  "ap_info[%u]: tbtt_info: hdr=0x%x, len=%u, op_c=%u, channel=%u, ",
-				  n, *ie, info->tbtt_info_len,
-				  info->op_class, info->channel);
-		if (os_snprintf_error(end - pos, ret))
-			return 0;
-		pos += ret;
-
 		ie += sizeof(struct ieee80211_neighbor_ap_info);
 		tbtt_start = ie;
-		if (info->tbtt_info_len >= 1) {
-			ret = os_snprintf(pos, end - pos,
-					  "tbtt_offset=%u, ", *ie);
-			if (os_snprintf_error(end - pos, ret))
-				return 0;
 
-			ie++;
-			pos += ret;
-		}
+		for (i = 0; i < count; i++) {
+			ie = tbtt_start + i * info->tbtt_info_len;
 
-		if (info->tbtt_info_len >= 7) {
 			ret = os_snprintf(pos, end - pos,
-					  "bssid=" MACSTR ", ",
-					  MAC2STR(ie));
+					  "ap_info[%u]: tbtt_info[%u]: hdr=0x%x, len=%u, op_c=%u, channel=%u, ",
+					  n, i, info->tbtt_info_hdr,
+					  info->tbtt_info_len,
+					  info->op_class, info->channel);
 			if (os_snprintf_error(end - pos, ret))
 				return 0;
-
-			ie += ETH_ALEN;
 			pos += ret;
-		}
 
-		if (info->tbtt_info_len >= 11) {
-			ret = os_snprintf(pos, end - pos,
-					  "short SSID=0x%x, ",
-					  WPA_GET_LE32(ie));
-			if (os_snprintf_error(end - pos, ret))
-				return 0;
+			if (info->tbtt_info_len >= 1) {
+				ret = os_snprintf(pos, end - pos,
+						  "tbtt_offset=%u, ", *ie);
+				if (os_snprintf_error(end - pos, ret))
+					return 0;
 
-			ie += 4;
-			pos += ret;
-		}
+				ie++;
+				pos += ret;
+			}
 
-		if (info->tbtt_info_len >= 12) {
-			ret = os_snprintf(pos, end - pos,
-					  "bss_params=0x%x, ", *ie);
-			if (os_snprintf_error(end - pos, ret))
-				return 0;
+			if (info->tbtt_info_len >= 7) {
+				ret = os_snprintf(pos, end - pos,
+						  "bssid=" MACSTR ", ",
+						  MAC2STR(ie));
+				if (os_snprintf_error(end - pos, ret))
+					return 0;
 
-			ie++;
-			pos += ret;
-		}
+				ie += ETH_ALEN;
+				pos += ret;
+			}
 
-		if (info->tbtt_info_len >= 13) {
-			ret = os_snprintf(pos, end - pos,
-					  "PSD=0x%x, ", *ie);
-			if (os_snprintf_error(end - pos, ret))
-				return 0;
+			if (info->tbtt_info_len >= 11) {
+				ret = os_snprintf(pos, end - pos,
+						  "short SSID=0x%x, ",
+						  WPA_GET_LE32(ie));
+				if (os_snprintf_error(end - pos, ret))
+					return 0;
 
-			ie++;
-			pos += ret;
-		}
+				ie += 4;
+				pos += ret;
+			}
 
-		if (info->tbtt_info_len >= 16) {
-			ret = os_snprintf(pos, end - pos,
-					  "mld ID=%u, link ID=%u",
-					  *ie, *(ie + 1) & 0xF);
+			if (info->tbtt_info_len >= 12) {
+				ret = os_snprintf(pos, end - pos,
+						  "bss_params=0x%x, ", *ie);
+				if (os_snprintf_error(end - pos, ret))
+					return 0;
+
+				ie++;
+				pos += ret;
+			}
+
+			if (info->tbtt_info_len >= 13) {
+				ret = os_snprintf(pos, end - pos,
+						  "PSD=0x%x, ", *ie);
+				if (os_snprintf_error(end - pos, ret))
+					return 0;
+
+				ie++;
+				pos += ret;
+			}
+
+			if (info->tbtt_info_len >= 16) {
+				ret = os_snprintf(pos, end - pos,
+						  "mld ID=%u, link ID=%u",
+						  *ie, *(ie + 1) & 0xF);
+				if (os_snprintf_error(end - pos, ret))
+					return 0;
+
+				ie += 3;
+				pos += ret;
+			}
+
+			ret = os_snprintf(pos, end - pos, "\n");
 			if (os_snprintf_error(end - pos, ret))
 				return 0;
-
-			ie += 3;
 			pos += ret;
 		}
 
-		ie = tbtt_start + info->tbtt_info_len;
-
-		ret = os_snprintf(pos, end - pos, "\n");
-		if (os_snprintf_error(end - pos, ret))
-			return 0;
-		pos += ret;
+		ie = tbtt_start + count * info->tbtt_info_len;
 
 		n++;
 	}
@@ -5783,8 +5788,14 @@ static int print_bss_info(struct wpa_supplicant *wpa_s, struct wpa_bss *bss,
 		pos += ret;
 	}
 
-	if (mask & WPA_BSS_MASK_RNR)
-		pos += print_rnr(bss, pos, end);
+	if (mask & WPA_BSS_MASK_RNR) {
+		size_t ies_len = bss->ie_len ? bss->ie_len : bss->beacon_ie_len;
+		const struct element *elem;
+
+		for_each_element_id(elem, WLAN_EID_REDUCED_NEIGHBOR_REPORT,
+				    wpa_bss_ie_ptr(bss), ies_len)
+			pos += print_rnr((const u8 *) elem, pos, end);
+	}
 
 	if (mask & WPA_BSS_MASK_ML)
 		pos += print_ml(bss, pos, end);
@@ -12286,6 +12297,85 @@ static int wpas_ctrl_iface_mlo_signal_poll(struct wpa_supplicant *wpa_s,
 }
 
 
+static int
+wpa_supplicant_ctrl_iface_setup_link_reconfig(struct wpa_supplicant *wpa_s,
+					      const char *cmd)
+{
+	const char *pos, *add_pos, *dlt_pos;
+	struct wpa_mlo_reconfig_info info;
+	int link_id;
+
+	add_pos = os_strstr(cmd, "add=");
+	dlt_pos = os_strstr(cmd, "delete=");
+
+	if (!add_pos && !dlt_pos) {
+		wpa_printf(MSG_INFO, "No add or delete links info");
+		return -1;
+	}
+
+	if (!wpa_s->current_bss) {
+		wpa_printf(MSG_INFO, "%s: Not connected", __func__);
+		return -1;
+	}
+
+	info.add_links = 0;
+	info.delete_links = 0;
+
+	if (add_pos) {
+		pos = add_pos + 4;
+
+		do {
+			link_id = atoi(pos);
+			if (link_id < 0 || link_id >=  MAX_NUM_MLD_LINKS)
+				return -1;
+
+			if (wpa_s->current_bss->valid_links & BIT(link_id)) {
+				info.add_links |= BIT(link_id);
+				os_memcpy(info.add_link_bssid[link_id],
+					  wpa_s->current_bss->mld_links[link_id].bssid,
+					  ETH_ALEN);
+				info.add_link_freq[link_id] =
+					wpa_s->current_bss->mld_links[link_id].freq;
+			} else {
+				wpa_printf(MSG_INFO,
+					   "%s: add link info not present",
+					   __func__);
+				return -1;
+			}
+
+			pos = os_strchr(pos, ' ');
+			if (pos)
+				pos++;
+		} while (pos && pos != dlt_pos);
+	}
+
+	if (dlt_pos) {
+		pos = dlt_pos + 7;
+
+		do {
+			link_id = atoi(pos);
+			if (link_id < 0 || link_id >=  MAX_NUM_MLD_LINKS)
+				return -1;
+
+			if (wpa_s->valid_links & BIT(link_id))
+				info.delete_links |= BIT(link_id);
+			else {
+				wpa_printf(MSG_INFO,
+					   "%s: not a valid delete link",
+					   __func__);
+				return -1;
+			}
+
+			pos = os_strchr(pos, ' ');
+			if (pos)
+				pos++;
+		} while (pos && pos != add_pos);
+	}
+
+	return wpa_drv_setup_link_reconfig(wpa_s, &info);
+}
+
+
 static int wpas_ctrl_iface_mlo_status(struct wpa_supplicant *wpa_s,
 				      char *buf, size_t buflen)
 {
@@ -13852,6 +13942,10 @@ char * wpa_supplicant_ctrl_iface_process(struct wpa_supplicant *wpa_s,
 		if (wpas_ctrl_iface_send_dscp_query(wpa_s, buf + 11))
 			reply_len = -1;
 #endif /* CONFIG_NO_ROBUST_AV */
+	} else if (os_strncmp(buf, "SETUP_LINK_RECONFIG", 19) == 0) {
+		if (wpa_supplicant_ctrl_iface_setup_link_reconfig(wpa_s,
+								  buf + 19) < 0)
+			reply_len = -1;
 	} else if (os_strcmp(buf, "MLO_STATUS") == 0) {
 		reply_len = wpas_ctrl_iface_mlo_status(wpa_s, reply,
 						       reply_size);
diff --git a/wpa_supplicant/dbus/dbus_new.c b/wpa_supplicant/dbus/dbus_new.c
index 7893f3561..0c5cfdf44 100644
--- a/wpa_supplicant/dbus/dbus_new.c
+++ b/wpa_supplicant/dbus/dbus_new.c
@@ -2390,7 +2390,7 @@ void wpas_dbus_signal_p2p_bootstrap_req(struct wpa_supplicant *wpa_s,
  * @wpa_s: %wpa_supplicant network interface data
  * @src: Source address of the peer with which bootstrapping is done
  * @status: Status of Bootstrapping handshake
- * @bootstrap_method: Peer's bootstrap method if status is success
+ * @bootstrap_method: Local device requested bootstrap method
  *
  * Sends a signal to notify that a peer P2P Device is requesting bootstrapping
  * negotiation with us.
diff --git a/wpa_supplicant/dbus/dbus_new_handlers_p2p.c b/wpa_supplicant/dbus/dbus_new_handlers_p2p.c
index fc59947ee..192c65d66 100644
--- a/wpa_supplicant/dbus/dbus_new_handlers_p2p.c
+++ b/wpa_supplicant/dbus/dbus_new_handlers_p2p.c
@@ -624,6 +624,7 @@ DBusMessage * wpas_dbus_handler_p2p_connect(DBusMessage *message,
 	struct wpa_dbus_dict_entry entry;
 	char *peer_object_path = NULL;
 	int persistent_group = 0;
+	int auto_join = 0;
 	int join = 0;
 	int authorize_only = 0;
 	int go_intent = -1;
@@ -657,6 +658,9 @@ DBusMessage * wpas_dbus_handler_p2p_connect(DBusMessage *message,
 		} else if (os_strcmp(entry.key, "join") == 0 &&
 			   entry.type == DBUS_TYPE_BOOLEAN) {
 			join = entry.bool_value;
+		} else if (os_strcmp(entry.key, "auto_join") == 0 &&
+			   entry.type == DBUS_TYPE_BOOLEAN) {
+			auto_join = entry.bool_value;
 		} else if (os_strcmp(entry.key, "authorize_only") == 0 &&
 			   entry.type == DBUS_TYPE_BOOLEAN) {
 			authorize_only = entry.bool_value;
@@ -705,7 +709,8 @@ DBusMessage * wpas_dbus_handler_p2p_connect(DBusMessage *message,
 	wpa_s = wpa_s->global->p2p_init_wpa_s;
 
 	new_pin = wpas_p2p_connect(wpa_s, addr, pin, wps_method,
-				   persistent_group, 0, join, authorize_only,
+				   persistent_group, auto_join, join,
+				   authorize_only,
 				   go_intent, freq, 0, -1, 0, 0, 0, 0, 0, 0,
 				   NULL, 0, false, 0, 0, NULL, false);
 
diff --git a/wpa_supplicant/dpp_supplicant.c b/wpa_supplicant/dpp_supplicant.c
index bdb3e2b9a..74b0ef1f8 100644
--- a/wpa_supplicant/dpp_supplicant.c
+++ b/wpa_supplicant/dpp_supplicant.c
@@ -1423,6 +1423,21 @@ static struct wpa_ssid * wpas_dpp_add_network(struct wpa_supplicant *wpa_s,
 		return NULL;
 	wpas_notify_network_added(wpa_s, ssid);
 	wpa_config_set_network_defaults(ssid);
+	if (wpa_s->drv_capa_known &&
+	    (wpa_s->drv_enc & WPA_DRIVER_CAPA_ENC_GCMP)) {
+		ssid->pairwise_cipher |= WPA_CIPHER_GCMP;
+		ssid->group_cipher |= WPA_CIPHER_GCMP;
+	}
+	if (wpa_s->drv_capa_known &&
+	    (wpa_s->drv_enc & WPA_DRIVER_CAPA_ENC_GCMP_256)) {
+		ssid->pairwise_cipher |= WPA_CIPHER_GCMP_256;
+		ssid->group_cipher |= WPA_CIPHER_GCMP_256;
+	}
+	if (wpa_s->drv_capa_known &&
+	    (wpa_s->drv_enc & WPA_DRIVER_CAPA_ENC_CCMP_256)) {
+		ssid->pairwise_cipher |= WPA_CIPHER_CCMP_256;
+		ssid->group_cipher |= WPA_CIPHER_CCMP_256;
+	}
 	ssid->disabled = 1;
 
 	ssid->ssid = os_malloc(conf->ssid_len);
diff --git a/wpa_supplicant/driver_i.h b/wpa_supplicant/driver_i.h
index 43847cf4a..ccebd2cbe 100644
--- a/wpa_supplicant/driver_i.h
+++ b/wpa_supplicant/driver_i.h
@@ -532,6 +532,16 @@ static inline int wpa_drv_mlo_signal_poll(struct wpa_supplicant *wpa_s,
 	return -1;
 }
 
+static inline int
+wpa_drv_setup_link_reconfig(struct wpa_supplicant *wpa_s,
+			    struct wpa_mlo_reconfig_info *info)
+{
+	if (wpa_s->driver->setup_link_reconfig)
+		return wpa_s->driver->setup_link_reconfig(wpa_s->drv_priv,
+							  info);
+	return -1;
+}
+
 static inline int wpa_drv_channel_info(struct wpa_supplicant *wpa_s,
 				       struct wpa_channel_info *ci)
 {
diff --git a/wpa_supplicant/events.c b/wpa_supplicant/events.c
index fe8e45e07..00b733a1c 100644
--- a/wpa_supplicant/events.c
+++ b/wpa_supplicant/events.c
@@ -6106,6 +6106,76 @@ static void wpas_tid_link_map(struct wpa_supplicant *wpa_s,
 }
 
 
+static void wpas_setup_link_reconfig(struct wpa_supplicant *wpa_s,
+				     struct reconfig_info *info)
+{
+	const u8 *key_data = info->resp_ie;
+	size_t key_data_len = 0;
+	const u8 *ies, *end;
+	bool success = false;
+	int i;
+
+	if (!info->added_links) {
+		wpa_printf(MSG_INFO, "No links to be added");
+		return;
+	}
+
+	if (wpa_drv_get_mlo_info(wpa_s) < 0) {
+		wpa_printf(MSG_INFO,
+			   "SETUP_LINK_RECONFIG: Failed to set reconfig info to wpa_s");
+		return;
+	}
+
+	if (wpa_sm_set_ml_info(wpa_s)) {
+		wpa_printf(MSG_ERROR,
+			   "SETUP_LINK_RECONFIG: Failed to set reconfig info to wpa_sm");
+		return;
+	}
+
+	wpa_hexdump(MSG_DEBUG, "MLD: Reconfiguration Status List",
+		    info->status_list, info->count * 3);
+	for (i = 0; i < info->count; i++) {
+		if (WPA_GET_LE16(info->status_list + i * 3 + 1) ==
+		    WLAN_STATUS_SUCCESS)
+			success = true;
+	}
+
+	if (!key_data || info->resp_ie_len == 0)
+		return;
+
+	if (success) {
+		/* Starting with Group Key Data subfield, Key Data Length
+		 * field */
+		if (info->resp_ie_len < 1U + key_data[0]) {
+			wpa_printf(MSG_INFO,
+				   "MLD: Invalid keys in the link setup response");
+			return;
+		}
+
+		key_data_len = key_data[0];
+		key_data++;
+		wpa_hexdump_key(MSG_DEBUG,
+				"MLD: Link reconfig resp - Group Key Data",
+				key_data, key_data_len);
+
+		if (wpa_sm_install_mlo_group_keys(wpa_s->wpa, key_data,
+						  key_data_len,
+						  info->added_links)) {
+			wpa_printf(MSG_ERROR,
+				   "SETUP_LINK_RECONFIG: Failed to install group keys for added links");
+			return;
+		}
+	}
+
+	ies = key_data + key_data_len;
+	end = info->resp_ie + info->resp_ie_len;
+	wpa_hexdump(MSG_DEBUG, "MLD: Link reconfig resp - IEs", ies, end - ies);
+
+	wpa_msg(wpa_s, MSG_INFO, WPA_EVENT_LINK_RECONFIG "valid_links=0x%x",
+		wpa_s->valid_links);
+}
+
+
 static void wpas_link_reconfig(struct wpa_supplicant *wpa_s)
 {
 	u8 bssid[ETH_ALEN];
@@ -7132,6 +7202,10 @@ void wpa_supplicant_event(void *ctx, enum wpa_event_type event,
 		if (data)
 			wpas_tid_link_map(wpa_s, &data->t2l_map_info);
 		break;
+	case EVENT_SETUP_LINK_RECONFIG:
+		if (data)
+			wpas_setup_link_reconfig(wpa_s, &data->reconfig_info);
+		break;
 	default:
 		wpa_msg(wpa_s, MSG_INFO, "Unknown event %d", event);
 		break;
diff --git a/wpa_supplicant/op_classes.c b/wpa_supplicant/op_classes.c
index ff11d20b9..ec66e8ccd 100644
--- a/wpa_supplicant/op_classes.c
+++ b/wpa_supplicant/op_classes.c
@@ -172,7 +172,8 @@ static enum chan_allowed verify_160mhz(struct hostapd_hw_modes *mode,
 			return NOT_ALLOWED;
 
 		if (!(flags & HOSTAPD_CHAN_VHT_80MHZ_SUBCHANNEL) ||
-		    !(flags & HOSTAPD_CHAN_VHT_160MHZ_SUBCHANNEL))
+		    (!(flags & HOSTAPD_CHAN_VHT_160MHZ_SUBCHANNEL) &&
+		     !(flags & HOSTAPD_CHAN_AUTO_BW)))
 			return NOT_ALLOWED;
 
 		if (flags & HOSTAPD_CHAN_NO_IR)
diff --git a/wpa_supplicant/p2p_supplicant.c b/wpa_supplicant/p2p_supplicant.c
index 2090dde02..b4e56f90a 100644
--- a/wpa_supplicant/p2p_supplicant.c
+++ b/wpa_supplicant/p2p_supplicant.c
@@ -2073,7 +2073,12 @@ static void wpas_start_gc(struct wpa_supplicant *wpa_s,
 		entry->network_ctx = ssid;
 		os_memcpy(entry->spa, wpa_s->own_addr, ETH_ALEN);
 
-		wpa_sm_pmksa_cache_add_entry(wpa_s->wpa, entry);
+		if (wpa_s->drv_flags & WPA_DRIVER_FLAGS_SME) {
+			wpa_sm_pmksa_cache_add_entry(wpa_s->wpa, entry);
+		} else {
+			os_free(wpa_s->p2p_pmksa_entry);
+			wpa_s->p2p_pmksa_entry = entry;
+		}
 		ssid->pmk_valid = true;
 	} else if (res->akmp == WPA_KEY_MGMT_SAE && res->sae_password[0]) {
 		ssid->auth_alg = WPA_AUTH_ALG_SAE;
@@ -4485,7 +4490,8 @@ static enum chan_allowed wpas_p2p_verify_160mhz(struct wpa_supplicant *wpa_s,
 
 		if (!is_6ghz_op_class(op_class)) {
 			if (!(flags & HOSTAPD_CHAN_VHT_80MHZ_SUBCHANNEL) ||
-			    !(flags & HOSTAPD_CHAN_VHT_160MHZ_SUBCHANNEL))
+			    (!(flags & HOSTAPD_CHAN_VHT_160MHZ_SUBCHANNEL) &&
+			     !(flags & HOSTAPD_CHAN_AUTO_BW)))
 				return NOT_ALLOWED;
 		} else if (is_6ghz_op_class(op_class) &&
 			   (!(wpas_get_6ghz_he_chwidth_capab(mode) &
@@ -8169,7 +8175,12 @@ static int wpas_start_p2p_client(struct wpa_supplicant *wpa_s,
 			entry->network_ctx = ssid;
 			os_memcpy(entry->spa, wpa_s->own_addr, ETH_ALEN);
 
-			wpa_sm_pmksa_cache_add_entry(wpa_s->wpa, entry);
+			if (wpa_s->drv_flags & WPA_DRIVER_FLAGS_SME) {
+				wpa_sm_pmksa_cache_add_entry(wpa_s->wpa, entry);
+			} else {
+				os_free(wpa_s->p2p_pmksa_entry);
+				wpa_s->p2p_pmksa_entry = entry;
+			}
 			ssid->pmk_valid = true;
 		}
 		wpa_s->current_ssid = ssid;
@@ -11585,6 +11596,8 @@ int wpas_p2p_pasn_auth_rx(struct wpa_supplicant *wpa_s,
 		return -2;
 
 	wpa_s->p2p2 = true;
+	if (wpa_s->p2p_mode == WPA_P2P_MODE_WFD_R1)
+		wpa_s->p2p_mode = WPA_P2P_MODE_WFD_R2;
 	return p2p_pasn_auth_rx(p2p, mgmt, len, freq);
 }
 
diff --git a/wpa_supplicant/pasn_supplicant.c b/wpa_supplicant/pasn_supplicant.c
index b290e3013..6399c58bc 100644
--- a/wpa_supplicant/pasn_supplicant.c
+++ b/wpa_supplicant/pasn_supplicant.c
@@ -360,6 +360,12 @@ static void wpas_pasn_configure_next_peer(struct wpa_supplicant *wpa_s,
 			continue;
 		}
 
+		if (wpas_pasn_get_params_from_bss(wpa_s, peer)) {
+			peer->status = PASN_STATUS_FAILURE;
+			wpa_s->pasn_count++;
+			continue;
+		}
+
 		if (wpas_pasn_set_keys_from_cache(wpa_s, peer->own_addr,
 						  peer->peer_addr,
 						  peer->cipher,
@@ -369,12 +375,6 @@ static void wpas_pasn_configure_next_peer(struct wpa_supplicant *wpa_s,
 			continue;
 		}
 
-		if (wpas_pasn_get_params_from_bss(wpa_s, peer)) {
-			peer->status = PASN_STATUS_FAILURE;
-			wpa_s->pasn_count++;
-			continue;
-		}
-
 		if (wpas_pasn_auth_start(wpa_s, peer->own_addr,
 					 peer->peer_addr, peer->akmp,
 					 peer->cipher, peer->group,
diff --git a/wpa_supplicant/sme.c b/wpa_supplicant/sme.c
index d4e9cebbc..47c965bfd 100644
--- a/wpa_supplicant/sme.c
+++ b/wpa_supplicant/sme.c
@@ -1499,10 +1499,15 @@ static bool is_sae_key_mgmt_suite(struct wpa_supplicant *wpa_s, u32 suite)
 	 * match that initial implementation so that already deployed use cases
 	 * remain functional. */
 	if (RSN_SELECTOR_GET(&suite) == RSN_AUTH_KEY_MGMT_SAE) {
-		/* Old drivers which follow initial implementation send SAE AKM
-		 * for both SAE and FT-SAE connections. In that case, determine
-		 * the actual AKM from wpa_s->key_mgmt. */
-		wpa_s->sme.ext_auth_key_mgmt = wpa_s->key_mgmt;
+		/* This will be true in following cases
+		 * 1. Old drivers which follow the initial implementation send
+		 *    RSN_AUTH_KEY_MGMT_SAE with swapped byte order for both SAE
+		 *    and FT-SAE connections.
+		 * 2. The driver sending RSN_AUTH_KEY_MGMT_SAE in host byte
+		 *    order but kernel swapped that byte order to follow initial
+		 *    implementation.
+		 * In these cases, update the AKM as WPA_KEY_MGMT_SAE. */
+		wpa_s->sme.ext_auth_key_mgmt = WPA_KEY_MGMT_SAE;
 		return true;
 	}
 
diff --git a/wpa_supplicant/wpa_cli.c b/wpa_supplicant/wpa_cli.c
index 2ab291712..b13bf4992 100644
--- a/wpa_supplicant/wpa_cli.c
+++ b/wpa_supplicant/wpa_cli.c
@@ -425,6 +425,13 @@ static int wpa_cli_cmd_mlo_signal_poll(struct wpa_ctrl *ctrl, int argc, char *ar
 }
 
 
+static int wpa_cli_cmd_setup_link_reconfig(struct wpa_ctrl *ctrl, int argc,
+					   char *argv[])
+{
+	return wpa_cli_cmd(ctrl, "SETUP_LINK_RECONFIG", 1, argc, argv);
+}
+
+
 static int wpa_cli_cmd_set(struct wpa_ctrl *ctrl, int argc, char *argv[])
 {
 	char cmd[256];
@@ -4092,6 +4099,9 @@ static const struct wpa_cli_cmd wpa_cli_commands[] = {
 	{ "dscp_query", wpa_cli_cmd_dscp_query, NULL,
 	  cli_cmd_flag_none,
 	  "wildcard/domain_name=<string> = Send DSCP Query" },
+	{ "setup_link_reconfig", wpa_cli_cmd_setup_link_reconfig, NULL,
+	  cli_cmd_flag_none,
+	  "<<add=/delete=><ID1> [ID2]...> = Add new setup links and/or remove existing ones for the current MLO connection in STA mode" },
 	{ "mlo_status", wpa_cli_cmd_mlo_status, NULL,
 	  cli_cmd_flag_none,
 	  "= get MLO status" },
diff --git a/wpa_supplicant/wpa_supplicant.c b/wpa_supplicant/wpa_supplicant.c
index da7ff00c9..dfbd63163 100644
--- a/wpa_supplicant/wpa_supplicant.c
+++ b/wpa_supplicant/wpa_supplicant.c
@@ -798,6 +798,11 @@ static void wpa_supplicant_cleanup(struct wpa_supplicant *wpa_s)
 	os_free(wpa_s->last_scan_res);
 	wpa_s->last_scan_res = NULL;
 
+#ifdef CONFIG_P2P
+	os_free(wpa_s->p2p_pmksa_entry);
+	wpa_s->p2p_pmksa_entry = NULL;
+#endif /* CONFIG_P2P */
+
 #ifdef CONFIG_HS20
 	if (wpa_s->drv_priv)
 		wpa_drv_configure_frame_filters(wpa_s, 0);
@@ -4931,6 +4936,15 @@ static void wpas_start_assoc_cb(struct wpa_radio_work *work, int deinit)
 		wpa_supplicant_req_auth_timeout(wpa_s, timeout, 0);
 	}
 
+#ifdef CONFIG_P2P
+	if (ssid->pmk_valid && wpa_s->p2p_pmksa_entry &&
+	    !(wpa_s->drv_flags & WPA_DRIVER_FLAGS_SME)) {
+		wpa_sm_pmksa_cache_add_entry(wpa_s->wpa,
+					     wpa_s->p2p_pmksa_entry);
+		wpa_s->p2p_pmksa_entry = NULL;
+	}
+#endif /* CONFIG_P2P */
+
 #ifdef CONFIG_WEP
 	if (wep_keys_set &&
 	    (wpa_s->drv_flags & WPA_DRIVER_FLAGS_SET_KEYS_AFTER_ASSOC)) {
diff --git a/wpa_supplicant/wpa_supplicant_i.h b/wpa_supplicant/wpa_supplicant_i.h
index 1a7e2148e..3f844aff6 100644
--- a/wpa_supplicant/wpa_supplicant_i.h
+++ b/wpa_supplicant/wpa_supplicant_i.h
@@ -1093,6 +1093,7 @@ struct wpa_supplicant {
 
 #ifdef CONFIG_P2P
 	struct p2p_go_neg_results *go_params;
+	struct rsn_pmksa_cache_entry *p2p_pmksa_entry;
 	int create_p2p_iface;
 	u8 pending_interface_addr[ETH_ALEN];
 	char pending_interface_name[100];
-- 
2.45.2

