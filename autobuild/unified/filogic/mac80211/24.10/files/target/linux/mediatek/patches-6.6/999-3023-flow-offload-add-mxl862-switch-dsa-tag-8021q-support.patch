From 169c3b71942e97a11f5d800a07db9be1e8f948cc Mon Sep 17 00:00:00 2001
From: "chak-kei.lam" <chak-kei.lam@mediatek.com>
Date: Wed, 20 Aug 2025 10:40:45 +0800
Subject: [PATCH] flow offload add mxl862 switch dsa tag 8021q support

---
 drivers/net/ethernet/mediatek/mtk_ppe.c       | 25 ++++++++++-----
 drivers/net/ethernet/mediatek/mtk_ppe.h       |  2 +-
 .../net/ethernet/mediatek/mtk_ppe_offload.c   | 31 +++++++++++--------
 3 files changed, 36 insertions(+), 22 deletions(-)

diff --git a/drivers/net/ethernet/mediatek/mtk_ppe.c b/drivers/net/ethernet/mediatek/mtk_ppe.c
index cea64bb..06c4795 100644
--- a/drivers/net/ethernet/mediatek/mtk_ppe.c
+++ b/drivers/net/ethernet/mediatek/mtk_ppe.c
@@ -538,20 +538,29 @@ int mtk_foe_entry_set_ipv6_tuple(struct mtk_eth *eth,
 }
 
 int mtk_foe_entry_set_dsa(struct mtk_eth *eth, struct mtk_foe_entry *entry,
-			  int port)
+			  int proto, int port)
 {
-	struct mtk_foe_mac_info *l2 = mtk_foe_entry_l2(eth, entry);
+#if IS_ENABLED(CONFIG_NET_DSA)
+	struct mtk_foe_mac_info *l2;
 
-	l2->etype = BIT(port);
+	if (proto == DSA_TAG_PROTO_MXL862_8021Q) {
+		mtk_foe_entry_set_vlan(eth, entry, port + GENMASK(11, 10));
+	} else {
+		l2 = mtk_foe_entry_l2(eth, entry);
+		l2->etype = BIT(port);
 
-	if (!(entry->ib1 & mtk_get_ib1_vlan_layer_mask(eth)))
-		entry->ib1 |= mtk_prep_ib1_vlan_layer(eth, 1);
-	else
-		l2->etype |= BIT(8);
+		if (!(entry->ib1 & mtk_get_ib1_vlan_layer_mask(eth)))
+			entry->ib1 |= mtk_prep_ib1_vlan_layer(eth, 1);
+		else
+			l2->etype |= BIT(8);
 
-	entry->ib1 &= ~mtk_get_ib1_vlan_tag_mask(eth);
+		entry->ib1 &= ~mtk_get_ib1_vlan_tag_mask(eth);
+	}
 
 	return 0;
+#else
+	return -ENOTSUPP;
+#endif
 }
 
 int mtk_foe_entry_set_dscp(struct mtk_eth *eth, struct mtk_foe_entry *entry,
diff --git a/drivers/net/ethernet/mediatek/mtk_ppe.h b/drivers/net/ethernet/mediatek/mtk_ppe.h
index fdb1619..dc649a9 100644
--- a/drivers/net/ethernet/mediatek/mtk_ppe.h
+++ b/drivers/net/ethernet/mediatek/mtk_ppe.h
@@ -401,7 +401,7 @@ int mtk_foe_entry_set_ipv6_tuple(struct mtk_eth *eth,
 				 __be32 *src_addr, __be16 src_port,
 				 __be32 *dest_addr, __be16 dest_port);
 int mtk_foe_entry_set_dsa(struct mtk_eth *eth, struct mtk_foe_entry *entry,
-			  int port);
+			  int proto, int port);
 int mtk_foe_entry_set_dscp(struct mtk_eth *eth, struct mtk_foe_entry *entry,
 			   unsigned int dscp);
 int mtk_foe_entry_set_vlan(struct mtk_eth *eth, struct mtk_foe_entry *entry,
diff --git a/drivers/net/ethernet/mediatek/mtk_ppe_offload.c b/drivers/net/ethernet/mediatek/mtk_ppe_offload.c
index 6642bc4..8183d6d 100644
--- a/drivers/net/ethernet/mediatek/mtk_ppe_offload.c
+++ b/drivers/net/ethernet/mediatek/mtk_ppe_offload.c
@@ -169,7 +169,7 @@ mtk_flow_mangle_ipv4(const struct flow_action_entry *act,
 }
 
 static int
-mtk_flow_get_dsa_port(struct net_device **dev)
+mtk_flow_get_dsa_port(struct net_device **dev, int *proto)
 {
 #if IS_ENABLED(CONFIG_NET_DSA)
 	struct dsa_port *dp;
@@ -178,11 +178,15 @@ mtk_flow_get_dsa_port(struct net_device **dev)
 	if (IS_ERR(dp))
 		return -ENODEV;
 
-	if (dp->cpu_dp->tag_ops->proto != DSA_TAG_PROTO_MTK)
+	if (dp->cpu_dp->tag_ops->proto != DSA_TAG_PROTO_MTK &&
+	    dp->cpu_dp->tag_ops->proto != DSA_TAG_PROTO_MXL862_8021Q)
 		return -ENODEV;
 
 	*dev = dsa_port_to_master(dp);
 
+	if (proto)
+		*proto = dp->cpu_dp->tag_ops->proto;
+
 	return dp->index;
 #else
 	return -ENODEV;
@@ -282,7 +286,7 @@ mtk_flow_set_output_device(struct mtk_eth *eth, struct mtk_foe_entry *foe,
 	struct nf_conn *ct = NULL;
 	struct mtk_mac *mac;
 	u32 ct_mark = 0;
-	int pse_port, dsa_port, queue;
+	int pse_port, dsa_port, dsa_proto, queue;
 
 	info.tid = dscp;
 
@@ -310,7 +314,7 @@ mtk_flow_set_output_device(struct mtk_eth *eth, struct mtk_foe_entry *foe,
 		goto out;
 	}
 
-	dsa_port = mtk_flow_get_dsa_port(&odev);
+	dsa_port = mtk_flow_get_dsa_port(&odev, &dsa_proto);
 
 	if (odev == eth->netdev[0]) {
 		mac = eth->mac[0];
@@ -325,7 +329,7 @@ mtk_flow_set_output_device(struct mtk_eth *eth, struct mtk_foe_entry *foe,
 		return -EOPNOTSUPP;
 
 	if (dsa_port >= 0) {
-		mtk_foe_entry_set_dsa(eth, foe, dsa_port);
+		mtk_foe_entry_set_dsa(eth, foe, dsa_proto, dsa_port);
 		queue = 3 + dsa_port;
 	} else {
 		queue = (pse_port == PSE_GDM3_PORT) ? 2 : pse_port - 1;
@@ -396,6 +400,7 @@ mtk_flow_offload_replace(struct mtk_eth *eth, struct flow_cls_offload *f,
 		flow_rule_match_meta(rule, &match);
 		if (mtk_is_netsys_v2_or_greater(eth)) {
 			idev = __dev_get_by_index(&init_net, match.key->ingress_ifindex);
+			mtk_flow_get_dsa_port(&idev, NULL);
 			if (idev && idev->netdev_ops == eth->netdev[0]->netdev_ops) {
 				struct mtk_mac *mac = netdev_priv(idev);
 
@@ -581,6 +586,14 @@ mtk_flow_offload_replace(struct mtk_eth *eth, struct flow_cls_offload *f,
 			return err;
 	}
 
+	err = mtk_flow_set_output_device(eth, &foe, idev, odev, f,
+					 data.eth.h_dest, &wed_index, dscp);
+	if (err)
+		return err;
+
+	if (wed_index >= 0 && (err = mtk_wed_flow_add(wed_index)) < 0)
+		return err;
+
 	if (offload_type == MTK_PPE_PKT_TYPE_BRIDGE)
 		foe.bridge.vlan = data.vlan_in;
 
@@ -590,14 +603,6 @@ mtk_flow_offload_replace(struct mtk_eth *eth, struct flow_cls_offload *f,
 	if (data.pppoe.num == 1)
 		mtk_foe_entry_set_pppoe(eth, &foe, data.pppoe.sid);
 
-	err = mtk_flow_set_output_device(eth, &foe, idev, odev, f,
-					 data.eth.h_dest, &wed_index, dscp);
-	if (err)
-		return err;
-
-	if (wed_index >= 0 && (err = mtk_wed_flow_add(wed_index)) < 0)
-		return err;
-
 	entry = kzalloc(sizeof(*entry), GFP_KERNEL);
 	if (!entry)
 		return -ENOMEM;
-- 
2.45.2

