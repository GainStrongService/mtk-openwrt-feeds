From 508538b08368bc4c4bab990f25973669503dd5fd Mon Sep 17 00:00:00 2001
From: Yi-Chia Hsieh <Yi-Chia.Hsieh@mediatek.com>
Date: Tue, 29 Jul 2025 01:05:21 +0000
Subject: [PATCH 115/128] mtk: mac80211: process broadcast TWT nl80211 msg

This commit introduces new ops for add_btwt and del_btwt, enabling hostapd to
send nl80211_cmd with broadcast TWT service period parameters. The parameters
are validated according to the defined nl80211_policy, which filters out
invalid or unreasonable values before passing them to the driver.

The implementation ensures that the received broadcast TWT parameters are
forwarded through the ops chain and ultimately handled by the underlying
driver, allowing the driver to execute the necessary actions for adding or
deleting broadcast TWT sessions.

Fix the uninitialized local data variable.

Signed-off-by: Yi-Chia Hsieh <Yi-Chia.Hsieh@mediatek.com>
Signed-off-by: Howard Hsu <howard-yh.hsu@mediatek.com>
---
 include/net/cfg80211.h       |  31 +++++++++++
 include/net/mac80211.h       |   3 ++
 include/uapi/linux/nl80211.h |  49 +++++++++++++++++
 net/mac80211/cfg.c           |  35 ++++++++++++
 net/mac80211/driver-ops.h    |  37 +++++++++++++
 net/mac80211/ieee80211_i.h   |   2 +
 net/mac80211/trace.h         |  70 ++++++++++++++++++++++++
 net/wireless/nl80211.c       | 101 +++++++++++++++++++++++++++++++++++
 net/wireless/rdev-ops.h      |  32 +++++++++++
 net/wireless/trace.h         |  59 ++++++++++++++++++++
 10 files changed, 419 insertions(+)

diff --git a/include/net/cfg80211.h b/include/net/cfg80211.h
index bd49fdfb..ffa3172b 100644
--- a/include/net/cfg80211.h
+++ b/include/net/cfg80211.h
@@ -303,6 +303,32 @@ struct ieee80211_rate {
 	u16 hw_value, hw_value_short;
 };
 
+/**
+ * struct cfg80211_broadcast_twt_settings - AP settings for broadcast TWT
+ *
+ * @id: broadcast TWT id
+ * @min_wake_dur: the min time that a TWT scheduled STA is expected to be awake
+ * @wake_intv_mantissa: mantissa part of wake interval
+ * @wake_intv_exp: exponential part of wake interval
+ * @setup_cmd: the type of TWT command
+ * @trigger: 0 for non-triggered and 1 for triggered
+ * @flow_type: 0 for announced and 1 for unannounced
+ * @recommendation: recommendations on the types of frames to be transmitted
+ * @persist: number of TBTTs during which the Broadcast TWT SPs corresponding
+ *	to this broadcast TWT Parameter set are present
+ */
+struct cfg80211_broadcast_twt_settings {
+	u8 id;
+	u8 min_wake_dur;
+	u16 wake_intv_mantissa;
+	u8 wake_intv_exp;
+	u8 setup_cmd;
+	bool trigger;
+	bool flow_type;
+	u8 recommendation;
+	u8 persist;
+};
+
 /**
  * struct ieee80211_he_obss_pd - AP settings for spatial reuse
  *
@@ -4863,6 +4889,8 @@ struct mgmt_frame_regs {
  *	links by calling cfg80211_mlo_reconf_add_done(). When calling
  *	cfg80211_mlo_reconf_add_done() the bss pointer must be given for each
  *	link for which MLO reconfiguration 'add' operation was requested.
+ * @add_btwt: add a new Broadcast TWT service period
+ * @del_btwt: delete an existing Broadcast TWT service period
  */
 struct cfg80211_ops {
 	int	(*suspend)(struct wiphy *wiphy, struct cfg80211_wowlan *wow);
@@ -5244,6 +5272,9 @@ struct cfg80211_ops {
 	int	(*set_epcs)(struct wiphy *wiphy, struct net_device *dev,
 			    bool val);
 	void	(*skip_cac)(struct wireless_dev *wdev, unsigned int link_id);
+	int	(*add_btwt)(struct wiphy *wiphy, struct net_device *dev,
+			    struct cfg80211_broadcast_twt_settings *settings);
+	int	(*del_btwt)(struct wiphy *wiphy, struct net_device *dev, u8 id);
 };
 
 /*
diff --git a/include/net/mac80211.h b/include/net/mac80211.h
index d2d212e9..583fbc1c 100644
--- a/include/net/mac80211.h
+++ b/include/net/mac80211.h
@@ -4930,6 +4930,9 @@ struct ieee80211_ops {
 			      struct ieee80211_twt_setup *twt);
 	void (*twt_teardown_request)(struct ieee80211_hw *hw,
 				     struct ieee80211_sta *sta, u8 flowid);
+	int (*add_btwt)(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
+			struct cfg80211_broadcast_twt_settings *btwt);
+	int (*del_btwt)(struct ieee80211_hw *hw, struct ieee80211_vif *vif, u8 id);
 	int (*set_radar_background)(struct ieee80211_hw *hw,
 				    struct cfg80211_chan_def *chandef);
 	int (*net_fill_forward_path)(struct ieee80211_hw *hw,
diff --git a/include/uapi/linux/nl80211.h b/include/uapi/linux/nl80211.h
index c83a10ea..bf2eca25 100644
--- a/include/uapi/linux/nl80211.h
+++ b/include/uapi/linux/nl80211.h
@@ -1364,6 +1364,13 @@
  * @NL80211_CMD_NOTIFY_CRIT_UPDATE: Notify the userspace that the status of a
  *	critical update event was changed.
  *
+ * @NL80211_CMD_ADD_BROADCAST_TWT: Setup a broadcast TWT service period on a AP.
+ *	The id, mantissa and exponent of wake interval and minimum wake duration
+ *	must be given.
+ *
+ * @NL80211_CMD_DEL_BROADCAST_TWT: Delete a broadcast TWT service period on a AP.
+ * 	The id of the to-be deleted service period must be specified.
+ *
  * @NL80211_CMD_MAX: highest used command number
  * @__NL80211_CMD_AFTER_LAST: internal use
  */
@@ -1635,6 +1642,8 @@ enum nl80211_commands {
 	NL80211_CMD_SET_STA_TTLM,
 	NL80211_CMD_NOTIFY_CRIT_UPDATE,
 	NL80211_CMD_TSF_OFFSET_EVENT,
+	NL80211_CMD_ADD_BROADCAST_TWT,
+	NL80211_CMD_DEL_BROADCAST_TWT,
 
 	/* used to define NL80211_CMD_MAX below */
 	__NL80211_CMD_AFTER_LAST,
@@ -3008,6 +3017,9 @@ enum nl80211_commands {
  * @NL80211_ATTR_DFS_STATE_UPDATE: Update the DFS state, especially when the radar
  *	detection is triggered by the offchain command.
  *
+ * @NL80211_ATTR_BROADCAST_TWT_PARAMS: Nested attribute for broadcast TWT
+ * 	service period parameters. See &enum nl80211_broadcast_twt_attributes.
+ *
  * @NUM_NL80211_ATTR: total number of nl80211_attrs available
  * @NL80211_ATTR_MAX: highest attribute number currently defined
  * @__NL80211_ATTR_AFTER_LAST: internal use
@@ -3594,6 +3606,7 @@ enum nl80211_attrs {
 	NL80211_ATTR_VENDOR_MTK_STA,
 
 	NL80211_ATTR_DFS_STATE_UPDATE,
+	NL80211_ATTR_BROADCAST_TWT_PARAMS,
 
 	__NL80211_ATTR_AFTER_LAST,
 	NUM_NL80211_ATTR = __NL80211_ATTR_AFTER_LAST,
@@ -8533,4 +8546,40 @@ enum nl80211_crit_update_event {
 	NL80211_CRIT_UPDATE_FLAG
 };
 
+/**
+ * enum nl80211_broadcast_twt_attributes - Parameters for a Broadcast TWT
+ *
+ * @NL80211_BROADCAST_TWT_ATTR_ID: Broadcast TWT ID. Range from 0 to 31.
+ * @NL80211_BROADCAST_TWT_ATTR_MIN_WAKE_DUR: Minimum wake duration.
+ * @NL80211_BROADCAST_TWT_ATTR_MANTISSA: Mantissa for wake interval
+ * @NL80211_BROADCAST_TWT_ATTR_EXPONENT: Exponent for wake interval
+ * @NL80211_BROADCAST_TWT_ATTR_TRIGGER: Decide a BTWT to be trigger based or
+ *	non-trigger based. 1 for trigger based.
+ * @NL80211_BROADCAST_TWT_ATTR_FLOW_TYPE: Decide a BTWT to be announced based or
+ *	non-announced based. 0 for announced based.
+ * @NL80211_BROADCAST_TWT_ATTR_RECOMMENDATION: Suggested data type by
+ * 	TWT scheduling AP.
+ * @NL80211_BROADCAST_TWT_ATTR_PERSISTENCE: Number of TBTT before this
+ * 	BTWT is end. Set 255 for a persist BTWT that never ends.
+ * @__NL80211_BROADCAST_TWT_ATTR_LAST: Internal
+ * @NL80211_BROADCAST_TWT_ATTR_MAX: Highest attribute
+ */
+
+enum nl80211_broadcast_twt_attributes {
+	__NL80211_BROADCAST_TWT_ATTR_INVALID,
+
+	NL80211_BROADCAST_TWT_ATTR_ID,
+	NL80211_BROADCAST_TWT_ATTR_MIN_WAKE_DUR,
+	NL80211_BROADCAST_TWT_ATTR_MANTISSA,
+	NL80211_BROADCAST_TWT_ATTR_EXPONENT,
+	NL80211_BROADCAST_TWT_ATTR_TRIGGER,
+	NL80211_BROADCAST_TWT_ATTR_FLOW_TYPE,
+	NL80211_BROADCAST_TWT_ATTR_RECOMMENDATION,
+	NL80211_BROADCAST_TWT_ATTR_PERSISTENCE,
+
+	/* keep last */
+	__NL80211_BROADCAST_TWT_ATTR_LAST,
+	NL80211_BROADCAST_TWT_ATTR_MAX = __NL80211_BROADCAST_TWT_ATTR_LAST - 1,
+};
+
 #endif /* __LINUX_NL80211_H */
diff --git a/net/mac80211/cfg.c b/net/mac80211/cfg.c
index c9d2b78d..8428ef03 100644
--- a/net/mac80211/cfg.c
+++ b/net/mac80211/cfg.c
@@ -5798,6 +5798,39 @@ void ieee80211_crit_update_notify(struct ieee80211_vif *vif, unsigned int link_i
 }
 EXPORT_SYMBOL_GPL(ieee80211_crit_update_notify);
 
+static int
+ieee80211_add_btwt(struct wiphy *wiphy, struct net_device *dev,
+		   struct cfg80211_broadcast_twt_settings *settings)
+{
+	struct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);
+	struct ieee80211_local *local = sdata->local;
+	int ret;
+
+	lockdep_assert_wiphy(sdata->local->hw.wiphy);
+
+	ret = drv_add_btwt(local, sdata, settings);
+	if (!ret)
+		sdata->deflink.btwt_active_bitmap |= BIT(settings->id);
+
+	return ret;
+}
+
+static int
+ieee80211_del_btwt(struct wiphy *wiphy, struct net_device *dev, u8 id)
+{
+	struct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);
+	struct ieee80211_local *local = sdata->local;
+	int ret;
+
+	lockdep_assert_wiphy(sdata->local->hw.wiphy);
+
+	ret =  drv_del_btwt(local, sdata, id);
+	if (!ret)
+		sdata->deflink.btwt_active_bitmap &= ~BIT(id);
+
+	return ret;
+}
+
 const struct cfg80211_ops mac80211_config_ops = {
 	.add_virtual_intf = ieee80211_add_iface,
 	.del_virtual_intf = ieee80211_del_iface,
@@ -5918,4 +5951,6 @@ const struct cfg80211_ops mac80211_config_ops = {
 	.assoc_ml_reconf = ieee80211_assoc_ml_reconf,
 	.set_epcs = ieee80211_set_epcs,
 	.skip_cac = ieee80211_skip_cac,
+	.add_btwt = ieee80211_add_btwt,
+	.del_btwt = ieee80211_del_btwt,
 };
diff --git a/net/mac80211/driver-ops.h b/net/mac80211/driver-ops.h
index e32291e3..e8e48a2b 100644
--- a/net/mac80211/driver-ops.h
+++ b/net/mac80211/driver-ops.h
@@ -1672,6 +1672,43 @@ static inline void drv_twt_teardown_request(struct ieee80211_local *local,
 	trace_drv_return_void(local);
 }
 
+static inline int drv_add_btwt(struct ieee80211_local *local,
+			       struct ieee80211_sub_if_data *sdata,
+			       struct cfg80211_broadcast_twt_settings *settings)
+{
+	int ret = -EOPNOTSUPP;
+
+	might_sleep();
+	lockdep_assert_wiphy(local->hw.wiphy);
+	if (!check_sdata_in_driver(sdata))
+		return -EIO;
+
+	trace_drv_add_btwt(local, sdata, settings);
+	if (local->ops->add_btwt)
+		ret = local->ops->add_btwt(&local->hw, &sdata->vif, settings);
+	trace_drv_return_int(local, ret);
+
+	return ret;
+}
+
+static inline int drv_del_btwt(struct ieee80211_local *local,
+			       struct ieee80211_sub_if_data *sdata, u8 id)
+{
+	int ret = -EOPNOTSUPP;
+
+	might_sleep();
+	lockdep_assert_wiphy(local->hw.wiphy);
+	if (!check_sdata_in_driver(sdata))
+		return -EIO;
+
+	trace_drv_del_btwt(local, sdata, id);
+	if (local->ops->del_btwt)
+		ret = local->ops->del_btwt(&local->hw, &sdata->vif, id);
+	trace_drv_return_int(local, ret);
+
+	return ret;
+}
+
 static inline int drv_net_fill_forward_path(struct ieee80211_local *local,
 					    struct ieee80211_sub_if_data *sdata,
 					    struct ieee80211_sta *sta,
diff --git a/net/mac80211/ieee80211_i.h b/net/mac80211/ieee80211_i.h
index a86d6717..07022c07 100644
--- a/net/mac80211/ieee80211_i.h
+++ b/net/mac80211/ieee80211_i.h
@@ -1089,6 +1089,8 @@ struct ieee80211_link_data {
 	struct wiphy_delayed_work color_collision_detect_work;
 	u64 color_bitmap;
 
+	u32 btwt_active_bitmap;
+
 	/* context reservation -- protected with wiphy mutex */
 	struct ieee80211_chanctx *reserved_chanctx;
 	struct ieee80211_chan_req reserved;
diff --git a/net/mac80211/trace.h b/net/mac80211/trace.h
index 30b25ef4..e219a2a1 100644
--- a/net/mac80211/trace.h
+++ b/net/mac80211/trace.h
@@ -2552,6 +2552,76 @@ TRACE_EVENT(drv_twt_teardown_request,
 	)
 );
 
+TRACE_EVENT(drv_add_btwt,
+	TP_PROTO(struct ieee80211_local *local,
+		 struct ieee80211_sub_if_data *sdata,
+		 struct cfg80211_broadcast_twt_settings *settings),
+
+	TP_ARGS(local, sdata, settings),
+
+	TP_STRUCT__entry(
+		LOCAL_ENTRY
+		VIF_ENTRY
+		__field(u8, id)
+		__field(u8, min_wake_dur)
+		__field(u16, wake_intv_mantissa)
+		__field(u8, wake_intv_exp)
+		__field(u8, setup_cmd)
+		__field(bool, trigger)
+		__field(bool, flow_type)
+		__field(u8, recommendation)
+		__field(u8, persist)
+	),
+
+	TP_fast_assign(
+		LOCAL_ASSIGN;
+		VIF_ASSIGN;
+		__entry->id = settings->id;
+		__entry->min_wake_dur = settings->min_wake_dur;
+		__entry->wake_intv_mantissa = settings->wake_intv_mantissa;
+		__entry->wake_intv_exp = settings->wake_intv_exp;
+		__entry->setup_cmd = settings->setup_cmd;
+		__entry->trigger = settings->trigger;
+		__entry->flow_type = settings->flow_type;
+		__entry->recommendation = settings->recommendation;
+		__entry->persist = settings->persist;
+	),
+
+	TP_printk(
+		LOCAL_PR_FMT VIF_PR_FMT " id=%u min_wake_dur=%u "
+		"wake_intv_mantissa=%u wake_intv_exp=%u setup_cmd=%u trigger=%u"
+		"flow_type=%u recommendation=%u persist=%u",
+		LOCAL_PR_ARG, VIF_PR_ARG, __entry->id, __entry->min_wake_dur,
+		__entry->wake_intv_mantissa, __entry->wake_intv_exp,
+		__entry->setup_cmd, __entry->trigger, __entry->flow_type,
+		__entry->recommendation, __entry->persist
+	)
+);
+
+TRACE_EVENT(drv_del_btwt,
+	TP_PROTO(struct ieee80211_local *local,
+		 struct ieee80211_sub_if_data *sdata, u8 id),
+
+	TP_ARGS(local, sdata, id),
+
+	TP_STRUCT__entry(
+		LOCAL_ENTRY
+		VIF_ENTRY
+		__field(u8, id)
+	),
+
+	TP_fast_assign(
+		LOCAL_ASSIGN;
+		VIF_ASSIGN;
+		__entry->id = id;
+	),
+
+	TP_printk(
+		LOCAL_PR_FMT VIF_PR_FMT " id=%u",
+		LOCAL_PR_ARG, VIF_PR_ARG, __entry->id
+	)
+);
+
 DEFINE_EVENT(sta_event, drv_net_fill_forward_path,
 	TP_PROTO(struct ieee80211_local *local,
 		 struct ieee80211_sub_if_data *sdata,
diff --git a/net/wireless/nl80211.c b/net/wireless/nl80211.c
index 02409761..c3459343 100644
--- a/net/wireless/nl80211.c
+++ b/net/wireless/nl80211.c
@@ -566,6 +566,18 @@ static const struct netlink_range_validation q_range = {
 };
 #endif
 
+static const struct nla_policy
+nl80211_broadcast_twt_policy[NL80211_BROADCAST_TWT_ATTR_MAX + 1] = {
+	[NL80211_BROADCAST_TWT_ATTR_ID] = NLA_POLICY_RANGE(NLA_U8, 0, 31),
+	[NL80211_BROADCAST_TWT_ATTR_MIN_WAKE_DUR] = { .type = NLA_U8 },
+	[NL80211_BROADCAST_TWT_ATTR_MANTISSA] = { .type = NLA_U16 },
+	[NL80211_BROADCAST_TWT_ATTR_EXPONENT] = NLA_POLICY_RANGE(NLA_U8, 0, 31),
+	[NL80211_BROADCAST_TWT_ATTR_TRIGGER] = { .type = NLA_FLAG },
+	[NL80211_BROADCAST_TWT_ATTR_FLOW_TYPE] = { .type = NLA_FLAG },
+	[NL80211_BROADCAST_TWT_ATTR_RECOMMENDATION] = NLA_POLICY_RANGE(NLA_U8, 0, 7),
+	[NL80211_BROADCAST_TWT_ATTR_PERSISTENCE] = { .type = NLA_U8 },
+};
+
 static const struct nla_policy nl80211_policy[NUM_NL80211_ATTR] = {
 	[0] = { .strict_start_type = NL80211_ATTR_HE_OBSS_PD },
 	[NL80211_ATTR_WIPHY] = { .type = NLA_U32 },
@@ -968,6 +980,8 @@ static const struct nla_policy nl80211_policy[NUM_NL80211_ATTR] = {
 	[NL80211_ATTR_CNTDWN_OFFS_STA_PROF] = { .type = NLA_BINARY },
 	[NL80211_ATTR_CRTI_UPDATE_EVENT] = { .type = NLA_U8 },
 	[NL80211_ATTR_VENDOR_MTK_STA] = { .type = NLA_FLAG },
+	[NL80211_ATTR_BROADCAST_TWT_PARAMS] =
+		NLA_POLICY_NESTED(nl80211_broadcast_twt_policy),
 };
 
 /* policy for the key attributes */
@@ -18007,6 +18021,81 @@ nl80211_epcs_cfg(struct sk_buff *skb, struct genl_info *info)
 	return rdev_set_epcs(rdev, dev, val);
 }
 
+static int
+nl80211_add_broadcast_twt(struct sk_buff *skb, struct genl_info *info)
+{
+	struct cfg80211_registered_device *rdev = info->user_ptr[0];
+	struct net_device *dev = info->user_ptr[1];
+	struct wireless_dev *wdev = dev->ieee80211_ptr;
+	struct nlattr *tb[NL80211_BROADCAST_TWT_ATTR_MAX + 1];
+	struct cfg80211_broadcast_twt_settings settings;
+	int ret;
+
+	if (wdev->iftype != NL80211_IFTYPE_AP)
+		return -EOPNOTSUPP;
+
+	ret = nla_parse_nested(tb, NL80211_BROADCAST_TWT_ATTR_MAX,
+			       info->attrs[NL80211_ATTR_BROADCAST_TWT_PARAMS],
+			       nl80211_broadcast_twt_policy, info->extack);
+	if (ret)
+		return ret;
+
+	if (!tb[NL80211_BROADCAST_TWT_ATTR_ID] ||
+	    !tb[NL80211_BROADCAST_TWT_ATTR_MIN_WAKE_DUR] ||
+	    !tb[NL80211_BROADCAST_TWT_ATTR_MANTISSA] ||
+	    !tb[NL80211_BROADCAST_TWT_ATTR_EXPONENT] ||
+	    !tb[NL80211_BROADCAST_TWT_ATTR_RECOMMENDATION] ||
+	    !tb[NL80211_BROADCAST_TWT_ATTR_PERSISTENCE])
+		return -EINVAL;
+
+	memset(&settings, 0, sizeof(settings));
+	settings.id =
+		nla_get_u8(tb[NL80211_BROADCAST_TWT_ATTR_ID]);
+	settings.min_wake_dur =
+		nla_get_u8(tb[NL80211_BROADCAST_TWT_ATTR_MIN_WAKE_DUR]);
+	settings.wake_intv_mantissa =
+		nla_get_u16(tb[NL80211_BROADCAST_TWT_ATTR_MANTISSA]);
+	settings.wake_intv_exp =
+		nla_get_u8(tb[NL80211_BROADCAST_TWT_ATTR_EXPONENT]);
+	settings.trigger =
+		nla_get_flag(tb[NL80211_BROADCAST_TWT_ATTR_TRIGGER]);
+	settings.flow_type =
+		nla_get_flag(tb[NL80211_BROADCAST_TWT_ATTR_FLOW_TYPE]);
+	settings.recommendation =
+		nla_get_u8(tb[NL80211_BROADCAST_TWT_ATTR_RECOMMENDATION]);
+	settings.persist =
+		nla_get_u8(tb[NL80211_BROADCAST_TWT_ATTR_PERSISTENCE]);
+
+	return rdev_add_btwt(rdev, dev, &settings);
+}
+
+static int
+nl80211_del_broadcast_twt(struct sk_buff *skb, struct genl_info *info)
+{
+	struct cfg80211_registered_device *rdev = info->user_ptr[0];
+	struct net_device *dev = info->user_ptr[1];
+	struct wireless_dev *wdev = dev->ieee80211_ptr;
+	struct nlattr *tb[NL80211_BROADCAST_TWT_ATTR_MAX + 1];
+	u8 id;
+	int ret;
+
+	if (wdev->iftype != NL80211_IFTYPE_AP)
+		return -EOPNOTSUPP;
+
+	ret = nla_parse_nested(tb, NL80211_BROADCAST_TWT_ATTR_MAX,
+			       info->attrs[NL80211_ATTR_BROADCAST_TWT_PARAMS],
+			       nl80211_broadcast_twt_policy, info->extack);
+	if (ret)
+		return ret;
+
+	if (!tb[NL80211_BROADCAST_TWT_ATTR_ID])
+		return -EINVAL;
+
+	id = nla_get_u8(tb[NL80211_BROADCAST_TWT_ATTR_ID]);
+
+	return rdev_del_btwt(rdev, dev, id);
+}
+
 #define NL80211_FLAG_NEED_WIPHY		0x01
 #define NL80211_FLAG_NEED_NETDEV	0x02
 #define NL80211_FLAG_NEED_RTNL		0x04
@@ -19238,6 +19327,18 @@ static const struct genl_small_ops nl80211_small_ops[] = {
 		.flags = GENL_UNS_ADMIN_PERM,
 		.internal_flags = IFLAGS(NL80211_FLAG_NEED_NETDEV_UP),
 	},
+	{
+		.cmd = NL80211_CMD_ADD_BROADCAST_TWT,
+		.doit = nl80211_add_broadcast_twt,
+		.flags = GENL_UNS_ADMIN_PERM,
+		.internal_flags = IFLAGS(NL80211_FLAG_NEED_NETDEV_UP),
+	},
+	{
+		.cmd = NL80211_CMD_DEL_BROADCAST_TWT,
+		.doit = nl80211_del_broadcast_twt,
+		.flags = GENL_UNS_ADMIN_PERM,
+		.internal_flags = IFLAGS(NL80211_FLAG_NEED_NETDEV_UP),
+	},
 };
 
 static struct genl_family nl80211_fam __ro_after_init = {
diff --git a/net/wireless/rdev-ops.h b/net/wireless/rdev-ops.h
index 36891bf8..31f89933 100644
--- a/net/wireless/rdev-ops.h
+++ b/net/wireless/rdev-ops.h
@@ -1648,4 +1648,36 @@ rdev_skip_cac(struct cfg80211_registered_device *rdev,
 
 	return 0;
 }
+
+static inline int
+rdev_add_btwt(struct cfg80211_registered_device *rdev,
+	      struct net_device *dev,
+	      struct cfg80211_broadcast_twt_settings *settings)
+{
+	struct wiphy *wiphy = &rdev->wiphy;
+	int ret = -EOPNOTSUPP;
+
+	trace_rdev_add_btwt(wiphy, dev, settings);
+	if (rdev->ops->add_btwt)
+		ret = rdev->ops->add_btwt(wiphy, dev, settings);
+	trace_rdev_return_int(wiphy, ret);
+
+	return ret;
+}
+
+static inline int
+rdev_del_btwt(struct cfg80211_registered_device *rdev,
+	      struct net_device *dev,
+	      u8 id)
+{
+	struct wiphy *wiphy = &rdev->wiphy;
+	int ret = -EOPNOTSUPP;
+
+	trace_rdev_del_btwt(wiphy, dev, id);
+	if (rdev->ops->del_btwt)
+		ret = rdev->ops->del_btwt(wiphy, dev, id);
+	trace_rdev_return_int(wiphy, ret);
+
+	return ret;
+}
 #endif /* __CFG80211_RDEV_OPS */
diff --git a/net/wireless/trace.h b/net/wireless/trace.h
index 3cd2e4e5..b0fda4f5 100644
--- a/net/wireless/trace.h
+++ b/net/wireless/trace.h
@@ -4329,6 +4329,65 @@ TRACE_EVENT(rdev_skip_cac,
 	),
 	TP_printk(WDEV_PR_FMT ", link_id: %d", WDEV_PR_ARG, __entry->link_id)
 );
+
+TRACE_EVENT(rdev_add_btwt,
+	TP_PROTO(struct wiphy *wiphy,
+		 struct net_device *netdev,
+		 struct cfg80211_broadcast_twt_settings *settings),
+	TP_ARGS(wiphy, netdev, settings),
+	TP_STRUCT__entry(
+		WIPHY_ENTRY
+		NETDEV_ENTRY
+		__field(u8, id)
+		__field(u8, min_wake_dur)
+		__field(u16, wake_intv_mantissa)
+		__field(u8, wake_intv_exp)
+		__field(u8, setup_cmd)
+		__field(bool, trigger)
+		__field(bool, flow_type)
+		__field(u8, recommendation)
+		__field(u8, persist)
+	),
+	TP_fast_assign(
+		WIPHY_ASSIGN;
+		NETDEV_ASSIGN;
+		__entry->id = settings->id;
+		__entry->min_wake_dur = settings->min_wake_dur;
+		__entry->wake_intv_mantissa = settings->wake_intv_mantissa;
+		__entry->wake_intv_exp = settings->wake_intv_exp;
+		__entry->setup_cmd = settings->setup_cmd;
+		__entry->trigger = settings->trigger;
+		__entry->flow_type = settings->flow_type;
+		__entry->recommendation = settings->recommendation;
+		__entry->persist = settings->persist;
+	),
+	TP_printk(WIPHY_PR_FMT NETDEV_PR_FMT " id=%u min_wake_dur=%u "
+		"wake_intv_mantissa=%u wake_intv_exp=%u setup_cmd=%u trigger=%u"
+		"flow_type=%u recommendation=%u persist=%u",
+		  WIPHY_PR_ARG, NETDEV_PR_ARG, __entry->id, __entry->min_wake_dur,
+		__entry->wake_intv_mantissa, __entry->wake_intv_exp,
+		__entry->setup_cmd, __entry->trigger, __entry->flow_type,
+		__entry->recommendation, __entry->persist)
+);
+
+TRACE_EVENT(rdev_del_btwt,
+	TP_PROTO(struct wiphy *wiphy,
+		 struct net_device *netdev,
+		 u8 id),
+	TP_ARGS(wiphy, netdev, id),
+	TP_STRUCT__entry(
+		WIPHY_ENTRY
+		NETDEV_ENTRY
+		__field(u8, id)
+	),
+	TP_fast_assign(
+		WIPHY_ASSIGN;
+		NETDEV_ASSIGN;
+		__entry->id = id;
+	),
+	TP_printk(WIPHY_PR_FMT NETDEV_PR_FMT " id=%u",
+		  WIPHY_PR_ARG, NETDEV_PR_ARG, __entry->id)
+);
 #endif /* !__RDEV_OPS_TRACE || TRACE_HEADER_MULTI_READ */
 
 #undef TRACE_INCLUDE_PATH
-- 
2.45.2

