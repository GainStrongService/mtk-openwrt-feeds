From c646fd5f99040d4a66300208caafdb1813260c48 Mon Sep 17 00:00:00 2001
From: Howard Hsu <howard-yh.hsu@mediatek.com>
Date: Fri, 5 Sep 2025 15:12:04 +0800
Subject: [PATCH 087/105] wifi: mt76: mt7996: add broadcast twt member after
 receiving the TXS

Add a BTWT member to the BTWT schedule after receiving the TXS of the
TWT setup response. The action to add BTWT member shall be deferred to
a workqueue to avoid sleeping in NAPI.

Signed-off-by: Howard Hsu <howard-yh.hsu@mediatek.com>
---
 mt7996/init.c   |   6 ++
 mt7996/mac.c    | 160 +++++++++++++++++++++++++++++++++++++++++++++---
 mt7996/main.c   |   2 +
 mt7996/mt7996.h |  10 +++
 4 files changed, 168 insertions(+), 10 deletions(-)

diff --git a/mt7996/init.c b/mt7996/init.c
index 1da535432..853f53342 100644
--- a/mt7996/init.c
+++ b/mt7996/init.c
@@ -1996,6 +1996,10 @@ int mt7996_register_device(struct mt7996_dev *dev)
 	INIT_LIST_HEAD(&dev->sta_rc_list);
 	INIT_LIST_HEAD(&dev->twt_list);
 
+	INIT_WORK(&dev->twt.event_work, mt7996_twt_event_work);
+	INIT_LIST_HEAD(&dev->twt.event_list);
+	spin_lock_init(&dev->twt.event_lock);
+
 	init_waitqueue_head(&dev->reset_wait);
 	INIT_WORK(&dev->reset_work, mt7996_mac_reset_work);
 	INIT_WORK(&dev->dump_work, mt7996_mac_dump_work);
@@ -2081,6 +2085,8 @@ error:
 void mt7996_unregister_device(struct mt7996_dev *dev)
 {
 	cancel_work_sync(&dev->wed_rro.work);
+	cancel_work_sync(&dev->twt.event_work);
+	mt7996_twt_event_list_free(dev);
 	mt7996_unregister_phy(mt7996_phy3(dev));
 	mt7996_unregister_phy(mt7996_phy2(dev));
 	mt7996_unregister_thermal(&dev->phy);
diff --git a/mt7996/mac.c b/mt7996/mac.c
index a06ed042b..3ee80773c 100644
--- a/mt7996/mac.c
+++ b/mt7996/mac.c
@@ -16,6 +16,8 @@
 
 static void mt7996_scan_rx(struct mt7996_phy *phy);
 static void mt7996_rx_beacon_hint(struct mt7996_phy *phy, struct mt7996_vif *mvif);
+static int mt7996_mac_btwt_add_member(struct mt7996_twt_flow *flow, u16 idx);
+static int mt7996_mac_btwt_del_member(struct mt7996_twt_flow *flow, u16 idx);
 
 static struct mt76_wcid *mt7996_rx_get_wcid(struct mt7996_dev *dev,
 					    u16 idx, u8 band_idx)
@@ -1502,6 +1504,145 @@ next:
 	}
 }
 
+static void
+mt7996_twt_event_enqueue(struct mt7996_dev *dev, struct sk_buff *skb, u16 wcid_idx)
+{
+	struct ieee80211_mgmt *mgmt = (struct ieee80211_mgmt *)skb->data;
+	struct ieee80211_twt_setup *twt =
+		(struct ieee80211_twt_setup *)mgmt->u.action.u.s1g.variable;
+	struct ieee80211_twt_params *twt_agrt =
+		(struct ieee80211_twt_params *)twt->params;
+	struct mt7996_twt_event *ev;
+	u8 id;
+
+	if (!(twt->control & IEEE80211_TWT_CONTROL_NEG_TYPE_BROADCAST))
+		return;
+
+	id = le16_get_bits(twt_agrt->bcast.btwt_info, IEEE80211_BTWT_INFO_ID);
+
+	ev = kzalloc(sizeof(*ev), GFP_ATOMIC);
+	if (!ev)
+		return;
+
+	INIT_LIST_HEAD(&ev->list);
+	ev->btwt_id = id;
+	ev->wcid_idx = wcid_idx;
+
+	spin_lock_bh(&dev->twt.event_lock);
+	list_add_tail(&ev->list, &dev->twt.event_list);
+	spin_unlock_bh(&dev->twt.event_lock);
+
+	queue_work(dev->mt76.wq, &dev->twt.event_work);
+}
+
+static void
+mt7996_mac_txs_action_frame(struct mt7996_dev *dev, struct sk_buff *skb, u16 wcid_idx)
+{
+	struct ieee80211_mgmt *mgmt = (struct ieee80211_mgmt *)skb->data;
+
+	switch (mgmt->u.action.category) {
+	case WLAN_CATEGORY_S1G:
+		if (mgmt->u.action.u.s1g.action_code == WLAN_S1G_TWT_SETUP)
+			mt7996_twt_event_enqueue(dev, skb, wcid_idx);
+		break;
+	default:
+		break;
+	}
+}
+
+static struct mt7996_vif_link *
+mt7996_twt_wcid_link(struct mt7996_dev *dev, u16 wcid_idx)
+{
+	struct mt7996_sta_link *msta_link;
+	struct mt76_wcid *wcid;
+	struct mt7996_sta *msta;
+	struct ieee80211_vif *vif;
+	u8 link_id;
+
+	lockdep_assert_held(&dev->mt76.mutex);
+
+	rcu_read_lock();
+	wcid = mt76_wcid_ptr(dev, wcid_idx);
+	if (!wcid || !wcid->sta) {
+		rcu_read_unlock();
+		return NULL;
+	}
+	link_id = wcid->link_id;
+
+	msta_link = container_of(wcid, struct mt7996_sta_link, wcid);
+	msta = msta_link->sta;
+	if (!msta || !msta->vif) {
+		rcu_read_unlock();
+		return NULL;
+	}
+	vif = container_of((void *)msta->vif, struct ieee80211_vif, drv_priv);
+	rcu_read_unlock();
+
+	return mt7996_vif_link(dev, vif, link_id);
+}
+
+void mt7996_twt_event_work(struct work_struct *work)
+{
+	struct mt7996_dev *dev =
+		container_of(work, struct mt7996_dev, twt.event_work);
+
+	for (;;) {
+		struct mt7996_twt_flow *flow = NULL;
+		struct mt7996_twt_event *ev;
+		struct mt7996_vif_link *link;
+		u8 i;
+
+		spin_lock_bh(&dev->twt.event_lock);
+		if (list_empty(&dev->twt.event_list)) {
+			spin_unlock_bh(&dev->twt.event_lock);
+			break;
+		}
+		ev = list_first_entry(&dev->twt.event_list, struct mt7996_twt_event, list);
+		list_del(&ev->list);
+		spin_unlock_bh(&dev->twt.event_lock);
+
+		mutex_lock(&dev->mt76.mutex);
+
+		for (i = 0; i < MT7996_MAX_BTWT_AGRT; i++) {
+			if ((dev->twt.table_mask & BIT(i + MT7996_BTWT_AGRT_OFFSET)) &&
+			    (dev->twt.btwt_flow[i].peer_id_grp_id & 0xff) == ev->btwt_id) {
+				flow = &dev->twt.btwt_flow[i];
+				break;
+			}
+		}
+		if (!flow)
+			goto out_unlock;
+
+		link = mt7996_twt_wcid_link(dev, ev->wcid_idx);
+		if (!link)
+			goto out_unlock;
+
+		if (mt7996_mac_btwt_add_member(flow, ev->wcid_idx))
+			goto out_unlock;
+
+		if (mt7996_mcu_twt_agrt_update(dev, link, flow, MCU_TWT_AGRT_MODIFY))
+			mt7996_mac_btwt_del_member(flow, ev->wcid_idx);
+
+out_unlock:
+		mutex_unlock(&dev->mt76.mutex);
+		kfree(ev);
+	}
+}
+
+void mt7996_twt_event_list_free(struct mt7996_dev *dev)
+{
+	struct mt7996_twt_event *ev;
+
+	spin_lock_bh(&dev->twt.event_lock);
+	while (!list_empty(&dev->twt.event_list)) {
+		ev = list_first_entry(&dev->twt.event_list,
+				      struct mt7996_twt_event, list);
+		list_del(&ev->list);
+		kfree(ev);
+	}
+	spin_unlock_bh(&dev->twt.event_lock);
+}
+
 static bool
 mt7996_mac_add_txs_skb(struct mt7996_dev *dev, struct mt76_wcid *wcid,
 		       struct mt76_wcid *link_wcid, int pid, __le32 *txs_data)
@@ -1551,6 +1692,10 @@ mt7996_mac_add_txs_skb(struct mt7996_dev *dev, struct mt76_wcid *wcid,
 				mvif->beacon_received_time[wcid->phy_idx] = jiffies;
 				mvif->probe_send_count[wcid->phy_idx] = 0;
 			}
+
+			if (ieee80211_is_action(hdr->frame_control) &&
+			    info->flags & IEEE80211_TX_STAT_ACK)
+				mt7996_mac_txs_action_frame(dev, skb, wcid->idx);
 		}
 		break;
 	default:
@@ -2551,6 +2696,9 @@ mt7996_mac_full_reset(struct mt7996_dev *dev)
 
 	mt76_abort_scan(&dev->mt76);
 
+	cancel_work_sync(&dev->twt.event_work);
+	mt7996_twt_event_list_free(dev);
+
 	mutex_lock(&dev->mt76.mutex);
 	for (i = 0; i < 10; i++) {
 		if (!mt7996_mac_restart(dev))
@@ -3529,11 +3677,11 @@ static int mt7996_mac_btwt_setup(struct ieee80211_hw *hw,
 	if (mt7996_mac_check_twt_req(twt))
 		goto out;
 
-	mutex_lock(&dev->mt76.mutex);
+	id = le16_get_bits(twt_agrt->bcast.btwt_info, IEEE80211_BTWT_INFO_ID);
 
+	mutex_lock(&dev->mt76.mutex);
 	msta_link = mt76_dereference(msta->link[0], &dev->mt76);
 	link = mt7996_vif_link(dev, vif, 0);
-	id = le16_get_bits(twt_agrt->bcast.btwt_info, IEEE80211_BTWT_INFO_ID);
 
 	if (id == 0) {
 		if (mt7996_mac_btwt_setup_id_0(dev, link, msta_link))
@@ -3552,14 +3700,6 @@ static int mt7996_mac_btwt_setup(struct ieee80211_hw *hw,
 	if (!flow)
 		goto unlock;
 
-	if (mt7996_mac_btwt_add_member(flow, msta_link->wcid.idx))
-		goto unlock;
-
-	if (mt7996_mcu_twt_agrt_update(dev, link, flow, MCU_TWT_AGRT_MODIFY)) {
-		mt7996_mac_btwt_del_member(flow, msta_link->wcid.idx);
-		goto unlock;
-	}
-
 	/* Calculate the future TSF and fill in the outgoing TWT action frame.
 	 * Since the TWT field in the frame has only 16bits, we need to
 	 * extract TSF[10:25] according to spec
diff --git a/mt7996/main.c b/mt7996/main.c
index 813c23acf..292708417 100644
--- a/mt7996/main.c
+++ b/mt7996/main.c
@@ -142,6 +142,8 @@ static void mt7996_stop(struct ieee80211_hw *hw, bool suspend)
 	struct mt7996_dev *dev = mt7996_hw_dev(hw);
 
 	cancel_delayed_work_sync(&dev->scs_work);
+	cancel_work_sync(&dev->twt.event_work);
+	mt7996_twt_event_list_free(dev);
 }
 
 static inline int get_free_idx(u64 mask, u8 start, u8 end)
diff --git a/mt7996/mt7996.h b/mt7996/mt7996.h
index 5ded01623..9c1c1cec9 100644
--- a/mt7996/mt7996.h
+++ b/mt7996/mt7996.h
@@ -329,6 +329,11 @@ struct mt7996_twt_flow {
 	u8 trigger:1;
 	u8 sched:1;
 };
+struct mt7996_twt_event {
+	struct list_head list;
+	u8 btwt_id;
+	u16 wcid_idx;
+};
 
 DECLARE_EWMA(avg_signal, 10, 8)
 
@@ -941,6 +946,9 @@ struct mt7996_dev {
 		u8 n_agrt;
 		u8 n_agrt_bc;
 		struct mt7996_twt_flow btwt_flow[MT7996_MAX_BTWT_AGRT];
+		struct work_struct event_work;
+		struct list_head event_list;
+		spinlock_t event_lock;
 	} twt;
 
 	spinlock_t reg_lock;
@@ -1487,6 +1495,8 @@ bool mt7996_rx_check(struct mt76_dev *mdev, void *data, int len);
 void mt7996_stats_work(struct work_struct *work);
 void mt7996_beacon_mon_work(struct work_struct *work);
 void mt7996_sta_chsw_work(struct work_struct *work);
+void mt7996_twt_event_work(struct work_struct *work);
+void mt7996_twt_event_list_free(struct mt7996_dev *dev);
 int mt76_dfs_start_rdd(struct mt7996_dev *dev, bool force);
 int mt7996_dfs_init_radar_detector(struct mt7996_phy *phy);
 void mt7996_set_stream_he_eht_caps(struct mt7996_phy *phy);
-- 
2.45.2

