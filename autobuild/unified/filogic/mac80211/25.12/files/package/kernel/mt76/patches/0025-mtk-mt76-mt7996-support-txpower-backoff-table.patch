From 99c403eae2479caec06175c7c29b460caf473d3d Mon Sep 17 00:00:00 2001
From: Shayne Chen <shayne.chen@mediatek.com>
Date: Mon, 8 Dec 2025 15:27:26 +0800
Subject: [PATCH 025/105] mtk: mt76: mt7996: support txpower backoff table

Signed-off-by: Shayne Chen <shayne.chen@mediatek.com>
---
 eeprom.c        |  22 +++++----
 mt76.h          |   8 ++--
 mt7915/init.c   |  11 +++--
 mt7915/mcu.c    |  66 +++++++++++++++-----------
 mt7996/init.c   |  23 +++++++--
 mt7996/mcu.c    | 124 ++++++++++++++++++++++++++++++++++++++----------
 mt7996/mt7996.h |   2 +
 7 files changed, 184 insertions(+), 72 deletions(-)

diff --git a/eeprom.c b/eeprom.c
index ea50c4cc6..197f36a0a 100644
--- a/eeprom.c
+++ b/eeprom.c
@@ -376,30 +376,24 @@ s8 mt76_get_rate_power_limits(struct mt76_phy *phy,
 			      struct mt76_power_limits *dest,
 			      s8 target_power)
 {
-	struct mt76_dev *dev = phy->dev;
 	struct device_node *np;
 	const s8 *val;
 	char name[16];
-	u32 mcs_rates = dev->drv->mcs_rates;
-	u32 ru_rates = ARRAY_SIZE(dest->ru[0]);
 	char band;
 	size_t len;
-	s8 max_power = 0;
+	s8 max_power = -127;
 	s8 max_power_backoff = -127;
 	s8 txs_delta;
 	int n_chains = hweight16(phy->chainmask);
 	s8 target_power_combine = target_power + mt76_tx_power_path_delta(n_chains);
 
-	if (!mcs_rates)
-		mcs_rates = 10;
-
 	memset(dest, target_power, sizeof(*dest) - sizeof(dest->path));
 	memset(&dest->path, 0, sizeof(dest->path));
 
 	if (!IS_ENABLED(CONFIG_OF))
 		return target_power;
 
-	np = mt76_find_power_limits_node(dev);
+	np = mt76_find_power_limits_node(phy->dev);
 	if (!np)
 		return target_power;
 
@@ -437,16 +431,24 @@ s8 mt76_get_rate_power_limits(struct mt76_phy *phy,
 	mt76_apply_array_limit(dest->ofdm, ARRAY_SIZE(dest->ofdm), val,
 			       target_power, txs_delta, &max_power);
 
-	val = mt76_get_of_array_s8(np, "rates-mcs", &len, mcs_rates + 1);
+	val = mt76_get_of_array_s8(np, "rates-mcs", &len,
+				   ARRAY_SIZE(dest->mcs[0]) + 1);
 	mt76_apply_multi_array_limit(dest->mcs[0], ARRAY_SIZE(dest->mcs[0]),
 				     ARRAY_SIZE(dest->mcs), val, len,
 				     target_power, txs_delta);
 
-	val = mt76_get_of_array_s8(np, "rates-ru", &len, ru_rates + 1);
+	val = mt76_get_of_array_s8(np, "rates-ru", &len,
+				   ARRAY_SIZE(dest->ru[0]) + 1);
 	mt76_apply_multi_array_limit(dest->ru[0], ARRAY_SIZE(dest->ru[0]),
 				     ARRAY_SIZE(dest->ru), val, len,
 				     target_power, txs_delta);
 
+	val = mt76_get_of_array_s8(np, "rates-eht", &len,
+				   ARRAY_SIZE(dest->eht[0]) + 1);
+	mt76_apply_multi_array_limit(dest->eht[0], ARRAY_SIZE(dest->eht[0]),
+				     ARRAY_SIZE(dest->eht), val, len,
+				     target_power, txs_delta);
+
 	max_power_backoff = max_power;
 	val = mt76_get_of_array_s8(np, "paths-cck", &len, ARRAY_SIZE(dest->path.cck));
 	mt76_apply_array_limit(dest->path.cck, ARRAY_SIZE(dest->path.cck), val,
diff --git a/mt76.h b/mt76.h
index 44c9c6192..2cf899c42 100644
--- a/mt76.h
+++ b/mt76.h
@@ -1146,11 +1146,11 @@ struct mt76_power_limits {
 	s8 eht[16][16];
 
 	struct {
-		s8 cck[4];
-		s8 ofdm[4];
+		s8 cck[5];
+		s8 ofdm[5];
 		s8 ofdm_bf[4];
-		s8 ru[7][10];
-		s8 ru_bf[7][10];
+		s8 ru[16][15];
+		s8 ru_bf[16][15];
 	} path;
 };
 
diff --git a/mt7915/init.c b/mt7915/init.c
index 2da6ea91b..b16f35963 100644
--- a/mt7915/init.c
+++ b/mt7915/init.c
@@ -287,7 +287,11 @@ static void __mt7915_init_txpower(struct mt7915_phy *phy,
 	int i, n_chains = hweight16(phy->mt76->chainmask);
 	int path_delta = mt76_tx_power_path_delta(n_chains);
 	int pwr_delta = mt7915_eeprom_get_power_delta(dev, sband->band);
-	struct mt76_power_limits limits;
+	struct mt76_power_limits *limits;
+
+	limits = kzalloc(sizeof(*limits), GFP_KERNEL);
+	if (!limits)
+		return;
 
 	phy->sku_limit_en = true;
 	phy->sku_path_en = true;
@@ -305,11 +309,11 @@ static void __mt7915_init_txpower(struct mt7915_phy *phy,
 
 		target_power += pwr_delta;
 		target_power = mt76_get_rate_power_limits(phy->mt76, chan,
-							  &limits,
+							  limits,
 							  target_power);
 
 		/* MT7915N can not enable Backoff table without setting value in dts */
-		if (!limits.path.ofdm[0])
+		if (!limits->path.ofdm[0])
 			phy->sku_path_en = false;
 
 		target_power += path_delta;
@@ -318,6 +322,7 @@ static void __mt7915_init_txpower(struct mt7915_phy *phy,
 					target_power);
 		chan->orig_mpwr = target_power;
 	}
+	kfree(limits);
 }
 
 void mt7915_init_txpower(struct mt7915_phy *phy)
diff --git a/mt7915/mcu.c b/mt7915/mcu.c
index 40364eeaa..9e8ecdd77 100644
--- a/mt7915/mcu.c
+++ b/mt7915/mcu.c
@@ -3435,13 +3435,17 @@ int mt7915_mcu_set_txpower_sku(struct mt7915_phy *phy)
 	};
 	int i, ret, tx_power;
 	const u8 *len = mt7915_sku_group_len;
-	struct mt76_power_limits la = {};
+	struct mt76_power_limits *la;
 	struct sk_buff *skb;
 
 	tx_power = mt76_get_power_bound(mphy, hw->conf.power_level);
 	if (phy->sku_limit_en) {
+		la = kzalloc(sizeof(*la), GFP_KERNEL);
+		if (!la)
+			return -ENOMEM;
+
 		tx_power = mt76_get_rate_power_limits(mphy, mphy->chandef.chan,
-						      &la, tx_power);
+						      la, tx_power);
 		mt7915_update_txpower(phy, tx_power);
 	} else {
 		mt7915_update_txpower(phy, tx_power);
@@ -3450,47 +3454,52 @@ int mt7915_mcu_set_txpower_sku(struct mt7915_phy *phy)
 
 	skb = mt76_mcu_msg_alloc(&dev->mt76, NULL,
 				 sizeof(hdr) + MT7915_SKU_RATE_NUM);
-	if (!skb)
-		return -ENOMEM;
+	if (!skb) {
+		ret = -ENOMEM;
+		goto out;
+	}
 
 	skb_put_data(skb, &hdr, sizeof(hdr));
-	skb_put_data(skb, &la.cck, len[SKU_CCK] + len[SKU_OFDM]);
-	skb_put_data(skb, &la.mcs[0], len[SKU_HT_BW20]);
-	skb_put_data(skb, &la.mcs[1], len[SKU_HT_BW40]);
+	skb_put_data(skb, &la->cck, len[SKU_CCK] + len[SKU_OFDM]);
+	skb_put_data(skb, &la->mcs[0], len[SKU_HT_BW20]);
+	skb_put_data(skb, &la->mcs[1], len[SKU_HT_BW40]); /* HT40 */
 
-	/* vht */
+	/* VHT20, VHT40, VHT80, and VHT160 */
 	for (i = 0; i < 4; i++) {
-		skb_put_data(skb, &la.mcs[i], sizeof(la.mcs[i]));
+		skb_put_data(skb, &la->mcs[i], 10);
 		skb_put_zero(skb, 2);  /* padding */
 	}
 
-	/* he */
-	skb_put_data(skb, &la.ru[0], sizeof(la.ru));
+	/* HE RU26, RU52, RU106, RU242, RU484, RU996, and RU2x996 */
+	skb_put_data(skb, &la->ru[0], len[SKU_HE_RU26] * 7);
 	ret = mt76_mcu_skb_send_msg(&dev->mt76, skb,
 				    MCU_EXT_CMD(TX_POWER_FEATURE_CTRL), true);
 	if (ret)
-		return ret;
+		goto out;
 
 	/* only set per-path power table when it's configured */
 	if (!phy->sku_path_en)
-		return 0;
+		goto out;
 
 	skb = mt76_mcu_msg_alloc(&dev->mt76, NULL,
 				 sizeof(hdr) + MT7915_SKU_PATH_NUM);
-	if (!skb)
-		return -ENOMEM;
+	if (!skb) {
+		ret = -ENOMEM;
+		goto out;
+	}
 
 	hdr.limit_type = TX_POWER_LIMIT_TABLE_PATH;
 	skb_put_data(skb, &hdr, sizeof(hdr));
-	skb_put_data(skb, &la.path.cck, sizeof(la.path.cck));
-	skb_put_data(skb, &la.path.ofdm, sizeof(la.path.ofdm));
-	skb_put_data(skb, &la.path.ofdm_bf[1], sizeof(la.path.ofdm_bf) - 1);
+	skb_put_data(skb, &la->path.cck, 4);
+	skb_put_data(skb, &la->path.ofdm, 4);
+	skb_put_data(skb, &la->path.ofdm_bf[1], 3);
 
-	/* HT20 and HT40 */
-	skb_put_data(skb, &la.path.ru[3], sizeof(la.path.ru[3]));
-	skb_put_data(skb, &la.path.ru_bf[3][1], sizeof(la.path.ru_bf[3]) - 1);
-	skb_put_data(skb, &la.path.ru[4], sizeof(la.path.ru[4]));
-	skb_put_data(skb, &la.path.ru_bf[4][1], sizeof(la.path.ru_bf[4]) - 1);
+	/* HT20 */
+	skb_put_data(skb, &la->path.ru[3], 10);
+	skb_put_data(skb, &la->path.ru_bf[3][1], 9);
+	/* HT40 */
+	skb_put_data(skb, &la->path.ru[4], 10);
+	skb_put_data(skb, &la->path.ru_bf[4][1], 9);
 
 	/* start from non-bf and bf fields of
 	 * BW20/RU242, BW40/RU484, BW80/RU996, BW160/RU2x996,
@@ -3500,7 +3509,7 @@ int mt7915_mcu_set_txpower_sku(struct mt7915_phy *phy)
 	for (i = 0; i < 8; i++) {
 		bool bf = i % 2;
 		u8 idx = (i + 6) / 2;
-		s8 *buf = bf ? la.path.ru_bf[idx] : la.path.ru[idx];
+		s8 *buf = bf ? la->path.ru_bf[idx] : la->path.ru[idx];
 		/* The non-bf fields of RU26 to RU106 are special cases */
 		if (bf)
 			skb_put_data(skb, buf + 1, 9);
@@ -3511,13 +3520,16 @@ int mt7915_mcu_set_txpower_sku(struct mt7915_phy *phy)
 	for (i = 0; i < 6; i++) {
 		bool bf = i % 2;
 		u8 idx = i / 2;
-		s8 *buf = bf ? la.path.ru_bf[idx] : la.path.ru[idx];
+		s8 *buf = bf ? la->path.ru_bf[idx] : la->path.ru[idx];
 
 		skb_put_data(skb, buf, 10);
 	}
 
-	return mt76_mcu_skb_send_msg(&dev->mt76, skb,
-				     MCU_EXT_CMD(TX_POWER_FEATURE_CTRL), true);
+	ret = mt76_mcu_skb_send_msg(&dev->mt76, skb,
+				    MCU_EXT_CMD(TX_POWER_FEATURE_CTRL), true);
+out:
+	kfree(la);
+	return ret;
 }
 
 int mt7915_mcu_get_txpower_sku(struct mt7915_phy *phy, s8 *txpower, int len,
diff --git a/mt7996/init.c b/mt7996/init.c
index 3215e4757..8e389cece 100644
--- a/mt7996/init.c
+++ b/mt7996/init.c
@@ -361,23 +361,38 @@ static void __mt7996_init_txpower(struct mt7996_phy *phy,
 	int i, n_chains = hweight16(phy->mt76->chainmask);
 	int path_delta = mt76_tx_power_path_delta(n_chains);
 	int pwr_delta = mt7996_eeprom_get_power_delta(dev, sband->band);
-	struct mt76_power_limits limits;
+	struct mt76_power_limits *limits;
+	struct device_node *np;
 
+	limits = kzalloc(sizeof(*limits), GFP_KERNEL);
+	if (!limits)
+		return;
+
+	phy->sku_limit_en = true;
+	phy->sku_path_en = true;
+	np = mt76_find_power_limits_node(&dev->mt76);
 	for (i = 0; i < sband->n_channels; i++) {
 		struct ieee80211_channel *chan = &sband->channels[i];
 		int target_power = mt7996_eeprom_get_target_power(dev, chan);
 
 		target_power += pwr_delta;
 		target_power = mt76_get_rate_power_limits(phy->mt76, chan,
-							  &limits,
+							  limits,
 							  target_power);
+		if (!limits->path.ofdm[0])
+			phy->sku_path_en = false;
+
 		target_power += path_delta;
 		target_power = DIV_ROUND_UP(target_power, 2);
-		chan->max_power = min_t(int, chan->max_reg_power,
-					target_power);
+		if (!np)
+			chan->max_power = min_t(int, chan->max_reg_power,
+						target_power);
+		else
+			chan->max_power = target_power;
 		phy->txpower = max(phy->txpower, chan->max_power);
 		chan->orig_mpwr = target_power;
 	}
+	kfree(limits);
 }
 
 void mt7996_init_txpower(struct mt7996_phy *phy)
diff --git a/mt7996/mcu.c b/mt7996/mcu.c
index b154353d8..f65a1b025 100644
--- a/mt7996/mcu.c
+++ b/mt7996/mcu.c
@@ -4953,9 +4953,42 @@ int mt7996_mcu_set_sniffer_mode(struct mt7996_phy *phy, bool enabled)
 				 sizeof(req), true);
 }
 
+static void
+mt7996_update_max_txpower_cur(struct mt7996_phy *phy, int tx_power)
+{
+	struct mt76_phy *mphy = phy->mt76;
+	struct ieee80211_channel *chan = mphy->main_chandef.chan;
+	int e2p_power_limit = 0;
+
+	if (chan == NULL) {
+		mphy->txpower_cur = tx_power;
+		return;
+	}
+
+	e2p_power_limit = mt7996_eeprom_get_target_power(phy->dev, chan);
+	e2p_power_limit += mt7996_eeprom_get_power_delta(phy->dev, chan->band);
+
+	if (phy->sku_limit_en)
+		mphy->txpower_cur = min_t(int, e2p_power_limit, tx_power);
+	else
+		mphy->txpower_cur = e2p_power_limit;
+}
+
+static s8 mt7996_get_power_bound(struct mt7996_phy *phy, s8 txpower)
+{
+       struct mt76_phy *mphy = phy->mt76;
+       int n_chains = hweight16(mphy->chainmask);
+
+       txpower = mt76_get_sar_power(mphy, mphy->chandef.chan, txpower * 2);
+       txpower -= mt76_tx_power_path_delta(n_chains);
+
+       return txpower;
+}
+
 int mt7996_mcu_set_txpower_sku(struct mt7996_phy *phy)
 {
 #define TX_POWER_LIMIT_TABLE_RATE	0
+#define TX_POWER_LIMIT_TABLE_PATH	1
 	struct mt7996_dev *dev = phy->dev;
 	struct mt76_phy *mphy = phy->mt76;
 	struct tx_power_limit_table_ctrl {
@@ -4973,45 +5006,88 @@ int mt7996_mcu_set_txpower_sku(struct mt7996_phy *phy)
 		.power_limit_type = TX_POWER_LIMIT_TABLE_RATE,
 		.band_idx = phy->mt76->band_idx,
 	};
-	struct mt76_power_limits la = {};
+	struct mt76_power_limits *la;
 	struct sk_buff *skb;
-	int i, tx_power;
+	int i, ret, txpower_limit;
+
+	txpower_limit = mt7996_get_power_bound(phy, phy->txpower);
+
+	if (phy->sku_limit_en) {
+		la = kzalloc(sizeof(*la), GFP_KERNEL);
+		if (!la)
+			return -ENOMEM;
 
-	tx_power = mt76_get_power_bound(mphy, phy->txpower);
-	tx_power = mt76_get_rate_power_limits(mphy, mphy->chandef.chan,
-					      &la, tx_power);
-	mphy->txpower_cur = tx_power;
+		txpower_limit = mt76_get_rate_power_limits(mphy, mphy->chandef.chan,
+							   la, txpower_limit);
+		mt7996_update_max_txpower_cur(phy, txpower_limit);
+	} else {
+		mt7996_update_max_txpower_cur(phy, txpower_limit);
+		return 0;
+	}
 
 	skb = mt76_mcu_msg_alloc(&dev->mt76, NULL,
 				 sizeof(req) + MT7996_SKU_PATH_NUM);
-	if (!skb)
-		return -ENOMEM;
+	if (!skb) {
+		ret = -ENOMEM;
+		goto out;
+	}
 
 	skb_put_data(skb, &req, sizeof(req));
-	/* cck and ofdm */
-	skb_put_data(skb, &la.cck, sizeof(la.cck));
-	skb_put_data(skb, &la.ofdm, sizeof(la.ofdm));
-	/* ht20 */
-	skb_put_data(skb, &la.mcs[0], 8);
-	/* ht40 */
-	skb_put_data(skb, &la.mcs[1], 9);
-
-	/* vht */
+	skb_put_data(skb, &la->cck, 12); /* CCK + OFDM */
+	skb_put_data(skb, &la->mcs[0], 8); /* HT20 */
+	skb_put_data(skb, &la->mcs[1], 9); /* HT40 */
+
+	/* VHT20, VHT40, VHT80, and VHT160 */
 	for (i = 0; i < 4; i++) {
-		skb_put_data(skb, &la.mcs[i], sizeof(la.mcs[i]));
+		skb_put_data(skb, &la->mcs[i], 10);
 		skb_put_zero(skb, 2);  /* padding */
 	}
 
-	/* he */
-	skb_put_data(skb, &la.ru[0], sizeof(la.ru));
-	/* eht */
-	skb_put_data(skb, &la.eht[0], sizeof(la.eht));
+	/* HE RU26, RU52, RU106, RU242, RU484, RU996, and RU2x996 */
+	skb_put_data(skb, &la->ru[0], 84);
+	/* EHT RU26, RU52, RU78, RU106, RU132, RU242, RU484, RU726, RU996, RU1480,
+	 * RU1722, RU1922, RU2476, RU2988, RU3472, and RU3984
+	 */
+	skb_put_data(skb, &la->eht[0], 256);
 
 	/* padding */
 	skb_put_zero(skb, MT7996_SKU_PATH_NUM - MT7996_SKU_RATE_NUM);
 
-	return mt76_mcu_skb_send_msg(&dev->mt76, skb,
-				     MCU_WM_UNI_CMD(TXPOWER), true);
+	ret = mt76_mcu_skb_send_msg(&dev->mt76, skb,
+				    MCU_WM_UNI_CMD(TXPOWER), true);
+	if (ret)
+		goto out;
+
+	/* only set per-path power table when it's configured */
+	if (!phy->sku_path_en)
+		goto out;
+
+	skb = mt76_mcu_msg_alloc(&dev->mt76, NULL,
+				 sizeof(req) + MT7996_SKU_PATH_NUM);
+	if (!skb) {
+		ret = -ENOMEM;
+		goto out;
+	}
+	req.power_limit_type = TX_POWER_LIMIT_TABLE_PATH;
+
+	skb_put_data(skb, &req, sizeof(req));
+	skb_put_data(skb, &la->path.cck, 5);
+	skb_put_data(skb, &la->path.ofdm, 5);
+	skb_put_data(skb, &la->path.ofdm_bf, 4);
+
+	for (i = 0; i < 32; i++) {
+		bool bf = i % 2;
+		u8 idx = i / 2;
+		s8 *buf = bf ? la->path.ru_bf[idx] : la->path.ru[idx];
+
+		skb_put_data(skb, buf, 15);
+	}
+
+	ret = mt76_mcu_skb_send_msg(&dev->mt76, skb,
+				    MCU_WM_UNI_CMD(TXPOWER), true);
+out:
+	kfree(la);
+	return ret;
 }
 
 int mt7996_mcu_cp_support(struct mt7996_dev *dev, u8 mode)
diff --git a/mt7996/mt7996.h b/mt7996/mt7996.h
index 89bac2d5e..f655cadff 100644
--- a/mt7996/mt7996.h
+++ b/mt7996/mt7996.h
@@ -378,6 +378,8 @@ struct mt7996_phy {
 	bool has_aux_rx;
 	bool counter_reset;
 	bool rdd_tx_paused;
+	bool sku_limit_en;
+	bool sku_path_en;
 };
 
 struct mt7996_dev {
-- 
2.45.2

