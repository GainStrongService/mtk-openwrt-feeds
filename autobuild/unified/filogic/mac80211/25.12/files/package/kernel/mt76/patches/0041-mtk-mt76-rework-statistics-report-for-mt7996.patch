From c5563d50c293ee460702dbf00fff6222cff4b9b7 Mon Sep 17 00:00:00 2001
From: Shayne Chen <shayne.chen@mediatek.com>
Date: Tue, 4 Nov 2025 12:09:25 +0800
Subject: [PATCH 041/105] mtk: mt76: rework statistics report for mt7996

Get statistics from FW instead of TXS.

---
 mt76.h            |  31 ++++
 mt76_connac_mcu.h |  17 ++
 mt7996/init.c     |   5 -
 mt7996/mac.c      | 340 +++++++++++----------------------------
 mt7996/main.c     |  84 +++++++++-
 mt7996/mcu.c      | 395 +++++++++++++++++++++++++++++++++++++++++++---
 mt7996/mcu.h      |  73 ++++++++-
 mt7996/mt7996.h   |  17 +-
 8 files changed, 680 insertions(+), 282 deletions(-)

diff --git a/mt76.h b/mt76.h
index bea4449aa..fe5404954 100644
--- a/mt76.h
+++ b/mt76.h
@@ -339,6 +339,7 @@ enum mt76_phy_type {
 	MT_PHY_TYPE_HT,
 	MT_PHY_TYPE_HT_GF,
 	MT_PHY_TYPE_VHT,
+	MT_PHY_TYPE_PLR, /* Proprietary Long Range */
 	MT_PHY_TYPE_HE_SU = 8,
 	MT_PHY_TYPE_HE_EXT_SU,
 	MT_PHY_TYPE_HE_TB,
@@ -347,6 +348,7 @@ enum mt76_phy_type {
 	MT_PHY_TYPE_EHT_TRIG,
 	MT_PHY_TYPE_EHT_MU,
 	__MT_PHY_TYPE_MAX,
+	MT_PHY_TYPE_UNKNOWN = 0xff
 };
 
 struct mt76_sta_stats {
@@ -355,15 +357,26 @@ struct mt76_sta_stats {
 	u64 tx_nss[4];		/* 1, 2, 3, 4 */
 	u64 tx_mcs[16];		/* mcs idx */
 	u64 tx_bytes;
+	u64 tx_bytes_per_ac[IEEE80211_NUM_ACS];
+	u64 tx_bytes_failed;
+	u64 tx_bytes_failed_per_ac[IEEE80211_NUM_ACS];
 	/* WED TX */
 	u32 tx_packets;		/* unit: MSDU */
+	u32 tx_packets_retried;
+	u32 tx_packets_failed;
+	u32 tx_mpdus;
 	u32 tx_retries;
 	u32 tx_failed;
+	u64 tx_airtime;
 	/* WED RX */
 	u64 rx_bytes;
+	u64 rx_bytes_per_ac[IEEE80211_NUM_ACS];
 	u32 rx_packets;
+	u32 rx_mpdus;
+	u32 rx_fcs_err;
 	u32 rx_errors;
 	u32 rx_drops;
+	u64 rx_airtime;
 };
 
 enum mt76_wcid_flags {
@@ -395,6 +408,8 @@ struct mt76_wcid {
 	int inactive_count;
 
 	struct rate_info rate;
+	struct rate_info rx_rate;
+
 	unsigned long ampdu_state;
 
 	u16 idx;
@@ -1413,6 +1428,22 @@ static inline int mt76_decr(int val, int size)
 
 u8 mt76_ac_to_hwq(u8 ac);
 
+static inline u8
+mt76_ac_to_tid(u8 ac)
+{
+	static const u8 ac_to_tid[] = {
+		[IEEE80211_AC_BE] = 0,
+		[IEEE80211_AC_BK] = 1,
+		[IEEE80211_AC_VI] = 4,
+		[IEEE80211_AC_VO] = 6
+	};
+
+	if (WARN_ON(ac >= IEEE80211_NUM_ACS))
+		return 0;
+
+	return ac_to_tid[ac];
+}
+
 static inline struct ieee80211_txq *
 mtxq_to_txq(struct mt76_txq *mtxq)
 {
diff --git a/mt76_connac_mcu.h b/mt76_connac_mcu.h
index 175ec5e00..dbfe2c43e 100644
--- a/mt76_connac_mcu.h
+++ b/mt76_connac_mcu.h
@@ -1393,6 +1393,21 @@ enum {
 	UNI_OFFLOAD_OFFLOAD_BMC_RPY_DETECT,
 };
 
+#define PER_STA_INFO_MAX_NUM	90
+
+enum UNI_PER_STA_INFO_TAG {
+	UNI_PER_STA_RSSI,
+	UNI_PER_STA_CONTENTION_RX_RATE,
+	UNI_PER_STA_PER,
+	UNI_PER_STA_SNR,
+	UNI_PER_STA_TX_RATE,
+	UNI_PER_STA_TX_CNT,
+	UNI_PER_STA_TID_SN_GET,
+	UNI_PER_STA_TID_SN_SET,
+	UNI_PER_STA_PKT_CNT,
+	UNI_PER_STA_MAX_NUM
+};
+
 enum UNI_ALL_STA_INFO_TAG {
 	UNI_ALL_STA_TXRX_RATE,
 	UNI_ALL_STA_TX_STAT,
@@ -1401,6 +1416,8 @@ enum UNI_ALL_STA_INFO_TAG {
 	UNI_ALL_STA_DATA_TX_RETRY_COUNT,
 	UNI_ALL_STA_GI_MODE,
 	UNI_ALL_STA_TXRX_MSDU_COUNT,
+	UNI_ALL_STA_TXOP_ACCESS_DELAY,
+	UNI_ALL_STA_RX_MPDU_COUNT,
 	UNI_ALL_STA_MAX_NUM
 };
 
diff --git a/mt7996/init.c b/mt7996/init.c
index f7fefb9d1..08ef87b70 100644
--- a/mt7996/init.c
+++ b/mt7996/init.c
@@ -618,11 +618,6 @@ mt7996_mac_init_band(struct mt7996_dev *dev, u8 band)
 	      FIELD_PREP(MT_WTBLOFF_RSCR_RCPI_PARAM, 0x3);
 	mt76_rmw(dev, MT_WTBLOFF_RSCR(band), mask, set);
 
-	/* MT_TXD5_TX_STATUS_HOST (MPDU format) has higher priority than
-	 * MT_AGG_ACR_PPDU_TXS2H (PPDU format) even though ACR bit is set.
-	 */
-	mt76_set(dev, MT_AGG_ACR4(band), MT_AGG_ACR_PPDU_TXS2H);
-
 	if (!is_mt7996(&dev->mt76))
 		mt7996_mcu_set_bssid_mapping_addr(&dev->mt76, band);
 }
diff --git a/mt7996/mac.c b/mt7996/mac.c
index 9c8a3f9a9..cd45b411e 100644
--- a/mt7996/mac.c
+++ b/mt7996/mac.c
@@ -72,119 +72,6 @@ u32 mt7996_mac_wtbl_lmac_addr(struct mt7996_dev *dev, u16 wcid, u8 dw)
 	return MT_WTBL_LMAC_OFFS(wcid, dw);
 }
 
-static void mt7996_mac_sta_poll(struct mt7996_dev *dev)
-{
-	static const u8 ac_to_tid[] = {
-		[IEEE80211_AC_BE] = 0,
-		[IEEE80211_AC_BK] = 1,
-		[IEEE80211_AC_VI] = 4,
-		[IEEE80211_AC_VO] = 6
-	};
-	struct mt7996_sta_link *msta_link;
-	struct mt76_vif_link *mlink;
-	struct ieee80211_sta *sta;
-	struct mt7996_sta *msta;
-	u32 tx_time[IEEE80211_NUM_ACS], rx_time[IEEE80211_NUM_ACS];
-	LIST_HEAD(sta_poll_list);
-	struct mt76_wcid *wcid;
-	int i;
-
-	spin_lock_bh(&dev->mt76.sta_poll_lock);
-	list_splice_init(&dev->mt76.sta_poll_list, &sta_poll_list);
-	spin_unlock_bh(&dev->mt76.sta_poll_lock);
-
-	rcu_read_lock();
-
-	while (true) {
-		bool clear = false;
-		u32 addr, val;
-		u16 idx;
-		s8 rssi[4];
-
-		spin_lock_bh(&dev->mt76.sta_poll_lock);
-		if (list_empty(&sta_poll_list)) {
-			spin_unlock_bh(&dev->mt76.sta_poll_lock);
-			break;
-		}
-		msta_link = list_first_entry(&sta_poll_list,
-					     struct mt7996_sta_link,
-					     wcid.poll_list);
-		msta = msta_link->sta;
-		wcid = &msta_link->wcid;
-		list_del_init(&wcid->poll_list);
-		spin_unlock_bh(&dev->mt76.sta_poll_lock);
-
-		idx = wcid->idx;
-
-		/* refresh peer's airtime reporting */
-		addr = mt7996_mac_wtbl_lmac_addr(dev, idx, 20);
-
-		for (i = 0; i < IEEE80211_NUM_ACS; i++) {
-			u32 tx_last = msta_link->airtime_ac[i];
-			u32 rx_last = msta_link->airtime_ac[i + 4];
-
-			msta_link->airtime_ac[i] = mt76_rr(dev, addr);
-			msta_link->airtime_ac[i + 4] = mt76_rr(dev, addr + 4);
-
-			tx_time[i] = msta_link->airtime_ac[i] - tx_last;
-			rx_time[i] = msta_link->airtime_ac[i + 4] - rx_last;
-
-			if ((tx_last | rx_last) & BIT(30))
-				clear = true;
-
-			addr += 8;
-		}
-
-		if (clear) {
-			mt7996_mac_wtbl_update(dev, idx,
-					       MT_WTBL_UPDATE_ADM_COUNT_CLEAR);
-			memset(msta_link->airtime_ac, 0,
-			       sizeof(msta_link->airtime_ac));
-		}
-
-		if (!wcid->sta)
-			continue;
-
-		sta = container_of((void *)msta, struct ieee80211_sta,
-				   drv_priv);
-		for (i = 0; i < IEEE80211_NUM_ACS; i++) {
-			u8 q = mt76_connac_lmac_mapping(i);
-			u32 tx_cur = tx_time[q];
-			u32 rx_cur = rx_time[q];
-			u8 tid = ac_to_tid[i];
-
-			if (!tx_cur && !rx_cur)
-				continue;
-
-			ieee80211_sta_register_airtime(sta, tid, tx_cur, rx_cur);
-		}
-
-		/* get signal strength of resp frames (CTS/BA/ACK) */
-		addr = mt7996_mac_wtbl_lmac_addr(dev, idx, 34);
-		val = mt76_rr(dev, addr);
-
-		rssi[0] = to_rssi(GENMASK(7, 0), val);
-		rssi[1] = to_rssi(GENMASK(15, 8), val);
-		rssi[2] = to_rssi(GENMASK(23, 16), val);
-		rssi[3] = to_rssi(GENMASK(31, 14), val);
-
-		mlink = rcu_dereference(msta->vif->mt76.link[wcid->link_id]);
-		if (mlink) {
-			struct mt76_phy *mphy = mt76_vif_link_phy(mlink);
-
-			if (mphy)
-				msta_link->ack_signal =
-					mt76_rx_signal(mphy->antenna_mask,
-						       rssi);
-		}
-
-		ewma_avg_signal_add(&msta_link->avg_ack_signal,
-				    -msta_link->ack_signal);
-	}
-
-	rcu_read_unlock();
-}
-
 /* The HW does not translate the mac header to 802.3 for mesh point */
 static int mt7996_reverse_frag0_hdr_trans(struct sk_buff *skb, u16 hdr_gap)
 {
@@ -1422,8 +1309,6 @@ next:
 		}
 	}
 
-	mt7996_mac_sta_poll(dev);
-
 	if (wake)
 		mt76_set_tx_blocked(&dev->mt76, false);
 
@@ -1437,25 +1322,25 @@ next:
 
 static bool
 mt7996_mac_add_txs_skb(struct mt7996_dev *dev, struct mt76_wcid *wcid,
-		       int pid, __le32 *txs_data)
+		       struct mt76_wcid *link_wcid, int pid, __le32 *txs_data)
 {
-	struct mt76_sta_stats *stats = &wcid->stats;
-	struct ieee80211_supported_band *sband;
+#define MT_TXS_MPDU_FMT	0
+	u8 fmt = le32_get_bits(txs_data[0], MT_TXS0_TXS_FORMAT);
+	struct mt76_sta_stats *stats = &link_wcid->stats;
 	struct mt76_dev *mdev = &dev->mt76;
-	struct mt76_phy *mphy;
 	struct ieee80211_tx_info *info;
 	struct sk_buff_head list;
-	struct rate_info rate = {};
 	struct sk_buff *skb = NULL;
-	bool cck = false;
-	u32 txrate, txs, mode, stbc;
+	u32 txrate, txs;
+	u8 mode, bw, mcs, nss;
 
 	txs = le32_to_cpu(txs_data[0]);
 
 	mt76_tx_status_lock(mdev, &list);
 
-	/* only report MPDU TXS */
-	if (le32_get_bits(txs_data[0], MT_TXS0_TXS_FORMAT) == 0) {
+	switch (fmt) {
+	case MT_TXS_MPDU_FMT:
+		/* Only report MPDU TXS to mac80211. */
 		skb = mt76_tx_status_skb_get(mdev, wcid, pid, &list);
 		if (skb) {
 			info = IEEE80211_SKB_CB(skb);
@@ -1468,119 +1353,33 @@ mt7996_mac_add_txs_skb(struct mt7996_dev *dev, struct mt76_wcid *wcid,
 
 			info->status.rates[0].idx = -1;
 		}
-	}
-
-	if (mtk_wed_device_active(&dev->mt76.mmio.wed) && wcid->sta) {
-		struct ieee80211_sta *sta;
-		u8 tid;
-
-		sta = wcid_to_sta(wcid);
-		tid = FIELD_GET(MT_TXS0_TID, txs);
-		ieee80211_refresh_tx_agg_session_timer(sta, tid);
-	}
-
-	txrate = FIELD_GET(MT_TXS0_TX_RATE, txs);
-
-	rate.mcs = FIELD_GET(MT_TX_RATE_IDX, txrate);
-	rate.nss = FIELD_GET(MT_TX_RATE_NSS, txrate) + 1;
-	stbc = le32_get_bits(txs_data[3], MT_TXS3_RATE_STBC);
-
-	if (stbc && rate.nss > 1)
-		rate.nss >>= 1;
-
-	if (rate.nss - 1 < ARRAY_SIZE(stats->tx_nss))
-		stats->tx_nss[rate.nss - 1]++;
-	if (rate.mcs < ARRAY_SIZE(stats->tx_mcs))
-		stats->tx_mcs[rate.mcs]++;
-
-	mode = FIELD_GET(MT_TX_RATE_MODE, txrate);
-	switch (mode) {
-	case MT_PHY_TYPE_CCK:
-		cck = true;
-		fallthrough;
-	case MT_PHY_TYPE_OFDM:
-		mphy = mt76_dev_phy(mdev, wcid->phy_idx);
-
-		if (mphy->chandef.chan->band == NL80211_BAND_5GHZ)
-			sband = &mphy->sband_5g.sband;
-		else if (mphy->chandef.chan->band == NL80211_BAND_6GHZ)
-			sband = &mphy->sband_6g.sband;
-		else
-			sband = &mphy->sband_2g.sband;
-
-		rate.mcs = mt76_get_rate(mphy->dev, sband, rate.mcs, cck);
-		rate.legacy = sband->bitrates[rate.mcs].bitrate;
-		break;
-	case MT_PHY_TYPE_HT:
-	case MT_PHY_TYPE_HT_GF:
-		if (rate.mcs > 31)
-			goto out;
-
-		rate.flags = RATE_INFO_FLAGS_MCS;
-		if (wcid->rate.flags & RATE_INFO_FLAGS_SHORT_GI)
-			rate.flags |= RATE_INFO_FLAGS_SHORT_GI;
-		break;
-	case MT_PHY_TYPE_VHT:
-		if (rate.mcs > 9)
-			goto out;
-
-		rate.flags = RATE_INFO_FLAGS_VHT_MCS;
-		if (wcid->rate.flags & RATE_INFO_FLAGS_SHORT_GI)
-			rate.flags |= RATE_INFO_FLAGS_SHORT_GI;
-		break;
-	case MT_PHY_TYPE_HE_SU:
-	case MT_PHY_TYPE_HE_EXT_SU:
-	case MT_PHY_TYPE_HE_TB:
-	case MT_PHY_TYPE_HE_MU:
-		if (rate.mcs > 11)
-			goto out;
-
-		rate.he_gi = wcid->rate.he_gi;
-		rate.he_dcm = FIELD_GET(MT_TX_RATE_DCM, txrate);
-		rate.flags = RATE_INFO_FLAGS_HE_MCS;
-		break;
-	case MT_PHY_TYPE_EHT_SU:
-	case MT_PHY_TYPE_EHT_TRIG:
-	case MT_PHY_TYPE_EHT_MU:
-		if (rate.mcs > 13)
-			goto out;
-
-		rate.eht_gi = wcid->rate.eht_gi;
-		rate.flags = RATE_INFO_FLAGS_EHT_MCS;
 		break;
 	default:
-		goto out;
+		dev_err(mdev->dev, "Unknown TXS format: %hhu\n", fmt);
+		goto unlock;
 	}
 
-	stats->tx_mode[mode]++;
+	txrate = FIELD_GET(MT_TXS0_TX_RATE, txs);
+	bw = FIELD_GET(MT_TXS0_BW, txs);
 
-	switch (FIELD_GET(MT_TXS0_BW, txs)) {
-	case IEEE80211_STA_RX_BW_320:
-		rate.bw = RATE_INFO_BW_320;
-		stats->tx_bw[4]++;
-		break;
-	case IEEE80211_STA_RX_BW_160:
-		rate.bw = RATE_INFO_BW_160;
-		stats->tx_bw[3]++;
-		break;
-	case IEEE80211_STA_RX_BW_80:
-		rate.bw = RATE_INFO_BW_80;
-		stats->tx_bw[2]++;
-		break;
-	case IEEE80211_STA_RX_BW_40:
-		rate.bw = RATE_INFO_BW_40;
-		stats->tx_bw[1]++;
-		break;
-	default:
-		rate.bw = RATE_INFO_BW_20;
-		stats->tx_bw[0]++;
-		break;
-	}
-	wcid->rate = rate;
+	mode = FIELD_GET(MT_TX_RATE_MODE, txrate);
+	mcs = FIELD_GET(MT_TX_RATE_IDX, txrate);
+	nss = FIELD_GET(MT_TX_RATE_NSS, txrate) + 1;
+	if (le32_get_bits(txs_data[3], MT_TXS3_RATE_STBC) && nss > 1)
+		nss >>= 1;
+
+	if (nss - 1 < ARRAY_SIZE(stats->tx_nss))
+		stats->tx_nss[nss - 1]++;
+	if (mcs < ARRAY_SIZE(stats->tx_mcs))
+		stats->tx_mcs[mcs]++;
+	if (mode < ARRAY_SIZE(stats->tx_mode))
+		stats->tx_mode[mode]++;
+	if (bw < ARRAY_SIZE(stats->tx_bw))
+		stats->tx_bw[bw]++;
 
-out:
 	if (skb)
 		mt76_tx_status_skb_done(mdev, skb, &list);
+unlock:
 	mt76_tx_status_unlock(mdev, &list);
 
 	return !!skb;
@@ -1588,13 +1387,13 @@ out:
 
 static void mt7996_mac_add_txs(struct mt7996_dev *dev, void *data)
 {
-	struct mt7996_sta_link *msta_link;
-	struct mt76_wcid *wcid;
+	struct mt76_wcid *wcid, *link_wcid;
 	__le32 *txs_data = data;
 	u16 wcidx;
-	u8 pid;
+	u8 band, pid;
 
 	wcidx = le32_get_bits(txs_data[2], MT_TXS2_WCID);
+	band = le32_get_bits(txs_data[2], MT_TXS2_BAND);
 	pid = le32_get_bits(txs_data[3], MT_TXS3_PID);
 
 	if (pid < MT_PACKET_ID_NO_SKB)
@@ -1606,14 +1405,16 @@ static void mt7996_mac_add_txs(struct mt7996_dev *dev, void *data)
 	if (!wcid)
 		goto out;
 
-	mt7996_mac_add_txs_skb(dev, wcid, pid, txs_data);
-
-	if (!wcid->sta)
+	link_wcid = mt7996_rx_get_wcid(dev, wcidx, band);
+	if (!link_wcid)
 		goto out;
 
-	msta_link = container_of(wcid, struct mt7996_sta_link, wcid);
-	mt76_wcid_add_poll(&dev->mt76, &msta_link->wcid);
+	mt7996_mac_add_txs_skb(dev, wcid, link_wcid, pid, txs_data);
 
+	if (!link_wcid->sta)
+		goto out;
+
+	mt76_wcid_add_poll(&dev->mt76, link_wcid);
 out:
 	rcu_read_unlock();
 }
@@ -2928,33 +2729,80 @@ void mt7996_mac_sta_rc_work(struct work_struct *work)
 	mutex_unlock(&dev->mt76.mutex);
 }
 
+static int mt7996_mac_sta_poll(struct mt76_dev *dev)
+{
+	u16 sta_list[PER_STA_INFO_MAX_NUM];
+	struct mt7996_sta_link *msta_link;
+	int i, ret;
+
+	spin_lock_bh(&dev->sta_poll_lock);
+	for (i = 0; i < PER_STA_INFO_MAX_NUM; ++i) {
+		if (list_empty(&dev->sta_poll_list))
+			break;
+
+		msta_link = list_first_entry(&dev->sta_poll_list,
+					 struct mt7996_sta_link,
+					 wcid.poll_list);
+		list_del_init(&msta_link->wcid.poll_list);
+		sta_list[i] = msta_link->wcid.idx;
+	}
+	spin_unlock_bh(&dev->sta_poll_lock);
+
+	if (i == 0)
+		return 0;
+
+	ret = mt7996_mcu_get_per_sta_info(dev, UNI_PER_STA_RSSI, i, sta_list);
+	if (ret)
+		return ret;
+
+	ret = mt7996_mcu_get_per_sta_info(dev, UNI_PER_STA_SNR, i, sta_list);
+	if (ret)
+		return ret;
+
+	return mt7996_mcu_get_per_sta_info(dev, UNI_PER_STA_PKT_CNT, i, sta_list);
+}
+
 void mt7996_mac_work(struct work_struct *work)
 {
 	struct mt7996_phy *phy;
 	struct mt76_phy *mphy;
+	struct mt76_dev *mdev;
 
 	mphy = (struct mt76_phy *)container_of(work, struct mt76_phy,
 					       mac_work.work);
 	phy = mphy->priv;
+	mdev = mphy->dev;
 
-	mutex_lock(&mphy->dev->mutex);
+	mutex_lock(&mdev->mutex);
 
 	mt76_update_survey(mphy);
-	if (++mphy->mac_work_count == 5) {
-		mphy->mac_work_count = 0;
+	if (++mphy->mac_work_count % 5 == 0) {
+		int i;
 
 		mt7996_mac_update_stats(phy);
 
-		mt7996_mcu_get_all_sta_info(phy, UNI_ALL_STA_TXRX_RATE);
-		if (mtk_wed_device_active(&phy->dev->mt76.mmio.wed)) {
-			mt7996_mcu_get_all_sta_info(phy, UNI_ALL_STA_TXRX_ADM_STAT);
-			mt7996_mcu_get_all_sta_info(phy, UNI_ALL_STA_TXRX_MSDU_COUNT);
+		/* Update DEV-wise information only in
+		 * the MAC work of the first band running.
+		 */
+		for (i = MT_BAND0; i <= mphy->band_idx; ++i) {
+			if (i == mphy->band_idx) {
+				mt7996_mcu_get_all_sta_info(mdev, UNI_ALL_STA_TXRX_RATE);
+				mt7996_mcu_get_all_sta_info(mdev, UNI_ALL_STA_TXRX_AIR_TIME);
+				mt7996_mac_sta_poll(mdev);
+				mt7996_mcu_get_all_sta_info(mdev, UNI_ALL_STA_TXRX_ADM_STAT);
+				mt7996_mcu_get_all_sta_info(mdev, UNI_ALL_STA_TXRX_MSDU_COUNT);
+				mt7996_mcu_get_all_sta_info(mdev, UNI_ALL_STA_RX_MPDU_COUNT);
+				mt7996_mcu_get_all_sta_info(mdev, UNI_ALL_STA_TX_STAT);
+				mt7996_mcu_get_all_sta_info(mdev, UNI_ALL_STA_DATA_TX_RETRY_COUNT);
+			} else if (mt7996_band_valid(phy->dev, i) &&
+			           test_bit(MT76_STATE_RUNNING, &mdev->phys[i]->state))
+				break;
 		}
 	}
 
-	mutex_unlock(&mphy->dev->mutex);
+	mutex_unlock(&mdev->mutex);
 
-	mt76_tx_status_check(mphy->dev, false);
+	mt76_tx_status_check(mdev, false);
 
 	ieee80211_queue_delayed_work(mphy->hw, &mphy->mac_work,
 				     MT7996_WATCHDOG_TIME);
diff --git a/mt7996/main.c b/mt7996/main.c
index 9f5b407af..b9b280d30 100644
--- a/mt7996/main.c
+++ b/mt7996/main.c
@@ -1010,15 +1010,13 @@ mt7996_mac_sta_init_link(struct mt7996_dev *dev,
 	struct mt7996_sta *msta = (struct mt7996_sta *)sta->drv_priv;
 	struct mt7996_phy *phy = link->phy;
 	struct mt7996_sta_link *msta_link;
-	int idx;
+	int idx, i;
 
 	idx = mt76_wcid_alloc(dev->mt76.wcid_mask, MT7996_WTBL_STA);
 	if (idx < 0)
 		return -ENOSPC;
 
 	if (msta->deflink_id == IEEE80211_LINK_UNSPECIFIED) {
-		int i;
-
 		msta_link = &msta->deflink;
 		msta->deflink_id = link_id;
 		msta->seclink_id = msta->deflink_id;
@@ -1054,6 +1052,9 @@ mt7996_mac_sta_init_link(struct mt7996_dev *dev,
 
 	ewma_avg_signal_init(&msta_link->avg_ack_signal);
 	ewma_signal_init(&msta_link->wcid.rssi);
+	for (i = 0; i < IEEE80211_MAX_CHAINS; ++i)
+		ewma_avg_signal_init(msta_link->chain_signal_avg + i);
+	ewma_avg_signal_init(&msta_link->signal_avg);
 
 	rcu_assign_pointer(msta->link[link_id], msta_link);
 
@@ -1803,6 +1804,82 @@ static void mt7996_sta_statistics(struct ieee80211_hw *hw,
 	}
 }
 
+static void mt7996_link_sta_statistics(struct ieee80211_hw *hw,
+				       struct ieee80211_vif *vif,
+				       struct ieee80211_link_sta *link_sta,
+				       struct link_station_info *link_sinfo)
+{
+	struct mt7996_dev *dev = mt7996_hw_dev(hw);
+	struct mt7996_sta *msta = (struct mt7996_sta *)link_sta->sta->drv_priv;
+	struct mt7996_sta_link *msta_link;
+	struct mt7996_vif_link *mconf;
+	struct mt76_sta_stats *stats;
+	u8 link_id = link_sta->link_id;
+	int i;
+
+	mutex_lock(&dev->mt76.mutex);
+	msta_link = mt76_dereference(msta->link[link_id], &dev->mt76);
+	if (!msta_link)
+		goto out;
+	stats = &msta_link->wcid.stats;
+
+	mconf = mt7996_vif_link(dev, vif, link_id);
+	if (!mconf)
+		goto out;
+
+	link_sinfo->signal = (s8)msta_link->signal;
+	link_sinfo->filled |= BIT_ULL(NL80211_STA_INFO_SIGNAL);
+
+	link_sinfo->chains = mt7996_rx_chainmask(mconf->phy);
+	memcpy(link_sinfo->chain_signal, msta_link->chain_signal, IEEE80211_MAX_CHAINS);
+	link_sinfo->filled |= BIT_ULL(NL80211_STA_INFO_CHAIN_SIGNAL);
+
+	link_sinfo->signal_avg = -(s8)ewma_avg_signal_read(&msta_link->signal_avg);
+	link_sinfo->filled |= BIT_ULL(NL80211_STA_INFO_SIGNAL_AVG);
+
+	for (i = 0; i < IEEE80211_MAX_CHAINS; ++i)
+		link_sinfo->chain_signal_avg[i] = -(s8)ewma_avg_signal_read(msta_link->chain_signal_avg + i);
+	link_sinfo->filled |= BIT_ULL(NL80211_STA_INFO_CHAIN_SIGNAL_AVG);
+
+	link_sinfo->ack_signal = (s8)msta_link->ack_signal;
+	link_sinfo->filled |= BIT_ULL(NL80211_STA_INFO_ACK_SIGNAL);
+
+	link_sinfo->avg_ack_signal = -(s8)ewma_avg_signal_read(&msta_link->avg_ack_signal);
+	link_sinfo->filled |= BIT_ULL(NL80211_STA_INFO_ACK_SIGNAL_AVG);
+
+	link_sinfo->txrate = msta_link->wcid.rate;
+	link_sinfo->filled |= BIT_ULL(NL80211_STA_INFO_TX_BITRATE);
+
+	link_sinfo->rxrate = msta_link->wcid.rx_rate;
+	link_sinfo->filled |= BIT_ULL(NL80211_STA_INFO_RX_BITRATE);
+
+	link_sinfo->tx_bytes = stats->tx_bytes;
+	link_sinfo->filled |= BIT_ULL(NL80211_STA_INFO_TX_BYTES64);
+
+	link_sinfo->rx_bytes = stats->rx_bytes;
+	link_sinfo->filled |= BIT_ULL(NL80211_STA_INFO_RX_BYTES64);
+
+	link_sinfo->tx_failed = stats->tx_failed;
+	link_sinfo->filled |= BIT_ULL(NL80211_STA_INFO_TX_FAILED);
+
+	link_sinfo->tx_retries = stats->tx_retries;
+	link_sinfo->filled |= BIT_ULL(NL80211_STA_INFO_TX_RETRIES);
+
+	link_sinfo->rx_mpdu_count = stats->rx_mpdus;
+	link_sinfo->filled |= BIT_ULL(NL80211_STA_INFO_RX_MPDUS);
+
+	link_sinfo->fcs_err_count = stats->rx_fcs_err;
+	link_sinfo->filled |= BIT_ULL(NL80211_STA_INFO_FCS_ERROR_COUNT);
+
+	link_sinfo->tx_duration = stats->tx_airtime;
+	link_sinfo->filled |= BIT_ULL(NL80211_STA_INFO_TX_DURATION);
+
+	link_sinfo->rx_duration = stats->rx_airtime;
+	link_sinfo->filled |= BIT_ULL(NL80211_STA_INFO_RX_DURATION);
+out:
+	mutex_unlock(&dev->mt76.mutex);
+}
+
 static void mt7996_link_rate_ctrl_update(void *data,
 					 struct mt7996_sta_link *msta_link)
 {
@@ -2430,6 +2507,7 @@ const struct ieee80211_ops mt7996_ops = {
 	.set_bitrate_mask = mt7996_set_bitrate_mask,
 	.set_coverage_class = mt7996_set_coverage_class,
 	.sta_statistics = mt7996_sta_statistics,
+	.link_sta_statistics = mt7996_link_sta_statistics,
 	.sta_set_4addr = mt7996_sta_set_4addr,
 	.sta_set_decap_offload = mt7996_sta_set_decap_offload,
 	.add_twt_setup = mt7996_mac_add_twt_setup,
diff --git a/mt7996/mcu.c b/mt7996/mcu.c
index 225c291e2..7f0394356 100644
--- a/mt7996/mcu.c
+++ b/mt7996/mcu.c
@@ -593,42 +593,191 @@ out:
 }
 
 static int
-mt7996_mcu_update_tx_gi(struct rate_info *rate, struct all_sta_trx_rate *mcu_rate)
+mt7996_mcu_update_rate(struct rate_info *rate, struct ieee80211_supported_band *sband,
+		       u8 mode, u8 bw, u8 mcs, u8 nss, u8 stbc, u8 gi)
 {
-	switch (mcu_rate->tx_mode) {
+	struct rate_info tmp_rate = {};
+
+	tmp_rate.mcs = mcs;
+	tmp_rate.nss = (stbc && nss > 1) ? nss / 2 : nss;
+
+	switch (mode) {
 	case MT_PHY_TYPE_CCK:
 	case MT_PHY_TYPE_OFDM:
+		if (mcs >= sband->n_bitrates)
+			return -EINVAL;
+
+		tmp_rate.legacy = sband->bitrates[mcs].bitrate;
 		break;
 	case MT_PHY_TYPE_HT:
 	case MT_PHY_TYPE_HT_GF:
+		if (mcs > 31)
+			return -EINVAL;
+
+		tmp_rate.flags |= RATE_INFO_FLAGS_MCS;
+		if (gi)
+			tmp_rate.flags |= RATE_INFO_FLAGS_SHORT_GI;
+		break;
 	case MT_PHY_TYPE_VHT:
-		if (mcu_rate->tx_gi)
-			rate->flags |= RATE_INFO_FLAGS_SHORT_GI;
-		else
-			rate->flags &= ~RATE_INFO_FLAGS_SHORT_GI;
+		if (mcs > 9)
+			return -EINVAL;
+
+		tmp_rate.flags |= RATE_INFO_FLAGS_VHT_MCS;
+		if (gi)
+			tmp_rate.flags |= RATE_INFO_FLAGS_SHORT_GI;
+		break;
+	case MT_PHY_TYPE_PLR:
 		break;
 	case MT_PHY_TYPE_HE_SU:
 	case MT_PHY_TYPE_HE_EXT_SU:
 	case MT_PHY_TYPE_HE_TB:
 	case MT_PHY_TYPE_HE_MU:
-		if (mcu_rate->tx_gi > NL80211_RATE_INFO_HE_GI_3_2)
+		tmp_rate.mcs = mcs & GENMASK(3, 0);
+		if (tmp_rate.mcs > 13 || gi > NL80211_RATE_INFO_HE_GI_3_2)
 			return -EINVAL;
-		rate->he_gi = mcu_rate->tx_gi;
+
+		tmp_rate.flags |= RATE_INFO_FLAGS_HE_MCS;
+		tmp_rate.he_gi = gi;
+		tmp_rate.he_dcm = mcs & MT_PRXV_TX_DCM;
 		break;
 	case MT_PHY_TYPE_EHT_SU:
 	case MT_PHY_TYPE_EHT_TRIG:
 	case MT_PHY_TYPE_EHT_MU:
-		if (mcu_rate->tx_gi > NL80211_RATE_INFO_EHT_GI_3_2)
+		tmp_rate.mcs = mcs & GENMASK(3, 0);
+		if (tmp_rate.mcs > 15 || gi > NL80211_RATE_INFO_EHT_GI_3_2)
 			return -EINVAL;
-		rate->eht_gi = mcu_rate->tx_gi;
+
+		tmp_rate.flags |= RATE_INFO_FLAGS_EHT_MCS;
+		tmp_rate.eht_gi = gi;
 		break;
+	case MT_PHY_TYPE_UNKNOWN:
+		return 0;
 	default:
 		return -EINVAL;
 	}
 
+	switch (bw) {
+	case IEEE80211_STA_RX_BW_20:
+		tmp_rate.bw = RATE_INFO_BW_20;
+		break;
+	case IEEE80211_STA_RX_BW_40:
+		tmp_rate.bw = RATE_INFO_BW_40;
+		break;
+	case IEEE80211_STA_RX_BW_80:
+		tmp_rate.bw = RATE_INFO_BW_80;
+		break;
+	case IEEE80211_STA_RX_BW_160:
+		tmp_rate.bw = RATE_INFO_BW_160;
+		break;
+	case IEEE80211_STA_RX_BW_320:
+		tmp_rate.bw = RATE_INFO_BW_320;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	if (mode == MT_PHY_TYPE_HE_EXT_SU && mcs & MT_PRXV_TX_ER_SU_106T) {
+		tmp_rate.bw = RATE_INFO_BW_HE_RU;
+		tmp_rate.he_ru_alloc = NL80211_RATE_INFO_HE_RU_ALLOC_106;
+	}
+	*rate = tmp_rate;
+
 	return 0;
 }
 
+static int
+mt7996_mcu_update_trx_rates(struct mt7996_dev *dev, struct mt76_wcid *wcid,
+			    struct all_sta_trx_rate *mcu_rate)
+{
+	struct mt76_phy *phy = mt76_dev_phy(&dev->mt76, wcid->phy_idx);
+	struct ieee80211_supported_band *sband = NULL;
+	bool cck;
+	int ret;
+
+	/* TX rate */
+	cck = false;
+
+	switch (mcu_rate->tx_mode) {
+	case MT_PHY_TYPE_CCK:
+		cck = true;
+		fallthrough;
+	case MT_PHY_TYPE_OFDM:
+		if (phy->chandef.chan->band == NL80211_BAND_2GHZ) {
+			sband = &phy->sband_2g.sband;
+			if (!cck)
+				mcu_rate->tx_mcs += 4;
+		} else if (phy->chandef.chan->band == NL80211_BAND_5GHZ)
+			sband = &phy->sband_5g.sband;
+		else
+			sband = &phy->sband_6g.sband;
+		break;
+	case MT_PHY_TYPE_HT:
+	case MT_PHY_TYPE_HT_GF:
+		mcu_rate->tx_mcs += ((mcu_rate->tx_nss - 1) << 3);
+		break;
+	default:
+		break;
+	}
+
+	ret = mt7996_mcu_update_rate(&wcid->rate, sband, mcu_rate->tx_mode,
+				     mcu_rate->tx_bw, mcu_rate->tx_mcs,
+				     mcu_rate->tx_nss, mcu_rate->tx_stbc,
+				     mcu_rate->tx_gi);
+	if (ret)
+		return ret;
+
+	/* RX rate */
+	cck = false;
+
+	switch (mcu_rate->rx_mode) {
+	case MT_PHY_TYPE_CCK:
+		cck = true;
+		fallthrough;
+	case MT_PHY_TYPE_OFDM:
+		if (phy->chandef.chan->band == NL80211_BAND_2GHZ)
+			sband = &phy->sband_2g.sband;
+		else if (phy->chandef.chan->band == NL80211_BAND_5GHZ)
+			sband = &phy->sband_5g.sband;
+		else
+			sband = &phy->sband_6g.sband;
+
+		mcu_rate->rx_rate = mt76_get_rate(&dev->mt76, sband, mcu_rate->rx_rate, cck);
+		break;
+	default:
+		break;
+	}
+
+	ret = mt7996_mcu_update_rate(&wcid->rx_rate, sband, mcu_rate->rx_mode,
+				     mcu_rate->rx_bw, mcu_rate->rx_rate,
+				     mcu_rate->rx_nsts + 1, mcu_rate->rx_stbc,
+				     mcu_rate->rx_gi);
+	return ret;
+}
+
+static inline void __mt7996_stat_to_netdev(struct mt76_phy *mphy,
+					   struct mt76_wcid *wcid,
+					   u32 tx_bytes, u32 rx_bytes,
+					   u32 tx_packets, u32 rx_packets)
+{
+	struct mt7996_sta_link *msta_link;
+	struct ieee80211_vif *vif;
+	struct wireless_dev *wdev;
+
+	if (wiphy_ext_feature_isset(mphy->hw->wiphy,
+				    NL80211_EXT_FEATURE_STAS_COUNT)) {
+		msta_link = container_of(wcid, struct mt7996_sta_link, wcid);
+		vif = container_of((void *)msta_link->sta->vif, struct ieee80211_vif,
+				   drv_priv);
+		wdev = ieee80211_vif_to_wdev(vif);
+
+		if (vif->type == NL80211_IFTYPE_MONITOR)
+			return;
+
+		dev_sw_netstats_tx_add(wdev->netdev, tx_packets, tx_bytes);
+		__dev_sw_netstats_rx_add(wdev->netdev, rx_packets, rx_bytes);
+	}
+}
+
 static void
 mt7996_mcu_rx_all_sta_info_event(struct mt7996_dev *dev, struct sk_buff *skb)
 {
@@ -641,8 +790,13 @@ mt7996_mcu_rx_all_sta_info_event(struct mt7996_dev *dev, struct sk_buff *skb)
 
 	for (i = 0; i < le16_to_cpu(res->sta_num); i++) {
 		u8 ac;
+		bool v1;
 		u16 wlan_idx;
 		struct mt76_wcid *wcid;
+		struct mt76_phy *mphy;
+		struct ieee80211_sta *sta;
+		u32 tx_bytes, rx_bytes, tx_bytes_failed = 0, tx_airtime, rx_airtime,
+		    tx_packets, rx_packets;
 
 		switch (le16_to_cpu(res->tag)) {
 		case UNI_ALL_STA_TXRX_RATE:
@@ -652,21 +806,45 @@ mt7996_mcu_rx_all_sta_info_event(struct mt7996_dev *dev, struct sk_buff *skb)
 			if (!wcid)
 				break;
 
-			if (mt7996_mcu_update_tx_gi(&wcid->rate, &res->rate[i]))
-				dev_err(dev->mt76.dev, "Failed to update TX GI\n");
+			if (mt7996_mcu_update_trx_rates(dev, wcid, &res->rate[i]))
+				dev_err(dev->mt76.dev, "Failed to update TX/RX rates.\n");
 			break;
 		case UNI_ALL_STA_TXRX_ADM_STAT:
-			wlan_idx = le16_to_cpu(res->adm_stat[i].wlan_idx);
+			v1 = le16_to_cpu(res->len) == UNI_EVENT_SIZE_ADM_STAT_V1;
+			if (v1)
+				wlan_idx = le16_to_cpu(res->adm_stat_v1[i].wlan_idx);
+			else
+				wlan_idx = le16_to_cpu(res->adm_stat_v2[i].wlan_idx);
 			wcid = mt76_wcid_ptr(dev, wlan_idx);
 
 			if (!wcid)
 				break;
 
-			for (ac = 0; ac < IEEE80211_NUM_ACS; ac++) {
-				wcid->stats.tx_bytes +=
-					le32_to_cpu(res->adm_stat[i].tx_bytes[ac]);
-				wcid->stats.rx_bytes +=
-					le32_to_cpu(res->adm_stat[i].rx_bytes[ac]);
+			mphy = mt76_dev_phy(&dev->mt76, wcid->phy_idx);
+			for (ac = IEEE80211_AC_VO; ac < IEEE80211_NUM_ACS; ac++) {
+				u8 lmac_ac = mt76_connac_lmac_mapping(ac);
+				if (v1) {
+					tx_bytes = le32_to_cpu(res->adm_stat_v1[i].tx_bytes[lmac_ac]);
+					rx_bytes = le32_to_cpu(res->adm_stat_v1[i].rx_bytes[lmac_ac]);
+				} else {
+					tx_bytes = le32_to_cpu(res->adm_stat_v2[i].tx_bytes[lmac_ac]);
+					rx_bytes = le32_to_cpu(res->adm_stat_v2[i].rx_bytes[lmac_ac]);
+					tx_bytes_failed = le32_to_cpu(res->adm_stat_v2[i].tx_bytes_failed[lmac_ac]);
+				}
+
+				wcid->stats.tx_bytes_per_ac[ac] += tx_bytes;
+				wcid->stats.rx_bytes_per_ac[ac] += rx_bytes;
+				wcid->stats.tx_bytes_failed_per_ac[ac] += tx_bytes_failed;
+
+				wcid->stats.tx_bytes += tx_bytes;
+				wcid->stats.rx_bytes += rx_bytes;
+				wcid->stats.tx_bytes_failed += tx_bytes_failed;
+
+				__mt7996_stat_to_netdev(mphy, wcid,
+							tx_bytes, rx_bytes, 0, 0);
+
+				ieee80211_tpt_led_trig_tx(mphy->hw, tx_bytes);
+				ieee80211_tpt_led_trig_rx(mphy->hw, rx_bytes);
 			}
 			break;
 		case UNI_ALL_STA_TXRX_MSDU_COUNT:
@@ -676,10 +854,62 @@ mt7996_mcu_rx_all_sta_info_event(struct mt7996_dev *dev, struct sk_buff *skb)
 			if (!wcid)
 				break;
 
-			wcid->stats.tx_packets +=
-				le32_to_cpu(res->msdu_cnt[i].tx_msdu_cnt);
-			wcid->stats.rx_packets +=
-				le32_to_cpu(res->msdu_cnt[i].rx_msdu_cnt);
+			mphy = mt76_dev_phy(&dev->mt76, wcid->phy_idx);
+
+			tx_packets = le32_to_cpu(res->msdu_cnt[i].tx_msdu_cnt);
+			rx_packets = le32_to_cpu(res->msdu_cnt[i].rx_msdu_cnt);
+
+			wcid->stats.tx_packets += tx_packets;
+			wcid->stats.rx_packets += rx_packets;
+
+			__mt7996_stat_to_netdev(mphy, wcid, 0, 0,
+						tx_packets, rx_packets);
+			break;
+		case UNI_ALL_STA_TXRX_AIR_TIME:
+			wlan_idx = le16_to_cpu(res->airtime[i].wlan_idx);
+			wcid = rcu_dereference(dev->mt76.wcid[wlan_idx]);
+			sta = wcid_to_sta(wcid);
+			if (!sta)
+				continue;
+
+			for (ac = IEEE80211_AC_VO; ac < IEEE80211_NUM_ACS; ++ac) {
+				u8 lmac_ac = mt76_connac_lmac_mapping(ac);
+				tx_airtime = le32_to_cpu(res->airtime[i].tx[lmac_ac]);
+				rx_airtime = le32_to_cpu(res->airtime[i].rx[lmac_ac]);
+
+				wcid->stats.tx_airtime += tx_airtime;
+				wcid->stats.rx_airtime += rx_airtime;
+				ieee80211_sta_register_airtime(sta, mt76_ac_to_tid(ac),
+				                               tx_airtime, rx_airtime);
+			}
+			break;
+		case UNI_ALL_STA_RX_MPDU_COUNT:
+			wlan_idx = le16_to_cpu(res->rx_mpdu_cnt[i].wlan_idx);
+			wcid = rcu_dereference(dev->mt76.wcid[wlan_idx]);
+			if (!wcid)
+				break;
+
+			wcid->stats.rx_mpdus += le32_to_cpu(res->rx_mpdu_cnt[i].total);
+			wcid->stats.rx_fcs_err += le32_to_cpu(res->rx_mpdu_cnt[i].total) -
+						  le32_to_cpu(res->rx_mpdu_cnt[i].success);
+			break;
+		case UNI_ALL_STA_TX_STAT:
+			wlan_idx = le16_to_cpu(res->tx_mpdu_stat[i].wlan_idx);
+			wcid = rcu_dereference(dev->mt76.wcid[wlan_idx]);
+			if (!wcid)
+				break;
+
+			wcid->stats.tx_mpdus += le32_to_cpu(res->tx_mpdu_stat[i].total);
+			wcid->stats.tx_failed += le32_to_cpu(res->tx_mpdu_stat[i].fails);
+			break;
+		/* Multiple retries of a single MPDU only increase the counter by 1 */
+		case UNI_ALL_STA_DATA_TX_RETRY_COUNT:
+			wlan_idx = le16_to_cpu(res->tx_mpdu_retry_cnt[i].wlan_idx);
+			wcid = rcu_dereference(dev->mt76.wcid[wlan_idx]);
+			if (!wcid)
+				break;
+
+			wcid->stats.tx_retries += le16_to_cpu(res->tx_mpdu_retry_cnt[i].val);
 			break;
 		default:
 			break;
@@ -4994,9 +5224,124 @@ int mt7996_mcu_set_rro(struct mt7996_dev *dev, u16 tag, u16 val)
 				 sizeof(req), true);
 }
 
-int mt7996_mcu_get_all_sta_info(struct mt7996_phy *phy, u16 tag)
+int mt7996_mcu_get_per_sta_info(struct mt76_dev *dev, u16 tag,
+				u16 sta_num, u16 *sta_list)
+{
+	struct mt7996_mcu_per_sta_info_event *res;
+	struct mt7996_sta_link *msta_link;
+	struct mt76_wcid *wcid;
+	struct sk_buff *skb;
+	int i, j, ret;
+	u16 wlan_idx;
+	struct {
+		u8 __rsv1;
+		u8 unsolicit;
+		u8 __rsv2[2];
+
+		__le16 tag;
+		__le16 len;
+		__le16 sta_num;
+		u8 __rsv3[2];
+		__le16 sta_list[PER_STA_INFO_MAX_NUM];
+	} __packed req = {
+		.unsolicit = 0,
+		.tag = cpu_to_le16(tag),
+		.len = cpu_to_le16(sizeof(req) - 4),
+		.sta_num = cpu_to_le16(sta_num)
+	};
+
+	if (sta_num > PER_STA_INFO_MAX_NUM)
+		return -EINVAL;
+
+	for (i = 0; i < sta_num; ++i)
+		req.sta_list[i] = cpu_to_le16(sta_list[i]);
+
+	ret = mt76_mcu_send_and_get_msg(dev, MCU_WM_UNI_CMD(PER_STA_INFO),
+	                                &req, sizeof(req), true, &skb);
+	if (ret)
+		return ret;
+
+	res = (struct mt7996_mcu_per_sta_info_event *)skb->data;
+	if (le16_to_cpu(res->tag) != tag) {
+		ret = -EINVAL;
+		goto out;
+	}
+
+	rcu_read_lock();
+	switch (tag) {
+	case UNI_PER_STA_RSSI:
+		for (i = 0; i < sta_num; ++i) {
+			struct per_sta_rssi *rssi = &res->rssi[i];
+			struct mt76_phy *mphy;
+			struct mt7996_phy *phy;
+			u8 *rcpi = rssi->rcpi;
+			u16 rx_mask;
+
+			wlan_idx = le16_to_cpu(rssi->wlan_idx);
+			wcid = rcu_dereference(dev->wcid[wlan_idx]);
+			msta_link = container_of(wcid, struct mt7996_sta_link, wcid);
+			if (!msta_link)
+				continue;
+
+			mphy = dev->phys[wcid->phy_idx];
+			phy = mphy->priv;
+			rx_mask = mt7996_rx_chainmask(phy);
+
+			for (j = 0; j < ARRAY_SIZE(rssi->rcpi); ++j)
+				msta_link->chain_ack_signal[j] = to_rssi(MT_PRXV_RCPI0, rcpi[j]);
+			if (rx_mask & BIT(4)) {
+				msta_link->chain_signal_wf4 = to_rssi(MT_PRXV_RCPI0,
+								      rssi->rcpi_wf4);
+				msta_link->chain_ack_signal[4] = msta_link->chain_signal_wf4;
+			}
+
+			msta_link->ack_signal = mt76_rx_signal(rx_mask,
+							       msta_link->chain_ack_signal);
+			ewma_avg_signal_add(&msta_link->avg_ack_signal, -msta_link->ack_signal);
+		}
+		break;
+	case UNI_PER_STA_SNR:
+		for (i = 0; i < sta_num; ++i) {
+			wlan_idx = le16_to_cpu(res->snr[i].wlan_idx);
+			wcid = rcu_dereference(dev->wcid[wlan_idx]);
+			msta_link = container_of(wcid, struct mt7996_sta_link, wcid);
+			if (msta_link)
+				memcpy(msta_link->chain_ack_snr, res->snr[i].val,
+				       sizeof(res->snr[i].val));
+		}
+		break;
+	case UNI_PER_STA_PKT_CNT:
+		for (i = 0; i < sta_num; ++i) {
+			wlan_idx = le16_to_cpu(res->msdu_cnt[i].wlan_idx);
+			wcid = rcu_dereference(dev->wcid[wlan_idx]);
+			if (wcid) {
+				u32 retries = le32_to_cpu(res->msdu_cnt[i].tx_retries),
+				    drops = le32_to_cpu(res->msdu_cnt[i].tx_drops);
+
+				/* Retry counter is increased by 1 when an MSDU is
+				 * successfully transmitted after one or more retries
+				 */
+				wcid->stats.tx_packets_retried += retries;
+
+				/* Drop counter is increased by 1 when an MSDU is
+				 * dropped due to retry limit or exceeded TXOP
+				 */
+				wcid->stats.tx_packets_failed += drops;
+			}
+		}
+		break;
+	default:
+		ret = -EINVAL;
+		dev_err(dev->dev, "Unknown UNI_PER_STA_INFO_TAG: %d\n", tag);
+	}
+	rcu_read_unlock();
+out:
+	dev_kfree_skb(skb);
+	return ret;
+}
+
+int mt7996_mcu_get_all_sta_info(struct mt76_dev *dev, u16 tag)
 {
-	struct mt7996_dev *dev = phy->dev;
 	struct {
 		u8 _rsv[4];
 
@@ -5007,7 +5352,7 @@ int mt7996_mcu_get_all_sta_info(struct mt7996_phy *phy, u16 tag)
 		.len = cpu_to_le16(sizeof(req) - 4),
 	};
 
-	return mt76_mcu_send_msg(&dev->mt76, MCU_WM_UNI_CMD(ALL_STA_INFO),
+	return mt76_mcu_send_msg(dev, MCU_WM_UNI_CMD(ALL_STA_INFO),
 				 &req, sizeof(req), false);
 }
 
diff --git a/mt7996/mcu.h b/mt7996/mcu.h
index e59b0b050..55242bb09 100644
--- a/mt7996/mcu.h
+++ b/mt7996/mcu.h
@@ -173,6 +173,39 @@ struct mt7996_mcu_mib {
 	__le64 data;
 } __packed;
 
+struct per_sta_rssi {
+	__le16 wlan_idx;
+	u8 rcpi_wf4;
+	u8 __rsv;
+	u8 rcpi[4];
+} __packed;
+
+struct per_sta_snr {
+	__le16 wlan_idx;
+	u8 __rsv[2];
+	s8 val[4];
+} __packed;
+
+struct per_sta_msdu_cnt {
+	__le16 wlan_idx;
+	u8 __rsv[2];
+	__le32 tx_drops;
+	__le32 tx_retries;
+} __packed;
+
+struct mt7996_mcu_per_sta_info_event {
+	u8 __rsv[4];
+
+	__le16 tag;
+	__le16 len;
+
+	union {
+		struct per_sta_rssi rssi[0];
+		struct per_sta_snr snr[0];
+		struct per_sta_msdu_cnt msdu_cnt[0];
+	};
+} __packed;
+
 struct all_sta_trx_rate {
 	__le16 wlan_idx;
 	u8 __rsv1[2];
@@ -194,6 +227,8 @@ struct all_sta_trx_rate {
 	u8 __rsv2;
 } __packed;
 
+#define UNI_EVENT_SIZE_ADM_STAT_V1	1452
+
 struct mt7996_mcu_all_sta_info_event {
 	u8 rsv[4];
 	__le16 tag;
@@ -210,7 +245,15 @@ struct mt7996_mcu_all_sta_info_event {
 			u8 rsv[2];
 			__le32 tx_bytes[IEEE80211_NUM_ACS];
 			__le32 rx_bytes[IEEE80211_NUM_ACS];
-		} __packed, adm_stat);
+		} __packed, adm_stat_v1);
+
+		DECLARE_FLEX_ARRAY(struct {
+			__le16 wlan_idx;
+			u8 rsv[2];
+			__le32 tx_bytes[IEEE80211_NUM_ACS];
+			__le32 rx_bytes[IEEE80211_NUM_ACS];
+			__le32 tx_bytes_failed[IEEE80211_NUM_ACS];
+		} __packed, adm_stat_v2);
 
 		DECLARE_FLEX_ARRAY(struct {
 			__le16 wlan_idx;
@@ -218,6 +261,34 @@ struct mt7996_mcu_all_sta_info_event {
 			__le32 tx_msdu_cnt;
 			__le32 rx_msdu_cnt;
 		} __packed, msdu_cnt);
+
+		DECLARE_FLEX_ARRAY(struct {
+			__le16 wlan_idx;
+			u8 rsv[2];
+			__le32 tx[IEEE80211_NUM_ACS];
+			__le32 rx[IEEE80211_NUM_ACS];
+		} __packed, airtime);
+
+		DECLARE_FLEX_ARRAY(struct {
+			__le16 wlan_idx;
+			u8 rsv[2];
+			__le32 total;
+			__le32 success;
+		} __packed, rx_mpdu_cnt);
+
+		DECLARE_FLEX_ARRAY(struct {
+			__le16 wlan_idx;
+			u8 rsv[2];
+			__le32 total;
+			__le32 fails;
+		} __packed, tx_mpdu_stat);
+
+		DECLARE_FLEX_ARRAY(struct {
+			__le16 wlan_idx;
+			u8 rsv1[2];
+			__le16 val;
+			u8 rsv2[2];
+		} __packed, tx_mpdu_retry_cnt);
 	} __packed;
 } __packed;
 
diff --git a/mt7996/mt7996.h b/mt7996/mt7996.h
index 9911185bb..3f4c0ba2c 100644
--- a/mt7996/mt7996.h
+++ b/mt7996/mt7996.h
@@ -135,6 +135,8 @@
 #define MT7996_RRO_MSDU_PG_CR_CNT	8
 #define MT7996_RRO_MSDU_PG_SIZE_PER_CR	0x10000
 
+#define to_rssi(field, rcpi)	((FIELD_GET(field, rcpi) - 220) / 2)
+
 struct mt7996_vif;
 struct mt7996_sta;
 struct mt7996_dfs_pulse;
@@ -223,11 +225,20 @@ struct mt7996_sta_link {
 	struct mt7996_sta *sta;
 
 	struct list_head rc_list;
-	u32 airtime_ac[8];
 
+	s8 chain_signal[IEEE80211_MAX_CHAINS];
+	int signal;
+	struct ewma_avg_signal chain_signal_avg[IEEE80211_MAX_CHAINS];
+	struct ewma_avg_signal signal_avg;
+
+	s8 chain_ack_signal[IEEE80211_MAX_CHAINS];
 	int ack_signal;
 	struct ewma_avg_signal avg_ack_signal;
 
+	s8 chain_signal_wf4;
+
+	s8 chain_ack_snr[IEEE80211_MAX_CHAINS];
+
 	unsigned long changed;
 
 	struct mt76_connac_sta_key_conf bip;
@@ -753,7 +764,9 @@ int mt7996_mcu_fw_dbg_ctrl(struct mt7996_dev *dev, u32 module, u8 level);
 int mt7996_mcu_trigger_assert(struct mt7996_dev *dev);
 void mt7996_mcu_rx_event(struct mt7996_dev *dev, struct sk_buff *skb);
 void mt7996_mcu_exit(struct mt7996_dev *dev);
-int mt7996_mcu_get_all_sta_info(struct mt7996_phy *phy, u16 tag);
+int mt7996_mcu_get_per_sta_info(struct mt76_dev *dev, u16 tag,
+	                        u16 sta_num, u16 *sta_list);
+int mt7996_mcu_get_all_sta_info(struct mt76_dev *dev, u16 tag);
 int mt7996_mcu_wed_rro_reset_sessions(struct mt7996_dev *dev, u16 id);
 int mt7996_mcu_set_sniffer_mode(struct mt7996_phy *phy, bool enabled);
 int mt7996_mcu_set_dup_wtbl(struct mt7996_dev *dev);
-- 
2.45.2

