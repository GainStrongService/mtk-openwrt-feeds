From ba9970c09409f42f938c41a865ce1775d095d296 Mon Sep 17 00:00:00 2001
From: Shayne Chen <shayne.chen@mediatek.com>
Date: Mon, 10 Nov 2025 15:26:25 +0800
Subject: [PATCH 042/105] mtk: mt76: mt7996: rework coredump


mtk: mt76: mt7990: add mt7990 coredump support

1. add mt7990 wm memory region.
2. fixed mt7996/mt7992 wrong wa status

Signed-off-by: Rex Lu <rex.lu@mediatek.com>
---
 mt7996/coredump.c | 335 ++++++++++++++++++++++++++++++++++++----------
 mt7996/coredump.h |  42 ++++--
 mt7996/debugfs.c  |  18 ++-
 mt7996/mac.c      |  56 ++++++--
 mt7996/mcu.c      |   5 +
 mt7996/mt7996.h   |  18 ++-
 mt7996/regs.h     |   8 ++
 7 files changed, 385 insertions(+), 97 deletions(-)

diff --git a/mt7996/coredump.c b/mt7996/coredump.c
index 5c293ae96..96572f143 100644
--- a/mt7996/coredump.c
+++ b/mt7996/coredump.c
@@ -7,11 +7,11 @@
 #include <linux/utsname.h>
 #include "coredump.h"
 
-static bool coredump_memdump;
+static bool coredump_memdump = true;
 module_param(coredump_memdump, bool, 0644);
 MODULE_PARM_DESC(coredump_memdump, "Optional ability to dump firmware memory");
 
-static const struct mt7996_mem_region mt7996_mem_regions[] = {
+static const struct mt7996_mem_region mt7996_wm_mem_regions[] = {
 	{
 		.start = 0x00800000,
 		.len = 0x0004ffff,
@@ -44,27 +44,149 @@ static const struct mt7996_mem_region mt7996_mem_regions[] = {
 	},
 };
 
+static const struct mt7996_mem_region mt7996_wa_mem_regions[] = {
+	{
+		.start = 0xE0000000,
+		.len = 0x0000ffff,
+		.name = "CRAM",
+	},
+	{
+		.start = 0xE0010000,
+		.len = 0x000117ff,
+		.name = "CRAM2",
+	},
+	{
+		.start = 0x10000000,
+		.len = 0x0001bfff,
+		.name = "ILM",
+	},
+	{
+		.start = 0x10200000,
+		.len = 0x00063fff,
+		.name = "DLM",
+	},
+};
+
+static const struct mt7996_mem_region mt7992_wm_mem_regions[] = {
+	{
+		.start = 0x00800000,
+		.len = 0x0004bfff,
+		.name = "ULM0",
+	},
+	{
+		.start = 0x00900000,
+		.len = 0x00035fff,
+		.name = "ULM1",
+	},
+	{
+		.start = 0x02200000,
+		.len = 0x0003ffff,
+		.name = "ULM2",
+	},
+	{
+		.start = 0x00400000,
+		.len = 0x00027fff,
+		.name = "SRAM",
+	},
+	{
+		.start = 0xe0000000,
+		.len = 0x0015ffff,
+		.name = "CRAM0",
+	},
+	{
+		.start = 0xe0160000,
+		.len = 0x00c7fff,
+		.name = "CRAM1",
+	},
+	{
+		.start = 0x7c050000,
+		.len = 0x00007fff,
+		.name = "CONN_INFRA",
+	},
+};
+
+static const struct mt7996_mem_region mt7990_wm_mem_regions[] = {
+	{
+		.start = 0x00800000,
+		.len = 0x0004afff,
+		.name = "ULM0",
+	},
+	{
+		.start = 0x00900000,
+		.len = 0x0003ffff,
+		.name = "ULM1",
+	},
+	{
+		.start = 0x02200000,
+		.len = 0x00045fff,
+		.name = "ULM2",
+	},
+	{
+		.start = 0x00400000,
+		.len = 0x00027fff,
+		.name = "SRAM",
+	},
+	{
+		.start = 0xe0000000,
+		.len = 0x00dffff,
+		.name = "CRAM0",
+	},
+	{
+		.start = 0xe00e0000,
+		.len = 0x00dffff,
+		.name = "CRAM1",
+	},
+	{
+		.start = 0xe01c0000,
+		.len = 0x005ffff,
+		.name = "CRAM2",
+	},
+	{
+		.start = 0x7c050000,
+		.len = 0x00007fff,
+		.name = "CONN_INFRA",
+	},
+};
+
 const struct mt7996_mem_region*
-mt7996_coredump_get_mem_layout(struct mt7996_dev *dev, u32 *num)
+mt7996_coredump_get_mem_layout(struct mt7996_dev *dev, u8 type, u32 *num)
 {
 	switch (mt76_chip(&dev->mt76)) {
 	case MT7996_DEVICE_ID:
 	case MT7996_DEVICE_ID_2:
-		*num = ARRAY_SIZE(mt7996_mem_regions);
-		return &mt7996_mem_regions[0];
+		if (type == MT7996_RAM_TYPE_WA) {
+			*num = ARRAY_SIZE(mt7996_wa_mem_regions);
+			return &mt7996_wa_mem_regions[0];
+		}
+
+		*num = ARRAY_SIZE(mt7996_wm_mem_regions);
+		return &mt7996_wm_mem_regions[0];
+	case MT7992_DEVICE_ID:
+		if (type == MT7996_RAM_TYPE_WA) {
+			/* mt7992 wa memory regions is the same as mt7996 */
+			*num = ARRAY_SIZE(mt7996_wa_mem_regions);
+			return &mt7996_wa_mem_regions[0];
+		}
+		*num = ARRAY_SIZE(mt7992_wm_mem_regions);
+		return &mt7992_wm_mem_regions[0];
+	case MT7990_DEVICE_ID:
+		if (type == MT7996_RAM_TYPE_WA)
+			return NULL;
+		*num = ARRAY_SIZE(mt7990_wm_mem_regions);
+		return &mt7990_wm_mem_regions[0];
 	default:
 		return NULL;
 	}
 }
 
-static int mt7996_coredump_get_mem_size(struct mt7996_dev *dev)
+static int mt7996_coredump_get_mem_size(struct mt7996_dev *dev, u8 type)
 {
 	const struct mt7996_mem_region *mem_region;
 	size_t size = 0;
 	u32 num;
 	int i;
 
-	mem_region = mt7996_coredump_get_mem_layout(dev, &num);
+	mem_region = mt7996_coredump_get_mem_layout(dev, type, &num);
 	if (!mem_region)
 		return 0;
 
@@ -81,14 +203,13 @@ static int mt7996_coredump_get_mem_size(struct mt7996_dev *dev)
 	return size;
 }
 
-struct mt7996_crash_data *mt7996_coredump_new(struct mt7996_dev *dev)
+struct mt7996_crash_data *mt7996_coredump_new(struct mt7996_dev *dev, u8 type)
 {
-	struct mt7996_crash_data *crash_data = dev->coredump.crash_data;
+	struct mt7996_crash_data *crash_data = dev->coredump.crash_data[type];
 
 	lockdep_assert_held(&dev->dump_mutex);
 
-	if (coredump_memdump &&
-	    !mt76_poll_msec(dev, MT_FW_DUMP_STATE, 0x3, 0x2, 500))
+	if (!coredump_memdump || !crash_data->supported)
 		return NULL;
 
 	guid_gen(&crash_data->guid);
@@ -98,12 +219,35 @@ struct mt7996_crash_data *mt7996_coredump_new(struct mt7996_dev *dev)
 }
 
 static void
-mt7996_coredump_fw_state(struct mt7996_dev *dev, struct mt7996_coredump *dump,
+mt7996_coredump_fw_state(struct mt7996_dev *dev, u8 type, struct mt7996_coredump *dump,
 			 bool *exception)
 {
-	u32 count;
+	u32 count, coredump_reg;
+
+	switch (mt76_chip(&dev->mt76)) {
+	case MT7996_DEVICE_ID:
+	case MT7996_DEVICE_ID_2:
+		if (type == MT7996_RAM_TYPE_WA)
+			coredump_reg = mt76_rr(dev, 0x7c05b080) + 4;
+		else
+			coredump_reg = 0x02209e90;
+		break;
+	case MT7992_DEVICE_ID:
+		if (type == MT7996_RAM_TYPE_WA)
+			coredump_reg = mt76_rr(dev, 0x7c056480) + 4;
+		else
+			coredump_reg = mt76_rr(dev, 0x7c0564a8) + 4;
+		break;
+	case MT7990_DEVICE_ID:
+		coredump_reg = mt76_rr(dev, 0x7c0564a8) + 4;
+		break;
+	default:
+		dev_info(dev->mt76.dev, "%s coredump not supported\n",
+			 wiphy_name(dev->mt76.hw->wiphy));
+		return;
+	}
 
-	count = mt76_rr(dev, MT_FW_ASSERT_CNT);
+	count = mt76_rr(dev, coredump_reg);
 
 	/* normal mode: driver can manually trigger assertÂ for detail info */
 	if (!count)
@@ -115,53 +259,68 @@ mt7996_coredump_fw_state(struct mt7996_dev *dev, struct mt7996_coredump *dump,
 }
 
 static void
-mt7996_coredump_fw_stack(struct mt7996_dev *dev, struct mt7996_coredump *dump,
+mt7996_coredump_fw_stack(struct mt7996_dev *dev, u8 type, struct mt7996_coredump *dump,
 			 bool exception)
 {
-	u32 oldest, i, idx;
+	u32 reg, i, offset = 0, val = MT7996_RAM_TYPE_WM;
 
-	strscpy(dump->pc_current, "program counter", sizeof(dump->pc_current));
+	if (type == MT7996_RAM_TYPE_WA) {
+		offset = is_mt7996(&dev->mt76) ?
+			 (MT_MCU_WA_EXCP_BASE - MT_MCU_WM_EXCP_BASE) : 0;
+		val = MT7996_RAM_TYPE_WA;
+	}
 
-	/* 0: WM PC log output */
-	mt76_wr(dev, MT_CONN_DBG_CTL_OUT_SEL, 0);
+	/* 0: WM PC log output, 1: WA PC log output  */
+	mt76_wr(dev, MT_CONN_DBG_CTL_OUT_SEL, val);
 	/* choose 33th PC log buffer to read current PC index */
 	mt76_wr(dev, MT_CONN_DBG_CTL_PC_LOG_SEL, 0x3f);
 
 	/* read current PC */
-	dump->pc_stack[0] = mt76_rr(dev, MT_CONN_DBG_CTL_PC_LOG);
-
-	/* stop call stack record */
-	if (!exception) {
-		mt76_clear(dev, MT_MCU_WM_EXCP_PC_CTRL, BIT(0));
-		mt76_clear(dev, MT_MCU_WM_EXCP_LR_CTRL, BIT(0));
-	}
-
-	oldest = (u32)mt76_get_field(dev, MT_MCU_WM_EXCP_PC_CTRL,
-				     GENMASK(20, 16)) + 2;
-	for (i = 0; i < 16; i++) {
-		idx = ((oldest + 2 * i + 1) % 32);
-		dump->pc_stack[i + 1] =
-			mt76_rr(dev, MT_MCU_WM_EXCP_PC_LOG + idx * 4);
-	}
-
-	oldest = (u32)mt76_get_field(dev, MT_MCU_WM_EXCP_LR_CTRL,
-				     GENMASK(20, 16)) + 2;
-	for (i = 0; i < 16; i++) {
-		idx = ((oldest + 2 * i + 1) % 32);
-		dump->lr_stack[i] =
-			mt76_rr(dev, MT_MCU_WM_EXCP_LR_LOG + idx * 4);
-	}
+	for (i = 0; i < 10; i++)
+		dump->pc_cur[i] = mt76_rr(dev, MT_CONN_DBG_CTL_PC_LOG);
+
+	/* read PC log */
+	if (is_mt7996(&dev->mt76)) {
+		dump->pc_dbg_ctrl = mt76_rr(dev, MT_MCU_WM_EXCP_PC_CTRL + offset);
+		dump->pc_cur_idx = FIELD_GET(MT_MCU_WM_EXCP_PC_CTRL_IDX_STATUS,
+					     dump->pc_dbg_ctrl);
+		for (i = 0; i < 32; i++) {
+			reg = MT_MCU_WM_EXCP_PC_LOG + i * 4 + offset;
+			dump->pc_stack[i] = mt76_rr(dev, reg);
+		}
 
-	/* start call stack record */
-	if (!exception) {
-		mt76_set(dev, MT_MCU_WM_EXCP_PC_CTRL, BIT(0));
-		mt76_set(dev, MT_MCU_WM_EXCP_LR_CTRL, BIT(0));
+		/* read LR log */
+		dump->lr_dbg_ctrl = mt76_rr(dev, MT_MCU_WM_EXCP_LR_CTRL + offset);
+		dump->lr_cur_idx = FIELD_GET(MT_MCU_WM_EXCP_LR_CTRL_IDX_STATUS,
+					     dump->lr_dbg_ctrl);
+		for (i = 0; i < 32; i++) {
+			reg = MT_MCU_WM_EXCP_LR_LOG + i * 4 + offset;
+			dump->lr_stack[i] = mt76_rr(dev, reg);
+		}
+	} else {
+		mt76_wr(dev, MT_CONN_DBG_CTL_PC_LOG_SEL, 0x20);
+		dump->pc_dbg_ctrl = mt76_rr(dev, MT_CONN_DBG_CTL_PC_LOG);
+		dump->pc_cur_idx = FIELD_GET(MT_CONN_DBG_CTL_PC_LOG_IDX_STATUS,
+					     dump->pc_dbg_ctrl);
+		for (i = 0; i < 32; i++) {
+			mt76_wr(dev, MT_CONN_DBG_CTL_PC_LOG_SEL, i);
+			dump->pc_stack[i] = mt76_rr(dev, MT_CONN_DBG_CTL_PC_LOG);
+		}
+		/* read LR log */
+		mt76_wr(dev, MT_CONN_DBG_CTL_GPR_LOG_SEL, 0x20);
+		dump->lr_dbg_ctrl = mt76_rr(dev, MT_CONN_DBG_CTL_GPR_BUS_OUT_LOG);
+		dump->lr_cur_idx = FIELD_GET(MT_CONN_DBG_CTL_GPR_BUS_OUT_IDX_STATUS,
+					     dump->lr_dbg_ctrl);
+		for (i = 0; i < 32; i++) {
+			mt76_wr(dev, MT_CONN_DBG_CTL_GPR_LOG_SEL, i);
+			dump->lr_stack[i] = mt76_rr(dev, MT_CONN_DBG_CTL_GPR_BUS_OUT_LOG);
+		}
 	}
 }
 
-static struct mt7996_coredump *mt7996_coredump_build(struct mt7996_dev *dev)
+struct mt7996_coredump *mt7996_coredump_build(struct mt7996_dev *dev, u8 type, bool full_dump)
 {
-	struct mt7996_crash_data *crash_data = dev->coredump.crash_data;
+	struct mt7996_crash_data *crash_data = dev->coredump.crash_data[type];
 	struct mt7996_coredump *dump;
 	struct mt7996_coredump_mem *dump_mem;
 	size_t len, sofar = 0, hdr_len = sizeof(*dump);
@@ -170,7 +329,7 @@ static struct mt7996_coredump *mt7996_coredump_build(struct mt7996_dev *dev)
 
 	len = hdr_len;
 
-	if (coredump_memdump && crash_data->memdump_buf_len)
+	if (full_dump && coredump_memdump && crash_data->memdump_buf_len)
 		len += sizeof(*dump_mem) + crash_data->memdump_buf_len;
 
 	sofar += hdr_len;
@@ -186,20 +345,34 @@ static struct mt7996_coredump *mt7996_coredump_build(struct mt7996_dev *dev)
 
 	dump = (struct mt7996_coredump *)(buf);
 	dump->len = len;
+	dump->hdr_len = hdr_len;
 
 	/* plain text */
 	strscpy(dump->magic, "mt76-crash-dump", sizeof(dump->magic));
 	strscpy(dump->kernel, init_utsname()->release, sizeof(dump->kernel));
+	strscpy(dump->fw_type, ((type == MT7996_RAM_TYPE_WA) ? "WA" : "WM"),
+		sizeof(dump->fw_type));
 	strscpy(dump->fw_ver, dev->mt76.hw->wiphy->fw_version,
 		sizeof(dump->fw_ver));
+	strscpy(dump->fw_patch_date, dev->patch_build_date,
+		sizeof(dump->fw_patch_date));
+	strscpy(dump->fw_ram_date[MT7996_RAM_TYPE_WM],
+		dev->ram_build_date[MT7996_RAM_TYPE_WM],
+		MT7996_BUILD_TIME_LEN);
+	strscpy(dump->fw_ram_date[MT7996_RAM_TYPE_WA],
+		dev->ram_build_date[MT7996_RAM_TYPE_WA],
+		MT7996_BUILD_TIME_LEN);
 
 	guid_copy(&dump->guid, &crash_data->guid);
 	dump->tv_sec = crash_data->timestamp.tv_sec;
 	dump->tv_nsec = crash_data->timestamp.tv_nsec;
 	dump->device_id = mt76_chip(&dev->mt76);
 
-	mt7996_coredump_fw_state(dev, dump, &exception);
-	mt7996_coredump_fw_stack(dev, dump, exception);
+	mt7996_coredump_fw_state(dev, type, dump, &exception);
+	mt7996_coredump_fw_stack(dev, type, dump, exception);
+
+	if (!full_dump)
+		goto skip_dump_mem;
 
 	/* gather memory content */
 	dump_mem = (struct mt7996_coredump_mem *)(buf + sofar);
@@ -208,22 +381,25 @@ static struct mt7996_coredump *mt7996_coredump_build(struct mt7996_dev *dev)
 		memcpy(dump_mem->data, crash_data->memdump_buf,
 		       crash_data->memdump_buf_len);
 
+skip_dump_mem:
 	mutex_unlock(&dev->dump_mutex);
 
 	return dump;
 }
 
-int mt7996_coredump_submit(struct mt7996_dev *dev)
+int mt7996_coredump_submit(struct mt7996_dev *dev, u8 type)
 {
 	struct mt7996_coredump *dump;
 
-	dump = mt7996_coredump_build(dev);
+	dump = mt7996_coredump_build(dev, type, true);
 	if (!dump) {
 		dev_warn(dev->mt76.dev, "no crash dump data found\n");
 		return -ENODATA;
 	}
 
 	dev_coredumpv(dev->mt76.dev, dump, dump->len, GFP_KERNEL);
+	dev_info(dev->mt76.dev, "%s coredump completed\n",
+		 wiphy_name(dev->mt76.hw->wiphy));
 
 	return 0;
 }
@@ -231,38 +407,51 @@ int mt7996_coredump_submit(struct mt7996_dev *dev)
 int mt7996_coredump_register(struct mt7996_dev *dev)
 {
 	struct mt7996_crash_data *crash_data;
+	int i;
+
+	for (i = 0; i < MT7996_COREDUMP_MAX; i++) {
+		crash_data = vzalloc(sizeof(*dev->coredump.crash_data[i]));
+		if (!crash_data)
+			goto nomem;
 
-	crash_data = vzalloc(sizeof(*dev->coredump.crash_data));
-	if (!crash_data)
-		return -ENOMEM;
+		dev->coredump.crash_data[i] = crash_data;
+		crash_data->supported = false;
 
-	dev->coredump.crash_data = crash_data;
+		if (coredump_memdump) {
+			crash_data->memdump_buf_len = mt7996_coredump_get_mem_size(dev, i);
+			if (!crash_data->memdump_buf_len)
+				/* no memory content */
+				continue;
 
-	if (coredump_memdump) {
-		crash_data->memdump_buf_len = mt7996_coredump_get_mem_size(dev);
-		if (!crash_data->memdump_buf_len)
-			/* no memory content */
-			return 0;
+			crash_data->memdump_buf = vzalloc(crash_data->memdump_buf_len);
+			if (!crash_data->memdump_buf)
+				goto nomem;
 
-		crash_data->memdump_buf = vzalloc(crash_data->memdump_buf_len);
-		if (!crash_data->memdump_buf) {
-			vfree(crash_data);
-			return -ENOMEM;
+			crash_data->supported = true;
 		}
 	}
 
 	return 0;
+nomem:
+	mt7996_coredump_unregister(dev);
+	return -ENOMEM;
 }
 
 void mt7996_coredump_unregister(struct mt7996_dev *dev)
 {
-	if (dev->coredump.crash_data->memdump_buf) {
-		vfree(dev->coredump.crash_data->memdump_buf);
-		dev->coredump.crash_data->memdump_buf = NULL;
-		dev->coredump.crash_data->memdump_buf_len = 0;
-	}
+	int i;
+	struct mt7996_crash_data *crash_data;
+
+	for (i = 0; i < MT7996_COREDUMP_MAX; i++) {
+		crash_data = dev->coredump.crash_data[i];
 
-	vfree(dev->coredump.crash_data);
-	dev->coredump.crash_data = NULL;
+		if (!crash_data)
+			continue;
+
+		if (crash_data->memdump_buf)
+			vfree(crash_data->memdump_buf);
+
+		vfree(crash_data);
+	}
 }
 
diff --git a/mt7996/coredump.h b/mt7996/coredump.h
index baa2f6f50..6cd6ec442 100644
--- a/mt7996/coredump.h
+++ b/mt7996/coredump.h
@@ -6,10 +6,13 @@
 
 #include "mt7996.h"
 
+#define MT7996_COREDUMP_MAX	(MT7996_RAM_TYPE_WA + 1)
+
 struct mt7996_coredump {
 	char magic[16];
 
 	u32 len;
+	u32 hdr_len;
 
 	guid_t guid;
 
@@ -21,17 +24,28 @@ struct mt7996_coredump {
 	char kernel[64];
 	/* firmware version */
 	char fw_ver[ETHTOOL_FWVERS_LEN];
+	char fw_patch_date[MT7996_BUILD_TIME_LEN];
+	char fw_ram_date[MT7996_COREDUMP_MAX][MT7996_BUILD_TIME_LEN];
 
 	u32 device_id;
 
+	/* fw type */
+	char fw_type[8];
+
 	/* exception state */
 	char fw_state[12];
 
 	/* program counters */
-	char pc_current[16];
-	u32 pc_stack[17];
-	/* link registers */
-	u32 lr_stack[16];
+	u32 pc_dbg_ctrl;
+	u32 pc_cur_idx;
+	u32 pc_cur[10];
+	/* PC registers */
+	u32 pc_stack[32];
+
+	u32 lr_dbg_ctrl;
+	u32 lr_cur_idx;
+	/* LR registers */
+	u32 lr_stack[32];
 
 	/* memory content */
 	u8 data[];
@@ -43,6 +57,7 @@ struct mt7996_coredump_mem {
 } __packed;
 
 struct mt7996_mem_hdr {
+	char name[64];
 	u32 start;
 	u32 len;
 	u8 data[];
@@ -58,27 +73,34 @@ struct mt7996_mem_region {
 #ifdef CONFIG_DEV_COREDUMP
 
 const struct mt7996_mem_region *
-mt7996_coredump_get_mem_layout(struct mt7996_dev *dev, u32 *num);
-struct mt7996_crash_data *mt7996_coredump_new(struct mt7996_dev *dev);
-int mt7996_coredump_submit(struct mt7996_dev *dev);
+mt7996_coredump_get_mem_layout(struct mt7996_dev *dev, u8 type, u32 *num);
+struct mt7996_crash_data *mt7996_coredump_new(struct mt7996_dev *dev, u8 type);
+struct mt7996_coredump *mt7996_coredump_build(struct mt7996_dev *dev, u8 type, bool full_dump);
+int mt7996_coredump_submit(struct mt7996_dev *dev, u8 type);
 int mt7996_coredump_register(struct mt7996_dev *dev);
 void mt7996_coredump_unregister(struct mt7996_dev *dev);
 
 #else /* CONFIG_DEV_COREDUMP */
 
 static inline const struct mt7996_mem_region *
-mt7996_coredump_get_mem_layout(struct mt7996_dev *dev, u32 *num)
+mt7996_coredump_get_mem_layout(struct mt7996_dev *dev, u8 type, u32 *num)
 {
 	return NULL;
 }
 
-static inline int mt7996_coredump_submit(struct mt7996_dev *dev)
+static inline int mt7996_coredump_submit(struct mt7996_dev *dev, u8 type)
 {
 	return 0;
 }
 
 static inline struct
-mt7996_crash_data *mt7996_coredump_new(struct mt7996_dev *dev)
+mt7996_coredump *mt7996_coredump_build(struct mt7996_dev *dev, u8 type, bool full_dump)
+{
+	return NULL;
+}
+
+static inline struct
+mt7996_crash_data *mt7996_coredump_new(struct mt7996_dev *dev, u8 type)
 {
 	return NULL;
 }
diff --git a/mt7996/debugfs.c b/mt7996/debugfs.c
index 9b29f16c8..600ffec6e 100644
--- a/mt7996/debugfs.c
+++ b/mt7996/debugfs.c
@@ -117,9 +117,21 @@ mt7996_sys_recovery_set(struct file *file, const char __user *user_buf,
 
 	/* WARNING: trigger firmware crash */
 	case UNI_CMD_SER_SET_SYSTEM_ASSERT:
-		ret = mt7996_mcu_trigger_assert(dev);
-		if (ret)
-			return ret;
+		// trigger wm assert exception
+		mt76_wr(dev, 0x89018108, 0x20);
+		mt76_wr(dev, 0x89018118, 0x20);
+		// trigger wa assert exception
+		if (mt7996_has_wa(dev)) {
+			mt76_wr(dev, 0x89098108, 0x20);
+			mt76_wr(dev, 0x89098118, 0x20);
+		}
+		break;
+	case UNI_CMD_SER_FW_COREDUMP_WA:
+		if (mt7996_has_wa(dev))
+			mt7996_coredump(dev, MT7996_COREDUMP_MANUAL_WA);
+		break;
+	case UNI_CMD_SER_FW_COREDUMP_WM:
+		mt7996_coredump(dev, MT7996_COREDUMP_MANUAL_WM);
 		break;
 	case UNI_CMD_SER_SET_HW_BIT_DETECT_ONLY:
 		ret = mt7996_mcu_set_ser(dev, UNI_CMD_SER_SET, BIT(0), band);
diff --git a/mt7996/mac.c b/mt7996/mac.c
index cd45b411e..e4fea1525 100644
--- a/mt7996/mac.c
+++ b/mt7996/mac.c
@@ -2445,28 +2445,26 @@ void mt7996_mac_reset_work(struct work_struct *work)
 }
 
 /* firmware coredump */
-void mt7996_mac_dump_work(struct work_struct *work)
+static void
+mt7996_mac_fw_coredump(struct mt7996_dev *dev, u8 type)
 {
 	const struct mt7996_mem_region *mem_region;
 	struct mt7996_crash_data *crash_data;
-	struct mt7996_dev *dev;
 	struct mt7996_mem_hdr *hdr;
 	size_t buf_len;
 	int i;
 	u32 num;
 	u8 *buf;
 
-	dev = container_of(work, struct mt7996_dev, dump_work);
-
 	mutex_lock(&dev->dump_mutex);
 
-	crash_data = mt7996_coredump_new(dev);
+	crash_data = mt7996_coredump_new(dev, type);
 	if (!crash_data) {
 		mutex_unlock(&dev->dump_mutex);
-		goto skip_coredump;
+		return;
 	}
 
-	mem_region = mt7996_coredump_get_mem_layout(dev, &num);
+	mem_region = mt7996_coredump_get_mem_layout(dev, type, &num);
 	if (!mem_region || !crash_data->memdump_buf_len) {
 		mutex_unlock(&dev->dump_mutex);
 		goto skip_memdump;
@@ -2476,6 +2474,9 @@ void mt7996_mac_dump_work(struct work_struct *work)
 	buf_len = crash_data->memdump_buf_len;
 
 	/* dumping memory content... */
+	dev_info(dev->mt76.dev, "%s start coredump for %s\n",
+		 wiphy_name(dev->mt76.hw->wiphy),
+		 ((type == MT7996_RAM_TYPE_WA) ? "WA" : "WM"));
 	memset(buf, 0, buf_len);
 	for (i = 0; i < num; i++) {
 		if (mem_region->len > buf_len) {
@@ -2492,6 +2493,7 @@ void mt7996_mac_dump_work(struct work_struct *work)
 		mt7996_memcpy_fromio(dev, buf, mem_region->start,
 				     mem_region->len);
 
+		strscpy(hdr->name, mem_region->name, sizeof(hdr->name));
 		hdr->start = mem_region->start;
 		hdr->len = mem_region->len;
 
@@ -2508,9 +2510,42 @@ void mt7996_mac_dump_work(struct work_struct *work)
 	mutex_unlock(&dev->dump_mutex);
 
 skip_memdump:
-	mt7996_coredump_submit(dev);
-skip_coredump:
-	queue_work(dev->mt76.wq, &dev->reset_work);
+	mt7996_coredump_submit(dev, type);
+}
+
+void mt7996_mac_dump_work(struct work_struct *work)
+{
+	struct mt7996_dev *dev;
+
+	dev = container_of(work, struct mt7996_dev, dump_work);
+	if (dev->dump_state == MT7996_COREDUMP_MANUAL_WA ||
+	    READ_ONCE(dev->recovery.state) & MT_MCU_CMD_WA_WDT)
+		mt7996_mac_fw_coredump(dev, MT7996_RAM_TYPE_WA);
+
+	if (dev->dump_state == MT7996_COREDUMP_MANUAL_WM ||
+	    READ_ONCE(dev->recovery.state) & MT_MCU_CMD_WM_WDT)
+		mt7996_mac_fw_coredump(dev, MT7996_RAM_TYPE_WM);
+
+	if (READ_ONCE(dev->recovery.state) & MT_MCU_CMD_WDT_MASK)
+		queue_work(dev->mt76.wq, &dev->reset_work);
+
+	dev->dump_state = MT7996_COREDUMP_IDLE;
+}
+
+void mt7996_coredump(struct mt7996_dev *dev, u8 state)
+{
+	if (state == MT7996_COREDUMP_IDLE ||
+	    state >= __MT7996_COREDUMP_TYPE_MAX)
+		return;
+
+	if (dev->dump_state != MT7996_COREDUMP_IDLE)
+		return;
+
+	dev->dump_state = state;
+	dev_info(dev->mt76.dev, "%s attempting grab coredump\n",
+		 wiphy_name(dev->mt76.hw->wiphy));
+
+	queue_work(dev->mt76.wq, &dev->dump_work);
 }
 
 void mt7996_reset(struct mt7996_dev *dev)
@@ -2530,6 +2565,7 @@ void mt7996_reset(struct mt7996_dev *dev)
 
 		mt7996_irq_disable(dev, MT_INT_MCU_CMD);
 		queue_work(dev->mt76.wq, &dev->dump_work);
+		mt7996_coredump(dev, MT7996_COREDUMP_AUTO);
 		return;
 	}
 
diff --git a/mt7996/mcu.c b/mt7996/mcu.c
index 7f0394356..328b60617 100644
--- a/mt7996/mcu.c
+++ b/mt7996/mcu.c
@@ -3363,6 +3363,8 @@ static int mt7996_load_patch(struct mt7996_dev *dev)
 
 	dev_info(dev->mt76.dev, "HW/SW Version: 0x%x, Build Time: %.16s\n",
 		 be32_to_cpu(hdr->hw_sw_ver), hdr->build_date);
+	strscpy(dev->patch_build_date, hdr->build_date,
+		sizeof(hdr->build_date));
 
 	for (i = 0; i < be32_to_cpu(hdr->desc.n_region); i++) {
 		struct mt7996_patch_sec *sec;
@@ -3489,6 +3491,9 @@ static int __mt7996_load_ram(struct mt7996_dev *dev, const char *fw_type,
 	}
 
 	hdr = (const void *)(fw->data + fw->size - sizeof(*hdr));
+	strscpy(dev->ram_build_date[ram_type],
+		hdr->build_date,
+		sizeof(hdr->build_date));
 	dev_info(dev->mt76.dev, "%s Firmware Version: %.10s, Build Time: %.15s\n",
 		 fw_type, hdr->fw_ver, hdr->build_date);
 
diff --git a/mt7996/mt7996.h b/mt7996/mt7996.h
index 3f4c0ba2c..e169dee68 100644
--- a/mt7996/mt7996.h
+++ b/mt7996/mt7996.h
@@ -135,6 +135,8 @@
 #define MT7996_RRO_MSDU_PG_CR_CNT	8
 #define MT7996_RRO_MSDU_PG_SIZE_PER_CR	0x10000
 
+#define MT7996_BUILD_TIME_LEN		24
+
 #define to_rssi(field, rcpi)	((FIELD_GET(field, rcpi) - 220) / 2)
 
 struct mt7996_vif;
@@ -146,6 +148,7 @@ enum mt7996_ram_type {
 	MT7996_RAM_TYPE_WM,
 	MT7996_RAM_TYPE_WA,
 	MT7996_RAM_TYPE_DSP,
+	__MT7996_RAM_TYPE_MAX,
 };
 
 enum mt7996_var_type {
@@ -168,6 +171,14 @@ enum mt7996_fem_type {
 	MT7996_FEM_MIX,
 };
 
+enum mt7996_coredump_state {
+	MT7996_COREDUMP_IDLE = 0,
+	MT7996_COREDUMP_MANUAL_WA,
+	MT7996_COREDUMP_MANUAL_WM,
+	MT7996_COREDUMP_AUTO,
+	__MT7996_COREDUMP_TYPE_MAX,
+};
+
 enum mt7996_txq_id {
 	MT7996_TXQ_FWDL = 16,
 	MT7996_TXQ_MCU_WM,
@@ -293,6 +304,7 @@ struct mt7996_vif {
 struct mt7996_crash_data {
 	guid_t guid;
 	struct timespec64 timestamp;
+	bool supported;
 
 	u8 *memdump_buf;
 	size_t memdump_buf_len;
@@ -443,11 +455,14 @@ struct mt7996_dev {
 
 	/* protects coredump data */
 	struct mutex dump_mutex;
+	u8 dump_state;
 #ifdef CONFIG_DEV_COREDUMP
 	struct {
-		struct mt7996_crash_data *crash_data;
+		struct mt7996_crash_data *crash_data[__MT7996_RAM_TYPE_MAX];
 	} coredump;
 #endif
+	char patch_build_date[MT7996_BUILD_TIME_LEN];
+	char ram_build_date[__MT7996_RAM_TYPE_MAX][MT7996_BUILD_TIME_LEN];
 
 	struct list_head sta_rc_list;
 	struct list_head twt_list;
@@ -673,6 +688,7 @@ int mt7996_init_tx_queues(struct mt7996_phy *phy, int idx,
 void mt7996_init_txpower(struct mt7996_phy *phy);
 int mt7996_txbf_init(struct mt7996_dev *dev);
 void mt7996_reset(struct mt7996_dev *dev);
+void mt7996_coredump(struct mt7996_dev *dev, u8 state);
 int mt7996_run(struct mt7996_phy *phy);
 int mt7996_mcu_init(struct mt7996_dev *dev);
 int mt7996_mcu_init_firmware(struct mt7996_dev *dev);
diff --git a/mt7996/regs.h b/mt7996/regs.h
index e48e0e575..65d3e45b2 100644
--- a/mt7996/regs.h
+++ b/mt7996/regs.h
@@ -696,8 +696,12 @@ enum offs_rev {
 #define MT_CONN_DBG_CTL_BASE			0x18023000
 #define MT_CONN_DBG_CTL(ofs)			(MT_CONN_DBG_CTL_BASE + (ofs))
 #define MT_CONN_DBG_CTL_OUT_SEL			MT_CONN_DBG_CTL(0x604)
+#define MT_CONN_DBG_CTL_GPR_BUS_OUT_LOG		MT_CONN_DBG_CTL(0x608)
+#define MT_CONN_DBG_CTL_GPR_BUS_OUT_IDX_STATUS	GENMASK(21, 17)
 #define MT_CONN_DBG_CTL_PC_LOG_SEL		MT_CONN_DBG_CTL(0x60c)
 #define MT_CONN_DBG_CTL_PC_LOG			MT_CONN_DBG_CTL(0x610)
+#define MT_CONN_DBG_CTL_PC_LOG_IDX_STATUS	GENMASK(21, 17)
+#define MT_CONN_DBG_CTL_GPR_LOG_SEL		MT_CONN_DBG_CTL(0x614)
 
 #define MT_LED_GPIO_MUX2			0x70005058 /* GPIO 18 */
 #define MT_LED_GPIO_MUX3			0x7000505C /* GPIO 26 */
@@ -774,11 +778,15 @@ enum offs_rev {
 #define MT_WF_PHYRX_CSD_BAND_RXTD12_IRPI_SW_CLR		BIT(29)
 
 /* CONN MCU EXCP CON */
+#define MT_MCU_WA_EXCP_BASE			0x890d0000
 #define MT_MCU_WM_EXCP_BASE			0x89050000
+
 #define MT_MCU_WM_EXCP(ofs)			(MT_MCU_WM_EXCP_BASE + (ofs))
 #define MT_MCU_WM_EXCP_PC_CTRL			MT_MCU_WM_EXCP(0x100)
+#define MT_MCU_WM_EXCP_PC_CTRL_IDX_STATUS	GENMASK(20, 16)
 #define MT_MCU_WM_EXCP_PC_LOG			MT_MCU_WM_EXCP(0x104)
 #define MT_MCU_WM_EXCP_LR_CTRL			MT_MCU_WM_EXCP(0x200)
+#define MT_MCU_WM_EXCP_LR_CTRL_IDX_STATUS	GENMASK(20, 16)
 #define MT_MCU_WM_EXCP_LR_LOG			MT_MCU_WM_EXCP(0x204)
 
 /* CONN AFE CTL CON */
-- 
2.45.2

