From c6b690726f48015a549c061f3a89fc7350f14e07 Mon Sep 17 00:00:00 2001
From: Allen Ye <allen.ye@mediatek.com>
Date: Mon, 3 Mar 2025 15:18:02 +0800
Subject: [PATCH 063/105] mtk: mt76: mt7996: Enable sku when hostapd bring sku
 index attr

Make txpwoer vendor cmd can default enable sku by hostapd config.

Signed-off-by: Allen Ye <allen.ye@mediatek.com>
---
 mt7996/mcu.c    | 25 +++++++++++------------
 mt7996/vendor.c | 53 +++++++++++++++++++++++++++----------------------
 2 files changed, 41 insertions(+), 37 deletions(-)

diff --git a/mt7996/mcu.c b/mt7996/mcu.c
index 49b4c26d8..87fa6982b 100644
--- a/mt7996/mcu.c
+++ b/mt7996/mcu.c
@@ -6714,7 +6714,6 @@ mt7996_update_max_txpower_cur(struct mt7996_phy *phy, int tx_power)
 static int mt7996_afc_update_power_limit(struct mt7996_dev *dev,
 					 struct ieee80211_channel *chan,
 					 struct mt76_power_limits *la,
-					 struct mt76_power_path_limits *la_path,
 					 int *tx_power,
 					 struct cfg80211_chan_def *chandef)
 {
@@ -6778,13 +6777,13 @@ static int mt7996_afc_update_power_limit(struct mt7996_dev *dev,
 	for (i = 0; i < sizeof(la->ofdm); i++)
 		la->ofdm[i] = min_t(s8, la->ofdm[i], target_power);
 
-	for (i = 0; i < sizeof(la_path->cck); i++)
-		la_path->cck[i] = min_t(s8, la_path->cck[i], power_list[afc_power_bw20]);
-	for (i = 0; i < sizeof(la_path->ofdm); i++)
-		la_path->ofdm[i] = min_t(s8, la_path->ofdm[i], target_power);
-	for (i = 0; i < sizeof(la_path->ofdm_bf); i++) {
-		la_path->ofdm_bf[i] =
-			min_t(s8, la_path->ofdm_bf[i],
+	for (i = 0; i < sizeof(la->path.cck); i++)
+		la->path.cck[i] = min_t(s8, la->path.cck[i], power_list[afc_power_bw20]);
+	for (i = 0; i < sizeof(la->path.ofdm); i++)
+		la->path.ofdm[i] = min_t(s8, la->path.ofdm[i], target_power);
+	for (i = 0; i < sizeof(la->path.ofdm_bf); i++) {
+		la->path.ofdm_bf[i] =
+			min_t(s8, la->path.ofdm_bf[i],
 			      target_power - bf_offset_ofdm[i]);
 	}
 
@@ -6818,11 +6817,11 @@ static int mt7996_afc_update_power_limit(struct mt7996_dev *dev,
 		}
 
 		if (path >= 0) {
-			for (i = 0; i < sizeof(la_path->ru[0]); i++) {
-				la_path->ru[path][i] =
-					min_t(s8, la_path->ru[path][i], power_list[bw]);
-				la_path->ru_bf[path][i] =
-					min_t(s8, la_path->ru_bf[path][i],
+			for (i = 0; i < sizeof(la->path.ru[0]); i++) {
+				la->path.ru[path][i] =
+					min_t(s8, la->path.ru[path][i], power_list[bw]);
+				la->path.ru_bf[path][i] =
+					min_t(s8, la->path.ru_bf[path][i],
 					      power_list[bw] - bf_offset[i]);
 			}
 		}
diff --git a/mt7996/vendor.c b/mt7996/vendor.c
index 0fcf33aa4..b0c59060a 100644
--- a/mt7996/vendor.c
+++ b/mt7996/vendor.c
@@ -1650,14 +1650,10 @@ static int mt7996_vendor_txpower_ctrl(struct wiphy *wiphy,
 	struct mt7996_dev *dev;
 	struct mt7996_phy *phy;
 	struct mt76_phy *mphy;
-	struct mt76_dev *mdev;
 	struct ieee80211_vif *vif = wdev_to_ieee80211_vif(wdev);
 	struct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;
 	struct mt7996_vif_link *mconf;
 	struct nlattr *tb[NUM_MTK_VENDOR_ATTRS_TXPOWER_CTRL], *table;
-	struct mt76_power_limits *la;
-	struct mt76_power_path_limits *la_path;
-	u8 orig_sku_idx = mphy->sku_idx;
 	int err, current_txpower, delta;
 	u8 val, link_id = 0, idx;
 
@@ -1685,7 +1681,7 @@ static int mt7996_vendor_txpower_ctrl(struct wiphy *wiphy,
 	rcu_read_unlock();
 
 	mphy = phy->mt76;
-	mdev = mphy->dev;
+	dev = phy->dev;
 	delta = mt76_tx_power_path_delta(hweight16(mphy->chainmask));
 
 	if (mphy->cap.has_6ghz &&
@@ -1701,10 +1697,13 @@ static int mt7996_vendor_txpower_ctrl(struct wiphy *wiphy,
 
 		err = mt7996_mcu_set_lpi_psd(phy, val);
 		if (err)
-			goto out;
+			return err;
 	}
 
 	if (tb[MTK_VENDOR_ATTR_TXPOWER_CTRL_SKU_IDX]) {
+		struct mt76_power_limits *la = NULL;
+		u8 orig_sku_idx = mphy->sku_idx;
+
 		mphy->sku_idx = nla_get_u8(tb[MTK_VENDOR_ATTR_TXPOWER_CTRL_SKU_IDX]);
 
 		if (mt76_find_power_limits_node(mphy) == NULL)
@@ -1715,24 +1714,33 @@ static int mt7996_vendor_txpower_ctrl(struct wiphy *wiphy,
 
 		phy->sku_limit_en = true;
 		phy->sku_path_en = true;
-		la = kzalloc(sizeof(struct mt76_power_limits), GFP_KERNEL);
-		la_path = kzalloc(sizeof(struct mt76_power_path_limits), GFP_KERNEL);
+		la = kzalloc(sizeof(*la), GFP_KERNEL);
+		if (!la)
+			return -ENOMEM;
 
-		mt76_get_rate_power_limits(mphy, mphy->chandef.chan, la, la_path, 127);
-		if (!la_path->ofdm[0])
+		mt76_get_rate_power_limits(mphy, mphy->chandef.chan, la, 127);
+		if (!la->path.ofdm[0])
 			phy->sku_path_en = false;
 
-		dev = phy->dev;
-		err = mt7996_mcu_set_tx_power_ctrl(phy, UNI_TXPOWER_SKU_POWER_LIMIT_CTRL,
-						   dev->dbg.sku_disable ? 0 : phy->sku_limit_en);
-		if (err)
-			goto out;
-		err = mt7996_mcu_set_tx_power_ctrl(phy, UNI_TXPOWER_BACKOFF_POWER_LIMIT_CTRL,
-						   dev->dbg.sku_disable ? 0 : phy->sku_path_en);
-		if (err)
-			goto out;
+#ifdef CONFIG_MTK_DEBUG
+		/* To make sure the sku is still enabled when we restart AP. */
+		dev->dbg.sku_disable = false;
+#endif
+		kfree(la);
+	} else {
+		phy->sku_limit_en = false;
+		phy->sku_path_en = false;
 	}
 
+	err = mt7996_mcu_set_tx_power_ctrl(phy, UNI_TXPOWER_SKU_POWER_LIMIT_CTRL,
+					   phy->sku_limit_en);
+	if (err)
+		return err;
+	err = mt7996_mcu_set_tx_power_ctrl(phy, UNI_TXPOWER_BACKOFF_POWER_LIMIT_CTRL,
+					   phy->sku_path_en);
+	if (err)
+		return err;
+
 	if (mphy->cap.has_6ghz &&
 	    tb[MTK_VENDOR_ATTR_TXPOWER_CTRL_LPI_BCN_ENHANCE]) {
 		val = nla_get_u8(tb[MTK_VENDOR_ATTR_TXPOWER_CTRL_LPI_BCN_ENHANCE]);
@@ -1742,7 +1750,7 @@ static int mt7996_vendor_txpower_ctrl(struct wiphy *wiphy,
 		err = mt7996_mcu_set_fixed_rate_table(phy, idx, FR_RATE_IDX_OFDM_6M,
 						      true);
 		if (err)
-			goto out;
+			return err;
 	}
 
 	if (mphy->cap.has_6ghz) {
@@ -1750,7 +1758,7 @@ static int mt7996_vendor_txpower_ctrl(struct wiphy *wiphy,
 		if (table) {
 			err = mt7996_parse_afc_table(dev, table, delta);
 			if (err)
-				goto out;
+				return err;
 		} else
 			mt7996_free_afc_table(dev);
 	}
@@ -1759,9 +1767,6 @@ static int mt7996_vendor_txpower_ctrl(struct wiphy *wiphy,
 
 	err = mt7996_mcu_set_txpower_sku(phy, current_txpower);
 
-out:
-	kfree(la);
-	kfree(la_path);
 	return err;
 }
 
-- 
2.45.2

