From 4800e491a8c1f7fb23d1a24151d60bcc1547be7d Mon Sep 17 00:00:00 2001
From: MeiChia Chiu <MeiChia.Chiu@mediatek.com>
Date: Tue, 7 May 2024 15:47:23 +0800
Subject: [PATCH 053/105] mtk: mt76: mt7996: Add support for EMLSR

1. Register the EMLSR capability
2. Set the EML capability of the station to firmware
3. Process the EML Operating Mode Notification frame

Signed-off-by: MeiChia Chiu <MeiChia.Chiu@mediatek.com>
---
 mt76_connac_mcu.h |  8 +++++
 mt7996/mcu.c      | 55 +++++++++++++++++++++++++++++++++++
 mt7996/mt7996.h   | 20 +++++++++++++
 mt7996/vendor.c   | 74 +++++++++++++++++++++++++++++++++++++++++++++++
 mt7996/vendor.h   | 15 ++++++++++
 5 files changed, 172 insertions(+)

diff --git a/mt76_connac_mcu.h b/mt76_connac_mcu.h
index ad53a6372..5b4675382 100644
--- a/mt76_connac_mcu.h
+++ b/mt76_connac_mcu.h
@@ -628,6 +628,13 @@ struct sta_rec_tx_proc {
 	__le32 flag;
 } __packed;
 
+struct sta_rec_eml_op {
+	__le16 tag;
+	__le16 len;
+	u8 bitmap;
+	u8 link_ant_num[3];
+} __packed;
+
 /* wtbl_rec */
 
 struct wtbl_req_hdr {
@@ -832,6 +839,7 @@ enum {
 	STA_REC_PN_INFO = 0x26,
 	STA_REC_KEY_V3 = 0x27,
 	STA_REC_HDRT = 0x28,
+	STA_REC_EML_OP = 0x29,
 	STA_REC_HDR_TRANS = 0x2B,
 	STA_REC_TX_CAP = 0x2f,
 	STA_REC_GET_WTBL = 0x42,
diff --git a/mt7996/mcu.c b/mt7996/mcu.c
index 4863b80f5..e404113dc 100644
--- a/mt7996/mcu.c
+++ b/mt7996/mcu.c
@@ -7334,6 +7334,61 @@ int mt7996_mcu_set_vow_feature_ctrl(struct mt7996_phy *phy)
 	                         &req, sizeof(req), true);
 }
 
+int mt7996_mcu_set_eml_omn(struct ieee80211_vif *vif,
+			   u8 link_id,
+			   struct ieee80211_sta *sta,
+			   struct mt7996_dev *dev,
+			   struct mt7996_eml_omn *eml_omn)
+{
+#define EML_OMN_CONTROL_EMLSR_MODE	0x01
+	struct mt7996_sta *msta = (struct mt7996_sta *)sta->drv_priv;
+	struct mt7996_sta_link *msta_link;
+	struct mt7996_vif_link *mconf, *mconf_link;
+	struct sta_rec_eml_op *eml_op;
+	struct sk_buff *skb;
+	struct tlv *tlv;
+
+	msta_link = mt76_dereference(msta->link[link_id], &dev->mt76);
+	mconf = mt7996_vif_link(dev, vif, link_id);
+
+	if (!msta_link || !mconf)
+		return -EINVAL;
+
+	skb = __mt76_connac_mcu_alloc_sta_req(&dev->mt76,
+					      &mconf->mt76,
+					      &msta_link->wcid,
+					      MT7996_STA_UPDATE_MAX_SIZE);
+
+	if (IS_ERR(skb))
+		return PTR_ERR(skb);
+
+	tlv = mt76_connac_mcu_add_tlv(skb, STA_REC_EML_OP, sizeof(*eml_op));
+	eml_op = (struct sta_rec_eml_op *) tlv;
+	eml_op->bitmap = 0;
+
+	if (eml_omn->control & EML_OMN_CONTROL_EMLSR_MODE) {
+		unsigned long bitmap = (unsigned long) le16_to_cpu(eml_omn->bitmap);
+		unsigned int linkid;
+
+		for_each_set_bit(linkid, &bitmap, IEEE80211_MLD_MAX_NUM_LINKS) {
+			mconf_link = mt7996_vif_link(dev, vif, linkid);
+
+			if (!mconf_link)
+				continue;
+
+			eml_op->bitmap |= BIT(mconf_link->phy->mt76->band_idx);
+		}
+	}
+
+	mt76_dbg(&dev->mt76, MT76_DBG_MLD,
+		 "%s: link:%u, wcid:%d, control:%x, mode:%d, bmp:%x\n",
+		 __func__, msta_link->wcid.link_id, msta_link->wcid.idx, eml_omn->control,
+		 !!(eml_omn->control & EML_OMN_CONTROL_EMLSR_MODE), eml_op->bitmap);
+
+	return mt76_mcu_skb_send_msg(&dev->mt76, skb,
+			MCU_WMWA_UNI_CMD(STA_REC_UPDATE), true);
+}
+
 #ifdef CONFIG_MTK_VENDOR
 void mt7996_set_wireless_vif(void *data, u8 *mac, struct ieee80211_vif *vif)
 {
diff --git a/mt7996/mt7996.h b/mt7996/mt7996.h
index a764f07bc..3534869a9 100644
--- a/mt7996/mt7996.h
+++ b/mt7996/mt7996.h
@@ -563,6 +563,23 @@ struct mt7996_sta_rc_work_data {
 	u32 changed;
 };
 
+struct mt7996_eml_omn {
+	u8 dialog_token;
+	u8 control;
+	__le16 bitmap;
+	union {
+		struct {
+			u8 emlsr_para_update;
+		} emlsr_info;
+		struct {
+			u8 mcs_map_count_control;
+			u8 mcs_map_bw80[3];
+			u8 mcs_map_bw160[3];
+			u8 mcs_map_bw320[3];
+		} emlmr_info;
+	} u;
+} __packed;
+
 #ifdef CONFIG_MTK_VENDOR
 #define MT7996_AIR_MONITOR_MAX_ENTRY	16
 #define MT7996_AIR_MONITOR_MAX_GROUP	(MT7996_AIR_MONITOR_MAX_ENTRY >> 1)
@@ -1347,6 +1364,9 @@ int mt7996_mcu_set_pp_en(struct mt7996_phy *phy, u8 mode, u16 bitmap);
 int mt7996_mcu_set_pp_sta_dscb(struct mt7996_phy *phy, struct cfg80211_chan_def *chandef,
 			       u8 omac_idx);
 int mt7996_mcu_set_pp_alg_ctrl(struct mt7996_phy *phy, u8 action);
+int mt7996_mcu_set_eml_omn(struct ieee80211_vif *vif, u8 link_id,
+			   struct ieee80211_sta *sta, struct mt7996_dev *dev,
+			   struct mt7996_eml_omn *eml_omn);
 #ifdef CONFIG_MAC80211_DEBUGFS
 void mt7996_sta_add_debugfs(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 			    struct ieee80211_sta *sta, struct dentry *dir);
diff --git a/mt7996/vendor.c b/mt7996/vendor.c
index 73345f46e..4265f9b34 100644
--- a/mt7996/vendor.c
+++ b/mt7996/vendor.c
@@ -129,6 +129,13 @@ beacon_ctrl_policy[NUM_MTK_VENDOR_ATTRS_BEACON_CTRL] = {
 	[MTK_VENDOR_ATTR_BEACON_CTRL_MODE] = { .type = NLA_U8 },
 };
 
+static const struct nla_policy
+eml_ctrl_policy[NUM_MTK_VENDOR_ATTRS_EML_CTRL] = {
+	[MTK_VENDOR_ATTR_EML_LINK_ID] = { .type = NLA_U8 },
+	[MTK_VENDOR_ATTR_EML_STA_ADDR] = { .type = NLA_BINARY },
+	[MTK_VENDOR_ATTR_EML_CTRL_STRUCT] = { .type = NLA_BINARY },
+};
+
 static const struct nla_policy
 scs_ctrl_policy[NUM_MTK_VENDOR_ATTRS_SCS_CTRL] = {
 	[MTK_VENDOR_ATTR_SCS_ID] = { .type = NLA_U8 },
@@ -1196,6 +1203,62 @@ static int mt7996_vendor_beacon_ctrl(struct wiphy *wiphy,
 	return 0;
 }
 
+static int mt7996_vendor_eml_ctrl(struct wiphy *wiphy, struct wireless_dev *wdev,
+				  const void *data, int data_len)
+{
+	struct ieee80211_hw *hw = wiphy_to_ieee80211_hw(wiphy);
+	struct ieee80211_vif *vif = wdev_to_ieee80211_vif(wdev);
+	struct ieee80211_sta *sta;
+	struct nlattr *tb[NUM_MTK_VENDOR_ATTRS_EML_CTRL];
+	struct mt7996_dev *dev = mt7996_hw_dev(hw);
+	struct mt7996_eml_omn *eml_omn;
+	u8 sta_addr[ETH_ALEN], link_id;
+	int err;
+
+	if (!ieee80211_vif_is_mld(vif))
+		return -EINVAL;
+
+	err = nla_parse(tb, MTK_VENDOR_ATTR_EML_CTRL_MAX, data, data_len,
+			eml_ctrl_policy, NULL);
+	if (err)
+		return err;
+
+	if (!tb[MTK_VENDOR_ATTR_EML_LINK_ID] || !tb[MTK_VENDOR_ATTR_EML_STA_ADDR])
+		return -EINVAL;
+
+	link_id = nla_get_u8(tb[MTK_VENDOR_ATTR_EML_LINK_ID]);
+
+	if (link_id >= IEEE80211_LINK_UNSPECIFIED)
+		return -EINVAL;
+
+	mutex_lock(&dev->mt76.mutex);
+	nla_memcpy(sta_addr, tb[MTK_VENDOR_ATTR_EML_STA_ADDR], ETH_ALEN);
+	sta = ieee80211_find_sta_by_ifaddr(hw, sta_addr, NULL);
+
+	if (!sta) {
+		err = -EINVAL;
+		goto out;
+	}
+
+	if (tb[MTK_VENDOR_ATTR_EML_CTRL_STRUCT]) {
+		eml_omn = kzalloc(sizeof(struct mt7996_eml_omn), GFP_KERNEL);
+		if (!eml_omn) {
+			err = -ENOMEM;
+			goto out;
+		}
+
+		nla_memcpy(eml_omn, tb[MTK_VENDOR_ATTR_EML_CTRL_STRUCT],
+			   sizeof(struct mt7996_eml_omn));
+
+		err = mt7996_mcu_set_eml_omn(vif, link_id, sta, dev, eml_omn);
+		kfree(eml_omn);
+	}
+
+out:
+	mutex_unlock(&dev->mt76.mutex);
+	return err;
+}
+
 static int mt7996_vendor_scs_ctrl(struct wiphy *wiphy, struct wireless_dev *wdev,
 				  const void *data, int data_len)
 {
@@ -1644,6 +1707,17 @@ static const struct wiphy_vendor_command mt7996_vendor_commands[] = {
 		.policy = csi_ctrl_policy,
 		.maxattr = MTK_VENDOR_ATTR_CSI_CTRL_MAX,
 	},
+	{
+		.info = {
+			.vendor_id = MTK_NL80211_VENDOR_ID,
+			.subcmd = MTK_NL80211_VENDOR_SUBCMD_EML_CTRL,
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_NETDEV |
+			 WIPHY_VENDOR_CMD_NEED_RUNNING,
+		.doit = mt7996_vendor_eml_ctrl,
+		.policy = eml_ctrl_policy,
+		.maxattr = MTK_VENDOR_ATTR_EML_CTRL_MAX,
+	},
 	{
 		.info = {
 			.vendor_id = MTK_NL80211_VENDOR_ID,
diff --git a/mt7996/vendor.h b/mt7996/vendor.h
index ca66f5229..62e89b1d5 100644
--- a/mt7996/vendor.h
+++ b/mt7996/vendor.h
@@ -19,6 +19,7 @@ enum mtk_nl80211_vendor_subcmds {
 	MTK_NL80211_VENDOR_SUBCMD_PP_CTRL = 0xcc,
 	MTK_NL80211_VENDOR_SUBCMD_BEACON_CTRL = 0xcd,
 	MTK_NL80211_VENDOR_SUBCMD_SCS_CTRL = 0xd0,
+	MTK_NL80211_VENDOR_SUBCMD_EML_CTRL = 0xd3,
 	MTK_NL80211_VENDOR_SUBCMD_DFS_TX_CTRL = 0xd5,
 };
 
@@ -252,6 +253,20 @@ enum mtk_vendor_attr_beacon_ctrl {
 		NUM_MTK_VENDOR_ATTRS_BEACON_CTRL - 1
 };
 
+enum mtk_vendor_attr_eml_ctrl {
+
+	MTK_VENDOR_ATTR_EML_CTRL_UNSPEC,
+
+	MTK_VENDOR_ATTR_EML_LINK_ID,
+	MTK_VENDOR_ATTR_EML_STA_ADDR,
+	MTK_VENDOR_ATTR_EML_CTRL_STRUCT,
+
+	/* keep last */
+	NUM_MTK_VENDOR_ATTRS_EML_CTRL,
+	MTK_VENDOR_ATTR_EML_CTRL_MAX =
+		NUM_MTK_VENDOR_ATTRS_EML_CTRL - 1
+};
+
 enum mtk_vendor_attr_scs_ctrl {
 	MTK_VENDOR_ATTR_SCS_CTRL_UNSPEC,
 
-- 
2.45.2

