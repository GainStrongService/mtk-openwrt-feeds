From 34d65687e5b824556faeded11e36a589ccc95e58 Mon Sep 17 00:00:00 2001
From: Shayne Chen <shayne.chen@mediatek.com>
Date: Tue, 19 Aug 2025 15:37:22 +0800
Subject: [PATCH 114/128] mtk: nl80211: support per-radio txpower setting

Support to configure txpower for each wiphy radio.

Signed-off-by: Shayne Chen <shayne.chen@mediatek.com>
---
 include/net/cfg80211.h |  2 ++
 net/mac80211/cfg.c     | 17 +++++++++++++++--
 net/mac80211/iface.c   |  8 ++++++++
 net/wireless/nl80211.c | 20 ++++++++++++++++++--
 4 files changed, 43 insertions(+), 4 deletions(-)

diff --git a/include/net/cfg80211.h b/include/net/cfg80211.h
index 2d955f85..bd49fdfb 100644
--- a/include/net/cfg80211.h
+++ b/include/net/cfg80211.h
@@ -5721,10 +5721,12 @@ struct wiphy_iftype_akm_suites {
  * @radio_debugfsdir: Pointer to debugfs directory containing the radio-
  *	specific parameters.
  *	NULL (default) = Debugfs directory not created
+ * @tx_power_level: txpower configured on this radio (dBm)
  */
 struct wiphy_radio_cfg {
 	u32 rts_threshold;
 	struct dentry *radio_debugfsdir;
+	int tx_power_level;
 };
 
 /**
diff --git a/net/mac80211/cfg.c b/net/mac80211/cfg.c
index db8b55a2..c9d2b78d 100644
--- a/net/mac80211/cfg.c
+++ b/net/mac80211/cfg.c
@@ -3431,7 +3431,8 @@ static int ieee80211_set_tx_power(struct wiphy *wiphy,
 		return 0;
 	}
 
-	local->user_power_level = user_power_level;
+	if (!wiphy->n_radio)
+		local->user_power_level = user_power_level;
 
 	list_for_each_entry(sdata, &local->interfaces, list) {
 		if (sdata->vif.type == NL80211_IFTYPE_MONITOR &&
@@ -3445,11 +3446,17 @@ static int ieee80211_set_tx_power(struct wiphy *wiphy,
 		     link_id++) {
 			struct ieee80211_link_data *link =
 				wiphy_dereference(wiphy, sdata->link[link_id]);
+			struct ieee80211_chanctx_conf *chanctx_conf;
 
 			if (!link)
 				continue;
 
-			link->user_power_level = local->user_power_level;
+			chanctx_conf = sdata_dereference(link->conf->chanctx_conf,
+							 sdata);
+			if (!chanctx_conf || radio_idx != chanctx_conf->radio_idx)
+				continue;
+
+			link->user_power_level = user_power_level;
 			if (txp_type != link->conf->txpower_type)
 				update_txp_type = true;
 			link->conf->txpower_type = txp_type;
@@ -3465,10 +3472,16 @@ static int ieee80211_set_tx_power(struct wiphy *wiphy,
 		     link_id++) {
 			struct ieee80211_link_data *link =
 				wiphy_dereference(wiphy, sdata->link[link_id]);
+			struct ieee80211_chanctx_conf *chanctx_conf;
 
 			if (!link)
 				continue;
 
+			chanctx_conf = sdata_dereference(link->conf->chanctx_conf,
+							 sdata);
+			if (!chanctx_conf || radio_idx != chanctx_conf->radio_idx)
+				continue;
+
 			ieee80211_recalc_txpower(link, update_txp_type);
 		}
 	}
diff --git a/net/mac80211/iface.c b/net/mac80211/iface.c
index f216d918..26b19513 100644
--- a/net/mac80211/iface.c
+++ b/net/mac80211/iface.c
@@ -46,6 +46,7 @@ static void ieee80211_iface_work(struct wiphy *wiphy, struct wiphy_work *work);
 
 bool __ieee80211_recalc_txpower(struct ieee80211_link_data *link)
 {
+	struct wiphy *wiphy = link->sdata->local->hw.wiphy;
 	struct ieee80211_chanctx_conf *chanctx_conf;
 	int power;
 
@@ -57,6 +58,13 @@ bool __ieee80211_recalc_txpower(struct ieee80211_link_data *link)
 	}
 
 	power = ieee80211_chandef_max_power(&chanctx_conf->def);
+	if (wiphy->n_radio) {
+		int radio_idx = chanctx_conf->radio_idx;
+		const struct wiphy_radio_cfg *rcfg = &wiphy->radio_cfg[radio_idx];
+
+		if (rcfg->tx_power_level)
+			power = min(power, rcfg->tx_power_level);
+	}
 	rcu_read_unlock();
 
 	if (link->user_power_level != IEEE80211_UNSET_POWER_LEVEL)
diff --git a/net/wireless/nl80211.c b/net/wireless/nl80211.c
index 039a5559..02409761 100644
--- a/net/wireless/nl80211.c
+++ b/net/wireless/nl80211.c
@@ -3894,7 +3894,12 @@ static int nl80211_set_wiphy(struct sk_buff *skb, struct genl_info *info)
 		if (radio_idx >= rdev->wiphy.n_radio)
 			return -EINVAL;
 
-		return nl80211_set_wiphy_radio(info, rdev, radio_idx);
+		result = nl80211_set_wiphy_radio(info, rdev, radio_idx);
+		if (result)
+			return result;
+
+		if (!info->attrs[NL80211_ATTR_WIPHY_TX_POWER_SETTING])
+			return 0;
 	}
 
 	if (info->attrs[NL80211_ATTR_WIPHY_TXQ_PARAMS]) {
@@ -3968,6 +3973,7 @@ static int nl80211_set_wiphy(struct sk_buff *skb, struct genl_info *info)
 		struct wireless_dev *txp_wdev = wdev;
 		enum nl80211_tx_power_setting type;
 		int idx, mbm = 0;
+		struct wiphy_radio_cfg *rcfg;
 
 		if (!(rdev->wiphy.features & NL80211_FEATURE_VIF_TXPOWER))
 			txp_wdev = NULL;
@@ -3975,6 +3981,9 @@ static int nl80211_set_wiphy(struct sk_buff *skb, struct genl_info *info)
 		if (!rdev->ops->set_tx_power)
 			return -EOPNOTSUPP;
 
+		if (!txp_wdev && rdev->wiphy.n_radio && radio_idx == -1)
+			return -EINVAL;
+
 		idx = NL80211_ATTR_WIPHY_TX_POWER_SETTING;
 		type = nla_get_u32(info->attrs[idx]);
 
@@ -3987,10 +3996,17 @@ static int nl80211_set_wiphy(struct sk_buff *skb, struct genl_info *info)
 			mbm = nla_get_u32(info->attrs[idx]);
 		}
 
+		if (rdev->wiphy.n_radio) {
+			rcfg = &rdev->wiphy.radio_cfg[radio_idx];
+			rcfg->tx_power_level = MBM_TO_DBM(mbm);
+		}
+
 		result = rdev_set_tx_power(rdev, txp_wdev, radio_idx, type,
 					   mbm);
-		if (result)
+		if (result) {
+			rcfg->tx_power_level = 0;
 			return result;
+		}
 	}
 
 	if (info->attrs[NL80211_ATTR_WIPHY_ANTENNA_TX] &&
-- 
2.45.2

