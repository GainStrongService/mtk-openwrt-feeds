From 1df2ff0a4ebb9ba2854d6fcc85a4312c5f00a898 Mon Sep 17 00:00:00 2001
From: Peter Chiu <chui-hao.chiu@mediatek.com>
Date: Tue, 27 Aug 2024 18:05:37 +0800
Subject: [PATCH 072/105] mtk: mt76: mt7990: use device id macro in internal
 debug file

This is a preliminary patch to support mt7990 chipset.

Signed-off-by: Peter Chiu <chui-hao.chiu@mediatek.com>

mtk: mt76: mt7990: add new device id for mt7990 chipset

Signed-off-by: Peter Chiu <chui-hao.chiu@mediatek.com>

mtk: mt76: mt7990: enable TX/RX for MT7990

Support TXD assignment for MT7990.

Signed-off-by: Benjamin Lin <benjamin-jw.lin@mediatek.com>

mtk: mt76: mt7990: add fw/eeprom/sku support

1. Add mt7990 fw/eeprom definition
2. Add mt7990 sku/part number parsing
3. Add mt7990 efuse FT merge support

Signed-off-by: StanleyYP Wang <StanleyYP.Wang@mediatek.com>

mtk: mt76: mt7990: add fwdl support

Add mt7990 fwdl support

Signed-off-by: StanleyYP Wang <StanleyYP.Wang@mediatek.com>

mtk: mt76: mt7990: Increase pp auto mode listen time

Add the time is prevent for 5g link doing channel switch triggered by fw
event before 6g link setup is not finished. The case makes hostapd couldn't
setup mld successfully.

Change pp detection theshold align for 5 seconds timer.

Signed-off-by: Allen Ye <allen.ye@mediatek.com>

mtk: mt76: mt7990: add CR for mt7990

Add CR for mt7990
1. mt7990_offs is checked and revised
2. mt7996_reg_base is identical in both mt7990 and mt7996/mt7992.
3. mt7996_reg_map is checked and revised
4. The CRs in mt7996_mac_init_band are identical
5. The CRs in mt7996_configure_filter are identical
6. The flow & CRs of l1/l2/cbtop remapping are checked and revised

Signed-off-by: StanleyYP Wang <StanleyYP.Wang@mediatek.com>

mtk: mt76: mt7990: add testmode support

mt7990 does not support mem dpd cal, so refactor prek flow to support
both of the following cases.
1. mt7996/mt7992: has mem dpd cal
2. mt7990: no mem dpd cal, use legacy dpd cal for BW > 20 instead

Signed-off-by: StanleyYP Wang <StanleyYP.Wang@mediatek.com>

mtk: mt76: mt7990: modify mcu command to support mt7990 chipset

The mt7990 does not have WA so send command to wm directly and
change wa commands to wm command.

Although WA is removed from mt7990, the WM still use mcu command destination
to check whether handle command or not.
Fix the mcu command by the following rules.
- If it was handled by WM only, use macro MCU_WM_UNI_CMD.
- If it was handled by WA only, use macro MCU_WA_UNI_CMD.
- If it was handled by both WA and WM, use macro MCU_WMWA_UNI_CMD.

Above rules should be followed by mt7996 and mt7992 so this patch is
compatible to mt7996 and mt7992.

Signed-off-by: Peter Chiu <chui-hao.chiu@mediatek.com>

mtk: mt76: mt7990: modify dma ring for removing wa

Modify dma ring for removing wa
Avoid setting wa mcu command

Signed-off-by: StanleyYP Wang <StanleyYP.Wang@mediatek.com>

mtk: mt76: mt7990: add mt7990 support for debugfs

Revise the following debugfs
1. tr_info
2. ple_info
3. pse_info
4. mib_info

Signed-off-by: StanleyYP Wang <StanleyYP.Wang@mediatek.com>

mtk: mt76: mt7990: revise txfree format for mt7990

In mt7990, a new txfree format (ver7) is used.
The differences between ver5 (used by mt7996/mt7992) and ver7 are listed below.
1. Add TID(bit 11..8) and PID(bit 7..0) in DW2.
2. An additional DW is added for TXD release timestamp, TXD release period from
queue head, and PPDU RTS TX count. This DW also sets the Pair bit(bit 31), so skip
it temporarily to avoid misparsing.

Signed-off-by: StanleyYP Wang <StanleyYP.Wang@mediatek.com>

mtk: mt76: mt7990: add unicmd for removing WA

Add the following commands
1. MCU_WA_PARAM_CMD(QUERY) => SDO command, tag UNI_CMD_SDO_QUERY
2. MCU_WA_PARAM_CMD(SET) => SDO command, tag UNI_CMD_SDO_SET
3. QUERY MCU_WA_PARAM_BSS_ACQ_PKT_CNT => SDO command, tag UNI_CMD_SDO_GET_BSS_ACQ_PKT_NUM
4. MCU_EXT_EVENT_BSS_ACQ_PKT_CNT => SDO event, tag UNI_EVENT_SDO_BSS_ACQ_PKT_CNT
5. MCU_WA_EXT_CMD(CP_SUPPORT) => SDO command, tag UNI_CMD_SDO_CP_MODE
6. MCU_WA_EXT_CMD(SET_QOS_MAP) => SDO command, tag UNI_CMD_SDO_SET_QOS_MAP

Signed-off-by: Peter Chiu <chui-hao.chiu@mediatek.com>

mtk: mt76: mt7990: refactor platfrom related configuration

1. Use enum to represent txfree path.
1. Use enum to represent bypass rro option.
3. Add some debug logs.

Signed-off-by: Peter Chiu <chui-hao.chiu@mediatek.com>

mtk: mt76: mt7990: add DMA ring for TxFree

Signed-off-by: Peter Chiu <chui-hao.chiu@mediatek.com>

mtk: mt76: mt7990: modify wtbl CRs for MT7990

Signed-off-by: Peter Chiu <chui-hao.chiu@mediatek.com>

mtk: mt76: mt7990: rename MT_RXQ_BAND1_CTRL to MT_RXQ_EXT_CTRL

The MT_RXQ_EXT_CTRL is ring extension control register for prefetch which
is unrelated to the band. Use MT_RXQ_EXT_CTRL instead of
MT_RXQ_BAND1_CTRL to avoid confusion.

Signed-off-by: Peter Chiu <chui-hao.chiu@mediatek.com>

mtk: mt76: mt7990: modify wtbl debug CRs for mt7990

This patch is based on the following commit:
https://gerrit.mediatek.inc/c/gateway/WiFi7/mac80211/mt76/+/9698501

Signed-off-by: StanleyYP Wang <StanleyYP.Wang@mediatek.com>

mtk: mt76: mt7990: refactor prefetch

The mt7996 different prefetch value with mt7992 and mt7990.
Set the correct prefetch size for each chip.

Signed-off-by: Peter Chiu <chui-hao.chiu@mediatek.com>

mtk: mt76: mt7990: add configuration to suppot wed and rro

Signed-off-by: Peter Chiu <chui-hao.chiu@mediatek.com>

mtk: mt76: mt7990: set specific data frames as management frame

The SDO would drop all non-mgmt packets before authorized so the EAPOL
and 4 address null func cannot be sent. Set these frames as management
frame to prevent SDO dropping it.

mtk: mt76: mt7990: change hw capability for mt7990

Signed-off-by: Peter Chiu <chui-hao.chiu@mediatek.com>

Modify phy cap according to hw capability. The mt7990 can support different
ba size for tx and rx. Without this patch, cannot meet peak performance.

Signed-off-by: Peter Chiu <chui-hao.chiu@mediatek.com>

mtk: mt76: mt7990: add mt7990 background radar capability eeprom check

According to SA & SE from the Logan team, mt7990 (whether i/efem) can
switch from 3T3R (no ZWDFS) to 2T2R + 1R (ZWDFS) without hardware reworking.
In logan, when the eeprom specifies 3T3R, then background radar capability is disabled to prevent conflicts.
Therefore, align it in mt76.

Signed-off-by: StanleyYP Wang <StanleyYP.Wang@mediatek.com>

mtk: mt76: mt7996: do not wait response for the SDO command

The SDO command does not need the response event.
Without this patch, WM will show error log when sending SDO command.

Signed-off-by: Peter Chiu <chui-hao.chiu@mediatek.com>

mtk: mt76: mt7990: rework mib register mapping for mt7990

Rework mib register offset for mt7990.

Signed-off-by: Howard Hsu <howard-yh.hsu@mediatek.com>

Fix the FIPS & power boost cap bit num in the following patch
"Add mt7990 sku/part number parsing"

Signed-off-by: StanleyYP Wang <StanleyYP.Wang@mediatek.com>

Revise wtbl_info DebugFS knob for mt7990.

Signed-off-by: Benjamin Lin <benjamin-jw.lin@mediatek.com>

Fix incorrect definitions used by UNI_CMD_SDO_GET_BSS_ACQ_PKT_NUM command on mt7990.

Signed-off-by: Benjamin Lin <benjamin-jw.lin@mediatek.com>

Set the default value of eht_cap, fips_cap & pwr_boost_cap to true when
the hw cap is not written in efuse

Signed-off-by: StanleyYP Wang <StanleyYP.Wang@mediatek.com>
---
 mt7996/eeprom.c |  19 ++-
 mt7996/mac.c    |   2 +
 mt7996/main.c   |   1 +
 mt7996/mcu.c    | 326 ++++++++++++++++++++++++++++++++++++++----------
 mt7996/mcu.h    |  32 ++++-
 mt7996/mmio.c   |  28 ++++-
 mt7996/mt7996.h |   4 +
 mt7996/pci.c    |   5 +-
 mt7996/vendor.c |  10 +-
 9 files changed, 353 insertions(+), 74 deletions(-)

diff --git a/mt7996/eeprom.c b/mt7996/eeprom.c
index e35e46be9..e5fbfe766 100644
--- a/mt7996/eeprom.c
+++ b/mt7996/eeprom.c
@@ -377,6 +377,8 @@ static int mt7996_eeprom_parse_efuse_hw_cap(struct mt7996_phy *phy,
 					    u8 *path, u8 *rx_path, u8 *nss)
 {
 #define MODE_HE_ONLY		BIT(0)
+#define PWR_BOOST_CAP		BIT(7)
+#define FIPS_CAP		BIT(8)
 #define WTBL_SIZE_GROUP		GENMASK(31, 28)
 #define STREAM_CAP(_offs)	((cap & (0x7 << (_offs))) >> (_offs))
 	struct mt7996_dev *dev = phy->dev;
@@ -387,8 +389,6 @@ static int mt7996_eeprom_parse_efuse_hw_cap(struct mt7996_phy *phy,
 	if (ret)
 		return ret;
 
-	/* for internal development */
-	dev->has_eht = true;
 	if (cap) {
 		u8 band_offs = phy->mt76->band_idx * 3;
 
@@ -397,6 +397,18 @@ static int mt7996_eeprom_parse_efuse_hw_cap(struct mt7996_phy *phy,
 		*nss = min_t(u8, *nss, STREAM_CAP(1 + band_offs));
 		*path = min_t(u8, *path, STREAM_CAP(10 + band_offs));
 		*rx_path = min_t(u8, *rx_path, STREAM_CAP(19 + band_offs));
+
+		if (is_mt7990(&dev->mt76)) {
+			dev->pwr_boost_cap = !!(cap & PWR_BOOST_CAP);
+			dev->fips_cap = !!(cap & FIPS_CAP);
+		}
+	} else {
+		/* for internal RFB without efuse hw cap */
+		dev->has_eht = true;
+		if (is_mt7990(&dev->mt76)) {
+			dev->pwr_boost_cap = true;
+			dev->fips_cap = true;
+		}
 	}
 
 	if (dev->wtbl_size_group < 2 || dev->wtbl_size_group > 4)
@@ -649,7 +661,8 @@ bool mt7996_eeprom_has_background_radar(struct mt7996_dev *dev)
 			return false;
 		break;
 	case MT7992_DEVICE_ID:
-		if (dev->var.type == MT7992_VAR_TYPE_23)
+		if (dev->var.type == MT7992_VAR_TYPE_23 ||
+		    dev->var.type == MT7992_VAR_TYPE_24)
 			return false;
 		break;
 	case MT7990_DEVICE_ID: {
diff --git a/mt7996/mac.c b/mt7996/mac.c
index e6dfce313..96bf3c074 100644
--- a/mt7996/mac.c
+++ b/mt7996/mac.c
@@ -3029,6 +3029,8 @@ void mt7996_mac_work(struct work_struct *work)
 				mt7996_mcu_get_all_sta_info(mdev, UNI_ALL_STA_TX_STAT);
 				mt7996_mcu_get_all_sta_info(mdev, UNI_ALL_STA_DATA_TX_RETRY_COUNT);
 
+				mt7996_mcu_get_bss_acq_pkt_cnt(phy->dev);
+
 				if (mphy->mac_work_count % 100 == 0) {
 					if (phy->dev->idxlog_enable && mt7996_mcu_fw_time_sync(mdev))
 						dev_err(mdev->dev, "Failed to synchronize time with FW.\n");
diff --git a/mt7996/main.c b/mt7996/main.c
index 84c250774..a9258b41f 100644
--- a/mt7996/main.c
+++ b/mt7996/main.c
@@ -2555,6 +2555,7 @@ mt7996_background_radar_handle_7975_ifem(struct ieee80211_hw *hw,
 		is_ifem_adie = dev->var.type == MT7992_VAR_TYPE_44 &&
 			       dev->var.fem != MT7996_FEM_EXT;
 		break;
+	case MT7990_DEVICE_ID:
 	default:
 		return;
 	}
diff --git a/mt7996/mcu.c b/mt7996/mcu.c
index 154d8bbac..6ceb1d404 100644
--- a/mt7996/mcu.c
+++ b/mt7996/mcu.c
@@ -1239,38 +1239,53 @@ void mt7996_mcu_wmm_pbc_work(struct work_struct *work)
 #define WMM_PBC_LOW_BOUND_BK	900
 #define WMM_PBC_LOW_BOUND_MGMT	32
 	struct mt7996_dev *dev = container_of(work, struct mt7996_dev, wmm_pbc_work);
+
 	struct {
-		u8 bss_idx;
-		u8 queue_num;
-		__le16 wlan_idx;
-		u8 band_idx;
-		u8 __rsv[3];
+		u8 _rsv[4];
+
+		__le16 tag;
+		__le16 len;
+
 		struct {
-			__le16 low;
-			__le16 up;
-		} __packed bound[WMM_PBC_QUEUE_NUM];
+			u8 bss_idx;
+			u8 queue_num;
+			__le16 wlan_idx;
+			u8 band_idx;
+			u8 __rsv[3];
+			struct {
+				__le16 low;
+				__le16 up;
+			} __packed bound[WMM_PBC_QUEUE_NUM];
+		} __packed data;
 	} __packed req = {
-		.bss_idx = WMM_PBC_BSS_ALL,
-		.queue_num = WMM_PBC_QUEUE_NUM,
-		.wlan_idx = cpu_to_le16(WMM_PBC_WLAN_IDX_ALL),
-		.band_idx = dev->mphy.band_idx,
+		.tag = cpu_to_le16(UNI_CMD_SDO_PKT_BUDGET_CTRL_CFG),
+		.len = cpu_to_le16(sizeof(req) - 4),
+		.data.bss_idx = WMM_PBC_BSS_ALL,
+		.data.queue_num = WMM_PBC_QUEUE_NUM,
+		.data.wlan_idx = cpu_to_le16(WMM_PBC_WLAN_IDX_ALL),
+		.data.band_idx = dev->mphy.band_idx,
 	};
 	int i, ret;
 
-#define pbc_acq_low_bound_config(_ac, _bound)								\
-	req.bound[mt76_connac_lmac_mapping(_ac)].low = dev->wmm_pbc_enable ? cpu_to_le16(_bound) : 0
+#define pbc_acq_low_bound_config(_ac, _bound)						\
+	req.data.bound[mt76_connac_lmac_mapping(_ac)].low = dev->wmm_pbc_enable ?	\
+							    cpu_to_le16(_bound) : 0
 	pbc_acq_low_bound_config(IEEE80211_AC_VO, WMM_PBC_LOW_BOUND_VO);
 	pbc_acq_low_bound_config(IEEE80211_AC_VI, WMM_PBC_LOW_BOUND_VI);
 	pbc_acq_low_bound_config(IEEE80211_AC_BE, WMM_PBC_LOW_BOUND_BE);
 	pbc_acq_low_bound_config(IEEE80211_AC_BK, WMM_PBC_LOW_BOUND_BK);
-	req.bound[4].low = dev->wmm_pbc_enable
-	                   ? cpu_to_le16(WMM_PBC_LOW_BOUND_MGMT) : 0;
+	req.data.bound[4].low = dev->wmm_pbc_enable ?
+				cpu_to_le16(WMM_PBC_LOW_BOUND_MGMT) : 0;
 
 	for (i = 0; i < WMM_PBC_QUEUE_NUM; ++i)
-		req.bound[i].up = cpu_to_le16(WMM_PBC_BOUND_DEFAULT);
+		req.data.bound[i].up = cpu_to_le16(WMM_PBC_BOUND_DEFAULT);
 
-	ret = mt76_mcu_send_msg(&dev->mt76, MCU_WA_EXT_CMD(PKT_BUDGET_CTRL),
-	                        &req, sizeof(req), true);
+	if (is_mt7990(&dev->mt76))
+		ret = mt76_mcu_send_msg(&dev->mt76, MCU_WA_UNI_CMD(SDO),
+					 &req, sizeof(req), false);
+	else
+		ret = mt76_mcu_send_msg(&dev->mt76, MCU_WA_EXT_CMD(PKT_BUDGET_CTRL),
+					&req.data, sizeof(req.data), true);
 	if (ret)
 		dev_err(dev->mt76.dev, "Failed to configure WMM PBC.\n");
 }
@@ -1469,6 +1484,60 @@ mt7996_mcu_pp_event(struct mt7996_dev *dev, struct sk_buff *skb)
 	}
 }
 
+static void
+mt7996_mcu_uni_bss_acq_pkt_cnt(struct mt7996_dev *dev, struct tlv *tlv)
+{
+	struct mt7996_mld_sdo_bss_acq_pkt_cnt *data =
+		(struct mt7996_mld_sdo_bss_acq_pkt_cnt *)tlv->data;
+	u64 sum[IEEE80211_NUM_ACS] = {0};
+	u8 ac_cnt = 0;
+	int i, j;
+
+	for (i = 0; i < UNI_CMD_SDO_CFG_BSS_NUM; i++) {
+		for (j = IEEE80211_AC_VO; j < IEEE80211_NUM_ACS; j++)
+			sum[j] += le32_to_cpu(data->pkt_cnt[i][mt76_connac_lmac_mapping(j)]);
+	}
+
+	for (i = IEEE80211_AC_VO; i < IEEE80211_NUM_ACS; i++) {
+		if (sum[i] > WMM_PKT_THRESHOLD)
+			ac_cnt++;
+	}
+
+	if (ac_cnt > 1 && !dev->wmm_pbc_enable) {
+		dev->wmm_pbc_enable = true;
+		queue_work(dev->mt76.wq, &dev->wmm_pbc_work);
+	} else if (ac_cnt <= 1 && dev->wmm_pbc_enable) {
+		dev->wmm_pbc_enable = false;
+		queue_work(dev->mt76.wq, &dev->wmm_pbc_work);
+	}
+}
+
+static void
+mt7996_mcu_sdo_event(struct mt7996_dev *dev, struct sk_buff *skb)
+{
+	struct mt7996_mcu_sdo_event *event = (void *)skb->data;
+	struct tlv *tlv;
+	int len;
+
+	skb_pull(skb, sizeof(*event));
+	tlv = (struct tlv *)skb->data;
+	len = skb->len;
+
+	while (len > 0 && le16_to_cpu(tlv->len) <= len) {
+		switch (le16_to_cpu(tlv->tag)) {
+		case UNI_EVENT_SDO_BSS_ACQ_PKT_CNT:
+			mt7996_mcu_uni_bss_acq_pkt_cnt(dev, tlv);
+			break;
+		default:
+			break;
+		}
+
+		len -= le16_to_cpu(tlv->len);
+		tlv = (struct tlv *)((u8 *)(tlv) + le16_to_cpu(tlv->len));
+	}
+
+}
+
 static void
 mt7996_mcu_bss_bcn_crit_finish(void *priv, u8 *mac, struct ieee80211_vif *vif)
 {
@@ -1547,6 +1616,9 @@ mt7996_mcu_uni_rx_unsolicited_event(struct mt7996_dev *dev, struct sk_buff *skb)
 	case MCU_UNI_EVENT_PP:
 		mt7996_mcu_pp_event(dev, skb);
 		break;
+	case MCU_UNI_EVENT_SDO:
+		mt7996_mcu_sdo_event(dev, skb);
+		break;
 	case MCU_UNI_EVENT_BSS_INFO:
 		mt7996_mcu_bss_event(dev, skb);
 		break;
@@ -2088,7 +2160,7 @@ int mt7996_mcu_set_timing(struct mt7996_phy *phy, struct ieee80211_vif *vif,
 	mt7996_mcu_bss_ifs_timing_tlv(skb, phy);
 
 	return mt76_mcu_skb_send_msg(&dev->mt76, skb,
-				     MCU_WMWA_UNI_CMD(BSS_INFO_UPDATE), true);
+				     MCU_WM_UNI_CMD(BSS_INFO_UPDATE), true);
 }
 
 static int
@@ -4039,7 +4111,7 @@ int mt7996_mcu_beacon_inband_discov(struct mt7996_dev *dev,
 	dev_kfree_skb(skb);
 
 	return mt76_mcu_skb_send_msg(&dev->mt76, rskb,
-				     MCU_WMWA_UNI_CMD(BSS_INFO_UPDATE), true);
+				     MCU_WM_UNI_CMD(BSS_INFO_UPDATE), true);
 }
 
 static int mt7996_driver_own(struct mt7996_dev *dev, u8 band)
@@ -4366,7 +4438,7 @@ int mt7996_mcu_fw_log_2_host(struct mt7996_dev *dev, u8 type, u8 ctrl)
 		.ctrl = ctrl,
 	};
 
-	if (type == MCU_FW_LOG_WA)
+	if (type == MCU_FW_LOG_WA && mt7996_has_wa(dev))
 		return mt76_mcu_send_msg(&dev->mt76, MCU_WA_UNI_CMD(WSYS_CONFIG),
 					 &data, sizeof(data), true);
 
@@ -4557,13 +4629,21 @@ out:
 
 static int mt7996_mcu_wa_red_config(struct mt7996_dev *dev)
 {
-#define RED_TOKEN_SRC_CNT	4
 #define RED_TOKEN_CONFIG	2
-	struct {
-		__le32 arg0;
-		__le32 arg1;
-		__le32 arg2;
+#define RED_TOKEN_SRC_CNT	4
+#define RED_MAX_BAND_CNT	4
+
+	struct mt7996_wa_params {
+		__le32 arg[3];
+	} __packed;
 
+	struct mt7996_red_config_hdr {
+		u8 rsv[4];
+		__le16 tag;
+		__le16 len;
+	} __packed;
+
+	struct mt7996_red_config {
 		u8 mode;
 		u8 version;
 		u8 _rsv[4];
@@ -4573,30 +4653,53 @@ static int mt7996_mcu_wa_red_config(struct mt7996_dev *dev)
 		__le16 priority_offset;
 		__le16 token_per_src[RED_TOKEN_SRC_CNT];
 		__le16 token_thr_per_src[RED_TOKEN_SRC_CNT];
+	} __packed;
+	struct mt7996_red_config *req;
+	void *data;
+	int ret, len = sizeof(struct mt7996_red_config);
+	u8 i;
 
-		u8 _rsv2[604];
-	} __packed req = {
-		.arg0 = cpu_to_le32(MCU_WA_PARAM_RED_CONFIG),
+	len += is_mt7990(&dev->mt76) ?
+		sizeof(struct mt7996_red_config_hdr) + 1120 :
+		sizeof(struct mt7996_wa_params) + 604;
 
-		.mode = RED_TOKEN_CONFIG,
-		.len = cpu_to_le16(sizeof(req) - sizeof(__le32) * 3),
+	data = kzalloc(len, GFP_KERNEL);
 
-		.tcp_offset = cpu_to_le16(200),
-		.priority_offset = cpu_to_le16(255),
-	};
-	u8 i;
+	if (is_mt7990(&dev->mt76)) {
+		struct mt7996_red_config_hdr *hdr = (struct mt7996_red_config_hdr *)data;
 
+		hdr->tag = cpu_to_le16(UNI_CMD_SDO_RED_SETTING);
+		hdr->len = cpu_to_le16(len - 4);
+		req = (struct mt7996_red_config *)(data + sizeof(*hdr));
+		req->len = cpu_to_le16(len - sizeof(*hdr));
+	} else {
+		struct mt7996_wa_params *param = (struct mt7996_wa_params *)data;
+
+		param->arg[0] = cpu_to_le32(MCU_WA_PARAM_RED_CONFIG);
+		req = (struct mt7996_red_config *)(data + sizeof(*param));
+		req->len = cpu_to_le16(len - sizeof(*param));
+	}
+
+	req->mode = RED_TOKEN_CONFIG;
+	req->tcp_offset = cpu_to_le16(200);
+	req->priority_offset = cpu_to_le16(255);
 	for (i = 0; i < RED_TOKEN_SRC_CNT; i++) {
-		req.token_per_src[i] = cpu_to_le16(MT7996_TOKEN_SIZE);
-		req.token_thr_per_src[i] = cpu_to_le16(MT7996_TOKEN_SIZE);
+		req->token_per_src[i] = cpu_to_le16(MT7996_TOKEN_SIZE);
+		req->token_thr_per_src[i] = cpu_to_le16(MT7996_TOKEN_SIZE);
 	}
 
-	if (!mtk_wed_device_active(&dev->mt76.mmio.wed))
-		req.token_per_src[RED_TOKEN_SRC_CNT - 1] =
-			cpu_to_le16(MT7996_SW_TOKEN_SIZE);
+	req->token_per_src[RED_TOKEN_SRC_CNT - 1] = dev->mt76.token_size;
 
-	return mt76_mcu_send_msg(&dev->mt76, MCU_WA_PARAM_CMD(SET),
-				 &req, sizeof(req), false);
+	if (is_mt7990(&dev->mt76))
+		ret = mt76_mcu_send_msg(&dev->mt76, MCU_WA_UNI_CMD(SDO), data,
+					len, false);
+	else
+		ret = mt76_mcu_send_msg(&dev->mt76, MCU_WA_PARAM_CMD(SET), data,
+					len, false);
+
+	kfree(data);
+
+	return ret;
 }
 
 int mt7996_mcu_red_config(struct mt7996_dev *dev, bool enable)
@@ -6364,7 +6467,7 @@ int mt7996_mcu_wtbl_update_hdr_trans(struct mt7996_dev *dev,
 	/* starec hdr trans */
 	mt7996_mcu_sta_hdr_trans_tlv(dev, skb, vif, &msta_link->wcid);
 	return mt76_mcu_skb_send_msg(&dev->mt76, skb,
-				     MCU_WMWA_UNI_CMD(STA_REC_UPDATE), true);
+				     MCU_WM_UNI_CMD(STA_REC_UPDATE), true);
 }
 
 int mt7996_mcu_ps_leave(struct mt7996_dev *dev, struct mt7996_vif_link *mconf,
@@ -6655,6 +6758,33 @@ int mt7996_mcu_get_all_sta_info(struct mt76_dev *dev, u16 tag)
 				 &req, sizeof(req), false);
 }
 
+int mt7996_mcu_get_bss_acq_pkt_cnt(struct mt7996_dev *dev)
+{
+	struct {
+		u8 _rsv[4];
+
+		__le16 tag;
+		__le16 len;
+
+		__le32 bitmap[UNI_CMD_SDO_CFG_BSS_MAP_WORDLEN];
+	} __packed req = {
+		.tag = cpu_to_le16(UNI_CMD_SDO_GET_BSS_ACQ_PKT_NUM),
+		.len = cpu_to_le16(sizeof(req) - 4),
+	};
+	int i = 0;
+
+	if (mt7996_has_wa(dev))
+		return mt7996_mcu_wa_cmd(dev, MCU_WA_PARAM_CMD(QUERY),
+			MCU_WA_PARAM_BSS_ACQ_PKT_CNT,
+			BSS_ACQ_PKT_CNT_BSS_BITMAP_ALL | BSS_ACQ_PKT_CNT_READ_CLR, 0);
+
+	for (i = 0; i < UNI_CMD_SDO_CFG_BSS_MAP_WORDLEN; i++)
+		req.bitmap[i] = cpu_to_le32(~0);
+
+	return mt76_mcu_send_msg(&dev->mt76, MCU_WA_UNI_CMD(SDO), &req,
+				 sizeof(req), false);
+}
+
 int mt7996_mcu_wed_rro_reset_sessions(struct mt7996_dev *dev, u16 id)
 {
 	struct {
@@ -7283,7 +7413,20 @@ int mt7996_mcu_set_pp_alg_ctrl(struct mt7996_phy *phy, u8 action)
 		__le16 len;
 
 		__le32 pp_timer_intv;
-		__le32 rsv2[14];
+		__le32 thr_x2_value;
+		__le32 thr_x2_shift;
+		__le32 thr_x3_value;
+		__le32 thr_x3_shift;
+		__le32 thr_x4_value;
+		__le32 thr_x4_shift;
+		__le32 thr_x5_value;
+		__le32 thr_x5_shift;
+		__le32 thr_x6_value;
+		__le32 thr_x6_shift;
+		__le32 thr_x7_value;
+		__le32 thr_x7_shift;
+		__le32 thr_x8_value;
+		__le32 thr_x8_shift;
 		u8 band_idx;
 		u8 pp_action;
 		u8 reset;
@@ -7292,12 +7435,53 @@ int mt7996_mcu_set_pp_alg_ctrl(struct mt7996_phy *phy, u8 action)
 		.tag = cpu_to_le16(UNI_CMD_PP_ALG_CTRL),
 		.len = cpu_to_le16(sizeof(req) - 4),
 
-		.pp_timer_intv = action == PP_ALG_SET_TIMER ? 2000 : 0,
+		.pp_timer_intv = 0,
+		.thr_x2_value = 0,
+		.thr_x2_shift = 0,
+		.thr_x3_value = 0,
+		.thr_x3_shift = 0,
+		.thr_x4_value = 0,
+		.thr_x4_shift = 0,
+		.thr_x5_value = 0,
+		.thr_x5_shift = 0,
+		.thr_x6_value = 0,
+		.thr_x6_shift = 0,
+		.thr_x7_value = 0,
+		.thr_x7_shift = 0,
+		.thr_x8_value = 0,
+		.thr_x8_shift = 0,
 		.band_idx = phy->mt76->band_idx,
 		.pp_action = action,
 		.reset = 0,
 	};
 
+	switch (action)
+	{
+	case PP_ALG_SET_TIMER:
+		req.pp_timer_intv = 5000;
+		break;
+	case PP_ALG_SET_THR:
+		req.thr_x2_value = 1;
+		req.thr_x2_shift = 0;
+		req.thr_x3_value = 5000000;
+		req.thr_x3_shift = 3;
+		req.thr_x4_value = 1;
+		req.thr_x4_shift = 1;
+		req.thr_x5_value = 1;
+		req.thr_x5_shift = 0;
+		req.thr_x6_value = 1;
+		req.thr_x6_shift = 3;
+		req.thr_x7_value = 1;
+		req.thr_x7_shift = 0;
+		req.thr_x8_value = 5000000;
+		req.thr_x8_shift = 2;
+		break;
+	case PP_ALG_GET_STATISTICS:
+		break;
+	default:
+		return 0;
+	}
+
 	return mt76_mcu_send_msg(&dev->mt76, MCU_WM_UNI_CMD(PP),
 				 &req, sizeof(req), false);
 }
@@ -8060,13 +8244,22 @@ int mt7996_mcu_set_qos_map(struct mt7996_dev *dev, struct ieee80211_vif *vif,
 {
 	struct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;
 	struct {
-		u8 bss_idx;
-		u8 qos_map_enable;
-		u8 __rsv[2];
-		s8 qos_map[IP_DSCP_NUM];
+		u8 _rsv[4];
+
+		__le16 tag;
+		__le16 len;
+
+		struct {
+			u8 bss_idx;
+			u8 qos_map_enable;
+			u8 __rsv[2];
+			s8 qos_map[IP_DSCP_NUM];
+		} data;
 	} __packed req = {
-		.bss_idx = link->mt76.idx,
-		.qos_map_enable = true,
+		.tag = cpu_to_le16(UNI_CMD_SDO_SET_QOS_MAP),
+		.len = cpu_to_le16(sizeof(req) - 4),
+		.data.bss_idx = link->mt76.idx,
+		.data.qos_map_enable = true,
 	};
 	s8 i;
 
@@ -8074,17 +8267,18 @@ int mt7996_mcu_set_qos_map(struct mt7996_dev *dev, struct ieee80211_vif *vif,
 	 * Three most significant bits of DSCP are used as UP.
 	 */
 	for (i = 0; i < IP_DSCP_NUM; ++i)
-		req.qos_map[i] = i >> 3;
+		req.data.qos_map[i] = i >> 3;
 
 	/* Recommended QoS map, defined in section 4 of RFC8325.
 	 * Used in cfg80211_classify8021d since kernel v6.8.
 	 */
-	req.qos_map[10] = req.qos_map[12] = req.qos_map[14] = req.qos_map[16] = 0;
-	req.qos_map[18] = req.qos_map[20] = req.qos_map[22] = 3;
-	req.qos_map[24] = 4;
-	req.qos_map[40] = 5;
-	req.qos_map[44] = req.qos_map[46] = 6;
-	req.qos_map[48] = 7;
+	req.data.qos_map[10] = req.data.qos_map[12] =
+			       req.data.qos_map[14] = req.data.qos_map[16] = 0;
+	req.data.qos_map[18] = req.data.qos_map[20] = req.data.qos_map[22] = 3;
+	req.data.qos_map[24] = 4;
+	req.data.qos_map[40] = 5;
+	req.data.qos_map[44] = req.data.qos_map[46] = 6;
+	req.data.qos_map[48] = 7;
 
 	/* User-defined QoS map */
 	if (usr_qos_map) {
@@ -8093,7 +8287,7 @@ int mt7996_mcu_set_qos_map(struct mt7996_dev *dev, struct ieee80211_vif *vif,
 			u8 high = usr_qos_map->up[i].high;
 
 			if (low < IP_DSCP_NUM && high < IP_DSCP_NUM && low <= high)
-				memset(req.qos_map + low, i, high - low + 1);
+				memset(req.data.qos_map + low, i, high - low + 1);
 		}
 
 		for (i = 0; i < usr_qos_map->num_des; ++i) {
@@ -8101,13 +8295,17 @@ int mt7996_mcu_set_qos_map(struct mt7996_dev *dev, struct ieee80211_vif *vif,
 			u8 up = usr_qos_map->dscp_exception[i].up;
 
 			if (dscp < IP_DSCP_NUM && up < IEEE80211_NUM_UPS)
-				req.qos_map[dscp] = up;
+				req.data.qos_map[dscp] = up;
 		}
 	}
 
-	memcpy(mvif->qos_map, req.qos_map, IP_DSCP_NUM);
+	memcpy(mvif->qos_map, req.data.qos_map, IP_DSCP_NUM);
 
-	return mt76_mcu_send_msg(&dev->mt76, MCU_WA_EXT_CMD(SET_QOS_MAP), &req,
-				 sizeof(req), false);
+	if (!mt7996_has_wa(dev))
+		return mt76_mcu_send_msg(&dev->mt76, MCU_WA_UNI_CMD(SDO),
+					 &req, sizeof(req), false);
+
+	return mt76_mcu_send_msg(&dev->mt76, MCU_WA_EXT_CMD(SET_QOS_MAP), &req.data,
+				 sizeof(req.data), false);
 }
 #endif
diff --git a/mt7996/mcu.h b/mt7996/mcu.h
index 61c6d7bca..639193ef3 100644
--- a/mt7996/mcu.h
+++ b/mt7996/mcu.h
@@ -1180,6 +1180,27 @@ struct mt7996_mcu_mac_info_tsf_diff {
 	u8 rsv[2];
 } __packed;
 
+struct mt7996_mcu_sdo_event {
+	struct mt7996_mcu_rxd rxd;
+
+	/* fixed field */
+	u8 rsv[4];
+	/* tlv */
+	u8 buf[];
+} __packed;
+
+#define UNI_CMD_SDO_CFG_BSS_NUM 96
+#define UNI_CMD_SDO_CFG_BSS_MAP_WORDLEN ((UNI_CMD_SDO_CFG_BSS_NUM + 31) / 32)
+
+struct mt7996_mld_sdo_bss_acq_pkt_cnt {
+	__le32 bitmap[UNI_CMD_SDO_CFG_BSS_MAP_WORDLEN];
+	__le32 pkt_cnt[UNI_CMD_SDO_CFG_BSS_NUM][IEEE80211_NUM_ACS];
+};
+
+enum {
+	UNI_EVENT_SDO_BSS_ACQ_PKT_CNT = 1,
+};
+
 struct mt7996_mcu_mac_info_event {
 	u8 rsv[4];
 	u8 buf[];
@@ -1415,7 +1436,14 @@ enum {
 enum {
 	UNI_CMD_SDO_SET = 1,
 	UNI_CMD_SDO_QUERY,
-	UNI_CMD_SDO_CP_MODE = 6,
+	UNI_CMD_SDO_AUTO_BA,
+	UNI_CMD_SDO_SET_QOS_MAP,
+	UNI_CMD_SDO_HOTSPOT,
+	UNI_CMD_SDO_CP_MODE,
+	UNI_CMD_SDO_RED_SETTING,
+	UNI_CMD_SDO_PKT_BUDGET_CTRL_CFG,
+	UNI_CMD_SDO_GET_BSS_ACQ_PKT_NUM,
+	UNI_CMD_SDO_OVERRIDE_CTRL
 };
 
 enum {
@@ -1441,7 +1469,7 @@ enum pp_mode {
 enum pp_alg_action {
 	PP_ALG_SET_TIMER,
 	PP_ALG_SET_THR,
-	PP_ALG_GET_STATISTICS = 2,
+	PP_ALG_GET_STATISTICS,
 };
 
 enum {
diff --git a/mt7996/mmio.c b/mt7996/mmio.c
index 15732fa42..c7e0d0bc9 100644
--- a/mt7996/mmio.c
+++ b/mt7996/mmio.c
@@ -60,6 +60,14 @@ static const u32 mt7996_offs[] = {
 	[MIB_BSCR7]		= 0x9e8,
 	[MIB_BSCR17]		= 0xa10,
 	[MIB_TRDR1]		= 0xa28,
+	[MIB_TSCR0]		= 0x6b0,
+	[MIB_TSCR1]		= 0x6b4,
+	[MIB_TSCR2]		= 0x6b8,
+	[MIB_TSCR3]		= 0x6bc,
+	[MIB_TSCR4]		= 0x6c0,
+	[MIB_TSCR5]		= 0x6c4,
+	[MIB_TSCR6]		= 0x6c8,
+	[MIB_TSCR7]		= 0x6d0,
 	[HIF_REMAP_L1]		= 0x24,
 	[HIF_REMAP_BASE_L1]	= 0x130000,
 	[HIF_REMAP_L2]		= 0x1b4,
@@ -97,6 +105,14 @@ static const u32 mt7992_offs[] = {
 	[MIB_BSCR7]		= 0xae4,
 	[MIB_BSCR17]		= 0xb0c,
 	[MIB_TRDR1]		= 0xb24,
+	[MIB_TSCR0]		= 0x6b0,
+	[MIB_TSCR1]		= 0x6b4,
+	[MIB_TSCR2]		= 0x6b8,
+	[MIB_TSCR3]		= 0x6bc,
+	[MIB_TSCR4]		= 0x6c0,
+	[MIB_TSCR5]		= 0x6c4,
+	[MIB_TSCR6]		= 0x6c8,
+	[MIB_TSCR7]		= 0x6d0,
 	[HIF_REMAP_L1]		= 0x8,
 	[HIF_REMAP_BASE_L1]	= 0x40000,
 	[HIF_REMAP_L2]		= 0x1b4,
@@ -134,6 +150,14 @@ static const u32 mt7990_offs[] = {
 	[MIB_BSCR7]		= 0xbd4,
 	[MIB_BSCR17]		= 0xbfc,
 	[MIB_TRDR1]		= 0xc14,
+	[MIB_TSCR0]		= 0x750,
+	[MIB_TSCR1]		= 0x754,
+	[MIB_TSCR2]		= 0x758,
+	[MIB_TSCR3]		= 0x75c,
+	[MIB_TSCR4]		= 0x760,
+	[MIB_TSCR5]		= 0x764,
+	[MIB_TSCR6]		= 0x768,
+	[MIB_TSCR7]		= 0x770,
 	[HIF_REMAP_L1]		= 0x8,
 	[HIF_REMAP_BASE_L1]	= 0x40000,
 	[HIF_REMAP_L2]		= 0x1b8,
@@ -660,10 +684,8 @@ int mt7996_mmio_wed_init(struct mt7996_dev *dev, void *pdev_ptr,
 			if (dev->hif2)
 				wed->wlan.id = MT7990_DEVICE_ID;
 		}
-		dev->mt76.rx_token_size = tx_token_size + rx_token_size;
 
-		if (dev->hif2 && is_mt7992(&dev->mt76))
-			wed->wlan.id = 0x7992;
+		dev->mt76.rx_token_size = tx_token_size + rx_token_size;
 	}
 
 	wed->wlan.nbuf = tx_token_size;
diff --git a/mt7996/mt7996.h b/mt7996/mt7996.h
index 4f68e7664..0cbadf7d3 100644
--- a/mt7996/mt7996.h
+++ b/mt7996/mt7996.h
@@ -826,6 +826,9 @@ struct mt7996_dev {
 	bool flash_mode:1;
 	bool has_eht:1;
 
+	bool fips_cap:1;
+	bool pwr_boost_cap:1;
+
 	struct {
 		struct {
 			void *ptr;
@@ -1247,6 +1250,7 @@ void mt7996_mcu_exit(struct mt7996_dev *dev);
 int mt7996_mcu_get_per_sta_info(struct mt76_dev *dev, u16 tag,
 	                        u16 sta_num, u16 *sta_list);
 int mt7996_mcu_get_all_sta_info(struct mt76_dev *dev, u16 tag);
+int mt7996_mcu_get_bss_acq_pkt_cnt(struct mt7996_dev *dev);
 int mt7996_mcu_wed_rro_reset_sessions(struct mt7996_dev *dev, u16 id);
 int mt7996_mcu_set_sniffer_mode(struct mt7996_phy *phy, bool enabled);
 int mt7996_mcu_set_dup_wtbl(struct mt7996_dev *dev);
diff --git a/mt7996/pci.c b/mt7996/pci.c
index b22d98ff2..c175eeb54 100644
--- a/mt7996/pci.c
+++ b/mt7996/pci.c
@@ -116,7 +116,10 @@ static int mt7996_pci_probe(struct pci_dev *pdev,
 	int irq, ret;
 	struct mt76_dev *mdev;
 
-	hif2_enable |= (id->device == 0x7990 || id->device == 0x7991 || id->device == 0x799a);
+	hif2_enable |= (id->device == MT7996_DEVICE_ID ||
+			id->device == MT7996_DEVICE_ID_2 ||
+			id->device == MT7992_DEVICE_ID_2 ||
+			id->device == MT7990_DEVICE_ID_2);
 
 	ret = pcim_enable_device(pdev);
 	if (ret)
diff --git a/mt7996/vendor.c b/mt7996/vendor.c
index b0c59060a..5ee23e53d 100644
--- a/mt7996/vendor.c
+++ b/mt7996/vendor.c
@@ -963,11 +963,19 @@ static int mt7996_vendor_pp_ctrl(struct wiphy *wiphy, struct wireless_dev *wdev,
 		return 0;
 
 	switch (mode) {
+	case PP_FW_MODE:
+		err = mt7996_mcu_set_pp_alg_ctrl(phy, PP_ALG_SET_TIMER);
+		if (err)
+			return err;
+
+		err = mt7996_mcu_set_pp_alg_ctrl(phy, PP_ALG_SET_THR);
+		if (err)
+			return err;
+		fallthrough;
 	case PP_USR_MODE:
 		if (tb[MTK_VENDOR_ATTR_PP_BITMAP])
 			punct_bitmap = nla_get_u16(tb[MTK_VENDOR_ATTR_PP_BITMAP]);
 		fallthrough;
-	case PP_FW_MODE:
 	case PP_DISABLE:
 		err = mt7996_mcu_set_pp_en(phy, mode, punct_bitmap);
 		break;
-- 
2.45.2

