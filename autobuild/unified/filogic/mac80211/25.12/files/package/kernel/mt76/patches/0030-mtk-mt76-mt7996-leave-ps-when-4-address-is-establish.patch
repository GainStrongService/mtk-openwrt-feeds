From f23b79ef9c0ac75ad868a8bf5a7daf66ccf6c008 Mon Sep 17 00:00:00 2001
From: Peter Chiu <chui-hao.chiu@mediatek.com>
Date: Thu, 18 Jul 2024 10:29:22 +0800
Subject: [PATCH 030/105] mtk: mt76: mt7996: leave ps when 4 address is
 established

Because the 4 address non-amsdu packet does not have bssid field, the
hardware cannot get the bssid. Without bssid, the station's are not able
leave PS mode due to HW design. Wake up non-setup link when receiving
4 address null data to prevent this issue.

Signed-off-by: Peter Chiu <chui-hao.chiu@mediatek.com>
---
 mt76_connac_mcu.h |  1 +
 mt7996/main.c     |  3 +++
 mt7996/mcu.c      | 18 ++++++++++++++++++
 mt7996/mcu.h      |  6 ++++++
 mt7996/mt7996.h   |  2 ++
 5 files changed, 30 insertions(+)

diff --git a/mt76_connac_mcu.h b/mt76_connac_mcu.h
index 8d59cf43f..175ec5e00 100644
--- a/mt76_connac_mcu.h
+++ b/mt76_connac_mcu.h
@@ -833,6 +833,7 @@ enum {
 	STA_REC_KEY_V3 = 0x27,
 	STA_REC_HDRT = 0x28,
 	STA_REC_HDR_TRANS = 0x2B,
+	STA_REC_PS_LEAVE = 0x45,
 	STA_REC_MAX_NUM
 };
 
diff --git a/mt7996/main.c b/mt7996/main.c
index 48c19614f..92638dea1 100644
--- a/mt7996/main.c
+++ b/mt7996/main.c
@@ -1869,6 +1869,9 @@ static void mt7996_sta_set_4addr(struct ieee80211_hw *hw,
 			continue;
 
 		mt7996_mcu_wtbl_update_hdr_trans(dev, vif, link, msta_link);
+
+		if (msta->deflink_id != link_id && is_mt7996(&dev->mt76))
+			mt7996_mcu_ps_leave(dev, link, msta_link);
 	}
 
 	mutex_unlock(&dev->mt76.mutex);
diff --git a/mt7996/mcu.c b/mt7996/mcu.c
index d058f484d..0e458709d 100644
--- a/mt7996/mcu.c
+++ b/mt7996/mcu.c
@@ -4786,6 +4786,24 @@ int mt7996_mcu_wtbl_update_hdr_trans(struct mt7996_dev *dev,
 				     MCU_WMWA_UNI_CMD(STA_REC_UPDATE), true);
 }
 
+int mt7996_mcu_ps_leave(struct mt7996_dev *dev, struct mt7996_vif_link *mconf,
+			struct mt7996_sta_link *msta_link)
+{
+	struct sk_buff *skb;
+
+	skb = __mt76_connac_mcu_alloc_sta_req(&dev->mt76, &mconf->mt76,
+					      &msta_link->wcid,
+					      MT7996_STA_UPDATE_MAX_SIZE);
+	if (IS_ERR(skb))
+		return PTR_ERR(skb);
+
+	mt76_connac_mcu_add_tlv(skb, STA_REC_PS_LEAVE,
+				sizeof(struct sta_rec_ps_leave));
+
+	return mt76_mcu_skb_send_msg(&dev->mt76, skb,
+				     MCU_WMWA_UNI_CMD(STA_REC_UPDATE), true);
+}
+
 int mt7996_mcu_set_fixed_rate_table(struct mt7996_phy *phy, u8 table_idx,
 				    u16 rate_idx, bool beacon)
 {
diff --git a/mt7996/mcu.h b/mt7996/mcu.h
index dabe84e74..f8bd1abfb 100644
--- a/mt7996/mcu.h
+++ b/mt7996/mcu.h
@@ -625,6 +625,12 @@ struct sta_rec_hdr_trans {
 	u8 mesh;
 } __packed;
 
+struct sta_rec_ps_leave {
+	__le16 tag;
+	__le16 len;
+	u8 __rsv[4];
+} __packed;
+
 struct sta_rec_mld_setup {
 	__le16 tag;
 	__le16 len;
diff --git a/mt7996/mt7996.h b/mt7996/mt7996.h
index a2e8a53cf..827d92f35 100644
--- a/mt7996/mt7996.h
+++ b/mt7996/mt7996.h
@@ -867,6 +867,8 @@ int mt7996_mcu_wtbl_update_hdr_trans(struct mt7996_dev *dev,
 				     struct ieee80211_vif *vif,
 				     struct mt7996_vif_link *link,
 				     struct mt7996_sta_link *msta_link);
+int mt7996_mcu_ps_leave(struct mt7996_dev *dev, struct mt7996_vif_link *mconf,
+			struct mt7996_sta_link *msta_link);
 int mt7996_mcu_cp_support(struct mt7996_dev *dev, u8 mode);
 #ifdef CONFIG_MAC80211_DEBUGFS
 void mt7996_sta_add_debugfs(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
-- 
2.45.2

