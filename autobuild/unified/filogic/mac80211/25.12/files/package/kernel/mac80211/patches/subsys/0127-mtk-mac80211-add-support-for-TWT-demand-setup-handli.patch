From c8ba280f49a53823aa254ca2c6a295e139fb2ef1 Mon Sep 17 00:00:00 2001
From: Howard Hsu <howard-yh.hsu@mediatek.com>
Date: Fri, 5 Sep 2025 11:09:04 +0800
Subject: [PATCH 127/128] mtk: mac80211: add support for TWT demand setup
 handling

Add support for processing TWT demand setup frames.
When receiving broadcast TWT setup with demand command, extract
parameters, create TWT schedule via driver, and notify userspace.

Extends cfg80211 with new RTWT attributes and notification mechanism
to coordinate TWT schedules between kernel and hostapd.

Signed-off-by: Howard Hsu <howard-yh.hsu@mediatek.com>
---
 include/linux/ieee80211-he.h | 18 ++++++-
 include/net/cfg80211.h       | 18 +++++++
 include/uapi/linux/nl80211.h |  2 +
 net/mac80211/s1g.c           | 95 +++++++++++++++++++++++++++++++++---
 net/wireless/nl80211.c       | 89 +++++++++++++++++++++++++++++++++
 5 files changed, 213 insertions(+), 9 deletions(-)

diff --git a/include/linux/ieee80211-he.h b/include/linux/ieee80211-he.h
index 8882e987..ee89f8a2 100644
--- a/include/linux/ieee80211-he.h
+++ b/include/linux/ieee80211-he.h
@@ -39,11 +39,20 @@
 #define IEEE80211_TWT_REQTYPE_PROTECTION		BIT(15)
 
 #define IEEE80211_TWT_REQTYPE_LAST_BCAST_PARAM		BIT(5)
-#define IEEE80211_TWT_REQTYPE_RECM			GENMASK(9, 7)
+#define IEEE80211_TWT_REQTYPE_BTWT_RECM			GENMASK(9, 7)
 
+#define IEEE80211_BTWT_RTWT_INFO_PRESENT		BIT(0)
 #define IEEE80211_BTWT_INFO_ID				GENMASK(7, 3)
 #define IEEE80211_BTWT_INFO_PERSISTENCE			GENMASK(15, 8)
 
+#define IEEE80211_RTWT_INFO_DL_TID_BMP_VALID		BIT(0)
+#define IEEE80211_RTWT_INFO_UL_TID_BMP_VALID		BIT(1)
+
+enum ieee80211_twt_request {
+	TWT_RESPONDING_OR_SCHEDULING_STA,
+	TWT_REQUESTING_OR_SCHEDULED_STA,
+};
+
 enum ieee80211_twt_setup_cmd {
 	TWT_SETUP_CMD_REQUEST,
 	TWT_SETUP_CMD_SUGGEST,
@@ -55,6 +64,12 @@ enum ieee80211_twt_setup_cmd {
 	TWT_SETUP_CMD_REJECT,
 };
 
+struct ieee80211_rtwt_info {
+	u8 info_ctrl;
+	u8 dl_tid_bmp;
+	u8 ul_tid_bmp;
+} __packed;
+
 struct ieee80211_twt_params {
 	__le16 req_type;
 	union {
@@ -69,6 +84,7 @@ struct ieee80211_twt_params {
 			u8 min_twt_dur;
 			__le16 mantissa;
 			__le16 btwt_info;
+			struct ieee80211_rtwt_info rtwt;
 		} __packed bcast;
 	};
 } __packed;
diff --git a/include/net/cfg80211.h b/include/net/cfg80211.h
index 8d5f0970..8e8a26fb 100644
--- a/include/net/cfg80211.h
+++ b/include/net/cfg80211.h
@@ -316,6 +316,8 @@ struct ieee80211_rate {
  * @recommendation: recommendations on the types of frames to be transmitted
  * @persist: number of TBTTs during which the Broadcast TWT SPs corresponding
  *	to this broadcast TWT Parameter set are present
+ * @dl_tid_bmp: latency sensitive traffic streams in the DL direction.
+ * @ul_tid_bmp: latency sensitive traffic streams in the UL direction.
  */
 struct cfg80211_broadcast_twt_settings {
 	u8 id;
@@ -327,6 +329,8 @@ struct cfg80211_broadcast_twt_settings {
 	bool flow_type;
 	u8 recommendation;
 	u8 persist;
+	u8 dl_tid_bmp;
+	u8 ul_tid_bmp;
 };
 
 /**
@@ -10245,6 +10249,20 @@ void cfg80211_attlm_notify(struct wireless_dev *wdev, u16 switch_time_tsf_tu,
 void cfg80211_tsf_offset_notify(struct wireless_dev *wdev, unsigned int link_id,
 				s64 *tsf_offset, size_t len, gfp_t gfp);
 
+/**
+ * cfg80211_btwt_demand_sched_notify - notify about broadcast TWT settings
+ * @dev: network device
+ * @settings: broadcast TWT parameters
+ * @gfp: allocation flags
+ *
+ * This sends a kernel-to-userspace NL80211 notification containing
+ * NL80211_ATTR_BROADCAST_TWT_PARAMS to inform user space about a
+ * broadcast TWT setup discovered/derived in kernel
+ */
+void cfg80211_btwt_demand_sched_notify(struct net_device *dev,
+				       struct cfg80211_broadcast_twt_settings *settings,
+				       gfp_t gfp);
+
 /**
  * cfg80211_obss_color_collision_notify - notify about bss color collision
  * @dev: network device
diff --git a/include/uapi/linux/nl80211.h b/include/uapi/linux/nl80211.h
index 353ec69d..6e3fd1a2 100644
--- a/include/uapi/linux/nl80211.h
+++ b/include/uapi/linux/nl80211.h
@@ -8578,6 +8578,8 @@ enum nl80211_broadcast_twt_attributes {
 	NL80211_BROADCAST_TWT_ATTR_FLOW_TYPE,
 	NL80211_BROADCAST_TWT_ATTR_RECOMMENDATION,
 	NL80211_BROADCAST_TWT_ATTR_PERSISTENCE,
+	NL80211_BROADCAST_TWT_ATTR_DL_TID_BMP,
+	NL80211_BROADCAST_TWT_ATTR_UL_TID_BMP,
 
 	/* keep last */
 	__NL80211_BROADCAST_TWT_ATTR_LAST,
diff --git a/net/mac80211/s1g.c b/net/mac80211/s1g.c
index dc752147..ab87d19a 100644
--- a/net/mac80211/s1g.c
+++ b/net/mac80211/s1g.c
@@ -94,6 +94,71 @@ ieee80211_s1g_send_twt_teardown(struct ieee80211_sub_if_data *sdata,
 	ieee80211_tx_skb(sdata, skb);
 }
 
+static int
+ieee80211_s1g_handle_twt_demand_setup(struct ieee80211_sub_if_data *sdata,
+				      struct sk_buff *skb)
+{
+	const size_t fixed_len = offsetof(struct ieee80211_twt_params, bcast.rtwt);
+	struct ieee80211_mgmt *mgmt = (void *)skb->data;
+	struct ieee80211_twt_setup *twt = (void *)mgmt->u.action.u.s1g.variable;
+	struct ieee80211_twt_params *twt_agrt = (void *)twt->params;
+	struct cfg80211_broadcast_twt_settings settings;
+	size_t remaining_len;
+	int ret;
+
+	remaining_len = skb->len - ((u8 *)twt_agrt - skb->data);
+	if (remaining_len < fixed_len)
+		return -EINVAL;
+
+	memset(&settings, 0, sizeof(settings));
+
+	settings.min_wake_dur = twt_agrt->bcast.min_twt_dur;
+	settings.wake_intv_mantissa = le16_to_cpu(twt_agrt->bcast.mantissa);
+	settings.wake_intv_exp = le16_get_bits(twt_agrt->req_type,
+					       IEEE80211_TWT_REQTYPE_WAKE_INT_EXP);
+	settings.trigger = le16_get_bits(twt_agrt->req_type,
+					 IEEE80211_TWT_REQTYPE_TRIGGER);
+	settings.flow_type = le16_get_bits(twt_agrt->req_type,
+					   IEEE80211_TWT_REQTYPE_FLOWTYPE);
+	settings.recommendation = le16_get_bits(twt_agrt->req_type,
+						IEEE80211_TWT_REQTYPE_BTWT_RECM);
+	settings.setup_cmd = le16_get_bits(twt_agrt->req_type,
+					   IEEE80211_TWT_REQTYPE_SETUP_CMD);
+
+	if (le16_get_bits(twt_agrt->bcast.btwt_info,
+			  IEEE80211_BTWT_RTWT_INFO_PRESENT)) {
+		if (remaining_len < fixed_len + sizeof(struct ieee80211_rtwt_info))
+			return -EINVAL;
+
+		if (FIELD_GET(IEEE80211_RTWT_INFO_DL_TID_BMP_VALID,
+			      twt_agrt->bcast.rtwt.info_ctrl))
+			settings.dl_tid_bmp = twt_agrt->bcast.rtwt.dl_tid_bmp;
+
+		if (FIELD_GET(IEEE80211_RTWT_INFO_UL_TID_BMP_VALID,
+			      twt_agrt->bcast.rtwt.info_ctrl))
+			settings.ul_tid_bmp = twt_agrt->bcast.rtwt.ul_tid_bmp;
+	}
+
+	if ((sdata->deflink.btwt_active_bitmap | BIT(0)) == ~0U)
+		return -ENOSPC;
+
+	settings.id = ffz(sdata->deflink.btwt_active_bitmap | BIT(0));
+
+	ret = drv_add_btwt(sdata->local, sdata, &settings);
+	if (ret)
+		return ret;
+
+	sdata->deflink.btwt_active_bitmap |= BIT(settings.id);
+	le16p_replace_bits(&twt_agrt->bcast.btwt_info, settings.id,
+			   IEEE80211_BTWT_INFO_ID);
+	le16p_replace_bits(&twt_agrt->bcast.btwt_info, settings.persist,
+			   IEEE80211_BTWT_INFO_PERSISTENCE);
+
+	cfg80211_btwt_demand_sched_notify(sdata->dev, &settings, GFP_KERNEL);
+
+	return 0;
+}
+
 static void
 ieee80211_s1g_rx_twt_setup(struct ieee80211_sub_if_data *sdata,
 			   struct sta_info *sta, struct sk_buff *skb)
@@ -101,19 +166,33 @@ ieee80211_s1g_rx_twt_setup(struct ieee80211_sub_if_data *sdata,
 	struct ieee80211_mgmt *mgmt = (void *)skb->data;
 	struct ieee80211_twt_setup *twt = (void *)mgmt->u.action.u.s1g.variable;
 	struct ieee80211_twt_params *twt_agrt = (void *)twt->params;
+	int ret;
+
+	if (twt->control & IEEE80211_TWT_CONTROL_NEG_TYPE_BROADCAST &&
+	    (le16_get_bits(twt_agrt->req_type, IEEE80211_TWT_REQTYPE_SETUP_CMD) ==
+	     TWT_SETUP_CMD_DEMAND)) {
+		ret = ieee80211_s1g_handle_twt_demand_setup(sdata, skb);
+		if (ret) {
+			le16p_replace_bits(&twt_agrt->req_type, TWT_SETUP_CMD_REJECT,
+					   IEEE80211_TWT_REQTYPE_SETUP_CMD);
+			pr_info("%s: Handle TWT demand failed: %d\n", __func__, ret);
+			goto send_rsp;
+		}
+	}
 
-	twt_agrt->req_type &= ~cpu_to_le16(IEEE80211_TWT_REQTYPE_REQUEST);
+	ret = drv_add_twt_setup(sdata->local, sdata, &sta->sta, twt);
+	if (ret) {
+		le16p_replace_bits(&twt_agrt->req_type, TWT_SETUP_CMD_REJECT,
+				   IEEE80211_TWT_REQTYPE_SETUP_CMD);
+		pr_info("%s: Handle add twt setup failed: %d\n", __func__, ret);
+	}
 
+send_rsp:
+	le16p_replace_bits(&twt_agrt->req_type, TWT_RESPONDING_OR_SCHEDULING_STA,
+			   IEEE80211_TWT_REQTYPE_REQUEST);
 	/* TWT Information not supported yet */
 	twt->control |= IEEE80211_TWT_CONTROL_RX_DISABLED;
 
-	if (drv_add_twt_setup(sdata->local, sdata, &sta->sta, twt)) {
-		twt_agrt->req_type &= ~cpu_to_le16(IEEE80211_TWT_REQTYPE_SETUP_CMD);
-		twt_agrt->req_type |=
-			le16_encode_bits(TWT_SETUP_CMD_REJECT,
-					 IEEE80211_TWT_REQTYPE_SETUP_CMD);
-	}
-
 	ieee80211_s1g_send_twt_setup(sdata, mgmt->sa, sdata->vif.addr, twt);
 }
 
diff --git a/net/wireless/nl80211.c b/net/wireless/nl80211.c
index c1bc0530..ec304506 100644
--- a/net/wireless/nl80211.c
+++ b/net/wireless/nl80211.c
@@ -576,6 +576,8 @@ nl80211_broadcast_twt_policy[NL80211_BROADCAST_TWT_ATTR_MAX + 1] = {
 	[NL80211_BROADCAST_TWT_ATTR_FLOW_TYPE] = { .type = NLA_FLAG },
 	[NL80211_BROADCAST_TWT_ATTR_RECOMMENDATION] = NLA_POLICY_RANGE(NLA_U8, 0, 7),
 	[NL80211_BROADCAST_TWT_ATTR_PERSISTENCE] = { .type = NLA_U8 },
+	[NL80211_BROADCAST_TWT_ATTR_DL_TID_BMP] = { .type = NLA_U8 },
+	[NL80211_BROADCAST_TWT_ATTR_UL_TID_BMP] = { .type = NLA_U8 },
 };
 
 static const struct nla_policy nl80211_policy[NUM_NL80211_ATTR] = {
@@ -18100,6 +18102,12 @@ nl80211_add_broadcast_twt(struct sk_buff *skb, struct genl_info *info)
 	settings.persist =
 		nla_get_u8(tb[NL80211_BROADCAST_TWT_ATTR_PERSISTENCE]);
 
+	if (tb[NL80211_BROADCAST_TWT_ATTR_DL_TID_BMP])
+		settings.dl_tid_bmp = nla_get_u8(tb[NL80211_BROADCAST_TWT_ATTR_DL_TID_BMP]);
+
+	if (tb[NL80211_BROADCAST_TWT_ATTR_UL_TID_BMP])
+		settings.ul_tid_bmp = nla_get_u8(tb[NL80211_BROADCAST_TWT_ATTR_UL_TID_BMP]);
+
 	return rdev_add_btwt(rdev, dev, &settings);
 }
 
@@ -21487,6 +21495,87 @@ nla_put_failure:
 }
 EXPORT_SYMBOL(cfg80211_tsf_offset_notify);
 
+void cfg80211_btwt_demand_sched_notify(struct net_device *dev,
+				       struct cfg80211_broadcast_twt_settings *settings,
+				       gfp_t gfp)
+{
+	struct wireless_dev *wdev = dev->ieee80211_ptr;
+	struct sk_buff *msg;
+	struct nlattr *attr;
+	void *hdr;
+
+	msg = nlmsg_new(NLMSG_DEFAULT_SIZE, gfp);
+	if (!msg)
+		return;
+
+	hdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_ADD_BROADCAST_TWT);
+	if (!hdr) {
+		nlmsg_free(msg);
+		return;
+	}
+
+	if (nla_put_u32(msg, NL80211_ATTR_IFINDEX, dev->ifindex))
+		goto nla_put_failure;
+
+	attr = nla_nest_start_noflag(msg, NL80211_ATTR_BROADCAST_TWT_PARAMS);
+	if (!attr)
+		goto nla_put_failure;
+
+	if (nla_put_u8(msg, NL80211_BROADCAST_TWT_ATTR_ID, settings->id))
+		goto nla_put_failure;
+
+	if (nla_put_u8(msg, NL80211_BROADCAST_TWT_ATTR_MIN_WAKE_DUR,
+		       settings->min_wake_dur))
+		goto nla_put_failure;
+
+	if (nla_put_u16(msg, NL80211_BROADCAST_TWT_ATTR_MANTISSA,
+			settings->wake_intv_mantissa))
+		goto nla_put_failure;
+
+	if (nla_put_u8(msg, NL80211_BROADCAST_TWT_ATTR_EXPONENT,
+		       settings->wake_intv_exp))
+		goto nla_put_failure;
+
+	if (settings->trigger &&
+	    nla_put_flag(msg, NL80211_BROADCAST_TWT_ATTR_TRIGGER))
+		goto nla_put_failure;
+
+	if (settings->flow_type &&
+	    nla_put_flag(msg, NL80211_BROADCAST_TWT_ATTR_FLOW_TYPE))
+		goto nla_put_failure;
+
+	if (nla_put_u8(msg, NL80211_BROADCAST_TWT_ATTR_RECOMMENDATION,
+		       settings->recommendation))
+		goto nla_put_failure;
+
+	if (nla_put_u8(msg, NL80211_BROADCAST_TWT_ATTR_PERSISTENCE,
+		       settings->persist))
+		goto nla_put_failure;
+
+	if (settings->dl_tid_bmp &&
+	    nla_put_u8(msg, NL80211_BROADCAST_TWT_ATTR_DL_TID_BMP,
+		       settings->dl_tid_bmp))
+		goto nla_put_failure;
+
+	if (settings->ul_tid_bmp &&
+	    nla_put_u8(msg, NL80211_BROADCAST_TWT_ATTR_UL_TID_BMP,
+		       settings->ul_tid_bmp))
+		goto nla_put_failure;
+
+	nla_nest_end(msg, attr);
+
+	genlmsg_end(msg, hdr);
+
+	genlmsg_multicast_netns(&nl80211_fam, wiphy_net(wdev->wiphy), msg, 0,
+				NL80211_MCGRP_MLME, gfp);
+
+	return;
+
+nla_put_failure:
+	nlmsg_free(msg);
+}
+EXPORT_SYMBOL(cfg80211_btwt_demand_sched_notify);
+
 void
 nl80211_radar_notify(struct cfg80211_registered_device *rdev,
 		     const struct cfg80211_chan_def *chandef,
-- 
2.45.2

