From 04dac7e8683fbcdaa57e17a49a0928cb999cd225 Mon Sep 17 00:00:00 2001
From: Yi-Chia Hsieh <Yi-Chia.Hsieh@mediatek.com>
Date: Fri, 15 Aug 2025 15:56:46 -0700
Subject: [PATCH 120/128] mtk: mac80211: Handle special case when broadcast TWT
 id=0

The btwt_id=0 is a special case that AP spontaneously add BTWT capable
STA into the group. When the the station is associated, mac80211 will forge
a BTWT s1g action frame with id=0 in order to add the station to the btwt_id=0
group.

Signed-off-by: Yi-Chia Hsieh <Yi-Chia.Hsieh@mediatek.com>
---
 include/net/mac80211.h |  1 +
 net/mac80211/cfg.c     | 47 ++++++++++++++++++++++++++++++++++++++++++
 net/mac80211/he.c      |  3 +++
 3 files changed, 51 insertions(+)

diff --git a/include/net/mac80211.h b/include/net/mac80211.h
index 03b7aa4e..5d4b5dbf 100644
--- a/include/net/mac80211.h
+++ b/include/net/mac80211.h
@@ -2564,6 +2564,7 @@ struct ieee80211_sta {
 	struct ieee80211_sta_aggregates *cur;
 
 	bool support_p2p_ps;
+	bool btwt;
 
 	struct ieee80211_txq *txq[IEEE80211_NUM_TIDS + 1];
 
diff --git a/net/mac80211/cfg.c b/net/mac80211/cfg.c
index caf19f3b..4c88746f 100644
--- a/net/mac80211/cfg.c
+++ b/net/mac80211/cfg.c
@@ -1944,6 +1944,39 @@ static int ieee80211_stop_ap(struct wiphy *wiphy, struct net_device *dev,
 	return 0;
 }
 
+static int process_btwt_id_0(struct ieee80211_local *local,
+			     struct ieee80211_sub_if_data *sdata,
+			     struct sta_info *sta,
+			     bool add)
+{
+	int ret = -EINVAL;
+
+	if (!sta->sta.btwt)
+		return ret;
+
+	if (add) {
+		struct ieee80211_twt_setup *twt;
+
+		twt = kzalloc(sizeof(*twt) + sizeof(struct ieee80211_twt_params),
+			      GFP_KERNEL);
+		if (!twt)
+			return -ENOMEM;
+
+		twt->control |= IEEE80211_TWT_NEGO_TYPE_BTWT_MBR_MGMT << 2;
+		ret = drv_add_twt_setup(local, sdata, &sta->sta, twt);
+
+		kfree(twt);
+	} else {
+		struct ieee80211_twt_teardown td;
+
+		memset(&td, 0, sizeof(td));
+		td.neg_type = IEEE80211_TWT_NEGO_TYPE_BTWT_MBR_MGMT;
+		ret = drv_twt_teardown_request(local, sdata, &sta->sta, &td);
+	}
+
+	return ret;
+}
+
 static int sta_apply_auth_flags(struct ieee80211_local *local,
 				struct sta_info *sta,
 				u32 mask, u32 set)
@@ -2438,10 +2471,19 @@ static int ieee80211_add_station(struct wiphy *wiphy, struct net_device *dev,
 static int ieee80211_del_station(struct wiphy *wiphy, struct net_device *dev,
 				 struct station_del_parameters *params)
 {
+	struct ieee80211_local *local = wiphy_priv(wiphy);
 	struct ieee80211_sub_if_data *sdata;
 
 	sdata = IEEE80211_DEV_TO_SUB_IF(dev);
 
+	if (sdata->vif.type == NL80211_IFTYPE_AP &&
+	    sdata->deflink.btwt_active_bitmap & BIT(0)) {
+		struct sta_info *sta = sta_info_get_bss(sdata, params->mac);
+
+		if (sta)
+			process_btwt_id_0(local, sdata, sta, false);
+	}
+
 	if (params->mac)
 		return sta_info_destroy_addr_bss(sdata, params->mac);
 
@@ -2544,6 +2586,11 @@ static int ieee80211_change_station(struct wiphy *wiphy,
 		ieee80211_recalc_ps_vif(sdata);
 	}
 
+	if (sdata->vif.type == NL80211_IFTYPE_AP &&
+	    test_sta_flag(sta, WLAN_STA_AUTHORIZED) &&
+	    sdata->deflink.btwt_active_bitmap & BIT(0))
+		process_btwt_id_0(local, sdata, sta, true);
+
 	return 0;
 }
 
diff --git a/net/mac80211/he.c b/net/mac80211/he.c
index 895abdae..c5c8d1dc 100644
--- a/net/mac80211/he.c
+++ b/net/mac80211/he.c
@@ -164,6 +164,9 @@ ieee80211_he_cap_ie_to_sta_he_cap(struct ieee80211_sub_if_data *sdata,
 	link_sta->cur_max_bandwidth = ieee80211_sta_cap_rx_bw(link_sta);
 	link_sta->pub->bandwidth = ieee80211_sta_cur_vht_bw(link_sta);
 
+	if (he_cap->he_cap_elem.mac_cap_info[2] & IEEE80211_HE_MAC_CAP2_BCAST_TWT)
+		link_sta->sta->sta.btwt = true;
+
 	if (sband->band == NL80211_BAND_6GHZ && he_6ghz_capa)
 		ieee80211_update_from_he_6ghz_capa(he_6ghz_capa, link_sta);
 
-- 
2.45.2

