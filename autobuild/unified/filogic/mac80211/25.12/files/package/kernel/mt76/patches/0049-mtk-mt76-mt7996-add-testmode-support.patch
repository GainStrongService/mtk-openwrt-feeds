From d7d4dd0f7f0eea1375d3447967fc798d68eacb7e Mon Sep 17 00:00:00 2001
From: Shayne Chen <shayne.chen@mediatek.com>
Date: Thu, 6 Nov 2025 20:17:23 +0800
Subject: [PATCH 049/105] mtk: mt76: mt7996: add testmode support


mtk: mt76: mt7996: update testmode bf support

Fix bssid & omac idx to band idx when testmode is enabled

Add support for per-packet bw & primary channel selection index configuration
This is used for ibf calibaration of group 9 ~ 13 in mt7992

Signed-off-by: StanleyYP Wang <StanleyYP.Wang@mediatek.com>

mtk: mt76: mt7996: add external eeprom support

Add external eeprom support
For mt7992 and mt7990, efuse mode is not supported due to the lack of
space in efuse.
So, an additional external eeprom is added for user to store their
golden eeprom.

Note that the FW currently has some issues with writing to the ext
eeprom, so the write back function of ext eeprom is not yet linked
to any command.
A write back command will be added once the FW fixes the issue.

Add ext eeprom write callback

Signed-off-by: StanleyYP Wang <StanleyYP.Wang@mediatek.com>

mtk: mt76: mt7996: parse nvmem partition name & offset for flash write back

If eeprom data is read from nvmem, parse and send the partition name & offset
to atenl for flash write back.

Signed-off-by: StanleyYP Wang <StanleyYP.Wang@mediatek.com>

mtk: mt76: mt7996: add listmode support

Add listmode support
1. mt76-test phy0 set list_act=tx_seg tx_length=...
2. mt76-test phy0 set list_act=tx_start/tx_stop/...
3. mt76-test phy0 set list_act=rx_stat/dut_stat
4. mt76-test phy0 set list_act=dump_seg/clear_seg

Signed-off-by: StanleyYP Wang <StanleyYP.Wang@mediatek.com>

mtk: mt76: mt7996: add efuse write protection

Add efuse write protection in case that the user overwritten
the FT value stored in efuse.
Reference change list (Logan):
https://gerrit.mediatek.inc/c/neptune/wlan_driver/logan/+/9473737
https://gerrit.mediatek.inc/c/neptune/wlan_driver/logan/+/9497426

Signed-off-by: StanleyYP Wang <StanleyYP.Wang@mediatek.com>

mtk: mt76: mt7996: add testmode support for single wiphy

Add testmode support for single wiphy
Handle phyX to radio index conversion

Ignore ENOTCONN when setting all monitor interfaces to idle for all
radios
Without this patch, some mon interface will not be reset to idle.
For example, add mon1, then add mon2.
In this case mon0 does not exist, so the for loop will break
immediately.

Signed-off-by: StanleyYP Wang <StanleyYP.Wang@mediatek.com>

mtk: mt76: mt7996: refactor adie efuse merge support

Some calibration process (e.g. XTAL cal) during manufacturing test will
require access to FT data from the driver's eeprom buffer, so the firmware
offload efuse merge support should be reverted.

Signed-off-by: StanleyYP Wang <StanleyYP.Wang@mediatek.com>

mtk: mt76: mt7996: fix adie efuse merge support

Refactor due to firmware design change
Notify the firmware that the driver has cal free data that should be
patched back to hwcfg buffer.
Therefore, don't trigger hwcfg buffer init until the patch back is
complete.
This avoid firmware using the eeprom without cal free data to init
hw settings.

Signed-off-by: StanleyYP Wang <StanleyYP.Wang@mediatek.com>

mtk: mt76: mt7996: add 5T5R support for testmode RX

add 5T5R support for testmode RX (especially for mt7992 BE7200 ifem)

Signed-off-by: StanleyYP Wang <StanleyYP.Wang@mediatek.com>

mtk: mt76: mt7996: add testmode rx gain cal support

Add testmode rx gain cal support
Usage:
mt76-test phy0 set state=rx_gain_cal
mt76-test phy0 set state=rx_gain_dump
mt76-test phy0 set state=rx_gain_clean

Signed-off-by: StanleyYP Wang <StanleyYP.Wang@mediatek.com>

mtk: mt76: mt7996: add testmode fast cal support

add testmode fast cal support
Usage:
mt76-test phy0 set fast_cal=none/tx_verify (perform full cal)
mt76-test phy0 set fast_cal=rx_verify (skip tx cal items)
mt76-test phy0 set fast_cal=power_cal (skip dpd cal)

Signed-off-by: StanleyYP Wang <StanleyYP.Wang@mediatek.com>fast cal

mtk: mt76: mt7996: testmode refactor

Some testmode refactor
1. add testmode debug msg
2. add wake_up for cal event
3. change bf wait event queue from tx_wait to mcu wait queue
4. code refactor

Signed-off-by: StanleyYP Wang <StanleyYP.Wang@mediatek.com>

Remove RX gain channel list check since the channel could be determined by the
user.
Keep the RX ongoing while performing RX gain calibration; otherwise, the
calibration would fail.
Move reset_rx_stats to the front of set_state(RX_FRAMES) to make sure
the RX stats is cleared before RX starts.

Signed-off-by: StanleyYP Wang <StanleyYP.Wang@mediatek.com>

In mt76_testmode_cmd, dev->test_ops->set_params (mt7996_tm_update_params) is called before
setting the param_set bitmap for each presented attributes via mt76_testmode_param_set.
Therefore, set param_set bitmap of MT76_TM_ATTR_TX_ANTENNA before
calling mt7996_tm_set_antenna, otherwise it would be blocked by
parameter present check.

Signed-off-by: StanleyYP Wang <StanleyYP.Wang@mediatek.com>

mtk: mt76: mt7996: fix testmode RX frame issue

Fix testmode RX frame issue
The own mac address should be zero in normal case.
Otherwise, the RX would be malfunctioning.
Also, add TX_PATH setting in rx_frames

Signed-off-by: StanleyYP Wang <StanleyYP.Wang@mediatek.com>

mtk: mt76: mt7996: fix testmode rx stats issue

Fix testmode RX stats issue
Originally, RX ok count is calculated by RX MDRDY count - FCS err count
- len mismatch count.
However, this is incorrect as the other err counts are not included in
the FW event.
Therefore, just use the RX ok count reported from FW.

Signed-off-by: StanleyYP Wang <StanleyYP.Wang@mediatek.com>

mtk: mt76: mt7996: rework testmode dump stats

Rework testmode dump stats for dump order
Originally, the dump order is determined by the order of MT76 testmode
attribute enums, and the order of the attribute enum cannot be exchanged.
If a new attribute which is related to the previous attribute, the dump
info of these two attributes will be separated.
Therefore, use nla_for_each_nested instead of for loop to dump info, so
that the dump order will be determined by the order of nla_put
in driver.

Additionally, adjust the dump stats flow to adjust the order of dump
info.

Signed-off-by: StanleyYP Wang <StanleyYP.Wang@mediatek.com>

mtk: mt76: mt7996: fix testmode rx retry issue

Remove the additional mt7996_tm_update_channel call in mt7996_tm_set_rx_frames.
The second channel update also performs calibration, which can result in missing
frames transmitted from the instrument.

The original purpose of adding the additional channel update was to prevent users
from setting the TRX state before setting the channel.
However, after rebasing to single wiphy, the command "mt76-test phyX add monX" creates
a monitor interface with the parking channel already set.
Therefore, the additional channel update is no longer required.

Signed-off-by: StanleyYP Wang <StanleyYP.Wang@mediatek.com>

mtk: mt76: mt7996: testmode: add TX mac header & payload configuration support

Add TX mac header & payload configuration support

Signed-off-by: StanleyYP Wang <StanleyYP.Wang@mediatek.com>

mtk: mt76: mt7996: testmode: add ru support

Add RU operation support

Signed-off-by: StanleyYP Wang <StanleyYP.Wang@mediatek.com>

mtk: mt76: mt7996: testmode: refactor mt76_tm_get & tm event struct

Refactor mt76_tm_get_u8 to support mt76_tm_get_##type
Refactor mt7996_tm_rf_test_result struct member

Signed-off-by: StanleyYP Wang <StanleyYP.Wang@mediatek.com>

refactor testmode

Signed-off-by: StanleyYP Wang <StanleyYP.Wang@mediatek.com>

mtk: mt76: mt7996: testmode: add rx filter support

Add RX filter support
disable rx filter by setting it to 0

Signed-off-by: StanleyYP Wang <StanleyYP.Wang@mediatek.com>

mtk: mt76: mt7996: testmode: add icap support

Add icap support

Signed-off-by: StanleyYP Wang <StanleyYP.Wang@mediatek.com>

add default antenna value for continuous tx

Signed-off-by: StanleyYP Wang <StanleyYP.Wang@mediatek.com>

Add icap path support
path is required when dumping icap data, but not required when setting
icap in testmode

Signed-off-by: StanleyYP Wang <StanleyYP.Wang@mediatek.com>

mtk: mt76: mt7996: testmode: add tx tone support

Add tx tone support

Signed-off-by: StanleyYP Wang <StanleyYP.Wang@mediatek.com>

mtk: mt76: mt7996: testmode: add cfg support

Add testmode cfg support

Signed-off-by: StanleyYP Wang <StanleyYP.Wang@mediatek.com>

mtk: mt76: mt7996: testmode: fix dpd cal switch reason

The offchannel flag IEEE80211_CONF_OFFCHANNEL has been replaced by mphy->offchannel
due to upstream changes.
Therefore, refactor the code to set the correct switch reason when performing
dpd precal.

Signed-off-by: StanleyYP Wang <StanleyYP.Wang@mediatek.com>

mtk: mt76: mt7996: testmode: add max packet extension

Add max packet extension support

Signed-off-by: StanleyYP Wang <StanleyYP.Wang@mediatek.com>

According to the testmode AN, the value of EHT_MU_DL_OFDMA is 15 and
EHT_TB_UL_OFDMA is 16, which is different from the values in mt76_phy_type
Therefore, define the own enum for testmode

Signed-off-by: StanleyYP Wang <StanleyYP.Wang@mediatek.com>

mtk: mt76: mt7996: rework precal data

To resolve the RCU stall that occurs when dumping extremely large pre-cal data
via printk, dump the pre-cal data through debugfs instead.
Also, this makes the pre-cal data visible to the user, which helps with debugging.

[90620.571164] rcu: INFO: rcu_sched self-detected stall on CPU
[90620.571168] rcu:     1-....: (5999 ticks this GP) idle=0804/1/0x4000000000000000 softirq=1825007/1825007 fqs=2993
[90620.571175] rcu:     (t=6000 jiffies g=4987813 q=1587 ncpus=4)
[90620.571181] CPU: 1 PID: 17386 Comm: mt76-test Tainted: G           O       6.6.110 #0
[90620.571186] Hardware name: MediaTek MT7988A Reference Board (DT)
[90620.571189] pstate: 60400005 (nZCv daif +PAN -UAO -TCO -DIT -SSBS BTYPE=--)
[90620.571193] pc : console_flush_all+0x218/0x4dc
[90620.571205] lr : console_flush_all+0x214/0x4dc
[90620.571209] sp : ffffffc08ddeb010
[90620.571210] x29: ffffffc08ddeb010 x28: ffffffc080ee7008 x27: 0000000000000000
[90620.571217] x26: ffffffc0810aa340 x25: ffffffc08ddeb118 x24: 0000000000000000
[90620.571222] x23: ffffffc080f1b870 x22: 0000000000000001 x21: ffffffc08ddeb117
[90620.571226] x20: ffffffc0810aa180 x19: ffffffc0810031a0 x18: 0000000000000005
[90620.571231] x17: 2020202020783020 x16: 3020202020202020 x15: 7830203020202020
[90620.571235] x14: 2020207830205d30 x13: 3020202020202020 x12: 7830203020202020
[90620.571239] x11: 2020207830203020 x10: 2020202020207830 x9 : 3736633130303078
[90620.571244] x8 : 305b203a302e3030 x7 : 205d373139323635 x6 : 352e30323630395b
[90620.571248] x5 : 0000000000000000 x4 : 0000000000000000 x3 : 0000000000000000
[90620.571252] x2 : 00000000ffffffff x1 : ffffffbfbee79000 x0 : ffffff803fd61a80
[90620.571257] Call trace:
[90620.571259]  console_flush_all+0x218/0x4dc
[90620.571264]  console_unlock+0x6c/0xb4
[90620.571268]  vprintk_emit+0x1b8/0x2ac
[90620.571273]  dev_printk_emit+0x90/0xbc
[90620.571278]  __dev_printk+0x38/0x7c
[90620.571280]  _dev_printk+0x40/0x48
[90620.571283]  __mt76_dbg+0x58/0x60 [mt76]
[90620.571302]  mt7996_tm_group_prek.isra.0+0x258/0x3a8 [mt7996e]
[90620.571325]  mt7996_tm_set_state+0xe4/0x978 [mt7996e]
[90620.571341]  __mt76_testmode_set_state+0x50/0x56c [mt76]
[90620.571351]  mt76_testmode_set_state+0x60/0x134 [mt76]
[90620.571361]  mt76_testmode_cmd+0xe54/0x11dc [mt76]
[90620.571370]  ieee80211_testmode_cmd+0x3c/0x50 [mac80211]
[90620.571434]  nl80211_testmode_do+0x90/0x170 [cfg80211]
[90620.571479]  genl_family_rcv_msg_doit+0xac/0x10c
[90620.571485]  genl_rcv_msg+0x1b0/0x244
[90620.571488]  netlink_rcv_skb+0x5c/0x128
[90620.571491]  genl_rcv+0x34/0x48
[90620.571494]  netlink_unicast+0x224/0x310
[90620.571497]  netlink_sendmsg+0x198/0x3c4
[90620.571499]  ____sys_sendmsg+0xb4/0x2a8
[90620.571506]  ___sys_sendmsg+0x7c/0xc0
[90620.571510]  __sys_sendmsg+0x44/0x98
[90620.571514]  __arm64_sys_sendmsg+0x20/0x28
[90620.571518]  invoke_syscall.constprop.0+0x4c/0xe0
[90620.571523]  do_el0_svc+0x3c/0xb8
[90620.571527]  el0_svc+0x18/0x4c
[90620.571532]  el0t_64_sync_handler+0x118/0x124
[90620.571535]  el0t_64_sync+0x150/0x154

Signed-off-by: StanleyYP Wang <StanleyYP.Wang@mediatek.com>
---
 debugfs.c            |    2 +
 eeprom.c             |   79 +-
 mac80211.c           |   39 +-
 mt76.h               |  224 +++-
 mt76_connac_mcu.h    |    5 +
 mt7996/Makefile      |    4 +
 mt7996/debugfs.c     |  118 ++
 mt7996/eeprom.c      |  299 ++++-
 mt7996/eeprom.h      |  124 +-
 mt7996/init.c        |   18 +-
 mt7996/main.c        |   74 +-
 mt7996/mcu.c         |  532 +++++++-
 mt7996/mcu.h         |  109 +-
 mt7996/mt7996.h      |  101 +-
 mt7996/mtk_mcu.c     |  609 +++++++++
 mt7996/mtk_mcu.h     |  738 +++++++++++
 mt7996/regs.h        |    3 +
 mt7996/testmode.c    | 2989 ++++++++++++++++++++++++++++++++++++++++++
 mt7996/testmode.h    |  658 ++++++++++
 testmode.c           | 1000 ++++++++++++--
 testmode.h           |  499 ++++++-
 tools/CMakeLists.txt |    7 +
 tools/eeprom.c       |    6 +-
 tools/fields.c       |  420 +++++-
 tools/fwlog.c        |  247 +++-
 tools/main.c         |  325 ++++-
 tools/mt76-test.h    |   49 +
 27 files changed, 8963 insertions(+), 315 deletions(-)
 create mode 100644 mt7996/mtk_mcu.c
 create mode 100644 mt7996/mtk_mcu.h
 create mode 100644 mt7996/testmode.c
 create mode 100644 mt7996/testmode.h

diff --git a/debugfs.c b/debugfs.c
index 41d1d486d..99da62c39 100644
--- a/debugfs.c
+++ b/debugfs.c
@@ -118,6 +118,8 @@ mt76_register_debugfs_fops(struct mt76_phy *phy,
 	debugfs_create_blob("eeprom", 0400, dir, &dev->eeprom);
 	if (dev->otp.data)
 		debugfs_create_blob("otp", 0400, dir, &dev->otp);
+	if (dev->ext_eeprom.data)
+		debugfs_create_blob("ext_eeprom", 0400, dir, &dev->ext_eeprom);
 	debugfs_create_devm_seqfile(dev->dev, "rx-queues", dir,
 				    mt76_rx_queues_read);
 
diff --git a/eeprom.c b/eeprom.c
index 197f36a0a..4c1f12c3f 100644
--- a/eeprom.c
+++ b/eeprom.c
@@ -94,12 +94,10 @@ int mt76_get_of_data_from_mtd(struct mt76_dev *dev, void *eep, int offset, int l
 	}
 
 #ifdef CONFIG_NL80211_TESTMODE
-	dev->test_mtd.name = devm_kstrdup(dev->dev, part, GFP_KERNEL);
-	if (!dev->test_mtd.name) {
-		ret = -ENOMEM;
-		goto out_put_node;
+	if (len == dev->eeprom.size) {
+		dev->test_mtd.name = devm_kstrdup(dev->dev, part, GFP_KERNEL);
+		dev->test_mtd.offset = offset;
 	}
-	dev->test_mtd.offset = offset;
 #endif
 
 out_put_node:
@@ -111,6 +109,52 @@ out_put_node:
 }
 EXPORT_SYMBOL_GPL(mt76_get_of_data_from_mtd);
 
+static void mt76_get_nvmem_part(struct mt76_dev *dev)
+{
+#ifdef CONFIG_NL80211_TESTMODE
+	struct device_node *np = dev->dev->of_node;
+	const __be32 *list;
+	const char *part;
+	phandle phandle;
+	int offset, size;
+	u32 reg[2];
+
+	list = of_get_property(np, "nvmem-cells", NULL);
+	if (!list)
+		return;
+
+	phandle = be32_to_cpup(list++);
+	if (!phandle)
+		return;
+
+	np = of_find_node_by_phandle(phandle);
+	if (!np)
+		return;
+
+	if (of_property_read_u32_array(np, "reg", reg, 2))
+		return;
+
+	offset = reg[0];
+	size = reg[1];
+
+	np = of_get_parent(of_get_parent(np));
+	if (!np)
+		return;
+
+	part = of_get_property(np, "partname", NULL);
+	if (!part)
+		part = of_get_property(np, "volname", NULL);
+	if (!part)
+		return;
+
+	if (size != dev->eeprom.size)
+		return;
+
+	dev->test_mtd.name = devm_kstrdup(dev->dev, part, GFP_KERNEL);
+	dev->test_mtd.offset = offset;
+#endif
+}
+
 int mt76_get_of_data_from_nvmem(struct mt76_dev *dev, void *eep,
 				const char *cell_name, int len)
 {
@@ -124,6 +168,8 @@ int mt76_get_of_data_from_nvmem(struct mt76_dev *dev, void *eep,
 	if (IS_ERR(cell))
 		return PTR_ERR(cell);
 
+	mt76_get_nvmem_part(dev);
+
 	data = nvmem_cell_read(cell, &retlen);
 	nvmem_cell_put(cell);
 
@@ -163,6 +209,29 @@ static int mt76_get_of_eeprom(struct mt76_dev *dev, void *eep, int len)
 	return mt76_get_of_data_from_nvmem(dev, eep, "eeprom", len);
 }
 
+bool mt76_check_bin_file_mode(struct mt76_dev *dev)
+{
+	struct device_node *np = dev->dev->of_node;
+	const char *bin_file_name = NULL;
+
+	if (!np)
+		return false;
+
+	of_property_read_string(np, "bin_file_name", &bin_file_name);
+
+	dev->bin_file_name = bin_file_name;
+	if (dev->bin_file_name) {
+		dev_info(dev->dev, "Using bin file %s\n", dev->bin_file_name);
+#ifdef CONFIG_NL80211_TESTMODE
+		dev->test_mtd.name = devm_kstrdup(dev->dev, bin_file_name, GFP_KERNEL);
+		dev->test_mtd.offset = -1;
+#endif
+	}
+
+	return dev->bin_file_name ? true : false;
+}
+EXPORT_SYMBOL_GPL(mt76_check_bin_file_mode);
+
 int
 mt76_eeprom_override(struct mt76_phy *phy)
 {
diff --git a/mac80211.c b/mac80211.c
index f59efec98..37fe0996c 100644
--- a/mac80211.c
+++ b/mac80211.c
@@ -6,27 +6,6 @@
 #include <linux/of.h>
 #include "mt76.h"
 
-#define CHAN2G(_idx, _freq) {			\
-	.band = NL80211_BAND_2GHZ,		\
-	.center_freq = (_freq),			\
-	.hw_value = (_idx),			\
-	.max_power = 30,			\
-}
-
-#define CHAN5G(_idx, _freq) {			\
-	.band = NL80211_BAND_5GHZ,		\
-	.center_freq = (_freq),			\
-	.hw_value = (_idx),			\
-	.max_power = 30,			\
-}
-
-#define CHAN6G(_idx, _freq) {			\
-	.band = NL80211_BAND_6GHZ,		\
-	.center_freq = (_freq),			\
-	.hw_value = (_idx),			\
-	.max_power = 30,			\
-}
-
 static const struct ieee80211_channel mt76_channels_2ghz[] = {
 	CHAN2G(1, 2412),
 	CHAN2G(2, 2417),
@@ -55,6 +34,15 @@ static const struct ieee80211_channel mt76_channels_5ghz[] = {
 	CHAN5G(60, 5300),
 	CHAN5G(64, 5320),
 
+	CHAN5G(68, 5340),
+	CHAN5G(72, 5360),
+	CHAN5G(76, 5380),
+	CHAN5G(80, 5400),
+	CHAN5G(84, 5420),
+	CHAN5G(88, 5440),
+	CHAN5G(92, 5460),
+	CHAN5G(96, 5480),
+
 	CHAN5G(100, 5500),
 	CHAN5G(104, 5520),
 	CHAN5G(108, 5540),
@@ -946,10 +934,11 @@ void mt76_rx(struct mt76_dev *dev, enum mt76_rxq_id q, struct sk_buff *skb)
 	}
 
 #ifdef CONFIG_NL80211_TESTMODE
-	if (phy->test.state == MT76_TM_STATE_RX_FRAMES) {
-		phy->test.rx_stats.packets[q]++;
+	if (!(phy->test.flag & MT_TM_FW_RX_COUNT) &&
+	    phy->test.state == MT76_TM_STATE_RX_FRAMES) {
+		phy->test.rx_stats[q].packets++;
 		if (status->flag & RX_FLAG_FAILED_FCS_CRC)
-			phy->test.rx_stats.fcs_error[q]++;
+			phy->test.rx_stats[q].fcs_error++;
 	}
 #endif
 
@@ -2071,7 +2060,7 @@ enum mt76_dfs_state mt76_phy_dfs_state(struct mt76_phy *phy)
 		return MT_DFS_STATE_DISABLED;
 
 	if (!phy->radar_enabled) {
-		if ((hw->conf.flags & IEEE80211_CONF_MONITOR) &&
+		if (((hw->conf.flags & IEEE80211_CONF_MONITOR) || phy->monitor_vif) &&
 		    (phy->chandef.chan->flags & IEEE80211_CHAN_RADAR))
 			return MT_DFS_STATE_ACTIVE;
 
diff --git a/mt76.h b/mt76.h
index 17b643325..79f87586d 100644
--- a/mt76.h
+++ b/mt76.h
@@ -30,6 +30,27 @@
 #include "testmode.h"
 #include "debug.h"
 
+#define CHAN2G(_idx, _freq) {			\
+	.band = NL80211_BAND_2GHZ,		\
+	.center_freq = (_freq),			\
+	.hw_value = (_idx),			\
+	.max_power = 30,			\
+}
+
+#define CHAN5G(_idx, _freq) {			\
+	.band = NL80211_BAND_5GHZ,		\
+	.center_freq = (_freq),			\
+	.hw_value = (_idx),			\
+	.max_power = 30,			\
+}
+
+#define CHAN6G(_idx, _freq) {			\
+	.band = NL80211_BAND_6GHZ,		\
+	.center_freq = (_freq),			\
+	.hw_value = (_idx),			\
+	.max_power = 30,			\
+}
+
 #define MT_MCU_RING_SIZE	32
 #define MT_RX_BUF_SIZE		2048
 #define MT_SKB_HEAD_LEN		256
@@ -804,14 +825,75 @@ struct mt76_testmode_ops {
 	int (*set_params)(struct mt76_phy *phy, struct nlattr **tb,
 			  enum mt76_testmode_state new_state);
 	int (*dump_stats)(struct mt76_phy *phy, struct sk_buff *msg);
+	void (*reset_rx_stats)(struct mt76_phy *phy);
+	void (*tx_stop)(struct mt76_phy *phy);
+	int (*set_eeprom)(struct mt76_phy *phy, u32 offset, u8 *val, u8 action);
+	int (*dump_precal)(struct mt76_phy *mphy, struct sk_buff *msg, int flag, int type);
+	int (*set_list_mode)(struct mt76_phy *phy, int seg_idx,
+			     enum mt76_testmode_list_act list_act);
+	int (*set_sta_ru_info)(struct mt76_phy *phy, bool init);
+	int (*dump_tb_info)(struct mt76_phy *phy);
+	int (*dump_icap)(struct mt76_phy *phy);
+};
+
+#define MT_TM_FW_RX_COUNT	BIT(0)
+#define MT_TM_MAX_MU_STA	16
+
+struct mt76_sta_ru_info {
+	u8 aid;
+	u8 ru_alloc;
+	u8 ru_idx;
+	u8 seg_idx;
+	u8 tx_rate_idx;
+	u8 tx_rate_ldpc;
+	u8 tx_rate_nss;
+	u8 ss_idx;
+	u16 tx_mpdu_len;
+};
+
+struct mt76_tb_info {
+	u32 afactor_init;
+	u32 ldpc_extra_symbol;
+	u32 packet_ext_disamb;
+	u32 tx_packet_ext;
+	u32 l_sig_len;
+};
+
+struct mt76_icap {
+	u8 ring_buffer;
+	u32 trigger_event;
+	u32 node;
+	u32 len;
+	u32 cycle;
+	u8 bandwidth;
+	u8 src;
+
+	u8 iq_type;
+	u8 path;
+	u8 cap_status;
+	u32 *data;
+};
+
+enum {
+	ICAP_SRC_PHY,
+	ICAP_SRC_AFE,
 };
 
+enum {
+	DATA_TYPE_I,
+	DATA_TYPE_Q,
+};
+
+#define MT_TM_ICAP_SAMPLE_LEN	256
+
 struct mt76_testmode_data {
 	enum mt76_testmode_state state;
 
 	u32 param_set[DIV_ROUND_UP(NUM_MT76_TM_ATTRS, 32)];
 	struct sk_buff *tx_skb;
 
+	u8 sku_en;
+
 	u32 tx_count;
 	u16 tx_mpdu_len;
 
@@ -821,6 +903,7 @@ struct mt76_testmode_data {
 	u8 tx_rate_sgi;
 	u8 tx_rate_ldpc;
 	u8 tx_rate_stbc;
+	u16 tx_preamble_puncture;
 	u8 tx_ltf;
 
 	u8 tx_antenna_mask;
@@ -830,6 +913,17 @@ struct mt76_testmode_data {
 	u32 tx_time;
 	u32 tx_ipg;
 
+	u8 txbf_act;
+	u16 txbf_param[8];
+	bool is_txbf_dut;
+	bool bf_en;
+	bool bf_ever_en;
+	bool ibf;
+	bool ebf;
+
+	u8 tx_pkt_bw;
+	u8 tx_pri_sel;
+
 	u32 freq_offset;
 
 	u8 tx_power[4];
@@ -842,9 +936,96 @@ struct mt76_testmode_data {
 	u16 tx_queued_limit;
 	u32 tx_done;
 	struct {
-		u64 packets[__MT_RXQ_MAX];
-		u64 fcs_error[__MT_RXQ_MAX];
-	} rx_stats;
+		u64 packets;
+		u64 rx_success;
+		u64 fcs_error;
+		u64 len_mismatch;
+	} rx_stats[__MT_RXQ_MAX];
+	u8 flag;
+
+	struct {
+		s32 freq_offset;
+		u8 path;
+		u8 *rcpi;
+		s8 *rssi;
+		s8 *ib_rssi;
+		s8 *wb_rssi;
+		u8 snr;
+	} last_rx;
+
+	struct {
+		u8 type;
+		u8 enable;
+	} cfg;
+
+	u8 aid;
+
+	u8 offchan_ch;
+	u8 offchan_center_ch;
+	u8 offchan_bw;
+
+	u8 ipi_threshold;
+	u32 ipi_period;
+	u8 ipi_reset;
+
+	u8 fast_cal;
+
+	u16 fc;
+	u16 dur;
+	u16 seq;
+	u8 payload_rule;
+	u8 payload;
+	u8 max_pkt_ext;
+
+	struct mt76_sta_ru_info *sta_ru_info;
+	struct mt76_tb_info tb_info;
+	u8 ru_sta_num;
+	u8 ru_sta_idx;
+
+	u32 rx_filter;
+
+	struct mt76_icap icap;
+
+	struct {
+		u8 type;
+		u8 bw;
+		u16 dc_offset[2];
+	} tone;
+};
+
+enum {
+	LM_SEG_TYPE_TX,
+	LM_SEG_TYPE_RX,
+};
+
+struct mt76_list_mode_data {
+	/* seg settings */
+	u8 seg_type;
+	u32 ant_swap;
+	u32 seg_timeout;
+	/* rf settings */
+	u8 addr[3][ETH_ALEN];
+	u8 tx_antenna_mask;
+	u8 rx_antenna_mask;
+	u8 center_ch1;
+	u8 center_ch2;
+	u8 system_bw;
+	u8 data_bw;
+	u8 pri_sel;
+	/* tx settings */
+	u16 tx_mpdu_len;
+	u32 tx_count;
+	u8 tx_power;
+	u8 tx_rate_mode;
+	u8 tx_rate_idx;
+	u8 tx_rate_stbc;
+	u8 tx_rate_ldpc;
+	u32 tx_ipg;
+	u8 tx_rate_sgi;
+	u8 tx_rate_nss;
+	u8 hw_tx_mode;
+	/* rx settings */
+	u32 sta_idx;
 };
 
 struct mt76_vif_link {
@@ -890,6 +1071,8 @@ struct mt76_phy {
 	struct mt76_queue *q_tx[__MT_TXQ_MAX];
 	int tokens;
 
+	struct ieee80211_vif *monitor_vif;
+
 	struct cfg80211_chan_def chandef;
 	struct cfg80211_chan_def main_chandef;
 	bool offchannel;
@@ -920,6 +1103,8 @@ struct mt76_phy {
 
 #ifdef CONFIG_NL80211_TESTMODE
 	struct mt76_testmode_data test;
+	struct mt76_list_mode_data *lists;
+	int seg_num;
 #endif
 
 	struct delayed_work mac_work;
@@ -945,6 +1130,7 @@ struct mt76_dev {
 	struct mt76_phy phy; /* must be first */
 	struct mt76_phy *phys[__MT_MAX_BAND];
 	struct mt76_phy *band_phys[NUM_NL80211_BANDS];
+	struct mt76_phy *radio_phy[__MT_MAX_BAND];
 
 	struct ieee80211_hw *hw;
 
@@ -1021,6 +1207,7 @@ struct mt76_dev {
 
 	struct debugfs_blob_wrapper eeprom;
 	struct debugfs_blob_wrapper otp;
+	struct debugfs_blob_wrapper ext_eeprom;
 
 	char alpha2[3];
 	enum nl80211_dfs_regions region;
@@ -1045,6 +1232,7 @@ struct mt76_dev {
 
 #ifdef CONFIG_NL80211_TESTMODE
 	const struct mt76_testmode_ops *test_ops;
+	/* test_mtd can be used for mtd or emmc */
 	struct {
 		const char *name;
 		u32 offset;
@@ -1062,6 +1250,8 @@ struct mt76_dev {
 
 	unsigned int debug_mask;
 
+	const char *bin_file_name;
+
 	u8 chainshift[__MT_MAX_BAND];
 };
 
@@ -1368,6 +1558,7 @@ int mt76_eeprom_override(struct mt76_phy *phy);
 int mt76_get_of_data_from_mtd(struct mt76_dev *dev, void *eep, int offset, int len);
 int mt76_get_of_data_from_nvmem(struct mt76_dev *dev, void *eep,
 				const char *cell_name, int len);
+bool mt76_check_bin_file_mode(struct mt76_dev *dev);
 
 struct mt76_queue *
 mt76_init_queue(struct mt76_dev *dev, int qid, int idx, int n_desc,
@@ -1539,6 +1730,15 @@ static inline bool mt76_testmode_enabled(struct mt76_phy *phy)
 #endif
 }
 
+static inline bool mt76_testmode_bf_enabled(struct mt76_phy *phy)
+{
+#ifdef CONFIG_NL80211_TESTMODE
+	return phy->test.bf_en;
+#else
+	return false;
+#endif
+}
+
 static inline bool mt76_is_testmode_skb(struct mt76_dev *dev,
 					struct sk_buff *skb,
 					struct ieee80211_hw **hw)
@@ -1786,6 +1986,24 @@ static inline int mt76_npu_get_msg(struct airoha_npu *npu, int ifindex,
 				       gfp);
 }
 
+static inline void
+mt76_testmode_param_set(struct mt76_testmode_data *td, u16 idx)
+{
+#ifdef CONFIG_NL80211_TESTMODE
+	td->param_set[idx / 32] |= BIT(idx % 32);
+#endif
+}
+
+static inline bool
+mt76_testmode_param_present(struct mt76_testmode_data *td, u16 idx)
+{
+#ifdef CONFIG_NL80211_TESTMODE
+	return td->param_set[idx / 32] & BIT(idx % 32);
+#else
+	return false;
+#endif
+}
+
 static inline void mt76_testmode_reset(struct mt76_phy *phy, bool disable)
 {
 #ifdef CONFIG_NL80211_TESTMODE
diff --git a/mt76_connac_mcu.h b/mt76_connac_mcu.h
index f50d3acaa..a923f0ec1 100644
--- a/mt76_connac_mcu.h
+++ b/mt76_connac_mcu.h
@@ -1062,9 +1062,11 @@ enum {
 	MCU_UNI_EVENT_RDD_REPORT = 0x11,
 	MCU_UNI_EVENT_ROC = 0x27,
 	MCU_UNI_EVENT_TX_DONE = 0x2d,
+	MCU_UNI_EVENT_BF = 0x33,
 	MCU_UNI_EVENT_THERMAL = 0x35,
 	MCU_UNI_EVENT_RSSI_MONITOR = 0x41,
 	MCU_UNI_EVENT_NIC_CAPAB = 0x43,
+	MCU_UNI_EVENT_TESTMODE_CTRL = 0x46,
 	MCU_UNI_EVENT_WED_RRO = 0x57,
 	MCU_UNI_EVENT_PP = 0x5a,
 	MCU_UNI_EVENT_PER_STA_INFO = 0x6d,
@@ -1304,12 +1306,15 @@ enum {
 	MCU_UNI_CMD_VOW = 0x37,
 	MCU_UNI_CMD_FIXED_RATE_TABLE = 0x40,
 	MCU_UNI_CMD_RSSI_MONITOR = 0x41,
+	MCU_UNI_CMD_TESTMODE_TRX_PARAM = 0x42,
 	MCU_UNI_CMD_TESTMODE_CTRL = 0x46,
+	MCU_UNI_CMD_PRECAL_RESULT = 0x47,
 	MCU_UNI_CMD_RRO = 0x57,
 	MCU_UNI_CMD_OFFCH_SCAN_CTRL = 0x58,
 	MCU_UNI_CMD_PER_STA_INFO = 0x6d,
 	MCU_UNI_CMD_ALL_STA_INFO = 0x6e,
 	MCU_UNI_CMD_ASSERT_DUMP = 0x6f,
+	MCU_UNI_CMD_EXT_EEPROM_CTRL  = 0x74,
 	MCU_UNI_CMD_RADIO_STATUS = 0x80,
 	MCU_UNI_CMD_SDO = 0x88,
 };
diff --git a/mt7996/Makefile b/mt7996/Makefile
index 69d2d4bb9..6091efa17 100644
--- a/mt7996/Makefile
+++ b/mt7996/Makefile
@@ -1,4 +1,5 @@
 # SPDX-License-Identifier: BSD-3-Clause-Clear
+EXTRA_CFLAGS += -DCONFIG_MTK_DEBUG
 
 obj-$(CONFIG_MT7996E) += mt7996e.o
 
@@ -7,3 +8,6 @@ mt7996e-y := pci.o init.o dma.o eeprom.o main.o mcu.o mac.o \
 
 mt7996e-$(CONFIG_MT7996_NPU) += npu.o
 mt7996e-$(CONFIG_DEV_COREDUMP) += coredump.o
+mt7996e-$(CONFIG_NL80211_TESTMODE) += testmode.o
+
+mt7996e-y += mtk_mcu.o
diff --git a/mt7996/debugfs.c b/mt7996/debugfs.c
index 600ffec6e..b0d6399e4 100644
--- a/mt7996/debugfs.c
+++ b/mt7996/debugfs.c
@@ -879,6 +879,121 @@ mt7996_rf_regval_set(void *data, u64 val)
 DEFINE_DEBUGFS_ATTRIBUTE(fops_rf_regval, mt7996_rf_regval_get,
 			 mt7996_rf_regval_set, "0x%08llx\n");
 
+static ssize_t
+mt7996_efuse_get(struct file *file, char __user *user_buf,
+		 size_t count, loff_t *ppos)
+{
+	struct mt7996_dev *dev = file->private_data;
+	struct mt76_dev *mdev = &dev->mt76;
+	u8 *buff = mdev->otp.data;
+	int i;
+	ssize_t ret;
+	u32 block_num;
+
+	mdev->otp.size = MT7996_EEPROM_SIZE;
+	if (is_mt7996(&dev->mt76) && dev->var.type == MT7996_VAR_TYPE_444)
+		mdev->otp.size += 3 * MT_EE_CAL_UNIT;
+
+	if (!mdev->otp.data) {
+		mdev->otp.data = devm_kzalloc(mdev->dev, mdev->otp.size, GFP_KERNEL);
+		if (!mdev->otp.data)
+			return -ENOMEM;
+
+		block_num = DIV_ROUND_UP(mdev->otp.size, MT7996_EEPROM_BLOCK_SIZE);
+		for (i = 0; i < block_num; i++) {
+			buff = mdev->otp.data + i * MT7996_EEPROM_BLOCK_SIZE;
+			ret = mt7996_mcu_get_eeprom(dev, i * MT7996_EEPROM_BLOCK_SIZE,
+						    buff, MT7996_EEPROM_BLOCK_SIZE,
+						    EFUSE_MODE);
+			if (ret && ret != -EINVAL)
+				return ret;
+		}
+	}
+
+	ret = simple_read_from_buffer(user_buf, count, ppos, mdev->otp.data, mdev->otp.size);
+
+	return ret;
+}
+
+static const struct file_operations mt7996_efuse_ops = {
+	.read = mt7996_efuse_get,
+	.open = simple_open,
+	.llseek = default_llseek,
+};
+
+static ssize_t
+mt7996_ext_eeprom_get(struct file *file, char __user *user_buf,
+		      size_t count, loff_t *ppos)
+{
+	struct mt7996_dev *dev = file->private_data;
+	struct mt76_dev *mdev = &dev->mt76;
+	u8 *buff = mdev->ext_eeprom.data;
+	u32 block_num, block_size = MT7996_EXT_EEPROM_BLOCK_SIZE;
+	int i;
+	ssize_t ret;
+
+	if (!mt7996_has_ext_eeprom(dev)) {
+		dev_info(dev->mt76.dev, "No external eeprom device found\n");
+		return 0;
+	}
+
+	mdev->ext_eeprom.size = MT7996_EEPROM_SIZE;
+
+	if (!mdev->ext_eeprom.data) {
+		mdev->ext_eeprom.data = devm_kzalloc(mdev->dev,
+						     mdev->ext_eeprom.size,
+						     GFP_KERNEL);
+		if (!mdev->ext_eeprom.data)
+			return -ENOMEM;
+
+		block_num = DIV_ROUND_UP(mdev->ext_eeprom.size, block_size);
+		for (i = 0; i < block_num; i++) {
+			u32 buf_len = block_size;
+			u32 offset = i * block_size;
+
+			if (offset + block_size > mdev->ext_eeprom.size)
+				buf_len = mdev->ext_eeprom.size % block_size;
+			buff = mdev->ext_eeprom.data + offset;
+			ret = mt7996_mcu_get_eeprom(dev, offset, buff, buf_len,
+						    EXT_EEPROM_MODE);
+			if (ret && ret != -EINVAL)
+				return ret;
+		}
+	}
+
+	ret = simple_read_from_buffer(user_buf, count, ppos,
+				      mdev->ext_eeprom.data, mdev->ext_eeprom.size);
+
+	return ret;
+}
+
+static const struct file_operations mt7996_ext_eeprom_ops = {
+	.read = mt7996_ext_eeprom_get,
+	.open = simple_open,
+	.llseek = default_llseek,
+};
+
+static ssize_t
+mt7996_precal_get(struct file *file, char __user *user_buf,
+		  size_t count, loff_t *ppos)
+{
+	struct mt7996_dev *dev = file->private_data;
+
+	if (!dev->cal.data || !dev->cal.size) {
+		dev_info(dev->mt76.dev, "No precal data available\n");
+		return 0;
+	}
+
+	return simple_read_from_buffer(user_buf, count, ppos,
+				       dev->cal.data, dev->cal.size);
+}
+
+static const struct file_operations mt7996_precal_ops = {
+	.read = mt7996_precal_get,
+	.open = simple_open,
+	.llseek = default_llseek,
+};
+
 int mt7996_init_debugfs(struct mt7996_dev *dev)
 {
 	struct dentry *dir;
@@ -905,6 +1020,9 @@ int mt7996_init_debugfs(struct mt7996_dev *dev)
 	debugfs_create_devm_seqfile(dev->mt76.dev, "twt_stats", dir,
 				    mt7996_twt_stats);
 	debugfs_create_file("rf_regval", 0600, dir, dev, &fops_rf_regval);
+	debugfs_create_file("otp", 0400, dir, dev, &mt7996_efuse_ops);
+	debugfs_create_file("ext_eeprom", 0400, dir, dev, &mt7996_ext_eeprom_ops);
+	debugfs_create_file("precal", 0400, dir, dev, &mt7996_precal_ops);
 
 	debugfs_create_u32("dfs_hw_pattern", 0400, dir, &dev->hw_pattern);
 	debugfs_create_file("radar_trigger", 0200, dir, dev,
diff --git a/mt7996/eeprom.c b/mt7996/eeprom.c
index 681aa9d0f..2d326c224 100644
--- a/mt7996/eeprom.c
+++ b/mt7996/eeprom.c
@@ -6,6 +6,80 @@
 #include <linux/firmware.h>
 #include "mt7996.h"
 #include "eeprom.h"
+#include <linux/moduleparam.h>
+
+static bool testmode_enable;
+module_param(testmode_enable, bool, 0644);
+MODULE_PARM_DESC(testmode_enable, "Enable testmode");
+
+const struct ieee80211_channel dpd_2g_ch_list_bw20[] = {
+	CHAN2G(3, 2422),
+	CHAN2G(7, 2442),
+	CHAN2G(11, 2462)
+};
+
+const struct ieee80211_channel dpd_5g_skip_ch_list[] = {
+	CHAN5G(68, 5340),
+	CHAN5G(72, 5360),
+	CHAN5G(76, 5380),
+	CHAN5G(80, 5400),
+	CHAN5G(84, 5420),
+	CHAN5G(88, 5440),
+	CHAN5G(92, 5460),
+	CHAN5G(96, 5480)
+};
+
+const struct ieee80211_channel dpd_5g_ch_list_bw80[] = {
+	CHAN5G(42, 5210),
+	CHAN5G(58, 5290),
+	CHAN5G(106, 5530),
+	CHAN5G(122, 5610),
+	CHAN5G(138, 5690),
+	CHAN5G(155, 5775),
+	CHAN5G(171, 5855)
+};
+
+const struct ieee80211_channel dpd_5g_ch_list_bw160[] = {
+	CHAN5G(50, 5250),
+	CHAN5G(114, 5570),
+	CHAN5G(163, 5815)
+};
+
+const struct ieee80211_channel dpd_6g_ch_list_bw80[] = {
+	CHAN6G(7, 5985),
+	CHAN6G(23, 6065),
+	CHAN6G(39, 6145),
+	CHAN6G(55, 6225),
+	CHAN6G(71, 6305),
+	CHAN6G(87, 6385),
+	CHAN6G(103, 6465),
+	CHAN6G(119, 6545),
+	CHAN6G(135, 6625),
+	CHAN6G(151, 6705),
+	CHAN6G(167, 6785),
+	CHAN6G(183, 6865),
+	CHAN6G(199, 6945),
+	CHAN6G(215, 7025)
+};
+
+const struct ieee80211_channel dpd_6g_ch_list_bw160[] = {
+	CHAN6G(15, 6025),
+	CHAN6G(47, 6185),
+	CHAN6G(79, 6345),
+	CHAN6G(111, 6505),
+	CHAN6G(143, 6665),
+	CHAN6G(175, 6825),
+	CHAN6G(207, 6985)
+};
+
+const struct ieee80211_channel dpd_6g_ch_list_bw320[] = {
+	CHAN6G(31, 6105),
+	CHAN6G(63, 6265),
+	CHAN6G(95, 6425),
+	CHAN6G(127, 6585),
+	CHAN6G(159, 6745),
+	CHAN6G(191, 6905)
+};
 
 static int mt7996_check_eeprom(struct mt7996_dev *dev)
 {
@@ -24,7 +98,7 @@ static int mt7996_check_eeprom(struct mt7996_dev *dev)
 	}
 }
 
-static char *mt7996_eeprom_name(struct mt7996_dev *dev)
+const char *mt7996_eeprom_name(struct mt7996_dev *dev)
 {
 	switch (mt76_chip(&dev->mt76)) {
 	case MT7992_DEVICE_ID:
@@ -153,7 +227,10 @@ mt7996_eeprom_check_or_use_default(struct mt7996_dev *dev, bool use_default)
 
 	dev_warn(dev->mt76.dev, "eeprom load fail, use default bin\n");
 	memcpy(eeprom, fw->data, MT7996_EEPROM_SIZE);
+	dev->bin_file_mode = false;
 	dev->flash_mode = true;
+	dev->eeprom_mode = DEFAULT_BIN_MODE;
+	eeprom[MT_EE_TESTMODE_EN] = dev->testmode_enable;
 
 out:
 	release_firmware(fw);
@@ -161,52 +238,126 @@ out:
 	return ret;
 }
 
-static int mt7996_eeprom_load(struct mt7996_dev *dev)
+static int
+mt7996_eeprom_load_bin(struct mt7996_dev *dev)
 {
-	bool use_default = false;
+	u8 *eeprom = dev->mt76.eeprom.data;
+	const struct firmware *fw = NULL;
 	int ret;
 
-	ret = mt76_eeprom_init(&dev->mt76, MT7996_EEPROM_SIZE);
-	if (ret < 0)
+	ret = request_firmware(&fw, dev->mt76.bin_file_name, dev->mt76.dev);
+	if (ret)
 		return ret;
 
-	if (ret && !mt7996_check_eeprom(dev)) {
-		dev->flash_mode = true;
+	if (!fw || !fw->data) {
+		dev_err(dev->mt76.dev, "Invalid bin %s\n", dev->mt76.bin_file_name);
+		ret = -EINVAL;
 		goto out;
 	}
 
+	memcpy(eeprom, fw->data, MT7996_EEPROM_SIZE);
+	dev->flash_mode = true;
+
+out:
+	release_firmware(fw);
+	return ret;
+}
+
+static int mt7996_eeprom_load_flash(struct mt7996_dev *dev)
+{
+	int ret = 1;
+
+	/* return > 0 for load success, return 0 for load failed, return < 0 for no memory */
+	dev->bin_file_mode = mt76_check_bin_file_mode(&dev->mt76);
+	if (dev->bin_file_mode) {
+		dev->mt76.eeprom.size = MT7996_EEPROM_SIZE;
+		dev->mt76.eeprom.data = devm_kzalloc(dev->mt76.dev, dev->mt76.eeprom.size,
+						     GFP_KERNEL);
+		if (!dev->mt76.eeprom.data)
+			return -ENOMEM;
+
+		if (mt7996_eeprom_load_bin(dev))
+			return 0;
+	} else {
+		ret = mt76_eeprom_init(&dev->mt76, MT7996_EEPROM_SIZE);
+	}
+
+	if (mt7996_check_eeprom(dev))
+		return 0;
+
+	return ret;
+}
+
+int mt7996_eeprom_check_fw_mode(struct mt7996_dev *dev)
+{
+	u8 *eeprom;
+	int ret;
+
+	dev->testmode_enable = testmode_enable;
+
+	/* load eeprom in flash or bin file mode to determine fw mode */
+	ret = mt7996_eeprom_load_flash(dev);
+	if (ret <= 0)
+		goto out;
+
+	dev->flash_mode = true;
+	dev->eeprom_mode = dev->bin_file_mode ? BIN_FILE_MODE : FLASH_MODE;
+	eeprom = dev->mt76.eeprom.data;
+	/* testmode enable priority: eeprom field > module parameter */
+	dev->testmode_enable = eeprom[MT_EE_TESTMODE_EN];
+
+out:
+	return ret;
+}
+
+static int mt7996_eeprom_load(struct mt7996_dev *dev)
+{
+	bool use_default = false;
+	int ret;
+
+	/* flash or bin file mode eeprom is loaded before mcu init */
 	if (!dev->flash_mode) {
-		u32 eeprom_blk_size = MT7996_EEPROM_BLOCK_SIZE;
-		u32 block_num = DIV_ROUND_UP(MT7996_EEPROM_SIZE, eeprom_blk_size);
+		u32 eeprom_blk_size, block_num;
 		u8 free_block_num;
 		int i;
 
 		memset(dev->mt76.eeprom.data, 0, MT7996_EEPROM_SIZE);
-		ret = mt7996_mcu_get_eeprom_free_block(dev, &free_block_num);
-		if (ret < 0)
-			return ret;
-
-		/* efuse info isn't enough */
-		if (free_block_num >= 59) {
-			use_default = true;
-			goto out;
+		if (!mt7996_has_ext_eeprom(dev)) {
+			/* efuse mode */
+			dev->eeprom_mode = EFUSE_MODE;
+			eeprom_blk_size = MT7996_EEPROM_BLOCK_SIZE;
+			ret = mt7996_mcu_get_efuse_free_block(dev, &free_block_num);
+			if (ret < 0)
+				return ret;
+
+			/* efuse info isn't enough */
+			if (free_block_num >= 59) {
+				use_default = true;
+				goto out;
+			}
+		} else {
+			/* external eeprom mode */
+			dev->eeprom_mode = EXT_EEPROM_MODE;
+			eeprom_blk_size = MT7996_EXT_EEPROM_BLOCK_SIZE;
 		}
 
 		/* check if eeprom data from fw is valid */
-		if (mt7996_mcu_get_eeprom(dev, 0, NULL, 0) ||
+		if (mt7996_mcu_get_eeprom(dev, 0, NULL, eeprom_blk_size,
+					  dev->eeprom_mode) ||
 		    mt7996_check_eeprom(dev)) {
 			use_default = true;
 			goto out;
 		}
 
 		/* read eeprom data from fw */
+		block_num = DIV_ROUND_UP(MT7996_EEPROM_SIZE, eeprom_blk_size);
 		for (i = 1; i < block_num; i++) {
 			u32 len = eeprom_blk_size;
 
 			if (i == block_num - 1)
 				len = MT7996_EEPROM_SIZE % eeprom_blk_size;
 			ret = mt7996_mcu_get_eeprom(dev, i * eeprom_blk_size,
-						    NULL, len);
+						    NULL, len, dev->eeprom_mode);
 			if (ret && ret != -EINVAL) {
 				use_default = true;
 				goto out;
@@ -320,14 +471,122 @@ int mt7996_eeprom_parse_hw_cap(struct mt7996_dev *dev, struct mt7996_phy *phy)
 	return mt7996_eeprom_parse_band_config(phy);
 }
 
+static int
+mt7996_eeprom_load_precal_binfile(struct mt7996_dev *dev, u32 offs, u32 size)
+{
+	const struct firmware *fw = NULL;
+	int ret;
+
+	ret = request_firmware(&fw, dev->mt76.bin_file_name, dev->mt76.dev);
+	if (ret)
+		return ret;
+
+	if (!fw || !fw->data) {
+		dev_err(dev->mt76.dev, "Invalid bin (bin file mode), load precal fail\n");
+		ret = -EINVAL;
+		goto out;
+	}
+
+	memcpy(dev->cal.data, fw->data + offs, size);
+
+out:
+	release_firmware(fw);
+
+	return ret;
+}
+
+static void mt7996_eeprom_init_precal(struct mt7996_dev *dev)
+{
+#define MT76_CHANNELS_5GHZ_SIZE		36	/* ARRAY_SIZE(mt76_channels_5ghz) */
+#define MT76_CHANNELS_6GHZ_SIZE		59	/* ARRAY_SIZE(mt76_channels_6ghz) */
+
+	dev->prek.dpd_ch_num[DPD_CH_NUM_BW20_2G] = ARRAY_SIZE(dpd_2g_ch_list_bw20);
+	dev->prek.dpd_ch_num[DPD_CH_NUM_BW20_5G_SKIP] = ARRAY_SIZE(dpd_5g_skip_ch_list);
+	dev->prek.dpd_ch_num[DPD_CH_NUM_BW20_5G] = MT76_CHANNELS_5GHZ_SIZE -
+						   DPD_CH_NUM(BW20_5G_SKIP);
+	dev->prek.dpd_ch_num[DPD_CH_NUM_BW160_5G] = ARRAY_SIZE(dpd_5g_ch_list_bw160);
+	dev->prek.dpd_ch_num[DPD_CH_NUM_BW20_6G] = MT76_CHANNELS_6GHZ_SIZE;
+	dev->prek.dpd_ch_num[DPD_CH_NUM_BW160_6G] = ARRAY_SIZE(dpd_6g_ch_list_bw160);
+
+	switch (mt76_chip(&dev->mt76)) {
+	case MT7996_DEVICE_ID:
+		dev->prek.rev = mt7996_prek_rev;
+		if (dev->var.type == MT7996_VAR_TYPE_233)
+			dev->prek.rev = mt7996_prek_rev_233;
+		/* 5g & 6g bw 80 dpd channel list is not used */
+		dev->prek.dpd_ch_num[DPD_CH_NUM_BW320_6G] = ARRAY_SIZE(dpd_6g_ch_list_bw320);
+		break;
+	case MT7992_DEVICE_ID:
+		dev->prek.rev = mt7992_prek_rev;
+		dev->prek.dpd_ch_num[DPD_CH_NUM_BW80_5G] = ARRAY_SIZE(dpd_5g_ch_list_bw80);
+		/* 6g is not used in current sku */
+		dev->prek.dpd_ch_num[DPD_CH_NUM_BW20_6G] = 0;
+		dev->prek.dpd_ch_num[DPD_CH_NUM_BW80_6G] = 0;
+		dev->prek.dpd_ch_num[DPD_CH_NUM_BW160_6G] = 0;
+		break;
+	case MT7990_DEVICE_ID:
+		dev->prek.rev = mt7990_prek_rev;
+		break;
+	default:
+		dev->prek.rev = mt7996_prek_rev;
+		break;
+	}
+}
+
+static int mt7996_eeprom_load_precal(struct mt7996_dev *dev)
+{
+	struct mt76_dev *mdev = &dev->mt76;
+	u8 *eeprom = mdev->eeprom.data;
+	u32 val = eeprom[MT_EE_DO_PRE_CAL];
+	u32 offs = MT_EE_PRECAL;
+	int ret;
+
+	mt7996_eeprom_init_precal(dev);
+
+	if (!dev->flash_mode || !val)
+		return 0;
+
+	dev->cal.size = MT_EE_CAL_GROUP_SIZE + MT_EE_CAL_DPD_SIZE;
+	dev->cal.data = devm_kzalloc(mdev->dev, dev->cal.size, GFP_KERNEL);
+	if (!dev->cal.data) {
+		ret = -ENOMEM;
+		goto fail;
+	}
+
+	if (dev->bin_file_mode) {
+		ret = mt7996_eeprom_load_precal_binfile(dev, offs, dev->cal.size);
+		if (ret)
+			goto fail;
+		return 0;
+	}
+
+	ret = mt76_get_of_data_from_mtd(mdev, dev->cal.data, offs, dev->cal.size);
+	if (!ret)
+		return 0;
+
+	ret = mt76_get_of_data_from_nvmem(mdev, dev->cal.data, "precal", dev->cal.size);
+	if (!ret)
+		return 0;
+
+fail:
+	dev_warn(dev->mt76.dev, "Failed to load precal data: %d\n", ret);
+	devm_kfree(dev->mt76.dev, dev->cal.data);
+	dev->cal.data = NULL;
+	dev->cal.size = 0;
+
+	return ret;
+}
+
 int mt7996_eeprom_init(struct mt7996_dev *dev)
 {
 	int ret;
 
 	ret = mt7996_eeprom_load(dev);
-	if (ret < 0)
+	if (ret)
 		return ret;
 
+	mt7996_eeprom_load_precal(dev);
+
 	ret = mt7996_eeprom_parse_hw_cap(dev, &dev->phy);
 	if (ret < 0)
 		return ret;
diff --git a/mt7996/eeprom.h b/mt7996/eeprom.h
index 9e6f0e04c..2bfcb1f53 100644
--- a/mt7996/eeprom.h
+++ b/mt7996/eeprom.h
@@ -14,6 +14,9 @@ enum mt7996_eeprom_field {
 	MT_EE_MAC_ADDR =	0x004,
 	MT_EE_MAC_ADDR2 =	0x00a,
 	MT_EE_WIFI_CONF =	0x190,
+	MT_EE_DO_RX_GAIN_CAL =	0x1a1,
+	MT_EE_DO_PRE_CAL =	0x1a5,
+	MT_EE_TESTMODE_EN =	0x1af,
 	MT_EE_MAC_ADDR3 =	0x2c0,
 	MT_EE_RATE_DELTA_2G =	0x1400,
 	MT_EE_RATE_DELTA_5G =	0x147d,
@@ -21,14 +24,133 @@ enum mt7996_eeprom_field {
 	MT_EE_TX0_POWER_2G =	0x1300,
 	MT_EE_TX0_POWER_5G =	0x1301,
 	MT_EE_TX0_POWER_6G =	0x1310,
+	MT_EE_RX_GAIN_CAL =	0x1830,
 
-	__MT_EE_MAX =	0x1dff,
+	__MT_EE_MAX =		0x1dff,
+	/* 0x1e10 ~ 0x2d644 used to save group cal data */
+	MT_EE_PRECAL =		0x1e10,
 };
 
 #define MT_EE_WIFI_CONF0_TX_PATH		GENMASK(2, 0)
 #define MT_EE_WIFI_CONF0_BAND_SEL		GENMASK(2, 0)
 #define MT_EE_WIFI_CONF1_BAND_SEL		GENMASK(5, 3)
 #define MT_EE_WIFI_CONF2_BAND_SEL		GENMASK(2, 0)
+#define MT_EE_WIFI_PA_LNA_CONFIG		GENMASK(1, 0)
+
+#define MT_EE_WIFI_CAL_RX_GAIN			GENMASK(5, 3)
+
+#define MT_EE_WIFI_CAL_GROUP_2G			BIT(0)
+#define MT_EE_WIFI_CAL_GROUP_5G			BIT(1)
+#define MT_EE_WIFI_CAL_GROUP_6G			BIT(2)
+#define MT_EE_WIFI_CAL_GROUP			GENMASK(2, 0)
+#define MT_EE_WIFI_CAL_DPD_2G			BIT(3)
+#define MT_EE_WIFI_CAL_DPD_5G			BIT(4)
+#define MT_EE_WIFI_CAL_DPD_6G			BIT(5)
+#define MT_EE_WIFI_CAL_DPD			GENMASK(5, 3)
+
+#define MT_EE_CAL_UNIT				1024
+
+enum mt7996_prek_rev {
+	GROUP_SIZE_2G,
+	GROUP_SIZE_5G,
+	GROUP_SIZE_6G,
+	ADCDCOC_SIZE_2G,
+	ADCDCOC_SIZE_5G,
+	ADCDCOC_SIZE_6G,
+	DPD_LEGACY_SIZE,
+	DPD_MEM_SIZE,
+	DPD_OTFG0_SIZE,
+};
+
+static const u32 mt7996_prek_rev[] = {
+	[GROUP_SIZE_2G] =			4 * MT_EE_CAL_UNIT,
+	[GROUP_SIZE_5G] =			45 * MT_EE_CAL_UNIT,
+	[GROUP_SIZE_6G] =			125 * MT_EE_CAL_UNIT,
+	[ADCDCOC_SIZE_2G] =			4 * 4,
+	[ADCDCOC_SIZE_5G] =			4 * 4,
+	[ADCDCOC_SIZE_6G] =			4 * 5,
+	[DPD_LEGACY_SIZE] =			4 * MT_EE_CAL_UNIT,
+	[DPD_MEM_SIZE] =			13 * MT_EE_CAL_UNIT,
+	[DPD_OTFG0_SIZE] =			2 * MT_EE_CAL_UNIT,
+};
+
+static const u32 mt7996_prek_rev_233[] = {
+	[GROUP_SIZE_2G] =			4 * MT_EE_CAL_UNIT,
+	[GROUP_SIZE_5G] =			44 * MT_EE_CAL_UNIT,
+	[GROUP_SIZE_6G] =			125 * MT_EE_CAL_UNIT,
+	[ADCDCOC_SIZE_2G] =			4 * 4,
+	[ADCDCOC_SIZE_5G] =			4 * 4,
+	[ADCDCOC_SIZE_6G] =			4 * 5,
+	[DPD_LEGACY_SIZE] =			4 * MT_EE_CAL_UNIT,
+	[DPD_MEM_SIZE] =			13 * MT_EE_CAL_UNIT,
+	[DPD_OTFG0_SIZE] =			2 * MT_EE_CAL_UNIT,
+};
+
+/* kite 2/5g config */
+static const u32 mt7992_prek_rev[] = {
+	[GROUP_SIZE_2G] =			4 * MT_EE_CAL_UNIT,
+	[GROUP_SIZE_5G] =			110 * MT_EE_CAL_UNIT,
+	[GROUP_SIZE_6G] =			0,
+	[ADCDCOC_SIZE_2G] =			4 * 4,
+	[ADCDCOC_SIZE_5G] =			4 * 5,
+	[ADCDCOC_SIZE_6G] =			0,
+	[DPD_LEGACY_SIZE] =			5 * MT_EE_CAL_UNIT,
+	[DPD_MEM_SIZE] =			16 * MT_EE_CAL_UNIT,
+	[DPD_OTFG0_SIZE] =			2 * MT_EE_CAL_UNIT,
+};
+
+static const u32 mt7990_prek_rev[] = {
+	[GROUP_SIZE_2G] =			4 * MT_EE_CAL_UNIT,
+	[GROUP_SIZE_5G] =			45 * MT_EE_CAL_UNIT,
+	[GROUP_SIZE_6G] =			90 * MT_EE_CAL_UNIT,
+	[ADCDCOC_SIZE_2G] =			4 * 2,
+	[ADCDCOC_SIZE_5G] =			4 * 3,
+	[ADCDCOC_SIZE_6G] =			4 * 3,
+	[DPD_LEGACY_SIZE] =			5 * MT_EE_CAL_UNIT,
+	/* no mem dpd cal for griffin, use legacy dpd cal instead */
+	[DPD_MEM_SIZE] =			0,
+	[DPD_OTFG0_SIZE] =			2 * MT_EE_CAL_UNIT,
+};
+
+extern const struct ieee80211_channel dpd_2g_ch_list_bw20[];
+extern const struct ieee80211_channel dpd_5g_skip_ch_list[];
+extern const struct ieee80211_channel dpd_5g_ch_list_bw80[];
+extern const struct ieee80211_channel dpd_5g_ch_list_bw160[];
+extern const struct ieee80211_channel dpd_6g_ch_list_bw80[];
+extern const struct ieee80211_channel dpd_6g_ch_list_bw160[];
+extern const struct ieee80211_channel dpd_6g_ch_list_bw320[];
+
+#define PREK(id)				(dev->prek.rev[(id)])
+#define DPD_CH_NUM(_type)			(dev->prek.dpd_ch_num[DPD_CH_NUM_##_type])
+#define MT_EE_CAL_GROUP_SIZE			(PREK(GROUP_SIZE_2G) + PREK(GROUP_SIZE_5G) + \
+						 PREK(GROUP_SIZE_6G) + PREK(ADCDCOC_SIZE_2G) + \
+						 PREK(ADCDCOC_SIZE_5G) + PREK(ADCDCOC_SIZE_6G))
+#define DPD_PER_CH_BW20_SIZE			(PREK(DPD_LEGACY_SIZE) + PREK(DPD_OTFG0_SIZE))
+#define DPD_PER_CH_GT_BW20_SIZE			(PREK(DPD_MEM_SIZE) ? PREK(DPD_MEM_SIZE) + \
+								      PREK(DPD_OTFG0_SIZE) : \
+								      DPD_PER_CH_BW20_SIZE)
+#define MT_EE_CAL_DPD_SIZE_2G			(DPD_CH_NUM(BW20_2G) * DPD_PER_CH_BW20_SIZE)
+#define MT_EE_CAL_DPD_SIZE_5G			(DPD_CH_NUM(BW20_5G) * DPD_PER_CH_BW20_SIZE + \
+						 DPD_CH_NUM(BW80_5G) * DPD_PER_CH_GT_BW20_SIZE + \
+						 DPD_CH_NUM(BW160_5G) * DPD_PER_CH_GT_BW20_SIZE)
+#define MT_EE_CAL_DPD_SIZE_6G			(DPD_CH_NUM(BW20_6G) * DPD_PER_CH_BW20_SIZE + \
+						 DPD_CH_NUM(BW80_6G) * DPD_PER_CH_GT_BW20_SIZE + \
+						 DPD_CH_NUM(BW160_6G) * DPD_PER_CH_GT_BW20_SIZE + \
+						 DPD_CH_NUM(BW320_6G) * DPD_PER_CH_GT_BW20_SIZE)
+#define MT_EE_CAL_DPD_SIZE			(MT_EE_CAL_DPD_SIZE_2G + MT_EE_CAL_DPD_SIZE_5G + \
+						 MT_EE_CAL_DPD_SIZE_6G)
+
+#define MT_EE_CAL_RX_GAIN_SIZE			748
+
+enum rf_cal_item {
+	RF_RX_GAIN_CAL = BIT(24),
+	RF_DPD_FLAT_CAL = BIT(28),
+	RF_PRE_CAL = BIT(29),
+	RF_DPD_FLAT_5G_CAL = GENMASK(29, 28),
+	RF_DPD_FLAT_5G_MEM_CAL = (BIT(30) | BIT(28)),
+	RF_DPD_FLAT_6G_CAL = GENMASK(30, 28),
+	RF_DPD_FLAT_6G_MEM_CAL = (BIT(31) | BIT(28)),
+};
 
 #define MT_EE_WIFI_CONF1_TX_PATH_BAND0		GENMASK(5, 3)
 #define MT_EE_WIFI_CONF2_TX_PATH_BAND1		GENMASK(2, 0)
diff --git a/mt7996/init.c b/mt7996/init.c
index 08ef87b70..01acf9606 100644
--- a/mt7996/init.c
+++ b/mt7996/init.c
@@ -486,6 +486,7 @@ mt7996_init_wiphy_band(struct ieee80211_hw *hw, struct mt7996_phy *phy)
 	}
 
 	dev->radio_phy[n_radios] = phy;
+	dev->mt76.radio_phy[n_radios] = phy->mt76;
 	radio->freq_range = freq;
 	radio->n_freq_range = 1;
 	radio->iface_combinations = &if_comb;
@@ -1214,7 +1215,8 @@ static int mt7996_variant_fem_init(struct mt7996_dev *dev)
 	if (ret)
 		return ret;
 
-	ret = mt7996_mcu_get_eeprom(dev, MT7976C_EFUSE_OFFSET, buf, sizeof(buf));
+	ret = mt7996_mcu_get_eeprom(dev, MT7976C_EFUSE_OFFSET, buf, sizeof(buf),
+				    EFUSE_MODE);
 	if (ret && ret != -EINVAL)
 		return ret;
 
@@ -1260,6 +1262,10 @@ static int mt7996_init_hardware(struct mt7996_dev *dev)
 
 	set_bit(MT76_STATE_INITIALIZED, &dev->mphy.state);
 
+	ret = mt7996_eeprom_check_fw_mode(dev);
+	if (ret < 0)
+		return ret;
+
 	ret = mt7996_mcu_init(dev);
 	if (ret)
 		return ret;
@@ -1276,6 +1282,12 @@ static int mt7996_init_hardware(struct mt7996_dev *dev)
 	if (ret < 0)
 		return ret;
 
+	if (dev->cal.data) {
+		ret = mt7996_mcu_apply_group_cal(dev);
+		if (ret)
+			return ret;
+	}
+
 	/* Beacon and mgmt frames should occupy wcid 0 */
 	idx = mt76_wcid_alloc(dev->mt76.wcid_mask, MT7996_WTBL_STA);
 	if (idx)
@@ -1735,6 +1747,10 @@ int mt7996_register_device(struct mt7996_dev *dev)
 
 	mt7996_init_wiphy(hw, &dev->mt76.mmio.wed);
 
+#ifdef CONFIG_NL80211_TESTMODE
+	dev->mt76.test_ops = &mt7996_testmode_ops;
+#endif
+
 	ret = mt7996_register_phy(dev, MT_BAND1);
 	if (ret)
 		return ret;
diff --git a/mt7996/main.c b/mt7996/main.c
index 1fc2387a5..cd932e4f3 100644
--- a/mt7996/main.c
+++ b/mt7996/main.c
@@ -7,6 +7,20 @@
 #include "mcu.h"
 #include "mac.h"
 
+static void mt7996_testmode_disable_all(struct mt7996_dev *dev)
+{
+#ifdef CONFIG_NL80211_TESTMODE
+	struct mt7996_phy *phy;
+	int i;
+
+	for (i = 0; i < __MT_MAX_BAND; i++) {
+		phy = __mt7996_phy(dev, i);
+		if (phy)
+			mt76_testmode_set_state(phy->mt76, MT76_TM_STATE_OFF);
+	}
+#endif
+}
+
 int mt7996_run(struct mt7996_phy *phy)
 {
 	struct mt7996_dev *dev = phy->dev;
@@ -304,13 +318,23 @@ int mt7996_vif_link_add(struct mt76_phy *mphy, struct ieee80211_vif *vif,
 	struct mt76_txq *mtxq;
 	int mld_idx, idx, ret;
 
-	mlink->idx = __ffs64(~dev->mt76.vif_mask);
-	if (mlink->idx >= mt7996_max_interface_num(dev))
-		return -ENOSPC;
+	if (!dev->testmode_enable) {
+		mlink->idx = __ffs64(~dev->mt76.vif_mask);
+		if (mlink->idx >= mt7996_max_interface_num(dev))
+			return -ENOSPC;
 
-	idx = get_omac_idx(vif->type, phy->omac_mask);
-	if (idx < 0)
-		return -ENOSPC;
+		idx = get_omac_idx(vif->type, phy->omac_mask);
+		if (idx < 0)
+			return -ENOSPC;
+	} else {
+		/* bss idx & omac idx should be set to band idx for ibf cal */
+		if (dev->mt76.vif_mask & BIT_ULL(band_idx) ||
+		    phy->omac_mask & BIT_ULL(band_idx))
+			return -ENOSPC;
+
+		mlink->idx = band_idx;
+		idx = band_idx;
+	}
 
 	mld_idx = get_own_mld_idx(dev->mld_idx_mask, false);
 	if (mld_idx < 0)
@@ -490,8 +514,15 @@ static int mt7996_add_interface(struct ieee80211_hw *hw,
 	struct mt7996_dev *dev = mt7996_hw_dev(hw);
 	int i, err = 0;
 
+	if (dev->testmode_enable && vif->type != NL80211_IFTYPE_MONITOR) {
+		dev_err(dev->mt76.dev, "Only monitor interface is allowed in testmode\n");
+		return -EINVAL;
+	}
+
 	mutex_lock(&dev->mt76.mutex);
 
+	mt7996_testmode_disable_all(dev);
+
 	for (i = 0; i < MT7996_MAX_RADIOS; i++) {
 		struct mt7996_phy *phy = dev->radio_phy[i];
 
@@ -503,8 +534,10 @@ static int mt7996_add_interface(struct ieee80211_hw *hw,
 		if (err)
 			goto out;
 
-		if (vif->type == NL80211_IFTYPE_MONITOR)
+		if (vif->type == NL80211_IFTYPE_MONITOR) {
 			mt7996_set_monitor(phy, true);
+			phy->mt76->monitor_vif = vif;
+		}
 	}
 
 	mt76_vif_init(vif, &mvif->mt76);
@@ -552,10 +585,21 @@ static void mt7996_remove_interface(struct ieee80211_hw *hw,
 
 		if (!phy)
 			continue;
-		if (!(rdata.monitor_mask & BIT(i)))
+		if (vif->type == NL80211_IFTYPE_MONITOR &&
+		    !(rdata.monitor_mask & BIT(i)))
 			mt7996_set_monitor(phy, false);
 		if (!(rdata.active_mask & BIT(i)))
 			mt7996_stop_phy(phy);
+
+		if (vif == phy->mt76->monitor_vif) {
+			mutex_lock(&dev->mt76.mutex);
+			phy->mt76->monitor_vif = NULL;
+#ifdef CONFIG_NL80211_TESTMODE
+			if (dev->testmode_enable)
+				kfree(phy->mt76->lists);
+#endif
+			mutex_unlock(&dev->mt76.mutex);
+		}
 	}
 }
 
@@ -567,6 +611,17 @@ int mt7996_set_channel(struct mt76_phy *mphy)
 	if (mphy->offchannel)
 		mt7996_mac_update_beacons(phy);
 
+	if (phy->dev->cal.data) {
+		ret = mt7996_mcu_apply_tx_dpd(phy);
+		if (ret)
+			goto out;
+	}
+
+	if (mt76_testmode_enabled(mphy) || mt76_testmode_bf_enabled(mphy)) {
+		mt7996_tm_update_channel(phy);
+		goto out;
+	}
+
 	ret = mt7996_mcu_set_chan_info(phy, UNI_CHANNEL_SWITCH);
 	if (ret)
 		goto out;
@@ -2354,7 +2409,6 @@ mt7996_net_fill_forward_path(struct ieee80211_hw *hw,
 			     struct net_device_path *path)
 {
 #ifdef CONFIG_NET_MEDIATEK_SOC_WED
-	struct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;
 	struct mt7996_sta *msta = (struct mt7996_sta *)sta->drv_priv;
 	struct mt7996_dev *dev = mt7996_hw_dev(hw);
 	struct mtk_wed_device *wed = &dev->mt76.mmio.wed;
@@ -2533,5 +2587,7 @@ const struct ieee80211_ops mt7996_ops = {
 	.change_vif_links = mt7996_change_vif_links,
 	.change_sta_links = mt7996_mac_sta_change_links,
 	.reconfig_complete = mt7996_reconfig_complete,
+	CFG80211_TESTMODE_CMD(mt76_testmode_cmd)
+	CFG80211_TESTMODE_DUMP(mt76_testmode_dump)
 	.set_qos_map = mt7996_set_qos_map,
 };
diff --git a/mt7996/mcu.c b/mt7996/mcu.c
index db5198056..cd6e128d3 100644
--- a/mt7996/mcu.c
+++ b/mt7996/mcu.c
@@ -1100,6 +1100,16 @@ mt7996_mcu_uni_rx_unsolicited_event(struct mt7996_dev *dev, struct sk_buff *skb)
 	case MCU_UNI_EVENT_THERMAL:
 		mt7996_mcu_rx_thermal_info_query(dev, skb);
 		break;
+#ifdef CONFIG_NL80211_TESTMODE
+	case MCU_UNI_EVENT_TESTMODE_CTRL:
+		mt7996_tm_rf_test_event(dev, skb);
+		break;
+#endif
+#if defined CONFIG_NL80211_TESTMODE || defined CONFIG_MTK_DEBUG
+	case MCU_UNI_EVENT_BF:
+		mt7996_mcu_rx_bf_event(dev, skb);
+		break;
+#endif
 	default:
 		break;
 	}
@@ -1422,6 +1432,10 @@ mt7996_mcu_bss_basic_tlv(struct sk_buff *skb,
 
 	if (vif->type == NL80211_IFTYPE_MONITOR) {
 		memcpy(bss->bssid, phy->macaddr, ETH_ALEN);
+#ifdef CONFIG_NL80211_TESTMODE
+		if (mt76_testmode_bf_enabled(phy))
+			memcpy(bss->bssid, phy->test.addr[2], ETH_ALEN);
+#endif
 		return 0;
 	}
 
@@ -4196,23 +4210,172 @@ int mt7996_mcu_set_chan_info(struct mt7996_phy *phy, u16 tag)
 				 &req, sizeof(req), true);
 }
 
-static int mt7996_mcu_set_eeprom_flash(struct mt7996_dev *dev)
+static int mt7996_mcu_get_cal_free_data(struct mt7996_dev *dev)
+{
+#define MT_EE_CAL_FREE_MAX_SIZE		30
+#define MT_EE_7977BN_OFFSET		(0x1200 - 0x500)
+#define MT_EE_END_OFFSET		0xffff
+	static const u16 adie_offs_list[][MT_EE_CAL_FREE_MAX_SIZE] = {
+		[ADIE_7975] = {0x5cd, 0x5cf, 0x5d1, 0x5d3, 0x6c0, 0x6c1, 0x6c2, 0x6c3,
+			       0x7a1, 0x7a6, 0x7a8, 0x7aa, -1},
+		[ADIE_7976] = {0x4c, 0x4d, 0x4e, 0x4f, 0x50, 0x51, 0x53, 0x55, 0x57, 0x59,
+			       0x70, 0x71, 0x790, 0x791, 0x794, 0x795, 0x7a6, 0x7a8, 0x7aa, -1},
+		[ADIE_7977] = {0x4c, 0x4d, 0x4e, 0x4f, 0x50, 0x51, 0x53, 0x55, 0x57, 0x59,
+			       0x69, 0x6a, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, -1},
+		[ADIE_7978] = {0x91, 0x95, 0x100, 0x102, 0x104, 0x106, 0x107,
+			       0x108, 0x109, 0x10a, 0x10b, 0x10c, 0x10e, 0x110, -1},
+		[ADIE_7979] = {0x4c, 0x4d, 0x4e, 0x4f, 0x50, 0x51, 0x53, 0x55, 0x57, 0x59,
+			       0x69, 0x6a, 0x7a, 0x7b, 0x7c, 0x7e, 0x80, -1},
+	};
+	static const u16 eep_offs_list[][MT_EE_CAL_FREE_MAX_SIZE] = {
+		[ADIE_7975] = {0x451, 0x453, 0x455, 0x457, 0x44c, 0x44d, 0x44e, 0x44f,
+			       0xba1, 0xba6, 0xba8, 0xbaa, -1},
+		[ADIE_7976] = {0x44c, 0x44d, 0x44e, 0x44f, 0x450,
+			       0x451, 0x453, 0x455, 0x457, 0x459,
+			       0x470, 0x471, 0xb90, 0xb91, 0xb94, 0xb95,
+			       0xba6, 0xba8, 0xbaa, -1},
+		[ADIE_7977] = {0x124c, 0x124d, 0x124e, 0x124f, 0x1250,
+			       0x1251, 0x1253, 0x1255, 0x1257, 0x1259,
+			       0x1269, 0x126a, 0x127a, 0x127b, 0x127c, 0x127d, 0x127e, -1},
+		[ADIE_7978] = {0xb91, 0xb95, 0x480, 0x482, 0x484, 0x486, 0x487, 0x488, 0x489,
+			       0x48a, 0x48b, 0x48c, 0x48e, 0x490, -1},
+		[ADIE_7979] = {0x124c, 0x124d, 0x124e, 0x124f, 0x1250, 0x1251,
+			       0x1253, 0x1255, 0x1257, 0x1259, 0x1269, 0x126a,
+			       0x127a, 0x127b, 0x127c, 0x127e, 0x1280, -1},
+	};
+	static const u16 adie_base_7996[] = {
+		EFUSE_BASE_OFFS_ADIE0, EFUSE_BASE_OFFS_ADIE1, EFUSE_BASE_OFFS_ADIE2
+	};
+	static const u16 adie_base_7992[] = {
+		EFUSE_BASE_OFFS_ADIE0, EFUSE_BASE_OFFS_ADIE1_7992, 0x0
+	};
+	static const u16 adie_base_7990[] = {
+		EFUSE_BASE_OFFS_ADIE0, 0x0, 0x0
+	};
+	static const u16 *adie_offs[__MT_MAX_BAND];
+	static const u16 *eep_offs[__MT_MAX_BAND];
+	static const u16 *adie_base;
+	int adie_id, band, i, ret;
+	u8 *eep;
+
+	switch (mt76_chip(&dev->mt76)) {
+	case MT7996_DEVICE_ID:
+		adie_base = adie_base_7996;
+		/* adie 0 */
+		if (dev->var.fem == MT7996_FEM_INT && dev->var.type != MT7996_VAR_TYPE_233)
+			adie_id = ADIE_7975;
+		else
+			adie_id = ADIE_7976;
+		adie_offs[0] = adie_offs_list[adie_id];
+		eep_offs[0] = eep_offs_list[adie_id];
+
+		/* adie 1 */
+		if (dev->var.type == MT7996_VAR_TYPE_444) {
+			adie_offs[1] = adie_offs_list[ADIE_7977];
+			eep_offs[1] = eep_offs_list[ADIE_7977];
+		}
+
+		/* adie 2 */
+		adie_offs[2] = adie_offs_list[ADIE_7977];
+		eep_offs[2] = eep_offs_list[ADIE_7977];
+		break;
+	case MT7992_DEVICE_ID:
+		adie_base = adie_base_7992;
+		/* adie 0 */
+		if (dev->var.type == MT7992_VAR_TYPE_44 &&
+		    dev->var.fem != MT7996_FEM_EXT)
+			adie_id = ADIE_7975;
+		else if (dev->var.type == MT7992_VAR_TYPE_24)
+			adie_id = ADIE_7978;
+		else
+			adie_id = ADIE_7976;
+		adie_offs[0] = adie_offs_list[adie_id];
+		eep_offs[0] = eep_offs_list[adie_id];
+
+		/* adie 1 */
+		if (dev->var.type == MT7992_VAR_TYPE_44 &&
+		    dev->var.fem != MT7996_FEM_INT)
+			adie_id = ADIE_7977;
+		else if (dev->var.type != MT7992_VAR_TYPE_23)
+			adie_id = ADIE_7979;
+		else
+			break;
+		adie_offs[1] = adie_offs_list[adie_id];
+		eep_offs[1] = eep_offs_list[adie_id];
+		break;
+	case MT7990_DEVICE_ID:
+		adie_base = adie_base_7990;
+		/* adie 0 */
+		adie_id = ADIE_7976;
+		adie_offs[0] = adie_offs_list[adie_id];
+		eep_offs[0] = eep_offs_list[adie_id];
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	eep = (u8 *)dev->mt76.eeprom.data;
+	for (band = 0; band < __MT_MAX_BAND; band++) {
+		u32 block_num, prev_block_num = -1;
+
+		if (!adie_offs[band])
+			continue;
+
+		for (i = 0; i < MT_EE_CAL_FREE_MAX_SIZE; i++) {
+			u16 adie_offset, eep_offset;
+			u8 buf[MT7996_EEPROM_BLOCK_SIZE];
+
+			adie_offset = adie_offs[band][i] + adie_base[band];
+			eep_offset = eep_offs[band][i];
+			block_num = adie_offset / MT7996_EEPROM_BLOCK_SIZE;
+
+			if (adie_offs[band][i] == MT_EE_END_OFFSET)
+				break;
+
+			if (is_mt7996(&dev->mt76) && dev->var.type == MT7996_VAR_TYPE_444 &&
+			    band == MT_BAND1)
+				eep_offset -= MT_EE_7977BN_OFFSET;
+
+			if (prev_block_num != block_num) {
+				ret = mt7996_mcu_get_eeprom(dev, adie_offset, buf,
+							    MT7996_EEPROM_BLOCK_SIZE,
+							    EFUSE_MODE);
+				if (ret) {
+					if (ret != -EINVAL)
+						return ret;
+					prev_block_num = -1;
+					continue;
+				}
+			}
+			eep[eep_offset] = buf[adie_offset % MT7996_EEPROM_BLOCK_SIZE];
+			prev_block_num = block_num;
+		}
+	}
+
+	return 0;
+}
+
+int mt7996_mcu_set_eeprom(struct mt7996_dev *dev)
 {
 #define MAX_PAGE_IDX_MASK	GENMASK(7, 5)
 #define PAGE_IDX_MASK		GENMASK(4, 2)
 #define PER_PAGE_SIZE		0x400
-	struct mt7996_mcu_eeprom req = {
+	struct mt7996_mcu_eeprom_update req = {
 		.tag = cpu_to_le16(UNI_EFUSE_BUFFER_MODE),
 		.buffer_mode = EE_MODE_BUFFER
 	};
 	u16 eeprom_size = MT7996_EEPROM_SIZE;
 	u8 total = DIV_ROUND_UP(eeprom_size, PER_PAGE_SIZE);
 	u8 *eep = (u8 *)dev->mt76.eeprom.data;
-	int eep_len, i;
+	int ret, eep_len, i;
+
+	ret = mt7996_mcu_get_cal_free_data(dev);
+	if (ret)
+		return ret;
 
 	for (i = 0; i < total; i++, eep += eep_len) {
 		struct sk_buff *skb;
-		int ret, msg_len;
+		int msg_len;
 
 		if (i == total - 1 && !!(eeprom_size % PER_PAGE_SIZE))
 			eep_len = eeprom_size % PER_PAGE_SIZE;
@@ -4241,59 +4404,63 @@ static int mt7996_mcu_set_eeprom_flash(struct mt7996_dev *dev)
 	return 0;
 }
 
-int mt7996_mcu_set_eeprom(struct mt7996_dev *dev)
-{
-	struct mt7996_mcu_eeprom req = {
-		.tag = cpu_to_le16(UNI_EFUSE_BUFFER_MODE),
-		.len = cpu_to_le16(sizeof(req) - 4),
-		.buffer_mode = EE_MODE_EFUSE,
-		.format = EE_FORMAT_WHOLE
-	};
-
-	if (dev->flash_mode)
-		return mt7996_mcu_set_eeprom_flash(dev);
-
-	return mt76_mcu_send_msg(&dev->mt76, MCU_WM_UNI_CMD(EFUSE_CTRL),
-				 &req, sizeof(req), true);
-}
-
-int mt7996_mcu_get_eeprom(struct mt7996_dev *dev, u32 offset, u8 *buf, u32 buf_len)
+int mt7996_mcu_get_eeprom(struct mt7996_dev *dev, u32 offset, u8 *buf, u32 buf_len,
+			  enum mt7996_eeprom_mode mode)
 {
-	struct {
-		u8 _rsv[4];
-
-		__le16 tag;
-		__le16 len;
-		__le32 addr;
-		__le32 valid;
-		u8 data[16];
-	} __packed req = {
-		.tag = cpu_to_le16(UNI_EFUSE_ACCESS),
-		.len = cpu_to_le16(sizeof(req) - 4),
-		.addr = cpu_to_le32(round_down(offset,
-				    MT7996_EEPROM_BLOCK_SIZE)),
-	};
+	struct mt7996_mcu_eeprom_access req;
+	struct mt7996_mcu_eeprom_access_event *event;
 	struct sk_buff *skb;
-	bool valid;
-	int ret;
+	int ret, cmd;
 
-	ret = mt76_mcu_send_and_get_msg(&dev->mt76,
-					MCU_WM_UNI_CMD_QUERY(EFUSE_CTRL),
-					&req, sizeof(req), true, &skb);
+	switch (mode) {
+	case EFUSE_MODE:
+		req.info.tag = cpu_to_le16(UNI_EFUSE_ACCESS);
+		req.info.len = cpu_to_le16(sizeof(req) - 4);
+		req.info.addr = cpu_to_le32(round_down(offset, MT7996_EEPROM_BLOCK_SIZE));
+		cmd = MCU_WM_UNI_CMD_QUERY(EFUSE_CTRL);
+		break;
+	case EXT_EEPROM_MODE:
+		req.info.tag = cpu_to_le16(UNI_EXT_EEPROM_ACCESS);
+		req.info.len = cpu_to_le16(sizeof(req) - 4);
+		req.info.addr = cpu_to_le32(round_down(offset, MT7996_EXT_EEPROM_BLOCK_SIZE));
+		req.eeprom.ext_eeprom.data_len = cpu_to_le32(buf_len);
+		cmd = MCU_WM_UNI_CMD_QUERY(EXT_EEPROM_CTRL);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	ret = mt76_mcu_send_and_get_msg(&dev->mt76, cmd, &req,
+					sizeof(req), true, &skb);
 	if (ret)
 		return ret;
 
-	valid = le32_to_cpu(*(__le32 *)(skb->data + 16));
-	if (valid) {
-		u32 addr = le32_to_cpu(*(__le32 *)(skb->data + 12));
+	event = (struct mt7996_mcu_eeprom_access_event *)skb->data;
+	if (event->valid) {
+		u32 addr = le32_to_cpu(event->addr);
+		u32 ret_len = le32_to_cpu(event->eeprom.ext_eeprom.data_len);
 
 		if (!buf)
 			buf = (u8 *)dev->mt76.eeprom.data + addr;
-		if (!buf_len || buf_len > MT7996_EEPROM_BLOCK_SIZE)
-			buf_len = MT7996_EEPROM_BLOCK_SIZE;
 
-		skb_pull(skb, 48);
-		memcpy(buf, skb->data, buf_len);
+		switch (mode) {
+		case EFUSE_MODE:
+			if (!buf_len || buf_len > MT7996_EEPROM_BLOCK_SIZE)
+				buf_len = MT7996_EEPROM_BLOCK_SIZE;
+
+			memcpy(buf, event->eeprom.efuse, buf_len);
+			break;
+		case EXT_EEPROM_MODE:
+			if (!buf_len || buf_len > MT7996_EXT_EEPROM_BLOCK_SIZE)
+				buf_len = MT7996_EXT_EEPROM_BLOCK_SIZE;
+
+			memcpy(buf, event->eeprom.ext_eeprom.data,
+			       ret_len < buf_len ? ret_len : buf_len);
+			break;
+		default:
+			ret = -EINVAL;
+			break;
+		}
 	} else {
 		ret = -EINVAL;
 	}
@@ -4303,7 +4470,57 @@ int mt7996_mcu_get_eeprom(struct mt7996_dev *dev, u32 offset, u8 *buf, u32 buf_l
 	return ret;
 }
 
-int mt7996_mcu_get_eeprom_free_block(struct mt7996_dev *dev, u8 *block_num)
+int
+mt7996_mcu_write_ext_eeprom(struct mt7996_dev *dev, u32 offset,
+			    u32 data_len, u8 *write_buf)
+{
+	struct mt7996_mcu_eeprom_access req = {
+		.info.tag = cpu_to_le16(UNI_EXT_EEPROM_ACCESS),
+		.info.len = cpu_to_le16(sizeof(req) - 4 +
+					MT7996_EXT_EEPROM_BLOCK_SIZE),
+	};
+	u32 block_num, block_size = MT7996_EXT_EEPROM_BLOCK_SIZE;
+	u8 *buf = write_buf;
+	int i, ret = -EINVAL;
+	int msg_len = sizeof(req) + block_size;
+
+	if (!mt7996_has_ext_eeprom(dev))
+		return ret;
+
+	if (!buf)
+		buf = (u8 *)dev->mt76.eeprom.data + offset;
+
+	block_num = DIV_ROUND_UP(data_len, block_size);
+	for (i = 0; i < block_num; i++) {
+		struct sk_buff *skb;
+		u32 buf_len = block_size;
+		u32 block_offs = i * block_size;
+
+		if (block_offs + block_size > data_len)
+			buf_len = data_len % block_size;
+
+		req.info.addr = cpu_to_le32(offset + block_offs);
+		req.eeprom.ext_eeprom.data_len = cpu_to_le32(buf_len);
+
+		skb = mt76_mcu_msg_alloc(&dev->mt76, NULL, msg_len);
+		if (!skb)
+			return -ENOMEM;
+
+		skb_put_data(skb, &req, sizeof(req));
+		skb_put_data(skb, buf, buf_len);
+
+		ret = mt76_mcu_skb_send_msg(&dev->mt76, skb,
+					    MCU_WM_UNI_CMD(EXT_EEPROM_CTRL), false);
+		if (ret)
+			return ret;
+
+		buf += buf_len;
+	}
+
+	return 0;
+}
+
+int mt7996_mcu_get_efuse_free_block(struct mt7996_dev *dev, u8 *block_num)
 {
 	struct {
 		u8 _rsv[4];
@@ -4333,6 +4550,192 @@ int mt7996_mcu_get_eeprom_free_block(struct mt7996_dev *dev, u8 *block_num)
 	return 0;
 }
 
+static int mt7996_mcu_set_pre_cal(struct mt7996_dev *dev, u32 idx,
+				  u8 *cal, u32 len, u32 cal_id)
+{
+#define PRECAL_CMD_PRE_CAL_RESULT	0x0
+	struct {
+		/* fixed field */
+		u8 action;
+		u8 dest;
+		u8 attribute;
+		u8 tag_num;
+
+		__le16 tag;
+		__le16 len;
+
+		__le32 cal_id;
+		s8 precal;
+		u8 band;
+		u8 rsv[2];
+		__le32 idx;
+		__le32 cal_len;
+	} req = {
+		.tag = cpu_to_le16(PRECAL_CMD_PRE_CAL_RESULT),
+		.len = cpu_to_le16(sizeof(req) - 4 + len),
+		.cal_id = cpu_to_le32(cal_id),
+		.idx = cpu_to_le32(idx),
+		.cal_len = cpu_to_le32(len),
+	};
+	struct sk_buff *skb;
+
+	if (!len)
+		return 0;
+
+	skb = mt76_mcu_msg_alloc(&dev->mt76, NULL, sizeof(req) + len);
+	if (!skb)
+		return -ENOMEM;
+
+	skb_put_data(skb, &req, sizeof(req));
+	skb_put_data(skb, cal, len);
+
+	return mt76_mcu_skb_send_msg(&dev->mt76, skb, MCU_WM_UNI_CMD(PRECAL_RESULT), false);
+}
+
+int mt7996_mcu_apply_group_cal(struct mt7996_dev *dev)
+{
+	u8 *cal = dev->cal.data, *eeprom = dev->mt76.eeprom.data;
+	u32 idx = 0, total_idx = MT_EE_CAL_GROUP_SIZE / MT_EE_CAL_UNIT;
+	u32 offs = MT_EE_DO_PRE_CAL;
+	int ret = 0;
+
+	if (!(eeprom[offs] & MT_EE_WIFI_CAL_GROUP))
+		return 0;
+
+	for (idx = 0; idx < total_idx; idx++, cal += MT_EE_CAL_UNIT) {
+		ret = mt7996_mcu_set_pre_cal(dev, idx, cal, MT_EE_CAL_UNIT, RF_PRE_CAL);
+		if (ret)
+			goto out;
+	}
+
+	ret = mt7996_mcu_set_pre_cal(dev, total_idx, cal,
+				     MT_EE_CAL_GROUP_SIZE % MT_EE_CAL_UNIT, RF_PRE_CAL);
+
+out:
+	return ret;
+}
+
+int mt7996_mcu_apply_tx_dpd(struct mt7996_phy *phy)
+{
+	struct mt7996_dev *dev = phy->dev;
+	struct mt76_phy *mphy = phy->mt76;
+	struct cfg80211_chan_def *chandef = &phy->mt76->chandef;
+	enum nl80211_band band = chandef->chan->band;
+	enum nl80211_chan_width bw = chandef->width;
+	const struct ieee80211_channel *chan_list;
+	u32 cal_id, chan_list_size, base_offset = 0, offs = MT_EE_DO_PRE_CAL;
+	u32 per_chan_size = DPD_PER_CH_BW20_SIZE;
+	u16 channel = ieee80211_frequency_to_channel(chandef->center_freq1);
+	u8 dpd_mask, *cal = dev->cal.data, *eeprom = dev->mt76.eeprom.data;
+	int idx, i, ret;
+	bool has_skip_ch = (band == NL80211_BAND_5GHZ);
+
+	switch (band) {
+	case NL80211_BAND_2GHZ:
+		dpd_mask = MT_EE_WIFI_CAL_DPD_2G;
+		/* channel 14 don't need DPD cal */
+		if (channel >= 1 && channel <= 4)
+			channel = 3;
+		else if (channel >= 5 && channel <= 9)
+			channel = 7;
+		else if (channel >= 10 && channel <= 13)
+			channel = 11;
+		else
+			return 0;
+		cal_id = RF_DPD_FLAT_CAL;
+		chan_list = dpd_2g_ch_list_bw20;
+		chan_list_size = DPD_CH_NUM(BW20_2G);
+		break;
+	case NL80211_BAND_5GHZ:
+		dpd_mask = MT_EE_WIFI_CAL_DPD_5G;
+		cal_id = RF_DPD_FLAT_5G_CAL;
+		chan_list = mphy->sband_5g.sband.channels;
+		chan_list_size = mphy->sband_5g.sband.n_channels;
+		base_offset += MT_EE_CAL_DPD_SIZE_2G;
+		if (bw == NL80211_CHAN_WIDTH_160) {
+			base_offset += DPD_CH_NUM(BW20_5G) * DPD_PER_CH_BW20_SIZE +
+				       DPD_CH_NUM(BW80_5G) * DPD_PER_CH_GT_BW20_SIZE;
+			per_chan_size = DPD_PER_CH_GT_BW20_SIZE;
+			cal_id = RF_DPD_FLAT_5G_MEM_CAL;
+			chan_list = dpd_5g_ch_list_bw160;
+			chan_list_size = DPD_CH_NUM(BW160_5G);
+			has_skip_ch = false;
+		} else if (is_mt7992(&dev->mt76) && bw == NL80211_CHAN_WIDTH_80) {
+			base_offset += DPD_CH_NUM(BW20_5G) * DPD_PER_CH_BW20_SIZE;
+			per_chan_size = DPD_PER_CH_GT_BW20_SIZE;
+			cal_id = RF_DPD_FLAT_5G_MEM_CAL;
+			chan_list = dpd_5g_ch_list_bw80;
+			chan_list_size = DPD_CH_NUM(BW80_5G);
+			has_skip_ch = false;
+		} else if (bw > NL80211_CHAN_WIDTH_20) {
+			/* apply (center channel - 2)'s dpd cal data for bw 40/80 channels */
+			channel -= 2;
+		}
+		if (channel >= dpd_5g_skip_ch_list[0].hw_value &&
+		    channel <= dpd_5g_skip_ch_list[DPD_CH_NUM(BW20_5G_SKIP) - 1].hw_value)
+			return 0;
+		break;
+	case NL80211_BAND_6GHZ:
+		dpd_mask = MT_EE_WIFI_CAL_DPD_6G;
+		cal_id = RF_DPD_FLAT_6G_CAL;
+		chan_list = mphy->sband_6g.sband.channels;
+		chan_list_size = mphy->sband_6g.sband.n_channels;
+		base_offset += MT_EE_CAL_DPD_SIZE_2G + MT_EE_CAL_DPD_SIZE_5G;
+		if (bw == NL80211_CHAN_WIDTH_160) {
+			base_offset += mphy->sband_6g.sband.n_channels * DPD_PER_CH_BW20_SIZE;
+			per_chan_size = DPD_PER_CH_GT_BW20_SIZE;
+			cal_id = RF_DPD_FLAT_6G_MEM_CAL;
+			chan_list = dpd_6g_ch_list_bw160;
+			chan_list_size = DPD_CH_NUM(BW160_6G);
+		} else if (is_mt7996(&dev->mt76) && bw == NL80211_CHAN_WIDTH_320) {
+			base_offset += mphy->sband_6g.sband.n_channels * DPD_PER_CH_BW20_SIZE +
+				       DPD_CH_NUM(BW80_6G) * DPD_PER_CH_GT_BW20_SIZE +
+				       DPD_CH_NUM(BW160_6G) * DPD_PER_CH_GT_BW20_SIZE;
+			per_chan_size = DPD_PER_CH_GT_BW20_SIZE;
+			cal_id = RF_DPD_FLAT_6G_MEM_CAL;
+			chan_list = dpd_6g_ch_list_bw320;
+			chan_list_size = DPD_CH_NUM(BW320_6G);
+		} else if (is_mt7992(&dev->mt76) && bw == NL80211_CHAN_WIDTH_80) {
+			base_offset += mphy->sband_6g.sband.n_channels * DPD_PER_CH_BW20_SIZE;
+			per_chan_size = DPD_PER_CH_GT_BW20_SIZE;
+			cal_id = RF_DPD_FLAT_6G_MEM_CAL;
+			chan_list = dpd_6g_ch_list_bw80;
+			chan_list_size = DPD_CH_NUM(BW80_6G);
+		} else if (bw > NL80211_CHAN_WIDTH_20) {
+			/* apply (center channel - 2)'s dpd cal data for bw 40/80 channels */
+			channel -= 2;
+		}
+		break;
+	default:
+		dpd_mask = 0;
+		break;
+	}
+
+	if (!(eeprom[offs] & dpd_mask))
+		return 0;
+
+	for (idx = 0; idx < chan_list_size; idx++)
+		if (channel == chan_list[idx].hw_value)
+			break;
+	if (idx == chan_list_size)
+		return -EINVAL;
+
+	if (has_skip_ch && channel > dpd_5g_skip_ch_list[DPD_CH_NUM(BW20_5G_SKIP) - 1].hw_value)
+		idx -= DPD_CH_NUM(BW20_5G_SKIP);
+
+	cal += MT_EE_CAL_GROUP_SIZE + base_offset + idx * per_chan_size;
+
+	for (i = 0; i < per_chan_size / MT_EE_CAL_UNIT; i++) {
+		ret = mt7996_mcu_set_pre_cal(dev, i, cal, MT_EE_CAL_UNIT, cal_id);
+		if (ret)
+			return ret;
+
+		cal += MT_EE_CAL_UNIT;
+	}
+
+	return ret;
+}
+
 int mt7996_mcu_get_chip_config(struct mt7996_dev *dev, u32 *cap)
 {
 #define UNI_EVENT_CHIP_CONFIG_EFUSE_VERSION	0x21
@@ -5745,4 +6148,37 @@ int mt7996_mcu_set_pp_sta_dscb(struct mt7996_phy *phy,
 
 	return mt76_mcu_send_msg(&dev->mt76, MCU_WM_UNI_CMD(PP),
 				 &req, sizeof(req), false);
+
+int mt7996_mcu_set_tx_power_ctrl(struct mt7996_phy *phy, u8 power_ctrl_id, u8 data)
+{
+	struct mt7996_dev *dev = phy->dev;
+	struct tx_power_ctrl req = {
+		.tag = cpu_to_le16(power_ctrl_id),
+		.len = cpu_to_le16(sizeof(req) - 4),
+		.power_ctrl_id = power_ctrl_id,
+		.band_idx = phy->mt76->band_idx,
+	};
+
+	switch (power_ctrl_id) {
+	case UNI_TXPOWER_SKU_POWER_LIMIT_CTRL:
+		req.sku_enable = !!data;
+		break;
+	case UNI_TXPOWER_PERCENTAGE_CTRL:
+		req.percentage_ctrl_enable = !!data;
+		break;
+	case UNI_TXPOWER_PERCENTAGE_DROP_CTRL:
+		req.power_drop_level = data;
+		break;
+	case UNI_TXPOWER_BACKOFF_POWER_LIMIT_CTRL:
+		req.bf_backoff_enable = !!data;
+		break;
+	case UNI_TXPOWER_ATE_MODE_CTRL:
+		req.ate_mode_enable = !!data;
+		break;
+	default:
+		req.sku_enable = !!data;
+	}
+
+	return mt76_mcu_send_msg(&dev->mt76, MCU_WM_UNI_CMD(TXPOWER),
+				 &req, sizeof(req), false);
 }
diff --git a/mt7996/mcu.h b/mt7996/mcu.h
index 2be0e4fbf..b3dccaf02 100644
--- a/mt7996/mcu.h
+++ b/mt7996/mcu.h
@@ -145,7 +145,7 @@ struct mt7996_mcu_background_chain_ctrl {
 	u8 rsv[2];
 } __packed;
 
-struct mt7996_mcu_eeprom {
+struct mt7996_mcu_eeprom_update {
 	u8 _rsv[4];
 
 	__le16 tag;
@@ -155,6 +155,43 @@ struct mt7996_mcu_eeprom {
 	__le16 buf_len;
 } __packed;
 
+union eeprom_data {
+	struct {
+		__le32 data_len;
+		DECLARE_FLEX_ARRAY(u8, data);
+	} ext_eeprom;
+	DECLARE_FLEX_ARRAY(u8, efuse);
+} __packed;
+
+struct mt7996_mcu_eeprom_info {
+	u8 _rsv[4];
+
+	__le16 tag;
+	__le16 len;
+	__le32 addr;
+	__le32 valid;
+} __packed;
+
+struct mt7996_mcu_eeprom_access {
+	struct mt7996_mcu_eeprom_info info;
+	union eeprom_data eeprom;
+} __packed;
+
+struct mt7996_mcu_eeprom_access_event {
+	u8 _rsv[4];
+
+	__le16 tag;
+	__le16 len;
+	__le32 version;
+	__le32 addr;
+	__le32 valid;
+	__le32 size;
+	__le32 magic_no;
+	__le32 type;
+	__le32 rsv[4];
+	union eeprom_data eeprom;
+} __packed;
+
 struct mt7996_mcu_phy_rx_info {
 	u8 category;
 	u8 rate;
@@ -780,6 +817,22 @@ struct bf_sounding_on {
 	__le32 snd_period;
 } __packed;
 
+enum sounding_mode {
+	SU_SOUNDING,
+	MU_SOUNDING,
+	SU_PERIODIC_SOUNDING,
+	MU_PERIODIC_SOUNDING,
+	BF_PROCESSING,
+	TXCMD_NONTB_SU_SOUNDING,
+	TXCMD_VHT_MU_SOUNDING,
+	TXCMD_TB_PER_BRP_SOUNDING,
+	TXCMD_TB_SOUNDING,
+
+	/* keep last */
+	NUM_SOUNDING_MODE,
+	SOUNDING_MODE_MAX = NUM_SOUNDING_MODE - 1,
+};
+
 struct bf_hw_en_status_update {
 	__le16 tag;
 	__le16 len;
@@ -805,6 +858,25 @@ union bf_tag_tlv {
 	struct bf_mod_en_ctrl bf_mod_en;
 };
 
+enum {
+	BF_SOUNDING_OFF = 0,
+	BF_SOUNDING_ON = 1,
+	BF_DATA_PACKET_APPLY = 2,
+	BF_PFMU_TAG_READ = 5,
+	BF_PFMU_TAG_WRITE = 6,
+	BF_STA_REC_READ = 11,
+	BF_PHASE_CALIBRATION = 12,
+	BF_IBF_PHASE_COMP = 13,
+	BF_PROFILE_WRITE_20M_ALL = 15,
+	BF_HW_EN_UPDATE = 17,
+	BF_MOD_EN_CTRL = 20,
+	BF_FBRPT_DBG_INFO_READ = 23,
+	BF_TXSND_INFO = 24,
+	BF_CMD_TXCMD = 27,
+	BF_CFG_PHY = 28,
+	BF_PROFILE_WRITE_20M_ALL_5X5 = 30,
+};
+
 struct ra_rate {
 	__le16 wlan_idx;
 	u8 mode;
@@ -852,12 +924,6 @@ enum {
 	RATE_PARAM_AUTO = 20,
 };
 
-enum {
-	BF_SOUNDING_ON = 1,
-	BF_HW_EN_UPDATE = 17,
-	BF_MOD_EN_CTRL = 20,
-};
-
 enum {
 	CMD_BAND_NONE,
 	CMD_BAND_24G,
@@ -947,6 +1013,10 @@ enum {
 	UNI_EFUSE_BUFFER_RD,
 };
 
+enum {
+	UNI_EXT_EEPROM_ACCESS = 1,
+};
+
 enum {
 	UNI_VOW_DRR_CTRL,
 	UNI_VOW_RX_AT_AIRTIME_EN = 0x0b,
@@ -994,8 +1064,33 @@ enum {
 	UNI_CMD_THERMAL_PROTECT_INFO,
 };
 
+struct tx_power_ctrl {
+	u8 _rsv[4];
+
+	__le16 tag;
+	__le16 len;
+
+	u8 power_ctrl_id;
+	union {
+		bool sku_enable;
+		bool ate_mode_enable;
+		bool percentage_ctrl_enable;
+		bool bf_backoff_enable;
+		u8 show_info_category;
+		u8 power_drop_level;
+	};
+	u8 band_idx;
+	u8 rsv[1];
+} __packed;
+
 enum {
+	UNI_TXPOWER_SKU_POWER_LIMIT_CTRL = 0,
+	UNI_TXPOWER_PERCENTAGE_CTRL = 1,
+	UNI_TXPOWER_PERCENTAGE_DROP_CTRL = 2,
+	UNI_TXPOWER_BACKOFF_POWER_LIMIT_CTRL = 3,
 	UNI_TXPOWER_POWER_LIMIT_TABLE_CTRL = 4,
+	UNI_TXPOWER_ATE_MODE_CTRL = 6,
+	UNI_TXPOWER_SHOW_INFO = 7,
 };
 
 enum {
diff --git a/mt7996/mt7996.h b/mt7996/mt7996.h
index b15ef2e27..a21ec6c9b 100644
--- a/mt7996/mt7996.h
+++ b/mt7996/mt7996.h
@@ -81,6 +81,7 @@
 
 #define MT7996_EEPROM_SIZE		7680
 #define MT7996_EEPROM_BLOCK_SIZE	16
+#define MT7996_EXT_EEPROM_BLOCK_SIZE	1024
 #define MT7996_TOKEN_SIZE		16384
 #define MT7996_WED_TOKEN_SIZE		16384
 #define MT7996_PER_BAND_TOKEN_SIZE	4000
@@ -154,11 +155,13 @@ enum mt7996_ram_type {
 enum mt7996_var_type {
 	MT7996_VAR_TYPE_444,
 	MT7996_VAR_TYPE_233,
+	MT7996_VAR_TYPE_404,
 };
 
 enum mt7992_var_type {
 	MT7992_VAR_TYPE_44,
 	MT7992_VAR_TYPE_23,
+	MT7992_VAR_TYPE_24,
 };
 
 enum mt7990_var_type {
@@ -171,6 +174,38 @@ enum mt7996_fem_type {
 	MT7996_FEM_MIX,
 };
 
+enum mt7996_eeprom_mode {
+	DEFAULT_BIN_MODE,
+	EFUSE_MODE,
+	FLASH_MODE,
+	BIN_FILE_MODE,
+	EXT_EEPROM_MODE,
+};
+
+enum mt7996_ddie_type {
+	DDIE_7996,
+	DDIE_7992,
+	DDIE_7990,
+	DDIE_TYPE_NUM,
+};
+
+enum mt7996_adie_type {
+	ADIE_7975,
+	ADIE_7976,
+	ADIE_7977,
+	ADIE_7978,
+	ADIE_7979,
+	ADIE_TYPE_NUM,
+};
+
+enum mt7996_efuse_base_offs {
+	EFUSE_BASE_OFFS_DDIE = 0x0,
+	EFUSE_BASE_OFFS_ADIE0 = 0x400,
+	EFUSE_BASE_OFFS_ADIE2 = 0x1200,
+	EFUSE_BASE_OFFS_ADIE1_7992 = 0x1200,
+	EFUSE_BASE_OFFS_ADIE1 = 0x1e00,
+};
+
 enum mt7996_coredump_state {
 	MT7996_COREDUMP_IDLE = 0,
 	MT7996_COREDUMP_MANUAL_WA,
@@ -232,6 +267,19 @@ struct mt7996_twt_flow {
 
 DECLARE_EWMA(avg_signal, 10, 8)
 
+enum mt7996_dpd_ch_num {
+	DPD_CH_NUM_BW20_2G,
+	DPD_CH_NUM_BW20_5G,
+	DPD_CH_NUM_BW20_5G_SKIP,
+	DPD_CH_NUM_BW80_5G,
+	DPD_CH_NUM_BW160_5G,
+	DPD_CH_NUM_BW20_6G,
+	DPD_CH_NUM_BW80_6G,
+	DPD_CH_NUM_BW160_6G,
+	DPD_CH_NUM_BW320_6G,
+	DPD_CH_NUM_TYPE_MAX,
+};
+
 struct mt7996_sta_link {
 	struct mt76_wcid wcid; /* must be first */
 
@@ -402,6 +450,7 @@ struct mt7996_phy {
 
 	struct mt76_mib_stats mib;
 	struct mt76_channel_state state_ts;
+	struct delayed_work ipi_work;
 
 	u16 orig_chainmask;
 	u16 orig_antenna_mask;
@@ -508,6 +557,10 @@ struct mt7996_dev {
 		struct list_head page_map[MT7996_RRO_MSDU_PG_HASH_SIZE];
 	} wed_rro;
 
+	bool testmode_enable;
+	bool bin_file_mode;
+	u8 eeprom_mode;
+
 	bool ibf;
 	u8 fw_debug_wm;
 	u8 fw_debug_wa;
@@ -517,6 +570,13 @@ struct mt7996_dev {
 	struct dentry *debugfs_dir;
 	struct rchan *relay_fwlog;
 
+	struct debugfs_blob_wrapper cal;
+	u32 cur_prek_offset;
+	struct {
+		const u32 *rev;
+		u8 dpd_ch_num[DPD_CH_NUM_TYPE_MAX];
+	} prek;
+
 	struct {
 		u16 table_mask;
 		u8 n_agrt;
@@ -529,6 +589,14 @@ struct mt7996_dev {
 		u8 type:4;
 		u8 fem:4;
 	} var;
+
+#if defined CONFIG_NL80211_TESTMODE || defined CONFIG_MTK_DEBUG
+	struct {
+		void *txbf_phase_cal;
+		void *txbf_pfmu_data;
+		void *txbf_pfmu_tag;
+	} test;
+#endif
 };
 
 enum {
@@ -615,6 +683,19 @@ mt7996_band_valid(struct mt7996_dev *dev, u8 band)
 	return band <= MT_BAND2;
 }
 
+static inline bool
+mt7996_has_ext_eeprom(struct mt7996_dev *dev)
+{
+	switch (mt76_chip(&dev->mt76)) {
+	case MT7996_DEVICE_ID:
+		return false;
+	case MT7992_DEVICE_ID:
+	case MT7990_DEVICE_ID:
+	default:
+		return true;
+	}
+}
+
 static inline struct mt7996_phy *
 mt7996_band_phy(struct mt7996_dev *dev, enum nl80211_band band)
 {
@@ -659,6 +740,7 @@ mt7996_vif_conf_link(struct mt7996_dev *dev, struct ieee80211_vif *vif,
 extern const struct ieee80211_ops mt7996_ops;
 extern struct pci_driver mt7996_pci_driver;
 extern struct pci_driver mt7996_hif_driver;
+extern const struct mt76_testmode_ops mt7996_testmode_ops;
 
 struct mt7996_dev *mt7996_mmio_probe(struct device *pdev,
 				     void __iomem *mem_base, u32 device_id);
@@ -674,7 +756,9 @@ int mt7996_vif_link_add(struct mt76_phy *mphy, struct ieee80211_vif *vif,
 void mt7996_vif_link_remove(struct mt76_phy *mphy, struct ieee80211_vif *vif,
 			    struct ieee80211_bss_conf *link_conf,
 			    struct mt76_vif_link *mlink);
+const char *mt7996_eeprom_name(struct mt7996_dev *dev);
 int mt7996_eeprom_init(struct mt7996_dev *dev);
+int mt7996_eeprom_check_fw_mode(struct mt7996_dev *dev);
 int mt7996_eeprom_parse_hw_cap(struct mt7996_dev *dev, struct mt7996_phy *phy);
 int mt7996_eeprom_get_target_power(struct mt7996_dev *dev,
 				   struct ieee80211_channel *chan);
@@ -746,8 +830,11 @@ int mt7996_mcu_set_fixed_rate_ctrl(struct mt7996_dev *dev,
 int mt7996_mcu_set_fixed_field(struct mt7996_dev *dev, struct mt7996_sta *msta,
 			       void *data, u8 link_id, u32 field);
 int mt7996_mcu_set_eeprom(struct mt7996_dev *dev);
-int mt7996_mcu_get_eeprom(struct mt7996_dev *dev, u32 offset, u8 *buf, u32 buf_len);
-int mt7996_mcu_get_eeprom_free_block(struct mt7996_dev *dev, u8 *block_num);
+int mt7996_mcu_get_eeprom(struct mt7996_dev *dev, u32 offset, u8 *buf, u32 buf_len,
+			  enum mt7996_eeprom_mode mode);
+int mt7996_mcu_get_efuse_free_block(struct mt7996_dev *dev, u8 *block_num);
+int mt7996_mcu_write_ext_eeprom(struct mt7996_dev *dev, u32 offset,
+				u32 data_len, u8 *write_buf);
 int mt7996_mcu_get_chip_config(struct mt7996_dev *dev, u32 *cap);
 int mt7996_mcu_set_ser(struct mt7996_dev *dev, u8 action, u8 set, u8 band);
 int mt7996_mcu_set_txbf(struct mt7996_dev *dev, u8 action);
@@ -788,6 +875,12 @@ int mt7996_mcu_get_all_sta_info(struct mt76_dev *dev, u16 tag);
 int mt7996_mcu_wed_rro_reset_sessions(struct mt7996_dev *dev, u16 id);
 int mt7996_mcu_set_sniffer_mode(struct mt7996_phy *phy, bool enabled);
 int mt7996_mcu_set_dup_wtbl(struct mt7996_dev *dev);
+int mt7996_mcu_set_tx_power_ctrl(struct mt7996_phy *phy, u8 power_ctrl_id, u8 data);
+int mt7996_mcu_apply_group_cal(struct mt7996_dev *dev);
+int mt7996_mcu_apply_tx_dpd(struct mt7996_phy *phy);
+#ifdef CONFIG_NL80211_TESTMODE
+void mt7996_tm_rf_test_event(struct mt7996_dev *dev, struct sk_buff *skb);
+#endif
 
 static inline bool mt7996_has_hwrro(struct mt7996_dev *dev)
 {
@@ -949,4 +1042,8 @@ static inline int mt7996_npu_rx_queues_init(struct mt7996_dev *dev)
 }
 #endif /* CONFIG_MT7996_NPU */
 
+int mt7996_mcu_set_txbf_internal(struct mt7996_phy *phy, u8 action, int idx, bool bfer);
+void mt7996_mcu_rx_bf_event(struct mt7996_dev *dev, struct sk_buff *skb);
+void mt7996_tm_update_channel(struct mt7996_phy *phy);
+
 #endif
diff --git a/mt7996/mtk_mcu.c b/mt7996/mtk_mcu.c
new file mode 100644
index 000000000..d0725e3ad
--- /dev/null
+++ b/mt7996/mtk_mcu.c
@@ -0,0 +1,609 @@
+// SPDX-License-Identifier: ISC
+/*
+ * Copyright (C) 2023 MediaTek Inc.
+ */
+
+#include <linux/firmware.h>
+#include <linux/fs.h>
+#include "mt7996.h"
+#include "mcu.h"
+#include "mac.h"
+#include "mtk_mcu.h"
+
+#ifdef CONFIG_MTK_DEBUG
+
+static struct tlv *
+__mt7996_mcu_add_uni_tlv(struct sk_buff *skb, u16 tag, u16 len)
+{
+	struct tlv *ptlv, tlv = {
+		.tag = cpu_to_le16(tag),
+		.len = cpu_to_le16(len),
+	};
+
+	ptlv = skb_put(skb, len);
+	memcpy(ptlv, &tlv, sizeof(tlv));
+
+	return ptlv;
+}
+
+int mt7996_mcu_set_txbf_internal(struct mt7996_phy *phy, u8 action, int idx, bool bfer)
+{
+	struct mt7996_dev *dev = phy->dev;
+#define MT7996_MTK_BF_MAX_SIZE	sizeof(struct bf_starec_read)
+	struct uni_header hdr;
+	struct sk_buff *skb;
+	struct tlv *tlv;
+	int len = sizeof(hdr) + MT7996_MTK_BF_MAX_SIZE;
+
+	memset(&hdr, 0, sizeof(hdr));
+
+	skb = mt76_mcu_msg_alloc(&dev->mt76, NULL, len);
+	if (!skb)
+		return -ENOMEM;
+
+	skb_put_data(skb, &hdr, sizeof(hdr));
+
+	switch (action) {
+	case BF_PFMU_TAG_READ: {
+		struct bf_pfmu_tag *req;
+
+		tlv = __mt7996_mcu_add_uni_tlv(skb, action, sizeof(*req));
+		req = (struct bf_pfmu_tag *)tlv;
+		req->pfmu_id = idx;
+		req->bfer = bfer;
+		req->band_idx = phy->mt76->band_idx;
+		break;
+	}
+	case BF_STA_REC_READ: {
+		struct bf_starec_read *req;
+
+		tlv = __mt7996_mcu_add_uni_tlv(skb, action, sizeof(*req));
+		req = (struct bf_starec_read *)tlv;
+		req->wlan_idx = idx;
+		break;
+	}
+	case BF_FBRPT_DBG_INFO_READ: {
+		struct bf_fbk_rpt_info *req;
+
+		if (idx != 0) {
+			dev_info(dev->mt76.dev, "Invalid input");
+			return 0;
+		}
+
+		tlv = __mt7996_mcu_add_uni_tlv(skb, action, sizeof(*req));
+		req = (struct bf_fbk_rpt_info *)tlv;
+		req->action = idx;
+		req->band_idx = phy->mt76->band_idx;
+		break;
+	}
+	default:
+		return -EINVAL;
+	}
+
+	return mt76_mcu_skb_send_msg(&phy->dev->mt76, skb, MCU_WM_UNI_CMD(BF), false);
+}
+
+int mt7996_mcu_set_txbf_snd_info(struct mt7996_dev *dev, void *para)
+{
+	char *buf = (char *)para;
+	__le16 input[5] = {0};
+	u8 recv_arg = 0;
+	struct bf_txsnd_info *req;
+	struct uni_header hdr;
+	struct sk_buff *skb;
+	struct tlv *tlv;
+	int len = sizeof(hdr) + MT7996_MTK_BF_MAX_SIZE;
+
+	memset(&hdr, 0, sizeof(hdr));
+
+	skb = mt76_mcu_msg_alloc(&dev->mt76, NULL, len);
+	if (!skb)
+		return -ENOMEM;
+
+	skb_put_data(skb, &hdr, sizeof(hdr));
+
+	recv_arg = sscanf(buf, "%hx:%hx:%hx:%hx:%hx", &input[0], &input[1], &input[2],
+						      &input[3], &input[4]);
+
+	if (!recv_arg)
+		return -EINVAL;
+
+	tlv = __mt7996_mcu_add_uni_tlv(skb, BF_TXSND_INFO, sizeof(*req));
+	req = (struct bf_txsnd_info *)tlv;
+	req->action = input[0];
+
+	switch (req->action) {
+	case BF_SND_READ_INFO: {
+		req->read_clr = input[1];
+		break;
+	}
+	case BF_SND_CFG_OPT: {
+		req->vht_opt = input[1];
+		req->he_opt = input[2];
+		req->glo_opt = input[3];
+		break;
+	}
+	case BF_SND_CFG_INTV: {
+		req->wlan_idx = input[1];
+		req->snd_intv = input[2];
+		break;
+	}
+	case BF_SND_STA_STOP: {
+		req->wlan_idx = input[1];
+		req->snd_stop = input[2];
+		break;
+	}
+	case BF_SND_CFG_MAX_STA: {
+		req->max_snd_stas = input[1];
+		break;
+	}
+	case BF_SND_CFG_BFRP: {
+		req->man = input[1];
+		req->tx_time = input[2];
+		req->mcs = input[3];
+		req->ldpc = input[4];
+		break;
+	}
+	case BF_SND_CFG_INF: {
+		req->inf = input[1];
+		break;
+	}
+	case BF_SND_CFG_TXOP_SND: {
+		req->man = input[1];
+		req->ac_queue = input[2];
+		req->sxn_protect = input[3];
+		req->direct_fbk = input[4];
+		break;
+	}
+	default:
+		return -EINVAL;
+	}
+
+	return mt76_mcu_skb_send_msg(&dev->mt76, skb, MCU_WM_UNI_CMD(BF), false);
+}
+
+static inline void
+mt7996_ibf_phase_assign(struct mt7996_dev *dev,
+			struct mt7996_ibf_cal_info *cal,
+			struct mt7996_txbf_phase *phase)
+{
+	/* fw return ibf calibrated data with
+	 * the mt7996_txbf_phase_info_5g struct for both 2G and 5G.
+	 * (return struct mt7992_txbf_phase_info_5g for ibf 2.0)
+	 * Therefore, memcpy cannot be used here.
+	 */
+	if (get_ibf_version(dev) != IBF_VER_2) {
+		phase_assign(cal->group, v1, m_t0_h, true);
+		phase_assign(cal->group, v1, m_t1_h, true);
+		phase_assign(cal->group, v1, m_t2_h, true);
+		phase_assign(cal->group, v1, m_t2_h_sx2, false);
+		phase_assign_rx_v1(cal->group, v1, r0);
+		phase_assign_rx_v1(cal->group, v1, r1);
+		phase_assign_rx_v1(cal->group, v1, r2);
+		phase_assign_rx_v1(cal->group, v1, r3);
+		phase_assign_rx(cal->group, v1, r2_sx2, false);
+		phase_assign_rx(cal->group, v1, r3_sx2, false);
+		phase_assign(cal->group, v1, r0_reserved, false);
+		phase_assign(cal->group, v1, r1_reserved, false);
+		phase_assign(cal->group, v1, r2_reserved, false);
+		phase_assign(cal->group, v1, r3_reserved, false);
+		phase_assign(cal->group, v1, r2_sx2_reserved, false);
+		phase_assign(cal->group, v1, r3_sx2_reserved, false);
+	} else {
+		phase_assign(cal->group, v2, m_t0_h, true);
+		phase_assign(cal->group, v2, m_t1_h, true);
+		phase_assign(cal->group, v2, m_t2_h, true);
+		if (cal->group) {
+			phase->v2.phase_5g.m_t3_h = cal->v2.phase_5g.m_t3_h;
+			mt76_dbg(&dev->mt76, MT76_DBG_TEST,
+				 "m_t3_h = %d\n", phase->v2.phase_5g.m_t3_h);
+		}
+		phase_assign_rx_ext(cal->group, v2, r0, true);
+		phase_assign_rx_ext(cal->group, v2, r1, true);
+		phase_assign_rx_ext(cal->group, v2, r2, true);
+		phase_assign_rx_ext(cal->group, v2, r3, true);
+		if (cal->group) {
+			memcpy(&phase->v2.phase_5g.r4, &cal->v2.phase_5g.r4,
+			       sizeof(struct txbf_rx_phase_ext));
+			mt76_dbg(&dev->mt76, MT76_DBG_TEST,
+				 "r4.rx_uh = %d\n", phase->v2.phase_5g.r4.rx_uh);
+			mt76_dbg(&dev->mt76, MT76_DBG_TEST,
+				 "r4.rx_h = %d\n", phase->v2.phase_5g.r4.rx_h);
+			mt76_dbg(&dev->mt76, MT76_DBG_TEST,
+				 "r4.rx_mh = %d\n", phase->v2.phase_5g.r4.rx_mh);
+			mt76_dbg(&dev->mt76, MT76_DBG_TEST,
+				 "r4.rx_m = %d\n", phase->v2.phase_5g.r4.rx_m);
+			mt76_dbg(&dev->mt76, MT76_DBG_TEST,
+				 "r4.rx_l = %d\n", phase->v2.phase_5g.r4.rx_l);
+			mt76_dbg(&dev->mt76, MT76_DBG_TEST,
+				 "r4.rx_ul = %d\n", phase->v2.phase_5g.r4.rx_ul);
+		}
+	}
+}
+
+void
+mt7996_mcu_rx_bf_event(struct mt7996_dev *dev, struct sk_buff *skb)
+{
+	struct mt7996_mcu_bf_basic_event *event;
+
+	event = (struct mt7996_mcu_bf_basic_event *)skb->data;
+
+	dev_info(dev->mt76.dev, " bf_event tag = %d\n", event->tag);
+
+	switch (event->tag) {
+	case UNI_EVENT_BF_PFMU_TAG: {
+
+		struct mt7996_pfmu_tag_event *tag;
+		u32 *raw_t1, *raw_t2;
+
+		tag = (struct mt7996_pfmu_tag_event *) skb->data;
+
+		raw_t1 = (u32 *)&tag->t1;
+		raw_t2 = (u32 *)&tag->t2;
+
+		dev_info(dev->mt76.dev, "=================== TXBf Profile Tag1 Info ==================\n");
+		dev_info(dev->mt76.dev,
+			 "DW0 = 0x%08x, DW1 = 0x%08x, DW2 = 0x%08x\n",
+			 raw_t1[0], raw_t1[1], raw_t1[2]);
+		dev_info(dev->mt76.dev,
+			 "DW4 = 0x%08x, DW5 = 0x%08x, DW6 = 0x%08x\n\n",
+			 raw_t1[3], raw_t1[4], raw_t1[5]);
+		dev_info(dev->mt76.dev, "PFMU ID = %d              Invalid status = %d\n",
+			 tag->t1.pfmu_idx, tag->t1.invalid_prof);
+		dev_info(dev->mt76.dev, "iBf/eBf = %d\n\n", tag->t1.ebf);
+		dev_info(dev->mt76.dev, "DBW   = %d\n", tag->t1.data_bw);
+		dev_info(dev->mt76.dev, "SU/MU = %d\n", tag->t1.is_mu);
+		dev_info(dev->mt76.dev,
+			 "nrow = %d, ncol = %d, ng = %d, LM = %d, CodeBook = %d MobCalEn = %d\n",
+			 tag->t1.nr, tag->t1.nc, tag->t1.ngroup, tag->t1.lm, tag->t1.codebook,
+			 tag->t1.mob_cal_en);
+
+		if (tag->t1.lm <= BF_LM_HE)
+			dev_info(dev->mt76.dev, "RU start = %d, RU end = %d\n",
+				 tag->t1.field.ru_start_id, tag->t1.field.ru_end_id);
+		else
+			dev_info(dev->mt76.dev, "PartialBW = %d\n",
+				 tag->t1.bw_info.partial_bw_info);
+
+		dev_info(dev->mt76.dev, "Mem Col1 = %d, Mem Row1 = %d, Mem Col2 = %d, Mem Row2 = %d\n",
+			 tag->t1.col_id1, tag->t1.row_id1, tag->t1.col_id2, tag->t1.row_id2);
+		dev_info(dev->mt76.dev, "Mem Col3 = %d, Mem Row3 = %d, Mem Col4 = %d, Mem Row4 = %d\n\n",
+			 tag->t1.col_id3, tag->t1.row_id3, tag->t1.col_id4, tag->t1.row_id4);
+		dev_info(dev->mt76.dev,
+			 "STS0_SNR = 0x%02x, STS1_SNR = 0x%02x, STS2_SNR = 0x%02x, STS3_SNR = 0x%02x\n",
+			 tag->t1.snr_sts0, tag->t1.snr_sts1, tag->t1.snr_sts2, tag->t1.snr_sts3);
+		dev_info(dev->mt76.dev,
+			 "STS4_SNR = 0x%02x, STS5_SNR = 0x%02x, STS6_SNR = 0x%02x, STS7_SNR = 0x%02x\n",
+			 tag->t1.snr_sts4, tag->t1.snr_sts5, tag->t1.snr_sts6, tag->t1.snr_sts7);
+		dev_info(dev->mt76.dev, "=============================================================\n");
+
+		dev_info(dev->mt76.dev, "=================== TXBf Profile Tag2 Info ==================\n");
+		dev_info(dev->mt76.dev,
+			 "DW0 = 0x%08x, DW1 = 0x%08x, DW2 = 0x%08x\n",
+			 raw_t2[0], raw_t2[1], raw_t2[2]);
+		dev_info(dev->mt76.dev,
+			 "DW3 = 0x%08x, DW4 = 0x%08x, DW5 = 0x%08x\n\n",
+			 raw_t2[3], raw_t2[4], raw_t2[5]);
+		dev_info(dev->mt76.dev, "Smart antenna ID = 0x%x,  SE index = %d\n",
+			 tag->t2.smart_ant, tag->t2.se_idx);
+		dev_info(dev->mt76.dev, "Timeout = 0x%x\n", tag->t2.ibf_timeout);
+		dev_info(dev->mt76.dev, "Desired BW = %d, Desired Ncol = %d, Desired Nrow = %d\n",
+			 tag->t2.ibf_data_bw, tag->t2.ibf_nc, tag->t2.ibf_nr);
+		dev_info(dev->mt76.dev, "Desired RU Allocation = %d\n", tag->t2.ibf_ru);
+		dev_info(dev->mt76.dev, "Mobility DeltaT = %d, Mobility LQ = %d\n",
+			 tag->t2.mob_delta_t, tag->t2.mob_lq_result);
+		dev_info(dev->mt76.dev, "=============================================================\n");
+		break;
+	}
+	case UNI_EVENT_BF_STAREC: {
+
+		struct mt7996_mcu_bf_starec_read *r;
+
+		r = (struct mt7996_mcu_bf_starec_read *)skb->data;
+		dev_info(dev->mt76.dev, "=================== BF StaRec ===================\n"
+					"rStaRecBf.u2PfmuId      = %d\n"
+					"rStaRecBf.fgSU_MU       = %d\n"
+					"rStaRecBf.u1TxBfCap     = %d\n"
+					"rStaRecBf.ucSoundingPhy = %d\n"
+					"rStaRecBf.ucNdpaRate    = %d\n"
+					"rStaRecBf.ucNdpRate     = %d\n"
+					"rStaRecBf.ucReptPollRate= %d\n"
+					"rStaRecBf.ucTxMode      = %d\n"
+					"rStaRecBf.ucNc          = %d\n"
+					"rStaRecBf.ucNr          = %d\n"
+					"rStaRecBf.ucCBW         = %d\n"
+					"rStaRecBf.ucMemRequire20M = %d\n"
+					"rStaRecBf.ucMemRow0     = %d\n"
+					"rStaRecBf.ucMemCol0     = %d\n"
+					"rStaRecBf.ucMemRow1     = %d\n"
+					"rStaRecBf.ucMemCol1     = %d\n"
+					"rStaRecBf.ucMemRow2     = %d\n"
+					"rStaRecBf.ucMemCol2     = %d\n"
+					"rStaRecBf.ucMemRow3     = %d\n"
+					"rStaRecBf.ucMemCol3     = %d\n",
+					r->pfmu_id,
+					r->is_su_mu,
+					r->txbf_cap,
+					r->sounding_phy,
+					r->ndpa_rate,
+					r->ndp_rate,
+					r->rpt_poll_rate,
+					r->tx_mode,
+					r->nc,
+					r->nr,
+					r->bw,
+					r->mem_require_20m,
+					r->mem_row0,
+					r->mem_col0,
+					r->mem_row1,
+					r->mem_col1,
+					r->mem_row2,
+					r->mem_col2,
+					r->mem_row3,
+					r->mem_col3);
+
+		dev_info(dev->mt76.dev, "rStaRecBf.u2SmartAnt    = 0x%x\n"
+					"rStaRecBf.ucSEIdx       = %d\n"
+					"rStaRecBf.uciBfTimeOut  = 0x%x\n"
+					"rStaRecBf.uciBfDBW      = %d\n"
+					"rStaRecBf.uciBfNcol     = %d\n"
+					"rStaRecBf.uciBfNrow     = %d\n"
+					"rStaRecBf.nr_bw160      = %d\n"
+					"rStaRecBf.nc_bw160 	  = %d\n"
+					"rStaRecBf.ru_start_idx  = %d\n"
+					"rStaRecBf.ru_end_idx 	  = %d\n"
+					"rStaRecBf.trigger_su 	  = %d\n"
+					"rStaRecBf.trigger_mu 	  = %d\n"
+					"rStaRecBf.ng16_su 	  = %d\n"
+					"rStaRecBf.ng16_mu 	  = %d\n"
+					"rStaRecBf.codebook42_su = %d\n"
+					"rStaRecBf.codebook75_mu = %d\n"
+					"rStaRecBf.he_ltf 	      = %d\n"
+					"======================================\n",
+					r->smart_ant,
+					r->se_idx,
+					r->bf_timeout,
+					r->bf_dbw,
+					r->bf_ncol,
+					r->bf_nrow,
+					r->nr_lt_bw80,
+					r->nc_lt_bw80,
+					r->ru_start_idx,
+					r->ru_end_idx,
+					r->trigger_su,
+					r->trigger_mu,
+					r->ng16_su,
+					r->ng16_mu,
+					r->codebook42_su,
+					r->codebook75_mu,
+					r->he_ltf);
+		break;
+	}
+	case UNI_EVENT_BF_FBK_INFO: {
+		struct mt7996_mcu_txbf_fbk_info *info;
+		__le32 total, i;
+
+		info = (struct mt7996_mcu_txbf_fbk_info *)skb->data;
+
+		total = info->u4PFMUWRDoneCnt + info->u4PFMUWRFailCnt;
+		total += info->u4PFMUWRTimeoutFreeCnt + info->u4FbRptPktDropCnt;
+
+		dev_info(dev->mt76.dev, "\n");
+		dev_info(dev->mt76.dev, "\x1b[32m =================================\x1b[m\n");
+		dev_info(dev->mt76.dev, "\x1b[32m PFMUWRDoneCnt              = %u\x1b[m\n",
+			info->u4PFMUWRDoneCnt);
+		dev_info(dev->mt76.dev, "\x1b[32m PFMUWRFailCnt              = %u\x1b[m\n",
+			info->u4PFMUWRFailCnt);
+		dev_info(dev->mt76.dev, "\x1b[32m PFMUWRTimeOutCnt           = %u\x1b[m\n",
+			info->u4PFMUWRTimeOutCnt);
+		dev_info(dev->mt76.dev, "\x1b[32m PFMUWRTimeoutFreeCnt       = %u\x1b[m\n",
+			info->u4PFMUWRTimeoutFreeCnt);
+		dev_info(dev->mt76.dev, "\x1b[32m FbRptPktDropCnt            = %u\x1b[m\n",
+			info->u4FbRptPktDropCnt);
+		dev_info(dev->mt76.dev, "\x1b[32m TotalFbRptPkt              = %u\x1b[m\n", total);
+		dev_info(dev->mt76.dev, "\x1b[32m PollPFMUIntrStatTimeOut    = %u(micro-sec)\x1b[m\n",
+			info->u4PollPFMUIntrStatTimeOut);
+		dev_info(dev->mt76.dev, "\x1b[32m FbRptDeQInterval           = %u(milli-sec)\x1b[m\n",
+			info->u4DeQInterval);
+		dev_info(dev->mt76.dev, "\x1b[32m PktCntInFbRptTimeOutQ      = %u\x1b[m\n",
+			info->u4RptPktTimeOutListNum);
+		dev_info(dev->mt76.dev, "\x1b[32m PktCntInFbRptQ             = %u\x1b[m\n",
+			info->u4RptPktListNum);
+
+		// [ToDo] Check if it is valid entry
+		for (i = 0; ((i < 5) && (i < CFG_BF_STA_REC_NUM)); i++) {
+
+			// [ToDo] AID needs to be refined
+			dev_info(dev->mt76.dev,"\x1b[32m AID%u  RxFbRptCnt           = %u\x1b[m\n"
+				, i, info->au4RxPerStaFbRptCnt[i]);
+		}
+
+		break;
+	}
+	case UNI_EVENT_BF_TXSND_INFO: {
+		struct mt7996_mcu_tx_snd_info *info;
+		struct uni_event_bf_txsnd_sta_info *snd_sta_info;
+		int Idx;
+		int max_wtbl_size = mt7996_wtbl_size(dev);
+
+		info = (struct mt7996_mcu_tx_snd_info *)skb->data;
+		dev_info(dev->mt76.dev, "=================== Global Setting ===================\n");
+
+		dev_info(dev->mt76.dev, "VhtOpt = 0x%02X, HeOpt = 0x%02X, GloOpt = 0x%02X\n",
+			info->vht_opt, info->he_opt, info->glo_opt);
+
+		for (Idx = 0; Idx < BF_SND_CTRL_STA_DWORD_CNT; Idx++) {
+			dev_info(dev->mt76.dev, "SuSta[%d] = 0x%08X,", Idx,
+				 info->snd_rec_su_sta[Idx]);
+			if ((Idx & 0x03) == 0x03)
+				dev_info(dev->mt76.dev, "\n");
+		}
+
+		if ((Idx & 0x03) != 0x03)
+			dev_info(dev->mt76.dev, "\n");
+
+
+		for (Idx = 0; Idx < BF_SND_CTRL_STA_DWORD_CNT; Idx++) {
+			dev_info(dev->mt76.dev, "VhtMuSta[%d] = 0x%08X,", Idx, info->snd_rec_vht_mu_sta[Idx]);
+			if ((Idx & 0x03) == 0x03)
+				dev_info(dev->mt76.dev, "\n");
+		}
+
+		if ((Idx & 0x03) != 0x03)
+			dev_info(dev->mt76.dev, "\n");
+
+		for (Idx = 0; Idx < BF_SND_CTRL_STA_DWORD_CNT; Idx++) {
+			dev_info(dev->mt76.dev, "HeTBSta[%d] = 0x%08X,", Idx, info->snd_rec_he_tb_sta[Idx]);
+			if ((Idx & 0x03) == 0x03)
+				dev_info(dev->mt76.dev, "\n");
+		}
+
+		if ((Idx & 0x03) != 0x03)
+			dev_info(dev->mt76.dev, "\n");
+
+		for (Idx = 0; Idx < BF_SND_CTRL_STA_DWORD_CNT; Idx++) {
+			dev_info(dev->mt76.dev, "EhtTBSta[%d] = 0x%08X,", Idx, info->snd_rec_eht_tb_sta[Idx]);
+			if ((Idx & 0x03) == 0x03)
+				dev_info(dev->mt76.dev, "\n");
+		}
+
+		if ((Idx & 0x03) != 0x03)
+			dev_info(dev->mt76.dev, "\n");
+
+		for (Idx = 0; Idx < CFG_WIFI_RAM_BAND_NUM; Idx++) {
+			dev_info(dev->mt76.dev, "Band%u:\n", Idx);
+			dev_info(dev->mt76.dev, "	 Wlan Idx For VHT MC Sounding = %u\n", info->wlan_idx_for_mc_snd[Idx]);
+			dev_info(dev->mt76.dev, "	 Wlan Idx For HE TB Sounding = %u\n", info->wlan_idx_for_he_tb_snd[Idx]);
+			dev_info(dev->mt76.dev, "	 Wlan Idx For EHT TB Sounding = %u\n", info->wlan_idx_for_eht_tb_snd[Idx]);
+		}
+
+		dev_info(dev->mt76.dev, "ULLen = %d, ULMcs = %d, ULLDCP = %d\n",
+			info->ul_length, info->mcs, info->ldpc);
+
+		dev_info(dev->mt76.dev, "=================== STA Info ===================\n");
+
+		for (Idx = 1; (Idx < 5 && (Idx < CFG_BF_STA_REC_NUM)); Idx++) {
+			snd_sta_info = &info->snd_sta_info[Idx];
+			dev_info(dev->mt76.dev, "Idx%2u Interval = %d, interval counter = %d, TxCnt = %d, StopReason = 0x%02X\n",
+				Idx,
+				snd_sta_info->snd_intv,
+				snd_sta_info->snd_intv_cnt,
+				snd_sta_info->snd_tx_cnt,
+				snd_sta_info->snd_stop_reason);
+		}
+
+		dev_info(dev->mt76.dev, "=================== STA Info Connected ===================\n");
+		// [ToDo] How to iterate and get AID info of station
+		// Check UniEventBFCtrlTxSndHandle() on Logan
+
+		//hardcode max_wtbl_size as 5
+		max_wtbl_size = 5;
+		for (Idx = 1; ((Idx < max_wtbl_size) && (Idx < CFG_BF_STA_REC_NUM)); Idx++) {
+
+			// [ToDo] We do not show AID info here
+			snd_sta_info = &info->snd_sta_info[Idx];
+			dev_info(dev->mt76.dev, " Interval = %d (%u ms), interval counter = %d (%u ms), TxCnt = %d, StopReason = 0x%02X\n",
+				snd_sta_info->snd_intv,
+				snd_sta_info->snd_intv * 10,
+				snd_sta_info->snd_intv_cnt,
+				snd_sta_info->snd_intv_cnt * 10,
+				snd_sta_info->snd_tx_cnt,
+				snd_sta_info->snd_stop_reason);
+		}
+
+		dev_info(dev->mt76.dev, "======================================\n");
+
+		break;
+	}
+	case UNI_EVENT_BF_CAL_PHASE: {
+		struct mt7996_ibf_cal_info *cal;
+		struct mt7996_txbf_phase *phase;
+		union {
+			struct mt7996_txbf_phase_out v1;
+			struct mt7992_txbf_phase_out v2;
+		} phase_out;
+		int phase_out_size = sizeof(struct mt7996_txbf_phase_out);
+
+		cal = (struct mt7996_ibf_cal_info *)skb->data;
+		phase = (struct mt7996_txbf_phase *)dev->test.txbf_phase_cal;
+		if (get_ibf_version(dev) == IBF_VER_2)
+			phase_out_size = sizeof(struct mt7992_txbf_phase_out);
+		memcpy(&phase_out, &cal->buf, phase_out_size);
+		switch (cal->cal_type) {
+		case IBF_PHASE_CAL_NORMAL:
+		case IBF_PHASE_CAL_NORMAL_INSTRUMENT:
+			/* Only calibrate group M */
+			if (cal->group_l_m_n != GROUP_M)
+				break;
+			phase = &phase[cal->group];
+			phase->status = cal->status;
+			mt76_dbg(&dev->mt76, MT76_DBG_TEST,
+				 "Calibrated result = %d\n", phase->status);
+			mt76_dbg(&dev->mt76, MT76_DBG_TEST,
+				 "Group %d and Group M\n", cal->group);
+			mt7996_ibf_phase_assign(dev, cal, phase);
+			break;
+		case IBF_PHASE_CAL_VERIFY:
+		case IBF_PHASE_CAL_VERIFY_INSTRUMENT:
+			mt76_dbg(&dev->mt76, MT76_DBG_TEST,
+				 "Verification result = %d\n", cal->status);
+			break;
+		default:
+			break;
+		}
+
+		if (get_ibf_version(dev) == IBF_VER_2) {
+			mt76_dbg(&dev->mt76, MT76_DBG_TEST,
+				 "c0_uh = %d, c1_uh = %d, c2_uh = %d, c3_uh = %d c4_uh = %d\n",
+				 phase_out.v2.c0_uh, phase_out.v2.c1_uh, phase_out.v2.c2_uh,
+				 phase_out.v2.c3_uh, phase_out.v2.c4_uh);
+			mt76_dbg(&dev->mt76, MT76_DBG_TEST,
+				 "c0_h = %d, c1_h = %d, c2_h = %d, c3_h = %d c4_h = %d\n",
+				 phase_out.v2.c0_h, phase_out.v2.c1_h, phase_out.v2.c2_h,
+				 phase_out.v2.c3_h, phase_out.v2.c4_h);
+			mt76_dbg(&dev->mt76, MT76_DBG_TEST,
+				 "c0_mh = %d, c1_mh = %d, c2_mh = %d, c3_mh = %d c4_mh = %d\n",
+				 phase_out.v2.c0_mh, phase_out.v2.c1_mh, phase_out.v2.c2_mh,
+				 phase_out.v2.c3_mh, phase_out.v2.c4_mh);
+			mt76_dbg(&dev->mt76, MT76_DBG_TEST,
+				 "c0_m = %d, c1_m = %d, c2_m = %d, c3_m = %d c4_m = %d\n",
+				 phase_out.v2.c0_m, phase_out.v2.c1_m, phase_out.v2.c2_m,
+				 phase_out.v2.c3_m, phase_out.v2.c4_m);
+			mt76_dbg(&dev->mt76, MT76_DBG_TEST,
+				 "c0_l = %d, c1_l = %d, c2_l = %d, c3_l = %d c4_l = %d\n",
+				 phase_out.v2.c0_l, phase_out.v2.c1_l, phase_out.v2.c2_l,
+				 phase_out.v2.c3_l, phase_out.v2.c4_l);
+		} else {
+			mt76_dbg(&dev->mt76, MT76_DBG_TEST,
+				 "c0_uh = %d, c1_uh = %d, c2_uh = %d, c3_uh = %d\n",
+				 phase_out.v1.c0_uh, phase_out.v1.c1_uh,
+				 phase_out.v1.c2_uh, phase_out.v1.c3_uh);
+			mt76_dbg(&dev->mt76, MT76_DBG_TEST,
+				 "c0_h = %d, c1_h = %d, c2_h = %d, c3_h = %d\n",
+				 phase_out.v1.c0_h, phase_out.v1.c1_h,
+				 phase_out.v1.c2_h, phase_out.v1.c3_h);
+			mt76_dbg(&dev->mt76, MT76_DBG_TEST,
+				 "c0_mh = %d, c1_mh = %d, c2_mh = %d, c3_mh = %d\n",
+				 phase_out.v1.c0_mh, phase_out.v1.c1_mh,
+				 phase_out.v1.c2_mh, phase_out.v1.c3_mh);
+			mt76_dbg(&dev->mt76, MT76_DBG_TEST,
+				 "c0_m = %d, c1_m = %d, c2_m = %d, c3_m = %d\n",
+				 phase_out.v1.c0_m, phase_out.v1.c1_m,
+				 phase_out.v1.c2_m, phase_out.v1.c3_m);
+			mt76_dbg(&dev->mt76, MT76_DBG_TEST,
+				 "c0_l = %d, c1_l = %d, c2_l = %d, c3_l = %d\n",
+				 phase_out.v1.c0_l, phase_out.v1.c1_l,
+				 phase_out.v1.c2_l, phase_out.v1.c3_l);
+		}
+
+		break;
+	}
+	default:
+		dev_info(dev->mt76.dev, "%s: unknown bf event tag %d\n",
+			 __func__, event->tag);
+	}
+
+	wake_up(&dev->mt76.mcu.wait);
+}
+
+#endif
diff --git a/mt7996/mtk_mcu.h b/mt7996/mtk_mcu.h
new file mode 100644
index 000000000..d9f6cfc72
--- /dev/null
+++ b/mt7996/mtk_mcu.h
@@ -0,0 +1,738 @@
+/* SPDX-License-Identifier: ISC */
+/*
+ * Copyright (C) 2023 MediaTek Inc.
+ */
+
+#ifndef __MT7996_MTK_MCU_H
+#define __MT7996_MTK_MCU_H
+
+#include "../mt76_connac_mcu.h"
+
+#ifdef CONFIG_MTK_DEBUG
+
+struct bf_pfmu_tag {
+	__le16 tag;
+	__le16 len;
+
+	u8 pfmu_id;
+	bool bfer;
+	u8 band_idx;
+	u8 __rsv[5];
+	u8 buf[56];
+} __packed;
+
+struct bf_starec_read {
+	__le16 tag;
+	__le16 len;
+
+	__le16 wlan_idx;
+	u8 __rsv[2];
+} __packed;
+
+struct bf_fbk_rpt_info {
+	__le16 tag;
+	__le16 len;
+
+	__le16 wlan_idx; // Only need for dynamic_pfmu_update 0x4
+	u8 action;
+	u8 band_idx;
+	u8 __rsv[4];
+
+} __packed;
+
+struct bf_txsnd_info {
+	__le16 tag;
+	__le16 len;
+
+	u8 action;
+	u8 read_clr;
+	u8 vht_opt;
+	u8 he_opt;
+	__le16 wlan_idx;
+	u8 glo_opt;
+	u8 snd_intv;
+	u8 snd_stop;
+	u8 max_snd_stas;
+	u8 tx_time;
+	u8 mcs;
+	u8 ldpc;
+	u8 inf;
+	u8 man;
+	u8 ac_queue;
+	u8 sxn_protect;
+	u8 direct_fbk;
+	u8 __rsv[2];
+} __packed;
+
+#define MAX_PHASE_GROUP_NUM	13
+
+struct bf_phase_comp {
+	__le16 tag;
+	__le16 len;
+
+	u8 bw;
+	u8 jp_band;
+	u8 band_idx;
+	bool read_from_e2p;
+	bool disable;
+	u8 group;
+	u8 rsv[2];
+	u8 buf[44];
+} __packed;
+
+struct bf_tx_apply {
+	__le16 tag;
+	__le16 len;
+
+	__le16 wlan_idx;
+	bool ebf;
+	bool ibf;
+	bool mu_txbf;
+	bool phase_cal;
+	u8 rsv[2];
+} __packed;
+
+struct bf_phase_cal {
+	__le16 tag;
+	__le16 len;
+
+	u8 group_l_m_n;
+	u8 group;
+	u8 sx2;
+	u8 cal_type;
+	u8 lna_gain_level;
+	u8 band_idx;
+	u8 version;
+	u8 rsv[1];
+} __packed;
+
+struct bf_txcmd {
+	__le16 tag;
+	__le16 len;
+
+	u8 action;
+	u8 bf_manual;
+	u8 bf_bit;
+	u8 rsv[5];
+} __packed;
+
+struct bf_pfmu_data_all {
+	__le16 tag;
+	__le16 len;
+
+	u8 pfmu_id;
+	u8 band_idx;
+	u8 rsv[2];
+
+	u8 buf[640];
+} __packed;
+
+#define TXBF_DUT_MAC_SUBADDR		0x22
+#define TXBF_GOLDEN_MAC_SUBADDR		0x11
+
+struct mt7996_tm_bf_req {
+	u8 _rsv[4];
+
+	union {
+		struct bf_sounding_on sounding;
+		struct bf_tx_apply tx_apply;
+		struct bf_pfmu_tag pfmu_tag;
+		struct bf_pfmu_data_all pfmu_data_all;
+		struct bf_phase_cal phase_cal;
+		struct bf_phase_comp phase_comp;
+		struct bf_txcmd txcmd;
+	};
+} __packed;
+
+enum tm_trx_mac_type {
+	TM_TRX_MAC_TX = 1,
+	TM_TRX_MAC_RX,
+	TM_TRX_MAC_TXRX,
+	TM_TRX_MAC_TXRX_RXV,
+	TM_TRX_MAC_RXV,
+	TM_TRX_MAC_RX_RXV,
+};
+
+enum tm_trx_param_idx {
+	TM_TRX_PARAM_RSV,
+	/* MAC */
+	TM_TRX_PARAM_SET_TRX,
+	TM_TRX_PARAM_RX_FILTER,
+	TM_TRX_PARAM_RX_FILTER_PKT_LEN,
+	TM_TRX_PARAM_SLOT_TIME,
+	TM_TRX_PARAM_CLEAN_PERSTA_TXQUEUE,
+	TM_TRX_PARAM_AMPDU_WTBL,
+	TM_TRX_PARAM_MU_RX_AID,
+	TM_TRX_PARAM_PHY_MANUAL_TX,
+
+	/* PHY */
+	TM_TRX_PARAM_RX_PATH,
+	TM_TRX_PARAM_TX_STREAM,
+	TM_TRX_PARAM_TSSI_STATUS,
+	TM_TRX_PARAM_DPD_STATUS,
+	TM_TRX_PARAM_RATE_POWER_OFFSET_ON_OFF,
+	TM_TRX_PARAM_THERMO_COMP_STATUS,
+	TM_TRX_PARAM_FREQ_OFFSET,
+	TM_TRX_PARAM_FAGC_RSSI_PATH,
+	TM_TRX_PARAM_PHY_STATUS_COUNT,
+	TM_TRX_PARAM_RXV_INDEX,
+
+	TM_TRX_PARAM_ANTENNA_PORT,
+	TM_TRX_PARAM_THERMAL_ONOFF,
+	TM_TRX_PARAM_TX_POWER_CONTROL_ALL_RF,
+	TM_TRX_PARAM_RATE_POWER_OFFSET,
+	TM_TRX_PARAM_SLT_CMD_TEST,
+	TM_TRX_PARAM_SKU,
+	TM_TRX_PARAM_POWER_PERCENTAGE_ON_OFF,
+	TM_TRX_PARAM_BF_BACKOFF_ON_OFF,
+	TM_TRX_PARAM_POWER_PERCENTAGE_LEVEL,
+	TM_TRX_PARAM_FRTBL_CFG,
+	TM_TRX_PARAM_PREAMBLE_PUNC_ON_OFF,
+
+	TM_TRX_PARAM_MAX_NUM,
+};
+
+enum trx_action {
+	TM_TRX_ACTION_SET,
+	TM_TRX_ACTION_GET,
+};
+
+struct tm_trx_set {
+	u8 type;
+	u8 enable;
+	u8 band_idx;
+	u8 rsv;
+} __packed;
+
+struct mt7996_tm_trx_req {
+	u8 param_num;
+	u8 _rsv[3];
+
+	__le16 tag;
+	__le16 len;
+
+	__le16 param_idx;
+	u8 band_idx;
+	u8 testmode_en;
+	u8 action;
+	u8 rsv[3];
+
+	u32 data;
+	struct tm_trx_set set_trx;
+
+	u8 buf[220];
+} __packed;
+
+struct mt7996_mcu_bf_basic_event {
+	struct mt7996_mcu_rxd rxd;
+
+	u8 __rsv1[4];
+
+	__le16 tag;
+	__le16 len;
+};
+
+struct mt7996_mcu_bf_starec_read {
+
+	struct mt7996_mcu_bf_basic_event event;
+
+	__le16 pfmu_id;
+	bool is_su_mu;
+	u8 txbf_cap;
+	u8 sounding_phy;
+	u8 ndpa_rate;
+	u8 ndp_rate;
+	u8 rpt_poll_rate;
+	u8 tx_mode;
+	u8 nc;
+	u8 nr;
+	u8 bw;
+	u8 total_mem_require;
+	u8 mem_require_20m;
+	u8 mem_row0;
+	u8 mem_col0:6;
+	u8 mem_row0_msb:2;
+	u8 mem_row1;
+	u8 mem_col1:6;
+	u8 mem_row1_msb:2;
+	u8 mem_row2;
+	u8 mem_col2:6;
+	u8 mem_row2_msb:2;
+	u8 mem_row3;
+	u8 mem_col3:6;
+	u8 mem_row3_msb:2;
+
+	__le16 smart_ant;
+	u8 se_idx;
+	u8 auto_sounding_ctrl;
+
+	u8 bf_timeout;
+	u8 bf_dbw;
+	u8 bf_ncol;
+	u8 bf_nrow;
+
+	u8 nr_lt_bw80;
+	u8 nc_lt_bw80;
+	u8 ru_start_idx;
+	u8 ru_end_idx;
+
+	bool trigger_su;
+	bool trigger_mu;
+
+	bool ng16_su;
+	bool ng16_mu;
+
+	bool codebook42_su;
+	bool codebook75_mu;
+
+	u8 he_ltf;
+	u8 rsv[3];
+};
+
+#define TXBF_PFMU_ID_NUM_MAX 48
+
+#define TXBF_PFMU_ID_NUM_MAX_TBTC_BAND0 TXBF_PFMU_ID_NUM_MAX
+#define TXBF_PFMU_ID_NUM_MAX_TBTC_BAND1 TXBF_PFMU_ID_NUM_MAX
+#define TXBF_PFMU_ID_NUM_MAX_TBTC_BAND2 TXBF_PFMU_ID_NUM_MAX
+
+/* CFG_BF_STA_REC shall be varied based on BAND Num */
+#define CFG_BF_STA_REC_NUM (TXBF_PFMU_ID_NUM_MAX_TBTC_BAND0 + TXBF_PFMU_ID_NUM_MAX_TBTC_BAND1 + TXBF_PFMU_ID_NUM_MAX_TBTC_BAND2)
+
+#define BF_SND_CTRL_STA_DWORD_CNT   ((CFG_BF_STA_REC_NUM + 0x1F) >> 5)
+
+#ifndef ALIGN_4
+	#define ALIGN_4(_value)             (((_value) + 3) & ~3u)
+#endif /* ALIGN_4 */
+
+#define CFG_WIFI_RAM_BAND_NUM 3
+
+struct uni_event_bf_txsnd_sta_info {
+	u8 snd_intv;       /* Sounding interval upper bound, unit:15ms */
+	u8 snd_intv_cnt;   /* Sounding interval counter */
+	u8 snd_tx_cnt;     /* Tx sounding count for debug */
+	u8 snd_stop_reason;  /* Bitwise reason to put in Stop Queue */
+};
+
+struct mt7996_mcu_tx_snd_info {
+
+	struct mt7996_mcu_bf_basic_event event;
+
+	u8 vht_opt;
+	u8 he_opt;
+	u8 glo_opt;
+	u8 __rsv;
+	__le32 snd_rec_su_sta[BF_SND_CTRL_STA_DWORD_CNT];
+	__le32 snd_rec_vht_mu_sta[BF_SND_CTRL_STA_DWORD_CNT];
+	__le32 snd_rec_he_tb_sta[BF_SND_CTRL_STA_DWORD_CNT];
+	__le32 snd_rec_eht_tb_sta[BF_SND_CTRL_STA_DWORD_CNT];
+	__le16 wlan_idx_for_mc_snd[ALIGN_4(CFG_WIFI_RAM_BAND_NUM)];
+	__le16 wlan_idx_for_he_tb_snd[ALIGN_4(CFG_WIFI_RAM_BAND_NUM)];
+	__le16 wlan_idx_for_eht_tb_snd[ALIGN_4(CFG_WIFI_RAM_BAND_NUM)];
+	__le16 ul_length;
+	u8 mcs;
+	u8 ldpc;
+	struct uni_event_bf_txsnd_sta_info snd_sta_info[CFG_BF_STA_REC_NUM];
+};
+
+struct mt7996_mcu_txbf_fbk_info {
+
+	struct mt7996_mcu_bf_basic_event event;
+
+	__le32 u4DeQInterval;     /* By ms */
+	__le32 u4PollPFMUIntrStatTimeOut; /* micro-sec */
+	__le32 u4RptPktTimeOutListNum;
+	__le32 u4RptPktListNum;
+	__le32 u4PFMUWRTimeOutCnt;
+	__le32 u4PFMUWRFailCnt;
+	__le32 u4PFMUWRDoneCnt;
+	__le32 u4PFMUWRTimeoutFreeCnt;
+	__le32 u4FbRptPktDropCnt;
+	__le32 au4RxPerStaFbRptCnt[CFG_BF_STA_REC_NUM];
+};
+
+struct pfmu_ru_field {
+	__le32 ru_start_id:7;
+	__le32 _rsv1:1;
+	__le32 ru_end_id:7;
+	__le32 _rsv2:1;
+} __packed;
+
+struct pfmu_partial_bw_info {
+	__le32 partial_bw_info:9;
+	__le32 _rsv1:7;
+} __packed;
+
+struct mt7996_pfmu_tag1 {
+	__le32 pfmu_idx:10;
+	__le32 ebf:1;
+	__le32 data_bw:3;
+	__le32 lm:3;
+	__le32 is_mu:1;
+	__le32 nr:3;
+	__le32 nc:3;
+	__le32 codebook:2;
+	__le32 ngroup:2;
+	__le32 invalid_prof:1;
+	__le32 _rsv:3;
+
+	__le32 col_id1:7, row_id1:9;
+	__le32 col_id2:7, row_id2:9;
+	__le32 col_id3:7, row_id3:9;
+	__le32 col_id4:7, row_id4:9;
+
+	union {
+		struct pfmu_ru_field field;
+		struct pfmu_partial_bw_info bw_info;
+	};
+	__le32 mob_cal_en:1;
+	__le32 _rsv2:3;
+	__le32 mob_ru_alloc:9;	/* EHT profile uses full 9 bit */
+	__le32 _rsv3:3;
+
+	__le32 snr_sts0:8, snr_sts1:8, snr_sts2:8, snr_sts3:8;
+	__le32 snr_sts4:8, snr_sts5:8, snr_sts6:8, snr_sts7:8;
+
+	__le32 _rsv4;
+} __packed;
+
+struct mt7996_pfmu_tag2 {
+	__le32 smart_ant:24;
+	__le32 se_idx:5;
+	__le32 _rsv:3;
+
+	__le32 _rsv1:16;
+	__le32 ibf_timeout:8;
+	__le32 _rsv2:8;
+
+	__le32 ibf_data_bw:3;
+	__le32 ibf_nc:3;
+	__le32 ibf_nr:3;
+	__le32 ibf_ru:9;
+	__le32 _rsv3:14;
+
+	__le32 mob_delta_t:8;
+	__le32 mob_lq_result:7;
+	__le32 _rsv5:1;
+	__le32 _rsv6:16;
+
+	__le32 _rsv7;
+} __packed;
+
+struct mt7996_pfmu_tag_event {
+	struct mt7996_mcu_bf_basic_event event;
+
+	u8 bfer;
+	u8 __rsv[3];
+
+	struct mt7996_pfmu_tag1 t1;
+	struct mt7996_pfmu_tag2 t2;
+};
+
+struct mt7996_pfmu_tag {
+	struct mt7996_pfmu_tag1 t1;
+	struct mt7996_pfmu_tag2 t2;
+};
+
+enum bf_lm_type {
+	BF_LM_LEGACY,
+	BF_LM_HT,
+	BF_LM_VHT,
+	BF_LM_HE,
+	BF_LM_EHT,
+};
+
+struct mt7996_txbf_phase_out {
+	u8 c0_l;
+	u8 c1_l;
+	u8 c2_l;
+	u8 c3_l;
+	u8 c0_m;
+	u8 c1_m;
+	u8 c2_m;
+	u8 c3_m;
+	u8 c0_mh;
+	u8 c1_mh;
+	u8 c2_mh;
+	u8 c3_mh;
+	u8 c0_h;
+	u8 c1_h;
+	u8 c2_h;
+	u8 c3_h;
+	u8 c0_uh;
+	u8 c1_uh;
+	u8 c2_uh;
+	u8 c3_uh;
+};
+
+struct mt7992_txbf_phase_out {
+	u8 c0_l;
+	u8 c1_l;
+	u8 c2_l;
+	u8 c3_l;
+	u8 c4_l;
+	u8 c0_m;
+	u8 c1_m;
+	u8 c2_m;
+	u8 c3_m;
+	u8 c4_m;
+	u8 c0_mh;
+	u8 c1_mh;
+	u8 c2_mh;
+	u8 c3_mh;
+	u8 c4_mh;
+	u8 c0_h;
+	u8 c1_h;
+	u8 c2_h;
+	u8 c3_h;
+	u8 c4_h;
+	u8 c0_uh;
+	u8 c1_uh;
+	u8 c2_uh;
+	u8 c3_uh;
+	u8 c4_uh;
+};
+
+struct txbf_rx_phase {
+	u8 rx_uh;
+	u8 rx_h;
+	u8 rx_m;
+	u8 rx_l;
+	u8 rx_ul;
+};
+
+struct txbf_rx_phase_ext {
+	u8 rx_uh;
+	u8 rx_h;
+	u8 rx_mh;
+	u8 rx_m;
+	u8 rx_l;
+	u8 rx_ul;
+};
+
+struct mt7996_txbf_phase_info_2g {
+	struct txbf_rx_phase r0;
+	struct txbf_rx_phase r1;
+	struct txbf_rx_phase r2;
+	struct txbf_rx_phase r3;
+	struct txbf_rx_phase r2_sx2;
+	struct txbf_rx_phase r3_sx2;
+	u8 m_t0_h;
+	u8 m_t1_h;
+	u8 m_t2_h;
+	u8 m_t2_h_sx2;
+	u8 r0_reserved;
+	u8 r1_reserved;
+	u8 r2_reserved;
+	u8 r3_reserved;
+	u8 r2_sx2_reserved;
+	u8 r3_sx2_reserved;
+};
+
+struct mt7996_txbf_phase_info_5g {
+	struct txbf_rx_phase_ext r0;
+	struct txbf_rx_phase_ext r1;
+	struct txbf_rx_phase_ext r2;
+	struct txbf_rx_phase_ext r3;
+	struct txbf_rx_phase r2_sx2;	/* no middle-high in r2_sx2 */
+	struct txbf_rx_phase r3_sx2;	/* no middle-high in r3_sx2 */
+	u8 m_t0_h;
+	u8 m_t1_h;
+	u8 m_t2_h;
+	u8 m_t2_h_sx2;
+	u8 r0_reserved;
+	u8 r1_reserved;
+	u8 r2_reserved;
+	u8 r3_reserved;
+	u8 r2_sx2_reserved;
+	u8 r3_sx2_reserved;
+};
+
+struct mt7992_txbf_phase_info_2g {
+	struct txbf_rx_phase_ext r0;
+	struct txbf_rx_phase_ext r1;
+	struct txbf_rx_phase_ext r2;
+	struct txbf_rx_phase_ext r3;
+	u8 m_t0_h;
+	u8 m_t1_h;
+	u8 m_t2_h;
+};
+
+struct mt7992_txbf_phase_info_5g {
+	struct txbf_rx_phase_ext r0;
+	struct txbf_rx_phase_ext r1;
+	struct txbf_rx_phase_ext r2;
+	struct txbf_rx_phase_ext r3;
+	struct txbf_rx_phase_ext r4;
+	u8 m_t0_h;
+	u8 m_t1_h;
+	u8 m_t2_h;
+	u8 m_t3_h;
+};
+
+struct mt7996_txbf_phase {
+	u8 status;
+	union {
+		union {
+			struct mt7996_txbf_phase_info_2g phase_2g;
+			struct mt7996_txbf_phase_info_5g phase_5g;
+		} v1;
+		union {
+			struct mt7992_txbf_phase_info_2g phase_2g;
+			struct mt7992_txbf_phase_info_5g phase_5g;
+		} v2;
+		u8 buf[44];
+	};
+};
+
+#define phase_assign(group, v, field, dump, ...)	({					\
+	if (group) {										\
+		phase->v.phase_5g.field = cal->v.phase_5g.field;				\
+		if (dump)									\
+			mt76_dbg(&dev->mt76, MT76_DBG_TEST, "%s = %d\n",			\
+				 #field, phase->v.phase_5g.field);				\
+	} else {										\
+		phase->v.phase_2g.field = cal->v.phase_5g.field;				\
+		if (dump)									\
+			mt76_dbg(&dev->mt76, MT76_DBG_TEST, "%s = %d\n",			\
+				 #field, phase->v.phase_2g.field);				\
+	}											\
+})
+
+#define phase_assign_rx(group, v, rx, dump, ...)	({					\
+	phase_assign(group, v, rx.rx_uh, dump);							\
+	phase_assign(group, v, rx.rx_h, dump);							\
+	phase_assign(group, v, rx.rx_m, dump);							\
+	phase_assign(group, v, rx.rx_l, dump);							\
+	phase_assign(group, v, rx.rx_ul, dump);							\
+})
+
+#define phase_assign_rx_ext(group, v, rx, dump, ...)	({					\
+	phase_assign(group, v, rx.rx_uh, dump);							\
+	phase_assign(group, v, rx.rx_h, dump);							\
+	phase_assign(group, v, rx.rx_mh, dump);							\
+	phase_assign(group, v, rx.rx_m, dump);							\
+	phase_assign(group, v, rx.rx_l, dump);							\
+	phase_assign(group, v, rx.rx_ul, dump);							\
+})
+
+#define phase_assign_rx_v1(group, v, rx, ...)	({						\
+	if (group) {										\
+		phase_assign(group, v, rx.rx_uh, true);						\
+		phase_assign(group, v, rx.rx_h, true);						\
+		phase->v.phase_5g.rx.rx_mh = cal->v.phase_5g.rx.rx_mh;				\
+		mt76_dbg(&dev->mt76, MT76_DBG_TEST, "%s.rx_mh = %d\n",				\
+			 #rx, phase->v.phase_5g.rx.rx_mh);					\
+		phase_assign(group, v, rx.rx_m, true);						\
+		phase_assign(group, v, rx.rx_l, true);						\
+		phase_assign(group, v, rx.rx_ul, true);						\
+	} else {										\
+		phase_assign_rx(group, v, rx, true, ...);					\
+	}											\
+})
+
+#define GROUP_L		0
+#define GROUP_M		1
+#define GROUP_H		2
+
+struct mt7996_pfmu_data {
+	__le16 subc_idx;
+	__le16 phi11;
+	__le16 phi21;
+	__le16 phi31;
+};
+
+struct mt7996_pfmu_data_5x5 {
+	__le16 subc_idx;
+	__le16 phi11;
+	__le16 phi21;
+	__le16 phi31;
+	__le16 phi41;
+};
+
+struct mt7996_ibf_cal_info {
+	struct mt7996_mcu_bf_basic_event event;
+
+	u8 category_id;
+	u8 group_l_m_n;
+	u8 group;
+	bool sx2;
+	u8 status;
+	u8 cal_type;
+	u8 nsts;
+	u8 version;
+	union {
+		struct {
+			struct mt7996_txbf_phase_out phase_out;
+			union {
+				struct mt7996_txbf_phase_info_2g phase_2g;
+				struct mt7996_txbf_phase_info_5g phase_5g;
+			};
+		} v1;
+		struct {
+			struct mt7992_txbf_phase_out phase_out;
+			union {
+				struct mt7992_txbf_phase_info_2g phase_2g;
+				struct mt7992_txbf_phase_info_5g phase_5g;
+			};
+		} v2;
+		u8 buf[64];
+	};
+} __packed;
+
+enum {
+	IBF_PHASE_CAL_UNSPEC,
+	IBF_PHASE_CAL_NORMAL,
+	IBF_PHASE_CAL_VERIFY,
+	IBF_PHASE_CAL_NORMAL_INSTRUMENT,
+	IBF_PHASE_CAL_VERIFY_INSTRUMENT,
+};
+
+enum ibf_version {
+	IBF_VER_1,
+	IBF_VER_2 = 3,
+};
+
+static inline int get_ibf_version(struct mt7996_dev *dev)
+{
+	switch (mt76_chip(&dev->mt76)) {
+	case MT7996_DEVICE_ID:
+		return IBF_VER_1;
+	case MT7992_DEVICE_ID:
+	default:
+		return IBF_VER_2;
+	}
+}
+
+#define MT7996_TXBF_SUBCAR_NUM		64
+#define MT7996_TXBF_PFMU_DATA_LEN	(MT7996_TXBF_SUBCAR_NUM * sizeof(struct mt7996_pfmu_data))
+#define MT7996_TXBF_PFMU_DATA_LEN_5X5	(MT7996_TXBF_SUBCAR_NUM * \
+					 sizeof(struct mt7996_pfmu_data_5x5))
+
+enum {
+	UNI_EVENT_BF_PFMU_TAG = 0x5,
+	UNI_EVENT_BF_PFMU_DATA = 0x7,
+	UNI_EVENT_BF_STAREC = 0xB,
+	UNI_EVENT_BF_CAL_PHASE = 0xC,
+	UNI_EVENT_BF_FBK_INFO = 0x17,
+	UNI_EVENT_BF_TXSND_INFO = 0x18,
+	UNI_EVENT_BF_PLY_INFO = 0x19,
+	UNI_EVENT_BF_METRIC_INFO = 0x1A,
+	UNI_EVENT_BF_TXCMD_CFG_INFO = 0x1B,
+	UNI_EVENT_BF_SND_CNT_INFO = 0x1D,
+	UNI_EVENT_BF_MAX_NUM
+};
+
+enum {
+	BF_SND_READ_INFO = 0,
+	BF_SND_CFG_OPT,
+	BF_SND_CFG_INTV,
+	BF_SND_STA_STOP,
+	BF_SND_CFG_MAX_STA,
+	BF_SND_CFG_BFRP,
+	BF_SND_CFG_INF,
+	BF_SND_CFG_TXOP_SND
+};
+
+#endif
+
+#endif
diff --git a/mt7996/regs.h b/mt7996/regs.h
index 1768ed346..c9211dd13 100644
--- a/mt7996/regs.h
+++ b/mt7996/regs.h
@@ -355,6 +355,9 @@ enum offs_rev {
 #define MT_ARB_SCR_TX_DISABLE			BIT(8)
 #define MT_ARB_SCR_RX_DISABLE			BIT(9)
 
+#define MT_ARB_TQSAXM0(_band)			MT_WF_ARB(_band, 0x180)
+#define MT_ARB_TQSAXM_ALTX_START_MASK		GENMASK(12, 8)
+
 /* RMAC: band 0(0x820e5000), band 1(0x820f5000), band 2(0x830e5000), */
 #define MT_WF_RMAC_BASE(_band)			__BASE(WF_RMAC_BASE, (_band))
 #define MT_WF_RMAC(_band, ofs)			(MT_WF_RMAC_BASE(_band) + (ofs))
diff --git a/mt7996/testmode.c b/mt7996/testmode.c
new file mode 100644
index 000000000..4bc8a1dbd
--- /dev/null
+++ b/mt7996/testmode.c
@@ -0,0 +1,2989 @@
+// SPDX-License-Identifier: ISC
+/*
+ * Copyright (C) 2022 MediaTek Inc.
+ */
+
+#include "mt7996.h"
+#include "mac.h"
+#include "mcu.h"
+#include "testmode.h"
+#include "eeprom.h"
+#include "mtk_mcu.h"
+
+enum tm_changed {
+	TM_CHANGED_TXPOWER,
+	TM_CHANGED_FREQ_OFFSET,
+	TM_CHANGED_SKU_EN,
+	TM_CHANGED_TX_LENGTH,
+	TM_CHANGED_TX_TIME,
+	TM_CHANGED_CFG,
+	TM_CHANGED_OFF_CHAN_CH,
+	TM_CHANGED_OFF_CHAN_CENTER_CH,
+	TM_CHANGED_OFF_CHAN_BW,
+	TM_CHANGED_IPI_THRESHOLD,
+	TM_CHANGED_IPI_PERIOD,
+	TM_CHANGED_IPI_RESET,
+	TM_CHANGED_TXBF_ACT,
+	TM_CHANGED_TX_ANTENNA,
+	TM_CHANGED_TX_RATE_NSS,
+	TM_CHANGED_TX_RATE_IDX,
+	TM_CHANGED_RX_FILTER,
+
+	/* must be last */
+	NUM_TM_CHANGED
+};
+
+static const u8 tm_change_map[] = {
+	[TM_CHANGED_TXPOWER] = MT76_TM_ATTR_TX_POWER,
+	[TM_CHANGED_FREQ_OFFSET] = MT76_TM_ATTR_FREQ_OFFSET,
+	[TM_CHANGED_SKU_EN] = MT76_TM_ATTR_SKU_EN,
+	[TM_CHANGED_TX_LENGTH] = MT76_TM_ATTR_TX_LENGTH,
+	[TM_CHANGED_TX_TIME] = MT76_TM_ATTR_TX_TIME,
+	[TM_CHANGED_CFG] = MT76_TM_ATTR_CFG,
+	[TM_CHANGED_OFF_CHAN_CH] = MT76_TM_ATTR_OFF_CH_SCAN_CH,
+	[TM_CHANGED_OFF_CHAN_CENTER_CH] = MT76_TM_ATTR_OFF_CH_SCAN_CENTER_CH,
+	[TM_CHANGED_OFF_CHAN_BW] = MT76_TM_ATTR_OFF_CH_SCAN_BW,
+	[TM_CHANGED_IPI_THRESHOLD] = MT76_TM_ATTR_IPI_THRESHOLD,
+	[TM_CHANGED_IPI_PERIOD] = MT76_TM_ATTR_IPI_PERIOD,
+	[TM_CHANGED_IPI_RESET] = MT76_TM_ATTR_IPI_RESET,
+	[TM_CHANGED_TXBF_ACT] = MT76_TM_ATTR_TXBF_ACT,
+	[TM_CHANGED_TX_ANTENNA] = MT76_TM_ATTR_TX_ANTENNA,
+	[TM_CHANGED_TX_RATE_NSS] = MT76_TM_ATTR_TX_RATE_NSS,
+	[TM_CHANGED_TX_RATE_IDX] = MT76_TM_ATTR_TX_RATE_IDX,
+	[TM_CHANGED_RX_FILTER] = MT76_TM_ATTR_RX_FILTER,
+};
+
+static void mt7996_tm_ipi_work(struct work_struct *work);
+static int mt7996_tm_txbf_apply_tx(struct mt7996_phy *phy, u16 wlan_idx,
+				   bool ebf, bool ibf, bool phase_cal);
+
+static u32 mt7996_tm_bw_mapping(enum nl80211_chan_width width, enum bw_mapping_method method)
+{
+	static const u32 width_to_bw[][NUM_BW_MAP] = {
+		[NL80211_CHAN_WIDTH_40] = {FW_CDBW_40MHZ, TM_CBW_40MHZ, BF_CDBW_40MHZ, 40,
+					   FIRST_CONTROL_CHAN_BITMAP_BW40, ICAP_BW_40MHZ},
+		[NL80211_CHAN_WIDTH_80] = {FW_CDBW_80MHZ, TM_CBW_80MHZ, BF_CDBW_80MHZ, 80,
+					   FIRST_CONTROL_CHAN_BITMAP_BW80, ICAP_BW_80MHZ},
+		[NL80211_CHAN_WIDTH_80P80] = {FW_CDBW_8080MHZ, TM_CBW_8080MHZ, BF_CDBW_8080MHZ,
+					      80, 0x0, ICAP_BW_8080MHZ},
+		[NL80211_CHAN_WIDTH_160] = {FW_CDBW_160MHZ, TM_CBW_160MHZ, BF_CDBW_160MHZ, 160,
+					    FIRST_CONTROL_CHAN_BITMAP_BW160, ICAP_BW_160MHZ},
+		[NL80211_CHAN_WIDTH_5] = {FW_CDBW_5MHZ, TM_CBW_5MHZ, BF_CDBW_5MHZ, 5,
+					  0x0, ICAP_BW_20MHZ},
+		[NL80211_CHAN_WIDTH_10] = {FW_CDBW_10MHZ, TM_CBW_10MHZ, BF_CDBW_10MHZ, 10,
+					   0x0, ICAP_BW_20MHZ},
+		[NL80211_CHAN_WIDTH_20] = {FW_CDBW_20MHZ, TM_CBW_20MHZ, BF_CDBW_20MHZ, 20,
+					   0x0, ICAP_BW_20MHZ},
+		[NL80211_CHAN_WIDTH_20_NOHT] = {FW_CDBW_20MHZ, TM_CBW_20MHZ, BF_CDBW_20MHZ,
+						20, 0x0, ICAP_BW_20MHZ},
+		[NL80211_CHAN_WIDTH_320] = {FW_CDBW_320MHZ, TM_CBW_320MHZ, BF_CDBW_320MHZ,
+					    320, 0x0, ICAP_BW_320MHZ},
+	};
+
+	if (width >= ARRAY_SIZE(width_to_bw))
+		return 0;
+
+	return width_to_bw[width][method];
+}
+
+static u8 mt7996_tm_rate_mapping(u8 tx_rate_mode, enum rate_mapping_type type)
+{
+	static const u8 rate_to_phy[][NUM_RATE_MAP] = {
+		[MT76_TM_TX_MODE_CCK] = {TM_PHY_MODE_CCK, BF_LM_LEGACY},
+		[MT76_TM_TX_MODE_OFDM] = {TM_PHY_MODE_OFDM, BF_LM_LEGACY},
+		[MT76_TM_TX_MODE_HT] = {TM_PHY_MODE_HT, BF_LM_HT},
+		[MT76_TM_TX_MODE_VHT] = {TM_PHY_MODE_VHT, BF_LM_VHT},
+		[MT76_TM_TX_MODE_HE_SU] = {TM_PHY_MODE_HE_SU, BF_LM_HE},
+		[MT76_TM_TX_MODE_HE_EXT_SU] = {TM_PHY_MODE_HE_EXT_SU, BF_LM_HE},
+		[MT76_TM_TX_MODE_HE_TB] = {TM_PHY_MODE_HE_TB, BF_LM_HE},
+		[MT76_TM_TX_MODE_HE_MU] = {TM_PHY_MODE_HE_MU, BF_LM_HE},
+		[MT76_TM_TX_MODE_EHT_SU] = {TM_PHY_MODE_EHT_SU, BF_LM_EHT},
+		[MT76_TM_TX_MODE_EHT_TRIG] = {TM_PHY_MODE_EHT_TRIG, BF_LM_EHT},
+		[MT76_TM_TX_MODE_EHT_MU] = {TM_PHY_MODE_EHT_MU, BF_LM_EHT},
+	};
+
+	if (tx_rate_mode > MT76_TM_TX_MODE_MAX)
+		return 0;
+
+	return rate_to_phy[tx_rate_mode][type];
+}
+
+static u8 mt7996_tm_band_mapping(enum nl80211_band band)
+{
+	static const u8 ch_band[] = {
+		[NL80211_BAND_2GHZ] = 0,
+		[NL80211_BAND_5GHZ] = 1,
+		[NL80211_BAND_6GHZ] = 2,
+	};
+
+	if (band >= NUM_NL80211_BANDS)
+		return 0;
+
+	return ch_band[band];
+}
+
+static int
+mt7996_tm_check_antenna(struct mt7996_phy *phy)
+{
+	struct mt76_testmode_data *td = &phy->mt76->test;
+	struct mt7996_dev *dev = phy->dev;
+	u32 chainmask = phy->mt76->chainmask;
+	u32 aux_rx_mask;
+
+	aux_rx_mask = BIT(fls(chainmask)) * phy->has_aux_rx;
+	if (td->tx_antenna_mask & ~(chainmask | aux_rx_mask)) {
+		mt76_err(&dev->mt76,
+			 "%s: antenna mask 0x%x exceeds limit (chainmask 0x%x, %s auxiliary RX)\n",
+			 __func__, td->tx_antenna_mask, chainmask,
+			 phy->has_aux_rx ? "has" : "no");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int
+mt7996_tm_set(struct mt7996_dev *dev, u32 func_idx, u32 data)
+{
+	struct mt7996_tm_req req = {
+		.rf_test = {
+			.tag = cpu_to_le16(UNI_RF_TEST_CTRL),
+			.len = cpu_to_le16(sizeof(req.rf_test)),
+			.action = RF_ACTION_SET,
+			.op.rf.func_idx = cpu_to_le32(func_idx),
+			.op.rf.param.func_data = cpu_to_le32(data),
+		},
+	};
+	bool wait = (data == RF_CMD(START_TX)) ? true : false;
+
+	return mt76_mcu_send_msg(&dev->mt76, MCU_WM_UNI_CMD(TESTMODE_CTRL), &req,
+				 sizeof(req), wait);
+}
+
+static int
+mt7996_tm_get(struct mt7996_dev *dev, u32 func_idx, u32 data, u32 *result)
+{
+	struct mt7996_tm_req req = {
+		.rf_test = {
+			.tag = cpu_to_le16(UNI_RF_TEST_CTRL),
+			.len = cpu_to_le16(sizeof(req.rf_test)),
+			.action = RF_ACTION_GET,
+			.op.rf.func_idx = cpu_to_le32(func_idx),
+			.op.rf.param.func_data = cpu_to_le32(data),
+		},
+	};
+	struct mt7996_tm_event *event;
+	struct sk_buff *skb;
+	int ret;
+
+	ret = mt76_mcu_send_and_get_msg(&dev->mt76, MCU_WM_UNI_CMD_QUERY(TESTMODE_CTRL),
+					&req, sizeof(req), true, &skb);
+	if (ret)
+		return ret;
+
+	event = (struct mt7996_tm_event *)skb->data;
+	*result = le32_to_cpu(event->result.func_data);
+
+	dev_kfree_skb(skb);
+
+	return ret;
+}
+
+static void
+mt7996_tm_set_antenna(struct mt7996_phy *phy, u32 func_idx)
+{
+#define SPE_INDEX_MASK		BIT(31)
+#define TX_ANTENNA_MASK		GENMASK(4, 0)
+#define RX_ANTENNA_MASK		GENMASK(20, 16)
+	struct mt7996_dev *dev = phy->dev;
+	struct mt76_testmode_data *td = &phy->mt76->test;
+	u32 antenna_mask;
+
+	if (!mt76_testmode_param_present(td, MT76_TM_ATTR_TX_ANTENNA))
+		return;
+
+	if (func_idx == SET_ID(TX_PATH))
+		antenna_mask = td->tx_spe_idx ? (SPE_INDEX_MASK | td->tx_spe_idx) :
+						td->tx_antenna_mask & TX_ANTENNA_MASK;
+	else if (func_idx == SET_ID(RX_PATH))
+		antenna_mask = u32_encode_bits(td->tx_antenna_mask, RX_ANTENNA_MASK);
+	else
+		return;
+
+	mt7996_tm_set(dev, func_idx, antenna_mask);
+}
+
+static void
+mt7996_tm_set_mac_addr(struct mt7996_dev *dev, u8 *addr, u32 func_idx)
+{
+#define REMAIN_PART_TAG		BIT(18)
+	u32 own_mac_first = 0, own_mac_remain = 0;
+	int len = sizeof(u32);
+
+	memcpy(&own_mac_first, addr, len);
+	mt7996_tm_set(dev, func_idx, own_mac_first);
+	/* Set the remain part of mac address */
+	memcpy(&own_mac_remain, addr + len, ETH_ALEN - len);
+	mt7996_tm_set(dev, func_idx | REMAIN_PART_TAG, own_mac_remain);
+}
+
+static int
+mt7996_tm_rf_switch_mode(struct mt7996_dev *dev, u32 op_mode)
+{
+	struct mt7996_tm_req req = {
+		.rf_test = {
+			.tag = cpu_to_le16(UNI_RF_TEST_CTRL),
+			.len = cpu_to_le16(sizeof(req.rf_test)),
+			.action = RF_ACTION_SWITCH_TO_RF_TEST,
+			.op.op_mode = cpu_to_le32(op_mode),
+		},
+	};
+
+	return mt76_mcu_send_msg(&dev->mt76, MCU_WM_UNI_CMD(TESTMODE_CTRL), &req,
+				 sizeof(req), false);
+}
+
+static void
+mt7996_tm_init(struct mt7996_phy *phy, bool en)
+{
+	struct ieee80211_vif *vif = phy->mt76->monitor_vif;
+	struct mt7996_dev *dev = phy->dev;
+	struct mt76_testmode_data *td = &phy->mt76->test;
+	struct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;
+	struct mt7996_vif_link *deflink = &mvif->deflink;
+	u8 rf_test_mode;
+	int state;
+
+	if (!test_bit(MT76_STATE_RUNNING, &phy->mt76->state))
+		return;
+
+	if (en) {
+		rf_test_mode = RF_OPER_RF_TEST;
+		state = CONN_STATE_PORT_SECURE;
+		/* use firmware counter for RX stats */
+		td->flag |= MT_TM_FW_RX_COUNT;
+		INIT_DELAYED_WORK(&phy->ipi_work, mt7996_tm_ipi_work);
+	} else {
+		rf_test_mode = RF_OPER_NORMAL;
+		state = CONN_STATE_DISCONNECT;
+		memset(td, 0, sizeof(*td));
+		kfree(phy->mt76->lists);
+		phy->mt76->lists = NULL;
+	}
+
+	mt7996_mcu_set_tx_power_ctrl(phy, POWER_CTRL(ATE_MODE), en);
+	mt7996_mcu_set_tx_power_ctrl(phy, POWER_CTRL(SKU_POWER_LIMIT), !en);
+	mt7996_mcu_set_tx_power_ctrl(phy, POWER_CTRL(BACKOFF_POWER_LIMIT), !en);
+
+	mt7996_tm_rf_switch_mode(dev, rf_test_mode);
+
+	mt7996_mcu_add_bss_info(phy, vif, &vif->bss_conf,
+				&deflink->mt76, &deflink->msta_link, en);
+	mt7996_mcu_add_sta(dev, &vif->bss_conf, NULL, deflink,
+			   &deflink->msta_link, state, false);
+
+	if (en)
+		mt7996_tm_set(dev, SET_ID(BAND_IDX), phy->mt76->band_idx);
+}
+
+void
+mt7996_tm_update_channel(struct mt7996_phy *phy)
+{
+#define CHAN_FREQ_BW_80P80_TAG		(SET_ID(CHAN_FREQ) | BIT(16))
+#define FAST_CAL_NONE			BIT(20)
+#define FAST_CAL_RX			BIT(21)
+#define FAST_CAL_POWER			BIT(22)
+	struct mt7996_dev *dev = phy->dev;
+	struct mt76_testmode_data *td = &phy->mt76->test;
+	struct cfg80211_chan_def *chandef = &phy->mt76->chandef;
+	struct ieee80211_channel *chan = chandef->chan;
+	u8 dbw, width = chandef->width, pri_sel = 0;
+	int width_mhz;
+
+	if (!chan) {
+		mt76_err(&dev->mt76, "%s: no channel found, update failed\n", __func__);
+		return;
+	}
+
+	/* system bw */
+	mt7996_tm_set(dev, SET_ID(CBW), mt7996_tm_bw_mapping(width, BW_MAP_NL_TO_FW));
+
+	if (width == NL80211_CHAN_WIDTH_80P80) {
+		width = NL80211_CHAN_WIDTH_160;
+		mt7996_tm_set(dev, CHAN_FREQ_BW_80P80_TAG, chandef->center_freq2 * 1000);
+	}
+
+	width_mhz = mt7996_tm_bw_mapping(width, BW_MAP_NL_TO_MHZ);
+
+	/* data (per-packet) bw */
+	dbw = width;
+	if (mt76_testmode_param_present(td, MT76_TM_ATTR_TX_PKT_BW)) {
+		int pkt_bw_mhz = mt7996_tm_bw_mapping(td->tx_pkt_bw, BW_MAP_NL_TO_MHZ);
+
+		if (pkt_bw_mhz > width_mhz) {
+			mt76_dbg(&dev->mt76, MT76_DBG_TEST,
+				 "%s: per-packet bw cannot exceed system bw, use %d MHz instead\n",
+				 __func__, width_mhz);
+			td->tx_pkt_bw = width;
+		}
+		dbw = td->tx_pkt_bw;
+	}
+	mt7996_tm_set(dev, SET_ID(DBW), mt7996_tm_bw_mapping(dbw, BW_MAP_NL_TO_FW));
+
+	/* control channel selection index */
+	if (mt76_testmode_param_present(td, MT76_TM_ATTR_TX_PRI_SEL)) {
+		if (td->tx_pri_sel > width_mhz / 20 - 1) {
+			mt76_dbg(&dev->mt76, MT76_DBG_TEST,
+				 "%s: invalid primary channel selection index, use 0 instead\n",
+				 __func__);
+			td->tx_pri_sel = 0;
+		}
+		pri_sel = td->tx_pri_sel;
+	}
+	mt7996_tm_set(dev, SET_ID(PRIMARY_CH), pri_sel);
+	mt7996_tm_set(dev, SET_ID(BAND), mt7996_tm_band_mapping(chan->band));
+
+	if (mt76_testmode_param_present(td, MT76_TM_ATTR_FAST_CAL)) {
+		switch (td->fast_cal) {
+		case MT76_TM_FAST_CAL_TYPE_RX:
+			mt7996_tm_set(dev, SET_ID(CAL_BITMAP), FAST_CAL_RX);
+			mt76_dbg(&dev->mt76, MT76_DBG_TEST,
+				 "%s: apply RX fast cal (skip TX cal)\n", __func__);
+			break;
+		case MT76_TM_FAST_CAL_TYPE_POWER:
+			mt7996_tm_set(dev, SET_ID(CAL_BITMAP), FAST_CAL_POWER);
+			mt76_dbg(&dev->mt76, MT76_DBG_TEST,
+				 "%s: apply power fast cal (skip DPD cal)\n", __func__);
+			break;
+		case MT76_TM_FAST_CAL_TYPE_NONE:
+		case MT76_TM_FAST_CAL_TYPE_TX:
+		default:
+			/* same as not setting any cal bitmap */
+			mt7996_tm_set(dev, SET_ID(CAL_BITMAP), FAST_CAL_NONE);
+			mt76_dbg(&dev->mt76, MT76_DBG_TEST,
+				 "%s: apply full cal\n", __func__);
+			break;
+		}
+	}
+
+	/* trigger switch channel calibration */
+	mt7996_tm_set(dev, SET_ID(CHAN_FREQ), chandef->center_freq1 * 1000);
+}
+
+static void
+mt7996_tm_tx_stop(struct mt76_phy *mphy)
+{
+	struct mt76_testmode_data *td = &mphy->test;
+	struct mt7996_phy *phy = mphy->priv;
+	struct mt7996_dev *dev = phy->dev;
+
+	mt7996_tm_set(dev, SET_ID(COMMAND), RF_CMD(STOP_TEST));
+	td->tx_pending = 0;
+}
+
+static void
+mt7996_tm_set_tx_frames(struct mt7996_phy *phy, bool en)
+{
+	struct mt76_testmode_data *td = &phy->mt76->test;
+	struct mt7996_dev *dev = phy->dev;
+
+	if (!en) {
+		/* trigger firmware to stop TX */
+		mt7996_tm_tx_stop(phy->mt76);
+		return;
+	}
+
+	mt7996_tm_set(dev, SET_ID(MAC_HEADER), td->dur << 16 | td->fc);
+	mt7996_tm_set(dev, SET_ID(SEQ_CTRL), td->seq);
+	mt7996_tm_set(dev, SET_ID(PAYLOAD), td->payload_rule << 16 | td->payload);
+
+	mt7996_tm_set(dev, SET_ID(TX_COUNT), td->tx_count);
+	mt7996_tm_set(dev, SET_ID(TX_MODE),
+		      mt7996_tm_rate_mapping(td->tx_rate_mode, RATE_MODE_TO_PHY));
+	mt7996_tm_set(dev, SET_ID(TX_RATE), td->tx_rate_idx);
+
+	if (mt76_testmode_param_present(td, MT76_TM_ATTR_TX_POWER))
+		mt7996_tm_set(dev, SET_ID(POWER), td->tx_power[0]);
+
+	if (mt76_testmode_param_present(td, MT76_TM_ATTR_TX_TIME)) {
+		mt7996_tm_set(dev, SET_ID(TX_LEN), 0);
+		mt7996_tm_set(dev, SET_ID(TX_TIME), td->tx_time);
+	} else {
+		mt7996_tm_set(dev, SET_ID(TX_LEN), td->tx_mpdu_len);
+		mt7996_tm_set(dev, SET_ID(TX_TIME), 0);
+	}
+
+	mt7996_tm_set_antenna(phy, SET_ID(TX_PATH));
+	mt7996_tm_set_antenna(phy, SET_ID(RX_PATH));
+	mt7996_tm_set(dev, SET_ID(STBC), td->tx_rate_stbc);
+	mt7996_tm_set(dev, SET_ID(ENCODE_MODE), td->tx_rate_ldpc);
+	mt7996_tm_set(dev, SET_ID(IBF_ENABLE), td->ibf);
+	mt7996_tm_set(dev, SET_ID(EBF_ENABLE), td->ebf);
+	mt7996_tm_set(dev, SET_ID(IPG), td->tx_ipg);
+	mt7996_tm_set(dev, SET_ID(GI), td->tx_rate_sgi);
+	mt7996_tm_set(dev, SET_ID(NSS), td->tx_rate_nss);
+	mt7996_tm_set(dev, SET_ID(AID_OFFSET), 0);
+	mt7996_tm_set(dev, SET_ID(PUNCTURE), td->tx_preamble_puncture);
+
+	mt7996_tm_set(dev, SET_ID(MAX_PKT_EXT), td->max_pkt_ext);
+	mt7996_tm_set(dev, SET_ID(HW_TX_MODE), 0);
+	if (!td->bf_en)
+		mt7996_tm_update_channel(phy);
+
+	/* trigger firmware to start TX */
+	mt7996_tm_set(dev, SET_ID(COMMAND), RF_CMD(START_TX));
+}
+
+static int
+mt7996_tm_rx_stats_user_ctrl(struct mt7996_phy *phy, u16 user_idx)
+{
+	struct mt7996_dev *dev = phy->dev;
+	struct mt7996_tm_rx_req req = {
+		.band = phy->mt76->band_idx,
+		.user_ctrl = {
+			.tag = cpu_to_le16(UNI_TM_RX_STAT_SET_USER_CTRL),
+			.len = cpu_to_le16(sizeof(req.user_ctrl)),
+			.band_idx = phy->mt76->band_idx,
+			.user_idx = cpu_to_le16(user_idx),
+		},
+	};
+
+	return mt76_mcu_send_msg(&dev->mt76, MCU_WM_UNI_CMD(TESTMODE_RX_STAT), &req,
+				 sizeof(req), false);
+}
+
+static void
+mt7996_tm_set_rx_frames(struct mt7996_phy *phy, bool en)
+{
+#define RX_MU_DISABLE	0xf800
+	struct mt76_testmode_data *td = &phy->mt76->test;
+	struct mt7996_dev *dev = phy->dev;
+	u8 own_mac[ETH_ALEN] = {0};
+	int ret;
+
+	if (!en) {
+		/* trigger firmware to stop RX */
+		mt7996_tm_set(dev, SET_ID(COMMAND), RF_CMD(STOP_TEST));
+		return;
+	}
+
+	ret = mt7996_tm_rx_stats_user_ctrl(phy, td->aid);
+	if (ret) {
+		mt76_err(&dev->mt76, "%s: failed to set RX stats user control (%d)\n",
+			 __func__, ret);
+		return;
+	}
+
+	if (td->tx_rate_mode >= MT76_TM_TX_MODE_HE_MU)
+		mt7996_tm_set(dev, SET_ID(RX_MU_AID), td->aid ?: RX_MU_DISABLE);
+
+	mt7996_tm_set(dev, SET_ID(TX_MODE),
+		      mt7996_tm_rate_mapping(td->tx_rate_mode, RATE_MODE_TO_PHY));
+	mt7996_tm_set(dev, SET_ID(GI), td->tx_rate_sgi);
+	mt7996_tm_set_antenna(phy, SET_ID(TX_PATH));
+	mt7996_tm_set_antenna(phy, SET_ID(RX_PATH));
+	mt7996_tm_set(dev, SET_ID(MAX_PKT_EXT), td->max_pkt_ext);
+
+	if (td->bf_en)
+		memcpy(own_mac, td->addr[1], ETH_ALEN);
+	mt7996_tm_set_mac_addr(dev, own_mac, SET_ID(SA));
+
+	/* trigger firmware to start RX */
+	mt7996_tm_set(dev, SET_ID(COMMAND), RF_CMD(START_RX));
+}
+
+static void
+mt7996_tm_set_tx_cont(struct mt7996_phy *phy, bool en)
+{
+#define CONT_WAVE_MODE_OFDM	3
+	struct mt76_testmode_data *td = &phy->mt76->test;
+	struct mt7996_dev *dev = phy->dev;
+	u16 antenna = phy->mt76->chainmask;
+
+	if (!en) {
+		/* trigger firmware to stop CONT TX */
+		mt7996_tm_set(dev, SET_ID(COMMAND), RF_CMD(STOP_TEST));
+		return;
+	}
+
+	mt7996_tm_update_channel(phy);
+	mt7996_tm_set(dev, SET_ID(TX_MODE),
+		      mt7996_tm_rate_mapping(td->tx_rate_mode, RATE_MODE_TO_PHY));
+	mt7996_tm_set(dev, SET_ID(TX_RATE), td->tx_rate_idx);
+	/* fix payload is OFDM */
+	mt7996_tm_set(dev, SET_ID(CONT_WAVE_MODE), CONT_WAVE_MODE_OFDM);
+	if (mt76_testmode_param_present(td, MT76_TM_ATTR_TX_ANTENNA))
+		antenna = td->tx_antenna_mask;
+	mt7996_tm_set(dev, SET_ID(ANT_MASK), antenna);
+
+	/* trigger firmware to start CONT TX */
+	mt7996_tm_set(dev, SET_ID(COMMAND), RF_CMD(CONT_WAVE));
+}
+
+static void
+mt7996_tm_set_tx_tone(struct mt7996_phy *phy, bool en)
+{
+	struct cfg80211_chan_def *chandef = &phy->mt76->chandef;
+	struct mt76_testmode_data *td = &phy->mt76->test;
+	struct mt7996_dev *dev = phy->dev;
+	u16 antenna = phy->mt76->chainmask;
+	u32 dc_offset = 0;
+
+	if (!en) {
+		/* trigger firmware to stop TX tone */
+		mt7996_tm_set(dev, SET_ID(COMMAND), RF_CMD(STOP_TEST));
+		return;
+	}
+
+	if (mt76_testmode_param_present(td, MT76_TM_ATTR_TX_ANTENNA))
+		antenna = td->tx_antenna_mask;
+	mt7996_tm_set(dev, SET_ID(ANT_MASK), antenna);
+	mt7996_tm_set(dev, SET_ID(BAND), mt7996_tm_band_mapping(chandef->chan->band));
+	mt7996_tm_set(dev, SET_ID(TX_TONE_TYPE), td->tone.type);
+	mt7996_tm_set(dev, SET_ID(TX_TONE_BW), td->tone.bw);
+
+	dc_offset |= u32_encode_bits(td->tone.dc_offset[DATA_TYPE_Q], GENMASK(31, 16)) |
+		     u32_encode_bits(td->tone.dc_offset[DATA_TYPE_I], GENMASK(15, 0));
+	mt7996_tm_set(dev, SET_ID(TX_TONE_DC_OFFSET), dc_offset);
+
+	/* trigger firmware to start TX tone */
+	mt7996_tm_set(dev, SET_ID(COMMAND), RF_CMD(TX_TONE));
+}
+
+static int
+mt7996_tm_group_prek(struct mt7996_phy *phy, enum mt76_testmode_state state)
+{
+	struct mt7996_dev *dev = phy->dev;
+	struct mt76_dev *mdev = &dev->mt76;
+	struct mt7996_tm_req req = {
+		.rf_test = {
+			.tag = cpu_to_le16(UNI_RF_TEST_CTRL),
+			.len = cpu_to_le16(sizeof(req.rf_test)),
+			.action = RF_ACTION_IN_RF_TEST,
+			.icap_len = RF_TEST_ICAP_LEN,
+			.op.rf.func_idx = cpu_to_le32(RF_TEST_RE_CAL),
+			.op.rf.param.cal_param.func_data = cpu_to_le32(RF_PRE_CAL),
+			.op.rf.param.cal_param.band_idx = phy->mt76->band_idx,
+		},
+	};
+	u32 group_size, dpd_size, size, offs, *pre_cal;
+	u8 *eeprom, do_precal;
+	int ret = 0;
+
+	if (!dev->flash_mode) {
+		mt76_err(&dev->mt76, "%s: currently not in FLASH or BIN FILE mode, return\n",
+			 __func__);
+		return -EOPNOTSUPP;
+	}
+
+	eeprom = mdev->eeprom.data;
+	dev->cur_prek_offset = 0;
+	group_size = MT_EE_CAL_GROUP_SIZE;
+	dpd_size = MT_EE_CAL_DPD_SIZE;
+	size = group_size + dpd_size;
+	offs = MT_EE_DO_PRE_CAL;
+	do_precal = (MT_EE_WIFI_CAL_GROUP_2G * !!PREK(GROUP_SIZE_2G)) |
+		    (MT_EE_WIFI_CAL_GROUP_5G * !!PREK(GROUP_SIZE_5G)) |
+		    (MT_EE_WIFI_CAL_GROUP_6G * !!PREK(GROUP_SIZE_6G));
+
+	switch (state) {
+	case MT76_TM_STATE_GROUP_PREK:
+		if (!dev->cal.data) {
+			dev->cal.data = devm_kzalloc(mdev->dev, size, GFP_KERNEL);
+			if (!dev->cal.data)
+				return -ENOMEM;
+
+			dev->cal.size = size;
+		}
+
+		ret = mt76_mcu_send_msg(&dev->mt76, MCU_WM_UNI_CMD(TESTMODE_CTRL), &req,
+					sizeof(req), false);
+		wait_event_timeout(mdev->mcu.wait, dev->cur_prek_offset == group_size,
+				   30 * HZ);
+
+		if (ret)
+			mt76_err(&dev->mt76, "%s: failed to send mcu msg (%d)\n",
+				 __func__, ret);
+		else
+			eeprom[offs] |= do_precal;
+		break;
+	case MT76_TM_STATE_GROUP_PREK_CLEAN:
+		pre_cal = (u32 *)dev->cal.data;
+		if (!pre_cal)
+			return ret;
+		memset(pre_cal, 0, group_size);
+		eeprom[offs] &= ~MT_EE_WIFI_CAL_GROUP;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return ret;
+}
+
+static int
+mt7996_tm_dpd_prek_send_req(struct mt7996_phy *phy, struct mt7996_tm_req *req,
+			    const struct ieee80211_channel *chan_list, u32 channel_size,
+			    enum nl80211_chan_width width, u32 func_data)
+{
+	struct mt7996_dev *dev = phy->dev;
+	struct mt76_phy *mphy = phy->mt76;
+	struct cfg80211_chan_def chandef_backup, *chandef = &mphy->chandef;
+	struct ieee80211_channel chan_backup;
+	int i, ret, skip_ch_num = DPD_CH_NUM(BW20_5G_SKIP);
+
+	if (!chan_list)
+		return -EOPNOTSUPP;
+	if (!channel_size)
+		return 0;
+
+	req->rf_test.op.rf.param.cal_param.func_data = cpu_to_le32(func_data);
+
+	memcpy(&chan_backup, chandef->chan, sizeof(struct ieee80211_channel));
+	memcpy(&chandef_backup, chandef, sizeof(struct cfg80211_chan_def));
+
+	for (i = 0; i < channel_size; i++) {
+		if (chan_list[i].band == NL80211_BAND_5GHZ &&
+		    chan_list[i].hw_value >= dpd_5g_skip_ch_list[0].hw_value &&
+		    chan_list[i].hw_value <= dpd_5g_skip_ch_list[skip_ch_num - 1].hw_value)
+			continue;
+
+		memcpy(chandef->chan, &chan_list[i], sizeof(struct ieee80211_channel));
+		chandef->center_freq1 = chandef->chan->center_freq;
+		chandef->width = width;
+
+		/* set channel switch reason */
+		mphy->offchannel = true;
+		mt7996_mcu_set_chan_info(phy, UNI_CHANNEL_SWITCH);
+
+		ret = mt76_mcu_send_msg(&dev->mt76, MCU_WM_UNI_CMD(TESTMODE_CTRL), req,
+					sizeof(*req), false);
+		if (ret) {
+			mt76_err(&dev->mt76, "%s: failed to send mcu msg (%d)\n",
+				 __func__, ret);
+			goto out;
+		}
+	}
+
+out:
+	mphy->offchannel = false;
+	memcpy(chandef, &chandef_backup, sizeof(struct cfg80211_chan_def));
+	memcpy(chandef->chan, &chan_backup, sizeof(struct ieee80211_channel));
+	mt7996_mcu_set_chan_info(phy, UNI_CHANNEL_SWITCH);
+
+	return ret;
+}
+
+static int
+mt7996_tm_dpd_prek(struct mt7996_phy *phy, enum mt76_testmode_state state)
+{
+	struct mt7996_dev *dev = phy->dev;
+	struct mt76_dev *mdev = &dev->mt76;
+	struct mt76_phy *mphy = phy->mt76;
+	struct mt7996_tm_req req = {
+		.rf_test = {
+			.tag = cpu_to_le16(UNI_RF_TEST_CTRL),
+			.len = cpu_to_le16(sizeof(req.rf_test)),
+			.action = RF_ACTION_IN_RF_TEST,
+			.icap_len = RF_TEST_ICAP_LEN,
+			.op.rf.func_idx = cpu_to_le32(RF_TEST_RE_CAL),
+			.op.rf.param.cal_param.band_idx = mphy->band_idx,
+		},
+	};
+	u32 group_size, dpd_size, size, offs, *pre_cal;
+	u32 func_data, wait_on_prek_offset = 0;
+	u8 do_precal, *eeprom;
+	int ret = 0;
+
+	if (!dev->flash_mode) {
+		mt76_err(&dev->mt76, "%s: currently not in FLASH or BIN FILE mode, return\n",
+			 __func__);
+		return -EOPNOTSUPP;
+	}
+
+	eeprom = mdev->eeprom.data;
+	dev->cur_prek_offset = 0;
+	group_size = MT_EE_CAL_GROUP_SIZE;
+	dpd_size = MT_EE_CAL_DPD_SIZE;
+	size = group_size + dpd_size;
+	offs = MT_EE_DO_PRE_CAL;
+
+	if (!dev->cal.data && state < MT76_TM_STATE_DPD_CLEAN) {
+		dev->cal.data = devm_kzalloc(mdev->dev, size, GFP_KERNEL);
+		if (!dev->cal.data)
+			return -ENOMEM;
+
+		dev->cal.size = size;
+	}
+
+	switch (state) {
+	case MT76_TM_STATE_DPD_2G:
+		ret = mt7996_tm_dpd_prek_send_req(phy, &req, dpd_2g_ch_list_bw20,
+						  DPD_CH_NUM(BW20_2G),
+						  NL80211_CHAN_WIDTH_20, RF_DPD_FLAT_CAL);
+		wait_on_prek_offset += DPD_CH_NUM(BW20_2G) * DPD_PER_CH_BW20_SIZE;
+		wait_event_timeout(mdev->mcu.wait, dev->cur_prek_offset == wait_on_prek_offset,
+				   30 * HZ);
+
+		do_precal = MT_EE_WIFI_CAL_DPD_2G;
+		break;
+	case MT76_TM_STATE_DPD_5G:
+		/* 5g channel bw20 calibration */
+		ret = mt7996_tm_dpd_prek_send_req(phy, &req, mphy->sband_5g.sband.channels,
+						  mphy->sband_5g.sband.n_channels,
+						  NL80211_CHAN_WIDTH_20, RF_DPD_FLAT_5G_CAL);
+		if (ret)
+			return ret;
+		wait_on_prek_offset += DPD_CH_NUM(BW20_5G) * DPD_PER_CH_BW20_SIZE;
+		wait_event_timeout(mdev->mcu.wait, dev->cur_prek_offset == wait_on_prek_offset,
+				   30 * HZ);
+
+		/* griffin does not support mem dpd cal */
+		func_data = PREK(DPD_MEM_SIZE) ? RF_DPD_FLAT_5G_MEM_CAL : RF_DPD_FLAT_5G_CAL;
+
+		/* 5g channel bw80 calibration */
+		ret = mt7996_tm_dpd_prek_send_req(phy, &req, dpd_5g_ch_list_bw80,
+						  DPD_CH_NUM(BW80_5G),
+						  NL80211_CHAN_WIDTH_80, func_data);
+		if (ret)
+			return ret;
+		wait_on_prek_offset += DPD_CH_NUM(BW80_5G) * DPD_PER_CH_GT_BW20_SIZE;
+		wait_event_timeout(mdev->mcu.wait, dev->cur_prek_offset == wait_on_prek_offset,
+				   30 * HZ);
+
+		/* 5g channel bw160 calibration */
+		ret = mt7996_tm_dpd_prek_send_req(phy, &req, dpd_5g_ch_list_bw160,
+						  DPD_CH_NUM(BW160_5G),
+						  NL80211_CHAN_WIDTH_160, func_data);
+		wait_on_prek_offset += DPD_CH_NUM(BW160_5G) * DPD_PER_CH_GT_BW20_SIZE;
+		wait_event_timeout(mdev->mcu.wait, dev->cur_prek_offset == wait_on_prek_offset,
+				   30 * HZ);
+
+		do_precal = MT_EE_WIFI_CAL_DPD_5G;
+		break;
+	case MT76_TM_STATE_DPD_6G:
+		/* 6g channel bw20 calibration */
+		ret = mt7996_tm_dpd_prek_send_req(phy, &req, mphy->sband_6g.sband.channels,
+						  mphy->sband_6g.sband.n_channels,
+						  NL80211_CHAN_WIDTH_20, RF_DPD_FLAT_6G_CAL);
+		if (ret)
+			return ret;
+		wait_on_prek_offset += DPD_CH_NUM(BW20_6G) * DPD_PER_CH_BW20_SIZE;
+		wait_event_timeout(mdev->mcu.wait, dev->cur_prek_offset == wait_on_prek_offset,
+				   30 * HZ);
+
+		/* griffin does not support mem dpd cal */
+		func_data = PREK(DPD_MEM_SIZE) ? RF_DPD_FLAT_6G_MEM_CAL : RF_DPD_FLAT_6G_CAL;
+
+		/* 6g channel bw80 calibration */
+		ret = mt7996_tm_dpd_prek_send_req(phy, &req, dpd_6g_ch_list_bw80,
+						  DPD_CH_NUM(BW80_6G),
+						  NL80211_CHAN_WIDTH_80, func_data);
+		if (ret)
+			return ret;
+		wait_on_prek_offset += DPD_CH_NUM(BW80_6G) * DPD_PER_CH_GT_BW20_SIZE;
+		wait_event_timeout(mdev->mcu.wait, dev->cur_prek_offset == wait_on_prek_offset,
+				   30 * HZ);
+
+		/* 6g channel bw160 calibration */
+		ret = mt7996_tm_dpd_prek_send_req(phy, &req, dpd_6g_ch_list_bw160,
+						  DPD_CH_NUM(BW160_6G),
+						  NL80211_CHAN_WIDTH_160, func_data);
+		if (ret)
+			return ret;
+		wait_on_prek_offset += DPD_CH_NUM(BW160_6G) * DPD_PER_CH_GT_BW20_SIZE;
+		wait_event_timeout(mdev->mcu.wait, dev->cur_prek_offset == wait_on_prek_offset,
+				   30 * HZ);
+
+		/* 6g channel bw320 calibration */
+		ret = mt7996_tm_dpd_prek_send_req(phy, &req, dpd_6g_ch_list_bw320,
+						  DPD_CH_NUM(BW320_6G),
+						  NL80211_CHAN_WIDTH_320, func_data);
+		wait_on_prek_offset += DPD_CH_NUM(BW320_6G) * DPD_PER_CH_GT_BW20_SIZE;
+		wait_event_timeout(mdev->mcu.wait, dev->cur_prek_offset == wait_on_prek_offset,
+				   30 * HZ);
+
+		do_precal = MT_EE_WIFI_CAL_DPD_6G;
+		break;
+	case MT76_TM_STATE_DPD_CLEAN:
+		pre_cal = (u32 *)dev->cal.data;
+		if (!pre_cal)
+			return ret;
+		memset(pre_cal + (group_size / sizeof(u32)), 0, dpd_size);
+		do_precal = MT_EE_WIFI_CAL_DPD;
+		eeprom[offs] &= ~do_precal;
+		return 0;
+	default:
+		return -EINVAL;
+	}
+
+	if (!ret)
+		eeprom[offs] |= do_precal;
+
+	return ret;
+}
+
+static int
+mt7996_tm_dump_precal(struct mt76_phy *mphy, struct sk_buff *msg, int flag, int type)
+{
+#define DPD_PER_CHAN_SIZE_MASK		GENMASK(31, 30)
+#define DPD_2G_RATIO_MASK		GENMASK(29, 20)
+#define DPD_5G_RATIO_MASK		GENMASK(19, 10)
+#define DPD_6G_RATIO_MASK		GENMASK(9, 0)
+	struct mt7996_phy *phy = mphy->priv;
+	struct mt7996_dev *dev = phy->dev;
+	u32 i, group_size, dpd_size, total_size, size, dpd_info = 0;
+	u32 dpd_size_2g, dpd_size_5g, dpd_size_6g;
+	u32 base, offs, transmit_size = 1000;
+	u8 *pre_cal, *eeprom;
+	void *precal;
+	enum prek_ops {
+		PREK_GET_INFO,
+		PREK_SYNC_ALL,
+		PREK_SYNC_GROUP,
+		PREK_SYNC_DPD_2G,
+		PREK_SYNC_DPD_5G,
+		PREK_SYNC_DPD_6G,
+		PREK_CLEAN_GROUP,
+		PREK_CLEAN_DPD,
+	};
+
+	if (!dev->cal.data) {
+		mt76_err(&dev->mt76, "%s: no pre-cal found\n", __func__);
+		return 0;
+	}
+
+	group_size = MT_EE_CAL_GROUP_SIZE;
+	dpd_size = MT_EE_CAL_DPD_SIZE;
+	total_size = group_size + dpd_size;
+	pre_cal = dev->cal.data;
+	eeprom = dev->mt76.eeprom.data;
+	offs = MT_EE_DO_PRE_CAL;
+
+	dpd_size_2g = MT_EE_CAL_DPD_SIZE_2G;
+	dpd_size_5g = MT_EE_CAL_DPD_SIZE_5G;
+	dpd_size_6g = MT_EE_CAL_DPD_SIZE_6G;
+
+	switch (type) {
+	case PREK_SYNC_ALL:
+		base = 0;
+		size = total_size;
+		break;
+	case PREK_SYNC_GROUP:
+		base = 0;
+		size = group_size;
+		break;
+	case PREK_SYNC_DPD_2G:
+		base = group_size;
+		size = dpd_size_2g;
+		break;
+	case PREK_SYNC_DPD_5G:
+		base = group_size + dpd_size_2g;
+		size = dpd_size_5g;
+		break;
+	case PREK_SYNC_DPD_6G:
+		base = group_size + dpd_size_2g + dpd_size_5g;
+		size = dpd_size_6g;
+		break;
+	case PREK_GET_INFO:
+		break;
+	default:
+		return 0;
+	}
+
+	if (!flag) {
+		if (eeprom[offs] & MT_EE_WIFI_CAL_DPD) {
+			dpd_info |= u32_encode_bits(1, DPD_PER_CHAN_SIZE_MASK) |
+				    u32_encode_bits(dpd_size_2g / MT_EE_CAL_UNIT,
+						    DPD_2G_RATIO_MASK) |
+				    u32_encode_bits(dpd_size_5g / MT_EE_CAL_UNIT,
+						    DPD_5G_RATIO_MASK) |
+				    u32_encode_bits(dpd_size_6g / MT_EE_CAL_UNIT,
+						    DPD_6G_RATIO_MASK);
+		}
+		dev->cur_prek_offset = 0;
+		precal = nla_nest_start(msg, MT76_TM_ATTR_PRECAL_INFO);
+		if (!precal)
+			return -ENOMEM;
+		nla_put_u32(msg, 0, group_size);
+		nla_put_u32(msg, 1, dpd_size);
+		nla_put_u32(msg, 2, dpd_info);
+		nla_put_u32(msg, 3, transmit_size);
+		nla_put_u32(msg, 4, eeprom[offs]);
+		nla_nest_end(msg, precal);
+	} else {
+		precal = nla_nest_start(msg, MT76_TM_ATTR_PRECAL);
+		if (!precal)
+			return -ENOMEM;
+
+		transmit_size = (dev->cur_prek_offset + transmit_size < size) ?
+				transmit_size : (size - dev->cur_prek_offset);
+		for (i = 0; i < transmit_size; i++) {
+			if (nla_put_u8(msg, i, pre_cal[base + dev->cur_prek_offset + i]))
+				return -ENOMEM;
+		}
+		dev->cur_prek_offset += transmit_size;
+
+		nla_nest_end(msg, precal);
+	}
+
+	return 0;
+}
+
+static int
+mt7996_tm_rx_gain_cal(struct mt7996_phy *phy, enum mt76_testmode_state state)
+{
+	struct mt7996_dev *dev = phy->dev;
+	struct mt76_phy *mphy = phy->mt76;
+	struct mt7996_tm_req req = {
+		.rf_test = {
+			.tag = cpu_to_le16(UNI_RF_TEST_CTRL),
+			.len = cpu_to_le16(sizeof(req.rf_test)),
+			.action = RF_ACTION_IN_RF_TEST,
+			.icap_len = RF_TEST_ICAP_LEN,
+			.op.rf.func_idx = cpu_to_le32(RF_TEST_RX_GAIN_CAL),
+			.op.rf.param.cal_param.func_data = cpu_to_le32(RF_RX_GAIN_CAL),
+			.op.rf.param.cal_param.band_idx = mphy->band_idx,
+		},
+	};
+	u8 *eeprom = dev->mt76.eeprom.data;
+	u32 i, j, size, *cal;
+	int ret = 0;
+
+	if (!dev->flash_mode) {
+		mt76_err(&dev->mt76, "%s: currently not in FLASH or BIN FILE mode, return\n",
+			 __func__);
+		return -EOPNOTSUPP;
+	}
+
+	dev->cur_prek_offset = 0;
+	size = MT_EE_CAL_RX_GAIN_SIZE;
+
+	switch (state) {
+	case MT76_TM_STATE_RX_GAIN_CAL:
+		ret = mt76_mcu_send_msg(&dev->mt76, MCU_WM_UNI_CMD(TESTMODE_CTRL), &req,
+					sizeof(req), false);
+		if (ret) {
+			mt76_err(&dev->mt76, "%s: failed to send mcu msg (%d)\n",
+				 __func__, ret);
+			return ret;
+		}
+
+		wait_event_timeout(dev->mt76.mcu.wait, dev->cur_prek_offset == size, 30 * HZ);
+		break;
+	case MT76_TM_STATE_RX_GAIN_CAL_DUMP:
+		cal = (u32 *)eeprom;
+		mt76_dbg(&dev->mt76, MT76_DBG_TEST, "RX Gain Cal:\n");
+		for (i = 0; i < (size / sizeof(u32)); i += 4) {
+			j = MT_EE_RX_GAIN_CAL / sizeof(u32) + i;
+			mt76_dbg(&dev->mt76, MT76_DBG_TEST,
+				 "[0x%08lx] 0x%8x 0x%8x 0x%8x 0x%8x\n",
+				 j * sizeof(u32), cal[j], cal[j + 1],
+				 cal[j + 2], cal[j + 3]);
+		}
+		break;
+	case MT76_TM_STATE_RX_GAIN_CAL_CLEAN:
+		memset(eeprom + MT_EE_RX_GAIN_CAL, 0, size);
+		eeprom[MT_EE_DO_RX_GAIN_CAL] &= ~u8_encode_bits(GENMASK(2, 0),
+								MT_EE_WIFI_CAL_RX_GAIN);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static void
+mt7996_tm_re_cal_event(struct mt7996_dev *dev, struct mt7996_tm_rf_test_data *data, u32 len)
+{
+	u32 base, cal_idx, cal_type;
+	u8 *cal = dev->cal.data;
+
+	cal_idx = le32_to_cpu(data->cal_idx);
+	cal_type = le32_to_cpu(data->cal_type);
+
+	switch (cal_type) {
+	case RF_RX_GAIN_CAL:
+		cal = dev->mt76.eeprom.data;
+		base = MT_EE_RX_GAIN_CAL;
+		break;
+	case RF_PRE_CAL:
+		base = 0;
+		break;
+	case RF_DPD_FLAT_CAL:
+		base = MT_EE_CAL_GROUP_SIZE;
+		break;
+	case RF_DPD_FLAT_5G_CAL:
+	case RF_DPD_FLAT_5G_MEM_CAL:
+		base = MT_EE_CAL_GROUP_SIZE + MT_EE_CAL_DPD_SIZE_2G;
+		break;
+	case RF_DPD_FLAT_6G_CAL:
+	case RF_DPD_FLAT_6G_MEM_CAL:
+		base = MT_EE_CAL_GROUP_SIZE + MT_EE_CAL_DPD_SIZE_2G +
+		       MT_EE_CAL_DPD_SIZE_5G;
+		break;
+	default:
+		mt76_err(&dev->mt76, "%s: unknown calibration type %x\n",
+			 __func__, cal_type);
+		return;
+	}
+
+	memcpy(cal + base + dev->cur_prek_offset, data->cal_data, len);
+	dev->cur_prek_offset += len;
+	wake_up(&dev->mt76.mcu.wait);
+}
+
+void mt7996_tm_rf_test_event(struct mt7996_dev *dev, struct sk_buff *skb)
+{
+	struct mt7996_tm_event *event;
+	struct mt7996_tm_rf_test_result *result;
+	struct mt7996_tm_rf_test_data *data;
+	u32 event_type, len;
+
+	skb_pull(skb, sizeof(struct mt7996_mcu_rxd));
+	event = (struct mt7996_tm_event *)skb->data;
+	result = (struct mt7996_tm_rf_test_result *)&event->result;
+	data = (struct mt7996_tm_rf_test_data *)result->data;
+
+	event_type = le32_to_cpu(result->func_idx);
+	len = le32_to_cpu(result->payload_length) - sizeof(struct mt7996_tm_rf_test_data);
+
+	switch (event_type) {
+	case RF_TEST_RE_CAL:
+		mt7996_tm_re_cal_event(dev, data, len);
+		break;
+	default:
+		break;
+	}
+}
+
+static u8
+mt7996_tm_get_center_chan(struct mt7996_phy *phy, struct cfg80211_chan_def *chandef)
+{
+	struct mt76_phy *mphy = phy->mt76;
+	const struct ieee80211_channel *chan = mphy->sband_5g.sband.channels;
+	u32 bitmap, i, offset, width_mhz, size = mphy->sband_5g.sband.n_channels;
+	u16 first_control = 0, control_chan = chandef->chan->hw_value;
+	bool not_first;
+
+	bitmap = mt7996_tm_bw_mapping(chandef->width, BW_MAP_NL_TO_CONTROL_BITMAP_5G);
+	if (!bitmap)
+		return control_chan;
+
+	width_mhz = mt7996_tm_bw_mapping(chandef->width, BW_MAP_NL_TO_MHZ);
+	offset = width_mhz / 10 - 2;
+
+	for (i = 0; i < size; i++) {
+		not_first = (chandef->width != NL80211_CHAN_WIDTH_160) ?
+			    (i % bitmap) : (i >= 32) || !((1 << i) & bitmap);
+		if (not_first)
+			continue;
+
+		if (control_chan >= chan[i].hw_value)
+			first_control = chan[i].hw_value;
+		else
+			break;
+	}
+
+	if (first_control == 0)
+		return control_chan;
+
+	return first_control + offset;
+}
+
+static int
+mt7996_tm_set_offchan(struct mt7996_phy *phy, bool no_center)
+{
+	struct mt76_phy *mphy = phy->mt76;
+	struct mt7996_dev *dev = phy->dev;
+	struct ieee80211_hw *hw = mphy->hw;
+	struct mt76_testmode_data *td = &phy->mt76->test;
+	struct cfg80211_chan_def chandef = {};
+	struct ieee80211_channel *chan;
+	int ret, freq = ieee80211_channel_to_frequency(td->offchan_ch, NL80211_BAND_5GHZ);
+
+	if (!mphy->cap.has_5ghz || !freq) {
+		ret = -EINVAL;
+		mt76_err(&dev->mt76, "%s: failed to set offchan (invalid band or channel)\n",
+			 __func__);
+		goto out;
+	}
+
+	chandef.width = td->offchan_bw;
+	chan = ieee80211_get_channel(hw->wiphy, freq);
+	chandef.chan = chan;
+	if (no_center)
+		td->offchan_center_ch = mt7996_tm_get_center_chan(phy, &chandef);
+	chandef.center_freq1 = ieee80211_channel_to_frequency(td->offchan_center_ch,
+							      NL80211_BAND_5GHZ);
+	if (!cfg80211_chandef_valid(&chandef)) {
+		ret = -EINVAL;
+		mt76_err(&dev->mt76, "%s: failed to set offchan (invalid chandef)\n",
+			 __func__);
+		goto out;
+	}
+
+	memset(&dev->rdd2_chandef, 0, sizeof(struct cfg80211_chan_def));
+
+	ret = mt7996_mcu_rdd_background_enable(phy, &chandef);
+
+	if (ret)
+		goto out;
+
+	dev->rdd2_phy = phy;
+	dev->rdd2_chandef = chandef;
+
+	return 0;
+
+out:
+	td->offchan_ch = 0;
+	td->offchan_center_ch = 0;
+	td->offchan_bw = 0;
+
+	return ret;
+}
+
+static void
+mt7996_tm_ipi_hist_ctrl(struct mt7996_phy *phy, struct mt7996_tm_rdd_ipi_ctrl *data, u8 cmd)
+{
+#define MT_IPI_RESET		0x830a5dfc
+#define MT_IPI_RESET_MASK	BIT(28)
+#define MT_IPI_COUNTER_BASE	0x83041000
+#define MT_IPI_COUNTER(idx)	(MT_IPI_COUNTER_BASE + ((idx) * 4))
+	struct mt7996_dev *dev = phy->dev;
+	bool val;
+	int i;
+
+	if (cmd == RDD_SET_IPI_HIST_RESET) {
+		val = mt76_rr(dev, MT_IPI_RESET) & MT_IPI_RESET_MASK;
+		mt76_rmw_field(dev, MT_IPI_RESET, MT_IPI_RESET_MASK, !val);
+		return;
+	}
+
+	for (i = 0; i < POWER_INDICATE_HIST_MAX; i++)
+		data->ipi_hist_val[i] = mt76_rr(dev, MT_IPI_COUNTER(i));
+}
+
+static void
+mt7996_tm_ipi_work(struct work_struct *work)
+{
+#define PRECISION	100
+	struct mt7996_phy *phy = container_of(work, struct mt7996_phy, ipi_work.work);
+	struct mt7996_dev *dev = phy->dev;
+	struct mt76_testmode_data *td = &phy->mt76->test;
+	struct mt7996_tm_rdd_ipi_ctrl data;
+	u32 ipi_idx, ipi_free_count, ipi_percentage;
+	u32 ipi_hist_count_th = 0, ipi_hist_total_count = 0;
+	u32 self_idle_ratio, ipi_idle_ratio, channel_load;
+	u32 *ipi_hist_data;
+	const char *power_lower_bound, *power_upper_bound;
+	static const char * const ipi_idx_to_power_bound[] = {
+		[RDD_IPI_HIST_0] = "-92",
+		[RDD_IPI_HIST_1] = "-89",
+		[RDD_IPI_HIST_2] = "-86",
+		[RDD_IPI_HIST_3] = "-83",
+		[RDD_IPI_HIST_4] = "-80",
+		[RDD_IPI_HIST_5] = "-75",
+		[RDD_IPI_HIST_6] = "-70",
+		[RDD_IPI_HIST_7] = "-65",
+		[RDD_IPI_HIST_8] = "-60",
+		[RDD_IPI_HIST_9] = "-55",
+		[RDD_IPI_HIST_10] = "inf",
+	};
+
+	memset(&data, 0, sizeof(data));
+	mt7996_tm_ipi_hist_ctrl(phy, &data, RDD_IPI_HIST_ALL_CNT);
+
+	ipi_hist_data = data.ipi_hist_val;
+	for (ipi_idx = 0; ipi_idx < POWER_INDICATE_HIST_MAX; ipi_idx++) {
+		power_lower_bound = ipi_idx ? ipi_idx_to_power_bound[ipi_idx - 1] : "-inf";
+		power_upper_bound = ipi_idx_to_power_bound[ipi_idx];
+
+		mt76_dbg(&dev->mt76, MT76_DBG_TEST,
+			 "IPI %d (power range: (%s, %s] dBm): ipi count = %d\n",
+			 ipi_idx, power_lower_bound, power_upper_bound,
+			 ipi_hist_data[ipi_idx]);
+
+		if (td->ipi_threshold <= ipi_idx && ipi_idx <= RDD_IPI_HIST_10)
+			ipi_hist_count_th += ipi_hist_data[ipi_idx];
+
+		ipi_hist_total_count += ipi_hist_data[ipi_idx];
+	}
+
+	ipi_free_count = ipi_hist_data[RDD_IPI_FREE_RUN_CNT];
+
+	mt76_dbg(&dev->mt76, MT76_DBG_TEST,
+		 "IPI threshold %d: ipi_hist_count_th = %d, ipi_free_count = %d\n",
+		 td->ipi_threshold, ipi_hist_count_th, ipi_free_count);
+	mt76_dbg(&dev->mt76, MT76_DBG_TEST, "TX assert time =  %d [ms]\n",
+		 data.tx_assert_time / 1000);
+
+	/* calculate channel load = (self idle ratio - idle ratio) / self idle ratio */
+	if (ipi_hist_count_th >= UINT_MAX / (100 * PRECISION))
+		ipi_percentage = 100 * PRECISION *
+				 (ipi_hist_count_th / (100 * PRECISION)) /
+				 (ipi_free_count / (100 * PRECISION));
+	else
+		ipi_percentage = PRECISION * 100 * ipi_hist_count_th / ipi_free_count;
+
+	ipi_idle_ratio = ((100 * PRECISION) - ipi_percentage) / PRECISION;
+
+	self_idle_ratio = PRECISION * 100 *
+			  (td->ipi_period - (data.tx_assert_time / 1000)) /
+			  td->ipi_period / PRECISION;
+
+	if (self_idle_ratio < ipi_idle_ratio)
+		channel_load = 0;
+	else
+		channel_load = self_idle_ratio - ipi_idle_ratio;
+
+	if (self_idle_ratio <= td->ipi_threshold) {
+		mt76_dbg(&dev->mt76, MT76_DBG_TEST,
+			 "band[%d]: self idle ratio = %d%%, idle ratio = %d%%\n",
+			 phy->mt76->band_idx, self_idle_ratio, ipi_idle_ratio);
+		return;
+	}
+
+	channel_load = (100 * channel_load) / self_idle_ratio;
+	mt76_dbg(&dev->mt76, MT76_DBG_TEST,
+		 "band[%d]: chan load = %d%%, self idle ratio = %d%%, idle ratio = %d%%\n",
+		 phy->mt76->band_idx, channel_load, self_idle_ratio, ipi_idle_ratio);
+}
+
+static int
+mt7996_tm_set_ipi(struct mt7996_phy *phy)
+{
+	struct mt76_testmode_data *td = &phy->mt76->test;
+
+	/* reset IPI CR */
+	mt7996_tm_ipi_hist_ctrl(phy, NULL, RDD_SET_IPI_HIST_RESET);
+
+	cancel_delayed_work(&phy->ipi_work);
+	ieee80211_queue_delayed_work(phy->mt76->hw, &phy->ipi_work,
+				     msecs_to_jiffies(td->ipi_period));
+
+	return 0;
+}
+
+static int
+mt7996_tm_set_trx_mac(struct mt7996_phy *phy, u8 type, bool en)
+{
+#define UNI_TM_TRX_CTRL 0
+	struct mt7996_dev *dev = phy->dev;
+	struct mt7996_tm_trx_req req = {
+		.param_num = 1,
+		.tag = cpu_to_le16(UNI_TM_TRX_CTRL),
+		.len = cpu_to_le16(sizeof(req) - 4),
+		.param_idx = cpu_to_le16(TM_TRX_PARAM_SET_TRX),
+		.band_idx = phy->mt76->band_idx,
+		.testmode_en = 1,
+		.action = TM_TRX_ACTION_SET,
+		.set_trx = {
+			.type = type,
+			.enable = en,
+			.band_idx = phy->mt76->band_idx,
+		}
+	};
+
+	return mt76_mcu_send_msg(&dev->mt76, MCU_WM_UNI_CMD(TESTMODE_TRX_PARAM),
+				 &req, sizeof(req), false);
+}
+
+static void
+mt7996_tm_set_cfg(struct mt7996_phy *phy)
+{
+	struct mt76_testmode_data *td = &phy->mt76->test;
+	struct mt7996_dev *dev = phy->dev;
+	u32 func_idx = td->cfg.enable ? SET_ID(CFG_ON) : SET_ID(CFG_OFF);
+	static const u8 cfg_type[] = {
+		[MT76_TM_CFG_TYPE_TSSI] = CFG_SET_TSSI,
+		[MT76_TM_CFG_TYPE_DPD] = CFG_SET_DPD,
+		[MT76_TM_CFG_TYPE_RATE_POWER_OFFSET] = CFG_SET_RATE_POWER_OFFSET,
+		[MT76_TM_CFG_TYPE_THERMAL_COMP] = CFG_SET_THERMAL_COMP,
+		[MT76_TM_CFG_TYPE_BAND_POWER] = CFG_SET_BAND_POWER,
+		[MT76_TM_CFG_TYPE_TMAC] = CFG_SET_TMAC,
+		[MT76_TM_CFG_TYPE_RMAC] = CFG_SET_RMAC,
+	};
+
+	mt7996_tm_set(dev, func_idx, cfg_type[td->cfg.type]);
+}
+
+static int
+mt7996_tm_txbf_init(struct mt7996_phy *phy, u16 *val)
+{
+#define EBF_BBP_RX_OFFSET	0x10280
+#define EBF_BBP_RX_ENABLE	(BIT(0) | BIT(15))
+	struct mt7996_dev *dev = phy->dev;
+	struct mt76_testmode_data *td = &phy->mt76->test;
+	struct ieee80211_vif *vif = phy->mt76->monitor_vif;
+	struct mt7996_vif *mvif = (struct mt7996_vif *)vif->drv_priv;
+	struct mt7996_vif_link *deflink = &mvif->deflink;
+	enum nl80211_chan_width width = NL80211_CHAN_WIDTH_20;
+	void *phase_cal, *pfmu_data, *pfmu_tag;
+	u8 nss, band_idx = phy->mt76->band_idx;
+	u8 addr, peer_addr, bss_addr;
+	bool enable = val[0];
+
+	if (!enable) {
+		td->bf_en = false;
+		return 0;
+	}
+
+	if (!dev->test.txbf_phase_cal) {
+		phase_cal = devm_kzalloc(dev->mt76.dev,
+					 sizeof(struct mt7996_txbf_phase) *
+					 MAX_PHASE_GROUP_NUM,
+					 GFP_KERNEL);
+		if (!phase_cal)
+			return -ENOMEM;
+
+		dev->test.txbf_phase_cal = phase_cal;
+	}
+
+	if (!dev->test.txbf_pfmu_data) {
+		/* allocate max size for 5x5 pfmu data */
+		pfmu_data = devm_kzalloc(dev->mt76.dev,
+					 MT7996_TXBF_PFMU_DATA_LEN_5X5,
+					 GFP_KERNEL);
+		if (!pfmu_data)
+			return -ENOMEM;
+
+		dev->test.txbf_pfmu_data = pfmu_data;
+	}
+
+	if (!dev->test.txbf_pfmu_tag) {
+		pfmu_tag = devm_kzalloc(dev->mt76.dev,
+					sizeof(struct mt7996_pfmu_tag), GFP_KERNEL);
+		if (!pfmu_tag)
+			return -ENOMEM;
+
+		dev->test.txbf_pfmu_tag = pfmu_tag;
+	}
+
+	td->bf_en = true;
+	dev->ibf = td->ibf;
+
+	/* 00:11:11:11:11:11 for golden/instrument (own mac addr)
+	 * 00:22:22:22:22:22 for DUT (own mac addr)
+	 * 00:22:22:22:22:22 for bssid
+	 */
+	bss_addr = TXBF_DUT_MAC_SUBADDR;
+	if (td->is_txbf_dut) {
+		addr = TXBF_DUT_MAC_SUBADDR;
+		peer_addr = TXBF_GOLDEN_MAC_SUBADDR;
+	} else {
+		addr = TXBF_GOLDEN_MAC_SUBADDR;
+		peer_addr = TXBF_DUT_MAC_SUBADDR;
+	}
+	memset(td->addr, 0, sizeof(td->addr));
+	memset(td->addr[0] + 1, peer_addr, ETH_ALEN - 1);
+	memset(td->addr[1] + 1, addr, ETH_ALEN - 1);
+	memset(td->addr[2] + 1, bss_addr, ETH_ALEN - 1);
+	memcpy(vif->addr, td->addr[1], ETH_ALEN);
+	mt7996_tm_set_mac_addr(dev, td->addr[0], SET_ID(DA));
+	mt7996_tm_set_mac_addr(dev, td->addr[1], SET_ID(SA));
+	mt7996_tm_set_mac_addr(dev, td->addr[2], SET_ID(BSSID));
+
+	mt7996_mcu_add_dev_info(phy, phy->mt76->monitor_vif, &phy->mt76->monitor_vif->bss_conf, &mvif->deflink.mt76, true);
+	mt7996_mcu_add_bss_info(phy, vif, &vif->bss_conf, &deflink->mt76,
+				&deflink->msta_link, true);
+
+	if (td->ibf) {
+		if (td->is_txbf_dut) {
+			/* Enable ITxBF Capability */
+			mt7996_mcu_set_txbf(dev, BF_HW_EN_UPDATE);
+			mt7996_tm_set_trx_mac(phy, TM_TRX_MAC_TX, true);
+
+			td->tx_ipg = 999;
+			td->tx_mpdu_len = 1024;
+			td->tx_antenna_mask = phy->mt76->chainmask;
+			nss = hweight8(td->tx_antenna_mask);
+			if (nss > 1 && nss <= 4)
+				td->tx_rate_idx = 15 + 8 * (nss - 2);
+			else
+				td->tx_rate_idx = 31;
+		} else {
+			td->tx_antenna_mask = 1;
+			td->tx_mpdu_len = 1024;
+			td->tx_rate_idx = 0;
+			mt76_set(dev, EBF_BBP_RX_OFFSET, EBF_BBP_RX_ENABLE);
+			mt76_dbg(&dev->mt76, MT76_DBG_TEST,
+				 "%s: set BBP RX CR = %x\n",
+				 __func__, mt76_rr(dev, EBF_BBP_RX_OFFSET));
+		}
+
+		td->tx_rate_mode = MT76_TM_TX_MODE_HT;
+		td->tx_rate_sgi = 0;
+		/* 5T5R ibf */
+		if (nss == 5) {
+			td->tx_rate_mode = MT76_TM_TX_MODE_VHT;
+			td->tx_rate_idx = 7;
+			td->tx_rate_nss = 4;
+		}
+	} else {
+		if (td->is_txbf_dut) {
+			/* Enable ETxBF Capability */
+			mt7996_mcu_set_txbf(dev, BF_HW_EN_UPDATE);
+			td->tx_antenna_mask = phy->mt76->chainmask;
+			td->tx_spe_idx = 24 + band_idx;
+			if (td->tx_rate_mode == MT76_TM_TX_MODE_VHT ||
+			    td->tx_rate_mode == MT76_TM_TX_MODE_HE_SU)
+				mt7996_tm_set(dev, SET_ID(NSS), td->tx_rate_nss);
+
+			mt7996_tm_set(dev, SET_ID(ENCODE_MODE), td->tx_rate_ldpc);
+			mt7996_tm_set(dev, SET_ID(TX_COUNT), td->tx_count);
+		} else {
+			/* Turn On BBP CR for RX */
+			mt76_set(dev, EBF_BBP_RX_OFFSET, EBF_BBP_RX_ENABLE);
+			mt76_dbg(&dev->mt76, MT76_DBG_TEST,
+				 "%s: set BBP RX CR = %x\n",
+				 __func__, mt76_rr(dev, EBF_BBP_RX_OFFSET));
+
+			td->tx_antenna_mask = 1;
+		}
+		width = phy->mt76->chandef.width;
+
+		if (td->tx_rate_mode == MT76_TM_TX_MODE_EHT_MU)
+			td->tx_rate_mode = MT76_TM_TX_MODE_EHT_SU;
+	}
+	mt76_testmode_param_set(td, MT76_TM_ATTR_TX_ANTENNA);
+
+	mt7996_tm_set(dev, SET_ID(TX_MODE),
+		      mt7996_tm_rate_mapping(td->tx_rate_mode, RATE_MODE_TO_PHY));
+	mt7996_tm_set(dev, SET_ID(TX_RATE), td->tx_rate_idx);
+	mt7996_tm_set(dev, SET_ID(GI), td->tx_rate_sgi);
+	mt7996_tm_set(dev, SET_ID(CBW),
+		      mt7996_tm_bw_mapping(width, BW_MAP_NL_TO_FW));
+	mt7996_tm_set(dev, SET_ID(DBW),
+		      mt7996_tm_bw_mapping(width, BW_MAP_NL_TO_FW));
+	mt7996_tm_set_antenna(phy, SET_ID(TX_PATH));
+	mt7996_tm_set_antenna(phy, SET_ID(RX_PATH));
+	mt7996_tm_set(dev, SET_ID(IPG), td->tx_ipg);
+	mt7996_tm_set(dev, SET_ID(TX_LEN), td->tx_mpdu_len);
+	mt7996_tm_set(dev, SET_ID(TX_TIME), 0);
+	mt7996_tm_set(dev, SET_ID(COMMAND), RF_CMD(TX_COMMIT));
+
+	return 0;
+}
+
+static inline void
+mt7996_tm_txbf_phase_copy(struct mt7996_dev *dev, void *des, void *src, int group)
+{
+	int phase_size;
+
+	if (group && get_ibf_version(dev) == IBF_VER_1)
+		phase_size = sizeof(struct mt7996_txbf_phase_info_5g);
+	else if (get_ibf_version(dev) == IBF_VER_1)
+		phase_size = sizeof(struct mt7996_txbf_phase_info_2g);
+	else if (group)
+		phase_size = sizeof(struct mt7992_txbf_phase_info_5g);
+	else
+		phase_size = sizeof(struct mt7992_txbf_phase_info_2g);
+
+	memcpy(des, src, phase_size);
+}
+
+static int
+mt7996_tm_txbf_phase_comp(struct mt7996_phy *phy, u16 *val)
+{
+	struct mt7996_dev *dev = phy->dev;
+	struct mt7996_tm_bf_req req = {
+		.phase_comp = {
+			.tag = cpu_to_le16(BF_IBF_PHASE_COMP),
+			.len = cpu_to_le16(sizeof(req.phase_comp)),
+			.bw = val[0],
+			.jp_band = (val[2] == 1) ? 1 : 0,
+			.band_idx = phy->mt76->band_idx,
+			.read_from_e2p = val[3],
+			.disable = val[4],
+			.group = val[2],
+		}
+	};
+	struct mt7996_txbf_phase *phase = (struct mt7996_txbf_phase *)dev->test.txbf_phase_cal;
+	int group = val[2];
+
+	if (!phase)
+		return -EINVAL;
+
+	wait_event_timeout(dev->mt76.mcu.wait, phase[group].status != 0, HZ);
+	mt7996_tm_txbf_phase_copy(dev, req.phase_comp.buf, phase[group].buf, group);
+
+	mt76_dbg(&dev->mt76, MT76_DBG_TEST, "%s: phase comp info\n", __func__);
+	print_hex_dump(KERN_INFO, "", DUMP_PREFIX_NONE, 16, 1,
+		       &req, sizeof(req), 0);
+
+	return mt76_mcu_send_msg(&dev->mt76, MCU_WM_UNI_CMD(BF), &req,
+				 sizeof(req), false);
+}
+
+static int
+mt7996_tm_txbf_profile_tag_write(struct mt7996_phy *phy, u8 pfmu_idx, struct mt7996_pfmu_tag *tag)
+{
+	struct mt7996_dev *dev = phy->dev;
+	struct mt7996_tm_bf_req req = {
+		.pfmu_tag = {
+			.tag = cpu_to_le16(BF_PFMU_TAG_WRITE),
+			.len = cpu_to_le16(sizeof(req.pfmu_tag)),
+			.pfmu_id = pfmu_idx,
+			.bfer = true,
+			.band_idx = phy->mt76->band_idx,
+		}
+	};
+
+	memcpy(req.pfmu_tag.buf, tag, sizeof(*tag));
+	wait_event_timeout(dev->mt76.mcu.wait, tag->t1.pfmu_idx != 0, HZ);
+
+	return mt76_mcu_send_msg(&dev->mt76, MCU_WM_UNI_CMD(BF), &req,
+				 sizeof(req), false);
+}
+
+static int
+mt7996_tm_add_txbf_sta(struct mt7996_phy *phy, u8 pfmu_idx, u8 nr, u8 nc, bool ebf)
+{
+	struct mt7996_dev *dev = phy->dev;
+	struct mt76_testmode_data *td = &phy->mt76->test;
+	struct {
+		struct sta_req_hdr hdr;
+		struct sta_rec_bf bf;
+	} __packed req = {
+		.hdr = {
+			.bss_idx = phy->mt76->band_idx,
+			.wlan_idx_lo = to_wcid_lo(phy->mt76->band_idx + 1),
+			.tlv_num = cpu_to_le16(1),
+			.is_tlv_append = 1,
+			.muar_idx = 0,
+			.wlan_idx_hi = to_wcid_hi(phy->mt76->band_idx + 1),
+		},
+		.bf = {
+			.tag = cpu_to_le16(STA_REC_BF),
+			.len = cpu_to_le16(sizeof(req.bf)),
+			.pfmu = cpu_to_le16(pfmu_idx),
+			.sounding_phy = 1,
+			.bf_cap = ebf,
+			.ncol = nc,
+			.nrow = nr,
+			.ibf_timeout = 0xff,
+			.tx_mode = mt7996_tm_rate_mapping(td->tx_rate_mode, RATE_MODE_TO_PHY),
+		},
+	};
+	u8 ndp_rate, ndpa_rate, rept_poll_rate;
+	u8 bf_bw = phy->mt76->chandef.width;
+
+	if ((td->tx_rate_mode == MT76_TM_TX_MODE_HE_SU ||
+	     td->tx_rate_mode == MT76_TM_TX_MODE_EHT_SU) && !td->ibf) {
+		rept_poll_rate = 0x49;
+		ndpa_rate = 0x49;
+		ndp_rate = 0;
+	} else if (td->tx_rate_mode == MT76_TM_TX_MODE_VHT && !td->ibf) {
+		rept_poll_rate = 0x9;
+		ndpa_rate = 0x9;
+		ndp_rate = 0;
+	} else {
+		rept_poll_rate = 0;
+		ndpa_rate = 0;
+		if (nr == 1)
+			ndp_rate = 8;
+		else if (nr == 2)
+			ndp_rate = 16;
+		else if (nr == 4)
+			ndp_rate = 32;
+		else
+			ndp_rate = 24;
+
+		/* 5T5R ebf profile for ibf cal */
+		if (nr == 4 && td->ibf && ebf) {
+			ndp_rate = 0;
+			ndpa_rate = 11;
+		}
+	}
+
+	req.bf.ndp_rate = ndp_rate;
+	req.bf.ndpa_rate = ndpa_rate;
+	req.bf.rept_poll_rate = rept_poll_rate;
+	if (mt76_testmode_param_present(td, MT76_TM_ATTR_TX_PKT_BW))
+		bf_bw = td->tx_pkt_bw;
+	req.bf.bw = mt7996_tm_bw_mapping(bf_bw, BW_MAP_NL_TO_BF);
+	req.bf.tx_mode = (td->tx_rate_mode == MT76_TM_TX_MODE_EHT_SU) ? 0xf : req.bf.tx_mode;
+
+	if (ebf) {
+		req.bf.mem[0].row = 0;
+		req.bf.mem[1].row = 1;
+		req.bf.mem[2].row = 2;
+		req.bf.mem[3].row = 3;
+	} else {
+		req.bf.mem[0].row = 4;
+		req.bf.mem[1].row = 5;
+		req.bf.mem[2].row = 6;
+		req.bf.mem[3].row = 7;
+	}
+
+	return mt76_mcu_send_msg(&dev->mt76, MCU_WMWA_UNI_CMD(STA_REC_UPDATE), &req,
+				 sizeof(req), true);
+}
+
+static int
+mt7996_tm_txbf_profile_update(struct mt7996_phy *phy, u16 *val, bool ebf)
+{
+#define MT_ARB_IBF_ENABLE			(BIT(0) | GENMASK(9, 8))
+	struct mt76_testmode_data *td = &phy->mt76->test;
+	struct mt7996_dev *dev = phy->dev;
+	struct mt7996_pfmu_tag *tag = dev->test.txbf_pfmu_tag;
+	u8 rate, pfmu_idx = val[0], nc = val[2], nr;
+	u8 dbw = phy->mt76->chandef.width;
+	int ret;
+	bool is_atenl = val[5];
+
+	if (!tag)
+		return -EINVAL;
+
+	if (td->tx_antenna_mask == 3)
+		nr = 1;
+	else if (td->tx_antenna_mask == 7)
+		nr = 2;
+	else if (td->tx_antenna_mask == 31)
+		nr = 4;
+	else
+		nr = 3;
+
+	memset(tag, 0, sizeof(*tag));
+	tag->t1.pfmu_idx = pfmu_idx;
+	tag->t1.ebf = ebf;
+	tag->t1.nr = nr;
+	tag->t1.nc = nc;
+	tag->t1.invalid_prof = true;
+	if (mt76_testmode_param_present(td, MT76_TM_ATTR_TX_PKT_BW))
+		dbw = td->tx_pkt_bw;
+	tag->t1.data_bw = mt7996_tm_bw_mapping(dbw, BW_MAP_NL_TO_BF);
+	tag->t2.se_idx = td->tx_spe_idx;
+
+	if (ebf) {
+		tag->t1.row_id1 = 0;
+		tag->t1.row_id2 = 1;
+		tag->t1.row_id3 = 2;
+		tag->t1.row_id4 = 3;
+		tag->t1.lm = mt7996_tm_rate_mapping(td->tx_rate_mode, RATE_MODE_TO_LM);
+	} else {
+		tag->t1.row_id1 = 4;
+		tag->t1.row_id2 = 5;
+		tag->t1.row_id3 = 6;
+		tag->t1.row_id4 = 7;
+		rate = nr == 4 ? td->tx_rate_mode : MT76_TM_TX_MODE_OFDM;
+		tag->t1.lm = mt7996_tm_rate_mapping(rate, RATE_MODE_TO_LM);
+
+		tag->t2.ibf_timeout = 0xff;
+		tag->t2.ibf_nr = nr;
+		tag->t2.ibf_nc = nc;
+	}
+
+	ret = mt7996_tm_txbf_profile_tag_write(phy, pfmu_idx, tag);
+	if (ret)
+		return ret;
+
+	ret = mt7996_tm_add_txbf_sta(phy, pfmu_idx, nr, nc, ebf);
+	if (ret)
+		return ret;
+
+	if (!is_atenl && !td->ibf) {
+		mt76_set(dev, MT_ARB_TQSAXM0(phy->mt76->band_idx), MT_ARB_TQSAXM_ALTX_START_MASK);
+		mt76_dbg(&dev->mt76, MT76_DBG_TEST,
+			 "%s: set TX queue start CR for AX management (0x%x) = 0x%x\n",
+			 __func__, MT_ARB_TQSAXM0(phy->mt76->band_idx),
+			 mt76_rr(dev, MT_ARB_TQSAXM0(phy->mt76->band_idx)));
+	} else if (!is_atenl && td->ibf && ebf) {
+		/* iBF's ebf profile update */
+		mt76_set(dev, MT_ARB_TQSAXM0(phy->mt76->band_idx), MT_ARB_IBF_ENABLE);
+		mt76_dbg(&dev->mt76, MT76_DBG_TEST,
+			 "%s: set TX queue start CR for AX management (0x%x) = 0x%x\n",
+			 __func__, MT_ARB_TQSAXM0(phy->mt76->band_idx),
+			 mt76_rr(dev, MT_ARB_TQSAXM0(phy->mt76->band_idx)));
+	}
+
+	if (!ebf && is_atenl)
+		return mt7996_tm_txbf_apply_tx(phy, 1, false, true, true);
+
+	return 0;
+}
+
+static int
+mt7996_tm_txbf_phase_cal(struct mt7996_phy *phy, u16 *val)
+{
+	struct mt7996_dev *dev = phy->dev;
+	struct mt7996_tm_bf_req req = {
+		.phase_cal = {
+			.tag = cpu_to_le16(BF_PHASE_CALIBRATION),
+			.len = cpu_to_le16(sizeof(req.phase_cal)),
+			.group = val[0],
+			.group_l_m_n = val[1],
+			.sx2 = val[2],
+			.cal_type = val[3],
+			.lna_gain_level = val[4],
+			.band_idx = phy->mt76->band_idx,
+			.version = val[5],
+		},
+	};
+	struct mt7996_txbf_phase *phase = (struct mt7996_txbf_phase *)dev->test.txbf_phase_cal;
+
+	if (!phase)
+		return -EINVAL;
+
+	/* reset phase status before update phase cal data */
+	phase[req.phase_cal.group].status = 0;
+
+	return mt76_mcu_send_msg(&dev->mt76, MCU_WM_UNI_CMD(BF), &req,
+				 sizeof(req), false);
+}
+
+static int
+mt7996_tm_txbf_profile_update_all(struct mt7996_phy *phy, u16 *val)
+{
+	struct mt7996_dev *dev = phy->dev;
+	u8 nss = hweight16(phy->mt76->chainmask);
+	u16 pfmu_idx = val[0];
+	u16 subc_id = val[1];
+	u16 angle11 = val[2];
+	u16 angle21 = val[3];
+	u16 angle31 = val[4];
+	u16 angle41 = val[5];
+	u16 angle51 = val[6];
+	s16 phi11 = 0, phi21 = 0, phi31 = 0, phi41 = 0;
+	s16 *pfmu_data;
+	int offs = subc_id * sizeof(struct mt7996_pfmu_data) / sizeof(*pfmu_data);
+
+	if (!dev->test.txbf_pfmu_data ||
+	    subc_id > MT7996_TXBF_SUBCAR_NUM - 1)
+		return -EINVAL;
+
+	if (nss == 2) {
+		phi11 = (s16)(angle21 - angle11);
+	} else if (nss == 3) {
+		phi11 = (s16)(angle31 - angle11);
+		phi21 = (s16)(angle31 - angle21);
+	} else if (nss == 5) {
+		phi11 = (s16)(angle51 - angle11);
+		phi21 = (s16)(angle51 - angle21);
+		phi31 = (s16)(angle51 - angle31);
+		phi41 = (s16)(angle51 - angle41);
+		offs = subc_id * sizeof(struct mt7996_pfmu_data_5x5) / sizeof(*pfmu_data);
+	} else {
+		phi11 = (s16)(angle41 - angle11);
+		phi21 = (s16)(angle41 - angle21);
+		phi31 = (s16)(angle41 - angle31);
+	}
+
+	pfmu_data = (s16 *)dev->test.txbf_pfmu_data;
+	pfmu_data += offs;
+
+	if (subc_id < 32)
+		pfmu_data[0] = cpu_to_le16(subc_id + 224);
+	else
+		pfmu_data[0] = cpu_to_le16(subc_id - 32);
+
+	pfmu_data[1] = cpu_to_le16(phi11);
+	pfmu_data[2] = cpu_to_le16(phi21);
+	pfmu_data[3] = cpu_to_le16(phi31);
+	if (nss == 5)
+		pfmu_data[4] = cpu_to_le16(phi41);
+
+	if (subc_id == MT7996_TXBF_SUBCAR_NUM - 1) {
+		struct mt7996_tm_bf_req req = {
+			.pfmu_data_all = {
+				.tag = cpu_to_le16(BF_PROFILE_WRITE_20M_ALL_5X5),
+				.len = cpu_to_le16(sizeof(req.pfmu_data_all)),
+				.pfmu_id = pfmu_idx,
+				.band_idx = phy->mt76->band_idx,
+			},
+		};
+		int size = MT7996_TXBF_PFMU_DATA_LEN_5X5;
+
+		if (nss != 5) {
+			size = MT7996_TXBF_PFMU_DATA_LEN;
+			req.pfmu_data_all.tag = cpu_to_le16(BF_PROFILE_WRITE_20M_ALL);
+			req.pfmu_data_all.len = cpu_to_le16(sizeof(req.pfmu_data_all) -
+							    MT7996_TXBF_PFMU_DATA_LEN_5X5 + size);
+		}
+		memcpy(req.pfmu_data_all.buf, dev->test.txbf_pfmu_data, size);
+
+		return mt76_mcu_send_msg(&dev->mt76, MCU_WM_UNI_CMD(BF),
+					 &req, sizeof(req), true);
+	}
+
+	return 0;
+}
+
+static int
+mt7996_tm_txbf_e2p_update(struct mt7996_phy *phy)
+{
+#define TXBF_PHASE_EEPROM_START_OFFSET		0xc00
+#define TXBF_PHASE_GROUP_EEPROM_OFFSET_VER_1	46
+#define TXBF_PHASE_G0_EEPROM_OFFSET_VER_2	29
+#define TXBF_PHASE_GX_EEPROM_OFFSET_VER_2	sizeof(struct mt7992_txbf_phase_info_5g)
+	struct mt7996_txbf_phase *phase, *p;
+	struct mt7996_dev *dev = phy->dev;
+	u8 *eeprom = dev->mt76.eeprom.data;
+	u16 offset;
+	int i;
+
+	offset = TXBF_PHASE_EEPROM_START_OFFSET;
+	phase = (struct mt7996_txbf_phase *)dev->test.txbf_phase_cal;
+	if (!phase)
+		return -EINVAL;
+
+	for (i = 0; i < MAX_PHASE_GROUP_NUM; i++) {
+		p = &phase[i];
+
+		/* copy valid phase cal data to eeprom */
+		if (p->status)
+			mt7996_tm_txbf_phase_copy(dev, eeprom + offset, p->buf, i);
+
+		if (get_ibf_version(dev) == IBF_VER_1)
+			offset += TXBF_PHASE_GROUP_EEPROM_OFFSET_VER_1;
+		else
+			offset += i ? TXBF_PHASE_GX_EEPROM_OFFSET_VER_2 :
+				      TXBF_PHASE_G0_EEPROM_OFFSET_VER_2;
+	}
+
+	return 0;
+}
+
+static int
+mt7996_tm_txbf_apply_tx(struct mt7996_phy *phy, u16 wlan_idx, bool ebf,
+			bool ibf, bool phase_cal)
+{
+	struct mt7996_dev *dev = phy->dev;
+	struct mt7996_tm_bf_req req = {
+		.tx_apply = {
+			.tag = cpu_to_le16(BF_DATA_PACKET_APPLY),
+			.len = cpu_to_le16(sizeof(req.tx_apply)),
+			.wlan_idx = cpu_to_le16(wlan_idx),
+			.ebf = ebf,
+			.ibf = ibf,
+			.phase_cal = phase_cal,
+		},
+	};
+
+	return mt76_mcu_send_msg(&dev->mt76, MCU_WM_UNI_CMD(BF), &req, sizeof(req), false);
+}
+
+static int
+mt7996_tm_txbf_set_tx(struct mt7996_phy *phy, u16 *val)
+{
+	bool bf_on = val[0], update = val[3];
+	struct mt7996_dev *dev = phy->dev;
+	struct mt7996_pfmu_tag *tag = dev->test.txbf_pfmu_tag;
+	struct mt76_testmode_data *td = &phy->mt76->test;
+
+	if (!tag)
+		return -EINVAL;
+
+	if (bf_on) {
+		mt7996_tm_set_rx_frames(phy, false);
+		mt7996_tm_set_tx_frames(phy, false);
+		mt7996_mcu_set_txbf_internal(phy, BF_PFMU_TAG_READ, 2, true);
+		tag->t1.invalid_prof = false;
+		mt7996_tm_txbf_profile_tag_write(phy, 2, tag);
+		td->bf_ever_en = true;
+
+		if (update)
+			mt7996_tm_txbf_apply_tx(phy, 1, 0, 1, 1);
+	} else {
+		if (!td->bf_ever_en) {
+			mt7996_tm_set_rx_frames(phy, false);
+			mt7996_tm_set_tx_frames(phy, false);
+
+			if (update)
+				mt7996_tm_txbf_apply_tx(phy, 1, 0, 0, 0);
+		} else {
+			td->bf_ever_en = false;
+
+			mt7996_mcu_set_txbf_internal(phy, BF_PFMU_TAG_READ, 2, true);
+			tag->t1.invalid_prof = true;
+			mt7996_tm_txbf_profile_tag_write(phy, 2, tag);
+		}
+	}
+
+	return 0;
+}
+
+static int
+mt7996_tm_trigger_sounding(struct mt7996_phy *phy, u16 *val, bool en)
+{
+	struct mt7996_dev *dev = phy->dev;
+	u8 sounding_mode = val[0];
+	u8 sta_num = val[1];
+	u32 sounding_interval = (u32)val[2] << 2;	/* input unit: 4ms */
+	u16 tag = en ? BF_SOUNDING_ON : BF_SOUNDING_OFF;
+	struct mt7996_tm_bf_req req = {
+		.sounding = {
+			.tag = cpu_to_le16(tag),
+			.len = cpu_to_le16(sizeof(req.sounding)),
+			.snd_mode = sounding_mode,
+			.sta_num = sta_num,
+			.wlan_id = {
+				cpu_to_le16(val[3]),
+				cpu_to_le16(val[4]),
+				cpu_to_le16(val[5]),
+				cpu_to_le16(val[6])
+			},
+			.snd_period = cpu_to_le32(sounding_interval),
+		},
+	};
+
+	if (sounding_mode > SOUNDING_MODE_MAX)
+		return -EINVAL;
+
+	return mt76_mcu_send_msg(&dev->mt76, MCU_WM_UNI_CMD(BF),
+				 &req, sizeof(req), false);
+}
+
+static int
+mt7996_tm_txbf_txcmd(struct mt7996_phy *phy, u16 *val)
+{
+	struct mt7996_dev *dev = phy->dev;
+	struct mt7996_tm_bf_req req = {
+		.txcmd = {
+			.tag = cpu_to_le16(BF_CMD_TXCMD),
+			.len = cpu_to_le16(sizeof(req.txcmd)),
+			.action = val[0],
+			.bf_manual = val[1],
+			.bf_bit = val[2],
+		},
+	};
+
+	return mt76_mcu_send_msg(&dev->mt76, MCU_WM_UNI_CMD(BF), &req, sizeof(req), false);
+}
+
+static int
+mt7996_tm_set_txbf(struct mt7996_phy *phy)
+{
+#define TXBF_IS_DUT_MASK	BIT(0)
+#define TXBF_IBF_MASK		BIT(1)
+	struct mt76_testmode_data *td = &phy->mt76->test;
+	struct mt7996_dev *dev = phy->dev;
+	u16 *val = td->txbf_param;
+
+	mt76_dbg(&dev->mt76, MT76_DBG_TEST,
+		 "%s: act = %u, val = %u, %u, %u, %u, %u, %u, %u, %u\n",
+		 __func__, td->txbf_act, val[0], val[1], val[2], val[3],
+		 val[4], val[5], val[6], val[7]);
+
+	switch (td->txbf_act) {
+	case MT76_TM_TXBF_ACT_GOLDEN_INIT:
+	case MT76_TM_TXBF_ACT_INIT:
+	case MT76_TM_TX_EBF_ACT_GOLDEN_INIT:
+	case MT76_TM_TX_EBF_ACT_INIT:
+		td->ibf = !u32_get_bits(td->txbf_act, TXBF_IBF_MASK);
+		td->ebf = true;
+		td->is_txbf_dut = !!u32_get_bits(td->txbf_act, TXBF_IS_DUT_MASK);
+		return mt7996_tm_txbf_init(phy, val);
+	case MT76_TM_TXBF_ACT_UPDATE_CH:
+		mt7996_tm_update_channel(phy);
+		break;
+	case MT76_TM_TXBF_ACT_PHASE_COMP:
+		return mt7996_tm_txbf_phase_comp(phy, val);
+	case MT76_TM_TXBF_ACT_TX_PREP:
+		return mt7996_tm_txbf_set_tx(phy, val);
+	case MT76_TM_TXBF_ACT_IBF_PROF_UPDATE:
+		return mt7996_tm_txbf_profile_update(phy, val, false);
+	case MT76_TM_TXBF_ACT_EBF_PROF_UPDATE:
+		return mt7996_tm_txbf_profile_update(phy, val, true);
+	case MT76_TM_TXBF_ACT_PHASE_CAL:
+		return mt7996_tm_txbf_phase_cal(phy, val);
+	case MT76_TM_TXBF_ACT_PROF_UPDATE_ALL_CMD:
+	case MT76_TM_TXBF_ACT_PROF_UPDATE_ALL:
+		return mt7996_tm_txbf_profile_update_all(phy, val);
+	case MT76_TM_TXBF_ACT_E2P_UPDATE:
+		return mt7996_tm_txbf_e2p_update(phy);
+	case MT76_TM_TXBF_ACT_APPLY_TX: {
+		u16 wlan_idx = val[0];
+		bool ebf = !!val[1], ibf = !!val[2], phase_cal = !!val[4];
+
+		return mt7996_tm_txbf_apply_tx(phy, wlan_idx, ebf, ibf, phase_cal);
+	}
+	case MT76_TM_TXBF_ACT_TRIGGER_SOUNDING:
+		return mt7996_tm_trigger_sounding(phy, val, true);
+	case MT76_TM_TXBF_ACT_STOP_SOUNDING:
+		memset(val, 0, sizeof(td->txbf_param));
+		return mt7996_tm_trigger_sounding(phy, val, false);
+	case MT76_TM_TXBF_ACT_PROFILE_TAG_READ:
+	case MT76_TM_TXBF_ACT_PROFILE_TAG_WRITE:
+	case MT76_TM_TXBF_ACT_PROFILE_TAG_INVALID: {
+		struct mt7996_pfmu_tag *tag = dev->test.txbf_pfmu_tag;
+		u8 pfmu_idx = val[0];
+		bool bfer = !!val[1];
+
+		if (!tag) {
+			mt76_err(&dev->mt76, "%s: pfmu tag is not initialized\n", __func__);
+			return -EINVAL;
+		}
+
+		if (td->txbf_act == MT76_TM_TXBF_ACT_PROFILE_TAG_WRITE)
+			return mt7996_tm_txbf_profile_tag_write(phy, pfmu_idx, tag);
+		else if (td->txbf_act == MT76_TM_TXBF_ACT_PROFILE_TAG_READ)
+			return mt7996_mcu_set_txbf_internal(phy, BF_PFMU_TAG_READ, pfmu_idx, bfer);
+
+		tag->t1.invalid_prof = !!val[0];
+
+		return 0;
+	}
+	case MT76_TM_TXBF_ACT_STA_REC_READ:
+		return mt7996_mcu_set_txbf_internal(phy, BF_STA_REC_READ, val[0], 0);
+	case MT76_TM_TXBF_ACT_TXCMD:
+		return mt7996_tm_txbf_txcmd(phy, val);
+	default:
+		break;
+	};
+
+	return 0;
+}
+
+static int
+mt7996_tm_set_icap(struct mt7996_phy *phy, bool en)
+{
+#define CAP_96_BIT	1
+	struct mt76_testmode_data *td = &phy->mt76->test;
+	struct mt7996_dev *dev = phy->dev;
+	struct mt7996_tm_req req = {
+		.rf_test = {
+			.tag = cpu_to_le16(UNI_RF_TEST_CTRL),
+			.len = cpu_to_le16(sizeof(req.rf_test)),
+			.action = RF_ACTION_IN_RF_TEST,
+			.op.rf.func_idx = cpu_to_le32(RF_TEST_SET_ICAP),
+			.op.rf.param.icap_param = {
+				.enable = cpu_to_le32(en),
+				.band_idx = cpu_to_le32(phy->mt76->band_idx),
+				.phy_idx = cpu_to_le32(phy->mt76->band_idx),
+				.bit_width = cpu_to_le32(CAP_96_BIT),
+			},
+		},
+	};
+	struct tm_icap_param *icap = &req.rf_test.op.rf.param.icap_param;
+	u32 bw;
+
+	if (!en) {
+		mt7996_tm_set_tx_frames(phy, false);
+		mt7996_tm_set_rx_frames(phy, false);
+		goto out;
+	}
+
+	icap->ring_buffer = cpu_to_le32(td->icap.ring_buffer);
+	icap->trigger_event = cpu_to_le32(td->icap.trigger_event);
+	icap->node = cpu_to_le32(td->icap.node);
+	icap->len = cpu_to_le32(td->icap.len);
+	icap->cycle = cpu_to_le32(td->icap.cycle);
+	bw = mt7996_tm_bw_mapping(td->icap.bandwidth, BW_MAP_NL_TO_ICAP);
+	icap->bandwidth = cpu_to_le32(bw);
+	icap->src = cpu_to_le32(td->icap.src);
+
+out:
+	return mt76_mcu_send_msg(&dev->mt76, MCU_WM_UNI_CMD(TESTMODE_CTRL), &req,
+				 sizeof(req), false);
+}
+
+static int
+mt7996_tm_dump_icap(struct mt76_phy *mphy)
+{
+	struct mt76_testmode_data *td = &mphy->test;
+	struct mt76_dev *mdev = mphy->dev;
+	struct mt7996_tm_req req = {
+		.rf_test = {
+			.tag = cpu_to_le16(UNI_RF_TEST_CTRL),
+			.len = cpu_to_le16(sizeof(req.rf_test)),
+			.action = RF_ACTION_IN_RF_TEST,
+			.icap_attr = 1,
+			.op.rf.func_idx = cpu_to_le32(RF_TEST_GET_ICAP_STATUS),
+		},
+	};
+	struct mt7996_tm_event *event;
+	struct mt7996_tm_rf_test_icap *icap;
+	struct sk_buff *skb;
+	int i, ret;
+
+	ret = mt76_mcu_send_and_get_msg(mdev, MCU_WM_UNI_CMD_QUERY(TESTMODE_CTRL),
+					&req, sizeof(req), true, &skb);
+	if (ret)
+		return ret;
+
+	event = (struct mt7996_tm_event *)skb->data;
+	td->icap.cap_status = le32_to_cpu(event->result.capture_done);
+
+	dev_kfree_skb(skb);
+
+	if (!td->icap.cap_status)
+		return -EBUSY;
+
+	req.rf_test.op.rf.func_idx = cpu_to_le32(RF_TEST_GET_ICAP_RAW_DATA);
+	req.rf_test.op.rf.param.icap_dump.path = cpu_to_le32(td->icap.path);
+	req.rf_test.op.rf.param.icap_dump.iq_type = cpu_to_le32(td->icap.iq_type);
+	ret = mt76_mcu_send_and_get_msg(mdev, MCU_WM_UNI_CMD_QUERY(TESTMODE_CTRL),
+					&req, sizeof(req), true, &skb);
+	if (ret)
+		return ret;
+
+	event = (struct mt7996_tm_event *)skb->data;
+	icap = (struct mt7996_tm_rf_test_icap *)&event->icap;
+	if (!td->icap.data) {
+		td->icap.data = devm_kcalloc(mdev->dev, MT_TM_ICAP_SAMPLE_LEN,
+					     sizeof(u32), GFP_KERNEL);
+		if (!td->icap.data) {
+			dev_kfree_skb(skb);
+			return -ENOMEM;
+		}
+	}
+
+	for (i = 0; i < MT_TM_ICAP_SAMPLE_LEN; i++)
+		td->icap.data[i] = le32_to_cpu(icap->data[i]);
+
+	dev_kfree_skb(skb);
+
+	return 0;
+}
+
+static void
+mt7996_tm_update_params(struct mt7996_phy *phy, u32 changed)
+{
+	struct mt76_testmode_data *td = &phy->mt76->test;
+	struct mt7996_dev *dev = phy->dev;
+
+	if (changed & BIT(TM_CHANGED_FREQ_OFFSET)) {
+		mt7996_tm_set(dev, SET_ID(FREQ_OFFSET), td->freq_offset);
+		mt7996_tm_set(dev, SET_ID(FREQ_OFFSET_C2), td->freq_offset);
+	}
+	if (changed & BIT(TM_CHANGED_TXPOWER))
+		mt7996_tm_set(dev, SET_ID(POWER), td->tx_power[0]);
+	if (changed & BIT(TM_CHANGED_SKU_EN)) {
+		mt7996_tm_update_channel(phy);
+		mt7996_mcu_set_tx_power_ctrl(phy, POWER_CTRL(SKU_POWER_LIMIT), td->sku_en);
+		mt7996_mcu_set_tx_power_ctrl(phy, POWER_CTRL(BACKOFF_POWER_LIMIT), td->sku_en);
+		mt7996_mcu_set_txpower_sku(phy);
+	}
+	if (changed & BIT(TM_CHANGED_TX_LENGTH)) {
+		mt7996_tm_set(dev, SET_ID(TX_LEN), td->tx_mpdu_len);
+		mt7996_tm_set(dev, SET_ID(TX_TIME), 0);
+	}
+	if (changed & BIT(TM_CHANGED_TX_TIME)) {
+		mt7996_tm_set(dev, SET_ID(TX_LEN), 0);
+		mt7996_tm_set(dev, SET_ID(TX_TIME), td->tx_time);
+	}
+	if (changed & BIT(TM_CHANGED_CFG))
+		mt7996_tm_set_cfg(phy);
+	if ((changed & BIT(TM_CHANGED_OFF_CHAN_CH)) &&
+	    (changed & BIT(TM_CHANGED_OFF_CHAN_BW)))
+		mt7996_tm_set_offchan(phy, !(changed & BIT(TM_CHANGED_OFF_CHAN_CENTER_CH)));
+	if ((changed & BIT(TM_CHANGED_IPI_THRESHOLD)) &&
+	    (changed & BIT(TM_CHANGED_IPI_PERIOD)))
+		mt7996_tm_set_ipi(phy);
+	if (changed & BIT(TM_CHANGED_IPI_RESET))
+		mt7996_tm_ipi_hist_ctrl(phy, NULL, RDD_SET_IPI_HIST_RESET);
+	if (changed & BIT(TM_CHANGED_TXBF_ACT))
+		mt7996_tm_set_txbf(phy);
+	if (changed & BIT(TM_CHANGED_TX_ANTENNA)) {
+		mt76_testmode_param_set(td, MT76_TM_ATTR_TX_ANTENNA);
+		mt7996_tm_set_antenna(phy, SET_ID(TX_PATH));
+		mt7996_tm_set_antenna(phy, SET_ID(RX_PATH));
+	}
+	if (changed & BIT(TM_CHANGED_TX_RATE_NSS))
+		mt7996_tm_set(dev, SET_ID(NSS), td->tx_rate_nss);
+	if (changed & BIT(TM_CHANGED_TX_RATE_IDX))
+		mt7996_tm_set(dev, SET_ID(TX_RATE), td->tx_rate_idx);
+	if (changed & BIT(TM_CHANGED_RX_FILTER)) {
+		bool en = !!td->rx_filter;
+		u32 data = 0;
+
+		data |= u32_encode_bits(en, BIT(30)) |
+			u32_encode_bits(phy->mt76->band_idx, GENMASK(25, 24)) |
+			u32_encode_bits(td->rx_filter, GENMASK(23, 0));
+		mt7996_tm_set(dev, SET_ID(RX_FILTER), data);
+	}
+}
+
+static int
+mt7996_tm_set_state(struct mt76_phy *mphy, enum mt76_testmode_state state)
+{
+	struct mt76_testmode_data *td = &mphy->test;
+	struct mt7996_phy *phy = mphy->priv;
+	struct mt7996_dev *dev = phy->dev;
+	enum mt76_testmode_state prev_state = td->state;
+
+	if (!dev->testmode_enable)
+		return -EPERM;
+
+	if (prev_state != MT76_TM_STATE_OFF)
+		mt7996_tm_set(dev, SET_ID(BAND_IDX), mphy->band_idx);
+
+	if (state >= MT76_TM_STATE_GROUP_PREK && state <= MT76_TM_STATE_GROUP_PREK_CLEAN)
+		return mt7996_tm_group_prek(phy, state);
+	else if (state >= MT76_TM_STATE_DPD_2G && state <= MT76_TM_STATE_DPD_CLEAN)
+		return mt7996_tm_dpd_prek(phy, state);
+	else if (state >= MT76_TM_STATE_RX_GAIN_CAL && state <= MT76_TM_STATE_RX_GAIN_CAL_CLEAN)
+		return mt7996_tm_rx_gain_cal(phy, state);
+
+	if (prev_state == MT76_TM_STATE_ICAP || state == MT76_TM_STATE_ICAP)
+		return mt7996_tm_set_icap(phy, state == MT76_TM_STATE_ICAP);
+
+	if (prev_state == MT76_TM_STATE_TX_FRAMES ||
+	    state == MT76_TM_STATE_TX_FRAMES)
+		mt7996_tm_set_tx_frames(phy, state == MT76_TM_STATE_TX_FRAMES);
+	else if (prev_state == MT76_TM_STATE_RX_FRAMES ||
+		 state == MT76_TM_STATE_RX_FRAMES)
+		mt7996_tm_set_rx_frames(phy, state == MT76_TM_STATE_RX_FRAMES);
+	else if (prev_state == MT76_TM_STATE_TX_CONT ||
+		 state == MT76_TM_STATE_TX_CONT)
+		mt7996_tm_set_tx_cont(phy, state == MT76_TM_STATE_TX_CONT);
+	else if (prev_state == MT76_TM_STATE_TX_TONE ||
+		 state == MT76_TM_STATE_TX_TONE)
+		mt7996_tm_set_tx_tone(phy, state == MT76_TM_STATE_TX_TONE);
+	else if (prev_state == MT76_TM_STATE_OFF ||
+		 state == MT76_TM_STATE_OFF)
+		mt7996_tm_init(phy, !(state == MT76_TM_STATE_OFF));
+
+	if ((state == MT76_TM_STATE_IDLE &&
+	     prev_state == MT76_TM_STATE_OFF) ||
+	    (state == MT76_TM_STATE_OFF &&
+	     prev_state == MT76_TM_STATE_IDLE)) {
+		u32 changed = 0;
+		int i, ret;
+
+		for (i = 0; i < ARRAY_SIZE(tm_change_map); i++) {
+			u16 cur = tm_change_map[i];
+
+			if (mt76_testmode_param_present(td, cur))
+				changed |= BIT(i);
+		}
+
+		ret = mt7996_tm_check_antenna(phy);
+		if (ret)
+			return ret;
+
+		mt7996_tm_update_params(phy, changed);
+	}
+
+	return 0;
+}
+
+static int
+mt7996_tm_set_params(struct mt76_phy *mphy, struct nlattr **tb,
+		     enum mt76_testmode_state new_state)
+{
+	struct mt76_testmode_data *td = &mphy->test;
+	struct mt7996_phy *phy = mphy->priv;
+	struct mt7996_dev *dev = phy->dev;
+	u32 changed = 0;
+	int i, ret;
+
+	BUILD_BUG_ON(NUM_TM_CHANGED >= 32);
+
+	if (new_state == MT76_TM_STATE_OFF ||
+	    td->state == MT76_TM_STATE_OFF)
+		return 0;
+
+	ret = mt7996_tm_check_antenna(phy);
+	if (ret)
+		return ret;
+
+	for (i = 0; i < ARRAY_SIZE(tm_change_map); i++) {
+		if (tb[tm_change_map[i]])
+			changed |= BIT(i);
+	}
+
+	mt7996_tm_set(dev, SET_ID(BAND_IDX), mphy->band_idx);
+	mt7996_tm_update_params(phy, changed);
+
+	return 0;
+}
+
+static int
+mt7996_tm_get_rx_stats(struct mt7996_phy *phy)
+{
+	struct mt7996_dev *dev = phy->dev;
+	struct mt7996_tm_rx_req req = {
+		.band = phy->mt76->band_idx,
+		.rx_stat_all = {
+			.tag = cpu_to_le16(UNI_TM_RX_STAT_GET_ALL_V2),
+			.len = cpu_to_le16(sizeof(req.rx_stat_all)),
+			.band_idx = phy->mt76->band_idx,
+		},
+	};
+	struct mt76_testmode_data *td = &phy->mt76->test;
+	struct mt7996_tm_rx_event *rx_stats;
+	struct mt7996_tm_rx_event_stat_all *rx_stats_all;
+	struct sk_buff *skb;
+	enum mt76_rxq_id qid;
+	int i, ret = 0;
+	u16 fcs_err_count, fcs_ok_count;
+	u16 len_mismatch;
+	u32 mdrdy_count;
+
+	if (td->state != MT76_TM_STATE_RX_FRAMES &&
+	    td->state != MT76_TM_STATE_ICAP)
+		return 0;
+
+	ret = mt76_mcu_send_and_get_msg(&dev->mt76, MCU_WM_UNI_CMD_QUERY(TESTMODE_RX_STAT),
+					&req, sizeof(req), true, &skb);
+
+	if (ret)
+		return ret;
+
+	rx_stats = (struct mt7996_tm_rx_event *)skb->data;
+	rx_stats_all = &rx_stats->rx_stat_all;
+
+	td->last_rx.freq_offset = le32_to_cpu(rx_stats_all->user_info[0].freq_offset);
+	td->last_rx.snr = le32_to_cpu(rx_stats_all->user_info[0].snr);
+	for (i = 0; i < td->last_rx.path; i++) {
+		td->last_rx.rcpi[i] = le16_to_cpu(rx_stats_all->rxv_info[i].rcpi);
+		td->last_rx.rssi[i] = le16_to_cpu(rx_stats_all->rxv_info[i].rssi);
+		td->last_rx.ib_rssi[i] = rx_stats_all->fagc[i].ib_rssi;
+		td->last_rx.wb_rssi[i] = rx_stats_all->fagc[i].wb_rssi;
+	}
+
+	if (phy->mt76->band_idx == MT_BAND2)
+		qid = MT_RXQ_BAND2;
+	else if (phy->mt76->band_idx == MT_BAND1)
+		qid = MT_RXQ_BAND1;
+	else
+		qid = MT_RXQ_MAIN;
+
+	mdrdy_count = le32_to_cpu(rx_stats_all->band_info.mac_rx_mdrdy_cnt);
+	fcs_ok_count = le16_to_cpu(rx_stats_all->band_info.mac_rx_fcs_ok_cnt);
+	fcs_err_count = le16_to_cpu(rx_stats_all->band_info.mac_rx_fcs_err_cnt);
+	len_mismatch = le16_to_cpu(rx_stats_all->band_info.mac_rx_len_mismatch);
+	td->rx_stats[qid].packets += mdrdy_count;
+	td->rx_stats[qid].rx_success += fcs_ok_count;
+	td->rx_stats[qid].fcs_error += fcs_err_count;
+	td->rx_stats[qid].len_mismatch += len_mismatch;
+
+	dev_kfree_skb(skb);
+
+	return ret;
+}
+
+static void
+mt7996_tm_reset_trx_stats(struct mt76_phy *mphy)
+{
+	struct mt7996_phy *phy = mphy->priv;
+
+	memset(&mphy->test.rx_stats, 0, sizeof(mphy->test.rx_stats));
+	mt7996_tm_set(phy->dev, SET_ID(TRX_COUNTER_RESET), 0);
+}
+
+static int
+mt7996_tm_get_tx_stats(struct mt7996_phy *phy)
+{
+	struct mt7996_dev *dev = phy->dev;
+	struct mt76_testmode_data *td = &phy->mt76->test;
+	int ret;
+
+	if (td->state != MT76_TM_STATE_TX_FRAMES &&
+	    td->state != MT76_TM_STATE_ICAP)
+		return 0;
+
+	ret = mt7996_tm_get(dev, GET_ID(TXED_COUNT), 0, &td->tx_done);
+	if (ret)
+		return ret;
+
+	td->tx_pending = td->tx_count - td->tx_done;
+
+	return ret;
+}
+
+static int
+mt7996_tm_dump_stats(struct mt76_phy *mphy, struct sk_buff *msg)
+{
+	struct mt76_testmode_data *td = &mphy->test;
+	struct mt7996_phy *phy = mphy->priv;
+	struct mt7996_dev *dev = phy->dev;
+	int band_idx = mphy->band_idx;
+
+	if (!td->last_rx.path) {
+		td->last_rx.path = hweight16(mphy->chainmask);
+		if (phy->has_aux_rx)
+			td->last_rx.path++;
+		td->last_rx.rcpi = devm_kzalloc(dev->mt76.dev, td->last_rx.path, GFP_KERNEL);
+		td->last_rx.rssi = devm_kzalloc(dev->mt76.dev, td->last_rx.path, GFP_KERNEL);
+		td->last_rx.ib_rssi = devm_kzalloc(dev->mt76.dev, td->last_rx.path, GFP_KERNEL);
+		td->last_rx.wb_rssi = devm_kzalloc(dev->mt76.dev, td->last_rx.path, GFP_KERNEL);
+	}
+
+	mt7996_tm_set(dev, SET_ID(BAND_IDX), band_idx);
+	mt7996_tm_get_rx_stats(phy);
+	mt7996_tm_get_tx_stats(phy);
+
+	return 0;
+}
+
+static int
+mt7996_tm_dump_tb_info(struct mt76_phy *mphy)
+{
+	struct mt76_testmode_data *td = &mphy->test;
+	struct mt76_tb_info *tb = &td->tb_info;
+	struct mt7996_phy *phy = mphy->priv;
+	struct mt7996_dev *dev = phy->dev;
+	int ret;
+
+	mt7996_tm_set(dev, SET_ID(BAND_IDX), mphy->band_idx);
+
+	ret = mt7996_tm_get(dev, GET_ID(TB_INFO_A_FACTOR), 0, &tb->afactor_init);
+	if (ret)
+		return ret;
+
+	ret = mt7996_tm_get(dev, GET_ID(TB_INFO_LDPC_EXT_SYM), 0, &tb->ldpc_extra_symbol);
+	if (ret)
+		return ret;
+
+	ret = mt7996_tm_get(dev, GET_ID(TB_INFO_PE_DISAMB), 0, &tb->packet_ext_disamb);
+	if (ret)
+		return ret;
+
+	ret = mt7996_tm_get(dev, GET_ID(TB_INFO_TX_PE), 0, &tb->tx_packet_ext);
+	if (ret)
+		return ret;
+
+	ret = mt7996_tm_get(dev, GET_ID(TB_INFO_L_SIG_LEN), 0, &tb->l_sig_len);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+static bool
+mt7996_tm_efuse_update_is_valid(struct mt7996_dev *dev, u32 offset, u8 *write_buf)
+{
+#define PROT_OFFS_MAX_SIZE	8
+#define EFUSE_PROT_END_OFFSET	0xffff
+#define EFUSE_PROT_ALL_MASK	GENMASK(15, 0)
+	static const struct efuse_region ddie_prot_offs[][PROT_OFFS_MAX_SIZE] = {
+		[DDIE_7996] = {{.start = 0x10, .end = 0x18f, .prot_mask = -1},
+			       {.start = 0x1b0, .end = 0x2bf, .prot_mask = -1},
+			       {.start = 0x2c0, .end = 0x2cf, .prot_mask = GENMASK(15, 6)},
+			       {.start = 0x2d0, .end = 0x2ff, .prot_mask = -1},
+			       {.start = 0x300, .end = 0x30f, .prot_mask = GENMASK(15, 1)},
+			       {.start = 0x310, .end = 0x31f, .prot_mask = GENMASK(15, 1)},
+			       {.start = 0x320, .end = 0x3ff, .prot_mask = -1},
+			       {.start = -1}},
+		[DDIE_7992] = {{.start = 0x10, .end = 0x18f, .prot_mask = -1},
+			       {.start = 0x1b0, .end = 0x3ff, .prot_mask = -1},
+			       {.start = -1}},
+		[DDIE_7990] = {{.start = 0x10, .end = 0x18f, .prot_mask = -1},
+			       {.start = 0x1b0, .end = 0x3ff, .prot_mask = -1},
+			       {.start = -1}},
+	};
+	static const struct efuse_region adie_prot_offs[][PROT_OFFS_MAX_SIZE] = {
+		[ADIE_7975] = {{.start = 0x5c0, .end = 0x62f, .prot_mask = -1},
+			       {.start = 0x6c0, .end = 0x6ff, .prot_mask = -1},
+			       {.start = 0x7a0, .end = 0x7af, .prot_mask = BIT(1) | BIT(9)},
+			       {.start = 0x7b0, .end = 0x7bf, .prot_mask = -1},
+			       {.start = -1}},
+		[ADIE_7976] = {{.start = 0x0, .end = 0x7f, .prot_mask = -1},
+			       {.start = 0x790, .end = 0x79f,
+				.prot_mask = GENMASK(15, 10) | GENMASK(8, 0)},
+			       {.start = 0x7a0, .end = 0x7af,
+				.prot_mask = BIT(6) | BIT(8) | BIT(10)},
+			       {.start = 0x7b0, .end = 0x7bf, .prot_mask = -1},
+			       {.start = -1}},
+		[ADIE_7977] = {{.start = 0x0, .end = 0x5f, .prot_mask = -1},
+			       {.start = 0x60, .end = 0x6f, .prot_mask = GENMASK(14, 0)},
+			       {.start = 0x70, .end = 0x7f,
+				.prot_mask = GENMASK(15, 14) | GENMASK(12, 0)},
+			       {.start = 0x80, .end = 0x10f, .prot_mask = -1},
+			       {.start = -1}},
+	};
+	static const struct efuse_region *prot_offs;
+	u8 read_buf[MT76_TM_EEPROM_BLOCK_SIZE], *eeprom = dev->mt76.eeprom.data;
+	int ret, i = 0;
+	u16 base;
+
+	if (!write_buf)
+		return false;
+
+	memset(read_buf, 0, MT76_TM_EEPROM_BLOCK_SIZE);
+	ret = mt7996_mcu_get_eeprom(dev, offset, read_buf,
+				    MT76_TM_EEPROM_BLOCK_SIZE, EFUSE_MODE);
+	if (ret && ret != -EINVAL)
+		return false;
+
+	/* no change in this block, so skip it */
+	if (!memcmp(eeprom + offset, read_buf, MT76_TM_EEPROM_BLOCK_SIZE))
+		return false;
+
+	memcpy(write_buf, eeprom + offset, MT76_TM_EEPROM_BLOCK_SIZE);
+
+	switch (mt76_chip(&dev->mt76)) {
+	case MT7996_DEVICE_ID:
+		if (offset < EFUSE_BASE_OFFS_ADIE0) {
+			base = EFUSE_BASE_OFFS_DDIE;
+			prot_offs = ddie_prot_offs[DDIE_7996];
+		} else if (offset >= EFUSE_BASE_OFFS_ADIE0 &&
+			   offset < EFUSE_BASE_OFFS_ADIE2) {
+			base = EFUSE_BASE_OFFS_ADIE0;
+			if (dev->var.type == MT7996_VAR_TYPE_233 ||
+			    dev->var.fem == MT7996_FEM_EXT)
+				prot_offs = adie_prot_offs[ADIE_7976];
+			else
+				prot_offs = adie_prot_offs[ADIE_7975];
+		} else if (offset >= EFUSE_BASE_OFFS_ADIE2 &&
+			   offset < EFUSE_BASE_OFFS_ADIE1) {
+			base = EFUSE_BASE_OFFS_ADIE2;
+			prot_offs = adie_prot_offs[ADIE_7977];
+		} else {
+			base = EFUSE_BASE_OFFS_ADIE1;
+			prot_offs = adie_prot_offs[ADIE_7977];
+		}
+		break;
+	case MT7992_DEVICE_ID:
+		/* block all the adie region in efuse for kite */
+		if (offset >= EFUSE_BASE_OFFS_ADIE0)
+			return false;
+		base = EFUSE_BASE_OFFS_DDIE;
+		prot_offs = ddie_prot_offs[DDIE_7992];
+		break;
+	case MT7990_DEVICE_ID:
+		/* block all the adie region in efuse for griffin */
+		if (offset >= EFUSE_BASE_OFFS_ADIE0)
+			return false;
+		base = EFUSE_BASE_OFFS_DDIE;
+		prot_offs = ddie_prot_offs[DDIE_7990];
+		break;
+	default:
+		return false;
+	}
+
+	/* check efuse protection */
+	while (prot_offs[i].start != EFUSE_PROT_END_OFFSET) {
+		if (offset >= prot_offs[i].start + base &&
+		    offset <= prot_offs[i].end + base) {
+			unsigned long prot_mask = prot_offs[i].prot_mask;
+			int j;
+
+			if (prot_mask == EFUSE_PROT_ALL_MASK)
+				return false;
+
+			for_each_set_bit(j, &prot_mask, MT76_TM_EEPROM_BLOCK_SIZE) {
+				if (write_buf[j] != read_buf[j]) {
+					write_buf[j] = read_buf[j];
+					mt76_dbg(&dev->mt76, MT76_DBG_TEST,
+						 "%s: offset %x is invalid to write\n",
+						 __func__, offset + j);
+				}
+			}
+			break;
+		}
+		i++;
+	}
+
+	if (!memcmp(read_buf, write_buf, MT76_TM_EEPROM_BLOCK_SIZE))
+		return false;
+
+	return true;
+}
+
+static int
+mt7996_tm_write_back_to_efuse(struct mt7996_dev *dev)
+{
+	struct mt7996_mcu_eeprom_info req = {
+		.tag = cpu_to_le16(UNI_EFUSE_ACCESS),
+		.len = cpu_to_le16(sizeof(req) - 4 +
+				   MT76_TM_EEPROM_BLOCK_SIZE),
+	};
+	int msg_len = sizeof(req) + MT76_TM_EEPROM_BLOCK_SIZE;
+	u8 *eeprom = dev->mt76.eeprom.data;
+	u8 write_buf[MT76_TM_EEPROM_BLOCK_SIZE];
+	int i, ret = -EINVAL;
+
+	/* prevent from damaging chip id in efuse */
+	if (mt76_chip(&dev->mt76) != get_unaligned_le16(eeprom))
+		return ret;
+
+	for (i = 0; i < MT7996_EEPROM_SIZE; i += MT76_TM_EEPROM_BLOCK_SIZE) {
+		struct sk_buff *skb;
+
+		memset(write_buf, 0, MT76_TM_EEPROM_BLOCK_SIZE);
+		if (!mt7996_tm_efuse_update_is_valid(dev, i, write_buf))
+			continue;
+
+		skb = mt76_mcu_msg_alloc(&dev->mt76, NULL, msg_len);
+		if (!skb)
+			return -ENOMEM;
+
+		req.addr = cpu_to_le32(i);
+		skb_put_data(skb, &req, sizeof(req));
+		skb_put_data(skb, write_buf, MT76_TM_EEPROM_BLOCK_SIZE);
+
+		ret = mt76_mcu_skb_send_msg(&dev->mt76, skb,
+					    MCU_WM_UNI_CMD(EFUSE_CTRL), true);
+		if (ret)
+			return ret;
+	}
+
+	return ret;
+}
+
+static int
+mt7996_tm_set_eeprom(struct mt76_phy *mphy, u32 offset, u8 *val, u8 action)
+{
+	struct mt7996_phy *phy = mphy->priv;
+	struct mt7996_dev *dev = phy->dev;
+	u8 *eeprom = dev->mt76.eeprom.data;
+	int ret = 0;
+
+	if (offset >= MT7996_EEPROM_SIZE)
+		return -EINVAL;
+
+	switch (action) {
+	case MT76_TM_EEPROM_ACTION_UPDATE_DATA:
+		memcpy(eeprom + offset, val, MT76_TM_EEPROM_BLOCK_SIZE);
+		break;
+	case MT76_TM_EEPROM_ACTION_UPDATE_BUFFER_MODE:
+		ret = mt7996_mcu_set_eeprom(dev);
+		break;
+	case MT76_TM_EEPROM_ACTION_WRITE_TO_EFUSE:
+		ret = mt7996_tm_write_back_to_efuse(dev);
+		break;
+	case MT76_TM_EEPROM_ACTION_WRITE_TO_EXT_EEPROM:
+		ret = mt7996_mcu_write_ext_eeprom(dev, 0, MT7996_EEPROM_SIZE, NULL);
+		break;
+	default:
+		break;
+	}
+
+	return ret;
+}
+
+static int
+mt7996_tm_dump_seg_list(struct mt7996_phy *phy)
+{
+	struct mt7996_dev *dev = phy->dev;
+	struct mt76_list_mode_data *list;
+	static const char * const testmode_tx_mode[] = {
+		[MT76_TM_TX_MODE_CCK] = "cck",
+		[MT76_TM_TX_MODE_OFDM] = "ofdm",
+		[MT76_TM_TX_MODE_HT] = "ht",
+		[MT76_TM_TX_MODE_VHT] = "vht",
+		[MT76_TM_TX_MODE_HE_SU] = "he_su",
+		[MT76_TM_TX_MODE_HE_EXT_SU] = "he_ext_su",
+		[MT76_TM_TX_MODE_HE_TB] = "he_tb",
+		[MT76_TM_TX_MODE_HE_MU] = "he_mu",
+		[MT76_TM_TX_MODE_EHT_SU] = "eht_su",
+		[MT76_TM_TX_MODE_EHT_TRIG] = "eht_tb",
+		[MT76_TM_TX_MODE_EHT_MU] = "eht_mu",
+	};
+	int i, cbw, dbw;
+
+	if (!phy->mt76->lists) {
+		mt76_err(&dev->mt76, "%s: no available segment list\n", __func__);
+		return 0;
+	}
+
+	mt76_dbg(&dev->mt76, MT76_DBG_TEST,
+		 "Total Segment Number %d:\n", phy->mt76->seg_num);
+	for (i = 0; i < phy->mt76->seg_num; i++) {
+		list = &phy->mt76->lists[i];
+
+		mt76_dbg(&dev->mt76, MT76_DBG_TEST, "%s Segment %d:\n",
+			 list->seg_type == LM_SEG_TYPE_TX ? "TX" : "RX", i);
+		mt76_dbg(&dev->mt76, MT76_DBG_TEST, "\tantenna swap: %d\n", list->ant_swap);
+		mt76_dbg(&dev->mt76, MT76_DBG_TEST,
+			 "\tsegment timeout: %d\n", list->seg_timeout);
+		mt76_dbg(&dev->mt76, MT76_DBG_TEST,
+			 "\ttx antenna mask: %d\n", list->tx_antenna_mask);
+		mt76_dbg(&dev->mt76, MT76_DBG_TEST,
+			 "\trx antenna mask: %d\n", list->rx_antenna_mask);
+		mt76_dbg(&dev->mt76, MT76_DBG_TEST, "\tcenter ch1: %d\n", list->center_ch1);
+		mt76_dbg(&dev->mt76, MT76_DBG_TEST, "\tcenter ch2: %d\n", list->center_ch2);
+		cbw = mt7996_tm_bw_mapping(list->system_bw, BW_MAP_NL_TO_MHZ);
+		dbw = mt7996_tm_bw_mapping(list->data_bw, BW_MAP_NL_TO_MHZ);
+		mt76_dbg(&dev->mt76, MT76_DBG_TEST, "\tsystem bw: %d MH\n", cbw);
+		mt76_dbg(&dev->mt76, MT76_DBG_TEST, "\tdata bw: %d MHz\n", dbw);
+		mt76_dbg(&dev->mt76, MT76_DBG_TEST,
+			 "\tprimary selection: %d\n", list->pri_sel);
+		if (list->seg_type == LM_SEG_TYPE_TX) {
+			mt76_dbg(&dev->mt76, MT76_DBG_TEST, "\tda: %pM\n", list->addr[0]);
+			mt76_dbg(&dev->mt76, MT76_DBG_TEST, "\tsa: %pM\n", list->addr[1]);
+			mt76_dbg(&dev->mt76, MT76_DBG_TEST, "\tbssid: %pM\n", list->addr[2]);
+			mt76_dbg(&dev->mt76, MT76_DBG_TEST,
+				 "\ttx mpdu len: %d\n", list->tx_mpdu_len);
+			mt76_dbg(&dev->mt76, MT76_DBG_TEST,
+				 "\ttx count: %d\n", list->tx_count);
+			mt76_dbg(&dev->mt76, MT76_DBG_TEST,
+				 "\ttx power: %d\n", list->tx_power);
+			mt76_dbg(&dev->mt76, MT76_DBG_TEST, "\ttx rate mode: %s\n",
+				 testmode_tx_mode[list->tx_rate_mode]);
+			mt76_dbg(&dev->mt76, MT76_DBG_TEST,
+				 "\ttx rate idx: %d\n", list->tx_rate_idx);
+			mt76_dbg(&dev->mt76, MT76_DBG_TEST,
+				 "\ttx rate stbc: %d\n", list->tx_rate_stbc);
+			mt76_dbg(&dev->mt76, MT76_DBG_TEST,
+				 "\ttx rate ldpc: %d\n", list->tx_rate_ldpc);
+			mt76_dbg(&dev->mt76, MT76_DBG_TEST, "\ttx ipg: %d\n", list->tx_ipg);
+			mt76_dbg(&dev->mt76, MT76_DBG_TEST,
+				 "\ttx rate sgi: %d\n", list->tx_rate_sgi);
+			mt76_dbg(&dev->mt76, MT76_DBG_TEST,
+				 "\ttx rate nss: %d\n", list->tx_rate_nss);
+			mt76_dbg(&dev->mt76, MT76_DBG_TEST,
+				 "\thw tx mode: %d\n", list->hw_tx_mode);
+		} else {
+			mt76_dbg(&dev->mt76, MT76_DBG_TEST,
+				 "\town addr: %pM\n", list->addr[0]);
+			mt76_dbg(&dev->mt76, MT76_DBG_TEST,
+				 "\tsta idx: %d\n", list->sta_idx);
+		}
+		mt76_dbg(&dev->mt76, MT76_DBG_TEST, "\n");
+	}
+
+	return 0;
+}
+
+static int
+mt7996_tm_get_list_mode_rx_stat(struct mt7996_dev *dev, int ext_id)
+{
+	struct mt7996_tm_list_req req = {
+		.tag = cpu_to_le16(UNI_RF_TEST_LIST_MODE),
+		.len = cpu_to_le16(sizeof(req.seg)),
+		.seg.rx_stat.ext_id = cpu_to_le32(ext_id),
+	};
+	int seg_idx, total_seg, seg_read_num, ret;
+	struct mt7996_tm_list_event *event;
+	struct sk_buff *skb;
+
+	for (seg_idx = 0; seg_idx < LIST_SEG_MAX_NUM;) {
+		struct lm_rx_status *rx_stat;
+		int i;
+
+		req.seg.rx_stat.seg_start_idx = cpu_to_le32(seg_idx);
+		ret = mt76_mcu_send_and_get_msg(&dev->mt76, MCU_WM_UNI_CMD_QUERY(TESTMODE_CTRL),
+						&req, sizeof(req), true, &skb);
+		if (ret)
+			break;
+
+		event = (struct mt7996_tm_list_event *)skb->data;
+		total_seg = le32_to_cpu(event->total_seg);
+		seg_read_num = le32_to_cpu(event->seg_read_num);
+		if (seg_idx == 0)
+			mt76_dbg(&dev->mt76, MT76_DBG_TEST,
+				 "ext_id: %d, status: %d, total_seg: %d, seg_read_num: %d\n",
+				 le32_to_cpu(event->ext_id), le16_to_cpu(event->status),
+				 total_seg, seg_read_num);
+
+		if (!seg_read_num)
+			break;
+
+		for (i = 0; i < seg_read_num; i++) {
+			rx_stat = &event->rx_stats[i];
+			mt76_dbg(&dev->mt76, MT76_DBG_TEST,
+				 "seg_idx: %u, rx_ok: %u, fcs_err: %u\n",
+				 seg_idx + i, le32_to_cpu(rx_stat->rx_ok),
+				 le32_to_cpu(rx_stat->fcs_err));
+			mt76_dbg(&dev->mt76, MT76_DBG_TEST, "rssi: %d, %d, %d, %d, %d\n",
+				 le32_to_cpu(rx_stat->rssi0), le32_to_cpu(rx_stat->rssi1),
+				 le32_to_cpu(rx_stat->rssi2), le32_to_cpu(rx_stat->rssi3),
+				 le32_to_cpu(rx_stat->rssi4));
+		}
+
+		seg_idx += seg_read_num;
+		if (seg_idx >= total_seg)
+			break;
+	}
+
+	return 0;
+}
+
+static int
+mt7996_tm_set_list_mode(struct mt76_phy *mphy, int seg_idx,
+			enum mt76_testmode_list_act list_act)
+{
+	struct mt76_list_mode_data *list = &mphy->lists[seg_idx];
+	struct mt7996_phy *phy = mphy->priv;
+	struct mt7996_dev *dev = phy->dev;
+	struct cfg80211_chan_def *chandef = &mphy->chandef;
+	struct ieee80211_channel *chan = chandef->chan;
+	struct mt7996_tm_list_req req = {
+		.tag = cpu_to_le16(UNI_RF_TEST_LIST_MODE),
+		.len = cpu_to_le16(sizeof(req.seg)),
+	};
+	static const u8 lm_ext_id[] = {
+		[MT76_TM_LM_ACT_SET_TX_SEGMENT] = 16,
+		[MT76_TM_LM_ACT_TX_START] = 17,
+		[MT76_TM_LM_ACT_TX_STOP] = 19,
+		[MT76_TM_LM_ACT_SET_RX_SEGMENT] = 20,
+		[MT76_TM_LM_ACT_RX_START] = 21,
+		[MT76_TM_LM_ACT_RX_STOP] = 23,
+		[MT76_TM_LM_ACT_SWITCH_SEGMENT] = 25,
+		[MT76_TM_LM_ACT_RX_STATUS] = 22,
+		[MT76_TM_LM_ACT_DUT_STATUS] = 24,
+	};
+	static const char * const lm_state[] = {
+		[LM_STATE_IDLE] = "idle",
+		[LM_STATE_DPD_CAL] = "dpd cal",
+		[LM_STATE_TX] = "tx ongoing",
+		[LM_STATE_RX] = "rx ongoing",
+	};
+	int seg_param_num = sizeof(req.seg.tx_seg.rf) / sizeof(u32);
+	int ret, state, band = mt7996_tm_band_mapping(chan->band);
+	struct mt7996_tm_list_event *event;
+	struct sk_buff *skb;
+	u8 cbw, dbw;
+
+	switch (list_act) {
+	case MT76_TM_LM_ACT_SET_TX_SEGMENT:
+		req.seg.tx_seg.hdr.ext_id = cpu_to_le32(lm_ext_id[list_act]);
+		req.seg.tx_seg.hdr.frame_control = cpu_to_le32(0x8);
+		req.seg.tx_seg.hdr.duration = cpu_to_le32(0);
+		req.seg.tx_seg.hdr.seq_id = cpu_to_le32(0);
+		req.seg.tx_seg.hdr.tx_mpdu_len = cpu_to_le32(list->tx_mpdu_len);
+		memcpy(req.seg.tx_seg.hdr.da, list->addr[0], ETH_ALEN);
+		memcpy(req.seg.tx_seg.hdr.sa, list->addr[1], ETH_ALEN);
+		memcpy(req.seg.tx_seg.hdr.bssid, list->addr[2], ETH_ALEN);
+		req.seg.tx_seg.hdr.tx_rate_stbc = cpu_to_le32(list->tx_rate_stbc);
+		req.seg.tx_seg.hdr.seg_num = cpu_to_le32(1);
+		seg_param_num += sizeof(req.seg.tx_seg.tx) / sizeof(u32);
+		req.seg.tx_seg.hdr.seg_param_num = cpu_to_le32(seg_param_num);
+		req.seg.tx_seg.rf.seg_idx = cpu_to_le32(seg_idx);
+		req.seg.tx_seg.rf.band = cpu_to_le32(band);
+		req.seg.tx_seg.rf.band_idx = cpu_to_le32(mphy->band_idx);
+		req.seg.tx_seg.rf.tx_antenna_mask = cpu_to_le32(list->tx_antenna_mask);
+		req.seg.tx_seg.rf.rx_antenna_mask = cpu_to_le32(list->rx_antenna_mask);
+		req.seg.tx_seg.rf.center_ch1 = cpu_to_le32(list->center_ch1);
+		req.seg.tx_seg.rf.center_ch2 = cpu_to_le32(list->center_ch2);
+		cbw = mt7996_tm_bw_mapping(list->system_bw, BW_MAP_NL_TO_TM);
+		dbw = mt7996_tm_bw_mapping(list->data_bw, BW_MAP_NL_TO_TM);
+		req.seg.tx_seg.rf.system_bw = cpu_to_le32(cbw);
+		req.seg.tx_seg.rf.data_bw = cpu_to_le32(dbw);
+		req.seg.tx_seg.rf.pri_sel = cpu_to_le32(list->pri_sel);
+		req.seg.tx_seg.tx.ch_band = cpu_to_le32(band);
+		req.seg.tx_seg.tx.tx_mpdu_len = cpu_to_le32(list->tx_mpdu_len);
+		req.seg.tx_seg.tx.tx_count = cpu_to_le32(list->tx_count);
+		req.seg.tx_seg.tx.tx_power = cpu_to_le32(list->tx_power);
+		req.seg.tx_seg.tx.tx_rate_mode = cpu_to_le32(list->tx_rate_mode);
+		req.seg.tx_seg.tx.tx_rate_idx = cpu_to_le32(list->tx_rate_idx);
+		req.seg.tx_seg.tx.tx_rate_ldpc = cpu_to_le32(list->tx_rate_ldpc);
+		req.seg.tx_seg.tx.tx_ipg = cpu_to_le32(list->tx_ipg);
+		req.seg.tx_seg.tx.tx_rate_sgi = cpu_to_le32(list->tx_rate_sgi);
+		req.seg.tx_seg.tx.tx_rate_nss = cpu_to_le32(list->tx_rate_nss);
+		req.seg.tx_seg.tx.hw_tx_mode = cpu_to_le32(0);
+		req.seg.tx_seg.tx.ant_swap = cpu_to_le32(0);
+		req.seg.tx_seg.tx.seg_timeout = cpu_to_le32(list->seg_timeout);
+		break;
+	case MT76_TM_LM_ACT_SET_RX_SEGMENT:
+		req.seg.rx_seg.hdr.ext_id = cpu_to_le32(lm_ext_id[list_act]);
+		memcpy(req.seg.rx_seg.hdr.addr, list->addr[0], ETH_ALEN);
+		req.seg.rx_seg.hdr.seg_num = cpu_to_le32(1);
+		seg_param_num += sizeof(req.seg.rx_seg.rx) / sizeof(u32);
+		req.seg.rx_seg.hdr.seg_param_num = cpu_to_le32(seg_param_num);
+		req.seg.rx_seg.rf.seg_idx = cpu_to_le32(seg_idx);
+		req.seg.rx_seg.rf.band = cpu_to_le32(band);
+		req.seg.rx_seg.rf.band_idx = cpu_to_le32(mphy->band_idx);
+		req.seg.rx_seg.rf.tx_antenna_mask = cpu_to_le32(list->tx_antenna_mask);
+		req.seg.rx_seg.rf.rx_antenna_mask = cpu_to_le32(list->rx_antenna_mask);
+		req.seg.rx_seg.rf.center_ch1 = cpu_to_le32(list->center_ch1);
+		req.seg.rx_seg.rf.center_ch2 = cpu_to_le32(list->center_ch2);
+		cbw = mt7996_tm_bw_mapping(list->system_bw, BW_MAP_NL_TO_TM);
+		dbw = mt7996_tm_bw_mapping(list->data_bw, BW_MAP_NL_TO_TM);
+		req.seg.rx_seg.rf.system_bw = cpu_to_le32(cbw);
+		req.seg.rx_seg.rf.data_bw = cpu_to_le32(dbw);
+		req.seg.rx_seg.rf.pri_sel = cpu_to_le32(list->pri_sel);
+		req.seg.rx_seg.rx.sta_idx = cpu_to_le32(list->sta_idx);
+		req.seg.rx_seg.rx.ch_band = cpu_to_le32(band);
+		req.seg.rx_seg.rx.ant_swap = cpu_to_le32(0);
+		req.seg.rx_seg.rx.seg_timeout = cpu_to_le32(list->seg_timeout);
+		break;
+	case MT76_TM_LM_ACT_TX_START:
+	case MT76_TM_LM_ACT_TX_STOP:
+	case MT76_TM_LM_ACT_RX_START:
+	case MT76_TM_LM_ACT_RX_STOP:
+	case MT76_TM_LM_ACT_SWITCH_SEGMENT:
+	case MT76_TM_LM_ACT_DUT_STATUS:
+		req.seg.ext_id = cpu_to_le32(lm_ext_id[list_act]);
+		break;
+	case MT76_TM_LM_ACT_RX_STATUS:
+		return mt7996_tm_get_list_mode_rx_stat(dev, lm_ext_id[list_act]);
+	case MT76_TM_LM_ACT_CLEAR_SEGMENT:
+		kfree(mphy->lists);
+		mphy->lists = NULL;
+		mphy->seg_num = 0;
+		return 0;
+	case MT76_TM_LM_ACT_DUMP_SEGMENT:
+		return mt7996_tm_dump_seg_list(phy);
+	default:
+		return -EINVAL;
+	}
+
+	ret = mt76_mcu_send_and_get_msg(&dev->mt76, MCU_WM_UNI_CMD_QUERY(TESTMODE_CTRL),
+					&req, sizeof(req), true, &skb);
+	if (ret)
+		return ret;
+
+	event = (struct mt7996_tm_list_event *)skb->data;
+	mt76_dbg(&dev->mt76, MT76_DBG_TEST,
+		 "ext_id: %u, status: %u, total_seg: %u, seg_read_num: %u\n",
+		 le32_to_cpu(event->ext_id), le16_to_cpu(event->status),
+		 le32_to_cpu(event->total_seg), le32_to_cpu(event->seg_read_num));
+
+	state = le32_to_cpu(event->event_state.state);
+	if (list_act == MT76_TM_LM_ACT_DUT_STATUS && state < LM_STATE_NUM)
+		mt76_dbg(&dev->mt76, MT76_DBG_TEST, "Event seg_idx: %u, state: %s\n",
+			 le32_to_cpu(event->event_state.seg_idx), lm_state[state]);
+
+	dev_kfree_skb(skb);
+
+	return ret;
+}
+
+static int
+mt7996_tm_set_sta_ru_info(struct mt76_phy *mphy, bool init)
+{
+	struct mt76_testmode_data *td = &mphy->test;
+	struct mt7996_phy *phy = mphy->priv;
+	struct mt7996_dev *dev = phy->dev;
+	struct mt76_sta_ru_info *sta;
+	u8 sta_addr[ETH_ALEN] = {0};
+	union ru_data ru;
+
+	mt7996_tm_set(dev, SET_ID(BAND_IDX), phy->mt76->band_idx);
+	if (init) {
+		mt7996_tm_set(dev, SET_ID(RU_INFO_NUM), td->ru_sta_num);
+		return 0;
+	}
+
+	mt7996_tm_set(dev, SET_ID(RU_STA_IDX), td->ru_sta_idx);
+	/* let FW generate random address */
+	mt7996_tm_set_mac_addr(dev, sta_addr, SET_ID(RU_STA_ADDR));
+
+	sta = &td->sta_ru_info[td->ru_sta_idx];
+
+	ru.data = 0;
+	ru.dw0.aid = sta->aid;
+	ru.dw0.rate_idx = sta->tx_rate_idx;
+	ru.dw0.nss = sta->tx_rate_nss;
+	ru.dw0.mu_nss = sta->tx_rate_nss;
+	ru.dw0.ss_idx = sta->ss_idx;
+	ru.dw0.pri_seg_80 = sta->seg_idx & BIT(0);
+	ru.dw0.pri_seg_160 = sta->seg_idx & BIT(1);
+	ru.dw0.ldpc = sta->tx_rate_ldpc;
+	ru.dw0.valid = true;
+	mt7996_tm_set(dev, SET_ID(RU_INFO_DW0), ru.data);
+
+	ru.data = 0;
+	ru.dw1.ru_alloc = sta->ru_alloc;
+	ru.dw1.ru_idx = sta->ru_idx;
+	mt7996_tm_set(dev, SET_ID(RU_INFO_DW1), ru.data);
+
+	ru.data = 0;
+	ru.dw2.tx_length = sta->tx_mpdu_len;
+	mt7996_tm_set(dev, SET_ID(RU_TX_LEN), sta->tx_mpdu_len);
+	mt7996_tm_set(dev, SET_ID(RU_INFO_DW2), ru.data);
+
+	return 0;
+}
+
+const struct mt76_testmode_ops mt7996_testmode_ops = {
+	.set_state = mt7996_tm_set_state,
+	.set_params = mt7996_tm_set_params,
+	.dump_stats = mt7996_tm_dump_stats,
+	.reset_rx_stats = mt7996_tm_reset_trx_stats,
+	.tx_stop = mt7996_tm_tx_stop,
+	.set_eeprom = mt7996_tm_set_eeprom,
+	.dump_precal = mt7996_tm_dump_precal,
+	.set_list_mode = mt7996_tm_set_list_mode,
+	.set_sta_ru_info = mt7996_tm_set_sta_ru_info,
+	.dump_tb_info = mt7996_tm_dump_tb_info,
+	.dump_icap = mt7996_tm_dump_icap,
+};
diff --git a/mt7996/testmode.h b/mt7996/testmode.h
new file mode 100644
index 000000000..94f2d466c
--- /dev/null
+++ b/mt7996/testmode.h
@@ -0,0 +1,658 @@
+/* SPDX-License-Identifier: ISC */
+/* Copyright (C) 2020 MediaTek Inc. */
+
+#ifndef __MT7996_TESTMODE_H
+#define __MT7996_TESTMODE_H
+
+enum tm_bw {
+	TM_CBW_20MHZ,
+	TM_CBW_40MHZ,
+	TM_CBW_80MHZ,
+	TM_CBW_10MHZ,
+	TM_CBW_5MHZ,
+	TM_CBW_160MHZ,
+	TM_CBW_8080MHZ,
+	TM_CBW_320MHZ = 12,
+};
+
+/* BW defined in FW hal_cal_flow_rom.h */
+enum {
+	FW_CDBW_20MHZ,
+	FW_CDBW_40MHZ,
+	FW_CDBW_80MHZ,
+	FW_CDBW_160MHZ,
+	FW_CDBW_320MHZ,
+	FW_CDBW_5MHZ,
+	FW_CDBW_10MHZ,
+	FW_CDBW_8080MHZ,
+};
+
+enum bf_bw {
+	BF_CDBW_20MHZ,
+	BF_CDBW_40MHZ,
+	BF_CDBW_80MHZ,
+	BF_CDBW_160MHZ,
+	BF_CDBW_320MHZ,
+	BF_CDBW_10MHZ = BF_CDBW_320MHZ,
+	BF_CDBW_5MHZ,
+	BF_CDBW_8080MHZ,
+};
+
+enum icap_bw {
+	ICAP_BW_20MHZ,
+	ICAP_BW_40MHZ,
+	ICAP_BW_80MHZ,
+	ICAP_BW_8080MHZ,
+	ICAP_BW_160MHZ,
+	ICAP_BW_320MHZ,
+};
+
+#define FIRST_CONTROL_CHAN_BITMAP_BW40		2
+#define FIRST_CONTROL_CHAN_BITMAP_BW80		4
+#define FIRST_CONTROL_CHAN_BITMAP_BW160		0x10010101
+
+enum bw_mapping_method {
+	BW_MAP_NL_TO_FW,
+	BW_MAP_NL_TO_TM,
+	BW_MAP_NL_TO_BF,
+	BW_MAP_NL_TO_MHZ,
+	BW_MAP_NL_TO_CONTROL_BITMAP_5G,
+	BW_MAP_NL_TO_ICAP,
+
+	NUM_BW_MAP,
+};
+
+enum tm_phy_mode {
+	TM_PHY_MODE_CCK,
+	TM_PHY_MODE_OFDM,
+	TM_PHY_MODE_HT,
+	TM_PHY_MODE_HT_GF,
+	TM_PHY_MODE_VHT,
+	TM_PHY_MODE_HE_SU = 8,
+	TM_PHY_MODE_HE_EXT_SU,
+	TM_PHY_MODE_HE_TB,
+	TM_PHY_MODE_HE_MU,
+	TM_PHY_MODE_EHT_SU = 13,
+	TM_PHY_MODE_EHT_MU = 15,
+	TM_PHY_MODE_EHT_TRIG,
+};
+
+enum rate_mapping_type {
+	RATE_MODE_TO_PHY,
+	RATE_MODE_TO_LM,
+
+	NUM_RATE_MAP,
+};
+
+struct tm_cal_param {
+	__le32 func_data;
+	u8 band_idx;
+	u8 rsv[3];
+};
+
+struct tm_icap_param {
+	__le32 enable;
+	__le32 ring_buffer;
+	__le32 trigger_event;
+	__le32 node;
+	__le32 len;
+	__le32 cycle;
+	__le32 mac_trigger_event;
+	__le32 addr_lsb;
+	__le32 addr_msb;
+	__le32 band_idx;
+	__le32 bandwidth;
+	__le32 bit_width;
+	__le32 mode;
+	__le32 phy_idx;
+	__le32 emi_start_addr;
+	__le32 emi_end_addr;
+	__le32 emi_msb_addr;
+	__le32 src;
+	__le32 path;
+	__le32 rx_gain;
+	__le32 rsv[2];
+};
+
+struct tm_icap_dump {
+	__le32 addr;
+	__le32 addr_offset;
+	__le32 bank;
+	__le32 bank_size;	/* unit: kbytes */
+	__le32 path;
+	__le32 iq_type;
+	__le32 rsv[6];
+};
+
+struct mt7996_tm_rf_test {
+	__le16 tag;
+	__le16 len;
+
+	u8 action;
+	u8 icap_len;
+	u8 icap_attr;
+	u8 _rsv;
+	union {
+		__le32 op_mode;
+		__le32 freq;
+
+		struct {
+			__le32 func_idx;
+			union {
+				__le32 func_data;
+				__le32 cal_dump;
+				struct tm_cal_param cal_param;
+				struct tm_icap_param icap_param;
+				struct tm_icap_dump icap_dump;
+				u8 _pad[88];
+			} param;
+		} rf;
+	} op;
+} __packed;
+
+struct mt7996_tm_req {
+	u8 _rsv[4];
+
+	struct mt7996_tm_rf_test rf_test;
+} __packed;
+
+struct mt7996_tm_rf_test_data {
+	__le32 cal_idx;
+	__le32 cal_type;
+	u8 cal_data[0];
+} __packed;
+
+struct mt7996_tm_rf_test_result {
+	__le32 func_idx;
+	union {
+		__le32 func_data;
+		__le32 payload_length;
+		__le32 capture_done;
+	};
+	u8 data[0];
+} __packed;
+
+struct mt7996_tm_rf_test_icap {
+	__le32 func_idx;
+	__le32 pkt_num;
+	__le32 bank;
+	__le32 len;
+	__le32 path_num;
+	__le32 sample_count;
+	__le32 rsv[6];
+	__le32 data[MT_TM_ICAP_SAMPLE_LEN];
+} __packed;
+
+struct mt7996_tm_event {
+	u8 _rsv[4];
+
+	__le16 tag;
+	__le16 len;
+	union {
+		struct mt7996_tm_rf_test_result result;
+		struct mt7996_tm_rf_test_icap icap;
+	};
+} __packed;
+
+enum rf_test_tag {
+	UNI_RF_TEST_CTRL,
+	UNI_RF_TEST_LIST_MODE,
+};
+
+enum rf_test_action {
+	RF_ACTION_SWITCH_TO_RF_TEST,
+	RF_ACTION_IN_RF_TEST,
+	RF_ACTION_SET = 3,
+	RF_ACTION_GET,
+};
+
+#define RF_TEST_ICAP_LEN	120
+
+enum rf_test_op_mode {
+	RF_OPER_NORMAL,
+	RF_OPER_RF_TEST,
+	RF_OPER_ICAP,
+	RF_OPER_ICAP_OVERLAP,
+	RF_OPER_WIFI_SPECTRUM,
+};
+
+/* func_idx for RF_ACTION_IN_RF_TEST */
+enum rf_test_func_idx {
+	RF_TEST_RE_CAL = 0x01,
+	RF_TEST_SET_ICAP = 0x0b,
+	RF_TEST_GET_ICAP_STATUS = 0x0c,
+	RF_TEST_GET_ICAP_RAW_DATA = 0x11,
+	RF_TEST_RX_GAIN_CAL = 0x14,
+};
+
+#define SET_ID(id)		RF_TEST_ID_SET_##id
+#define GET_ID(id)		RF_TEST_ID_GET_##id
+
+/* func_idx for RF_ACTION_SET & RF_ACTION_GET */
+enum rf_test_id {
+	RF_TEST_ID_SET_COMMAND = 1,
+	RF_TEST_ID_SET_POWER = 2,
+	RF_TEST_ID_SET_TX_RATE = 3,
+	RF_TEST_ID_SET_TX_MODE = 4,
+	RF_TEST_ID_SET_TX_LEN = 6,
+	RF_TEST_ID_SET_TX_COUNT = 7,
+	RF_TEST_ID_SET_IPG = 8,
+	RF_TEST_ID_SET_GI = 16,
+	RF_TEST_ID_SET_STBC = 17,
+	RF_TEST_ID_SET_CHAN_FREQ = 18,
+	RF_TEST_ID_GET_TXED_COUNT = 32,
+	RF_TEST_ID_SET_CONT_WAVE_MODE = 65,
+	RF_TEST_ID_SET_DA = 68,
+	RF_TEST_ID_SET_SA = 69,
+	RF_TEST_ID_SET_CBW = 71,
+	RF_TEST_ID_SET_DBW = 72,
+	RF_TEST_ID_SET_PRIMARY_CH = 73,
+	RF_TEST_ID_SET_ENCODE_MODE = 74,
+	RF_TEST_ID_SET_BAND = 90,
+	RF_TEST_ID_SET_TRX_COUNTER_RESET = 91,
+	RF_TEST_ID_SET_RX_FILTER = 93,
+	RF_TEST_ID_SET_TX_TONE_TYPE = 98,
+	RF_TEST_ID_SET_TX_TONE_DC_OFFSET = 99,
+	RF_TEST_ID_SET_TX_TONE_BW = 100,
+	RF_TEST_ID_SET_MAC_HEADER = 101,
+	RF_TEST_ID_SET_SEQ_CTRL = 102,
+	RF_TEST_ID_SET_PAYLOAD = 103,
+	RF_TEST_ID_SET_BAND_IDX = 104,
+	RF_TEST_ID_SET_RX_PATH = 106,
+	RF_TEST_ID_SET_FREQ_OFFSET = 107,
+	RF_TEST_ID_GET_FREQ_OFFSET = 108,
+	RF_TEST_ID_SET_TX_PATH = 113,
+	RF_TEST_ID_SET_NSS = 114,
+	RF_TEST_ID_SET_ANT_MASK = 115,
+	RF_TEST_ID_SET_CAL_BITMAP = 125,
+	RF_TEST_ID_SET_IBF_ENABLE = 126,
+	RF_TEST_ID_SET_EBF_ENABLE = 127,
+	RF_TEST_ID_GET_TX_POWER = 136,
+	RF_TEST_ID_SET_RX_MU_AID = 157,
+	RF_TEST_ID_SET_HW_TX_MODE = 167,
+	RF_TEST_ID_SET_PUNCTURE = 168,
+	RF_TEST_ID_SET_FREQ_OFFSET_C2 = 171,
+	RF_TEST_ID_GET_FREQ_OFFSET_C2 = 172,
+	RF_TEST_ID_SET_CFG_ON = 176,
+	RF_TEST_ID_SET_CFG_OFF = 177,
+	RF_TEST_ID_SET_RU_INFO_NUM = 178,
+	RF_TEST_ID_SET_RU_INFO_DW0 = 179,
+	RF_TEST_ID_SET_RU_INFO_DW1 = 180,
+	RF_TEST_ID_SET_RU_INFO_DW2 = 181,
+	RF_TEST_ID_GET_TB_INFO_A_FACTOR = 182,
+	RF_TEST_ID_GET_TB_INFO_LDPC_EXT_SYM = 183,
+	RF_TEST_ID_GET_TB_INFO_PE_DISAMB = 184,
+	RF_TEST_ID_GET_TB_INFO_TX_PE = 185,
+	RF_TEST_ID_GET_TB_INFO_L_SIG_LEN = 186,
+	RF_TEST_ID_SET_RU_STA_IDX = 187,
+	RF_TEST_ID_SET_RU_STA_ADDR = 188,
+	RF_TEST_ID_SET_BSSID = 189,
+	RF_TEST_ID_SET_TX_TIME = 190,
+	RF_TEST_ID_SET_MAX_PKT_EXT = 191,
+	RF_TEST_ID_SET_AID_OFFSET = 204,
+	RF_TEST_ID_SET_RU_TX_LEN = 208,
+};
+
+#define RF_CMD(cmd)		RF_TEST_CMD_##cmd
+
+/* func_data for RF_TEST_ID_SET_COMMAND */
+enum rf_test_cmd {
+	RF_TEST_CMD_STOP_TEST = 0,
+	RF_TEST_CMD_START_TX = 1,
+	RF_TEST_CMD_START_RX = 2,
+	RF_TEST_CMD_CONT_WAVE = 10,
+	RF_TEST_CMD_TX_TONE = 15,
+	RF_TEST_CMD_TX_COMMIT = 18,
+	RF_TEST_CMD_RX_COMMIT = 19,
+};
+
+#define POWER_CTRL(type)	UNI_TXPOWER_##type##_CTRL
+
+struct mt7996_tm_rx_stat_user_ctrl {
+	__le16 tag;
+	__le16 len;
+
+	u8 band_idx;
+	u8 rsv;
+	__le16 user_idx;
+} __packed;
+
+struct mt7996_tm_rx_stat_all {
+	__le16 tag;
+	__le16 len;
+
+	u8 band_idx;
+	u8 rsv[3];
+} __packed;
+
+struct mt7996_tm_rx_req {
+	u8 band;
+	u8 _rsv[3];
+
+	union {
+		struct mt7996_tm_rx_stat_user_ctrl user_ctrl;
+		struct mt7996_tm_rx_stat_all rx_stat_all;
+	};
+} __packed;
+
+enum rx_stat_tag {
+	UNI_TM_RX_STAT_SET_USER_CTRL = 7,
+	UNI_TM_RX_STAT_GET_ALL_V2 = 9,
+};
+
+struct rx_band_info {
+	/* mac part */
+	__le16 mac_rx_fcs_err_cnt;
+	__le16 mac_rx_len_mismatch;
+	__le16 mac_rx_fcs_ok_cnt;
+	u8 rsv1[2];
+	__le32 mac_rx_mdrdy_cnt;
+
+	/* phy part */
+	__le16 phy_rx_fcs_err_cnt_cck;
+	__le16 phy_rx_fcs_err_cnt_ofdm;
+	__le16 phy_rx_pd_cck;
+	__le16 phy_rx_pd_ofdm;
+	__le16 phy_rx_sig_err_cck;
+	__le16 phy_rx_sfd_err_cck;
+	__le16 phy_rx_sig_err_ofdm;
+	__le16 phy_rx_tag_err_ofdm;
+	__le16 phy_rx_mdrdy_cnt_cck;
+	__le16 phy_rx_mdrdy_cnt_ofdm;
+} __packed;
+
+struct rx_band_info_ext {
+	/* mac part */
+	__le32 mac_rx_mpdu_cnt;
+
+	/* phy part */
+	u8 rsv[4];
+} __packed;
+
+struct rx_common_info {
+	__le16 rx_fifo_full;
+	u8 rsv[2];
+	__le32 aci_hit_low;
+	__le32 aci_hit_high;
+} __packed;
+
+struct rx_common_info_ext {
+	__le32 driver_rx_count;
+	__le32 sinr;
+	__le32 mu_pkt_count;
+
+	/* mac part */
+	u8 _rsv[4];
+
+	/* phy part */
+	u8 sig_mcs;
+	u8 rsv[3];
+} __packed;
+
+struct rx_rxv_info {
+	__le16 rcpi;
+	s16 rssi;
+	s16 snr;
+	s16 adc_rssi;
+} __packed;
+
+struct rx_rssi_info {
+	s8 ib_rssi;
+	s8 wb_rssi;
+	u8 rsv[2];
+} __packed;
+
+struct rx_user_info {
+	s32 freq_offset;
+	s32 snr;
+	__le32 fcs_err_count;
+} __packed;
+
+struct rx_user_info_ext {
+	s8 ne_var_db_all_user;
+	u8 rsv[3];
+} __packed;
+
+#define MAX_ANTENNA_NUM		8
+#define MAX_USER_NUM		16
+
+struct mt7996_tm_rx_event_stat_all {
+	__le16 tag;
+	__le16 len;
+
+	struct rx_band_info band_info;
+	struct rx_band_info_ext band_info_ext;
+	struct rx_common_info common_info;
+	struct rx_common_info_ext common_info_ext;
+
+	/* RXV info */
+	struct rx_rxv_info rxv_info[MAX_ANTENNA_NUM];
+
+	/* RSSI info */
+	struct rx_rssi_info fagc[MAX_ANTENNA_NUM];
+	struct rx_rssi_info inst[MAX_ANTENNA_NUM];
+
+	/* User info */
+	struct rx_user_info user_info[MAX_USER_NUM];
+	struct rx_user_info_ext user_info_ext[MAX_USER_NUM];
+} __packed;
+
+struct mt7996_tm_rx_event {
+	u8 _rsv[4];
+
+	union {
+		struct mt7996_tm_rx_event_stat_all rx_stat_all;
+	};
+} __packed;
+
+enum rdd_ipi_cmd {
+	RDD_SET_IPI_CR_INIT,		/* CR initialization */
+	RDD_SET_IPI_HIST_RESET,		/* Reset IPI histogram counter */
+	RDD_SET_IDLE_POWER,		/* Idle power info */
+	RDD_SET_IPI_HIST_NUM
+};
+
+enum rdd_ipi_hist {
+	RDD_IPI_HIST_0,			/* IPI count for power <= -92 (dBm) */
+	RDD_IPI_HIST_1,			/* IPI count for -92 < power <= -89 (dBm) */
+	RDD_IPI_HIST_2,			/* IPI count for -89 < power <= -86 (dBm) */
+	RDD_IPI_HIST_3,			/* IPI count for -86 < power <= -83 (dBm) */
+	RDD_IPI_HIST_4,			/* IPI count for -83 < power <= -80 (dBm) */
+	RDD_IPI_HIST_5,			/* IPI count for -80 < power <= -75 (dBm) */
+	RDD_IPI_HIST_6,			/* IPI count for -75 < power <= -70 (dBm) */
+	RDD_IPI_HIST_7,			/* IPI count for -70 < power <= -65 (dBm) */
+	RDD_IPI_HIST_8,			/* IPI count for -65 < power <= -60 (dBm) */
+	RDD_IPI_HIST_9,			/* IPI count for -60 < power <= -55 (dBm) */
+	RDD_IPI_HIST_10,		/* IPI count for -55 < power        (dBm) */
+	RDD_IPI_FREE_RUN_CNT,		/* IPI count for counter++ per 8 us */
+	RDD_IPI_HIST_ALL_CNT,		/* Get all IPI */
+	RDD_IPI_HIST_0_TO_10_CNT,	/* Get IPI histogram 0 to 10 */
+	RDD_IPI_HIST_2_TO_10_CNT,	/* Get IPI histogram 2 to 10 */
+	RDD_TX_ASSERT_TIME,		/* Get band 1 TX assert time */
+	RDD_IPI_HIST_NUM
+};
+
+#define POWER_INDICATE_HIST_MAX		RDD_IPI_FREE_RUN_CNT
+#define IPI_HIST_TYPE_NUM		(POWER_INDICATE_HIST_MAX + 1)
+
+struct mt7996_tm_rdd_ipi_ctrl {
+	u8 ipi_hist_idx;
+	u8 band_idx;
+	u8 rsv[2];
+	__le32 ipi_hist_val[IPI_HIST_TYPE_NUM];
+	__le32 tx_assert_time;		/* unit: us */
+} __packed;
+
+struct efuse_region {
+	u16 start;
+	u16 end;
+	u16 prot_mask;
+};
+
+/* list mode */
+
+struct lm_tx_seg_hdr {
+	__le32 ext_id;
+	__le32 frame_control;
+	__le32 duration;
+	__le32 seq_id;
+	__le32 tx_mpdu_len;
+	u8 da[ETH_ALEN];
+	u8 sa[ETH_ALEN];
+	u8 bssid[ETH_ALEN];
+	__le32 tx_rate_stbc;
+	__le32 seg_num;
+	__le32 seg_param_num;
+} __packed;
+
+struct lm_rx_seg_hdr {
+	__le32 ext_id;
+	u8 addr[ETH_ALEN];
+	__le32 seg_num;
+	__le32 seg_param_num;
+} __packed;
+
+struct lm_rf_setting {
+	__le32 seg_idx;
+	__le32 band;
+	__le32 band_idx;
+	__le32 tx_antenna_mask;
+	__le32 rx_antenna_mask;
+	__le32 center_ch1;
+	__le32 center_ch2;
+	__le32 system_bw;
+	__le32 data_bw;
+	__le32 pri_sel;
+} __packed;
+
+struct lm_tx_setting {
+	__le32 ch_band;
+	__le32 tx_mpdu_len;
+	__le32 tx_count;
+	__le32 tx_power;
+	__le32 tx_rate_mode;
+	__le32 tx_rate_idx;
+	__le32 tx_rate_ldpc;
+	__le32 tx_ipg;
+	__le32 tx_rate_sgi;
+	__le32 tx_rate_nss;
+	__le32 hw_tx_mode;
+	__le32 ant_swap;
+	__le32 seg_timeout;
+} __packed;
+
+struct lm_rx_setting {
+	__le32 sta_idx;
+	__le32 ch_band;
+	__le32 ant_swap;
+	__le32 seg_timeout;
+} __packed;
+
+struct mt7996_tm_list_tx_seg {
+	struct lm_tx_seg_hdr hdr;
+	struct lm_rf_setting rf;
+	struct lm_tx_setting tx;
+};
+
+struct mt7996_tm_list_rx_seg {
+	struct lm_rx_seg_hdr hdr;
+	struct lm_rf_setting rf;
+	struct lm_rx_setting rx;
+};
+
+struct mt7996_tm_list_rx_stat {
+	__le32 ext_id;
+	__le32 seg_start_idx;
+} __packed;
+
+struct mt7996_tm_list_req {
+	u8 _rsv[4];
+
+	__le16 tag;
+	__le16 len;
+	union {
+		struct mt7996_tm_list_tx_seg tx_seg;
+		struct mt7996_tm_list_rx_seg rx_seg;
+		struct mt7996_tm_list_rx_stat rx_stat;
+		__le32 ext_id;
+	} seg;
+} __packed;
+
+enum lm_state {
+	LM_STATE_IDLE,
+	LM_STATE_DPD_CAL,
+	LM_STATE_TX,
+	LM_STATE_RX,
+	LM_STATE_NUM,
+};
+
+struct lm_event_state {
+	enum lm_state state;
+	__le32 seg_idx;
+} __packed;
+
+struct lm_rx_status {
+	__le32 rx_ok;
+	__le32 fcs_err;
+	s32 rssi0;
+	s32 rssi1;
+	s32 rssi2;
+	s32 rssi3;
+	s32 rssi4;
+} __packed;
+
+struct mt7996_tm_list_event {
+	/* FIXME: the actual event data has two extra byte */
+	u8 rsv[2];
+
+	__le16 status;
+	__le32 ext_id;
+	__le32 total_seg;
+	__le32 seg_read_num;
+	union {
+		DECLARE_FLEX_ARRAY(__le32, tx_stats);
+		DECLARE_FLEX_ARRAY(struct lm_rx_status, rx_stats);
+		struct lm_event_state event_state;
+		u8 event[1024];
+	};
+} __packed;
+
+union ru_data {
+	__le32 data;
+	struct {
+		u8 aid;
+		u8 rate_idx;
+		__le16 distributed_ru:1;
+		__le16 rsv:2;
+		__le16 nss:3;
+		__le16 mu_nss:3;
+		__le16 ss_idx:3;
+		__le16 pri_seg_80:1;
+		__le16 pri_seg_160:1;
+		__le16 ldpc:1;
+		__le16 valid:1;
+	} __packed dw0;
+	struct {
+		__le16 ru_alloc:9;
+		__le16 ru_idx:7;
+		__le16 alpha;
+	} __packed dw1;
+	struct {
+		__le32 tx_length:20;
+		__le32 mu_group_id:4;
+		__le32 vht_up:4;
+		__le32 vht_gid:4;
+	} __packed dw2;
+};
+
+enum cfg_type {
+	CFG_SET_TSSI = 0,
+	CFG_SET_DPD = 1,
+	CFG_SET_RATE_POWER_OFFSET = 2,
+	CFG_SET_THERMAL_COMP = 4,
+	CFG_SET_BAND_POWER = 10,
+	CFG_SET_TMAC = 15,
+	CFG_SET_RMAC = 16,
+};
+
+#endif
diff --git a/testmode.c b/testmode.c
index 6ee160bda..9a1b78f2a 100644
--- a/testmode.c
+++ b/testmode.c
@@ -2,11 +2,13 @@
 /* Copyright (C) 2020 Felix Fietkau <nbd@nbd.name> */
 
 #include <linux/random.h>
+#include "mt76_connac.h"
 #include "mt76.h"
 
 const struct nla_policy mt76_tm_policy[NUM_MT76_TM_ATTRS] = {
 	[MT76_TM_ATTR_RESET] = { .type = NLA_FLAG },
 	[MT76_TM_ATTR_STATE] = { .type = NLA_U8 },
+	[MT76_TM_ATTR_SKU_EN] = { .type = NLA_U8 },
 	[MT76_TM_ATTR_TX_COUNT] = { .type = NLA_U32 },
 	[MT76_TM_ATTR_TX_LENGTH] = { .type = NLA_U32 },
 	[MT76_TM_ATTR_TX_RATE_MODE] = { .type = NLA_U8 },
@@ -23,11 +25,50 @@ const struct nla_policy mt76_tm_policy[NUM_MT76_TM_ATTRS] = {
 	[MT76_TM_ATTR_TX_DUTY_CYCLE] = { .type = NLA_U8 },
 	[MT76_TM_ATTR_TX_IPG] = { .type = NLA_U32 },
 	[MT76_TM_ATTR_TX_TIME] = { .type = NLA_U32 },
+	[MT76_TM_ATTR_TX_PKT_BW] = { .type = NLA_U8 },
+	[MT76_TM_ATTR_TX_PRI_SEL] = { .type = NLA_U8 },
 	[MT76_TM_ATTR_FREQ_OFFSET] = { .type = NLA_U32 },
 	[MT76_TM_ATTR_DRV_DATA] = { .type = NLA_NESTED },
+	[MT76_TM_ATTR_OFF_CH_SCAN_CH] = { .type = NLA_U8 },
+	[MT76_TM_ATTR_OFF_CH_SCAN_CENTER_CH] = { .type = NLA_U8 },
+	[MT76_TM_ATTR_OFF_CH_SCAN_BW] = { .type = NLA_U8 },
+	[MT76_TM_ATTR_OFF_CH_SCAN_PATH] = { .type = NLA_U8 },
+	[MT76_TM_ATTR_IPI_THRESHOLD] = { .type = NLA_U8 },
+	[MT76_TM_ATTR_IPI_PERIOD] = { .type = NLA_U32 },
+	[MT76_TM_ATTR_IPI_RESET] = { .type = NLA_U8 },
+	[MT76_TM_ATTR_LM_ACT] = { .type = NLA_U8 },
+	[MT76_TM_ATTR_LM_SEG_IDX] = { .type = NLA_U8 },
+	[MT76_TM_ATTR_LM_CENTER_CH] = { .type = NLA_U8 },
+	[MT76_TM_ATTR_LM_CBW] = { .type = NLA_U8 },
+	[MT76_TM_ATTR_LM_STA_IDX] = { .type = NLA_U8 },
+	[MT76_TM_ATTR_LM_SEG_TIMEOUT] = { .type = NLA_U32 },
+	[MT76_TM_ATTR_FAST_CAL] = { .type = NLA_U8 },
+	[MT76_TM_ATTR_FRAME_CONTROL] = { .type = NLA_U16 },
+	[MT76_TM_ATTR_DURATION] = { .type = NLA_U16 },
+	[MT76_TM_ATTR_SEQ_IDX] = { .type = NLA_U16 },
+	[MT76_TM_ATTR_PAYLOAD_RULE] = { .type = NLA_U8 },
+	[MT76_TM_ATTR_PAYLOAD] = { .type = NLA_U8 },
+	[MT76_TM_ATTR_MAX_PKT_EXT] = { .type = NLA_U8 },
+	[MT76_TM_ATTR_RU_STA_NUM] = { .type = NLA_U8 },
+	[MT76_TM_ATTR_RU_STA_IDX] = { .type = NLA_U8 },
+	[MT76_TM_ATTR_RU_SEG_IDX] = { .type = NLA_U8 },
+	[MT76_TM_ATTR_RU_SS_IDX] = { .type = NLA_U8 },
+	[MT76_TM_ATTR_RX_FILTER] = { .type = NLA_U32 },
+	[MT76_TM_ATTR_TX_TONE_TYPE] = { .type = NLA_U8 },
+	[MT76_TM_ATTR_TX_TONE_BW] = { .type = NLA_U8 },
+	[MT76_TM_ATTR_TX_TONE_DC_OFFSET] = { .type = NLA_NESTED },
 };
 EXPORT_SYMBOL_GPL(mt76_tm_policy);
 
+static inline bool mt76_testmode_offload(struct mt76_dev *dev)
+{
+	return is_mt799x(dev);
+}
+
+MT76_TM_NLA_GET(u8)
+MT76_TM_NLA_GET(u16)
+MT76_TM_NLA_GET(u32)
+
 void mt76_testmode_tx_pending(struct mt76_phy *phy)
 {
 	struct mt76_testmode_data *td = &phy->test;
@@ -82,6 +123,11 @@ mt76_testmode_max_mpdu_len(struct mt76_phy *phy, u8 tx_rate_mode)
 		    IEEE80211_VHT_CAP_MAX_MPDU_LENGTH_7991)
 			return IEEE80211_MAX_MPDU_LEN_VHT_7991;
 		return IEEE80211_MAX_MPDU_LEN_VHT_11454;
+	case MT76_TM_TX_MODE_EHT_SU:
+	case MT76_TM_TX_MODE_EHT_TRIG:
+	case MT76_TM_TX_MODE_EHT_MU:
+		/* TODO: check the limit */
+		return UINT_MAX;
 	case MT76_TM_TX_MODE_CCK:
 	case MT76_TM_TX_MODE_OFDM:
 	default:
@@ -174,6 +220,114 @@ int mt76_testmode_alloc_skb(struct mt76_phy *phy, u32 len)
 }
 EXPORT_SYMBOL(mt76_testmode_alloc_skb);
 
+static int
+mt76_testmode_tx_config_check(struct mt76_phy *phy)
+{
+	struct mt76_dev *dev = phy->dev;
+	struct mt76_testmode_data *td = &phy->test;
+	struct cfg80211_chan_def *chandef = &phy->chandef;
+	u8 max_nss = hweight8(phy->antenna_mask);
+	enum invalid_type {
+		INVALID_TYPE_TX_LEN,
+		INVALID_TYPE_RATE_MODE,
+		INVALID_TYPE_RATE_IDX,
+		INVALID_TYPE_RATE_NSS,
+		INVALID_TYPE_LDPC,
+	} type;
+	static const char * const invalid_msg[] = {
+		[INVALID_TYPE_TX_LEN] = "tx length",
+		[INVALID_TYPE_RATE_MODE] = "tx rate mode",
+		[INVALID_TYPE_RATE_IDX] = "tx rate idx",
+		[INVALID_TYPE_RATE_NSS] = "tx rate nss",
+		[INVALID_TYPE_LDPC] = "tx rate ldpc",
+	};
+	u32 max_tx_len;
+
+	max_tx_len = mt76_testmode_max_mpdu_len(phy, td->tx_rate_mode);
+	if (max_tx_len < td->tx_mpdu_len ||
+	    sizeof(struct ieee80211_hdr) > td->tx_mpdu_len) {
+		type = INVALID_TYPE_TX_LEN;
+		goto fail;
+	}
+
+	if (td->tx_antenna_mask)
+		max_nss = min_t(u8, max_nss, hweight8(td->tx_antenna_mask));
+
+	switch (td->tx_rate_mode) {
+	case MT76_TM_TX_MODE_CCK:
+		if (chandef->chan->band != NL80211_BAND_2GHZ) {
+			type = INVALID_TYPE_RATE_MODE;
+			goto fail;
+		}
+		if (td->tx_rate_idx > 3) {
+			type = INVALID_TYPE_RATE_IDX;
+			goto fail;
+		}
+		break;
+	case MT76_TM_TX_MODE_OFDM:
+		if (td->tx_rate_idx > 7) {
+			type = INVALID_TYPE_RATE_IDX;
+			goto fail;
+		}
+		break;
+	case MT76_TM_TX_MODE_HT:
+		if (td->tx_rate_idx > 8 * max_nss - 1) {
+			type = INVALID_TYPE_RATE_IDX;
+			goto fail;
+		}
+		break;
+	case MT76_TM_TX_MODE_VHT:
+		if (td->tx_rate_nss > max_nss) {
+			type = INVALID_TYPE_RATE_IDX;
+			goto fail;
+		}
+		if (td->tx_rate_idx > 9) {
+			type = INVALID_TYPE_RATE_IDX;
+			goto fail;
+		}
+		break;
+	case MT76_TM_TX_MODE_HE_SU:
+	case MT76_TM_TX_MODE_HE_EXT_SU:
+	case MT76_TM_TX_MODE_HE_TB:
+	case MT76_TM_TX_MODE_HE_MU:
+		if (td->tx_rate_nss > max_nss) {
+			type = INVALID_TYPE_RATE_IDX;
+			goto fail;
+		}
+		if (td->tx_rate_idx > 11) {
+			type = INVALID_TYPE_RATE_IDX;
+			goto fail;
+		}
+		if (chandef->width > NL80211_CHAN_WIDTH_20 &&
+		    !td->tx_rate_ldpc) {
+			type = INVALID_TYPE_LDPC;
+			goto fail;
+		}
+		break;
+	case MT76_TM_TX_MODE_EHT_SU:
+	case MT76_TM_TX_MODE_EHT_TRIG:
+	case MT76_TM_TX_MODE_EHT_MU:
+		if (td->tx_rate_idx > 15) {
+			type = INVALID_TYPE_RATE_IDX;
+			goto fail;
+		}
+		if (chandef->width > NL80211_CHAN_WIDTH_20 &&
+		    !td->tx_rate_ldpc) {
+			type = INVALID_TYPE_LDPC;
+			goto fail;
+		}
+		break;
+	default:
+		type = INVALID_TYPE_RATE_MODE;
+		goto fail;
+	}
+
+	return 0;
+fail:
+	mt76_err(dev, "%s: invalid %s\n", __func__, invalid_msg[type]);
+	return -EINVAL;
+}
+
 static int
 mt76_testmode_tx_init(struct mt76_phy *phy)
 {
@@ -183,6 +337,13 @@ mt76_testmode_tx_init(struct mt76_phy *phy)
 	u8 max_nss = hweight8(phy->antenna_mask);
 	int ret;
 
+	ret = mt76_testmode_tx_config_check(phy);
+	if (ret)
+		return ret;
+
+	if (mt76_testmode_offload(phy->dev))
+		return 0;
+
 	ret = mt76_testmode_alloc_skb(phy, td->tx_mpdu_len);
 	if (ret)
 		return ret;
@@ -200,36 +361,17 @@ mt76_testmode_tx_init(struct mt76_phy *phy)
 
 	switch (td->tx_rate_mode) {
 	case MT76_TM_TX_MODE_CCK:
-		if (phy->chandef.chan->band != NL80211_BAND_2GHZ)
-			return -EINVAL;
-
-		if (rate->idx > 4)
-			return -EINVAL;
 		break;
 	case MT76_TM_TX_MODE_OFDM:
 		if (phy->chandef.chan->band != NL80211_BAND_2GHZ)
 			break;
 
-		if (rate->idx > 8)
-			return -EINVAL;
-
 		rate->idx += 4;
 		break;
 	case MT76_TM_TX_MODE_HT:
-		if (rate->idx > 8 * max_nss &&
-			!(rate->idx == 32 &&
-			  phy->chandef.width >= NL80211_CHAN_WIDTH_40))
-			return -EINVAL;
-
 		rate->flags |= IEEE80211_TX_RC_MCS;
 		break;
 	case MT76_TM_TX_MODE_VHT:
-		if (rate->idx > 9)
-			return -EINVAL;
-
-		if (td->tx_rate_nss > max_nss)
-			return -EINVAL;
-
 		ieee80211_rate_set_vht(rate, td->tx_rate_idx, td->tx_rate_nss);
 		rate->flags |= IEEE80211_TX_RC_VHT_MCS;
 		break;
@@ -275,7 +417,9 @@ mt76_testmode_tx_start(struct mt76_phy *phy)
 	td->tx_queued = 0;
 	td->tx_done = 0;
 	td->tx_pending = td->tx_count;
-	mt76_worker_schedule(&dev->tx_worker);
+
+	if (!mt76_testmode_offload(dev))
+		mt76_worker_schedule(&dev->tx_worker);
 }
 
 static void
@@ -284,6 +428,11 @@ mt76_testmode_tx_stop(struct mt76_phy *phy)
 	struct mt76_testmode_data *td = &phy->test;
 	struct mt76_dev *dev = phy->dev;
 
+	if (mt76_testmode_offload(dev) && dev->test_ops->tx_stop) {
+		dev->test_ops->tx_stop(phy);
+		return;
+	}
+
 	mt76_worker_disable(&dev->tx_worker);
 
 	td->tx_pending = 0;
@@ -296,22 +445,11 @@ mt76_testmode_tx_stop(struct mt76_phy *phy)
 	mt76_testmode_free_skb(phy);
 }
 
-static inline void
-mt76_testmode_param_set(struct mt76_testmode_data *td, u16 idx)
-{
-	td->param_set[idx / 32] |= BIT(idx % 32);
-}
-
-static inline bool
-mt76_testmode_param_present(struct mt76_testmode_data *td, u16 idx)
-{
-	return td->param_set[idx / 32] & BIT(idx % 32);
-}
-
 static void
 mt76_testmode_init_defaults(struct mt76_phy *phy)
 {
 	struct mt76_testmode_data *td = &phy->test;
+	u8 addr[ETH_ALEN] = {0x00, 0x11, 0x22, 0xaa, 0xbb, 0xcc + phy->band_idx};
 
 	if (td->tx_mpdu_len > 0)
 		return;
@@ -319,11 +457,24 @@ mt76_testmode_init_defaults(struct mt76_phy *phy)
 	td->tx_mpdu_len = 1024;
 	td->tx_count = 1;
 	td->tx_rate_mode = MT76_TM_TX_MODE_OFDM;
+	td->tx_rate_idx = 7;
 	td->tx_rate_nss = 1;
-
-	memcpy(td->addr[0], phy->macaddr, ETH_ALEN);
-	memcpy(td->addr[1], phy->macaddr, ETH_ALEN);
-	memcpy(td->addr[2], phy->macaddr, ETH_ALEN);
+	/* 0xffff for OFDMA no puncture */
+	td->tx_preamble_puncture = ~(td->tx_preamble_puncture & 0);
+	td->tx_ipg = 50;
+
+	/* rx stat user config */
+	td->aid = 1;
+
+	/* Qos Data */
+	td->fc = 0x88;
+	td->payload_rule = MT76_TM_PAYLOAD_RULE_RANDOM;
+	td->payload = 0xaa;
+	td->max_pkt_ext = MT76_TM_MAX_PKT_EXT_8US;
+
+	memcpy(td->addr[0], addr, ETH_ALEN);
+	memcpy(td->addr[1], addr, ETH_ALEN);
+	memcpy(td->addr[2], addr, ETH_ALEN);
 }
 
 static int
@@ -333,7 +484,7 @@ __mt76_testmode_set_state(struct mt76_phy *phy, enum mt76_testmode_state state)
 	struct mt76_dev *dev = phy->dev;
 	int err;
 
-	if (prev_state == MT76_TM_STATE_TX_FRAMES)
+	if (prev_state == MT76_TM_STATE_TX_FRAMES && state != MT76_TM_STATE_ICAP)
 		mt76_testmode_tx_stop(phy);
 
 	if (state == MT76_TM_STATE_TX_FRAMES) {
@@ -342,6 +493,9 @@ __mt76_testmode_set_state(struct mt76_phy *phy, enum mt76_testmode_state state)
 			return err;
 	}
 
+	if (state == MT76_TM_STATE_RX_FRAMES)
+		dev->test_ops->reset_rx_stats(phy);
+
 	err = dev->test_ops->set_state(phy, state);
 	if (err) {
 		if (state == MT76_TM_STATE_TX_FRAMES)
@@ -352,9 +506,8 @@ __mt76_testmode_set_state(struct mt76_phy *phy, enum mt76_testmode_state state)
 
 	if (state == MT76_TM_STATE_TX_FRAMES)
 		mt76_testmode_tx_start(phy);
-	else if (state == MT76_TM_STATE_RX_FRAMES) {
-		memset(&phy->test.rx_stats, 0, sizeof(phy->test.rx_stats));
-	}
+	else if (state == MT76_TM_STATE_RX_GAIN_CAL)
+		return 0;
 
 	phy->test.state = state;
 
@@ -365,19 +518,30 @@ int mt76_testmode_set_state(struct mt76_phy *phy, enum mt76_testmode_state state
 {
 	struct mt76_testmode_data *td = &phy->test;
 	struct ieee80211_hw *hw = phy->hw;
+	int ret;
 
 	if (state == td->state && state == MT76_TM_STATE_OFF)
 		return 0;
 
 	if (state > MT76_TM_STATE_OFF &&
 	    (!test_bit(MT76_STATE_RUNNING, &phy->state) ||
-	     !(hw->conf.flags & IEEE80211_CONF_MONITOR)))
+	     (!(hw->conf.flags & IEEE80211_CONF_MONITOR) &&
+	      !phy->monitor_vif)))
 		return -ENOTCONN;
 
+	/* keep rx while performing rx gain calibration */
+	if (state == MT76_TM_STATE_RX_GAIN_CAL) {
+		if (td->state != MT76_TM_STATE_RX_FRAMES) {
+			ret = __mt76_testmode_set_state(phy, MT76_TM_STATE_RX_FRAMES);
+			if (ret)
+				return ret;
+		}
+		return __mt76_testmode_set_state(phy, state);
+	}
+
 	if (state != MT76_TM_STATE_IDLE &&
+	    state != MT76_TM_STATE_ICAP &&
 	    td->state != MT76_TM_STATE_IDLE) {
-		int ret;
-
 		ret = __mt76_testmode_set_state(phy, MT76_TM_STATE_IDLE);
 		if (ret)
 			return ret;
@@ -388,25 +552,325 @@ int mt76_testmode_set_state(struct mt76_phy *phy, enum mt76_testmode_state state
 }
 EXPORT_SYMBOL(mt76_testmode_set_state);
 
+static void
+mt76_testmode_list_init_defaults(struct mt76_phy *phy, u8 seg_idx, u8 seg_type)
+{
+	struct mt76_list_mode_data *list = &phy->lists[seg_idx];
+	u8 addr[ETH_ALEN] = {phy->band_idx, 0x11, 0x22, 0x33, 0x44, 0x55};
+
+	list->seg_type = seg_type;
+	list->seg_timeout = 200;
+	/* rf settings */
+	memcpy(list->addr[0], addr, ETH_ALEN);
+	memcpy(list->addr[1], addr, ETH_ALEN);
+	memcpy(list->addr[2], addr, ETH_ALEN);
+	list->tx_antenna_mask = phy->antenna_mask;
+	list->rx_antenna_mask = phy->antenna_mask;
+	if (phy->chandef.chan)
+		list->center_ch1 = phy->chandef.chan->hw_value;
+
+	/* tx settings */
+	list->tx_mpdu_len = 1024;
+	list->tx_count = 1000;
+	list->tx_power = 23;
+	list->tx_rate_mode = MT76_TM_TX_MODE_OFDM;
+	list->tx_rate_idx = 7;
+	list->tx_rate_nss = 1;
+	list->tx_ipg = 50;
+}
+
 static int
-mt76_tm_get_u8(struct nlattr *attr, u8 *dest, u8 min, u8 max)
+mt76_testmode_set_list_mode(struct mt76_phy *phy, struct nlattr **tb)
 {
-	u8 val;
+	struct mt76_dev *dev = phy->dev;
+	struct mt76_list_mode_data *list;
+	u8 list_act, seg_idx, seg_type;
+	u8 min_ch, max_ch;
+	int err;
 
-	if (!attr)
-		return 0;
+	if (!dev->test_ops->set_list_mode)
+		return -EOPNOTSUPP;
+
+	err = mt76_tm_get_u8(tb[MT76_TM_ATTR_LM_ACT], &list_act, 0, MT76_TM_LM_ACT_MAX);
+	if (err)
+		return err;
+
+	if (list_act != MT76_TM_LM_ACT_SET_TX_SEGMENT &&
+	    list_act != MT76_TM_LM_ACT_SET_RX_SEGMENT)
+		return dev->test_ops->set_list_mode(phy, 0, list_act);
 
-	val = nla_get_u8(attr);
-	if (val < min || val > max)
+	if (!tb[MT76_TM_ATTR_LM_SEG_IDX] ||
+	    mt76_tm_get_u8(tb[MT76_TM_ATTR_LM_SEG_IDX], &seg_idx, 0, LIST_SEG_MAX_NUM) ||
+	    seg_idx > phy->seg_num)
 		return -EINVAL;
 
-	*dest = val;
+	if (list_act == MT76_TM_LM_ACT_SET_TX_SEGMENT)
+		seg_type = LM_SEG_TYPE_TX;
+	else
+		seg_type = LM_SEG_TYPE_RX;
+
+	if (!phy->lists) {
+		phy->lists = kzalloc(sizeof(*phy->lists), GFP_KERNEL);
+		if (!phy->lists)
+			return -ENOMEM;
+
+		phy->seg_num = 1;
+		mt76_testmode_list_init_defaults(phy, seg_idx, seg_type);
+	} else {
+		/* mixed segment type is not allowed */
+		if (phy->lists[0].seg_type != seg_type)
+			return -EINVAL;
+		if (seg_idx == phy->seg_num) {
+			unsigned long size;
+			void *tmp;
+
+			phy->seg_num++;
+			size = sizeof(*phy->lists) * phy->seg_num;
+			tmp = krealloc((void *)phy->lists, size, GFP_KERNEL);
+			if (!tmp)
+				return -ENOMEM;
+
+			phy->lists = (struct mt76_list_mode_data *)tmp;
+			mt76_testmode_list_init_defaults(phy, seg_idx, seg_type);
+		}
+	}
+
+	list = &phy->lists[seg_idx];
+
+	if (tb[MT76_TM_ATTR_LM_CENTER_CH]) {
+		struct ieee80211_supported_band *sband = NULL;
+		int n_channels;
+
+		if (phy->cap.has_2ghz)
+			sband = &phy->sband_2g.sband;
+		if (phy->cap.has_5ghz)
+			sband = &phy->sband_5g.sband;
+		if (phy->cap.has_6ghz)
+			sband = &phy->sband_6g.sband;
+		if (!sband)
+			return -EINVAL;
+
+		n_channels = sband->n_channels;
+		min_ch = sband->channels[0].hw_value;
+		max_ch = sband->channels[n_channels - 1].hw_value;
+	}
+
+	if (mt76_tm_get_u8(tb[MT76_TM_ATTR_TX_ANTENNA], &list->tx_antenna_mask, 0, 0xff) ||
+	    mt76_tm_get_u8(tb[MT76_TM_ATTR_TX_ANTENNA], &list->rx_antenna_mask, 0, 0xff) ||
+	    mt76_tm_get_u8(tb[MT76_TM_ATTR_LM_CBW], &list->system_bw,
+			   NL80211_CHAN_WIDTH_20_NOHT, NL80211_CHAN_WIDTH_320) ||
+	    mt76_tm_get_u8(tb[MT76_TM_ATTR_TX_PKT_BW], &list->data_bw,
+			   NL80211_CHAN_WIDTH_20_NOHT, NL80211_CHAN_WIDTH_320) ||
+	    mt76_tm_get_u8(tb[MT76_TM_ATTR_TX_PRI_SEL], &list->pri_sel, 0, 15) ||
+	    mt76_tm_get_u8(tb[MT76_TM_ATTR_TX_RATE_MODE], &list->tx_rate_mode,
+			   0, MT76_TM_TX_MODE_MAX) ||
+	    mt76_tm_get_u8(tb[MT76_TM_ATTR_TX_RATE_IDX], &list->tx_rate_idx, 0, 31) ||
+	    mt76_tm_get_u8(tb[MT76_TM_ATTR_TX_RATE_NSS], &list->tx_rate_nss,
+			   1, hweight8(phy->antenna_mask)) ||
+	    mt76_tm_get_u8(tb[MT76_TM_ATTR_TX_RATE_SGI], &list->tx_rate_sgi, 0, 2) ||
+	    mt76_tm_get_u8(tb[MT76_TM_ATTR_TX_RATE_LDPC], &list->tx_rate_ldpc, 0, 1) ||
+	    mt76_tm_get_u8(tb[MT76_TM_ATTR_TX_RATE_STBC], &list->tx_rate_stbc, 0, 1) ||
+	    mt76_tm_get_u8(tb[MT76_TM_ATTR_LM_CENTER_CH], &list->center_ch1, min_ch, max_ch))
+		return -EINVAL;
+
+	if (mt76_tm_get_u16(tb[MT76_TM_ATTR_TX_LENGTH], &list->tx_mpdu_len,
+			    sizeof(struct ieee80211_hdr),
+			    mt76_testmode_max_mpdu_len(phy, list->tx_rate_mode)))
+		return -EINVAL;
+
+	if (mt76_tm_get_u32(tb[MT76_TM_ATTR_TX_COUNT], &list->tx_count, 1, UINT_MAX) ||
+	    mt76_tm_get_u32(tb[MT76_TM_ATTR_TX_IPG], &list->tx_ipg,
+			    MT76_TM_MIN_IPG, MT76_TM_MAX_IPG) ||
+	    mt76_tm_get_u32(tb[MT76_TM_ATTR_LM_SEG_TIMEOUT], &list->seg_timeout, 0, UINT_MAX) ||
+	    mt76_tm_get_u32(tb[MT76_TM_ATTR_LM_STA_IDX], &list->sta_idx, 0, 16))
+		return -EINVAL;
+
+	if (tb[MT76_TM_ATTR_MAC_ADDRS]) {
+		struct nlattr *cur;
+		int idx = 0;
+		int rem;
+
+		nla_for_each_nested(cur, tb[MT76_TM_ATTR_MAC_ADDRS], rem) {
+			if (nla_len(cur) != ETH_ALEN || idx >= ARRAY_SIZE(list->addr))
+				return -EINVAL;
+
+			memcpy(list->addr[idx], nla_data(cur), ETH_ALEN);
+			idx++;
+		}
+	}
+
+	if (tb[MT76_TM_ATTR_TX_POWER]) {
+		struct nlattr *cur;
+		int idx = 0;
+		int rem;
+
+		nla_for_each_nested(cur, tb[MT76_TM_ATTR_TX_POWER], rem) {
+			if (nla_len(cur) != 1 || idx >= 1)
+				return -EINVAL;
+
+			err = mt76_tm_get_u8(cur, &list->tx_power, 0, 63);
+			if (err)
+				return err;
+			idx++;
+		}
+	}
+
+	err = dev->test_ops->set_list_mode(phy, seg_idx, list_act);
+
+	return err;
+}
+
+static int
+mt76_testmode_set_ru_sta(struct mt76_phy *phy, struct nlattr **tb)
+{
+	struct mt76_testmode_data *td = &phy->test;
+	struct mt76_dev *dev = phy->dev;
+	int ret = -EINVAL;
+
+	if (!dev->test_ops->set_sta_ru_info) {
+		ret = -EOPNOTSUPP;
+		goto out;
+	}
+
+	if (tb[MT76_TM_ATTR_RU_STA_NUM]) {
+		if (mt76_tm_get_u8(tb[MT76_TM_ATTR_RU_STA_NUM], &td->ru_sta_num,
+				   1, MT_TM_MAX_MU_STA))
+			goto out;
+
+		devm_kfree(dev->dev, td->sta_ru_info);
+		td->sta_ru_info = devm_kcalloc(dev->dev, td->ru_sta_num,
+					       sizeof(*td->sta_ru_info), GFP_KERNEL);
+		if (!td->sta_ru_info) {
+			ret = -ENOMEM;
+			goto out;
+		}
+
+		if (dev->test_ops->set_sta_ru_info(phy, true))
+			goto out;
+	}
+
+	if (tb[MT76_TM_ATTR_RU_STA_IDX]) {
+		struct mt76_sta_ru_info *sta;
+
+		if (!td->ru_sta_num ||
+		    mt76_tm_get_u8(tb[MT76_TM_ATTR_RU_STA_IDX], &td->ru_sta_idx,
+				   0, td->ru_sta_num - 1))
+			goto out;
+
+		if (!tb[MT76_TM_ATTR_AID] || !tb[MT76_TM_ATTR_RU_ALLOC] ||
+		    !tb[MT76_TM_ATTR_RU_IDX] || !tb[MT76_TM_ATTR_RU_SEG_IDX])
+			goto out;
+
+		sta = &td->sta_ru_info[td->ru_sta_idx];
+
+		if (mt76_tm_get_u8(tb[MT76_TM_ATTR_TX_RATE_IDX], &sta->tx_rate_idx, 0, 15) ||
+		    mt76_tm_get_u8(tb[MT76_TM_ATTR_AID], &sta->aid, 0, MT_TM_MAX_MU_STA) ||
+		    mt76_tm_get_u8(tb[MT76_TM_ATTR_RU_ALLOC], &sta->ru_alloc, 0, 255) ||
+		    mt76_tm_get_u8(tb[MT76_TM_ATTR_RU_IDX], &sta->ru_idx, 0, 107) ||
+		    mt76_tm_get_u8(tb[MT76_TM_ATTR_RU_SEG_IDX], &sta->seg_idx, 0, 3))
+			goto out;
+
+		if (mt76_tm_get_u8(tb[MT76_TM_ATTR_TX_RATE_LDPC], &sta->tx_rate_ldpc, 0, 1) ||
+		    mt76_tm_get_u8(tb[MT76_TM_ATTR_TX_RATE_NSS], &sta->tx_rate_nss,
+				   1, hweight8(phy->antenna_mask)) ||
+		    mt76_tm_get_u8(tb[MT76_TM_ATTR_RU_SS_IDX], &sta->ss_idx,
+				   0, hweight8(phy->antenna_mask) - 1))
+			goto out;
+
+		if (mt76_tm_get_u16(tb[MT76_TM_ATTR_TX_LENGTH], &sta->tx_mpdu_len,
+				    sizeof(struct ieee80211_hdr),
+				    mt76_testmode_max_mpdu_len(phy, td->tx_rate_mode)))
+			goto out;
+
+		if (dev->test_ops->set_sta_ru_info(phy, false))
+			goto out;
+	}
+
+	ret = 0;
+out:
+	return ret;
+}
+
+static int
+mt76_testmode_set_eeprom(struct mt76_phy *phy, struct nlattr **tb)
+{
+	struct mt76_dev *dev = phy->dev;
+	u8 action, val[MT76_TM_EEPROM_BLOCK_SIZE];
+	u32 offset = 0;
+	int err = -EINVAL;
+
+	if (!dev->test_ops->set_eeprom)
+		return -EOPNOTSUPP;
+
+	if (mt76_tm_get_u8(tb[MT76_TM_ATTR_EEPROM_ACTION], &action,
+			   0, MT76_TM_EEPROM_ACTION_MAX))
+		goto out;
+
+	if (tb[MT76_TM_ATTR_EEPROM_OFFSET]) {
+		struct nlattr *cur;
+		int rem, idx = 0;
+
+		offset = nla_get_u32(tb[MT76_TM_ATTR_EEPROM_OFFSET]);
+		if (!!(offset % MT76_TM_EEPROM_BLOCK_SIZE) ||
+		    !tb[MT76_TM_ATTR_EEPROM_VAL])
+			goto out;
+
+		nla_for_each_nested(cur, tb[MT76_TM_ATTR_EEPROM_VAL], rem) {
+			if (nla_len(cur) != 1 || idx >= ARRAY_SIZE(val))
+				goto out;
+
+			val[idx++] = nla_get_u8(cur);
+		}
+	}
+
+	err = dev->test_ops->set_eeprom(phy, offset, val, action);
+
+out:
+	return err;
+}
+
+static int
+mt76_testmode_txbf_profile_update_all_cmd(struct mt76_phy *phy, struct nlattr **tb, u32 state)
+{
+#define PARAM_UNIT	5
+#define PARAM_UNIT_5X5	6
+	static u8 pfmu_idx;
+	struct mt76_testmode_data *td = &phy->test;
+	struct mt76_dev *dev = phy->dev;
+	struct nlattr *cur;
+	u16 tmp_val[PARAM_UNIT_5X5], *val = td->txbf_param;
+	int idx, rem, ret, i = 0;
+	int param_len = hweight16(phy->chainmask) == 5 ? PARAM_UNIT_5X5 : PARAM_UNIT;
+
+	memset(td->txbf_param, 0, sizeof(td->txbf_param));
+	nla_for_each_nested(cur, tb[MT76_TM_ATTR_TXBF_PARAM], rem) {
+		if (nla_len(cur) != 2)
+			return -EINVAL;
+		idx = i % param_len;
+		tmp_val[idx] = nla_get_u16(cur);
+		if (idx == 1 && (tmp_val[idx] == 0xf0 || tmp_val[idx] == 0xff)) {
+			pfmu_idx = tmp_val[0];
+			return 0;
+		}
+		if (idx == param_len - 1) {
+			val[0] = pfmu_idx;
+			memcpy(val + 1, tmp_val, param_len * sizeof(u16));
+			if (dev->test_ops->set_params) {
+				ret = dev->test_ops->set_params(phy, tb, state);
+				if (ret)
+					return ret;
+			}
+		}
+		i++;
+	}
+
 	return 0;
 }
 
 int mt76_testmode_cmd(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 		      void *data, int len)
 {
+#define MT76_TM_MAX_PPDU_TX_TIME	5484
 	struct mt76_phy *phy = hw->priv;
 	struct mt76_dev *dev = phy->dev;
 	struct mt76_testmode_data *td = &phy->test;
@@ -427,6 +891,34 @@ int mt76_testmode_cmd(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 
 	mutex_lock(&dev->mutex);
 
+	/* handle radio conversion for single multi-radio wiphy */
+	if (tb[MT76_TM_ATTR_RADIO_IDX]) {
+		u32 radio_idx;
+
+		radio_idx = nla_get_u32(tb[MT76_TM_ATTR_RADIO_IDX]);
+		if (radio_idx > __MT_MAX_BAND ||
+		    !dev->radio_phy[radio_idx])
+			goto out;
+
+		phy = dev->radio_phy[radio_idx];
+		td = &phy->test;
+	}
+
+	if (tb[MT76_TM_ATTR_LM_ACT]) {
+		err = mt76_testmode_set_list_mode(phy, tb);
+		goto out;
+	}
+
+	if (tb[MT76_TM_ATTR_RU_STA_NUM] || tb[MT76_TM_ATTR_RU_STA_IDX]) {
+		err = mt76_testmode_set_ru_sta(phy, tb);
+		goto out;
+	}
+
+	if (tb[MT76_TM_ATTR_EEPROM_ACTION]) {
+		err = mt76_testmode_set_eeprom(phy, tb);
+		goto out;
+	}
+
 	if (tb[MT76_TM_ATTR_RESET]) {
 		mt76_testmode_set_state(phy, MT76_TM_STATE_OFF);
 		memset(td, 0, sizeof(*td));
@@ -434,47 +926,79 @@ int mt76_testmode_cmd(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 
 	mt76_testmode_init_defaults(phy);
 
-	if (tb[MT76_TM_ATTR_TX_COUNT])
-		td->tx_count = nla_get_u32(tb[MT76_TM_ATTR_TX_COUNT]);
-
-	if (tb[MT76_TM_ATTR_TX_RATE_IDX])
-		td->tx_rate_idx = nla_get_u8(tb[MT76_TM_ATTR_TX_RATE_IDX]);
-
 	if (mt76_tm_get_u8(tb[MT76_TM_ATTR_TX_RATE_MODE], &td->tx_rate_mode,
 			   0, MT76_TM_TX_MODE_MAX) ||
+	    mt76_tm_get_u8(tb[MT76_TM_ATTR_TX_RATE_IDX], &td->tx_rate_idx, 0, 31) ||
 	    mt76_tm_get_u8(tb[MT76_TM_ATTR_TX_RATE_NSS], &td->tx_rate_nss,
 			   1, hweight8(phy->antenna_mask)) ||
 	    mt76_tm_get_u8(tb[MT76_TM_ATTR_TX_RATE_SGI], &td->tx_rate_sgi, 0, 2) ||
 	    mt76_tm_get_u8(tb[MT76_TM_ATTR_TX_RATE_LDPC], &td->tx_rate_ldpc, 0, 1) ||
 	    mt76_tm_get_u8(tb[MT76_TM_ATTR_TX_RATE_STBC], &td->tx_rate_stbc, 0, 1) ||
 	    mt76_tm_get_u8(tb[MT76_TM_ATTR_TX_LTF], &td->tx_ltf, 0, 2) ||
-	    mt76_tm_get_u8(tb[MT76_TM_ATTR_TX_ANTENNA],
-			   &td->tx_antenna_mask, 0, 0xff) ||
+	    mt76_tm_get_u8(tb[MT76_TM_ATTR_TX_ANTENNA], &td->tx_antenna_mask, 0, 0xff) ||
 	    mt76_tm_get_u8(tb[MT76_TM_ATTR_TX_SPE_IDX], &td->tx_spe_idx, 0, 27) ||
-	    mt76_tm_get_u8(tb[MT76_TM_ATTR_TX_DUTY_CYCLE],
-			   &td->tx_duty_cycle, 0, 99) ||
-	    mt76_tm_get_u8(tb[MT76_TM_ATTR_TX_POWER_CONTROL],
-			   &td->tx_power_control, 0, 1))
+	    mt76_tm_get_u8(tb[MT76_TM_ATTR_TX_DUTY_CYCLE], &td->tx_duty_cycle, 0, 99) ||
+	    mt76_tm_get_u8(tb[MT76_TM_ATTR_TX_POWER_CONTROL], &td->tx_power_control, 0, 1) ||
+	    mt76_tm_get_u8(tb[MT76_TM_ATTR_TX_PKT_BW], &td->tx_pkt_bw,
+			   NL80211_CHAN_WIDTH_20_NOHT, NL80211_CHAN_WIDTH_320) ||
+	    mt76_tm_get_u8(tb[MT76_TM_ATTR_TX_PRI_SEL], &td->tx_pri_sel, 0, 15) ||
+	    mt76_tm_get_u8(tb[MT76_TM_ATTR_AID], &td->aid, 0, 16) ||
+	    mt76_tm_get_u8(tb[MT76_TM_ATTR_OFF_CH_SCAN_CH], &td->offchan_ch, 36, 196) ||
+	    mt76_tm_get_u8(tb[MT76_TM_ATTR_OFF_CH_SCAN_CENTER_CH], &td->offchan_center_ch,
+			   36, 196) ||
+	    mt76_tm_get_u8(tb[MT76_TM_ATTR_OFF_CH_SCAN_BW], &td->offchan_bw,
+			   NL80211_CHAN_WIDTH_20_NOHT, NL80211_CHAN_WIDTH_160) ||
+	    mt76_tm_get_u8(tb[MT76_TM_ATTR_IPI_THRESHOLD], &td->ipi_threshold, 0, 10) ||
+	    mt76_tm_get_u8(tb[MT76_TM_ATTR_IPI_RESET], &td->ipi_reset, 0, 1) ||
+	    mt76_tm_get_u8(tb[MT76_TM_ATTR_FAST_CAL], &td->fast_cal,
+			   0, MT76_TM_FAST_CAL_TYPE_MAX) ||
+	    mt76_tm_get_u8(tb[MT76_TM_ATTR_SKU_EN], &td->sku_en, 0, 1) ||
+	    mt76_tm_get_u8(tb[MT76_TM_ATTR_PAYLOAD_RULE], &td->payload_rule,
+			   0, MT76_TM_PAYLOAD_RULE_MAX) ||
+	    mt76_tm_get_u8(tb[MT76_TM_ATTR_PAYLOAD], &td->payload, 0, 0xff) ||
+	    mt76_tm_get_u8(tb[MT76_TM_ATTR_MAX_PKT_EXT], &td->max_pkt_ext,
+			   0, MT76_TM_MAX_PKT_EXT_MAX) ||
+	    mt76_tm_get_u8(tb[MT76_TM_ATTR_ICAP_RING], &td->icap.ring_buffer, 0, 1) ||
+	    mt76_tm_get_u8(tb[MT76_TM_ATTR_ICAP_BANDWIDTH], &td->icap.bandwidth,
+			   NL80211_CHAN_WIDTH_20_NOHT, NL80211_CHAN_WIDTH_320) ||
+	    mt76_tm_get_u8(tb[MT76_TM_ATTR_ICAP_SRC], &td->icap.src, 0, ICAP_SRC_AFE) ||
+	    mt76_tm_get_u8(tb[MT76_TM_ATTR_ICAP_IQ_TYPE], &td->icap.iq_type,
+			   0, DATA_TYPE_Q) ||
+	    mt76_tm_get_u8(tb[MT76_TM_ATTR_ICAP_PATH], &td->icap.path,
+			   0, hweight16(phy->chainmask) - 1) ||
+	    mt76_tm_get_u8(tb[MT76_TM_ATTR_TX_TONE_TYPE], &td->tone.type,
+			   0, MT76_TM_TX_TONE_TYPE_MAX) ||
+	    mt76_tm_get_u8(tb[MT76_TM_ATTR_TX_TONE_BW], &td->tone.bw,
+			   0, MT76_TM_TX_TONE_BW_MAX))
 		goto out;
 
-	if (tb[MT76_TM_ATTR_TX_LENGTH]) {
-		u32 val = nla_get_u32(tb[MT76_TM_ATTR_TX_LENGTH]);
-
-		if (val > mt76_testmode_max_mpdu_len(phy, td->tx_rate_mode) ||
-		    val < sizeof(struct ieee80211_hdr))
-			goto out;
-
-		td->tx_mpdu_len = val;
-	}
-
-	if (tb[MT76_TM_ATTR_TX_IPG])
-		td->tx_ipg = nla_get_u32(tb[MT76_TM_ATTR_TX_IPG]);
+	if (mt76_tm_get_u16(tb[MT76_TM_ATTR_TX_LENGTH], &td->tx_mpdu_len,
+			    sizeof(struct ieee80211_hdr),
+			    mt76_testmode_max_mpdu_len(phy, td->tx_rate_mode)) ||
+	    mt76_tm_get_u16(tb[MT76_TM_ATTR_FRAME_CONTROL], &td->fc, 0, 0xffff) ||
+	    mt76_tm_get_u16(tb[MT76_TM_ATTR_DURATION], &td->dur, 0, 0x7fff) ||
+	    mt76_tm_get_u16(tb[MT76_TM_ATTR_SEQ_IDX], &td->seq, 0, GENMASK(11, 0)))
+		goto out;
 
-	if (tb[MT76_TM_ATTR_TX_TIME])
-		td->tx_time = nla_get_u32(tb[MT76_TM_ATTR_TX_TIME]);
+	if (mt76_tm_get_u32(tb[MT76_TM_ATTR_TX_COUNT], &td->tx_count, 1, UINT_MAX) ||
+	    mt76_tm_get_u32(tb[MT76_TM_ATTR_TX_IPG], &td->tx_ipg,
+			    MT76_TM_MIN_IPG, MT76_TM_MAX_IPG) ||
+	    mt76_tm_get_u32(tb[MT76_TM_ATTR_FREQ_OFFSET], &td->freq_offset, 0, 127) ||
+	    mt76_tm_get_u32(tb[MT76_TM_ATTR_IPI_PERIOD], &td->ipi_period, 0, 10000) ||
+	    mt76_tm_get_u32(tb[MT76_TM_ATTR_TX_TIME], &td->tx_time,
+			    0, MT76_TM_MAX_PPDU_TX_TIME) ||
+	    mt76_tm_get_u32(tb[MT76_TM_ATTR_RX_FILTER], &td->rx_filter,
+			    0, GENMASK(23, 0)))
+		goto out;
 
-	if (tb[MT76_TM_ATTR_FREQ_OFFSET])
-		td->freq_offset = nla_get_u32(tb[MT76_TM_ATTR_FREQ_OFFSET]);
+	if (tb[MT76_TM_ATTR_ICAP_EVENT])
+		td->icap.trigger_event = nla_get_u32(tb[MT76_TM_ATTR_ICAP_EVENT]);
+	if (tb[MT76_TM_ATTR_ICAP_NODE])
+		td->icap.node = nla_get_u32(tb[MT76_TM_ATTR_ICAP_NODE]);
+	if (tb[MT76_TM_ATTR_ICAP_LEN])
+		td->icap.len = nla_get_u32(tb[MT76_TM_ATTR_ICAP_LEN]);
+	if (tb[MT76_TM_ATTR_ICAP_CYCLE])
+		td->icap.cycle = nla_get_u32(tb[MT76_TM_ATTR_ICAP_CYCLE]);
 
 	if (tb[MT76_TM_ATTR_STATE]) {
 		state = nla_get_u32(tb[MT76_TM_ATTR_STATE]);
@@ -494,7 +1018,23 @@ int mt76_testmode_cmd(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 			    idx >= ARRAY_SIZE(td->tx_power))
 				goto out;
 
-			td->tx_power[idx++] = nla_get_u8(cur);
+			err = mt76_tm_get_u8(cur, &td->tx_power[idx++], 0, 63);
+			if (err)
+				goto out;
+		}
+	}
+
+	if (tb[MT76_TM_ATTR_TX_TONE_DC_OFFSET]) {
+		struct nlattr *cur;
+		int idx = 0;
+		int rem;
+
+		nla_for_each_nested(cur, tb[MT76_TM_ATTR_TX_TONE_DC_OFFSET], rem) {
+			if (nla_len(cur) != sizeof(u16) ||
+			    idx >= ARRAY_SIZE(td->tone.dc_offset))
+				goto out;
+
+			td->tone.dc_offset[idx++] = nla_get_u16(cur);
 		}
 	}
 
@@ -512,6 +1052,55 @@ int mt76_testmode_cmd(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 		}
 	}
 
+	if (tb[MT76_TM_ATTR_CFG]) {
+		struct nlattr *cur;
+		int rem;
+
+		nla_for_each_nested(cur, tb[MT76_TM_ATTR_CFG], rem) {
+			if (nla_len(cur) != sizeof(u8))
+				goto out;
+
+			switch (nla_type(cur)) {
+			case MT76_TM_CFG_ATTR_TYPE:
+				err = mt76_tm_get_u8(cur, &td->cfg.type,
+						     0, MT76_TM_CFG_TYPE_MAX);
+				break;
+			case MT76_TM_CFG_ATTR_ENABLE:
+				err = mt76_tm_get_u8(cur, &td->cfg.enable, 0, 1);
+				break;
+			default:
+				err = -EINVAL;
+			};
+
+			if (err)
+				goto out;
+		}
+	}
+
+	if (tb[MT76_TM_ATTR_TXBF_ACT]) {
+		struct nlattr *cur;
+		int rem, idx = 0;
+
+		if (!tb[MT76_TM_ATTR_TXBF_PARAM] ||
+		    mt76_tm_get_u8(tb[MT76_TM_ATTR_TXBF_ACT], &td->txbf_act,
+				   0, MT76_TM_TXBF_ACT_MAX))
+			goto out;
+
+		if (td->txbf_act == MT76_TM_TXBF_ACT_PROF_UPDATE_ALL_CMD) {
+			err = mt76_testmode_txbf_profile_update_all_cmd(phy, tb, state);
+			goto out;
+		}
+
+		memset(td->txbf_param, 0, sizeof(td->txbf_param));
+		nla_for_each_nested(cur, tb[MT76_TM_ATTR_TXBF_PARAM], rem) {
+			if (nla_len(cur) != 2 ||
+			    idx >= ARRAY_SIZE(td->txbf_param))
+				goto out;
+
+			td->txbf_param[idx++] = nla_get_u16(cur);
+		}
+	}
+
 	if (dev->test_ops->set_params) {
 		err = dev->test_ops->set_params(phy, tb, state);
 		if (err)
@@ -533,13 +1122,77 @@ out:
 }
 EXPORT_SYMBOL(mt76_testmode_cmd);
 
+static int
+mt76_testmode_dump_last_rx_stats(struct mt76_phy *phy, struct sk_buff *msg)
+{
+	struct mt76_testmode_data *td = &phy->test;
+	void *rx, *rssi;
+	int i;
+
+	rx = nla_nest_start(msg, MT76_TM_STATS_ATTR_LAST_RX);
+	if (!rx)
+		return -ENOMEM;
+
+	rssi = nla_nest_start(msg, MT76_TM_RX_ATTR_RSSI);
+	if (!rssi)
+		return -ENOMEM;
+
+	for (i = 0; i < td->last_rx.path; i++)
+		if (nla_put_s8(msg, i, td->last_rx.rssi[i]))
+			return -ENOMEM;
+
+	nla_nest_end(msg, rssi);
+
+	rssi = nla_nest_start(msg, MT76_TM_RX_ATTR_RCPI);
+	if (!rssi)
+		return -ENOMEM;
+
+	for (i = 0; i < td->last_rx.path; i++)
+		if (nla_put_u8(msg, i, td->last_rx.rcpi[i]))
+			return -ENOMEM;
+
+	nla_nest_end(msg, rssi);
+
+	rssi = nla_nest_start(msg, MT76_TM_RX_ATTR_IB_RSSI);
+	if (!rssi)
+		return -ENOMEM;
+
+	for (i = 0; i < td->last_rx.path; i++)
+		if (nla_put_s8(msg, i, td->last_rx.ib_rssi[i]))
+			return -ENOMEM;
+
+	nla_nest_end(msg, rssi);
+
+	rssi = nla_nest_start(msg, MT76_TM_RX_ATTR_WB_RSSI);
+	if (!rssi)
+		return -ENOMEM;
+
+	for (i = 0; i < td->last_rx.path; i++)
+		if (nla_put_s8(msg, i, td->last_rx.wb_rssi[i]))
+			return -ENOMEM;
+
+	nla_nest_end(msg, rssi);
+
+	if (nla_put_s32(msg, MT76_TM_RX_ATTR_FREQ_OFFSET, td->last_rx.freq_offset))
+		return -ENOMEM;
+
+	if (nla_put_u8(msg, MT76_TM_RX_ATTR_SNR, td->last_rx.snr))
+		return -ENOMEM;
+
+	nla_nest_end(msg, rx);
+
+	return 0;
+}
+
 static int
 mt76_testmode_dump_stats(struct mt76_phy *phy, struct sk_buff *msg)
 {
 	struct mt76_testmode_data *td = &phy->test;
 	struct mt76_dev *dev = phy->dev;
 	u64 rx_packets = 0;
+	u64 rx_success = 0;
 	u64 rx_fcs_error = 0;
+	u64 rx_len_mismatch = 0;
 	int i;
 
 	if (dev->test_ops->dump_stats) {
@@ -550,9 +1203,11 @@ mt76_testmode_dump_stats(struct mt76_phy *phy, struct sk_buff *msg)
 			return ret;
 	}
 
-	for (i = 0; i < ARRAY_SIZE(td->rx_stats.packets); i++) {
-		rx_packets += td->rx_stats.packets[i];
-		rx_fcs_error += td->rx_stats.fcs_error[i];
+	for (i = 0; i < ARRAY_SIZE(td->rx_stats); i++) {
+		rx_packets += td->rx_stats[i].packets;
+		rx_success += td->rx_stats[i].rx_success;
+		rx_fcs_error += td->rx_stats[i].fcs_error;
+		rx_len_mismatch += td->rx_stats[i].len_mismatch;
 	}
 
 	if (nla_put_u32(msg, MT76_TM_STATS_ATTR_TX_PENDING, td->tx_pending) ||
@@ -560,10 +1215,69 @@ mt76_testmode_dump_stats(struct mt76_phy *phy, struct sk_buff *msg)
 	    nla_put_u32(msg, MT76_TM_STATS_ATTR_TX_DONE, td->tx_done) ||
 	    nla_put_u64_64bit(msg, MT76_TM_STATS_ATTR_RX_PACKETS, rx_packets,
 			      MT76_TM_STATS_ATTR_PAD) ||
+	    nla_put_u64_64bit(msg, MT76_TM_STATS_ATTR_RX_SUCCESS, rx_success,
+			      MT76_TM_STATS_ATTR_PAD) ||
 	    nla_put_u64_64bit(msg, MT76_TM_STATS_ATTR_RX_FCS_ERROR, rx_fcs_error,
+			      MT76_TM_STATS_ATTR_PAD) ||
+	    nla_put_u64_64bit(msg, MT76_TM_STATS_ATTR_RX_LEN_MISMATCH, rx_len_mismatch,
 			      MT76_TM_STATS_ATTR_PAD))
 		return -EMSGSIZE;
 
+	return mt76_testmode_dump_last_rx_stats(phy, msg);
+}
+
+static int
+mt76_testmode_dump_tb_info(struct mt76_phy *phy, struct sk_buff *msg)
+{
+	struct mt76_testmode_data *td = &phy->test;
+	struct mt76_tb_info *tb = &td->tb_info;
+	struct mt76_dev *dev = phy->dev;
+	int ret;
+
+	if (!dev->test_ops->dump_tb_info)
+		return -EOPNOTSUPP;
+
+	ret = dev->test_ops->dump_tb_info(phy);
+	if (ret)
+		return ret;
+
+	if (nla_put_u32(msg, MT76_TM_TB_INFO_ATTR_A_FACTOR_INIT, tb->afactor_init) ||
+	    nla_put_u32(msg, MT76_TM_TB_INFO_ATTR_LDPC_EXTRA_SYM, tb->ldpc_extra_symbol) ||
+	    nla_put_u32(msg, MT76_TM_TB_INFO_ATTR_PKT_EXT_DISAMB, tb->packet_ext_disamb) ||
+	    nla_put_u32(msg, MT76_TM_TB_INFO_ATTR_TX_PKT_EXT, tb->tx_packet_ext) ||
+	    nla_put_u32(msg, MT76_TM_TB_INFO_ATTR_L_SIG_LEN, tb->l_sig_len))
+		return -EMSGSIZE;
+
+	return 0;
+}
+
+static int
+mt76_testmode_dump_icap(struct mt76_phy *phy, struct sk_buff *msg)
+{
+	struct mt76_testmode_data *td = &phy->test;
+	struct mt76_dev *dev = phy->dev;
+	void *data;
+	int i, ret;
+
+	if (!dev->test_ops->dump_icap)
+		return -EOPNOTSUPP;
+
+	ret = dev->test_ops->dump_icap(phy);
+	if (ret)
+		return ret;
+
+	nla_put_u32(msg, MT76_TM_ICAP_STATS_ATTR_STATUS, td->icap.cap_status);
+
+	data = nla_nest_start(msg, MT76_TM_ICAP_STATS_ATTR_DATA);
+	if (!data)
+		return -ENOMEM;
+
+	for (i = 0; i < MT_TM_ICAP_SAMPLE_LEN; i++)
+		if (nla_put_u32(msg, i, td->icap.data[i]))
+			return -ENOMEM;
+
+	nla_nest_end(msg, data);
+
 	return 0;
 }
 
@@ -593,6 +1307,32 @@ int mt76_testmode_dump(struct ieee80211_hw *hw, struct sk_buff *msg,
 
 	mutex_lock(&dev->mutex);
 
+	/* handle radio conversion for single multi-radio wiphy */
+	if (tb[MT76_TM_ATTR_RADIO_IDX]) {
+		u32 radio_idx;
+
+		radio_idx = nla_get_u32(tb[MT76_TM_ATTR_RADIO_IDX]);
+		if (radio_idx > __MT_MAX_BAND ||
+		    !dev->radio_phy[radio_idx])
+			goto out;
+
+		phy = dev->radio_phy[radio_idx];
+		td = &phy->test;
+	}
+
+	if (tb[MT76_TM_ATTR_PRECAL] || tb[MT76_TM_ATTR_PRECAL_INFO]) {
+		int flag, type;
+
+		err = -EINVAL;
+		flag = tb[MT76_TM_ATTR_PRECAL] ? 1 : 0;
+		type = flag ? nla_get_u8(tb[MT76_TM_ATTR_PRECAL_INFO]) : 0;
+		if (dev->test_ops->dump_precal)
+			err = dev->test_ops->dump_precal(phy, msg, flag, type);
+
+		goto out;
+	}
+
+	/* the dump order follows the order of nla_put for each attribute */
 	if (tb[MT76_TM_ATTR_STATS]) {
 		err = -EINVAL;
 
@@ -605,25 +1345,63 @@ int mt76_testmode_dump(struct ieee80211_hw *hw, struct sk_buff *msg,
 		goto out;
 	}
 
+	if (tb[MT76_TM_ATTR_TB_INFO]) {
+		err = -EINVAL;
+
+		a = nla_nest_start(msg, MT76_TM_ATTR_TB_INFO);
+		if (a) {
+			err = mt76_testmode_dump_tb_info(phy, msg);
+			nla_nest_end(msg, a);
+		}
+
+		goto out;
+	}
+
+	if (tb[MT76_TM_ATTR_ICAP_STATS]) {
+		err = -EINVAL;
+
+		a = nla_nest_start(msg, MT76_TM_ATTR_ICAP_STATS);
+		if (a) {
+			err = mt76_testmode_dump_icap(phy, msg);
+			nla_nest_end(msg, a);
+		}
+
+		goto out;
+	}
+
 	mt76_testmode_init_defaults(phy);
 
 	err = -EMSGSIZE;
 	if (nla_put_u32(msg, MT76_TM_ATTR_STATE, td->state))
 		goto out;
 
+	if (nla_put_u8(msg, MT76_TM_ATTR_BAND_IDX, phy->band_idx))
+		goto out;
+
 	if (dev->test_mtd.name &&
 	    (nla_put_string(msg, MT76_TM_ATTR_MTD_PART, dev->test_mtd.name) ||
 	     nla_put_u32(msg, MT76_TM_ATTR_MTD_OFFSET, dev->test_mtd.offset)))
 		goto out;
 
 	if (nla_put_u32(msg, MT76_TM_ATTR_TX_COUNT, td->tx_count) ||
-	    nla_put_u32(msg, MT76_TM_ATTR_TX_LENGTH, td->tx_mpdu_len) ||
+	    nla_put_u16(msg, MT76_TM_ATTR_TX_LENGTH, td->tx_mpdu_len) ||
 	    nla_put_u8(msg, MT76_TM_ATTR_TX_RATE_MODE, td->tx_rate_mode) ||
 	    nla_put_u8(msg, MT76_TM_ATTR_TX_RATE_NSS, td->tx_rate_nss) ||
 	    nla_put_u8(msg, MT76_TM_ATTR_TX_RATE_IDX, td->tx_rate_idx) ||
 	    nla_put_u8(msg, MT76_TM_ATTR_TX_RATE_SGI, td->tx_rate_sgi) ||
 	    nla_put_u8(msg, MT76_TM_ATTR_TX_RATE_LDPC, td->tx_rate_ldpc) ||
 	    nla_put_u8(msg, MT76_TM_ATTR_TX_RATE_STBC, td->tx_rate_stbc) ||
+	    nla_put_u8(msg, MT76_TM_ATTR_SKU_EN, td->sku_en) ||
+	    nla_put_u8(msg, MT76_TM_ATTR_AID, td->aid) ||
+	    nla_put_u8(msg, MT76_TM_ATTR_OFF_CH_SCAN_CH, td->offchan_ch) ||
+	    nla_put_u8(msg, MT76_TM_ATTR_OFF_CH_SCAN_CENTER_CH, td->offchan_center_ch) ||
+	    nla_put_u8(msg, MT76_TM_ATTR_OFF_CH_SCAN_BW, td->offchan_bw) ||
+	    nla_put_u16(msg, MT76_TM_ATTR_FRAME_CONTROL, td->fc) ||
+	    nla_put_u16(msg, MT76_TM_ATTR_DURATION, td->dur) ||
+	    nla_put_u16(msg, MT76_TM_ATTR_SEQ_IDX, td->seq) ||
+	    nla_put_u8(msg, MT76_TM_ATTR_PAYLOAD_RULE, td->payload_rule) ||
+	    nla_put_u8(msg, MT76_TM_ATTR_PAYLOAD, td->payload) ||
+	    nla_put_u8(msg, MT76_TM_ATTR_MAX_PKT_EXT, td->max_pkt_ext) ||
 	    (mt76_testmode_param_present(td, MT76_TM_ATTR_TX_LTF) &&
 	     nla_put_u8(msg, MT76_TM_ATTR_TX_LTF, td->tx_ltf)) ||
 	    (mt76_testmode_param_present(td, MT76_TM_ATTR_TX_ANTENNA) &&
@@ -638,8 +1416,38 @@ int mt76_testmode_dump(struct ieee80211_hw *hw, struct sk_buff *msg,
 	     nla_put_u32(msg, MT76_TM_ATTR_TX_TIME, td->tx_time)) ||
 	    (mt76_testmode_param_present(td, MT76_TM_ATTR_TX_POWER_CONTROL) &&
 	     nla_put_u8(msg, MT76_TM_ATTR_TX_POWER_CONTROL, td->tx_power_control)) ||
+	    (mt76_testmode_param_present(td, MT76_TM_ATTR_TX_PKT_BW) &&
+	     nla_put_u8(msg, MT76_TM_ATTR_TX_PKT_BW, td->tx_pkt_bw)) ||
+	    (mt76_testmode_param_present(td, MT76_TM_ATTR_TX_PRI_SEL) &&
+	     nla_put_u8(msg, MT76_TM_ATTR_TX_PRI_SEL, td->tx_pri_sel)) ||
 	    (mt76_testmode_param_present(td, MT76_TM_ATTR_FREQ_OFFSET) &&
-	     nla_put_u8(msg, MT76_TM_ATTR_FREQ_OFFSET, td->freq_offset)))
+	     nla_put_u32(msg, MT76_TM_ATTR_FREQ_OFFSET, td->freq_offset)) ||
+	    (mt76_testmode_param_present(td, MT76_TM_ATTR_FAST_CAL) &&
+	     nla_put_u8(msg, MT76_TM_ATTR_FAST_CAL, td->fast_cal)) ||
+	    (mt76_testmode_param_present(td, MT76_TM_ATTR_RX_FILTER) &&
+	     nla_put_u32(msg, MT76_TM_ATTR_RX_FILTER, td->rx_filter)) ||
+	    (mt76_testmode_param_present(td, MT76_TM_ATTR_ICAP_RING) &&
+	     nla_put_u8(msg, MT76_TM_ATTR_ICAP_RING, td->icap.ring_buffer)) ||
+	    (mt76_testmode_param_present(td, MT76_TM_ATTR_ICAP_EVENT) &&
+	     nla_put_u32(msg, MT76_TM_ATTR_ICAP_EVENT, td->icap.trigger_event)) ||
+	    (mt76_testmode_param_present(td, MT76_TM_ATTR_ICAP_NODE) &&
+	     nla_put_u32(msg, MT76_TM_ATTR_ICAP_NODE, td->icap.node)) ||
+	    (mt76_testmode_param_present(td, MT76_TM_ATTR_ICAP_LEN) &&
+	     nla_put_u32(msg, MT76_TM_ATTR_ICAP_LEN, td->icap.len)) ||
+	    (mt76_testmode_param_present(td, MT76_TM_ATTR_ICAP_CYCLE) &&
+	     nla_put_u32(msg, MT76_TM_ATTR_ICAP_CYCLE, td->icap.cycle)) ||
+	    (mt76_testmode_param_present(td, MT76_TM_ATTR_ICAP_BANDWIDTH) &&
+	     nla_put_u8(msg, MT76_TM_ATTR_ICAP_BANDWIDTH, td->icap.bandwidth)) ||
+	    (mt76_testmode_param_present(td, MT76_TM_ATTR_ICAP_SRC) &&
+	     nla_put_u8(msg, MT76_TM_ATTR_ICAP_SRC, td->icap.src)) ||
+	    (mt76_testmode_param_present(td, MT76_TM_ATTR_ICAP_IQ_TYPE) &&
+	     nla_put_u8(msg, MT76_TM_ATTR_ICAP_IQ_TYPE, td->icap.iq_type)) ||
+	    (mt76_testmode_param_present(td, MT76_TM_ATTR_ICAP_PATH) &&
+	     nla_put_u8(msg, MT76_TM_ATTR_ICAP_PATH, td->icap.path)) ||
+	    (mt76_testmode_param_present(td, MT76_TM_ATTR_TX_TONE_TYPE) &&
+	     nla_put_u8(msg, MT76_TM_ATTR_TX_TONE_TYPE, td->tone.type)) ||
+	    (mt76_testmode_param_present(td, MT76_TM_ATTR_TX_TONE_BW) &&
+	     nla_put_u8(msg, MT76_TM_ATTR_TX_TONE_BW, td->tone.bw)))
 		goto out;
 
 	if (mt76_testmode_param_present(td, MT76_TM_ATTR_TX_POWER)) {
@@ -654,6 +1462,18 @@ int mt76_testmode_dump(struct ieee80211_hw *hw, struct sk_buff *msg,
 		nla_nest_end(msg, a);
 	}
 
+	if (mt76_testmode_param_present(td, MT76_TM_ATTR_TX_TONE_DC_OFFSET)) {
+		a = nla_nest_start(msg, MT76_TM_ATTR_TX_TONE_DC_OFFSET);
+		if (!a)
+			goto out;
+
+		for (i = 0; i < ARRAY_SIZE(td->tone.dc_offset); i++)
+			if (nla_put_u16(msg, i, td->tone.dc_offset[i]))
+				goto out;
+
+		nla_nest_end(msg, a);
+	}
+
 	if (mt76_testmode_param_present(td, MT76_TM_ATTR_MAC_ADDRS)) {
 		a = nla_nest_start(msg, MT76_TM_ATTR_MAC_ADDRS);
 		if (!a)
@@ -666,6 +1486,18 @@ int mt76_testmode_dump(struct ieee80211_hw *hw, struct sk_buff *msg,
 		nla_nest_end(msg, a);
 	}
 
+	if (mt76_testmode_param_present(td, MT76_TM_ATTR_CFG)) {
+		a = nla_nest_start(msg, MT76_TM_ATTR_CFG);
+		if (!a)
+			goto out;
+
+		if (nla_put_u8(msg, MT76_TM_CFG_ATTR_TYPE, td->cfg.type) ||
+		    nla_put_u8(msg, MT76_TM_CFG_ATTR_ENABLE, td->cfg.enable))
+			goto out;
+
+		nla_nest_end(msg, a);
+	}
+
 	err = 0;
 
 out:
diff --git a/testmode.h b/testmode.h
index aeb779e14..479e3fc96 100644
--- a/testmode.h
+++ b/testmode.h
@@ -5,7 +5,24 @@
 #ifndef __MT76_TESTMODE_H
 #define __MT76_TESTMODE_H
 
-#define MT76_TM_TIMEOUT	10
+#define MT76_TM_TIMEOUT			10
+#define MT76_TM_EEPROM_BLOCK_SIZE	16
+
+#define MT76_TM_MIN_IPG			34
+#define MT76_TM_MAX_IPG			591981
+
+#define MT76_TM_NLA_GET(type)								\
+static int mt76_tm_get_##type(struct nlattr *attr, type *dest, type min, type max)	\
+{											\
+	type val;									\
+	if (!attr)									\
+		return 0;								\
+	val = nla_get_##type(attr);							\
+	if (val < min || val > max)							\
+		return -EINVAL;								\
+	*dest = val;									\
+	return 0;									\
+}
 
 /**
  * enum mt76_testmode_attr - testmode attributes inside NL80211_ATTR_TESTDATA
@@ -15,12 +32,13 @@
  * @MT76_TM_ATTR_RESET: reset parameters to default (flag)
  * @MT76_TM_ATTR_STATE: test state (u32), see &enum mt76_testmode_state
  *
- * @MT76_TM_ATTR_MTD_PART: mtd partition used for eeprom data (string)
+ * @MT76_TM_ATTR_MTD_PART: mtd/emmc partition or binfile used for eeprom data (string)
  * @MT76_TM_ATTR_MTD_OFFSET: offset of eeprom data within the partition (u32)
+ * @MT76_TM_ATTR_BAND_IDX: band idx of the chip (u8)
  *
+ * @MT76_TM_ATTR_SKU_EN: config txpower sku is enabled or disabled in testmode (u8)
  * @MT76_TM_ATTR_TX_COUNT: configured number of frames to send when setting
  *	state to MT76_TM_STATE_TX_FRAMES (u32)
- * @MT76_TM_ATTR_TX_PENDING: pending frames during MT76_TM_STATE_TX_FRAMES (u32)
  * @MT76_TM_ATTR_TX_LENGTH: packet tx mpdu length (u32)
  * @MT76_TM_ATTR_TX_RATE_MODE: packet tx mode (u8, see &enum mt76_testmode_tx_mode)
  * @MT76_TM_ATTR_TX_RATE_NSS: packet tx number of spatial streams (u8)
@@ -34,10 +52,17 @@
  * @MT76_TM_ATTR_TX_POWER_CONTROL: enable tx power control (u8)
  * @MT76_TM_ATTR_TX_POWER: per-antenna tx power array (nested, u8 attrs)
  *
+ * @MT76_TM_ATTR_TX_PKT_BW: per-packet data bandwidth (u8)
+ * @MT76_TM_ATTR_TX_PRI_SEL: primary channel selection index (u8)
+ *
  * @MT76_TM_ATTR_FREQ_OFFSET: RF frequency offset (u32)
  *
  * @MT76_TM_ATTR_STATS: statistics (nested, see &enum mt76_testmode_stats_attr)
  *
+ * @MT76_TM_ATTR_PRECAL: pre-cal data (u8)
+ * @MT76_TM_ATTR_PRECAL_INFO: group size, dpd size, dpd_info, transmit size,
+ *	eeprom cal indicator (u32), dpd_info = [dpd_per_chan_size, chan_num_2g,
+ *	chan_num_5g, chan_num_6g]
  * @MT76_TM_ATTR_TX_SPE_IDX: tx spatial extension index (u8)
  *
  * @MT76_TM_ATTR_TX_DUTY_CYCLE: packet tx duty cycle (u8)
@@ -47,6 +72,80 @@
  * @MT76_TM_ATTR_DRV_DATA: driver specific netlink attrs (nested)
  *
  * @MT76_TM_ATTR_MAC_ADDRS: array of nested MAC addresses (nested)
+ * @MT76_TM_ATTR_AID: association index for wtbl (u8)
+ * @MT76_TM_ATTR_RU_ALLOC: resource unit allocation subfield (u8)
+ * @MT76_TM_ATTR_RU_IDX: resource unit index (u8)
+ *
+ * @MT76_TM_ATTR_EEPROM_ACTION: eeprom setting actions
+ *	(u8, see &enum mt76_testmode_eeprom_action)
+ * @MT76_TM_ATTR_EEPROM_OFFSET: offset of eeprom data block for writing (u32)
+ * @MT76_TM_ATTR_EEPROM_VAL: values for writing into a 16-byte data block
+ *	(nested, u8 attrs)
+ *
+ * @MT76_TM_ATTR_CFG: config testmode rf feature (nested, see &mt76_testmode_cfg)
+ * @MT76_TM_ATTR_TXBF_ACT: txbf setting actions (u8)
+ * @MT76_TM_ATTR_TXBF_PARAM: txbf parameters (nested)
+ *
+ * @MT76_TM_ATTR_OFF_CH_SCAN_CH: config the channel of background chain (ZWDFS) (u8)
+ * @MT76_TM_ATTR_OFF_CH_SCAN_CENTER_CH: config the center channel of background chain (ZWDFS) (u8)
+ * @MT76_TM_ATTR_OFF_CH_SCAN_BW: config the bandwidth of background chain (ZWDFS) (u8)
+ * @MT76_TM_ATTR_OFF_CH_SCAN_PATH: config the tx path of background chain (ZWDFS) (u8)
+ *
+ * @MT76_TM_ATTR_IPI_THRESHOLD: config the IPI index you want to read (u8)
+ * @MT76_TM_ATTR_IPI_PERIOD: config the time period for reading
+ *	the histogram of specific IPI index (u8)
+ * @MT76_TM_ATTR_IPI_ANTENNA_INDEX: config the antenna index for reading
+ *	the histogram of specific IPI index (u8)
+ * @MT76_TM_ATTR_IPI_RESET: reset the IPI counter
+ *
+ * @MT76_TM_ATTR_LM_ACT: list mode setting actions (u8)
+ * @MT76_TM_ATTR_LM_SEG_IDX: segment index used in list mode (u8)
+ * @MT76_TM_ATTR_LM_CENTER_CH: center channel used in list mode (u8)
+ * @MT76_TM_ATTR_LM_CBW: system index used in list mode (u8)
+ * @MT76_TM_ATTR_LM_STA_IDX: station index used in list mode (u8)
+ * @MT76_TM_ATTR_LM_SEG_TIMEOUT: TX/RX segment timeout used in list mode (u8)
+ *
+ * @MT76_TM_ATTR_RADIO_IDX: radio index used for single multi-radio wiphy (u32)
+ *
+ * @MT76_TM_ATTR_FAST_CAL: perform a fast calibration for a channel switch speed boost
+ *	(u8, see &enum mt76_testmode_fast_cal_type)
+ *
+ * @MT76_TM_ATTR_FRAME_CONTROL: frame control field for the mac header of the TX packet (u16)
+ * @MT76_TM_ATTR_DURATION: duration field for the mac header of the TX packet (u16)
+ * @MT76_TM_ATTR_SEQ_IDX: sequence index for the TX packet (u16)
+ * @MT76_TM_ATTR_PAYLOAD_RULE: payload generating rule
+ *	(u8, see &enum mt76_testmode_payload_rule)
+ * @MT76_TM_ATTR_PAYLOAD: payload content for repeat mode (u8)
+ * @MT76_TM_ATTR_MAX_PKT_EXT: max packet extension (u8)
+ *
+ * @MT76_TM_ATTR_RU_STA_NUM: the number of RU STAs (u8)
+ * @MT76_TM_ATTR_RU_STA_IDX: the RU STA index to be configured (u8)
+ * @MT76_TM_ATTR_RU_SEG_IDX: indicate the bandwidth segment that a STA is located in (u8)
+ * @MT76_TM_ATTR_RU_SS_IDX: the starting spatial stream index for a RU STA (u8)
+ * @MT76_TM_ATTR_TB_INFO: trigger-based PPDU info for decoding
+ *	(nested, see &enum mt76_testmode_tb_info_attr)
+ *
+ * @MT76_TM_ATTR_RX_FILTER: config the packet length for RX filtering,
+ *	where 0 disables RX filtering (u32)
+ *
+ * @MT76_TM_ATTR_ICAP_RING: enable ring buffer capture (u8)
+ * @MT76_TM_ATTR_ICAP_EVENT: config the icap trigger event (u32)
+ * @MT76_TM_ATTR_ICAP_NODE: config the icap node (u32)
+ * @MT76_TM_ATTR_ICAP_LEN: config the capture length (u32)
+ * @MT76_TM_ATTR_ICAP_CYCLE: config the capture stop cycle based on clock cycles (u32)
+ * @MT76_TM_ATTR_ICAP_BANDWIDTH: config the capture bandwidth, which can be different
+ *	from system bandwidth (u8)
+ * @MT76_TM_ATTR_ICAP_SRC: config the capture source of icap (u8)
+ * @MT76_TM_ATTR_ICAP_IQ_TYPE: config the I/Q data type of icap (u8)
+ * @MT76_TM_ATTR_ICAP_PATH: config the path for icap (u8)
+ * @MT76_TM_ATTR_ICAP_STATS: icap statistic
+ *	(nested, see &enum mt76_testmode_icap_stats_attr)
+ *
+ * @MT76_TM_ATTR_TX_TONE_TYPE: config the TX tone to be single or dual (u8)
+ * @MT76_TM_ATTR_TX_TONE_BW: config the tone bandwidth (u8)
+ * @MT76_TM_ATTR_TX_TONE_DC_OFFSET: config the DC offset of the tone
+ *	including in-phase and quadrature data (nested, u16 attrs)
+ *
  */
 enum mt76_testmode_attr {
 	MT76_TM_ATTR_UNSPEC,
@@ -56,7 +155,9 @@ enum mt76_testmode_attr {
 
 	MT76_TM_ATTR_MTD_PART,
 	MT76_TM_ATTR_MTD_OFFSET,
+	MT76_TM_ATTR_BAND_IDX,
 
+	MT76_TM_ATTR_SKU_EN,
 	MT76_TM_ATTR_TX_COUNT,
 	MT76_TM_ATTR_TX_LENGTH,
 	MT76_TM_ATTR_TX_RATE_MODE,
@@ -71,10 +172,16 @@ enum mt76_testmode_attr {
 	MT76_TM_ATTR_TX_POWER_CONTROL,
 	MT76_TM_ATTR_TX_POWER,
 
+	MT76_TM_ATTR_TX_PKT_BW,
+	MT76_TM_ATTR_TX_PRI_SEL,
+
 	MT76_TM_ATTR_FREQ_OFFSET,
 
 	MT76_TM_ATTR_STATS,
 
+	MT76_TM_ATTR_PRECAL,
+	MT76_TM_ATTR_PRECAL_INFO,
+
 	MT76_TM_ATTR_TX_SPE_IDX,
 
 	MT76_TM_ATTR_TX_DUTY_CYCLE,
@@ -84,6 +191,68 @@ enum mt76_testmode_attr {
 	MT76_TM_ATTR_DRV_DATA,
 
 	MT76_TM_ATTR_MAC_ADDRS,
+	MT76_TM_ATTR_AID,
+	MT76_TM_ATTR_RU_ALLOC,
+	MT76_TM_ATTR_RU_IDX,
+
+	MT76_TM_ATTR_EEPROM_ACTION,
+	MT76_TM_ATTR_EEPROM_OFFSET,
+	MT76_TM_ATTR_EEPROM_VAL,
+
+	MT76_TM_ATTR_CFG,
+	MT76_TM_ATTR_TXBF_ACT,
+	MT76_TM_ATTR_TXBF_PARAM,
+
+	MT76_TM_ATTR_OFF_CH_SCAN_CH,
+	MT76_TM_ATTR_OFF_CH_SCAN_CENTER_CH,
+	MT76_TM_ATTR_OFF_CH_SCAN_BW,
+	MT76_TM_ATTR_OFF_CH_SCAN_PATH,
+
+	MT76_TM_ATTR_IPI_THRESHOLD,
+	MT76_TM_ATTR_IPI_PERIOD,
+	MT76_TM_ATTR_IPI_ANTENNA_INDEX,
+	MT76_TM_ATTR_IPI_RESET,
+
+	MT76_TM_ATTR_LM_ACT,
+	MT76_TM_ATTR_LM_SEG_IDX,
+	MT76_TM_ATTR_LM_CENTER_CH,
+	MT76_TM_ATTR_LM_CBW,
+	MT76_TM_ATTR_LM_STA_IDX,
+	MT76_TM_ATTR_LM_SEG_TIMEOUT,
+
+	MT76_TM_ATTR_RADIO_IDX,
+
+	MT76_TM_ATTR_FAST_CAL,
+
+	MT76_TM_ATTR_FRAME_CONTROL,
+	MT76_TM_ATTR_DURATION,
+	MT76_TM_ATTR_SEQ_IDX,
+	MT76_TM_ATTR_PAYLOAD_RULE,
+	MT76_TM_ATTR_PAYLOAD,
+	MT76_TM_ATTR_MAX_PKT_EXT,
+
+	MT76_TM_ATTR_RU_STA_NUM,
+	MT76_TM_ATTR_RU_STA_IDX,
+	MT76_TM_ATTR_RU_SEG_IDX,
+	MT76_TM_ATTR_RU_SS_IDX,
+	MT76_TM_ATTR_TB_INFO,
+
+	MT76_TM_ATTR_RX_FILTER,
+
+	MT76_TM_ATTR_ICAP_RING,
+	MT76_TM_ATTR_ICAP_EVENT,
+	MT76_TM_ATTR_ICAP_NODE,
+	MT76_TM_ATTR_ICAP_LEN,
+	MT76_TM_ATTR_ICAP_CYCLE,
+	MT76_TM_ATTR_ICAP_BANDWIDTH,
+	MT76_TM_ATTR_ICAP_SRC,
+	MT76_TM_ATTR_ICAP_IQ_TYPE,
+	MT76_TM_ATTR_ICAP_PATH,
+	MT76_TM_ATTR_ICAP_STATS,
+
+	MT76_TM_ATTR_TX_TONE_TYPE,
+	MT76_TM_ATTR_TX_TONE_BW,
+	MT76_TM_ATTR_TX_TONE_DC_OFFSET,
 
 	/* keep last */
 	NUM_MT76_TM_ATTRS,
@@ -91,16 +260,20 @@ enum mt76_testmode_attr {
 };
 
 /**
- * enum mt76_testmode_state - statistics attributes
+ * enum mt76_testmode_stats_attr - statistics attributes
  *
  * @MT76_TM_STATS_ATTR_TX_PENDING: pending tx frames (u32)
  * @MT76_TM_STATS_ATTR_TX_QUEUED: queued tx frames (u32)
- * @MT76_TM_STATS_ATTR_TX_QUEUED: completed tx frames (u32)
+ * @MT76_TM_STATS_ATTR_TX_DONE: completed tx frames (u32)
  *
- * @MT76_TM_STATS_ATTR_RX_PACKETS: number of rx packets (u64)
+ * @MT76_TM_STATS_ATTR_RX_PACKETS: number of rx mdrdy packets
+ *	with successfully parsed headers (u64)
  * @MT76_TM_STATS_ATTR_RX_FCS_ERROR: number of rx packets with FCS error (u64)
  * @MT76_TM_STATS_ATTR_LAST_RX: information about the last received packet
  *	see &enum mt76_testmode_rx_attr
+ * @MT76_TM_STATS_ATTR_RX_LEN_MISMATCH: number of rx packets with length
+ *	mismatch error (u64)
+ * @MT76_TM_STATS_ATTR_RX_SUCCESS: number of successfully rx packets (u64)
  */
 enum mt76_testmode_stats_attr {
 	MT76_TM_STATS_ATTR_UNSPEC,
@@ -113,6 +286,8 @@ enum mt76_testmode_stats_attr {
 	MT76_TM_STATS_ATTR_RX_PACKETS,
 	MT76_TM_STATS_ATTR_RX_FCS_ERROR,
 	MT76_TM_STATS_ATTR_LAST_RX,
+	MT76_TM_STATS_ATTR_RX_LEN_MISMATCH,
+	MT76_TM_STATS_ATTR_RX_SUCCESS,
 
 	/* keep last */
 	NUM_MT76_TM_STATS_ATTRS,
@@ -125,6 +300,7 @@ enum mt76_testmode_stats_attr {
  *
  * @MT76_TM_RX_ATTR_FREQ_OFFSET: frequency offset (s32)
  * @MT76_TM_RX_ATTR_RCPI: received channel power indicator (array, u8)
+ * @MT76_TM_RX_ATTR_RSSI: received signal strength indicator (array, s8)
  * @MT76_TM_RX_ATTR_IB_RSSI: internal inband RSSI (array, s8)
  * @MT76_TM_RX_ATTR_WB_RSSI: internal wideband RSSI (array, s8)
  * @MT76_TM_RX_ATTR_SNR: signal-to-noise ratio (u8)
@@ -134,6 +310,7 @@ enum mt76_testmode_rx_attr {
 
 	MT76_TM_RX_ATTR_FREQ_OFFSET,
 	MT76_TM_RX_ATTR_RCPI,
+	MT76_TM_RX_ATTR_RSSI,
 	MT76_TM_RX_ATTR_IB_RSSI,
 	MT76_TM_RX_ATTR_WB_RSSI,
 	MT76_TM_RX_ATTR_SNR,
@@ -151,6 +328,17 @@ enum mt76_testmode_rx_attr {
  * @MT76_TM_STATE_TX_FRAMES: send a fixed number of test frames
  * @MT76_TM_STATE_RX_FRAMES: receive packets and keep statistics
  * @MT76_TM_STATE_TX_CONT: waveform tx without time gap
+ * @MT76_TM_STATE_GROUP_PREK: start group pre-calibration
+ * @MT76_TM_STATE_GROUP_PREK_CLEAN: clear the data group pre-calibration
+ * @MT76_TM_STATE_DPD_2G: start 2G DPD pre-calibration
+ * @MT76_TM_STATE_DPD_5G: start 5G DPD pre-calibration
+ * @MT76_TM_STATE_DPD_6G: start 6G DPD pre-calibration
+ * @MT76_TM_STATE_DPD_CLEAN: clear the data of DPD pre-calibration
+ * @MT76_TM_STATE_RX_GAIN_CAL: start RX gain calibration
+ * @MT76_TM_STATE_RX_GAIN_CAL_DUMP: dump the data of RX gain calibration
+ * @MT76_TM_STATE_RX_GAIN_CAL_CLEAN: clear the data of RX gain calibration
+ * @MT76_TM_STATE_ICAP: start internal data capture
+ * @MT76_TM_STATE_TX_TONE: start transmitting single tone
  * @MT76_TM_STATE_ON: test mode enabled used in offload firmware
  */
 enum mt76_testmode_state {
@@ -159,6 +347,17 @@ enum mt76_testmode_state {
 	MT76_TM_STATE_TX_FRAMES,
 	MT76_TM_STATE_RX_FRAMES,
 	MT76_TM_STATE_TX_CONT,
+	MT76_TM_STATE_GROUP_PREK,
+	MT76_TM_STATE_GROUP_PREK_CLEAN,
+	MT76_TM_STATE_DPD_2G,
+	MT76_TM_STATE_DPD_5G,
+	MT76_TM_STATE_DPD_6G,
+	MT76_TM_STATE_DPD_CLEAN,
+	MT76_TM_STATE_RX_GAIN_CAL,
+	MT76_TM_STATE_RX_GAIN_CAL_DUMP,
+	MT76_TM_STATE_RX_GAIN_CAL_CLEAN,
+	MT76_TM_STATE_ICAP,
+	MT76_TM_STATE_TX_TONE,
 	MT76_TM_STATE_ON,
 
 	/* keep last */
@@ -177,6 +376,9 @@ enum mt76_testmode_state {
  * @MT76_TM_TX_MODE_HE_EXT_SU: 802.11ax extended-range SU
  * @MT76_TM_TX_MODE_HE_TB: 802.11ax trigger-based
  * @MT76_TM_TX_MODE_HE_MU: 802.11ax multi-user MIMO
+ * @MT76_TM_TX_MODE_EHT_SU: 802.11be single-user MIMO
+ * @MT76_TM_TX_MODE_EHT_TRIG: 802.11be trigger-based
+ * @MT76_TM_TX_MODE_EHT_MU: 802.11be multi-user MIMO
  */
 enum mt76_testmode_tx_mode {
 	MT76_TM_TX_MODE_CCK,
@@ -187,10 +389,295 @@ enum mt76_testmode_tx_mode {
 	MT76_TM_TX_MODE_HE_EXT_SU,
 	MT76_TM_TX_MODE_HE_TB,
 	MT76_TM_TX_MODE_HE_MU,
+	MT76_TM_TX_MODE_EHT_SU,
+	MT76_TM_TX_MODE_EHT_TRIG,
+	MT76_TM_TX_MODE_EHT_MU,
 
 	/* keep last */
 	NUM_MT76_TM_TX_MODES,
 	MT76_TM_TX_MODE_MAX = NUM_MT76_TM_TX_MODES - 1,
 };
 
+/**
+ * enum mt76_testmode_eeprom_action - eeprom setting actions
+ *
+ * @MT76_TM_EEPROM_ACTION_UPDATE_DATA: update rf values to specific
+ *	eeprom data block
+ * @MT76_TM_EEPROM_ACTION_UPDATE_BUFFER_MODE: send updated eeprom data to fw
+ * @MT76_TM_EEPROM_ACTION_WRITE_TO_EFUSE: write eeprom data back to efuse
+ * @MT76_TM_EEPROM_ACTION_WRITE_TO_EXT_EEPROM: write eeprom data back to external eeprom
+ */
+enum mt76_testmode_eeprom_action {
+	MT76_TM_EEPROM_ACTION_UPDATE_DATA,
+	MT76_TM_EEPROM_ACTION_UPDATE_BUFFER_MODE,
+	MT76_TM_EEPROM_ACTION_WRITE_TO_EFUSE,
+	MT76_TM_EEPROM_ACTION_WRITE_TO_EXT_EEPROM,
+
+	/* keep last */
+	NUM_MT76_TM_EEPROM_ACTION,
+	MT76_TM_EEPROM_ACTION_MAX = NUM_MT76_TM_EEPROM_ACTION - 1,
+};
+
+/**
+ * enum mt76_testmode_cfg - testmode cfg attributes
+ *
+ * @MT76_TM_CFG_ATTR_TYPE: config cfg type
+ * @MT76_TM_CFG_ATTR_ENABLE: config cfg on or off
+ */
+enum mt76_testmode_cfg {
+	MT76_TM_CFG_ATTR_TYPE,
+	MT76_TM_CFG_ATTR_ENABLE,
+
+	/* keep last */
+	NUM_MT76_TM_CFG_ATTRS,
+	MT76_TM_CFG_ATTR_MAX = NUM_MT76_TM_CFG_ATTRS - 1,
+};
+
+/**
+ * enum mt76_testmode_cfg_type - testmode configuration type
+ *
+ * @MT76_TM_CFG_TSSI: config TSSI on or off
+ * @MT76_TM_CFG_DPD: config DPD on or off
+ * @MT76_TM_CFG_RATE_POWER_OFFSET: config rate power offset on or off
+ * @MT76_TM_CFG_THERMAL_COMP: config thermal compensation on or off
+ * @MT76_TM_CFG_BAND_POWER: config band power on or off
+ * @MT76_TM_CFG_TMAC: config MAC TX on or off
+ * @MT76_TM_CFG_RMAC: config MAC RX on or off
+ */
+enum mt76_testmode_cfg_type {
+	MT76_TM_CFG_TYPE_TSSI,
+	MT76_TM_CFG_TYPE_DPD,
+	MT76_TM_CFG_TYPE_RATE_POWER_OFFSET,
+	MT76_TM_CFG_TYPE_THERMAL_COMP,
+	MT76_TM_CFG_TYPE_BAND_POWER,
+	MT76_TM_CFG_TYPE_TMAC,
+	MT76_TM_CFG_TYPE_RMAC,
+
+	/* keep last */
+	NUM_MT76_TM_CFG_TYPE,
+	MT76_TM_CFG_TYPE_MAX = NUM_MT76_TM_CFG_TYPE - 1,
+};
+
+/**
+ * enum mt76_testmode_txbf_act - txbf action
+ *
+ * @MT76_TM_TXBF_ACT_GOLDEN_INIT: init ibf setting for golden device
+ * @MT76_TM_TXBF_ACT_INIT: init ibf setting for DUT
+ * @MT76_TM_TX_EBF_ACT_GOLDEN_INIT: init ebf setting for golden device
+ * @MT76_TM_TX_EBF_ACT_INIT: init ebf setting for DUT
+ * @MT76_TM_TXBF_ACT_UPDATE_CH: update channel info
+ * @MT76_TM_TXBF_ACT_PHASE_COMP: txbf phase compensation
+ * @MT76_TM_TXBF_ACT_TX_PREP: TX preparation for txbf
+ * @MT76_TM_TXBF_ACT_IBF_PROF_UPDATE: update ibf profile (pfmu tag, bf sta record)
+ * @MT76_TM_TXBF_ACT_EBF_PROF_UPDATE: update ebf profile
+ * @MT76_TM_TXBF_ACT_APPLY_TX: apply TX setting for txbf
+ * @MT76_TM_TXBF_ACT_PHASE_CAL: perform txbf phase calibration
+ * @MT76_TM_TXBF_ACT_PROF_UPDATE_ALL: update bf profile via instrument
+ * @MT76_TM_TXBF_ACT_PROF_UPDATE_ALL_CMD: update bf profile via instrument
+ * @MT76_TM_TXBF_ACT_E2P_UPDATE: write back txbf calibration result to eeprom
+ * @MT76_TM_TXBF_ACT_TRIGGER_SOUNDING: trigger beamformer to send sounding packet
+ * @MT76_TM_TXBF_ACT_STOP_SOUNDING: stop sending sounding packet
+ * @MT76_TM_TXBF_ACT_PROFILE_TAG_READ: read pfmu tag
+ * @MT76_TM_TXBF_ACT_PROFILE_TAG_WRITE: update pfmu tag
+ * @MT76_TM_TXBF_ACT_PROFILE_TAG_INVALID: invalidate pfmu tag
+ * @MT76_TM_TXBF_ACT_STA_REC_READ: read bf sta record
+ * @MT76_TM_TXBF_ACT_TXCMD: configure txcmd bf bit manually
+ */
+enum mt76_testmode_txbf_act {
+	MT76_TM_TXBF_ACT_GOLDEN_INIT,
+	MT76_TM_TXBF_ACT_INIT,
+	MT76_TM_TX_EBF_ACT_GOLDEN_INIT,
+	MT76_TM_TX_EBF_ACT_INIT,
+	MT76_TM_TXBF_ACT_UPDATE_CH,
+	MT76_TM_TXBF_ACT_PHASE_COMP,
+	MT76_TM_TXBF_ACT_TX_PREP,
+	MT76_TM_TXBF_ACT_IBF_PROF_UPDATE,
+	MT76_TM_TXBF_ACT_EBF_PROF_UPDATE,
+	MT76_TM_TXBF_ACT_APPLY_TX,
+	MT76_TM_TXBF_ACT_PHASE_CAL,
+	MT76_TM_TXBF_ACT_PROF_UPDATE_ALL,
+	MT76_TM_TXBF_ACT_PROF_UPDATE_ALL_CMD,
+	MT76_TM_TXBF_ACT_E2P_UPDATE,
+	MT76_TM_TXBF_ACT_TRIGGER_SOUNDING,
+	MT76_TM_TXBF_ACT_STOP_SOUNDING,
+	MT76_TM_TXBF_ACT_PROFILE_TAG_READ,
+	MT76_TM_TXBF_ACT_PROFILE_TAG_WRITE,
+	MT76_TM_TXBF_ACT_PROFILE_TAG_INVALID,
+	MT76_TM_TXBF_ACT_STA_REC_READ,
+	MT76_TM_TXBF_ACT_TXCMD,
+
+	/* keep last */
+	NUM_MT76_TM_TXBF_ACT,
+	MT76_TM_TXBF_ACT_MAX = NUM_MT76_TM_TXBF_ACT - 1,
+};
+
+#define LIST_SEG_MAX_NUM	100
+
+/**
+ * enum mt76_testmode_list_act - list mode action
+ *
+ * @MT76_TM_LM_ACT_SET_TX_SEGMENT: set the config of a TX segment
+ * @MT76_TM_LM_ACT_TX_START: start list TX
+ * @MT76_TM_LM_ACT_TX_STOP: stop list TX
+ * @MT76_TM_LM_ACT_SET_RX_SEGMENT: set the config of a RX segment
+ * @MT76_TM_LM_ACT_RX_START: start list RX
+ * @MT76_TM_LM_ACT_RX_STOP: stop list RX
+ * @MT76_TM_LM_ACT_SWITCH_SEGMENT: switch TX/RX segment
+ * @MT76_TM_LM_ACT_RX_STATUS: get RX status
+ * @MT76_TM_LM_ACT_DUT_STATUS: get DUT status
+ * @MT76_TM_LM_ACT_CLEAR_SEGMENT: clear all the TX/RX segments
+ * @MT76_TM_LM_ACT_DUMP_SEGMENT: dump all the TX/RX segment settings
+ */
+enum mt76_testmode_list_act {
+	MT76_TM_LM_ACT_SET_TX_SEGMENT,
+	MT76_TM_LM_ACT_TX_START,
+	MT76_TM_LM_ACT_TX_STOP,
+	MT76_TM_LM_ACT_SET_RX_SEGMENT,
+	MT76_TM_LM_ACT_RX_START,
+	MT76_TM_LM_ACT_RX_STOP,
+	MT76_TM_LM_ACT_SWITCH_SEGMENT,
+	MT76_TM_LM_ACT_RX_STATUS,
+	MT76_TM_LM_ACT_DUT_STATUS,
+	MT76_TM_LM_ACT_CLEAR_SEGMENT,
+	MT76_TM_LM_ACT_DUMP_SEGMENT,
+
+	/* keep last */
+	NUM_MT76_TM_LM_ACT,
+	MT76_TM_LM_ACT_MAX = NUM_MT76_TM_LM_ACT - 1,
+};
+
+/**
+ * enum mt76_testmode_fast_cal_type - fast channel calibration type
+ *
+ * @MT76_TM_FAST_CAL_TYPE_NONE: perform full calibration
+ * @MT76_TM_FAST_CAL_TYPE_TX: fast calibration for TX verification
+ * @MT76_TM_FAST_CAL_TYPE_RX: fast calibration for RX verification
+ * @MT76_TM_FAST_CAL_TYPE_POWER: fast calibration for power calibration
+ */
+enum mt76_testmode_fast_cal_type {
+	MT76_TM_FAST_CAL_TYPE_NONE,
+	MT76_TM_FAST_CAL_TYPE_TX,
+	MT76_TM_FAST_CAL_TYPE_RX,
+	MT76_TM_FAST_CAL_TYPE_POWER,
+
+	/* keep last */
+	NUM_MT76_TM_FAST_CAL_TYPE,
+	MT76_TM_FAST_CAL_TYPE_MAX = NUM_MT76_TM_FAST_CAL_TYPE - 1,
+};
+
+/**
+ * enum mt76_testmode_payload_rule - rule to generate TX payload
+ *
+ * @MT76_TM_PAYLOAD_RULE_NORMAL: all-zero payload
+ * @MT76_TM_PAYLOAD_RULE_REPEAT: generate payload by repeating specified content
+ * @MT76_TM_PAYLOAD_RULE_RANDOM: generate random payload
+ */
+enum mt76_testmode_payload_rule {
+	MT76_TM_PAYLOAD_RULE_NORMAL,
+	MT76_TM_PAYLOAD_RULE_REPEAT,
+	MT76_TM_PAYLOAD_RULE_RANDOM,
+
+	/* keep last */
+	NUM_MT76_TM_PAYLOAD_RULE,
+	MT76_TM_PAYLOAD_RULE_MAX = NUM_MT76_TM_PAYLOAD_RULE - 1,
+};
+
+/**
+ * enum mt76_testmode_max_pkt_ext - maximum packet extension duration
+ *
+ * @MT76_TM_MAX_PKT_EXT_0US: no extended packet duration is allowed
+ * @MT76_TM_MAX_PKT_EXT_4US: packet duration can be extended by up to 4 microseconds
+ * @MT76_TM_MAX_PKT_EXT_8US: packet duration can be extended by up to 8 microseconds
+ * @MT76_TM_MAX_PKT_EXT_12US: packet duration can be extended by up to 12 microseconds
+ * @MT76_TM_MAX_PKT_EXT_16US: packet duration can be extended by up to 16 microseconds
+ * @MT76_TM_MAX_PKT_EXT_20US: packet duration can be extended by up to 20 microseconds
+ */
+enum mt76_testmode_max_pkt_ext {
+	MT76_TM_MAX_PKT_EXT_0US,
+	MT76_TM_MAX_PKT_EXT_4US,
+	MT76_TM_MAX_PKT_EXT_8US,
+	MT76_TM_MAX_PKT_EXT_12US,
+	MT76_TM_MAX_PKT_EXT_16US,
+	MT76_TM_MAX_PKT_EXT_20US,
+
+	/* keep last */
+	NUM_MT76_TM_MAX_PKT_EXT,
+	MT76_TM_MAX_PKT_EXT_MAX = NUM_MT76_TM_MAX_PKT_EXT - 1,
+};
+
+/**
+ * enum mt76_testmode_tb_info_attr - Trigger-based PPDU attributes
+ *
+ * @MT76_TM_TB_INFO_ATTR_A_FACTOR_INIT: Initial A-factor value for LDPC
+ * @MT76_TM_TB_INFO_ATTR_LDPC_EXTRA_SYM: LDPC extra symbol
+ * @MT76_TM_TB_INFO_ATTR_PKT_EXT_DISAMB: packet extension disambiguation
+ * @MT76_TM_TB_INFO_ATTR_TX_PKT_EXT: TX packet extension
+ * @MT76_TM_TB_INFO_ATTR_L_SIG_LEN: length of L-SIG field
+ *
+ */
+enum mt76_testmode_tb_info_attr {
+	MT76_TM_TB_INFO_ATTR_UNSPEC,
+
+	MT76_TM_TB_INFO_ATTR_A_FACTOR_INIT,
+	MT76_TM_TB_INFO_ATTR_LDPC_EXTRA_SYM,
+	MT76_TM_TB_INFO_ATTR_PKT_EXT_DISAMB,
+	MT76_TM_TB_INFO_ATTR_TX_PKT_EXT,
+	MT76_TM_TB_INFO_ATTR_L_SIG_LEN,
+
+	/* keep last */
+	NUM_MT76_TM_TB_INFO_ATTRS,
+	MT76_TM_TB_INFO_ATTR_MAX = NUM_MT76_TM_TB_INFO_ATTRS - 1,
+};
+
+/**
+ * enum mt76_testmode_icap_stats_attr - icap statistic attributes
+ *
+ * @MT76_TM_ICAP_STATS_ATTR_STATUS: icap capture status (u8)
+ * @MT76_TM_ICAP_STATS_ATTR_DATA: icap data (array, u32)
+ */
+enum mt76_testmode_icap_stats_attr {
+	MT76_TM_ICAP_STATS_ATTR_UNSPEC,
+	MT76_TM_ICAP_STATS_ATTR_STATUS,
+	MT76_TM_ICAP_STATS_ATTR_DATA,
+
+	/* keep last */
+	NUM_MT76_TM_ICAP_STATS_ATTRS,
+	MT76_TM_ICAP_STATS_ATTR_MAX = NUM_MT76_TM_ICAP_STATS_ATTRS - 1,
+};
+
+/**
+ * enum mt76_testmode_tx_tone_type - tx tone type
+ *
+ * @MT76_TM_TX_TONE_TYPE_SINGLE: single tone
+ * @MT76_TM_TX_TONE_TYPE_DUAL: dual tone
+ */
+enum mt76_testmode_tx_tone_type {
+	MT76_TM_TX_TONE_TYPE_SINGLE,
+	MT76_TM_TX_TONE_TYPE_DUAL,
+
+	/* keep last */
+	NUM_MT76_TM_TX_TONE_TYPE,
+	MT76_TM_TX_TONE_TYPE_MAX = NUM_MT76_TM_TX_TONE_TYPE - 1,
+};
+
+/**
+ * enum mt76_testmode_tx_tone_bw - tx tone bandwidth
+ *
+ * @MT76_TM_TX_TONE_BW_DC: DC tone
+ * @MT76_TM_TX_TONE_BW_5: 5 MHz tone
+ * @MT76_TM_TX_TONE_BW_10: 10 MHz tone
+ * @MT76_TM_TX_TONE_BW_20: 20 MHz tone
+ * @MT76_TM_TX_TONE_BW_40: 40 MHz tone
+ */
+enum mt76_testmode_tx_tone_bw {
+	MT76_TM_TX_TONE_BW_DC,
+	MT76_TM_TX_TONE_BW_5,
+	MT76_TM_TX_TONE_BW_10,
+	MT76_TM_TX_TONE_BW_20,
+	MT76_TM_TX_TONE_BW_40,
+
+	/* keep last */
+	NUM_MT76_TM_TX_TONE_BW,
+	MT76_TM_TX_TONE_BW_MAX = NUM_MT76_TM_TX_TONE_BW - 1,
+};
 #endif
diff --git a/tools/CMakeLists.txt b/tools/CMakeLists.txt
index 276f74591..9a6ae29c7 100644
--- a/tools/CMakeLists.txt
+++ b/tools/CMakeLists.txt
@@ -3,6 +3,13 @@ cmake_minimum_required(VERSION 3.10)
 PROJECT(mt76-test C)
 ADD_DEFINITIONS(-Os -Wall -Werror --std=gnu99 -g3)
 
+UNSET(backports_dir CACHE)
+FIND_PATH(
+	backports_dir
+	NAMES "mac80211/uapi/linux"
+)
+INCLUDE_DIRECTORIES("${backports_dir}/mac80211/uapi")
+
 ADD_EXECUTABLE(mt76-test main.c fields.c eeprom.c fwlog.c)
 TARGET_LINK_LIBRARIES(mt76-test nl-tiny)
 
diff --git a/tools/eeprom.c b/tools/eeprom.c
index d8fceaa56..cbb44d82d 100644
--- a/tools/eeprom.c
+++ b/tools/eeprom.c
@@ -132,6 +132,7 @@ mt76_eeprom_init_file(void)
 int mt76_eeprom_init(int phy)
 {
 	struct nl_msg *msg;
+	int len;
 
 	msg = unl_genl_msg(&unl, NL80211_CMD_TESTMODE, true);
 	nla_put_u32(msg, NL80211_ATTR_WIPHY, phy);
@@ -142,8 +143,9 @@ int mt76_eeprom_init(int phy)
 		return -1;
 	}
 
-	eeprom_file = malloc(sizeof(EEPROM_FILE_PATH_FMT) + strlen(mtd_part));
-	sprintf(eeprom_file, EEPROM_FILE_PATH_FMT, mtd_part);
+	len = sizeof(EEPROM_FILE_PATH_FMT) + strlen(mtd_part);
+	eeprom_file = malloc(len);
+	snprintf(eeprom_file, len, EEPROM_FILE_PATH_FMT, mtd_part);
 
 	eeprom_fd = mt76_eeprom_init_file();
 	if (eeprom_fd < 0)
diff --git a/tools/fields.c b/tools/fields.c
index e3f690896..c2917d344 100644
--- a/tools/fields.c
+++ b/tools/fields.c
@@ -10,6 +10,18 @@ static const char * const testmode_state[] = {
 	[MT76_TM_STATE_IDLE] = "idle",
 	[MT76_TM_STATE_TX_FRAMES] = "tx_frames",
 	[MT76_TM_STATE_RX_FRAMES] = "rx_frames",
+	[MT76_TM_STATE_TX_CONT] = "tx_cont",
+	[MT76_TM_STATE_GROUP_PREK] = "group_prek",
+	[MT76_TM_STATE_GROUP_PREK_CLEAN] = "group_prek_clean",
+	[MT76_TM_STATE_DPD_2G] = "dpd_2g",
+	[MT76_TM_STATE_DPD_5G] = "dpd_5g",
+	[MT76_TM_STATE_DPD_6G] = "dpd_6g",
+	[MT76_TM_STATE_DPD_CLEAN] = "dpd_clean",
+	[MT76_TM_STATE_RX_GAIN_CAL] = "rx_gain_cal",
+	[MT76_TM_STATE_RX_GAIN_CAL_DUMP] = "rx_gain_dump",
+	[MT76_TM_STATE_RX_GAIN_CAL_CLEAN] = "rx_gain_clean",
+	[MT76_TM_STATE_ICAP] = "icap",
+	[MT76_TM_STATE_TX_TONE] = "tx_tone",
 };
 
 static const char * const testmode_tx_mode[] = {
@@ -21,6 +33,94 @@ static const char * const testmode_tx_mode[] = {
 	[MT76_TM_TX_MODE_HE_EXT_SU] = "he_ext_su",
 	[MT76_TM_TX_MODE_HE_TB] = "he_tb",
 	[MT76_TM_TX_MODE_HE_MU] = "he_mu",
+	[MT76_TM_TX_MODE_EHT_SU] = "eht_su",
+	[MT76_TM_TX_MODE_EHT_TRIG] = "eht_tb",
+	[MT76_TM_TX_MODE_EHT_MU] = "eht_mu",
+};
+
+static const char * const testmode_bw[] = {
+	[NL80211_CHAN_WIDTH_20_NOHT] = "NOHT",
+	[NL80211_CHAN_WIDTH_20] = "20",
+	[NL80211_CHAN_WIDTH_40] = "40",
+	[NL80211_CHAN_WIDTH_80] = "80",
+	[NL80211_CHAN_WIDTH_80P80] = "80p80",
+	[NL80211_CHAN_WIDTH_160] = "160",
+	[NL80211_CHAN_WIDTH_5] = "5",
+	[NL80211_CHAN_WIDTH_10] = "10",
+	[NL80211_CHAN_WIDTH_1] = "1",
+	[NL80211_CHAN_WIDTH_2] = "2",
+	[NL80211_CHAN_WIDTH_4] = "4",
+	[NL80211_CHAN_WIDTH_8] = "8",
+	[NL80211_CHAN_WIDTH_16] = "16",
+	[NL80211_CHAN_WIDTH_320] = "320",
+};
+
+static const char * const testmode_txbf_act[] = {
+	[MT76_TM_TXBF_ACT_GOLDEN_INIT] = "golden_init",
+	[MT76_TM_TXBF_ACT_INIT] = "init",
+	[MT76_TM_TX_EBF_ACT_GOLDEN_INIT] = "ebf_golden_init",
+	[MT76_TM_TX_EBF_ACT_INIT] = "ebf_init",
+	[MT76_TM_TXBF_ACT_UPDATE_CH] = "update_ch",
+	[MT76_TM_TXBF_ACT_PHASE_COMP] = "phase_comp",
+	[MT76_TM_TXBF_ACT_TX_PREP] = "tx_prep",
+	[MT76_TM_TXBF_ACT_IBF_PROF_UPDATE] = "ibf_prof_update",
+	[MT76_TM_TXBF_ACT_EBF_PROF_UPDATE] = "ebf_prof_update",
+	[MT76_TM_TXBF_ACT_APPLY_TX] = "apply_tx",
+	[MT76_TM_TXBF_ACT_PHASE_CAL] = "phase_cal",
+	[MT76_TM_TXBF_ACT_PROF_UPDATE_ALL] = "prof_update",
+	[MT76_TM_TXBF_ACT_PROF_UPDATE_ALL_CMD] = "prof_update_all",
+	[MT76_TM_TXBF_ACT_E2P_UPDATE] = "e2p_update",
+	[MT76_TM_TXBF_ACT_TRIGGER_SOUNDING] = "trigger_sounding",
+	[MT76_TM_TXBF_ACT_STOP_SOUNDING] = "stop_sounding",
+	[MT76_TM_TXBF_ACT_PROFILE_TAG_READ] = "pfmu_tag_read",
+	[MT76_TM_TXBF_ACT_PROFILE_TAG_WRITE] = "pfmu_tag_write",
+	[MT76_TM_TXBF_ACT_PROFILE_TAG_INVALID] = "set_invalid_prof",
+	[MT76_TM_TXBF_ACT_STA_REC_READ] = "sta_rec_read",
+	[MT76_TM_TXBF_ACT_TXCMD] = "txcmd",
+};
+
+static const char * const testmode_list_act[] = {
+	[MT76_TM_LM_ACT_SET_TX_SEGMENT] = "tx_seg",
+	[MT76_TM_LM_ACT_TX_START] = "tx_start",
+	[MT76_TM_LM_ACT_TX_STOP] = "tx_stop",
+	[MT76_TM_LM_ACT_SET_RX_SEGMENT] = "rx_seg",
+	[MT76_TM_LM_ACT_RX_START] = "rx_start",
+	[MT76_TM_LM_ACT_RX_STOP] = "rx_stop",
+	[MT76_TM_LM_ACT_SWITCH_SEGMENT] = "switch_seg",
+	[MT76_TM_LM_ACT_RX_STATUS] = "rx_stat",
+	[MT76_TM_LM_ACT_DUT_STATUS] = "dut_stat",
+	[MT76_TM_LM_ACT_CLEAR_SEGMENT] = "clear_seg",
+	[MT76_TM_LM_ACT_DUMP_SEGMENT] = "dump_seg",
+};
+
+static const char * const testmode_fast_cal[] = {
+	[MT76_TM_FAST_CAL_TYPE_NONE] = "none",
+	[MT76_TM_FAST_CAL_TYPE_TX] = "tx_verify",
+	[MT76_TM_FAST_CAL_TYPE_RX] = "rx_verify",
+	[MT76_TM_FAST_CAL_TYPE_POWER] = "power_cal",
+};
+
+static const char * const testmode_tone_type[] = {
+	[MT76_TM_TX_TONE_TYPE_SINGLE] = "single",
+	[MT76_TM_TX_TONE_TYPE_DUAL] = "dual",
+};
+
+static const char * const testmode_tone_bw[] = {
+	[MT76_TM_TX_TONE_BW_DC] = "dc",
+	[MT76_TM_TX_TONE_BW_5] = "5",
+	[MT76_TM_TX_TONE_BW_10] = "10",
+	[MT76_TM_TX_TONE_BW_20] = "20",
+	[MT76_TM_TX_TONE_BW_40] = "40",
+};
+
+static const char * const cfg_type[] = {
+	[MT76_TM_CFG_TYPE_TSSI] = "tssi",
+	[MT76_TM_CFG_TYPE_DPD] = "dpd",
+	[MT76_TM_CFG_TYPE_RATE_POWER_OFFSET] = "rate_power_offset",
+	[MT76_TM_CFG_TYPE_THERMAL_COMP] = "thermal_comp",
+	[MT76_TM_CFG_TYPE_BAND_POWER] = "band_power",
+	[MT76_TM_CFG_TYPE_TMAC] = "tmac",
+	[MT76_TM_CFG_TYPE_RMAC] = "rmac",
 };
 
 static void print_enum(const struct tm_field *field, struct nlattr *attr)
@@ -60,12 +160,17 @@ static bool parse_enum(const struct tm_field *field, int idx,
 static bool parse_u8(const struct tm_field *field, int idx,
 		     struct nl_msg *msg, const char *val)
 {
+	if (field->hex_parse)
+		return !nla_put_u8(msg, idx, strtoul(val, NULL, 16));
 	return !nla_put_u8(msg, idx, strtoul(val, NULL, 0));
 }
 
 static void print_u8(const struct tm_field *field, struct nlattr *attr)
 {
-	printf("%d", nla_get_u8(attr));
+	if (field->hex_dump)
+		printf("0x%x", nla_get_u8(attr));
+	else
+		printf("%u", nla_get_u8(attr));
 }
 
 static void print_s8(const struct tm_field *field, struct nlattr *attr)
@@ -73,9 +178,27 @@ static void print_s8(const struct tm_field *field, struct nlattr *attr)
 	printf("%d", (int8_t)nla_get_u8(attr));
 }
 
+static bool parse_u16(const struct tm_field *field, int idx,
+		      struct nl_msg *msg, const char *val)
+{
+	if (field->hex_parse)
+		return !nla_put_u16(msg, idx, strtoul(val, NULL, 16));
+	return !nla_put_u16(msg, idx, strtoul(val, NULL, 0));
+}
+
+static void print_u16(const struct tm_field *field, struct nlattr *attr)
+{
+	if (field->hex_dump)
+		printf("0x%x", nla_get_u16(attr));
+	else
+		printf("%u", nla_get_u16(attr));
+}
+
 static bool parse_u32(const struct tm_field *field, int idx,
 		      struct nl_msg *msg, const char *val)
 {
+	if (field->hex_parse)
+		return !nla_put_u32(msg, idx, strtoul(val, NULL, 16));
 	return !nla_put_u32(msg, idx, strtoul(val, NULL, 0));
 }
 
@@ -86,12 +209,15 @@ static void print_s32(const struct tm_field *field, struct nlattr *attr)
 
 static void print_u32(const struct tm_field *field, struct nlattr *attr)
 {
-	printf("%d", nla_get_u32(attr));
+	if (field->hex_dump)
+		printf("0x%x", nla_get_u32(attr));
+	else
+		printf("%u", nla_get_u32(attr));
 }
 
 static void print_u64(const struct tm_field *field, struct nlattr *attr)
 {
-	printf("%lld", (unsigned long long)nla_get_u64(attr));
+	printf("%llu", (unsigned long long)nla_get_u64(attr));
 }
 
 static bool parse_flag(const struct tm_field *field, int idx,
@@ -144,29 +270,58 @@ static void print_array(const struct tm_field *field, struct nlattr *attr)
 	nla_for_each_nested(cur, attr, rem) {
 		if (idx++ > 0)
 			printf(",");
-		if (nla_len(cur) != 1)
+		if (nla_len(cur) != field->entry_len)
 			continue;
 		field->print2(field, cur);
 	}
 }
 
+static bool parse_nested(const struct tm_field *field, int idx,
+			 struct nl_msg *msg, const char *val)
+{
+	const struct tm_field *fields = field->fields;
+	char *str, *cur, *ap;
+	bool ret = true;
+	int i = 0;
+	void *a;
+
+	str = strdup(val);
+	ap = str;
+
+	a = nla_nest_start(msg, idx);
+
+	while ((cur = strsep(&ap, ":")) != NULL) {
+		if (i >= field->len)
+			break;
+
+		ret = fields[i].parse(&fields[i], i, msg, cur);
+		if (!ret)
+			break;
+
+		i++;
+	}
+
+	nla_nest_end(msg, a);
+
+	free(str);
+
+	return ret;
+}
+
 static void print_nested(const struct tm_field *field, struct nlattr *attr)
 {
-	struct nlattr **tb = alloca(field->len * sizeof(struct nlattr *));
 	const struct tm_field *fields = field->fields;
-	int i;
+	struct nlattr *cur;
+	int i, rem;
 
-	nla_parse_nested(tb, field->len - 1, attr, field->policy);
-	for (i = 0; i < field->len; i++) {
+	nla_for_each_nested(cur, attr, rem) {
 		int prefix_len = 0;
 
-		if (!tb[i])
-			continue;
-
+		i = nla_type(cur);
 		if (!fields[i].print)
 			continue;
 
-		if (fields[i].name)
+		if (fields[i].name && !fields[i].skip_print)
 			printf("%s%s=", prefix, fields[i].name);
 
 		if (fields[i].prefix) {
@@ -175,34 +330,95 @@ static void print_nested(const struct tm_field *field, struct nlattr *attr)
 				sizeof(prefix) - prefix_len - 1);
 		}
 
-		fields[i].print(&fields[i], tb[i]);
+		fields[i].print(&fields[i], cur);
 		if (fields[i].prefix)
 			prefix[prefix_len] = 0;
 
-		if (fields[i].name)
+		if (fields[i].name && !fields[i].skip_print)
 			printf("\n");
 	}
 
-	if (field->print_extra)
+	if (field->print_extra) {
+		struct nlattr **tb = alloca(field->len * sizeof(struct nlattr *));
+
+		nla_parse_nested(tb, field->len - 1, attr, field->policy);
 		field->print_extra(field, tb);
+	}
 }
 
 static void print_extra_stats(const struct tm_field *field, struct nlattr **tb)
 {
-	float total, failed;
+	float total, success, failed;
 
 	if (!tb[MT76_TM_STATS_ATTR_RX_PACKETS] ||
-	    !tb[MT76_TM_STATS_ATTR_RX_FCS_ERROR])
+	    !tb[MT76_TM_STATS_ATTR_RX_SUCCESS])
 		return;
 
 	total = nla_get_u64(tb[MT76_TM_STATS_ATTR_RX_PACKETS]);
-	failed = nla_get_u64(tb[MT76_TM_STATS_ATTR_RX_FCS_ERROR]);
+	success = nla_get_u64(tb[MT76_TM_STATS_ATTR_RX_SUCCESS]);
+	failed = total - success;
 
 	printf("%srx_per=%.02f%%\n", prefix, 100 * failed / total);
 }
 
+static bool parse_mac(const struct tm_field *field, int idx,
+		      struct nl_msg *msg, const char *val)
+{
+#define ETH_ALEN	6
+	bool ret = true;
+	char *str, *cur, *ap;
+	void *a;
+
+	str = strdup(val);
+	ap = str;
+
+	a = nla_nest_start(msg, idx);
+
+	idx = 0;
+	while ((cur = strsep(&ap, ",")) != NULL) {
+		unsigned char addr[ETH_ALEN];
+		char *val, *tmp = cur;
+		int i = 0;
+
+		while ((val = strsep(&tmp, ":")) != NULL) {
+			if (i >= ETH_ALEN)
+				break;
+
+			addr[i++] = strtoul(val, NULL, 16);
+		}
+
+		nla_put(msg, idx, ETH_ALEN, addr);
+
+		idx++;
+	}
+
+	nla_nest_end(msg, a);
+
+	free(str);
+
+	return ret;
+}
+
+static void print_mac(const struct tm_field *field, struct nlattr *attr)
+{
+#define MAC2STR(a) (a)[0], (a)[1], (a)[2], (a)[3], (a)[4], (a)[5]
+#define MACSTR "%02x:%02x:%02x:%02x:%02x:%02x"
+	unsigned char addr[3][6];
+	struct nlattr *cur;
+	int idx = 0;
+	int rem;
+
+	nla_for_each_nested(cur, attr, rem) {
+		if (nla_len(cur) != 6)
+			continue;
+		memcpy(addr[idx++], nla_data(cur), 6);
+	}
 
-#define FIELD_GENERIC(_field, _name, ...)	\
+	printf("" MACSTR "," MACSTR "," MACSTR "",
+	       MAC2STR(addr[0]), MAC2STR(addr[1]), MAC2STR(addr[2]));
+}
+
+#define FIELD_GENERIC(_field, _name, ...)		\
 	[FIELD_NAME(_field)] = {			\
 		.name = _name,				\
 		##__VA_ARGS__				\
@@ -232,6 +448,7 @@ static void print_extra_stats(const struct tm_field *field, struct nlattr **tb)
 #define FIELD_ARRAY_RO(_type, _field, _name, ...)	\
 	FIELD(array, _field, _name,			\
 	      .print2 = print_##_type,			\
+	      .entry_len = sizeof(_type),		\
 	      ##__VA_ARGS__				\
 	)
 
@@ -250,10 +467,28 @@ static void print_extra_stats(const struct tm_field *field, struct nlattr **tb)
 		 ##__VA_ARGS__				\
 	)
 
+#define FIELD_NESTED(_field, _data, _prefix, _n, ...)	\
+	FIELD_RO(nested, _field, _n,			\
+		 .prefix = _prefix,			\
+		 .fields = _data ## _fields,		\
+		 .policy = _data ## _policy,		\
+		 .len = ARRAY_SIZE(_data ## _fields),	\
+		 .parse = parse_nested,			\
+		 ##__VA_ARGS__				\
+	)
+
+#define FIELD_MAC(_field, _name)			\
+	[FIELD_NAME(_field)] = {			\
+		.name = _name,				\
+		.parse = parse_mac,			\
+		.print = print_mac			\
+	}
+
 #define FIELD_NAME(_field) MT76_TM_RX_ATTR_##_field
 static const struct tm_field rx_fields[NUM_MT76_TM_RX_ATTRS] = {
 	FIELD_RO(s32, FREQ_OFFSET, "freq_offset"),
 	FIELD_ARRAY_RO(u8, RCPI, "rcpi"),
+	FIELD_ARRAY_RO(s8, RSSI, "rssi"),
 	FIELD_ARRAY_RO(s8, IB_RSSI, "ib_rssi"),
 	FIELD_ARRAY_RO(s8, WB_RSSI, "wb_rssi"),
 	FIELD_RO(s8, SNR, "snr"),
@@ -261,6 +496,7 @@ static const struct tm_field rx_fields[NUM_MT76_TM_RX_ATTRS] = {
 static struct nla_policy rx_policy[NUM_MT76_TM_RX_ATTRS] = {
 	[MT76_TM_RX_ATTR_FREQ_OFFSET] = { .type = NLA_U32 },
 	[MT76_TM_RX_ATTR_RCPI] = { .type = NLA_NESTED },
+	[MT76_TM_RX_ATTR_RSSI] = { .type = NLA_NESTED },
 	[MT76_TM_RX_ATTR_IB_RSSI] = { .type = NLA_NESTED },
 	[MT76_TM_RX_ATTR_WB_RSSI] = { .type = NLA_NESTED },
 	[MT76_TM_RX_ATTR_SNR] = { .type = NLA_U8 },
@@ -274,6 +510,8 @@ static const struct tm_field stats_fields[NUM_MT76_TM_STATS_ATTRS] = {
 	FIELD_RO(u32, TX_DONE, "tx_done"),
 	FIELD_RO(u64, RX_PACKETS, "rx_packets"),
 	FIELD_RO(u64, RX_FCS_ERROR, "rx_fcs_error"),
+	FIELD_RO(u64, RX_LEN_MISMATCH, "rx_len_mismatch"),
+	FIELD_RO(u64, RX_SUCCESS, "rx_success"),
 	FIELD_NESTED_RO(LAST_RX, rx, "last_"),
 };
 static struct nla_policy stats_policy[NUM_MT76_TM_STATS_ATTRS] = {
@@ -282,6 +520,47 @@ static struct nla_policy stats_policy[NUM_MT76_TM_STATS_ATTRS] = {
 	[MT76_TM_STATS_ATTR_TX_DONE] = { .type = NLA_U32 },
 	[MT76_TM_STATS_ATTR_RX_PACKETS] = { .type = NLA_U64 },
 	[MT76_TM_STATS_ATTR_RX_FCS_ERROR] = { .type = NLA_U64 },
+	[MT76_TM_STATS_ATTR_RX_LEN_MISMATCH] = { .type = NLA_U64 },
+	[MT76_TM_STATS_ATTR_RX_SUCCESS] = { .type = NLA_U64 },
+};
+#undef FIELD_NAME
+
+#define FIELD_NAME(_field) MT76_TM_TB_INFO_ATTR_##_field
+static const struct tm_field tb_info_fields[NUM_MT76_TM_TB_INFO_ATTRS] = {
+	FIELD_RO(u32, A_FACTOR_INIT, "a_factor_init"),
+	FIELD_RO(u32, LDPC_EXTRA_SYM, "ldpc_extra_sym"),
+	FIELD_RO(u32, PKT_EXT_DISAMB, "pkt_ext_disamb"),
+	FIELD_RO(u32, TX_PKT_EXT, "tx_pkt_ext"),
+	FIELD_RO(u32, L_SIG_LEN, "l_sig_len"),
+};
+static struct nla_policy tb_info_policy[NUM_MT76_TM_TB_INFO_ATTRS] = {
+	[MT76_TM_TB_INFO_ATTR_A_FACTOR_INIT] = { .type = NLA_U32 },
+	[MT76_TM_TB_INFO_ATTR_LDPC_EXTRA_SYM] = { .type = NLA_U32 },
+	[MT76_TM_TB_INFO_ATTR_PKT_EXT_DISAMB] = { .type = NLA_U32 },
+	[MT76_TM_TB_INFO_ATTR_TX_PKT_EXT] = { .type = NLA_U32 },
+	[MT76_TM_TB_INFO_ATTR_L_SIG_LEN] = { .type = NLA_U32 },
+};
+#undef FIELD_NAME
+
+#define FIELD_NAME(_field) MT76_TM_ICAP_STATS_ATTR_##_field
+static const struct tm_field icap_stats_fields[NUM_MT76_TM_ICAP_STATS_ATTRS] = {
+	FIELD_RO(u8, STATUS, "status"),
+	FIELD_ARRAY_RO(u32, DATA, "data", .hex_dump = true),
+};
+static struct nla_policy icap_stats_policy[NUM_MT76_TM_ICAP_STATS_ATTRS] = {
+	[MT76_TM_ICAP_STATS_ATTR_STATUS] = { .type = NLA_U8 },
+	[MT76_TM_ICAP_STATS_ATTR_DATA] = { .type = NLA_NESTED },
+};
+#undef FIELD_NAME
+
+#define FIELD_NAME(_field) MT76_TM_CFG_ATTR_##_field
+static const struct tm_field cfg_fields[NUM_MT76_TM_CFG_ATTRS] = {
+	FIELD_ENUM(TYPE, "type", cfg_type),
+	FIELD(u8, ENABLE, "enable"),
+};
+static struct nla_policy cfg_policy[NUM_MT76_TM_CFG_ATTRS] = {
+	[MT76_TM_CFG_ATTR_TYPE] = { .type = NLA_U8 },
+	[MT76_TM_CFG_ATTR_ENABLE] = { .type = NLA_U8 },
 };
 #undef FIELD_NAME
 
@@ -291,6 +570,7 @@ static const struct tm_field testdata_fields[NUM_MT76_TM_ATTRS] = {
 	FIELD_ENUM(STATE, "state", testmode_state),
 	FIELD_RO(string, MTD_PART, "mtd_part"),
 	FIELD_RO(u32, MTD_OFFSET, "mtd_offset"),
+	FIELD(u8, SKU_EN, "sku_en"),
 	FIELD(u32, TX_COUNT, "tx_count"),
 	FIELD(u32, TX_LENGTH, "tx_length"),
 	FIELD_ENUM(TX_RATE_MODE, "tx_rate_mode", testmode_tx_mode),
@@ -300,12 +580,63 @@ static const struct tm_field testdata_fields[NUM_MT76_TM_ATTRS] = {
 	FIELD(u8, TX_RATE_LDPC, "tx_rate_ldpc"),
 	FIELD(u8, TX_RATE_STBC, "tx_rate_stbc"),
 	FIELD(u8, TX_LTF, "tx_ltf"),
+	FIELD(u8, TX_DUTY_CYCLE, "tx_duty_cycle"),
+	FIELD(u32, TX_IPG, "tx_ipg"),
+	FIELD(u32, TX_TIME, "tx_time"),
 	FIELD(u8, TX_POWER_CONTROL, "tx_power_control"),
 	FIELD_ARRAY(u8, TX_POWER, "tx_power"),
 	FIELD(u8, TX_ANTENNA, "tx_antenna"),
+	FIELD(u8, TX_SPE_IDX, "tx_spe_idx"),
+	FIELD_ENUM(TX_PKT_BW, "tx_pkt_bw", testmode_bw),
+	FIELD(u8, TX_PRI_SEL, "tx_pri_sel"),
 	FIELD(u32, FREQ_OFFSET, "freq_offset"),
+	FIELD(u8, AID, "aid"),
+	FIELD(u8, RU_ALLOC, "ru_alloc"),
+	FIELD(u8, RU_IDX, "ru_idx"),
+	FIELD_NESTED(CFG, cfg, "cfg_", "cfg", .skip_print = true),
+	FIELD_ENUM(TXBF_ACT, "txbf_act", testmode_txbf_act),
+	FIELD_ARRAY(u16, TXBF_PARAM, "txbf_param", .hex_parse = true),
+	FIELD(u8, OFF_CH_SCAN_CH, "offchan_ch"),
+	FIELD(u8, OFF_CH_SCAN_CENTER_CH, "offchan_center_ch"),
+	FIELD_ENUM(OFF_CH_SCAN_BW, "offchan_bw", testmode_bw),
+	FIELD(u8, IPI_THRESHOLD, "ipi_threshold"),
+	FIELD(u32, IPI_PERIOD, "ipi_period"),
+	FIELD(u8, IPI_RESET, "ipi_reset"),
+	FIELD_ENUM(LM_ACT, "list_act", testmode_list_act),
+	FIELD(u8, LM_SEG_IDX, "lm_seg_idx"),
+	FIELD(u8, LM_CENTER_CH, "lm_center_ch"),
+	FIELD_ENUM(LM_CBW, "lm_cbw", testmode_bw),
+	FIELD(u8, LM_STA_IDX, "lm_sta_idx"),
+	FIELD(u32, LM_SEG_TIMEOUT, "lm_seg_timeout"),
+	FIELD_ENUM(FAST_CAL, "fast_cal", testmode_fast_cal),
+	FIELD_MAC(MAC_ADDRS, "mac_addrs"),
+	FIELD(u16, FRAME_CONTROL, "fc", .hex_dump = true),
+	FIELD(u16, DURATION, "dur", .hex_dump = true),
+	FIELD(u16, SEQ_IDX, "seq"),
+	FIELD(u8, PAYLOAD_RULE, "payload_rule"),
+	FIELD(u8, PAYLOAD, "payload", .hex_dump = true),
+	FIELD(u8, MAX_PKT_EXT, "max_pkt_ext"),
+	FIELD(u8, RU_STA_NUM, "ru_sta_num"),
+	FIELD(u8, RU_STA_IDX, "ru_sta_idx"),
+	FIELD(u8, RU_SEG_IDX, "ru_seg_idx"),
+	FIELD(u8, RU_SS_IDX, "ru_ss_idx"),
+	FIELD_NESTED_RO(TB_INFO, tb_info, ""),
 	FIELD_NESTED_RO(STATS, stats, "",
 			.print_extra = print_extra_stats),
+	FIELD(u32, RX_FILTER, "rx_filter"),
+	FIELD(u8, ICAP_RING, "icap_ring"),
+	FIELD(u32, ICAP_EVENT, "icap_event", .hex_dump = true),
+	FIELD(u32, ICAP_NODE, "icap_node", .hex_dump = true),
+	FIELD(u32, ICAP_LEN, "icap_len"),
+	FIELD(u32, ICAP_CYCLE, "icap_cycle"),
+	FIELD_ENUM(ICAP_BANDWIDTH, "icap_bw", testmode_bw),
+	FIELD(u8, ICAP_SRC, "icap_src"),
+	FIELD(u8, ICAP_IQ_TYPE, "icap_iq_type"),
+	FIELD(u8, ICAP_PATH, "icap_path"),
+	FIELD_NESTED_RO(ICAP_STATS, icap_stats, ""),
+	FIELD_ENUM(TX_TONE_TYPE, "tone_type", testmode_tone_type),
+	FIELD_ENUM(TX_TONE_BW, "tone_bw", testmode_tone_bw),
+	FIELD_ARRAY(u16, TX_TONE_DC_OFFSET, "tone_dc_offs"),
 };
 #undef FIELD_NAME
 
@@ -313,6 +644,7 @@ static struct nla_policy testdata_policy[NUM_MT76_TM_ATTRS] = {
 	[MT76_TM_ATTR_STATE] = { .type = NLA_U8 },
 	[MT76_TM_ATTR_MTD_PART] = { .type = NLA_STRING },
 	[MT76_TM_ATTR_MTD_OFFSET] = { .type = NLA_U32 },
+	[MT76_TM_ATTR_SKU_EN] = { .type = NLA_U8 },
 	[MT76_TM_ATTR_TX_COUNT] = { .type = NLA_U32 },
 	[MT76_TM_ATTR_TX_LENGTH] = { .type = NLA_U32 },
 	[MT76_TM_ATTR_TX_RATE_MODE] = { .type = NLA_U8 },
@@ -322,10 +654,60 @@ static struct nla_policy testdata_policy[NUM_MT76_TM_ATTRS] = {
 	[MT76_TM_ATTR_TX_RATE_LDPC] = { .type = NLA_U8 },
 	[MT76_TM_ATTR_TX_RATE_STBC] = { .type = NLA_U8 },
 	[MT76_TM_ATTR_TX_LTF] = { .type = NLA_U8 },
+	[MT76_TM_ATTR_TX_DUTY_CYCLE] = { .type = NLA_U8 },
+	[MT76_TM_ATTR_TX_IPG] = { .type = NLA_U32 },
+	[MT76_TM_ATTR_TX_TIME] = { .type = NLA_U32 },
 	[MT76_TM_ATTR_TX_POWER_CONTROL] = { .type = NLA_U8 },
 	[MT76_TM_ATTR_TX_ANTENNA] = { .type = NLA_U8 },
+	[MT76_TM_ATTR_TX_SPE_IDX] = { .type = NLA_U8 },
+	[MT76_TM_ATTR_TX_PKT_BW] = { .type = NLA_U8 },
+	[MT76_TM_ATTR_TX_PRI_SEL] = { .type = NLA_U8 },
 	[MT76_TM_ATTR_FREQ_OFFSET] = { .type = NLA_U32 },
+	[MT76_TM_ATTR_AID] = { .type = NLA_U8 },
+	[MT76_TM_ATTR_RU_ALLOC] = { .type = NLA_U8 },
+	[MT76_TM_ATTR_RU_IDX] = { .type = NLA_U8 },
 	[MT76_TM_ATTR_STATS] = { .type = NLA_NESTED },
+	[MT76_TM_ATTR_CFG] = { .type = NLA_NESTED },
+	[MT76_TM_ATTR_TXBF_ACT] = { .type = NLA_U8 },
+	[MT76_TM_ATTR_OFF_CH_SCAN_CH] = { .type = NLA_U8 },
+	[MT76_TM_ATTR_OFF_CH_SCAN_CENTER_CH] = { .type = NLA_U8 },
+	[MT76_TM_ATTR_OFF_CH_SCAN_BW] = { .type = NLA_U8 },
+	[MT76_TM_ATTR_IPI_THRESHOLD] = { .type = NLA_U8 },
+	[MT76_TM_ATTR_IPI_PERIOD] = { .type = NLA_U32 },
+	[MT76_TM_ATTR_IPI_ANTENNA_INDEX] = { .type = NLA_U8 },
+	[MT76_TM_ATTR_IPI_RESET] = { .type = NLA_U8 },
+	[MT76_TM_ATTR_LM_ACT] = { .type = NLA_U8 },
+	[MT76_TM_ATTR_LM_SEG_IDX] = { .type = NLA_U8 },
+	[MT76_TM_ATTR_LM_CENTER_CH] = { .type = NLA_U8 },
+	[MT76_TM_ATTR_LM_CBW] = { .type = NLA_U8 },
+	[MT76_TM_ATTR_LM_STA_IDX] = { .type = NLA_U8 },
+	[MT76_TM_ATTR_LM_SEG_TIMEOUT] = { .type = NLA_U32 },
+	[MT76_TM_ATTR_FAST_CAL] = { .type = NLA_U8 },
+	[MT76_TM_ATTR_FRAME_CONTROL] = { .type = NLA_U16 },
+	[MT76_TM_ATTR_DURATION] = { .type = NLA_U16 },
+	[MT76_TM_ATTR_SEQ_IDX] = { .type = NLA_U16 },
+	[MT76_TM_ATTR_PAYLOAD_RULE] = { .type = NLA_U8 },
+	[MT76_TM_ATTR_PAYLOAD] = { .type = NLA_U8 },
+	[MT76_TM_ATTR_MAX_PKT_EXT] = { .type = NLA_U8 },
+	[MT76_TM_ATTR_RU_STA_NUM] = { .type = NLA_U8 },
+	[MT76_TM_ATTR_RU_STA_IDX] = { .type = NLA_U8 },
+	[MT76_TM_ATTR_RU_SEG_IDX] = { .type = NLA_U8 },
+	[MT76_TM_ATTR_RU_SS_IDX] = { .type = NLA_U8 },
+	[MT76_TM_ATTR_TB_INFO] = { .type = NLA_NESTED },
+	[MT76_TM_ATTR_RX_FILTER] = { .type = NLA_U32 },
+	[MT76_TM_ATTR_ICAP_RING] = { .type = NLA_U8 },
+	[MT76_TM_ATTR_ICAP_EVENT] = { .type = NLA_U32 },
+	[MT76_TM_ATTR_ICAP_NODE] = { .type = NLA_U32 },
+	[MT76_TM_ATTR_ICAP_LEN] = { .type = NLA_U32 },
+	[MT76_TM_ATTR_ICAP_CYCLE] = { .type = NLA_U32 },
+	[MT76_TM_ATTR_ICAP_BANDWIDTH] = { .type = NLA_U8 },
+	[MT76_TM_ATTR_ICAP_SRC] = { .type = NLA_U8 },
+	[MT76_TM_ATTR_ICAP_IQ_TYPE] = { .type = NLA_U8 },
+	[MT76_TM_ATTR_ICAP_PATH] = { .type = NLA_U8 },
+	[MT76_TM_ATTR_ICAP_STATS] = { .type = NLA_NESTED },
+	[MT76_TM_ATTR_TX_TONE_TYPE] = { .type = NLA_U8 },
+	[MT76_TM_ATTR_TX_TONE_BW] = { .type = NLA_U8 },
+	[MT76_TM_ATTR_TX_TONE_DC_OFFSET] = { .type = NLA_NESTED },
 };
 
 const struct tm_field msg_field = {
diff --git a/tools/fwlog.c b/tools/fwlog.c
index e5d4a1051..c894d31a9 100644
--- a/tools/fwlog.c
+++ b/tools/fwlog.c
@@ -26,16 +26,36 @@ static const char *debugfs_path(const char *phyname, const char *file)
 	return path;
 }
 
-static int mt76_set_fwlog_en(const char *phyname, bool en)
+static int mt76_set_fwlog_en(const char *phyname, bool en, char *val)
 {
 	FILE *f = fopen(debugfs_path(phyname, "fw_debug_bin"), "w");
+	if (!f) {
+		perror("fopen");
+		return -1;
+	}
+
+	if (en && val)
+		fprintf(f, "%s", val);
+	else if (en)
+		fprintf(f, "7");
+	else
+		fprintf(f, "0");
+
+	fclose(f);
+
+	return 0;
+}
 
+static int mt76_set_idxlog_enable(const char *phyname, bool enable)
+{
+	FILE *f = fopen(debugfs_path(phyname, "idxlog_enable"), "w");
 	if (!f) {
-		fprintf(stderr, "Could not open fw_debug_bin file\n");
-		return 1;
+		perror("fopen");
+		return -1;
 	}
 
-	fprintf(f, "7");
+	fprintf(f, "%hhu", enable);
+
 	fclose(f);
 
 	return 0;
@@ -74,104 +94,215 @@ static void handle_signal(int sig)
 	done = true;
 }
 
-int mt76_fwlog(const char *phyname, int argc, char **argv)
+static int mt76_log_socket(struct sockaddr_in *remote, char *ip, unsigned short port)
 {
 	struct sockaddr_in local = {
 		.sin_family = AF_INET,
 		.sin_addr.s_addr = INADDR_ANY,
 	};
-	struct sockaddr_in remote = {
-		.sin_family = AF_INET,
-		.sin_port = htons(55688),
-	};
-	char buf[1504];
-	int ret = 0;
-	int yes = 1;
-	int s, fd;
-
-	if (argc < 1) {
-		fprintf(stderr, "need destination address\n");
-		return 1;
-	}
+	int s, ret;
 
-	if (!inet_aton(argv[0], &remote.sin_addr)) {
-		fprintf(stderr, "invalid destination address\n");
-		return 1;
+	remote->sin_family = AF_INET;
+	remote->sin_port = htons(port);
+	if (!inet_aton(ip, &remote->sin_addr)) {
+		fprintf(stderr, "Invalid destination IP address: %s\n", ip);
+		return -EINVAL;
 	}
 
 	s = socket(PF_INET, SOCK_DGRAM, IPPROTO_UDP);
 	if (s < 0) {
 		perror("socket");
-		return 1;
+		return s;
 	}
 
-	setsockopt(s, SOL_SOCKET, SO_BROADCAST, &yes, sizeof(yes));
-	if (bind(s, (struct sockaddr *)&local, sizeof(local)) < 0) {
+	ret = bind(s, (struct sockaddr *)&local, sizeof(local));
+	if (ret) {
 		perror("bind");
-		return 1;
+		close(s);
+		return ret;
 	}
 
-	if (mt76_set_fwlog_en(phyname, true))
-		return 1;
+	return s;
+}
+
+static int mt76_log_relay(int in_fd, int out_fd, struct sockaddr_in *remote)
+{
+	char *buf = malloc(FWLOG_BUF_SIZE);
+	int ret = 0;
 
-	fd = open(debugfs_path(phyname, "fwlog_data"), O_RDONLY);
-	if (fd < 0) {
-		fprintf(stderr, "Could not open fwlog_data file: %s\n", strerror(errno));
-		ret = 1;
-		goto out;
+	if (!buf) {
+		perror("malloc");
+		return -ENOMEM;
 	}
 
 	signal(SIGTERM, handle_signal);
 	signal(SIGINT, handle_signal);
 	signal(SIGQUIT, handle_signal);
 
-	while (1) {
+	while (!done) {
 		struct pollfd pfd = {
-			.fd = fd,
-			.events = POLLIN | POLLHUP | POLLERR,
+			.fd = in_fd,
+			.events = POLLIN,
 		};
 		uint32_t len;
-		int r;
-
-		if (done)
-			break;
+		int rc;
 
 		poll(&pfd, 1, -1);
 
-		r = read_retry(fd, &len, sizeof(len));
-		if (r < 0)
+		rc = read_retry(in_fd, &len, sizeof(len));
+		if (rc < 0) {
+			if (!done) {
+				fprintf(stderr, "Failed to read relay file.\n");
+				ret = -1;
+			}
 			break;
-
-		if (!r)
+		}
+		if (!rc)
 			continue;
 
-		if (len > sizeof(buf)) {
-			fprintf(stderr, "Length error: %d > %d\n", len, (int)sizeof(buf));
-			ret = 1;
+		if (len > FWLOG_BUF_SIZE) {
+			fprintf(stderr, "Log size was too large: %u bytes\n", len);
+			ret = -ENOMEM;
 			break;
 		}
 
-		if (done)
+		rc = read_retry(in_fd, buf, len);
+		if (rc < 0) {
+			if (!done) {
+				fprintf(stderr, "Failed to read relay file.\n");
+				ret = -1;
+			}
 			break;
-
-		r = read_retry(fd, buf, len);
-		if (done)
+		}
+		if (rc != len) {
+			fprintf(stderr, "Expected log size: %u bytes\n", len);
+			fprintf(stderr, "Read log size: %u bytes\n", rc);
+			ret = -EIO;
 			break;
+		}
 
-		if (r != len) {
-			fprintf(stderr, "Short read: %d < %d\n", r, len);
-			ret = 1;
+		if (remote)
+			rc = sendto(out_fd, buf, len, 0, (struct sockaddr *)remote, sizeof(*remote));
+		else
+			rc = write(out_fd, buf, len);
+		if (rc < 0) {
+			perror("sendto/write");
+			ret = -1;
 			break;
 		}
+	}
+
+	free(buf);
+
+	return ret;
+}
 
-		/* send buf */
-		sendto(s, buf, len, 0, (struct sockaddr *)&remote, sizeof(remote));
+int mt76_fwlog(const char *phyname, int argc, char **argv)
+{
+	struct sockaddr_in remote;
+	int in_fd, out_fd, ret;
+	char dev_ip[16] = {};
+	unsigned short port;
+
+	if (argc < 2) {
+		fprintf(stderr, "need destination address and fw_debug_bin\n");
+		return -EINVAL;
 	}
 
-	close(fd);
 
-out:
-	mt76_set_fwlog_en(phyname, false);
+	if (argc == 2) {
+		/* support ip:port format */
+		if (strchr(argv[0], ':')) {
+			sscanf(argv[0], "%[^:]:%hu", dev_ip, &port);
+		} else {
+			strncpy(dev_ip, argv[0], sizeof(dev_ip) - 1);
+			port = 55688;
+		}
+
+		out_fd = mt76_log_socket(&remote, dev_ip, port);
+		if (out_fd < 0)
+			return out_fd;
+	} else if (argc == 3) {
+		out_fd = open(argv[2], O_WRONLY | O_CREAT | O_TRUNC, S_IRUSR);
+		if (out_fd < 0) {
+			perror("open");
+			return out_fd;
+		}
+	} else {
+		fprintf(stderr, "Too many arguments.\n");
+		return -EINVAL;
+	}
+
+	ret = mt76_set_fwlog_en(phyname, true, argv[1]);
+	if (ret)
+		goto close;
+
+	in_fd = open(debugfs_path(phyname, "fwlog_data"), O_RDONLY);
+	if (in_fd < 0) {
+		perror("open");
+		goto disable;
+	}
+
+	if (mt76_log_relay(in_fd, out_fd, argc == 3 ? NULL : &remote))
+		fprintf(stderr, "Failed to relay FW log.\n");
+
+	close(in_fd);
+disable:
+	ret = mt76_set_fwlog_en(phyname, false, NULL);
+close:
+	close(out_fd);
+
+	return ret;
+}
+
+int mt76_idxlog(const char *phyname, int argc, char **argv)
+{
+#define IDXLOG_FILE_PATH	"/tmp/log/WIFI_FW.clog"
+	struct sockaddr_in remote;
+	int in_fd, out_fd, ret;
+
+	if (argc) {
+		out_fd = mt76_log_socket(&remote, argv[0], 55688);
+		if (out_fd < 0)
+			return out_fd;
+	} else {
+		out_fd = open(IDXLOG_FILE_PATH, O_WRONLY | O_CREAT | O_TRUNC, S_IRUSR);
+		if (out_fd < 0) {
+			perror("open");
+			return -1;
+		}
+	}
+
+	ret = mt76_set_idxlog_enable(phyname, true);
+	if (ret)
+		goto close;
+
+	in_fd = open(debugfs_path(phyname, "idxlog_data"), O_RDONLY);
+	if (in_fd < 0) {
+		perror("open");
+		goto disable;
+	}
+
+	if (mt76_log_relay(in_fd, out_fd, argc ? &remote : NULL))
+		fprintf(stderr, "Failed to relay index log.\n");
+
+	close(in_fd);
+disable:
+	ret = mt76_set_idxlog_enable(phyname, false);
+close:
+	close(out_fd);
+
+	if (argc)
+		system("timestamp=$(date +\"%y%m%d_%H%M%S\");"
+		       "clog_dir=/tmp/log/clog_${timestamp};"
+		       "mkdir ${clog_dir};"
+		       "dmesg > ${clog_dir}/WIFI_KERNEL_${timestamp}.clog");
+	else
+		system("timestamp=$(date +\"%y%m%d_%H%M%S\");"
+		       "clog_dir=/tmp/log/clog_${timestamp};"
+		       "mkdir ${clog_dir};"
+		       "mv /tmp/log/WIFI_FW.clog ${clog_dir}/WIFI_FW_${timestamp}.clog;"
+		       "dmesg > ${clog_dir}/WIFI_KERNEL_${timestamp}.clog");
 
 	return ret;
 }
diff --git a/tools/main.c b/tools/main.c
index 699a9eea6..f6eef12db 100644
--- a/tools/main.c
+++ b/tools/main.c
@@ -13,42 +13,164 @@
 #include <poll.h>
 #include <fcntl.h>
 #include <signal.h>
+#include <net/if.h>
 #include "mt76-test.h"
 
 struct unl unl;
 static uint32_t tm_changed[DIV_ROUND_UP(NUM_MT76_TM_ATTRS, 32)];
 static const char *progname;
 
-static int phy_lookup_idx(const char *name)
+static void parse_radio_config(struct radio_config *radio, struct nlattr *freqs)
 {
-	char buf[128];
-	FILE *f;
-	int len;
+	struct nlattr *freq;
+	int rem;
+
+	nla_for_each_nested(freq, freqs, rem) {
+		static struct nla_policy freq_policy[NL80211_WIPHY_RADIO_FREQ_ATTR_MAX + 1] = {
+			[NL80211_WIPHY_RADIO_FREQ_ATTR_START] = { .type = NLA_U32 },
+			[NL80211_WIPHY_RADIO_FREQ_ATTR_END] = { .type = NLA_U32 },
+		};
+		struct nlattr *tb[NL80211_WIPHY_RADIO_FREQ_ATTR_MAX + 1];
+		uint32_t start, end;
+
+		if (nla_type(freq) != NL80211_WIPHY_RADIO_ATTR_FREQ_RANGE)
+			continue;
+
+		if (nla_parse_nested(tb, NL80211_WIPHY_RADIO_ATTR_MAX + 1,
+				     freq, freq_policy) ||
+		    !tb[NL80211_WIPHY_RADIO_FREQ_ATTR_START] ||
+		    !tb[NL80211_WIPHY_RADIO_FREQ_ATTR_END])
+			continue;
+
+		start = nla_get_u32(tb[NL80211_WIPHY_RADIO_FREQ_ATTR_START]) / 1000;
+		end = nla_get_u32(tb[NL80211_WIPHY_RADIO_FREQ_ATTR_END]) / 1000;
+
+		if (start >= 2400 && end <= 2500) {
+			radio->band = NL80211_BAND_2GHZ;
+			radio->parking_freq = 2412;
+			return;
+		}
+		if (start >= 5000 && end <= 5900) {
+			radio->band = NL80211_BAND_5GHZ;
+			radio->parking_freq = 5180;
+			return;
+		}
+		if (start >= 5925 && end <= 7200) {
+			radio->band = NL80211_BAND_6GHZ;
+			radio->parking_freq = 5955;
+			return;
+		}
+	}
 
-	snprintf(buf, sizeof(buf), "/sys/class/ieee80211/%s/index", name);
-	f = fopen(buf, "r");
-	if (!f)
-		return -1;
+	radio->band = -1;
+	radio->parking_freq = 0;
+}
 
-	len = fread(buf, 1, sizeof(buf) - 1, f);
-	fclose(f);
+static void parse_radios(struct wiphy_config *wiphy, struct nlattr *radios)
+{
+	struct nlattr *radio;
+	int radio_idx, rem;
+
+	nla_for_each_nested(radio, radios, rem) {
+		static struct nla_policy radio_policy[NL80211_WIPHY_RADIO_ATTR_MAX + 1] = {
+			[NL80211_WIPHY_RADIO_ATTR_INDEX] = { .type = NLA_U32 },
+		};
+		struct nlattr *tb[NL80211_WIPHY_RADIO_ATTR_MAX + 1];
+
+		if (nla_parse_nested(tb, NL80211_WIPHY_RADIO_ATTR_MAX + 1,
+				     radio, radio_policy) ||
+		    !tb[NL80211_WIPHY_RADIO_ATTR_INDEX])
+			continue;
+
+		radio_idx = nla_get_u32(tb[NL80211_WIPHY_RADIO_ATTR_INDEX]);
+		parse_radio_config(&wiphy->radio[radio_idx], radio);
+		wiphy->radio_num++;
+	}
+}
+
+static int mt76_get_wiphy_cb(struct nl_msg *msg, void *arg)
+{
+	struct nlattr *tb_msg[NL80211_ATTR_MAX + 1];
+	struct genlmsghdr *gnlh = nlmsg_data(nlmsg_hdr(msg));
+	struct wiphy_list *wiphys = (struct wiphy_list *)arg;
+	int wiphy_idx, idx = wiphys->wiphy_num - 1;
+
+	nla_parse(tb_msg, NL80211_ATTR_MAX, genlmsg_attrdata(gnlh, 0),
+		  genlmsg_attrlen(gnlh, 0), NULL);
+
+	if (!tb_msg[NL80211_ATTR_WIPHY])
+		return NL_STOP;
+
+	wiphy_idx = nla_get_u32(tb_msg[NL80211_ATTR_WIPHY]);
+	if (idx < 0 || wiphys->wiphy[idx].wiphy_idx != wiphy_idx) {
+		idx++;
+		wiphys->wiphy[idx].wiphy_idx = wiphy_idx;
+		wiphys->wiphy_num++;
+	}
+
+	if (tb_msg[NL80211_ATTR_MAC])
+		nla_memcpy(wiphys->mac_addr, tb_msg[NL80211_ATTR_MAC], ETH_ALEN);
 
-	if (!len)
-		return -1;
+	if (tb_msg[NL80211_ATTR_WIPHY_RADIOS]) {
+		wiphys->is_single_wiphy = true;
+		parse_radios(&wiphys->wiphy[idx], tb_msg[NL80211_ATTR_WIPHY_RADIOS]);
+	}
 
-	buf[len] = 0;
-	return atoi(buf);
+	return NL_SKIP;
+}
+
+static void mt76_get_wiphy(struct phy_config *config, int phy_idx)
+{
+	struct wiphy_list wiphys = {0};
+	struct nl_msg *msg;
+	int i, radio_num;
+	int idx = 0;
+
+	msg = unl_genl_msg(&unl, NL80211_CMD_GET_WIPHY, true);
+	nla_put_flag(msg, NL80211_ATTR_SPLIT_WIPHY_DUMP);
+	unl_genl_request(&unl, msg, mt76_get_wiphy_cb, (void *)&wiphys);
+
+	config->wiphy_idx = -1;
+	config->radio_idx = -1;
+	config->parking_freq = 0;
+	config->band = -1;
+	memcpy(config->mac_addr, wiphys.mac_addr, ETH_ALEN);
+
+	if (!wiphys.is_single_wiphy) {
+		config->wiphy_idx = phy_idx;
+		return;
+	}
+
+	/* wiphys is in reversed order */
+	for (i = wiphys.wiphy_num - 1; i >= 0; i--) {
+		struct wiphy_config *wiphy = &wiphys.wiphy[i];
+
+		radio_num = wiphy->radio_num;
+		if (idx <= phy_idx && phy_idx < idx + radio_num) {
+			config->wiphy_idx = wiphy->wiphy_idx;
+			config->radio_idx = phy_idx - idx;
+			config->mac_addr[5] += config->radio_idx;
+			config->parking_freq = wiphy->radio[config->radio_idx].parking_freq;
+			config->band = wiphy->radio[config->radio_idx].band;
+			config->radio_num = radio_num;
+			return;
+		}
+		idx += radio_num;
+	}
 }
 
 void usage(void)
 {
 	static const char *const commands[] = {
+		"add <interface>",
+		"del <interface>",
 		"set <var>=<val> [...]",
 		"dump [stats]",
 		"eeprom file",
 		"eeprom set <addr>=<val> [...]",
 		"eeprom changes",
 		"eeprom reset",
+		"fwlog <ip> <fw_debug_bin input> <fwlog name>",
 	};
 	int i;
 
@@ -74,19 +196,26 @@ static int mt76_dump_cb(struct nl_msg *msg, void *arg)
 	return NL_SKIP;
 }
 
-static int mt76_dump(int phy, int argc, char **argv)
+static int mt76_dump(struct phy_config *config, int argc, char **argv)
 {
 	struct nl_msg *msg;
 	void *data;
 
 	msg = unl_genl_msg(&unl, NL80211_CMD_TESTMODE, true);
-	nla_put_u32(msg, NL80211_ATTR_WIPHY, phy);
+	nla_put_u32(msg, NL80211_ATTR_WIPHY, config->wiphy_idx);
 
 	data = nla_nest_start(msg, NL80211_ATTR_TESTDATA);
 
+	if (config->radio_idx >= 0)
+		nla_put_u32(msg, MT76_TM_ATTR_RADIO_IDX, config->radio_idx);
+
 	for (; argc > 0; argc--, argv++) {
 		if (!strcmp(argv[0], "stats"))
 			nla_put_flag(msg, MT76_TM_ATTR_STATS);
+		if (!strcmp(argv[0], "tb_info"))
+			nla_put_flag(msg, MT76_TM_ATTR_TB_INFO);
+		if (!strcmp(argv[0], "icap"))
+			nla_put_flag(msg, MT76_TM_ATTR_ICAP_STATS);
 	}
 
 	nla_nest_end(msg, data);
@@ -106,7 +235,7 @@ static inline bool tm_is_changed(uint32_t id)
 	return tm_changed[id / 32] & (1U << (id % 32));
 }
 
-static int mt76_set(int phy, int argc, char **argv)
+static int mt76_set(struct phy_config *config, int argc, char **argv)
 {
 	const struct tm_field *fields = msg_field.fields;
 	struct nl_msg *msg;
@@ -117,9 +246,13 @@ static int mt76_set(int phy, int argc, char **argv)
 		return 1;
 
 	msg = unl_genl_msg(&unl, NL80211_CMD_TESTMODE, false);
-	nla_put_u32(msg, NL80211_ATTR_WIPHY, phy);
+	nla_put_u32(msg, NL80211_ATTR_WIPHY, config->wiphy_idx);
 
 	data = nla_nest_start(msg, NL80211_ATTR_TESTDATA);
+
+	if (config->radio_idx >= 0)
+		nla_put_u32(msg, MT76_TM_ATTR_RADIO_IDX, config->radio_idx);
+
 	for (; argc > 0; argc--, argv++) {
 		char *name = argv[0];
 		char *val = strchr(name, '=');
@@ -164,10 +297,146 @@ static int mt76_set(int phy, int argc, char **argv)
 	return ret;
 }
 
+static int mt76_set_state_all(struct phy_config *config, char *state)
+{
+	const struct tm_field *fields = msg_field.fields;
+	struct nl_msg *msg;
+	int i, radio, max_radio, ret = 0;
+	void *data;
+
+	max_radio = config->radio_idx >= 0 ? config->radio_num : 1;
+
+	for (radio = 0; radio < max_radio; radio++) {
+		msg = unl_genl_msg(&unl, NL80211_CMD_TESTMODE, false);
+		nla_put_u32(msg, NL80211_ATTR_WIPHY, config->wiphy_idx);
+
+		data = nla_nest_start(msg, NL80211_ATTR_TESTDATA);
+
+		if (config->radio_idx >= 0)
+			nla_put_u32(msg, MT76_TM_ATTR_RADIO_IDX, radio);
+
+		for (i = 0; i < msg_field.len; i++) {
+			if (!fields[i].parse)
+				continue;
+
+			if (!strcmp(fields[i].name, "state"))
+				break;
+		}
+
+		if (!fields[i].parse(&fields[i], i, msg, state))
+			return 1;
+
+		tm_set_changed(i);
+		nla_nest_end(msg, data);
+
+		ret = unl_genl_request(&unl, msg, NULL, NULL);
+		if (ret && ret != -ENOTCONN) {
+			fprintf(stderr, "Failed to set state %s for radio %d: %s\n",
+				state, radio, strerror(-ret));
+			break;
+		}
+	}
+
+	return ret;
+}
+
+static void mt76_set_tm_reg(void)
+{
+	struct nl_msg *msg;
+	char reg[3] = "VV\0";
+	int ret;
+
+	msg = unl_genl_msg(&unl, NL80211_CMD_REQ_SET_REG, false);
+	nla_put_string(msg, NL80211_ATTR_REG_ALPHA2, reg);
+
+	ret = unl_genl_request(&unl, msg, NULL, NULL);
+	if (ret)
+		fprintf(stderr, "Failed to set reg %s: %s\n", reg, strerror(-ret));
+}
+
+static int mt76_add_iface(struct phy_config *config, int argc, char **argv)
+{
+	struct nl_msg *msg;
+	char *name, cmd[64];
+	int ret;
+
+	mt76_set_tm_reg();
+
+	if (argc < 1)
+		return 1;
+
+	name = argv[0];
+	msg = unl_genl_msg(&unl, NL80211_CMD_NEW_INTERFACE, false);
+	nla_put_u32(msg, NL80211_ATTR_WIPHY, config->wiphy_idx);
+	nla_put_u32(msg, NL80211_ATTR_IFTYPE, NL80211_IFTYPE_MONITOR);
+	nla_put_string(msg, NL80211_ATTR_IFNAME, name);
+	if (config->radio_idx >= 0)
+		nla_put_u32(msg, NL80211_ATTR_VIF_RADIO_MASK, BIT(config->radio_idx));
+
+	nla_put(msg, NL80211_ATTR_MAC, ETH_ALEN, config->mac_addr);
+
+	ret = unl_genl_request(&unl, msg, NULL, NULL);
+	if (ret) {
+		fprintf(stderr, "nl80211 call failed: %s\n", strerror(-ret));
+		return ret;
+	}
+
+	snprintf(cmd, sizeof(cmd), "ifconfig %s up", name);
+	system(cmd);
+
+	/* for single wiphy model, parking channel will not be set */
+	if (config->parking_freq) {
+		snprintf(cmd, sizeof(cmd), "iw dev %s set freq %d HT20", name, config->parking_freq);
+		system(cmd);
+	}
+
+	/* turn on testmode */
+	ret = mt76_set_state_all(config, "idle");
+	return ret;
+}
+
+static int mt76_delete_iface(struct phy_config *config, int argc, char **argv)
+{
+	unsigned int devidx;
+	struct nl_msg *msg;
+	char *name, cmd[64];
+	int ret;
+
+	if (argc < 1)
+		return 1;
+
+	name = argv[0];
+	devidx = if_nametoindex(name);
+	if (!devidx) {
+		fprintf(stderr, "Failed to find ifindex for %s: %s\n",
+			name, strerror(errno));
+		return 2;
+	}
+
+	/* turn off testmode before deleting interface */
+	ret = mt76_set_state_all(config, "off");
+	if (ret)
+		return ret;
+
+	snprintf(cmd, sizeof(cmd), "ifconfig %s down", name);
+	system(cmd);
+
+	/* delete interface */
+	msg = unl_genl_msg(&unl, NL80211_CMD_DEL_INTERFACE, false);
+	nla_put_u32(msg, NL80211_ATTR_WIPHY, config->wiphy_idx);
+	nla_put_u32(msg, NL80211_ATTR_IFINDEX, devidx);
+
+	ret = unl_genl_request(&unl, msg, NULL, NULL);
+	if (ret)
+		fprintf(stderr, "nl80211 call failed: %s\n", strerror(-ret));
+
+	return ret;
+}
+
 int main(int argc, char **argv)
 {
+	struct phy_config config = {0};
 	const char *cmd, *phyname;
-	int phy;
 	int ret = 0;
 
 	progname = argv[0];
@@ -180,9 +449,9 @@ int main(int argc, char **argv)
 	}
 
 	phyname = argv[1];
-	phy = phy_lookup_idx(phyname);
-	if (phy < 0) {
-		fprintf(stderr, "Could not find phy '%s'\n", argv[1]);
+	mt76_get_wiphy(&config, atoi(phyname + 3));
+	if (config.wiphy_idx < 0) {
+		fprintf(stderr, "Could not find phy '%s'\n", phyname);
 		return 2;
 	}
 
@@ -191,13 +460,19 @@ int main(int argc, char **argv)
 	argc -= 3;
 
 	if (!strcmp(cmd, "dump"))
-		ret = mt76_dump(phy, argc, argv);
+		ret = mt76_dump(&config, argc, argv);
 	else if (!strcmp(cmd, "set"))
-		ret = mt76_set(phy, argc, argv);
+		ret = mt76_set(&config, argc, argv);
+	else if (!strcmp(cmd, "add"))
+		ret = mt76_add_iface(&config, argc, argv);
+	else if (!strcmp(cmd, "del"))
+		ret = mt76_delete_iface(&config, argc, argv);
 	else if (!strcmp(cmd, "eeprom"))
-		ret = mt76_eeprom(phy, argc, argv);
+		ret = mt76_eeprom(config.wiphy_idx, argc, argv);
 	else if (!strcmp(cmd, "fwlog"))
 		ret = mt76_fwlog(phyname, argc, argv);
+	else if (!strcmp(cmd, "idxlog"))
+		ret = mt76_idxlog(phyname, argc, argv);
 	else
 		usage();
 
diff --git a/tools/mt76-test.h b/tools/mt76-test.h
index d2fafa862..d5bc676a2 100644
--- a/tools/mt76-test.h
+++ b/tools/mt76-test.h
@@ -19,15 +19,57 @@
 #define DIV_ROUND_UP(n, d) (((n) + (d) - 1) / (d))
 #endif
 
+#ifndef BIT
+#define BIT(n) (1UL << (n))
+#endif
+
+#ifndef ETH_ALEN
+#define ETH_ALEN	6
+#endif
+
 #define EEPROM_FILE_PATH_FMT	"/tmp/mt76-test-%s"
 #define EEPROM_PART_SIZE	20480
 
+#define FWLOG_BUF_SIZE	1504
+
 struct nl_msg;
 struct nlattr;
 
+#define MT_MAX_BAND	3
+
+struct phy_config {
+	int wiphy_idx;
+	int radio_idx;
+	int radio_num;
+	int parking_freq;
+	int band;
+	uint8_t mac_addr[ETH_ALEN];
+};
+
+struct radio_config {
+	int parking_freq;
+	enum nl80211_band band;
+};
+
+struct wiphy_config {
+	int wiphy_idx;
+	int radio_num;
+	struct radio_config radio[MT_MAX_BAND];
+};
+
+struct wiphy_list {
+	bool is_single_wiphy;
+	int wiphy_num;
+	uint8_t mac_addr[ETH_ALEN];
+	struct wiphy_config wiphy[MT_MAX_BAND * 2];
+};
+
 struct tm_field {
 	const char *name;
 	const char *prefix;
+	bool hex_parse;
+	bool hex_dump;
+	bool skip_print;
 
 	bool (*parse)(const struct tm_field *field, int idx, struct nl_msg *msg,
 		      const char *val);
@@ -43,6 +85,7 @@ struct tm_field {
 				       struct nl_msg *msg, const char *val);
 			void (*print2)(const struct tm_field *field,
 				       struct nlattr *attr);
+			int entry_len;
 		};
 		struct {
 			void (*print_extra)(const struct tm_field *field,
@@ -54,6 +97,11 @@ struct tm_field {
 	};
 };
 
+typedef unsigned char u8;
+typedef signed char s8;
+typedef unsigned short u16;
+typedef unsigned int u32;
+
 extern struct unl unl;
 extern const struct tm_field msg_field;
 extern unsigned char *eeprom_data;
@@ -61,5 +109,6 @@ extern unsigned char *eeprom_data;
 void usage(void);
 int mt76_eeprom(int phy, int argc, char **argv);
 int mt76_fwlog(const char *phyname, int argc, char **argv);
+int mt76_idxlog(const char *phyname, int argc, char **argv);
 
 #endif
-- 
2.45.2

