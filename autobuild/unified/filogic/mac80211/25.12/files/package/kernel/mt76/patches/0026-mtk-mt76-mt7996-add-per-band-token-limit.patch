From aad4ec786ce4ee1447b92756ee83c418f2be9b28 Mon Sep 17 00:00:00 2001
From: Peter Chiu <chui-hao.chiu@mediatek.com>
Date: Tue, 9 Dec 2025 17:43:17 +0800
Subject: [PATCH 026/105] mtk: mt76: mt7996: add per-band token limit

Add a threshold for per-band token count.
The bands use the same token pool so a band cannot transmit if
the other band occupy too many tokens. With this patch, we can
prevent a band from interfering with the other band.

mtk: mt76: mt7996: adjust per-band token size

Signed-off-by: Peter Chiu <chui-hao.chiu@mediatek.com>
Signed-off-by: Shayne Chen <shayne.chen@mediatek.com>
---
 mt76.h          |  6 +++++-
 mt7996/init.c   |  2 ++
 mt7996/mac.c    | 31 +++++++++++++++++++++++++++++--
 mt7996/mt7996.h |  1 +
 tx.c            | 19 ++++++++++++++++---
 5 files changed, 53 insertions(+), 6 deletions(-)

diff --git a/mt76.h b/mt76.h
index 2cf899c42..e2e8e5c7e 100644
--- a/mt76.h
+++ b/mt76.h
@@ -460,6 +460,7 @@ struct mt76_txwi_cache {
 	};
 
 	u8 qid;
+	u8 phy_idx;
 };
 
 struct mt76_rx_tid {
@@ -870,6 +871,7 @@ struct mt76_phy {
 	spinlock_t tx_lock;
 	struct list_head tx_list;
 	struct mt76_queue *q_tx[__MT_TXQ_MAX];
+	int tokens;
 
 	struct cfg80211_chan_def chandef;
 	struct cfg80211_chan_def main_chandef;
@@ -973,6 +975,7 @@ struct mt76_dev {
 	u16 token_count;
 	u16 token_start;
 	u16 token_size;
+	u16 token_threshold;
 
 	spinlock_t rx_token_lock;
 	struct idr rx_token;
@@ -2010,7 +2013,8 @@ static inline bool mt76_queue_is_npu_rx(struct mt76_queue *q)
 
 struct mt76_txwi_cache *
 mt76_token_release(struct mt76_dev *dev, int token, bool *wake);
-int mt76_token_consume(struct mt76_dev *dev, struct mt76_txwi_cache **ptxwi);
+int mt76_token_consume(struct mt76_dev *dev, struct mt76_txwi_cache **ptxwi,
+		       u8 phy_idx);
 void __mt76_set_tx_blocked(struct mt76_dev *dev, bool blocked);
 struct mt76_txwi_cache *mt76_rx_token_release(struct mt76_dev *dev, int token);
 int mt76_rx_token_consume(struct mt76_dev *dev, void *ptr,
diff --git a/mt7996/init.c b/mt7996/init.c
index 8e389cece..b6ef57790 100644
--- a/mt7996/init.c
+++ b/mt7996/init.c
@@ -1744,6 +1744,8 @@ int mt7996_register_device(struct mt7996_dev *dev)
 
 	ieee80211_queue_work(mt76_hw(dev), &dev->init_work);
 
+	dev->mt76.token_threshold = MT7996_PER_BAND_TOKEN_SIZE;
+
 	dev->recovery.hw_init_done = true;
 
 	ret = mt7996_init_debugfs(dev);
diff --git a/mt7996/mac.c b/mt7996/mac.c
index 5f92e1ab7..2da6defbf 100644
--- a/mt7996/mac.c
+++ b/mt7996/mac.c
@@ -1062,9 +1062,33 @@ int mt7996_tx_prepare_skb(struct mt76_dev *mdev, void *txwi_ptr,
 	t = (struct mt76_txwi_cache *)(txwi + mdev->drv->txwi_size);
 	t->skb = tx_info->skb;
 
-	id = mt76_token_consume(mdev, &t);
-	if (id < 0)
+	id = mt76_token_consume(mdev, &t, wcid->phy_idx);
+	if (id == -EBUSY && sta && sta->mlo) {
+		unsigned long valid_links = vif->valid_links ?: BIT(0);
+		struct mt7996_vif_link *mconf_temp;
+		unsigned int link_id_temp;
+
+		/* For MLO station, try to get token from affiliated link */
+		for_each_set_bit(link_id_temp, &valid_links,
+				 IEEE80211_MLD_MAX_NUM_LINKS) {
+			mconf_temp = (struct mt7996_vif_link *)
+				     rcu_dereference(mvif->mt76.link[link_id_temp]);
+			if (!mconf_temp)
+				continue;
+
+			id = mt76_token_consume(mdev, &t, mconf_temp->mt76.band_idx);
+			if (id >= 0)
+				break;
+		}
+	}
+
+	if (id < 0) {
+		mdev->tx_dbg_stats.tx_drop[MT_TX_DROP_GET_TOKEN_FAIL]++;
 		return id;
+	}
+#ifdef CONFIG_MTK_DEBUG
+	t->jiffies = jiffies;
+#endif
 
 	/* Since the rules of HW MLD address translation are not fully
 	 * compatible with 802.11 EAPOL frame, we do the translation by
@@ -2216,8 +2240,11 @@ void mt7996_tx_token_put(struct mt7996_dev *dev)
 
 	spin_lock_bh(&dev->mt76.token_lock);
 	idr_for_each_entry(&dev->mt76.token, txwi, id) {
+		struct mt76_phy *phy = mt76_dev_phy(&dev->mt76, txwi->phy_idx);
+
 		mt7996_txwi_free(dev, txwi, NULL, NULL, NULL);
 		dev->mt76.token_count--;
+		phy->tokens--;
 	}
 	spin_unlock_bh(&dev->mt76.token_lock);
 	idr_destroy(&dev->mt76.token);
diff --git a/mt7996/mt7996.h b/mt7996/mt7996.h
index f655cadff..a2e8a53cf 100644
--- a/mt7996/mt7996.h
+++ b/mt7996/mt7996.h
@@ -83,6 +83,7 @@
 #define MT7996_EEPROM_BLOCK_SIZE	16
 #define MT7996_TOKEN_SIZE		16384
 #define MT7996_HW_TOKEN_SIZE		8192
+#define MT7996_PER_BAND_TOKEN_SIZE	4000
 
 #define MT7996_CFEND_RATE_DEFAULT	0x49	/* OFDM 24M */
 #define MT7996_CFEND_RATE_11B		0x03	/* 11B LP, 11M */
diff --git a/tx.c b/tx.c
index 9ec6d0b53..2dc8b467f 100644
--- a/tx.c
+++ b/tx.c
@@ -841,18 +841,27 @@ void __mt76_set_tx_blocked(struct mt76_dev *dev, bool blocked)
 }
 EXPORT_SYMBOL_GPL(__mt76_set_tx_blocked);
 
-int mt76_token_consume(struct mt76_dev *dev, struct mt76_txwi_cache **ptxwi)
+int mt76_token_consume(struct mt76_dev *dev, struct mt76_txwi_cache **ptxwi,
+		       u8 phy_idx)
 {
-	int token;
+	struct mt76_phy *phy = mt76_dev_phy(dev, phy_idx);
+	int token = -EBUSY;
 
 	spin_lock_bh(&dev->token_lock);
 
+	if (phy->tokens >= dev->token_threshold)
+		goto out;
+
 	token = idr_alloc(&dev->token, *ptxwi, dev->token_start,
 			  dev->token_start + dev->token_size,
 			  GFP_ATOMIC);
-	if (token >= dev->token_start)
+	if (token >= dev->token_start) {
 		dev->token_count++;
 
+		(*ptxwi)->phy_idx = phy_idx;
+		phy->tokens++;
+	}
+
 #ifdef CONFIG_NET_MEDIATEK_SOC_WED
 	if (mtk_wed_device_active(&dev->mmio.wed) &&
 	    token >= dev->mmio.wed.wlan.token_start)
@@ -862,6 +871,7 @@ int mt76_token_consume(struct mt76_dev *dev, struct mt76_txwi_cache **ptxwi)
 	if (dev->token_count >= dev->token_size - MT76_TOKEN_FREE_THR)
 		__mt76_set_tx_blocked(dev, true);
 
+out:
 	spin_unlock_bh(&dev->token_lock);
 
 	return token;
@@ -895,7 +905,10 @@ mt76_token_release(struct mt76_dev *dev, int token, bool *wake)
 
 	txwi = idr_remove(&dev->token, token);
 	if (txwi) {
+		struct mt76_phy *phy = mt76_dev_phy(dev, txwi->phy_idx);
+
 		dev->token_count--;
+		phy->tokens--;
 
 #ifdef CONFIG_NET_MEDIATEK_SOC_WED
 		if (mtk_wed_device_active(&dev->mmio.wed) &&
-- 
2.45.2

