From 0f7f1da56d4c3812b03a4bc3b643a5b5be8785d5 Mon Sep 17 00:00:00 2001
From: Michael-CY Lee <michael-cy.lee@mediatek.com>
Date: Mon, 27 Oct 2025 16:13:36 +0800
Subject: [PATCH 240/254] mtk: wpa_s: skip the link on unused radio when
 setting MLO links

Before sending authentication, the STA determines which link(s) it wants
to connect to (i.e., determines wpa_s->valid_links).
However, if the link is operating on the radio that is disabled by the STA
interface, the STA should not choose the link.

This commit adds "vif_radio_mask", "multi_hw_info", and "num_multi_hws"
to help filtering out the unused radio(s).

Signed-off-by: Michael-CY Lee <michael-cy.lee@mediatek.com>
---
 wpa_supplicant/sme.c              | 11 ++++++-----
 wpa_supplicant/wpa_supplicant.c   | 24 +++++++++++++++++++++++-
 wpa_supplicant/wpa_supplicant_i.h |  4 ++++
 3 files changed, 33 insertions(+), 6 deletions(-)

diff --git a/wpa_supplicant/sme.c b/wpa_supplicant/sme.c
index e619e1d4d..8d5285015 100644
--- a/wpa_supplicant/sme.c
+++ b/wpa_supplicant/sme.c
@@ -542,12 +542,13 @@ static void wpas_sme_set_mlo_links(struct wpa_supplicant *wpa_s,
 
 	for_each_link(bss->valid_links, i) {
 		const u8 *bssid = bss->mld_links[i].bssid;
+		int radio_idx;
 
-		if (wpa_s->conf->freq_list &&
-		    !int_array_includes(wpa_s->conf->freq_list,
-					bss->mld_links[i].freq)) {
-			wpa_printf(MSG_DEBUG,
-				   "MLD: Skip the link on disallowed channel");
+		wpa_printf(MSG_INFO, "MLD: check freq=%u\n", bss->mld_links[i].freq);
+		radio_idx = wpas_get_radio_idx_with_freq(wpa_s, bss->mld_links[i].freq);
+		if ((BIT(radio_idx) & wpa_s->vif_radio_mask) == 0) {
+			wpa_printf(MSG_INFO,
+				   "MLD: Skip the link on unused radio");
 			continue;
 		}
 
diff --git a/wpa_supplicant/wpa_supplicant.c b/wpa_supplicant/wpa_supplicant.c
index 5d0750b9f..3de2e16bf 100644
--- a/wpa_supplicant/wpa_supplicant.c
+++ b/wpa_supplicant/wpa_supplicant.c
@@ -7653,7 +7653,7 @@ static int wpa_supplicant_init_iface(struct wpa_supplicant *wpa_s,
 				     const struct wpa_interface *iface)
 {
 	struct wpa_driver_capa capa;
-	int capa_res;
+	int capa_res, ret;
 	u8 dfs_domain;
 
 	wpa_printf(MSG_DEBUG, "Initializing interface '%s' conf '%s' driver "
@@ -7826,6 +7826,14 @@ static int wpa_supplicant_init_iface(struct wpa_supplicant *wpa_s,
 		wpa_s->support_6ghz = wpas_is_6ghz_supported(wpa_s, false);
 	}
 
+	wpa_s->multi_hw_info = wpas_drv_get_multi_hw_info(wpa_s, &wpa_s->num_multi_hws);
+	if (!wpa_s->multi_hw_info)
+		return -1;
+
+	ret = wpas_drv_get_vif_radio_mask(wpa_s, &wpa_s->vif_radio_mask);
+	if (ret || !wpa_s->vif_radio_mask)
+		return -1;
+
 	capa_res = wpa_drv_get_capa(wpa_s, &capa);
 	if (capa_res == 0) {
 		wpa_s->drv_capa_known = 1;
@@ -10142,3 +10150,17 @@ int wpas_get_owe_trans_network(const u8 *owe_ie, const u8 **bssid,
 	return -1;
 #endif /* CONFIG_OWE */
 }
+
+int wpas_get_radio_idx_with_freq(struct wpa_supplicant *wpa_s, int freq) {
+	struct hostapd_multi_hw_info *hw_info;
+	int i;
+
+	for (i = 0; i < wpa_s->num_multi_hws; i++) {
+		hw_info = &wpa_s->multi_hw_info[i];
+
+		if (hw_info->start_freq <= freq && hw_info->end_freq >= freq)
+			return hw_info->hw_idx;
+	}
+
+	return -1;
+}
diff --git a/wpa_supplicant/wpa_supplicant_i.h b/wpa_supplicant/wpa_supplicant_i.h
index a6eb71b42..da53cf6ad 100644
--- a/wpa_supplicant/wpa_supplicant_i.h
+++ b/wpa_supplicant/wpa_supplicant_i.h
@@ -1640,6 +1640,9 @@ struct wpa_supplicant {
 	unsigned int next_beacon_check;
 
 	bool scs_reconfigure;
+	struct hostapd_multi_hw_info *multi_hw_info;
+	unsigned int num_multi_hws;
+	unsigned int vif_radio_mask;
 };
 
 
@@ -2054,5 +2057,6 @@ bool wpas_ap_supports_rsn_overriding_2(struct wpa_supplicant *wpa_s,
 				       struct wpa_bss *bss);
 int wpas_get_owe_trans_network(const u8 *owe_ie, const u8 **bssid,
 			       const u8 **ssid, size_t *ssid_len);
+int wpas_get_radio_idx_with_freq(struct wpa_supplicant *wpa_s, int freq);
 
 #endif /* WPA_SUPPLICANT_I_H */
-- 
2.45.2

