From 015a2e2a2b1e5afcba777d0e42af6c29a450827c Mon Sep 17 00:00:00 2001
From: Michael-CY Lee <michael-cy.lee@mediatek.com>
Date: Tue, 30 Sep 2025 11:00:22 +0800
Subject: [PATCH 236/254] mtk: hostapd: Align QCA's prpl hostapd Neg-TTLM
 commands format

This commit aligns QCA's prpl hostapd 3 TTLM commands format:
$ hostapd_cli -i <iface> negotiated_ttlm request <STA MLD address> ...
$ hostapd_cli -i <iface> negotiated_ttlm teardown <STA MLD address>
$ hostapd_cli -i <iface> negotiated_ttlm get <STA MLD address>

The request command should follow the format:
$ hostapd_cli -i <iface> negotiated_ttlm request
<STA MLD address> <TTLM 1> <TTLM 2>

The TTLM 2 could be empty, and if the TTLM 1 is bi-direction, the
TTLM 2 should be empty.

A TTLM should start with "dir=" string and end with a TID/map pair.
The following is the format.
<TTLM>: dir=<0/1/2>, def_link_map=<0/1>, link_map_size=<0/1>,
	num_tids=<1..8> <TID> <hex link map> <TID> <hex link map> ...

Example to enable link ID 0 and 2:
00:0c:43:55:66:77 dir=2 def_link_map=0 link_map_size=1 num_tids=8 0 0x5
1 0x5 2 0x5 ... 7 0x5

Signed-off-by: Michael-CY Lee <michael-cy.lee@mediatek.com>
---
 hostapd/ctrl_iface.c  | 168 ++++++++++++++++++++++++++++++++++++++++++
 hostapd/hostapd_cli.c |  13 ++++
 2 files changed, 181 insertions(+)

diff --git a/hostapd/ctrl_iface.c b/hostapd/ctrl_iface.c
index 877a57dd1..f08f4ee9a 100644
--- a/hostapd/ctrl_iface.c
+++ b/hostapd/ctrl_iface.c
@@ -4408,6 +4408,168 @@ static int hostapd_ctrl_iface_get_neg_ttlm(struct hostapd_data *hapd, char *cmd,
 
 	return pos - buf;
 }
+
+static int
+hostapd_ctrl_iface_negotiated_ttlm_request(struct hostapd_data *hapd,
+					   char *cmd)
+{
+	struct sta_info *sta;
+	struct ieee80211_neg_ttlm *neg_ttlm;
+	struct hostapd_data *assoc_hapd;
+	char *token;
+	u16 valid_links = hapd->mld->valid_links;
+	int dir = -1, tmp;
+
+	/*
+	 * Format:
+	 * <STA MLD address> <TTLM 1> <TTLM 2>
+	 * The TTLM 2 could be empty, and if the TTLM 1 is bi-direction, the
+	 * TTLM 2 should be empty.
+	 *
+	 * A TTLM should start with "dir=" string and end with a TID/map pair.
+	 * The following is the format.
+	 * <TTLM>: dir=<0/1/2>, def_link_map=<0/1>, link_map_size=<0/1>,
+	 *         num_tids=<1..8> <TID> <hex link map> <TID> <hex link map> ...
+	 *
+	 * Example to enable link ID 0 and 2:
+	 * 00:0c:43:55:66:77 dir=2 def_link_map=0 link_map_size=1 num_tids=8 0 0x5
+	 * 1 0x5 2 0x5 ... 7 0x5
+	 */
+	token = strtok_r(cmd, " ", &cmd);
+	sta = hostapd_ctrl_read_sta(hapd, token);
+	if (!sta)
+		return -1;
+
+	sta = hostapd_ml_get_assoc_sta(hapd, sta, &assoc_hapd);
+	if (!sta || !sta->mld_info.mld_sta) {
+		wpa_printf(MSG_DEBUG, "TTLM: Invalid STA\n");
+		return -1;
+	}
+	neg_ttlm = &sta->neg_ttlm;
+	os_memset(neg_ttlm, 0, sizeof(*neg_ttlm));
+
+	token = strtok_r(NULL, " ", &cmd);
+	while (token) {
+		if (os_strncmp(token, "dir=", 4) == 0) {
+			dir = atoi(token + 4);
+			token = strtok_r(NULL, " ", &cmd);
+			if (!token) {
+				wpa_printf(MSG_ERROR, "TTLM: Invalid input");
+				return -1;
+			}
+		}
+
+		if (dir < 0 || dir > IEEE80211_TTLM_DIRECTION_BOTH) {
+			wpa_printf(MSG_ERROR, "TTLM: Invalid direction");
+			return -1;
+		}
+
+		/* TODO Add support to handle TTLM with different directions */
+		if (dir != IEEE80211_TTLM_DIRECTION_BOTH) {
+			wpa_printf(MSG_ERROR, "TTLM: Only support bi-direction");
+			return -1;
+		}
+
+		if (os_strncmp(token, "def_link_map=", 13) == 0) {
+			tmp = atoi(token + 13);
+			if (tmp < 0 || tmp > 2) {
+				wpa_printf(MSG_ERROR,
+					   "TTLM: Invalid def_link_map value: %d",
+					   tmp);
+				return -1;
+			}
+
+			neg_ttlm->def_link_map = !!tmp;
+			if (neg_ttlm->def_link_map)
+				dir = -1;
+		} else if (os_strncmp(token, "link_map_size=", 15) == 0) {
+			tmp = atoi(token + 15);
+			if (tmp < 0 || tmp > 2) {
+				wpa_printf(MSG_ERROR,
+					   "TTLM: Invalid link_map_size value: %d",
+					   tmp);
+				return -1;
+			}
+
+			neg_ttlm->link_map_size = tmp;
+		} else if (os_strncmp(token, "num_tids=", 9) == 0) {
+			int num_tids = atoi(token + 9), i, tid, map;
+			char *tid_str, *map_str;
+
+			if (num_tids < 0 || num_tids > IEEE80211_TTLM_NUM_TIDS) {
+				wpa_printf(MSG_ERROR,
+					   "TTLM: Invalid number of TIDs: %d", num_tids);
+				return -1;
+			}
+
+			/* If the link map is not specified for some tids, the
+			 * tids should be mapped to all valid links
+			 */
+			os_memset(neg_ttlm->dlink, valid_links, sizeof(neg_ttlm->dlink));
+			os_memset(neg_ttlm->ulink, valid_links, sizeof(neg_ttlm->ulink));
+			for (i = 0; i < num_tids; i++) {
+				tid_str = strtok_r(NULL, " ", &cmd);
+				map_str = strtok_r(NULL, " ", &cmd);
+
+				if (!tid_str || !map_str) {
+					wpa_printf(MSG_ERROR,
+						   "TTLM: Invalid TID/map");
+					return -1;
+				}
+
+				tid = atoi(tid_str);
+				if (tid < 0 || tid > IEEE80211_TTLM_NUM_TIDS) {
+					wpa_printf(MSG_ERROR,
+						   "TTLM: Invalid TID: %d", tid);
+					return -1;
+				}
+
+				map = strtol(map_str, NULL, 0);
+				if (map < 0 || map > BIT(MAX_NUM_MLD_LINKS) - 1) {
+					wpa_printf(MSG_ERROR,
+						   "TTLM: Invalid map: %d", map);
+					return -1;
+				}
+
+				neg_ttlm->dlink[tid] = map;
+				neg_ttlm->ulink[tid] = map;
+			}
+
+			/* End of the TTLM */
+			dir = -1;
+		}
+
+		token = strtok_r(NULL, " ", &cmd);
+	}
+
+	if (ieee802_11_send_neg_ttlm_request(hapd, sta)) {
+		wpa_printf(MSG_DEBUG, "Failed sending Negotiated TTLM request");
+		return -1;
+	}
+
+	return 0;
+}
+
+static int hostapd_ctrl_iface_negotiated_ttlm(struct hostapd_data *hapd, char *cmd)
+{
+	if (!hostapd_is_mld_ap(hapd) || !hapd->mld) {
+		wpa_printf(MSG_ERROR, "TTLM: Invalid hapd");
+		return -1;
+	}
+
+	if (os_strncmp(cmd, "request ", 8) == 0) {
+		wpa_printf(MSG_DEBUG, "TTLM: Request");
+		return hostapd_ctrl_iface_negotiated_ttlm_request(hapd, cmd + 8);
+	} else if (os_strncmp(cmd, "response ", 9) == 0) {
+		wpa_printf(MSG_ERROR, "TTLM: Response is not supported");
+		return -1;
+	} else if (os_strncmp(cmd, "teardown ", 9) == 0) {
+		wpa_printf(MSG_DEBUG, "TTLM: Teardown");
+		return hostapd_ctrl_iface_neg_ttlm_teardown(hapd, cmd + 9);
+	}
+
+	return 0;
+}
 #endif /* CONFIG_TESTING_OPTIONS */
 #endif /* CONFIG_IEEE80211BE */
 
@@ -7158,6 +7320,12 @@ static int hostapd_ctrl_iface_receive_process(struct hostapd_data *hapd,
 	} else if (os_strncmp(buf, "GET_NEG_TTLM ", 13) == 0) {
 		reply_len = hostapd_ctrl_iface_get_neg_ttlm(hapd, buf + 13,
 							    reply, reply_size);
+	} else if (os_strncmp(buf, "NEGOTIATED_TTLM get ", 20) == 0) {
+		reply_len = hostapd_ctrl_iface_get_neg_ttlm(hapd, buf + 20,
+							    reply, reply_size);
+	} else if (os_strncmp(buf, "NEGOTIATED_TTLM ", 16) == 0) {
+		if (hostapd_ctrl_iface_negotiated_ttlm(hapd, buf + 16))
+			reply_len = -1;
 #endif /* CONFIG_TESTING_OPTIONS */
 #endif /* CONFIG_IEEE80211BE */
 #ifdef CONFIG_SAE
diff --git a/hostapd/hostapd_cli.c b/hostapd/hostapd_cli.c
index cb2fb9b68..796741fbe 100644
--- a/hostapd/hostapd_cli.c
+++ b/hostapd/hostapd_cli.c
@@ -1858,6 +1858,17 @@ static int hostapd_cli_cmd_get_neg_ttlm(struct wpa_ctrl *ctrl, int argc,
 	return hostapd_cli_cmd(ctrl, "GET_NEG_TTLM", 1, argc, argv);
 }
 
+static int hostapd_cli_cmd_negotiated_ttlm(struct wpa_ctrl *ctrl, int argc,
+					   char *argv[])
+{
+       if (argc < 2) {
+               printf("Invalid 'negotiated_ttlm command' - needs at least 2 arguments\n");
+               return -1;
+       }
+
+       return hostapd_cli_cmd(ctrl, "NEGOTIATED_TTLM", 1, argc, argv);
+}
+
 static int hostapd_cli_cmd_epcs(struct wpa_ctrl *ctrl, int argc, char *argv[])
 {
 	return hostapd_cli_cmd(ctrl, "EPCS", 1, argc, argv);
@@ -2203,6 +2214,8 @@ static const struct hostapd_cli_cmd hostapd_cli_commands[] = {
 		" = Teardown the Negotiated TTLM with the STA" },
 	{ "get_neg_ttlm", hostapd_cli_cmd_get_neg_ttlm, NULL,
 		" = Get the Negotiated TTLM Status of the STA" },
+	{ "negotiated_ttlm", hostapd_cli_cmd_negotiated_ttlm, NULL,
+		" = send ttlm test commands" },
 	{ "epcs", hostapd_cli_cmd_epcs, NULL,
 		" = Control EPCS priority access" },
 	{ "del_mscs", hostapd_cli_cmd_del_mscs, NULL,
-- 
2.45.2

