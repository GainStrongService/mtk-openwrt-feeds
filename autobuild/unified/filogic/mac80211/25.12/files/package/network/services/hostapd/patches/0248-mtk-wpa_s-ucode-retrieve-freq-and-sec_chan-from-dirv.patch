From 00bfd5ba08884cfeb7fa5263ee895c22f92c2e39 Mon Sep 17 00:00:00 2001
From: Michael-CY Lee <michael-cy.lee@mediatek.com>
Date: Thu, 4 Dec 2025 16:04:28 +0800
Subject: [PATCH 248/254] mtk: wpa_s: ucode: retrieve 'freq' and 'sec_chan'
 from dirver instead of wpa_s->current_bss

The wpa_s->current_bss is set when sending authentication.
If the AP's channel information changes (e.g. bandwidth) during the
assotiation, the wpa_s->current_bss remains unchanged.
Therefore it cannot be use when shyncronizing channel information to
Extender AP interfaces. Instead, the channel information from driver
can be used.

Signed-off-by: Michael-CY Lee <michael-cy.lee@mediatek.com>
---
 wpa_supplicant/ucode.c | 45 ++++++++++++++++--------------------------
 1 file changed, 17 insertions(+), 28 deletions(-)

diff --git a/wpa_supplicant/ucode.c b/wpa_supplicant/ucode.c
index 2b1cc3a54..cfc67461d 100644
--- a/wpa_supplicant/ucode.c
+++ b/wpa_supplicant/ucode.c
@@ -365,29 +365,6 @@ out:
 	return ucv_int64_new(ret);
 }
 
-static void
-uc_wpas_iface_status_bss(uc_value_t *ret, struct wpa_bss *bss)
-{
-	int sec_chan = 0;
-	const u8 *ie;
-
-	ie = wpa_bss_get_ie(bss, WLAN_EID_HT_OPERATION);
-	if (ie && ie[1] >= 2) {
-		const struct ieee80211_ht_operation *ht_oper;
-		int sec;
-
-		ht_oper = (const void *) (ie + 2);
-		sec = ht_oper->ht_param & HT_INFO_HT_PARAM_SECONDARY_CHNL_OFF_MASK;
-		if (sec == HT_INFO_HT_PARAM_SECONDARY_CHNL_ABOVE)
-			sec_chan = 1;
-		else if (sec == HT_INFO_HT_PARAM_SECONDARY_CHNL_BELOW)
-			sec_chan = -1;
-	}
-
-	ucv_object_add(ret, "sec_chan_offset", ucv_int64_new(sec_chan));
-	ucv_object_add(ret, "frequency", ucv_int64_new(bss->freq));
-}
-
 static void
 uc_wpas_iface_status_multi_ap(uc_vm_t *vm, uc_value_t *ret, struct wpa_supplicant *wpa_s)
 {
@@ -411,9 +388,12 @@ uc_wpas_iface_status_channel_info(struct wpa_supplicant *wpa_s,
 {
 	enum oper_chan_width oper_chwidth;
 	enum chan_width width;
-	int center_freq1, bw320_offset = 1, radio_idx;
+	enum hostapd_hw_mode hw_mode;
+	int center_freq1, bw320_offset = 1, radio_idx, sec_chan = 0;
+	u8 channel;
 	u16 punct_bitmap;
 	u32 freq;
+	bool is_24ghz;
 
 	if (link_id >= 0) {
 		freq = wpa_s->links[link_id].freq;
@@ -455,7 +435,19 @@ uc_wpas_iface_status_channel_info(struct wpa_supplicant *wpa_s,
 		break;
 	}
 
+	hw_mode = ieee80211_freq_to_chan(freq, &channel);
+	is_24ghz = hw_mode == HOSTAPD_MODE_IEEE80211G ||
+		   hw_mode == HOSTAPD_MODE_IEEE80211B;
+	if (freq != center_freq1) {
+		if (is_24ghz)
+			sec_chan = (freq < center_freq1) ? 1 : -1;
+		else
+			sec_chan = (freq / 20) & 1 ? 1 : -1;
+	}
+
 	radio_idx = wpas_get_radio_idx_with_freq(wpa_s, freq);
+	ucv_object_add(ret, "frequency", ucv_int64_new(freq));
+	ucv_object_add(ret, "sec_chan_offset", ucv_int64_new(sec_chan));
 	ucv_object_add(ret, "radio_idx", ucv_int64_new(radio_idx));
 	ucv_object_add(ret, "oper_chwidth", ucv_int64_new(oper_chwidth));
 	ucv_object_add(ret, "bw320_offset", ucv_int64_new(bw320_offset));
@@ -478,10 +470,8 @@ uc_wpas_iface_status(uc_vm_t *vm, size_t nargs)
 	ucv_object_add(ret, "vif_radio_mask", ucv_int64_new(wpa_s->vif_radio_mask));
 
 	bss = wpa_s->current_bss;
-	if (bss) {
-		uc_wpas_iface_status_bss(ret, bss);
+	if (bss)
 		uc_wpas_iface_status_channel_info(wpa_s, ret, -1);
-	}
 
 	if (wpa_s->valid_links) {
 		unsigned int valid_links = wpa_s->valid_links;
@@ -498,7 +488,6 @@ uc_wpas_iface_status(uc_vm_t *vm, size_t nargs)
 				continue;
 
 			link = ucv_object_new(vm);
-			uc_wpas_iface_status_bss(link, bss);
 			uc_wpas_iface_status_channel_info(wpa_s, link, i);
 			ucv_array_set(links, i, link);
 		}
-- 
2.45.2

