From 9f809f395b20228ab3cd506f7e0a15da87935e6a Mon Sep 17 00:00:00 2001
From: StanleyYP Wang <StanleyYP.Wang@mediatek.com>
Date: Thu, 4 Sep 2025 16:49:50 +0800
Subject: [PATCH 219/254] mtk: hostapd: rework mld started

Rework mld started to support DFS CAC case
For an AP MLD with 2/5G radio, the previous design did not set its
mld->started flag until CAC was completed

Signed-off-by: StanleyYP Wang <StanleyYP.Wang@mediatek.com>
---
 src/ap/hostapd.c | 69 ++++++++++++++++++++++++++++++++++++++++--------
 1 file changed, 58 insertions(+), 11 deletions(-)

diff --git a/src/ap/hostapd.c b/src/ap/hostapd.c
index 06c17e5fc..b032629cb 100644
--- a/src/ap/hostapd.c
+++ b/src/ap/hostapd.c
@@ -1439,17 +1439,11 @@ static int hostapd_start_beacon(struct hostapd_data *hapd,
 		return -1;
 
 #ifdef CONFIG_IEEE80211BE
-	if (hapd->conf->mld_ap && (!hapd->mld->started ||
-				   hapd->conf->mld_allowed_links == 255)) {
-		u16 valid_links = hapd->mld->valid_links;
-
-		if (valid_links == hapd->conf->mld_allowed_links ||
-		    hapd->conf->mld_allowed_links == 255 ||
-		    !hapd->conf->mld_allowed_links) {
-			hapd->mld->started = 1;
-			ieee802_11_set_beacon(hapd);
-		}
-	}
+
+	/* set additional beacon to enable beacon for the last link of an AP MLD */
+	if (hapd->conf->mld_ap && hapd->mld->started &&
+	    ieee802_11_set_beacon_per_bss_only(hapd) < 0)
+		return -1;
 
 	if (flush_old_stations &&
 	    conf->broadcast_deauth && (hapd->conf->mld_ap && !hapd->mld->started)) {
@@ -2716,6 +2710,58 @@ void hostapd_owe_update_trans(struct hostapd_iface *iface)
 }
 
 
+static void hostapd_mld_started(struct hostapd_iface *iface)
+{
+#ifdef CONFIG_IEEE80211BE
+	struct hostapd_data *hapd;
+	unsigned int i, j, k;
+	u16 valid_links;
+
+	for (i = 0; i < iface->num_bss; i++) {
+		hapd = iface->bss[i];
+		if (!hapd->conf->mld_ap || !hapd->mld || hapd->mld->started)
+			continue;
+
+		valid_links = hapd->mld->valid_links | BIT(hapd->mld_link_id);
+		/*
+		 * For non-first BSSes of the interface that require CAC,
+		 * they will not be added to the valid link until CAC is completed.
+		 */
+		for (j = 0; j < iface->interfaces->count; j++) {
+			struct hostapd_iface *tmp_iface = iface->interfaces->iface[j];
+
+			if (!tmp_iface || tmp_iface == iface || !tmp_iface->cac_started)
+				continue;
+			for (k = 0; k < tmp_iface->num_bss; k++) {
+				struct hostapd_data *tmp = tmp_iface->bss[k];
+
+				if (!tmp || !tmp->conf->mld_ap || !tmp->mld ||
+				    !hostapd_is_ml_partner(tmp, hapd))
+					continue;
+
+				valid_links |= BIT(tmp->mld_link_id);
+			}
+		}
+
+		if (hapd->conf->mld_allowed_links != valid_links &&
+		    hapd->conf->mld_allowed_links != 255 &&
+		    hapd->conf->mld_allowed_links != 0)
+			continue;
+
+		hapd->mld->started = 1;
+
+		if (hapd->conf->eml_disable)
+			hapd->mld->eml_disable = hapd->conf->eml_disable;
+		if (hapd->conf->eml_resp)
+			hapd->mld->eml_resp = hapd->conf->eml_resp;
+
+		if (hapd->conf->epcs_disabled)
+			hapd->mld->epcs_disabled = hapd->conf->epcs_disabled;
+	}
+#endif /* CONFIG_IEEE80211BE */
+}
+
+
 static void hostapd_interface_setup_failure_handler(void *eloop_ctx,
 						    void *timeout_ctx)
 {
@@ -2743,6 +2789,7 @@ static int hostapd_setup_interface_complete_sync(struct hostapd_iface *iface,
 	if (err)
 		goto fail;
 
+	hostapd_mld_started(iface);
 	hostapd_ubus_add_iface(iface);
 	wpa_printf(MSG_DEBUG, "Completing interface initialization");
 	if (iface->freq) {
-- 
2.45.2

