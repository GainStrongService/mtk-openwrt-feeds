From c8937d5141fd70ab7b51d2bc16dd67cd431b1668 Mon Sep 17 00:00:00 2001
From: Zong-Zhe Yang <kevin_yang@realtek.com>
Date: Fri, 19 Sep 2025 12:24:47 +0200
Subject: [PATCH 01/11] iw: jump to 2025-10-27 codebase

iw: update nl80211.h

Also deal with the new extended feature bit.

Signed-off-by: Zong-Zhe Yang <kevin_yang@realtek.com>
[squash, use current wireless-next version]
Signed-off-by: Johannes Berg <johannes.berg@intel.com>

iw: util: support parsing link id

For NL80211_FLAG_MLO_VALID_LINK_ID cases, MLD needs to assign link id,
but non-MLD doesn't. Add support of parsing link id where the pattern
is as below. To avoid mess where some fields could have "link-id" as a
value, this pattern is only parsed at the beginning of argv.

	[link-id <LINK ID>]

If found, put NL80211_ATTR_MLO_LINK_ID and remove the assignment from
the argv range.

Signed-off-by: Zong-Zhe Yang <kevin_yang@realtek.com>
Link: https://patch.msgid.link/20250922071017.11954-2-kevin_yang@realtek.com
Signed-off-by: Johannes Berg <johannes.berg@intel.com>

iw: bitrate: refactor description

The description is too long to read, and some parameters
have been described incorrectly, e.g. vht-mcs.

Re-plan macro for description and use it.

Signed-off-by: Zong-Zhe Yang <kevin_yang@realtek.com>
Link: https://patch.msgid.link/20250922071017.11954-3-kevin_yang@realtek.com
Signed-off-by: Johannes Berg <johannes.berg@intel.com>

iw: bitrate: support EHT rate/gi/ltf

Support eht-mcs-*/eht-gi-*/eht-ltf-* fields when iw set bitrates.

Signed-off-by: Zong-Zhe Yang <kevin_yang@realtek.com>
Link: https://patch.msgid.link/20250922071017.11954-4-kevin_yang@realtek.com
Signed-off-by: Johannes Berg <johannes.berg@intel.com>

iw: bitrate: support link id

For MLD, support to assign link-id field. For non-MLD, just as before,
no need to assign it. If going to assign link-id field, need to place
it at the beginning of argv (i.e. right after "set bitrates").

	set bitrates [link-id <LINK ID>] ...

Signed-off-by: Zong-Zhe Yang <kevin_yang@realtek.com>
Link: https://patch.msgid.link/20250922071017.11954-5-kevin_yang@realtek.com
Signed-off-by: Johannes Berg <johannes.berg@intel.com>

iw: connect: Add support for WPA3 SAE association

If the driver advertises NL80211_EXT_FEATURE_SAE_OFFLOAD, pass the
SAE password and let it handle SAE.

Added extra auth and key option to connect since SAE requires a separate
AUTHTYPE and a password instead of pre-shared keys.

Signed-off-by: Wonseok Kim <wonseok.kim@morsemicro.com>
Link: https://patch.msgid.link/20251008044847.16966-1-wonseok.kim@morsemicro.com
Signed-off-by: Johannes Berg <johannes.berg@intel.com>
---
 bitrate.c | 207 ++++++++++++++++++++++++++++++++++++++++++--
 connect.c |   8 ++
 info.c    |   1 +
 iw.h      |   1 +
 nl80211.h | 255 ++++++++++++++++++++++++++++++++++++++++++++++++++++--
 util.c    |  59 ++++++++++++-
 6 files changed, 515 insertions(+), 16 deletions(-)

diff --git a/bitrate.c b/bitrate.c
index 8714669..4ed7f2a 100644
--- a/bitrate.c
+++ b/bitrate.c
@@ -7,7 +7,7 @@
 static int parse_rate_chunk(const char *arg, __u8 *nss, __u16 *mcs, unsigned int mode)
 {
 	unsigned int count, i;
-	unsigned int inss, mcs_start, mcs_end, tab[12];
+	unsigned int inss, mcs_start, mcs_end, tab[16];
 	unsigned int max_mcs = 0, max_nss = 0;
 
 	*nss = 0; *mcs = 0;
@@ -15,6 +15,9 @@ static int parse_rate_chunk(const char *arg, __u8 *nss, __u16 *mcs, unsigned int
 	if (mode == NL80211_TXRATE_HE) {
 		max_mcs = 11;
 		max_nss = NL80211_HE_NSS_MAX;
+	} else if (mode == NL80211_TXRATE_EHT) {
+		max_mcs = 15;
+		max_nss = NL80211_EHT_NSS_MAX;
 	} else {
 		max_mcs = 9;
 		max_nss = NL80211_VHT_NSS_MAX;
@@ -47,6 +50,12 @@ static int parse_rate_chunk(const char *arg, __u8 *nss, __u16 *mcs, unsigned int
 				       &inss, &tab[0], &tab[1], &tab[2], &tab[3],
 				       &tab[4], &tab[5], &tab[6], &tab[7], &tab[8],
 				       &tab[9], &tab[10], &tab[11]);
+		} else if (mode == NL80211_TXRATE_EHT) {
+			count = sscanf(arg, "%u:%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,%u",
+				       &inss, &tab[0], &tab[1], &tab[2], &tab[3],
+				       &tab[4], &tab[5], &tab[6], &tab[7], &tab[8],
+				       &tab[9], &tab[10], &tab[11], &tab[12], &tab[13],
+				       &tab[14], &tab[15]);
 		} else {
 			count = sscanf(arg, "%u:%u,%u,%u,%u,%u,%u,%u,%u,%u,%u", &inss,
 				       &tab[0], &tab[1], &tab[2], &tab[3], &tab[4],
@@ -80,6 +89,11 @@ static int parse_he_chunk(const char *arg, __u8 *nss, __u16 *mcs)
 	return parse_rate_chunk(arg, nss, mcs, NL80211_TXRATE_HE);
 }
 
+static int parse_eht_chunk(const char *arg, __u8 *nss, __u16 *mcs)
+{
+	return parse_rate_chunk(arg, nss, mcs, NL80211_TXRATE_EHT);
+}
+
 static int setup_vht(struct nl80211_txrate_vht *txrate_vht,
 		     int argc, char **argv)
 {
@@ -120,6 +134,26 @@ static int setup_he(struct nl80211_txrate_he *txrate_he,
 	return 1;
 }
 
+static int setup_eht(struct nl80211_txrate_eht *txrate_eht,
+		     int argc, char **argv)
+{
+	__u8 nss;
+	__u16 mcs;
+	int i;
+
+	memset(txrate_eht, 0, sizeof(*txrate_eht));
+
+	for (i = 0; i < argc; i++) {
+		if (!parse_eht_chunk(argv[i], &nss, &mcs))
+			return 0;
+
+		nss--;
+		txrate_eht->mcs[nss] |= mcs;
+	}
+
+	return 1;
+}
+
 #define HE_GI_STR_MAX	16
 #define HE_GI_08_STR "0.8"
 #define HE_GI_16_STR "1.6"
@@ -139,6 +173,24 @@ static int parse_he_gi(char *he_gi)
 	return -1;
 }
 
+#define EHT_GI_08_STR "0.8"
+#define EHT_GI_16_STR "1.6"
+#define EHT_GI_32_STR "3.2"
+static int parse_eht_gi(char *eht_gi)
+{
+	if (eht_gi == NULL)
+		return 0;
+
+	if (!strncmp(eht_gi, EHT_GI_08_STR, sizeof(EHT_GI_08_STR)))
+		return NL80211_RATE_INFO_EHT_GI_0_8;
+	if (!strncmp(eht_gi, EHT_GI_16_STR, sizeof(EHT_GI_16_STR)))
+		return NL80211_RATE_INFO_EHT_GI_1_6;
+	if (!strncmp(eht_gi, EHT_GI_32_STR, sizeof(EHT_GI_32_STR)))
+		return NL80211_RATE_INFO_EHT_GI_3_2;
+
+	return -1;
+}
+
 #define VHT_ARGC_MAX	100
 
 int set_bitrates(struct nl_msg *msg,
@@ -156,6 +208,7 @@ int set_bitrates(struct nl_msg *msg,
 	bool have_vht_mcs_24 = false, have_vht_mcs_5 = false;
 	bool have_he_mcs_24 = false, have_he_mcs_5 = false;
 	bool have_he_mcs_6 = false;
+	bool have_eht_mcs_24 = false, have_eht_mcs_5 = false, have_eht_mcs_6 = false;
 	uint8_t ht_mcs_24[77], ht_mcs_5[77];
 	int n_ht_mcs_24 = 0, n_ht_mcs_5 = 0;
 	struct nl80211_txrate_vht txrate_vht_24 = {};
@@ -163,21 +216,32 @@ int set_bitrates(struct nl_msg *msg,
 	struct nl80211_txrate_he txrate_he_24 = {};
 	struct nl80211_txrate_he txrate_he_5 = {};
 	struct nl80211_txrate_he txrate_he_6 = {};
+	struct nl80211_txrate_eht txrate_eht_24 = {};
+	struct nl80211_txrate_eht txrate_eht_5 = {};
+	struct nl80211_txrate_eht txrate_eht_6 = {};
 	uint8_t *mcs = NULL;
 	int *n_mcs = NULL;
 	char *vht_argv_5[VHT_ARGC_MAX] = {}; char *vht_argv_24[VHT_ARGC_MAX] = {};
 	char *he_argv_5[VHT_ARGC_MAX] = {}; char *he_argv_24[VHT_ARGC_MAX] = {};
 	char *he_argv_6[VHT_ARGC_MAX] = {};
-	char **vht_argv = NULL, **he_argv = NULL;
+	char *eht_argv_24[VHT_ARGC_MAX] = {};
+	char *eht_argv_5[VHT_ARGC_MAX] = {};
+	char *eht_argv_6[VHT_ARGC_MAX] = {};
+	char **vht_argv = NULL, **he_argv = NULL, **eht_argv = NULL;
 	int vht_argc_5 = 0; int vht_argc_24 = 0;
 	int he_argc_5 = 0; int he_argc_24 = 0;
 	int he_argc_6 = 0;
-	int *vht_argc = NULL, *he_argc = NULL;
+	int eht_argc_24 = 0, eht_argc_5 = 0, eht_argc_6 = 0;
+	int *vht_argc = NULL, *he_argc = NULL, *eht_argc = NULL;
 	int sgi_24 = 0, sgi_5 = 0, lgi_24 = 0, lgi_5 = 0;
 	int has_he_gi_24 = 0, has_he_gi_5 = 0, has_he_ltf_24 = 0, has_he_ltf_5 = 0;
 	int has_he_gi_6 = 0, has_he_ltf_6 = 0;
+	int has_eht_gi_24 = 0, has_eht_gi_5 = 0, has_eht_gi_6 = 0;
+	int has_eht_ltf_24 = 0, has_eht_ltf_5 = 0, has_eht_ltf_6 = 0;
 	int he_gi = 0, he_ltf = 0;
 	char *he_gi_argv = NULL;
+	int eht_gi = 0, eht_ltf = 0;
+	char *eht_gi_argv = NULL;
 
 	enum {
 		S_NONE,
@@ -185,9 +249,12 @@ int set_bitrates(struct nl_msg *msg,
 		S_HT,
 		S_VHT,
 		S_HE,
+		S_EHT,
 		S_GI,
 		S_HE_GI,
 		S_HE_LTF,
+		S_EHT_GI,
+		S_EHT_LTF,
 	} parser_state = S_NONE;
 
 	for (i = 0; i < argc; i++) {
@@ -259,6 +326,27 @@ int set_bitrates(struct nl_msg *msg,
 			he_argv = he_argv_6;
 			he_argc = &he_argc_6;
 			have_he_mcs_6 = true;
+		} else if (strcmp(argv[i], "eht-mcs-2.4") == 0) {
+			if (have_eht_mcs_24)
+				return 1;
+			parser_state = S_EHT;
+			eht_argv = eht_argv_24;
+			eht_argc = &eht_argc_24;
+			have_eht_mcs_24 = true;
+		} else if (strcmp(argv[i], "eht-mcs-5") == 0) {
+			if (have_eht_mcs_5)
+				return 1;
+			parser_state = S_EHT;
+			eht_argv = eht_argv_5;
+			eht_argc = &eht_argc_5;
+			have_eht_mcs_5 = true;
+		} else if (strcmp(argv[i], "eht-mcs-6") == 0) {
+			if (have_eht_mcs_6)
+				return 1;
+			parser_state = S_EHT;
+			eht_argv = eht_argv_6;
+			eht_argc = &eht_argc_6;
+			have_eht_mcs_6 = true;
 		} else if (strcmp(argv[i], "sgi-2.4") == 0) {
 			sgi_24 = 1;
 			parser_state = S_GI;
@@ -289,6 +377,24 @@ int set_bitrates(struct nl_msg *msg,
 		} else if (strcmp(argv[i], "he-ltf-6") == 0) {
 			has_he_ltf_6 = 1;
 			parser_state = S_HE_LTF;
+		} else if (strcmp(argv[i], "eht-gi-2.4") == 0) {
+			has_eht_gi_24 = 1;
+			parser_state = S_EHT_GI;
+		} else if (strcmp(argv[i], "eht-gi-5") == 0) {
+			has_eht_gi_5 = 1;
+			parser_state = S_EHT_GI;
+		} else if (strcmp(argv[i], "eht-gi-6") == 0) {
+			has_eht_gi_6 = 1;
+			parser_state = S_EHT_GI;
+		} else if (strcmp(argv[i], "eht-ltf-2.4") == 0) {
+			has_eht_ltf_24 = 1;
+			parser_state = S_EHT_LTF;
+		} else if (strcmp(argv[i], "eht-ltf-5") == 0) {
+			has_eht_ltf_5 = 1;
+			parser_state = S_EHT_LTF;
+		} else if (strcmp(argv[i], "eht-ltf-6") == 0) {
+			has_eht_ltf_6 = 1;
+			parser_state = S_EHT_LTF;
 		} else switch (parser_state) {
 		case S_LEGACY:
 			tmpd = strtod(argv[i], &end);
@@ -316,6 +422,11 @@ int set_bitrates(struct nl_msg *msg,
 				return 1;
 			he_argv[(*he_argc)++] = argv[i];
 			break;
+		case S_EHT:
+			if (*eht_argc >= VHT_ARGC_MAX)
+				return 1;
+			eht_argv[(*eht_argc)++] = argv[i];
+			break;
 		case S_GI:
 			break;
 		case S_HE_GI:
@@ -329,6 +440,19 @@ int set_bitrates(struct nl_msg *msg,
 				return 1;
 			he_ltf = he_ltf >> 1;
 			break;
+		case S_EHT_GI:
+			eht_gi_argv = argv[i];
+			break;
+		case S_EHT_LTF:
+			eht_ltf = strtol(argv[i], &end, 0);
+			if (*end != '\0')
+				return 1;
+			if (eht_ltf < 1 || eht_ltf > 8)
+				return 1;
+			if (eht_ltf != 1 && eht_ltf % 2)
+				return 1;
+			eht_ltf >>= 1;
+			break;
 		default:
 			if (attr != NL80211_ATTR_TX_RATES)
 				goto next;
@@ -360,6 +484,18 @@ next:
 		if (!setup_he(&txrate_he_6, he_argc_6, he_argv_6))
 			return -EINVAL;
 
+	if (have_eht_mcs_24)
+		if (!setup_eht(&txrate_eht_24, eht_argc_24, eht_argv_24))
+			return -EINVAL;
+
+	if (have_eht_mcs_5)
+		if (!setup_eht(&txrate_eht_5, eht_argc_5, eht_argv_5))
+			return -EINVAL;
+
+	if (have_eht_mcs_6)
+		if (!setup_eht(&txrate_eht_6, eht_argc_6, eht_argv_6))
+			return -EINVAL;
+
 	if (sgi_5 && lgi_5)
 		return 1;
 
@@ -372,12 +508,19 @@ next:
 			return 1;
 	}
 
+	if (eht_gi_argv) {
+		eht_gi = parse_eht_gi(eht_gi_argv);
+		if (eht_gi < 0)
+			return 1;
+	}
+
 	nl_rates = nla_nest_start(msg, attr);
 	if (!nl_rates)
 		goto nla_put_failure;
 
 	if (have_legacy_24 || have_ht_mcs_24 || have_vht_mcs_24 || have_he_mcs_24 ||
-	    sgi_24 || lgi_24 || has_he_gi_24 || has_he_ltf_24) {
+	    sgi_24 || lgi_24 || has_he_gi_24 || has_he_ltf_24 ||
+	    have_eht_mcs_24 || has_eht_gi_24 || has_eht_ltf_24) {
 		nl_band = nla_nest_start(msg, NL80211_BAND_2GHZ);
 		if (!nl_band)
 			goto nla_put_failure;
@@ -390,6 +533,9 @@ next:
 		if (have_he_mcs_24)
 			nla_put(msg, NL80211_TXRATE_HE, sizeof(txrate_he_24),
 				&txrate_he_24);
+		if (have_eht_mcs_24)
+			nla_put(msg, NL80211_TXRATE_EHT, sizeof(txrate_eht_24),
+				&txrate_eht_24);
 		if (sgi_24)
 			nla_put_u8(msg, NL80211_TXRATE_GI, NL80211_TXRATE_FORCE_SGI);
 		if (lgi_24)
@@ -398,11 +544,16 @@ next:
 			nla_put_u8(msg, NL80211_TXRATE_HE_GI, he_gi);
 		if (has_he_ltf_24)
 			nla_put_u8(msg, NL80211_TXRATE_HE_LTF, he_ltf);
+		if (has_eht_gi_24)
+			nla_put_u8(msg, NL80211_TXRATE_EHT_GI, eht_gi);
+		if (has_eht_ltf_24)
+			nla_put_u8(msg, NL80211_TXRATE_EHT_LTF, eht_ltf);
 		nla_nest_end(msg, nl_band);
 	}
 
 	if (have_legacy_5 || have_ht_mcs_5 || have_vht_mcs_5 || have_he_mcs_5 ||
-	    sgi_5 || lgi_5 || has_he_gi_5 || has_he_ltf_5) {
+	    sgi_5 || lgi_5 || has_he_gi_5 || has_he_ltf_5 ||
+	    have_eht_mcs_5 || has_eht_gi_5 || has_eht_ltf_5) {
 		nl_band = nla_nest_start(msg, NL80211_BAND_5GHZ);
 		if (!nl_band)
 			goto nla_put_failure;
@@ -415,6 +566,9 @@ next:
 		if (have_he_mcs_5)
 			nla_put(msg, NL80211_TXRATE_HE, sizeof(txrate_he_5),
 				&txrate_he_5);
+		if (have_eht_mcs_5)
+			nla_put(msg, NL80211_TXRATE_EHT, sizeof(txrate_eht_5),
+				&txrate_eht_5);
 		if (sgi_5)
 			nla_put_u8(msg, NL80211_TXRATE_GI, NL80211_TXRATE_FORCE_SGI);
 		if (lgi_5)
@@ -423,20 +577,32 @@ next:
 			nla_put_u8(msg, NL80211_TXRATE_HE_GI, he_gi);
 		if (has_he_ltf_5)
 			nla_put_u8(msg, NL80211_TXRATE_HE_LTF, he_ltf);
+		if (has_eht_gi_5)
+			nla_put_u8(msg, NL80211_TXRATE_EHT_GI, eht_gi);
+		if (has_eht_ltf_5)
+			nla_put_u8(msg, NL80211_TXRATE_EHT_LTF, eht_ltf);
 		nla_nest_end(msg, nl_band);
 	}
 
-	if (have_he_mcs_6 || has_he_gi_6 || has_he_ltf_6) {
+	if (have_he_mcs_6 || has_he_gi_6 || has_he_ltf_6 ||
+	    have_eht_mcs_6 || has_eht_gi_6 || has_eht_ltf_6) {
 		nl_band = nla_nest_start(msg, NL80211_BAND_6GHZ);
 		if (!nl_band)
 			goto nla_put_failure;
 		if (have_he_mcs_6)
 			nla_put(msg, NL80211_TXRATE_HE, sizeof(txrate_he_6),
 				&txrate_he_6);
+		if (have_eht_mcs_6)
+			nla_put(msg, NL80211_TXRATE_EHT, sizeof(txrate_eht_6),
+				&txrate_eht_6);
 		if (has_he_gi_6)
 			nla_put_u8(msg, NL80211_TXRATE_HE_GI, he_gi);
 		if (has_he_ltf_6)
 			nla_put_u8(msg, NL80211_TXRATE_HE_LTF, he_ltf);
+		if (has_eht_gi_6)
+			nla_put_u8(msg, NL80211_TXRATE_EHT_GI, eht_gi);
+		if (has_eht_ltf_6)
+			nla_put_u8(msg, NL80211_TXRATE_EHT_LTF, eht_ltf);
 		nla_nest_end(msg, nl_band);
 	}
 
@@ -452,13 +618,36 @@ static int handle_bitrates(struct nl80211_state *state,
 			   int argc, char **argv,
 			   enum id_input id)
 {
+	int ret;
+
+	ret = parse_link_id(msg, &argc, &argv);
+	if (ret)
+		return ret;
+
 	return set_bitrates(msg, argc, argv, NL80211_ATTR_TX_RATES);
 }
 
+#define DESCR_MLO "[link-id <LINK ID>] "
 #define DESCR_LEGACY "[legacy-<2.4|5> <legacy rate in Mbps>*]"
-#define DESCR DESCR_LEGACY " [ht-mcs-<2.4|5> <MCS index>*] [vht-mcs-<2.4|5>  [he-mcs-<2.4|5|6> <NSS:MCSx,MCSy... | NSS:MCSx-MCSy>*] [sgi-2.4|lgi-2.4] [sgi-5|lgi-5]"
-
-COMMAND(set, bitrates, "[legacy-<2.4|5> <legacy rate in Mbps>*] [ht-mcs-<2.4|5> <MCS index>*] [vht-mcs-<2.4|5> [he-mcs-<2.4|5|6> <NSS:MCSx,MCSy... | NSS:MCSx-MCSy>*] [sgi-2.4|lgi-2.4] [sgi-5|lgi-5] [he-gi-<2.4|5|6> <0.8|1.6|3.2>] [he-ltf-<2.4|5|6> <1|2|4>]",
+#define DESCR_HT " [ht-mcs-<2.4|5> <MCS index>*]"
+#define DESCR_VHT " [vht-mcs-<2.4|5> <NSS:MCSx,MCSy... | NSS:MCSx-MCSy>*]"
+#define DESCR_HE " [he-mcs-<2.4|5|6> <NSS:MCSx,MCSy... | NSS:MCSx-MCSy>*]"
+#define DESCR_EHT " [eht-mcs-<2.4|5|6> <NSS:MCSx,MCSy... | NSS:MCSx-MCSy>*]"
+#define DESCR_GI " [sgi-2.4|lgi-2.4] [sgi-5|lgi-5] [he-gi-<2.4|5|6> <0.8|1.6|3.2>] [eht-gi-<2.4|5|6> <0.8|1.6|3.2>]"
+#define DESCR_LTF " [he-ltf-<2.4|5|6> <1|2|4>] [eht-ltf-<2.4|5|6> <1|2|4|6|8>]"
+
+#define DESCR \
+	DESCR_MLO \
+	DESCR_LEGACY \
+	DESCR_HT \
+	DESCR_VHT \
+	DESCR_HE \
+	DESCR_EHT \
+	DESCR_GI \
+	DESCR_LTF \
+	/* end of DESCR */
+
+COMMAND(set, bitrates, DESCR,
 	NL80211_CMD_SET_TX_BITRATE_MASK, 0, CIB_NETDEV, handle_bitrates,
 	"Sets up the specified rate masks.\n"
 	"Not passing any arguments would clear the existing mask (if any).");
diff --git a/connect.c b/connect.c
index 33e1a5f..14a8a7b 100644
--- a/connect.c
+++ b/connect.c
@@ -63,6 +63,10 @@ static int iw_conn(struct nl80211_state *state,
 			NLA_PUT_U32(msg, NL80211_ATTR_AUTH_TYPE,
 			    NL80211_AUTHTYPE_SHARED_KEY);
 			need_key = true;
+		} else if (strcmp(argv[0], "sae") == 0) {
+			NLA_PUT_U32(msg, NL80211_ATTR_AUTH_TYPE,
+			    NL80211_AUTHTYPE_SAE);
+			need_key = true;
 		} else {
 			return 1;
 		}
@@ -229,6 +233,10 @@ static int iw_auth(struct nl80211_state *state,
 		NLA_PUT_U32(msg, NL80211_ATTR_AUTH_TYPE,
 			    NL80211_AUTHTYPE_SHARED_KEY);
 		need_key = true;
+	} else if (strcmp(argv[0], "sae") == 0) {
+		NLA_PUT_U32(msg, NL80211_ATTR_AUTH_TYPE,
+			    NL80211_AUTHTYPE_SAE);
+		need_key = true;
 	} else {
 		return 1;
 	}
diff --git a/info.c b/info.c
index 18dcd36..5ce3f78 100644
--- a/info.c
+++ b/info.c
@@ -174,6 +174,7 @@ static void ext_feat_print(enum nl80211_ext_feature_index idx)
 	ext_feat_case(OWE_OFFLOAD_AP, "OWE DH element handling offload (AP)");
 	ext_feat_case(DFS_CONCURRENT, "DFS channel use under concurrent DFS master");
 	ext_feat_case(SPP_AMSDU_SUPPORT, "SPP A-MSDU support");
+	ext_feat_case(BEACON_RATE_EHT, "EHT beacon rate support (AP/mesh)");
 	}
 }
 
diff --git a/iw.h b/iw.h
index 145b058..df9ea13 100644
--- a/iw.h
+++ b/iw.h
@@ -305,6 +305,7 @@ int set_bitrates(struct nl_msg *msg, int argc, char **argv,
 		 enum nl80211_attrs attr);
 
 int calc_s1g_ch_center_freq(__u8 ch_index, __u8 s1g_oper_class);
+int parse_link_id(struct nl_msg *msg, int *argc, char ***argv);
 
 /* sections */
 DECLARE_SECTION(ap);
diff --git a/nl80211.h b/nl80211.h
index d1a14f2..8134f10 100644
--- a/nl80211.h
+++ b/nl80211.h
@@ -1085,8 +1085,9 @@
  *	%NL80211_ATTR_NAN_MASTER_PREF attribute and optional
  *	%NL80211_ATTR_BANDS attributes.  If %NL80211_ATTR_BANDS is
  *	omitted or set to 0, it means don't-care and the device will
- *	decide what to use.  After this command NAN functions can be
- *	added.
+ *	decide what to use. Additional cluster configuration may be
+ *	optionally provided with %NL80211_ATTR_NAN_CONFIG.
+ *	After this command NAN functions can be added.
  * @NL80211_CMD_STOP_NAN: Stop the NAN operation, identified by
  *	its %NL80211_ATTR_WDEV interface.
  * @NL80211_CMD_ADD_NAN_FUNCTION: Add a NAN function. The function is defined
@@ -1115,6 +1116,10 @@
  *	current configuration is not changed.  If it is present but
  *	set to zero, the configuration is changed to don't-care
  *	(i.e. the device can decide what to do).
+ *	Additional parameters may be provided with
+ *	%NL80211_ATTR_NAN_CONFIG. User space should provide all previously
+ *	configured nested attributes under %NL80211_ATTR_NAN_CONFIG, even if
+ *	only a subset was changed.
  * @NL80211_CMD_NAN_MATCH: Notification sent when a match is reported.
  *	This will contain a %NL80211_ATTR_NAN_MATCH nested attribute and
  *	%NL80211_ATTR_COOKIE.
@@ -1344,6 +1349,18 @@
  *	control EPCS configuration. Used to notify userland on the current state
  *	of EPCS.
  *
+ * @NL80211_CMD_NAN_NEXT_DW_NOTIFICATION: This command is used to notify
+ *	user space about the next NAN Discovery Window (DW). User space may use
+ *	it to prepare frames to be sent in the next DW.
+ *	%NL80211_ATTR_WIPHY_FREQ is used to indicate the frequency of the next
+ *	DW. SDF transmission should be requested with %NL80211_CMD_FRAME and
+ *	the device/driver shall take care of the actual transmission timing.
+ *	This notification is only sent to the NAN interface owning socket
+ *	(see %NL80211_ATTR_SOCKET_OWNER flag).
+ * @NL80211_CMD_NAN_CLUSTER_JOINED: This command is used to notify
+ *	user space that the NAN new cluster has been joined. The cluster ID is
+ *	indicated by %NL80211_ATTR_MAC.
+ *
  * @NL80211_CMD_MAX: highest used command number
  * @__NL80211_CMD_AFTER_LAST: internal use
  */
@@ -1604,6 +1621,9 @@ enum nl80211_commands {
 	NL80211_CMD_ASSOC_MLO_RECONF,
 	NL80211_CMD_EPCS_CFG,
 
+	NL80211_CMD_NAN_NEXT_DW_NOTIFICATION,
+	NL80211_CMD_NAN_CLUSTER_JOINED,
+
 	/* add new commands above here */
 
 	/* used to define NL80211_CMD_MAX below */
@@ -1943,8 +1963,9 @@ enum nl80211_commands {
  *	The driver must also specify support for this with the extended
  *	features NL80211_EXT_FEATURE_BEACON_RATE_LEGACY,
  *	NL80211_EXT_FEATURE_BEACON_RATE_HT,
- *	NL80211_EXT_FEATURE_BEACON_RATE_VHT and
- *	NL80211_EXT_FEATURE_BEACON_RATE_HE.
+ *	NL80211_EXT_FEATURE_BEACON_RATE_VHT,
+ *	NL80211_EXT_FEATURE_BEACON_RATE_HE and
+ *	NL80211_EXT_FEATURE_BEACON_RATE_EHT.
  *
  * @NL80211_ATTR_FRAME_MATCH: A binary attribute which typically must contain
  *	at least one byte, currently used with @NL80211_CMD_REGISTER_FRAME.
@@ -2283,7 +2304,8 @@ enum nl80211_commands {
  * @NL80211_ATTR_PEER_AID: Association ID for the peer TDLS station (u16).
  *	This is similar to @NL80211_ATTR_STA_AID but with a difference of being
  *	allowed to be used with the first @NL80211_CMD_SET_STATION command to
- *	update a TDLS peer STA entry.
+ *	update a TDLS peer STA entry. For S1G interfaces, this is limited to
+ *	1600 for the current mac80211 implementation.
  *
  * @NL80211_ATTR_COALESCE_RULE: Coalesce rule information.
  *
@@ -2928,6 +2950,29 @@ enum nl80211_commands {
  *	required alongside this attribute. Refer to
  *	@enum nl80211_s1g_short_beacon_attrs for the attribute definitions.
  *
+ * @NL80211_ATTR_BSS_PARAM: nested attribute used with %NL80211_CMD_GET_WIPHY
+ *	which indicates which BSS parameters can be modified. The attribute can
+ *	also be used as flag attribute by user-space in %NL80211_CMD_SET_BSS to
+ *	indicate that it wants strict checking on the BSS parameters to be
+ *	modified.
+ *
+ * @NL80211_ATTR_NAN_CONFIG: Nested attribute for
+ *	extended NAN cluster configuration. This is used with
+ *	%NL80211_CMD_START_NAN and %NL80211_CMD_CHANGE_NAN_CONFIG.
+ *	See &enum nl80211_nan_conf_attributes for details.
+ *	This attribute is optional.
+ * @NL80211_ATTR_NAN_NEW_CLUSTER: Flag attribute indicating that a new
+ *	NAN cluster has been created. This is used with
+ *	%NL80211_CMD_NAN_CLUSTER_JOINED
+ * @NL80211_ATTR_NAN_CAPABILITIES: Nested attribute for NAN capabilities.
+ *	This is used with %NL80211_CMD_GET_WIPHY to indicate the NAN
+ *	capabilities supported by the driver. See &enum nl80211_nan_capabilities
+ *	for details.
+ *
+ * @NL80211_ATTR_S1G_PRIMARY_2MHZ: flag attribute indicating that the S1G
+ *	primary channel is 2 MHz wide, and the control channel designates
+ *	the 1 MHz primary subchannel within that 2 MHz primary.
+ *
  * @NUM_NL80211_ATTR: total number of nl80211_attrs available
  * @NL80211_ATTR_MAX: highest attribute number currently defined
  * @__NL80211_ATTR_AFTER_LAST: internal use
@@ -3489,6 +3534,12 @@ enum nl80211_attrs {
 
 	NL80211_ATTR_S1G_LONG_BEACON_PERIOD,
 	NL80211_ATTR_S1G_SHORT_BEACON,
+	NL80211_ATTR_BSS_PARAM,
+	NL80211_ATTR_NAN_CONFIG,
+	NL80211_ATTR_NAN_NEW_CLUSTER,
+	NL80211_ATTR_NAN_CAPABILITIES,
+
+	NL80211_ATTR_S1G_PRIMARY_2MHZ,
 
 	/* add attributes here, update the policy in nl80211.c */
 
@@ -3735,6 +3786,22 @@ enum nl80211_eht_gi {
 	NL80211_RATE_INFO_EHT_GI_3_2,
 };
 
+/**
+ * enum nl80211_eht_ltf - EHT long training field
+ * @NL80211_RATE_INFO_EHT_1XLTF: 3.2 usec
+ * @NL80211_RATE_INFO_EHT_2XLTF: 6.4 usec
+ * @NL80211_RATE_INFO_EHT_4XLTF: 12.8 usec
+ * @NL80211_RATE_INFO_EHT_6XLTF: 19.2 usec
+ * @NL80211_RATE_INFO_EHT_8XLTF: 25.6 usec
+ */
+enum nl80211_eht_ltf {
+	NL80211_RATE_INFO_EHT_1XLTF,
+	NL80211_RATE_INFO_EHT_2XLTF,
+	NL80211_RATE_INFO_EHT_4XLTF,
+	NL80211_RATE_INFO_EHT_6XLTF,
+	NL80211_RATE_INFO_EHT_8XLTF,
+};
+
 /**
  * enum nl80211_eht_ru_alloc - EHT RU allocation values
  * @NL80211_RATE_INFO_EHT_RU_ALLOC_26: 26-tone RU allocation
@@ -4371,6 +4438,12 @@ enum nl80211_wmm_rule {
  *	very low power (VLP) AP, despite being NO_IR.
  * @NL80211_FREQUENCY_ATTR_ALLOW_20MHZ_ACTIVITY: This channel can be active in
  *	20 MHz bandwidth, despite being NO_IR.
+ * @NL80211_FREQUENCY_ATTR_NO_4MHZ: 4 MHz operation is not allowed on this
+ *	channel in current regulatory domain.
+ * @NL80211_FREQUENCY_ATTR_NO_8MHZ: 8 MHz operation is not allowed on this
+ *	channel in current regulatory domain.
+ * @NL80211_FREQUENCY_ATTR_NO_16MHZ: 16 MHz operation is not allowed on this
+ *	channel in current regulatory domain.
  * @NL80211_FREQUENCY_ATTR_MAX: highest frequency attribute number
  *	currently defined
  * @__NL80211_FREQUENCY_ATTR_AFTER_LAST: internal use
@@ -4416,6 +4489,9 @@ enum nl80211_frequency_attr {
 	NL80211_FREQUENCY_ATTR_CAN_MONITOR,
 	NL80211_FREQUENCY_ATTR_ALLOW_6GHZ_VLP_AP,
 	NL80211_FREQUENCY_ATTR_ALLOW_20MHZ_ACTIVITY,
+	NL80211_FREQUENCY_ATTR_NO_4MHZ,
+	NL80211_FREQUENCY_ATTR_NO_8MHZ,
+	NL80211_FREQUENCY_ATTR_NO_16MHZ,
 
 	/* keep last */
 	__NL80211_FREQUENCY_ATTR_AFTER_LAST,
@@ -5481,6 +5557,10 @@ enum nl80211_key_attributes {
  *	see &struct nl80211_txrate_he
  * @NL80211_TXRATE_HE_GI: configure HE GI, 0.8us, 1.6us and 3.2us.
  * @NL80211_TXRATE_HE_LTF: configure HE LTF, 1XLTF, 2XLTF and 4XLTF.
+ * @NL80211_TXRATE_EHT: EHT rates allowed for TX rate selection,
+ *	see &struct nl80211_txrate_eht
+ * @NL80211_TXRATE_EHT_GI: configure EHT GI, (u8, see &enum nl80211_eht_gi)
+ * @NL80211_TXRATE_EHT_LTF: configure EHT LTF, (u8, see &enum nl80211_eht_ltf)
  * @__NL80211_TXRATE_AFTER_LAST: internal
  * @NL80211_TXRATE_MAX: highest TX rate attribute
  */
@@ -5493,6 +5573,9 @@ enum nl80211_tx_rate_attributes {
 	NL80211_TXRATE_HE,
 	NL80211_TXRATE_HE_GI,
 	NL80211_TXRATE_HE_LTF,
+	NL80211_TXRATE_EHT,
+	NL80211_TXRATE_EHT_GI,
+	NL80211_TXRATE_EHT_LTF,
 
 	/* keep last */
 	__NL80211_TXRATE_AFTER_LAST,
@@ -5525,6 +5608,15 @@ enum nl80211_txrate_gi {
 	NL80211_TXRATE_FORCE_LGI,
 };
 
+#define NL80211_EHT_NSS_MAX             16
+/**
+ * struct nl80211_txrate_eht - EHT MCS/NSS txrate bitmap
+ * @mcs: MCS bitmap table for each NSS (array index 0 for 1 stream, etc.)
+ */
+struct nl80211_txrate_eht {
+	__u16 mcs[NL80211_EHT_NSS_MAX];
+};
+
 /**
  * enum nl80211_band - Frequency band
  * @NL80211_BAND_2GHZ: 2.4 GHz ISM band
@@ -6649,6 +6741,9 @@ enum nl80211_feature_flags {
  *	(signaling and payload protected) A-MSDUs and this shall be advertised
  *	in the RSNXE.
  *
+ * @NL80211_EXT_FEATURE_BEACON_RATE_EHT: Driver supports beacon rate
+ *	configuration (AP/mesh) with EHT rates.
+ *
  * @NUM_NL80211_EXT_FEATURES: number of extended features.
  * @MAX_NL80211_EXT_FEATURES: highest extended feature index.
  */
@@ -6724,6 +6819,7 @@ enum nl80211_ext_feature_index {
 	NL80211_EXT_FEATURE_OWE_OFFLOAD_AP,
 	NL80211_EXT_FEATURE_DFS_CONCURRENT,
 	NL80211_EXT_FEATURE_SPP_AMSDU_SUPPORT,
+	NL80211_EXT_FEATURE_BEACON_RATE_EHT,
 
 	/* add new features before the definition below */
 	NUM_NL80211_EXT_FEATURES,
@@ -7278,6 +7374,105 @@ enum nl80211_nan_match_attributes {
 	NL80211_NAN_MATCH_ATTR_MAX = NUM_NL80211_NAN_MATCH_ATTR - 1
 };
 
+/**
+ * enum nl80211_nan_band_conf_attributes - NAN band configuration attributes
+ * @__NL80211_NAN_BAND_CONF_INVALID: Invalid.
+ * @NL80211_NAN_BAND_CONF_BAND: Band for which the configuration is
+ *	being set. The value is according to &enum nl80211_band (u8).
+ * @NL80211_NAN_BAND_CONF_FREQ: Discovery frequency. This attribute shall not
+ *	be present on 2.4 GHZ band. On 5 GHz band its presence is optional.
+ *	The allowed values are 5220 (channel 44) or 5745 (channel 149).
+ *	If not present, channel 149 is used if allowed, otherwise channel 44
+ *	will be selected. The value is in MHz (u16).
+ * @NL80211_NAN_BAND_CONF_RSSI_CLOSE: RSSI close threshold used for NAN state
+ *	transition algorithm as described in chapters 3.3.6 and 3.3.7 "NAN
+ *	Device Role and State Transition" of Wi-Fi Aware (TM) Specification
+ *	v4.0. If not specified, default device value is used. The value should
+ *	be greater than -60 dBm (s8).
+ * @NL80211_NAN_BAND_CONF_RSSI_MIDDLE: RSSI middle threshold used for NAN state
+ *	transition algorithm as described in chapters 3.3.6 and 3.3.7 "NAN
+ *	Device Role and State Transition" of Wi-Fi Aware (TM) Specification
+ *	v4.0. If not present, default device value is used. The value should be
+ *	greater than -75 dBm and less than %NL80211_NAN_BAND_CONF_RSSI_CLOSE
+ *	(s8).
+ * @NL80211_NAN_BAND_CONF_WAKE_DW: Committed DW information (values 0-5).
+ *	Value 0 means that the device will not wake up during the
+ *	discovery window. Values 1-5 mean that the device will wake up
+ *	during each 2^(n - 1) discovery window, where n is the value of
+ *	this attribute. Setting this attribute to 0 is not allowed on
+ *	2.4 GHz band (u8). This is an optional parameter (default is 1).
+ * @NL80211_NAN_BAND_CONF_DISABLE_SCAN: Optional flag attribute to disable
+ *	scanning (for cluster merge) on the band. If set, the device will not
+ *	scan on this band anymore. Disabling scanning on 2.4 GHz band is not
+ *	allowed.
+ * @NUM_NL80211_NAN_BAND_CONF_ATTR: Internal.
+ * @NL80211_NAN_BAND_CONF_ATTR_MAX: Highest NAN band configuration attribute.
+ *
+ * These attributes are used to configure NAN band-specific parameters. Note,
+ * that both RSSI attributes should be configured (or both left unset).
+ */
+enum nl80211_nan_band_conf_attributes {
+	__NL80211_NAN_BAND_CONF_INVALID,
+	NL80211_NAN_BAND_CONF_BAND,
+	NL80211_NAN_BAND_CONF_FREQ,
+	NL80211_NAN_BAND_CONF_RSSI_CLOSE,
+	NL80211_NAN_BAND_CONF_RSSI_MIDDLE,
+	NL80211_NAN_BAND_CONF_WAKE_DW,
+	NL80211_NAN_BAND_CONF_DISABLE_SCAN,
+
+	/* keep last */
+	NUM_NL80211_NAN_BAND_CONF_ATTR,
+	NL80211_NAN_BAND_CONF_ATTR_MAX = NUM_NL80211_NAN_BAND_CONF_ATTR - 1,
+};
+
+/**
+ * enum nl80211_nan_conf_attributes - NAN configuration attributes
+ * @__NL80211_NAN_CONF_INVALID: Invalid attribute, used for validation.
+ * @NL80211_NAN_CONF_CLUSTER_ID: ID for the NAN cluster. This is a MAC
+ *	address that can take values from 50-6F-9A-01-00-00 to
+ *	50-6F-9A-01-FF-FF. This attribute is optional. If not present,
+ *	a random Cluster ID will be chosen.
+ * @NL80211_NAN_CONF_EXTRA_ATTRS: Additional NAN attributes to be
+ *	published in the beacons. This is an optional byte array.
+ * @NL80211_NAN_CONF_VENDOR_ELEMS: Vendor-specific elements that will
+ *	be published in the beacons. This is an optional byte array.
+ * @NL80211_NAN_CONF_BAND_CONFIGS: This is a nested array attribute,
+ *	containing multiple entries for each supported band. Each band
+ *	configuration consists of &enum nl80211_nan_band_conf_attributes.
+ * @NL80211_NAN_CONF_SCAN_PERIOD: Scan period in seconds. If not configured,
+ *	device default is used. Zero value will disable scanning.
+ *	This is u16 (optional).
+ * @NL80211_NAN_CONF_SCAN_DWELL_TIME: Scan dwell time in TUs per channel.
+ *	Only non-zero values are valid. If not configured the device default
+ *	value is used. This is u16 (optional)
+ * @NL80211_NAN_CONF_DISCOVERY_BEACON_INTERVAL: Discovery beacon interval
+ *	in TUs. Valid range is 50-200 TUs. If not configured the device default
+ *	value is used. This is u8 (optional)
+ * @NL80211_NAN_CONF_NOTIFY_DW: If set, the driver will notify userspace about
+ *	the upcoming discovery window with
+ *	%NL80211_CMD_NAN_NEXT_DW_NOTIFICATION.
+ *	This is a flag attribute.
+ * @NUM_NL80211_NAN_CONF_ATTR: Internal.
+ * @NL80211_NAN_CONF_ATTR_MAX: Highest NAN configuration attribute.
+ *
+ * These attributes are used to configure NAN-specific parameters.
+ */
+enum nl80211_nan_conf_attributes {
+	__NL80211_NAN_CONF_INVALID,
+	NL80211_NAN_CONF_CLUSTER_ID,
+	NL80211_NAN_CONF_EXTRA_ATTRS,
+	NL80211_NAN_CONF_VENDOR_ELEMS,
+	NL80211_NAN_CONF_BAND_CONFIGS,
+	NL80211_NAN_CONF_SCAN_PERIOD,
+	NL80211_NAN_CONF_SCAN_DWELL_TIME,
+	NL80211_NAN_CONF_DISCOVERY_BEACON_INTERVAL,
+	NL80211_NAN_CONF_NOTIFY_DW,
+
+	/* keep last */
+	NUM_NL80211_NAN_CONF_ATTR,
+	NL80211_NAN_CONF_ATTR_MAX = NUM_NL80211_NAN_CONF_ATTR - 1,
+};
+
 /**
  * enum nl80211_external_auth_action - Action to perform with external
  *     authentication request. Used by NL80211_ATTR_EXTERNAL_AUTH_ACTION.
@@ -8187,4 +8382,54 @@ enum nl80211_s1g_short_beacon_attrs {
 		__NL80211_S1G_SHORT_BEACON_ATTR_LAST - 1
 };
 
+/**
+ * enum nl80211_nan_capabilities - NAN (Neighbor Aware Networking)
+ *	capabilities.
+ *
+ * @__NL80211_NAN_CAPABILITIES_INVALID: Invalid.
+ * @NL80211_NAN_CAPA_CONFIGURABLE_SYNC: Flag attribute indicating that
+ *	the device supports configurable synchronization. If set, the device
+ *	should be able to handle %NL80211_ATTR_NAN_CONFIG
+ *	attribute in the %NL80211_CMD_START_NAN (and change) command.
+ * @NL80211_NAN_CAPA_USERSPACE_DE: Flag attribute indicating that
+ *	NAN Discovery Engine (DE) is not offloaded and the driver assumes
+ *	user space DE implementation. When set, %NL80211_CMD_ADD_NAN_FUNCTION,
+ *	%NL80211_CMD_DEL_NAN_FUNCTION and %NL80211_CMD_NAN_MATCH commands
+ *	should not be used. In addition, the device/driver should support
+ *	sending discovery window (DW) notifications using
+ *	%NL80211_CMD_NAN_NEXT_DW_NOTIFICATION and handling transmission and
+ *	reception of NAN SDF frames on NAN device interface during DW windows.
+ *	(%NL80211_CMD_FRAME is used to transmit SDFs)
+ * @NL80211_NAN_CAPA_OP_MODE: u8 attribute indicating the supported operation
+ *	modes as defined in Wi-Fi Aware (TM) specification Table 81 (Operation
+ *	Mode field format).
+ * @NL80211_NAN_CAPA_NUM_ANTENNAS: u8 attribute indicating the number of
+ *	TX and RX antennas supported by the device. Lower nibble indicates
+ *	the number of TX antennas and upper nibble indicates the number of RX
+ *	antennas. Value 0 indicates the information is not available.
+ *	See table 79 of Wi-Fi Aware (TM) specification (Number of
+ *	Antennas field).
+ * @NL80211_NAN_CAPA_MAX_CHANNEL_SWITCH_TIME: u16 attribute indicating the
+ *	maximum time in microseconds that the device requires to switch
+ *	channels.
+ * @NL80211_NAN_CAPA_CAPABILITIES: u8 attribute containing the
+ *	capabilities of the device as defined in Wi-Fi Aware (TM)
+ *	specification Table 79 (Capabilities field).
+ * @__NL80211_NAN_CAPABILITIES_LAST: Internal
+ * @NL80211_NAN_CAPABILITIES_MAX: Highest NAN capability attribute.
+ */
+enum nl80211_nan_capabilities {
+	__NL80211_NAN_CAPABILITIES_INVALID,
+
+	NL80211_NAN_CAPA_CONFIGURABLE_SYNC,
+	NL80211_NAN_CAPA_USERSPACE_DE,
+	NL80211_NAN_CAPA_OP_MODE,
+	NL80211_NAN_CAPA_NUM_ANTENNAS,
+	NL80211_NAN_CAPA_MAX_CHANNEL_SWITCH_TIME,
+	NL80211_NAN_CAPA_CAPABILITIES,
+	/* keep last */
+	__NL80211_NAN_CAPABILITIES_LAST,
+	NL80211_NAN_CAPABILITIES_MAX = __NL80211_NAN_CAPABILITIES_LAST - 1,
+};
+
 #endif /* __LINUX_NL80211_H */
diff --git a/util.c b/util.c
index 36c1185..06c3347 100644
--- a/util.c
+++ b/util.c
@@ -285,6 +285,9 @@ static int parse_akm_suite(const char *cipher_str)
 		return 0x000FAC03;
 	if (!strcmp(cipher_str, "PSK/SHA-256"))
 		return 0x000FAC06;
+	if (!strcmp(cipher_str, "SAE"))
+		return 0x000FAC08;
+
 	return -EINVAL;
 }
 
@@ -373,6 +376,25 @@ int parse_keys(struct nl_msg *msg, char **argv[], int *argc)
 		return 0;
 	}
 
+	if (!memcmp(&arg[pos], "sae_pwd", 7)) {
+		pos += 7;
+		if (arg[pos] != ':')
+			goto explain;
+		pos++;
+
+		NLA_PUT_U32(msg, NL80211_ATTR_WPA_VERSIONS, NL80211_WPA_VERSION_3);
+		NLA_PUT(msg, NL80211_ATTR_SAE_PASSWORD, strlen(&arg[pos]), &arg[pos]);
+		NLA_PUT_U32(msg, NL80211_ATTR_AUTH_TYPE, NL80211_AUTHTYPE_SAE);
+		NLA_PUT_U32(msg, NL80211_ATTR_AKM_SUITES, parse_akm_suite("SAE"));
+		NLA_PUT_U32(msg, NL80211_ATTR_CIPHER_SUITE_GROUP, parse_cipher_suite("CCMP"));
+		NLA_PUT_U32(msg, NL80211_ATTR_CIPHER_SUITES_PAIRWISE, parse_cipher_suite("CCMP"));
+
+		*argv += 1;
+		*argc -= 1;
+
+		return 0;
+	}
+
 	NLA_PUT_FLAG(msg, NL80211_ATTR_PRIVACY);
 
 	keys = nla_nest_start(msg, NL80211_ATTR_KEYS);
@@ -453,10 +475,12 @@ int parse_keys(struct nl_msg *msg, char **argv[], int *argc)
 			"           or 10 or 26 hex digits\n"
 			"for example: d:2:6162636465 is the same as d:2:abcde\n"
 			"or psk:data <AKM Suite> <pairwise CIPHER> <groupwise CIPHER> where\n"
-			"  'data' is the PSK (output of wpa_passphrase and the CIPHER can be CCMP or GCMP\n"
+			"  'data' is the PSK (output of wpa_passphrase and the CIPHER can be CCMP or GCMP)\n"
 			"for example: psk:0123456789abcdef PSK CCMP CCMP\n"
 			"The allowed AKM suites are PSK, FT/PSK, PSK/SHA-256\n"
-			"The allowed Cipher suites are TKIP, CCMP, GCMP, GCMP-256, CCMP-256\n");
+			"The allowed Cipher suites are TKIP, CCMP, GCMP, GCMP-256, CCMP-256\n"
+			"or sae_pwd:data where 'data' is the password\n"
+			"for example: sae_pwd:foobar\n");
 	return 2;
 }
 
@@ -2378,3 +2402,34 @@ void print_s1g_capability(const uint8_t *caps)
 	/* Last 2 bits are reserved */
 #undef PRINT_S1G_CAP
 }
+
+int parse_link_id(struct nl_msg *msg, int *argc, char ***argv)
+{
+	unsigned int link_id;
+	char *endptr;
+
+	if (*argc < 1)
+		return 0;
+
+	if (strcmp((*argv)[0], "link-id") != 0)
+		return 0;
+
+	if (*argc == 1)
+		goto usage;
+
+	link_id = strtol((*argv)[1], &endptr, 0);
+	if (*endptr != '\0')
+		goto usage;
+
+	*argv += 2;
+	*argc -= 2;
+
+	NLA_PUT_U8(msg, NL80211_ATTR_MLO_LINK_ID, link_id);
+	return 0;
+
+usage:
+	return HANDLER_RET_USAGE;
+
+nla_put_failure:
+	return -ENOBUFS;
+}
-- 
2.45.2

