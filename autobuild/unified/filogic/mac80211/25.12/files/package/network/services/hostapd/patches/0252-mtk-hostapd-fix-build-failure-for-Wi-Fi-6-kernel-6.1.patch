From f14ceae1fb4751853546330c7f66176b145ed048 Mon Sep 17 00:00:00 2001
From: Benjamin Lin <benjamin-jw.lin@mediatek.com>
Date: Mon, 1 Dec 2025 16:51:48 +0800
Subject: [PATCH 252/254] mtk: hostapd: fix build failure for Wi-Fi 6 kernel
 6.12 codebase

Signed-off-by: Benjamin Lin <benjamin-jw.lin@mediatek.com>
---
 hostapd/config_file.c        |  2 ++
 hostapd/ctrl_iface.c         | 18 ++++++++++++++++++
 src/ap/ap_drv_ops.c          | 36 ++++++++++++++++++++++++++++++++++++
 src/ap/ap_drv_ops.h          |  2 ++
 src/ap/beacon.c              | 12 ++++++++----
 src/ap/beacon.h              |  2 ++
 src/ap/dfs.c                 |  4 ++++
 src/ap/drv_callbacks.c       |  6 ++++--
 src/ap/hostapd.c             | 14 ++++++++++++++
 src/ap/hostapd.h             | 13 ++++++++-----
 src/ap/ieee802_11.c          |  4 +++-
 src/ap/ieee802_11.h          |  2 ++
 src/ap/sta_info.c            |  2 ++
 src/ap/ucode.c               |  2 ++
 src/ap/wmm.c                 |  2 ++
 src/ap/wpa_auth_ft.c         |  9 ++++++++-
 src/ap/wpa_auth_glue.c       | 23 ++++++++++++++++-------
 src/drivers/driver_nl80211.c |  2 ++
 18 files changed, 135 insertions(+), 20 deletions(-)

diff --git a/hostapd/config_file.c b/hostapd/config_file.c
index 37815dd5b..360831c88 100644
--- a/hostapd/config_file.c
+++ b/hostapd/config_file.c
@@ -5350,6 +5350,7 @@ static int hostapd_config_fill(struct hostapd_config *conf,
 		}
 		conf->amsdu = val;
 	} else if (os_strcmp(buf, "pp_mode") == 0) {
+#ifdef CONFIG_IEEE80211BE
 		int val = atoi(pos);
 
 		if ((val != PP_USR_MODE && conf->punct_bitmap) ||
@@ -5359,6 +5360,7 @@ static int hostapd_config_fill(struct hostapd_config *conf,
 			return 1;
 		}
 		conf->pp_mode = (u8) val;
+#endif /* CONFIG_IEEE80211BE */
 	} else if (os_strcmp(buf, "lpi_psd") == 0) {
 		u8 en = strtol(pos, NULL, 10);
 		conf->lpi_psd = !!en;
diff --git a/hostapd/ctrl_iface.c b/hostapd/ctrl_iface.c
index 806d5f520..516eae7f0 100644
--- a/hostapd/ctrl_iface.c
+++ b/hostapd/ctrl_iface.c
@@ -6039,6 +6039,7 @@ static int
 hostapd_ctrl_iface_set_pp(struct hostapd_data *hapd, char *cmd, char *buf,
 			  size_t buflen)
 {
+#ifdef CONFIG_IEEE80211BE
 	char *config, *value;
 
 	config = cmd;
@@ -6071,14 +6072,21 @@ hostapd_ctrl_iface_set_pp(struct hostapd_data *hapd, char *cmd, char *buf,
 		return -1;
 	}
 	return os_snprintf(buf, buflen, "OK\n");
+#else /* CONFIG_IEEE80211BE */
+	return os_snprintf(buf, buflen, "not supported");
+#endif /* CONFIG_IEEE80211BE */
 }
 
 static int
 hostapd_ctrl_iface_get_pp(struct hostapd_data *hapd, char *cmd, char *buf,
 			  size_t buflen)
 {
+#ifdef CONFIG_IEEE80211BE
 	return os_snprintf(buf, buflen, "pp_mode: %d, punct_bitmap: 0x%04x\n",
 			   hapd->iconf->pp_mode, hapd->iconf->punct_bitmap);
+#else /* CONFIG_IEEE80211BE */
+	return os_snprintf(buf, buflen, "not supported");
+#endif /* CONFIG_IEEE80211BE */
 }
 
 static int
@@ -6099,6 +6107,7 @@ hostapd_ctrl_iface_disable_beacon(struct hostapd_data *hapd, char *value,
 
 }
 
+#ifdef CONFIG_IEEE80211BE
 static int
 hostapd_ctrl_iface_set_eml_resp(struct hostapd_data *hapd, char *value,
 				char *buf, size_t buflen)
@@ -6444,6 +6453,7 @@ hostapd_ctrl_iface_epcs(struct hostapd_data *hapd, char *cmd, char *buf, size_t
 
 	return os_snprintf(buf, len, "OK\n");
 }
+#endif /* CONFIG_IEEE80211BE */
 
 static int
 hostapd_ctrl_iface_set_csi(struct hostapd_data *hapd, char *cmd,
@@ -6632,6 +6642,7 @@ hostapd_ctrl_iface_dump_csi(struct hostapd_data *hapd, char *cmd,
 	return 0;
 }
 
+#ifdef CONFIG_IEEE80211BE
 static int
 hostapd_ctrl_iface_wmm(struct hostapd_data *hapd, char *cmd, char *buf,
 		       size_t buflen)
@@ -6726,6 +6737,7 @@ hostapd_ctrl_iface_del_mscs(struct hostapd_data *hapd, char *cmd,
 fail:
 	return os_snprintf(buf, buflen, "FAIL\n");
 }
+#endif /* CONFIG_IEEE80211BE */
 
 static int hostapd_ctrl_iface_receive_process(struct hostapd_data *hapd,
 					      char *buf, char *reply,
@@ -7448,6 +7460,7 @@ static int hostapd_ctrl_iface_receive_process(struct hostapd_data *hapd,
 	} else if (os_strncmp(buf, "DUMP_CSI ", 8) == 0) {
 		reply_len = hostapd_ctrl_iface_dump_csi(hapd, buf + 9,
 							reply, reply_size);
+#ifdef CONFIG_IEEE80211BE
 	} else if (os_strncmp(buf, "WMM", 3) == 0) {
 		reply_len = hostapd_ctrl_iface_wmm(hapd, buf + 4,
 						   reply, reply_size);
@@ -7457,6 +7470,7 @@ static int hostapd_ctrl_iface_receive_process(struct hostapd_data *hapd,
 		reply_len = hostapd_ctrl_iface_epcs(hapd, buf + 5, reply, reply_size);
 	} else if (os_strncmp(buf, "DEL_MSCS ", 9) == 0) {
 		reply_len = hostapd_ctrl_iface_del_mscs(hapd, buf + 9, reply, reply_size);
+#endif /* CONFIG_IEEE80211BE */
 	} else {
 		os_memcpy(reply, "UNKNOWN COMMAND\n", 16);
 		reply_len = 16;
@@ -8251,6 +8265,7 @@ static int hostapd_ctrl_bss_remove(struct hapd_interfaces *interfaces,
 }
 
 
+#ifdef CONFIG_IEEE80211BE
 static int hostapd_ctrl_mld_remove(struct hapd_interfaces *interfaces,
 				   char *buf)
 {
@@ -8260,6 +8275,7 @@ static int hostapd_ctrl_mld_remove(struct hapd_interfaces *interfaces,
 	}
 	return 0;
 }
+#endif /* CONFIG_IEEE80211BE */
 
 
 static int hostapd_ctrl_iface_remove(struct hapd_interfaces *interfaces,
@@ -8660,9 +8676,11 @@ static void hostapd_global_ctrl_iface_receive(int sock, void *eloop_ctx,
 	} else if (os_strncmp(buf, "REMOVE_BSS ", 11) == 0) {
 		if (hostapd_ctrl_bss_remove(interfaces, buf + 11) < 0)
 			reply_len = -1;
+#ifdef CONFIG_IEEE80211BE
 	} else if (os_strncmp(buf, "REMOVE_MLD ", 11) == 0) {
 		if (hostapd_ctrl_mld_remove(interfaces, buf + 11) < 0)
 			reply_len = -1;
+#endif /* CONFIG_IEEE80211BE */
 	} else if (os_strcmp(buf, "ATTACH") == 0) {
 		if (hostapd_global_ctrl_iface_attach(interfaces, &from,
 						     fromlen, NULL))
diff --git a/src/ap/ap_drv_ops.c b/src/ap/ap_drv_ops.c
index abb81cf84..9e7757a99 100644
--- a/src/ap/ap_drv_ops.c
+++ b/src/ap/ap_drv_ops.c
@@ -336,12 +336,14 @@ int hostapd_set_sta_flags(struct hostapd_data *hapd, struct sta_info *sta)
 		return 0;
 	}
 
+#ifdef CONFIG_IEEE80211BE
 	if (hapd->conf->mld_ap && hapd->mld->removed_links) {
 		wpa_printf(MSG_DEBUG,
 			   "%s: Do not update station flags (" MACSTR ")"
 			   " during ap link removal", __func__, MAC2STR(sta->addr));
 		return 0;
 	}
+#endif /* CONFIG_IEEE80211BE */
 
 	flags_or = total_flags & set_flags;
 	flags_and = total_flags | ~set_flags;
@@ -1493,8 +1495,10 @@ int hostapd_drv_configure_edcca_enable(struct hostapd_data *hapd)
 	if (!hapd->driver || !hapd->driver->configure_edcca_enable)
 		return 0;
 
+#ifdef CONFIG_IEEE80211BE
 	if (hapd->conf->mld_ap)
 		link_id = hapd->mld_link_id;
+#endif /* CONFIG_IEEE80211BE */
 
 	return hapd->driver->configure_edcca_enable(hapd->drv_priv, link_id,
 						    hapd->iconf->edcca_enable,
@@ -1510,8 +1514,10 @@ int hostapd_drv_configure_edcca_threshold(struct hostapd_data *hapd,
 	if (!hapd->driver || !hapd->driver->configure_edcca_threshold)
 		return 0;
 
+#ifdef CONFIG_IEEE80211BE
 	if (hapd->conf->mld_ap)
 		link_id = hapd->mld_link_id;
+#endif /* CONFIG_IEEE80211BE */
 
 	return hapd->driver->configure_edcca_threshold(hapd->drv_priv, link_id, threshold);
 }
@@ -1524,8 +1530,10 @@ int hostapd_drv_get_edcca(struct hostapd_data *hapd, const u8 mode, u8 *value)
 	if (!hapd->driver || !hapd->driver->get_edcca)
 		return 0;
 
+#ifdef CONFIG_IEEE80211BE
 	if (hapd->conf->mld_ap)
 		link_id = hapd->mld_link_id;
+#endif /* CONFIG_IEEE80211BE */
 
 	return hapd->driver->get_edcca(hapd->drv_priv, link_id, mode, value);
 }
@@ -1537,8 +1545,10 @@ int hostapd_drv_mu_ctrl(struct hostapd_data *hapd, u8 mode)
 	if (!hapd->driver || !hapd->driver->mu_ctrl)
 		return 0;
 
+#ifdef CONFIG_IEEE80211BE
 	if (hapd->conf->mld_ap)
 		link_id = hapd->mld_link_id;
+#endif /* CONFIG_IEEE80211BE */
 
 	return hapd->driver->mu_ctrl(hapd->drv_priv, mode, link_id);
 }
@@ -1550,8 +1560,10 @@ int hostapd_drv_mu_dump(struct hostapd_data *hapd, u8 *mu_onoff)
 	if (!hapd->driver || !hapd->driver->mu_dump)
 		return 0;
 
+#ifdef CONFIG_IEEE80211BE
 	if (hapd->conf->mld_ap)
 		link_id = hapd->mld_link_id;
+#endif /* CONFIG_IEEE80211BE */
 
 	return hapd->driver->mu_dump(hapd->drv_priv, mu_onoff, link_id);
 }
@@ -1671,8 +1683,10 @@ int hostapd_drv_txpower_ctrl(struct hostapd_data *hapd)
 	if (!hapd->driver || !hapd->driver->txpower_ctrl)
 		return 0;
 
+#ifdef CONFIG_IEEE80211BE
 	if (hapd->conf->mld_ap)
 		link_id = hapd->mld_link_id;
+#endif /* CONFIG_IEEE80211BE */
 
 #ifdef CONFIG_AFC
 	lpi_mode = hapd->iface->afc.lpi_mode;
@@ -1709,8 +1723,10 @@ int hostapd_drv_ap_wireless(struct hostapd_data *hapd, u8 sub_vendor_id, int val
 	if (!hapd->driver || !hapd->driver->ap_wireless)
 		return 0;
 
+#ifdef CONFIG_IEEE80211BE
 	if (hapd->conf->mld_ap)
 		link_id = hapd->mld_link_id;
+#endif /* CONFIG_IEEE80211BE */
 
 	return hapd->driver->ap_wireless(hapd->drv_priv, sub_vendor_id, value,
 					 link_id);
@@ -1723,8 +1739,10 @@ int hostapd_drv_ap_rfeatures(struct hostapd_data *hapd, u8 sub_vendor_id, int va
 	if (!hapd->driver || !hapd->driver->ap_rfeatures)
 		return 0;
 
+#ifdef CONFIG_IEEE80211BE
 	if (hapd->conf->mld_ap)
 		link_id = hapd->mld_link_id;
+#endif /* CONFIG_IEEE80211BE */
 
 	return hapd->driver->ap_rfeatures(hapd->drv_priv, sub_vendor_id, value,
 					  link_id);
@@ -1737,8 +1755,10 @@ int hostapd_drv_ap_trig_type(struct hostapd_data *hapd, u8 enable, u8 type)
 	if (!hapd->driver || !hapd->driver->ap_trigtype)
 		return 0;
 
+#ifdef CONFIG_IEEE80211BE
 	if (hapd->conf->mld_ap)
 		link_id = hapd->mld_link_id;
+#endif /* CONFIG_IEEE80211BE */
 
 	return hapd->driver->ap_trigtype(hapd->drv_priv, enable, type,
 					 link_id);
@@ -1751,8 +1771,10 @@ int hostapd_drv_amnt_set(struct hostapd_data *hapd, u8 amnt_idx, u8 *amnt_sta_ma
 	if (!hapd->driver || !hapd->driver->amnt_set)
 		return 0;
 
+#ifdef CONFIG_IEEE80211BE
 	if (hapd->conf->mld_ap)
 		link_id = hapd->mld_link_id;
+#endif /* CONFIG_IEEE80211BE */
 
 	return hapd->driver->amnt_set(hapd->drv_priv, amnt_idx, amnt_sta_mac,
 				      link_id);
@@ -1765,8 +1787,10 @@ int hostapd_drv_amnt_dump(struct hostapd_data *hapd, u8 amnt_idx, u8 *amnt_dump_
 	if (!hapd->driver || !hapd->driver->amnt_dump)
 		return 0;
 
+#ifdef CONFIG_IEEE80211BE
 	if (hapd->conf->mld_ap)
 		link_id = hapd->mld_link_id;
+#endif /* CONFIG_IEEE80211BE */
 
 	return hapd->driver->amnt_dump(hapd->drv_priv, amnt_idx, amnt_dump_buf,
 				       link_id);
@@ -1788,6 +1812,7 @@ int hostapd_drv_background_radar_mode(struct hostapd_data *hapd)
 
 int hostapd_drv_pp_mode_set(struct hostapd_data *hapd)
 {
+#ifdef CONFIG_IEEE80211BE
 	s8 link_id = -1;
 
 	if (!hapd->driver || !hapd->driver->pp_mode_set ||
@@ -1802,6 +1827,9 @@ int hostapd_drv_pp_mode_set(struct hostapd_data *hapd)
 					 hapd->iconf->pp_mode,
 					 link_id,
 					 hapd->iconf->punct_bitmap);
+#else /* CONFIG_IEEE80211BE */
+	return 0;
+#endif /* CONFIG_IEEE80211BE */
 }
 
 int hostapd_drv_beacon_ctrl(struct hostapd_data *hapd, u8 beacon_mode)
@@ -1811,6 +1839,7 @@ int hostapd_drv_beacon_ctrl(struct hostapd_data *hapd, u8 beacon_mode)
 	return hapd->driver->beacon_ctrl(hapd->drv_priv, beacon_mode);
 }
 
+#ifdef CONFIG_IEEE80211BE
 int hostapd_drv_set_eml_omn(struct hostapd_data *hapd, const u8 *mac,
 			    struct eml_omn_element *omn_ie)
 {
@@ -1851,6 +1880,7 @@ int hostapd_drv_set_epcs(struct hostapd_data *hapd, struct epcs_entry *entry,
 
 	return ret;
 }
+#endif /* CONFIG_IEEE80211BE */
 
 int hostapd_drv_csi_set(struct hostapd_data *hapd, u8 mode, u8 cfg, u8 v1, u32 v2, u8 *mac)
 {
@@ -1859,8 +1889,10 @@ int hostapd_drv_csi_set(struct hostapd_data *hapd, u8 mode, u8 cfg, u8 v1, u32 v
 	if (!hapd->driver || !hapd->driver->csi_set)
 		return 0;
 
+#ifdef CONFIG_IEEE80211BE
 	if (hapd->conf->mld_ap)
 		link_id = hapd->mld_link_id;
+#endif /* CONFIG_IEEE80211BE */
 
 	return hapd->driver->csi_set(hapd->drv_priv, link_id, mode, cfg, v1, v2, mac);
 }
@@ -1872,8 +1904,10 @@ int hostapd_drv_csi_dump(struct hostapd_data *hapd, void *dump_buf)
 	if (!hapd->driver || !hapd->driver->csi_dump)
 		return 0;
 
+#ifdef CONFIG_IEEE80211BE
 	if (hapd->conf->mld_ap)
 		link_id = hapd->mld_link_id;
+#endif /* CONFIG_IEEE80211BE */
 
 	return hapd->driver->csi_dump(hapd->drv_priv, link_id, dump_buf);
 }
@@ -1894,8 +1928,10 @@ int hostapd_drv_dfs_tx_mode(struct hostapd_data *hapd, u8 dfs_tx_mode)
 	if (!hapd->driver || !hapd->driver->dfs_tx_mode)
 		return 0;
 
+#ifdef CONFIG_IEEE80211BE
 	if (hapd->conf->mld_ap)
 		link_id = hapd->mld_link_id;
+#endif /* CONFIG_IEEE80211BE */
 
 	return hapd->driver->dfs_tx_mode(hapd->drv_priv, link_id,
 					 dfs_tx_mode);
diff --git a/src/ap/ap_drv_ops.h b/src/ap/ap_drv_ops.h
index 387913d9b..a14eaa42d 100644
--- a/src/ap/ap_drv_ops.h
+++ b/src/ap/ap_drv_ops.h
@@ -185,10 +185,12 @@ int hostapd_drv_amnt_dump(struct hostapd_data *hapd, u8 amnt_idx, u8 *amnt_dump_
 int hostapd_drv_background_radar_mode(struct hostapd_data *hapd);
 int hostapd_drv_pp_mode_set(struct hostapd_data *hapd);
 int hostapd_drv_beacon_ctrl(struct hostapd_data *hapd, u8 beacon_mode);
+#ifdef CONFIG_IEEE80211BE
 int hostapd_drv_set_eml_omn(struct hostapd_data *hapd, const u8 *mac,
 			    struct eml_omn_element *omn_ie);
 int hostapd_drv_set_epcs(struct hostapd_data *hapd, struct epcs_entry *entry,
 			 struct mld_info *mld);
+#endif /* CONFIG_IEEE80211BE */
 int hostapd_drv_csi_set(struct hostapd_data *hapd, u8 mode, u8 cfg, u8 v1, u32 v2, u8 *mac);
 int hostapd_drv_csi_dump(struct hostapd_data *hapd, void *dump_buf);
 
diff --git a/src/ap/beacon.c b/src/ap/beacon.c
index 5cf6cdd18..8c2b14cf0 100644
--- a/src/ap/beacon.c
+++ b/src/ap/beacon.c
@@ -755,9 +755,7 @@ static void hostapd_free_probe_resp_params(struct probe_resp_params *params)
 static size_t hostapd_probe_resp_elems_len(struct hostapd_data *hapd,
 					   struct probe_resp_params *params)
 {
-#ifdef CONFIG_IEEE80211BE
 	struct hostapd_data *hapd_probed = hapd;
-#endif /* CONFIG_IEEE80211BE */
 	size_t buflen = 0;
 
 	if (!params->is_ml_sta_info)
@@ -838,9 +836,7 @@ static u8 * hostapd_probe_resp_fill_elems(struct hostapd_data *hapd,
 					  struct probe_resp_params *params,
 					  u8 *pos, size_t len)
 {
-#ifdef CONFIG_IEEE80211BE
 	struct hostapd_data *hapd_probed = hapd;
-#endif /* CONFIG_IEEE80211BE */
 	u8 *csa_pos;
 	u8 *epos;
 
@@ -2236,6 +2232,7 @@ static u8 * hostapd_fils_discovery(struct hostapd_data *hapd,
 #endif /* CONFIG_FILS */
 
 
+#ifdef CONFIG_IEEE80211BE
 static void hostapd_fill_bcn_sta_profile(struct hostapd_data *hapd,
 					 struct mld_info *info)
 {
@@ -2295,6 +2292,7 @@ static void hostapd_fill_bcn_sta_profile(struct hostapd_data *hapd,
 		 */
 	}
 }
+#endif /* CONFIG_IEEE80211BE */
 
 int ieee802_11_build_ap_params(struct hostapd_data *hapd,
 			       struct wpa_driver_ap_params *params)
@@ -2399,12 +2397,14 @@ int ieee802_11_build_ap_params(struct hostapd_data *hapd,
 	os_memcpy(head->bssid, hapd->own_addr, ETH_ALEN);
 	head->u.beacon.beacon_int =
 		host_to_le16(hapd->iconf->beacon_int);
+#ifdef CONFIG_IEEE80211BE
 	/* if MLD AP hasn't finished setting up all links, also set beacon interval
 	 * to 0. This allows mac80211 to bypass some beacon active checks, for
 	 * example, when doing ACS
 	 */
 	if (hapd->conf->mld_ap && !hapd->mld->started)
 		head->u.beacon.beacon_int = host_to_le16(0);
+#endif /* CONFIG_IEEE80211BE */
 
 	/* hardware or low-level driver will setup seq_ctrl and timestamp */
 	capab_info = hostapd_own_capab_info(hapd);
@@ -2833,6 +2833,7 @@ static int __ieee802_11_set_beacon(struct hostapd_data *hapd)
 	int res, ret = -1, i;
 	struct hostapd_hw_modes *mode;
 
+#ifdef CONFIG_IEEE80211BE
 	/* skip setting beacon if other links are not started yet */
 	if (hapd->conf->mld_ap && !hapd->mld->started && hapd->beacon_set_done)
 		return 0;
@@ -2840,6 +2841,7 @@ static int __ieee802_11_set_beacon(struct hostapd_data *hapd)
 	/* skip setting beacon during ap link removal */
 	if (hapd->conf->mld_ap && hapd->mld->removed_links)
 		return 0;
+#endif /* CONFIG_IEEE80211BE */
 
 	if (!hapd->drv_priv) {
 		wpa_printf(MSG_ERROR, "Interface is disabled");
@@ -3577,6 +3579,7 @@ int ieee802_11_update_beacons(struct hostapd_iface *iface)
 }
 
 
+#ifdef CONFIG_IEEE80211BE
 int ieee802_11_set_bss_critical_update(struct hostapd_data *hapd,
 				       enum bss_crit_update_event event)
 {
@@ -3645,5 +3648,6 @@ int ieee802_11_set_bss_critical_update(struct hostapd_data *hapd,
 
 	return 0;
 }
+#endif /* CONFIG_IEEE80211BE */
 
 #endif /* CONFIG_NATIVE_WINDOWS */
diff --git a/src/ap/beacon.h b/src/ap/beacon.h
index 53bd3c6f4..189a6000f 100644
--- a/src/ap/beacon.h
+++ b/src/ap/beacon.h
@@ -55,8 +55,10 @@ int ieee802_11_set_beacon_per_iface_only(struct hostapd_iface *iface);
 int ieee802_11_set_beacon_for_colocat(struct hostapd_data *hapd);
 int ieee802_11_set_beacon(struct hostapd_data *hapd);
 int ieee802_11_set_beacons(struct hostapd_iface *iface);
+#ifdef CONFIG_IEEE80211BE
 int ieee802_11_set_bss_critical_update(struct hostapd_data *hapd,
 				       enum bss_crit_update_event event);
+#endif /* CONFIG_IEEE80211BE */
 int ieee802_11_update_beacons(struct hostapd_iface *iface);
 int ieee802_11_build_ap_params(struct hostapd_data *hapd,
 			       struct wpa_driver_ap_params *params);
diff --git a/src/ap/dfs.c b/src/ap/dfs.c
index 88fafedee..2fc57ed93 100644
--- a/src/ap/dfs.c
+++ b/src/ap/dfs.c
@@ -1414,6 +1414,7 @@ int hostapd_dfs_complete_cac(struct hostapd_iface *iface, int success, int freq,
 			 */
 			if (iface->state != HAPD_IFACE_ENABLED &&
 			    hostapd_is_dfs_chan_available(iface)) {
+#ifdef CONFIG_IEEE80211BE
 				for (i = 0; i < iface->num_bss; i++) {
 					struct hostapd_data *h, *hapd = iface->bss[i];
 
@@ -1426,6 +1427,7 @@ int hostapd_dfs_complete_cac(struct hostapd_iface *iface, int success, int freq,
 					hapd->mld->link_reconf_in_progress &=
 								~BIT(hapd->mld_link_id);
 				}
+#endif /* CONFIG_IEEE80211BE */
 				hostapd_setup_interface_complete(iface, 0);
 			}
 
@@ -1761,7 +1763,9 @@ int hostapd_dfs_radar_detected(struct hostapd_iface *iface, int freq,
 			return 0;
 	}
 
+#ifdef CONFIG_IEEE80211BE
 	iface->bss[0]->iconf->punct_bitmap = 0;
+#endif /* CONFIG_IEEE80211BE */
 
 	if (hostapd_dfs_background_start_channel_switch(iface, freq)) {
 		/* Radar detected while operating, switch the channel. */
diff --git a/src/ap/drv_callbacks.c b/src/ap/drv_callbacks.c
index a4c853fcd..d62357889 100644
--- a/src/ap/drv_callbacks.c
+++ b/src/ap/drv_callbacks.c
@@ -2798,11 +2798,9 @@ static void hostapd_event_pp_bitmap_update(struct hostapd_data *hapd,
 		if (err)
 			break;
 
-#ifdef CONFIG_IEEE80211BE
 		if (iface->bss[i]->conf->mld_ap)
 			hostapd_update_aff_link_beacon(iface->bss[i],
 						       csa_settings.cs_count);
-#endif /* CONFIG_IEEE80211BE */
 	}
 }
 #endif /* CONFIG_IEEE80211BE */
@@ -2831,8 +2829,10 @@ static int hostapd_event_btwt_add(struct hostapd_data *hapd,
 	}
 	os_memcpy(&entry->btwt, &data->btwt, sizeof(struct broadcast_twt_param));
 
+#ifdef CONFIG_IEEE80211BE
 	ieee802_11_set_bss_critical_update(hapd,
 					   BSS_CRIT_UPDATE_EVENT_BCAST_TWT_PARAM_SET);
+#endif /* CONFIG_IEEE80211BE */
 	ieee802_11_set_beacon_per_bss_only(hapd);
 
 	return 0;
@@ -3157,10 +3157,12 @@ void hostapd_wpa_event(void *ctx, enum wpa_event_type event,
 		break;
 #endif /* NEED_AP_MLME */
 	case EVENT_PP_BITMAP_UPDATE:
+#ifdef CONFIG_IEEE80211BE
 		if (!data)
 			break;
 		hapd = switch_link_hapd(hapd, data->ch_switch.link_id);
 		hostapd_event_pp_bitmap_update(hapd, &data->ch_switch);
+#endif /* CONFIG_IEEE80211BE */
 		break;
 	case EVENT_INTERFACE_ENABLED:
 #ifdef CONFIG_IEEE80211BE
diff --git a/src/ap/hostapd.c b/src/ap/hostapd.c
index 740ef916a..ad46399b5 100644
--- a/src/ap/hostapd.c
+++ b/src/ap/hostapd.c
@@ -966,8 +966,10 @@ static int hostapd_flush_old_stations(struct hostapd_data *hapd, u16 reason)
 void hostapd_bss_deinit_no_free(struct hostapd_data *hapd)
 {
 	hostapd_free_stas(hapd);
+#ifdef CONFIG_IEEE80211BE
 	/* do not flush stations during ap link removal */
 	if (!hapd->conf->mld_ap || !hapd->mld->removed_links)
+#endif /* CONFIG_IEEE80211BE */
 		hostapd_flush_old_stations(hapd, WLAN_REASON_DEAUTH_LEAVING);
 #ifdef CONFIG_WEP
 	hostapd_clear_wep(hapd);
@@ -1560,12 +1562,14 @@ int hostapd_setup_bss(struct hostapd_data *hapd, int first, bool start_beacon)
 		flush_old_stations = 0;
 		wpa_printf(MSG_DEBUG,
 			   "MLD: %s: Setting non-first BSS", __func__);
+#ifdef CONFIG_IEEE80211BE
 	} else if (hapd->conf->mld_ap &&
 		   hapd->iface->state == HAPD_IFACE_DFS) {
 		/* Also, avoid flushing old STA when the first BSS of the MLD requires CAC. */
 		flush_old_stations = 0;
 		wpa_printf(MSG_DEBUG,
 			   "MLD: %s: Setting first BSS after CAC complete", __func__);
+#endif /* CONFIG_IEEE80211BE */
 	}
 
 	wpa_printf(MSG_DEBUG, "%s(hapd=%p (%s), first=%d)",
@@ -3732,6 +3736,7 @@ hostapd_interface_init_bss(struct hapd_interfaces *interfaces, const char *phy,
 			return NULL;
 		}
 
+#ifdef CONFIG_IEEE80211BE
 		tmp_hapd = hostapd_interfaces_get_hapd(interfaces, ifname);
 		if (tmp_hapd) {
 			/* A BSS with an existing interface name can only be added
@@ -3746,6 +3751,7 @@ hostapd_interface_init_bss(struct hapd_interfaces *interfaces, const char *phy,
 				return NULL;
 			}
 		}
+#endif /* CONFIG_IEEE80211BE */
 
 		tmp_conf = os_realloc_array(
 			iface->conf->bss, iface->conf->num_bss + 1,
@@ -4687,6 +4693,7 @@ int hostapd_remove_iface(struct hapd_interfaces *interfaces, char *buf)
 }
 
 
+#ifdef CONFIG_IEEE80211BE
 static int hostapd_remove_mld_link_by_idx(struct hostapd_iface *iface, int idx)
 {
 	size_t j;
@@ -4778,6 +4785,7 @@ int hostapd_remove_mld(struct hapd_interfaces *interfaces, char *buf)
 	hostapd_cleanup_unused_mlds(interfaces);
 	return 0;
 }
+#endif /* CONFIG_IEEE80211BE */
 
 
 /**
@@ -5317,8 +5325,10 @@ static int hostapd_fill_csa_settings(struct hostapd_data *hapd,
 	if (ret)
 		return ret;
 
+#ifdef CONFIG_IEEE80211BE
 	/* Another CU in the new channel due to OP element modification */
 	ieee802_11_set_bss_critical_update(hapd, BSS_CRIT_UPDATE_EVENT_EHT_OPERATION);
+#endif /* CONFIG_IEEE80211BE */
 	ret = hostapd_build_beacon_data(hapd, &settings->beacon_after);
 
 	/* change back the configuration */
@@ -5421,6 +5431,7 @@ int hostapd_switch_channel(struct hostapd_data *hapd,
 		return -1;
 	}
 
+#ifdef CONFIG_IEEE80211BE
 	ieee802_11_set_bss_critical_update(hapd, BSS_CRIT_UPDATE_EVENT_CSA);
 
 	if (hapd->conf->mld_ap) {
@@ -5428,6 +5439,7 @@ int hostapd_switch_channel(struct hostapd_data *hapd,
 		for_each_mld_link(link_bss, hapd)
 			hostapd_gen_per_sta_profiles(link_bss);
 	}
+#endif /* CONFIG_IEEE80211BE */
 
 	ret = hostapd_fill_csa_settings(hapd, settings);
 	if (ret)
@@ -5450,6 +5462,7 @@ int hostapd_switch_channel(struct hostapd_data *hapd,
 	return 0;
 }
 
+#ifdef CONFIG_IEEE80211BE
 int hostapd_update_aff_link_beacon(struct hostapd_data *hapd, u8 cs_count)
 {
 	struct hostapd_data *h;
@@ -5521,6 +5534,7 @@ int hostapd_update_aff_link_beacon(struct hostapd_data *hapd, u8 cs_count)
 
 	return 0;
 }
+#endif /* CONFIG_IEEE80211BE */
 
 
 void
diff --git a/src/ap/hostapd.h b/src/ap/hostapd.h
index 4c140675b..85f79b2a5 100644
--- a/src/ap/hostapd.h
+++ b/src/ap/hostapd.h
@@ -558,6 +558,10 @@ struct hostapd_data {
 
 	s64 tsf_offset[MAX_NUM_MLD_LINKS];
 
+#ifdef CONFIG_TESTING_OPTIONS
+	u8 eht_mld_link_removal_count;
+#endif /* CONFIG_TESTING_OPTIONS */
+#endif /* CONFIG_IEEE80211BE */
 	u32 deauth_count_from_sta;
 	u32 deauth_count_from_ap_uc;
 	u32 deauth_count_from_ap_bc;
@@ -565,11 +569,6 @@ struct hostapd_data {
 	u32 disassoc_count_from_ap_uc;
 	u32 disassoc_count_from_ap_bc;
 
-#ifdef CONFIG_TESTING_OPTIONS
-	u8 eht_mld_link_removal_count;
-#endif /* CONFIG_TESTING_OPTIONS */
-#endif /* CONFIG_IEEE80211BE */
-
 #ifdef CONFIG_NAN_USD
 	struct nan_de *nan_de;
 #endif /* CONFIG_NAN_USD */
@@ -989,7 +988,9 @@ void hostapd_cleanup_iface_partial(struct hostapd_iface *iface);
 int hostapd_add_iface(struct hapd_interfaces *ifaces, char *buf);
 int hostapd_remove_bss(struct hapd_interfaces *ifaces, char *buf);
 int hostapd_remove_iface(struct hapd_interfaces *ifaces, char *buf);
+#ifdef CONFIG_IEEE80211BE
 int hostapd_remove_mld(struct hapd_interfaces *ifaces, char *buf);
+#endif /* CONFIG_IEEE80211BE */
 void hostapd_channel_list_updated(struct hostapd_iface *iface, int initiator);
 void hostapd_set_state(struct hostapd_iface *iface, enum hostapd_iface_state s);
 const char * hostapd_state_text(enum hostapd_iface_state s);
@@ -998,7 +999,9 @@ void hostapd_chan_switch_config(struct hostapd_data *hapd,
 				struct hostapd_freq_params *freq_params);
 int hostapd_switch_channel(struct hostapd_data *hapd,
 			   struct csa_settings *settings);
+#ifdef CONFIG_IEEE80211BE
 int hostapd_update_aff_link_beacon(struct hostapd_data *hapd, u8 cs_count);
+#endif /* CONFIG_IEEE80211BE */
 void
 hostapd_switch_channel_fallback(struct hostapd_iface *iface,
 				const struct hostapd_freq_params *freq_params);
diff --git a/src/ap/ieee802_11.c b/src/ap/ieee802_11.c
index 4bf539f72..839aad3d2 100644
--- a/src/ap/ieee802_11.c
+++ b/src/ap/ieee802_11.c
@@ -3852,6 +3852,7 @@ static u16 check_wmm(struct hostapd_data *hapd, struct sta_info *sta,
 	return WLAN_STATUS_SUCCESS;
 }
 
+#ifdef CONFIG_IEEE80211BE
 static void check_mscs_desc_elem(struct hostapd_data *hapd, struct sta_info *sta,
 				 struct ieee802_11_elems *elems)
 {
@@ -3863,6 +3864,7 @@ static void check_mscs_desc_elem(struct hostapd_data *hapd, struct sta_info *sta
 				 elems->mscs_desc_len);
 	sta->mscs_assoc_included = 1;
 }
+#endif /* CONFIG_IEEE80211BE */
 
 static void check_mtk_vendor_elem(struct hostapd_data *hapd, struct sta_info *sta,
 				  struct ieee802_11_elems *elems)
@@ -7018,8 +7020,8 @@ static int handle_action(struct hostapd_data *hapd,
 	case WLAN_ACTION_ROBUST_AV_STREAMING:
 		hostapd_handle_robust_av_streaming(hapd, (const u8 *) mgmt, len);
 		return 1;
-	}
 #endif /* CONFIG_IEEE80211BE */
+	}
 
 	hostapd_logger(hapd, mgmt->sa, HOSTAPD_MODULE_IEEE80211,
 		       HOSTAPD_LEVEL_DEBUG,
diff --git a/src/ap/ieee802_11.h b/src/ap/ieee802_11.h
index a0064a1ca..329667a8e 100644
--- a/src/ap/ieee802_11.h
+++ b/src/ap/ieee802_11.h
@@ -325,6 +325,7 @@ void ieee80211_ml_build_assoc_resp(struct hostapd_data *hapd,
 				   struct mld_link_info *link,
 				   struct wpa_state_machine *sm);
 
+#ifdef CONFIG_IEEE80211BE
 void ieee802_11_rx_protected_eht_action(struct hostapd_data *hapd,
 					const struct ieee80211_mgmt *mgmt,
 					size_t len);
@@ -348,5 +349,6 @@ int ieee802_11_send_epcs_req(struct hostapd_data *hapd, struct mld_info *mld,
 int ieee802_11_send_epcs_resp(struct hostapd_data *hapd, struct mld_info *mld,
 			      u8 dialog_token, u16 status, u16 *wmm_idx_tbl);
 int ieee802_11_send_epcs_teardown(struct hostapd_data *hapd, struct mld_info *mld);
+#endif /* CONFIG_IEEE80211BE */
 bool hostapd_is_robust_av_scs_disabled(struct hostapd_data *hapd);
 #endif /* IEEE802_11_H */
diff --git a/src/ap/sta_info.c b/src/ap/sta_info.c
index 1591aea67..5918daa2a 100644
--- a/src/ap/sta_info.c
+++ b/src/ap/sta_info.c
@@ -2158,6 +2158,7 @@ void ap_cleanup_sta(struct hostapd_data *hapd, const u8 *addr) {
 		ap_free_sta(hapd, sta);
 }
 
+#ifdef CONFIG_IEEE80211BE
 static void hostapd_reset_assoc_sta(struct hostapd_data *hapd, struct sta_info *sta)
 {
 	struct hostapd_data *link_bss, *new_assoc_hapd = NULL;
@@ -2236,6 +2237,7 @@ static void hostapd_reset_assoc_sta(struct hostapd_data *hapd, struct sta_info *
 		link_sta->flags |= WLAN_STA_ASSOC;
 	}
 }
+#endif /* CONFIG_IEEE80211BE */
 
 void hostapd_reset_assoc_stas(struct hostapd_data *hapd)
 {
diff --git a/src/ap/ucode.c b/src/ap/ucode.c
index 45b6ce6d5..8da2d55f9 100644
--- a/src/ap/ucode.c
+++ b/src/ap/ucode.c
@@ -661,9 +661,11 @@ uc_hostapd_iface_start(uc_vm_t *vm, size_t nargs)
 	if (!errno)
 		hostapd_set_oper_chwidth(conf, intval);
 
+#ifdef CONFIG_IEEE80211BE
 	intval = ucv_int64_get(ucv_object_get(info, "punct_bitmap", NULL));
 	if (!errno)
 		conf->punct_bitmap = intval;
+#endif /* CONFIG_IEEE80211BE */
 
 	conf->pp_mode = PP_USR_MODE;
 	if (iface->state == HAPD_IFACE_ENABLED &&
diff --git a/src/ap/wmm.c b/src/ap/wmm.c
index b53838a5b..ee9978703 100644
--- a/src/ap/wmm.c
+++ b/src/ap/wmm.c
@@ -389,6 +389,7 @@ void hostapd_wmm_action(struct hostapd_data *hapd,
 		       action_code);
 }
 
+#ifdef CONFIG_IEEE80211BE
 size_t hostapd_eid_eht_epcs_ml_len(struct mld_info *mld)
 {
 	size_t len = 3 + sizeof(struct ieee80211_eht_ml) +
@@ -463,4 +464,5 @@ int hostapd_eid_eht_epcs_ml(struct hostapd_data *hapd, struct wpabuf *buf,
 
 	return 0;
 }
+#endif /* CONFIG_IEEE80211BE */
 
diff --git a/src/ap/wpa_auth_ft.c b/src/ap/wpa_auth_ft.c
index d26e90f16..fecc0bc25 100644
--- a/src/ap/wpa_auth_ft.c
+++ b/src/ap/wpa_auth_ft.c
@@ -2899,6 +2899,7 @@ u8 * wpa_sm_write_assoc_resp_ies(struct wpa_state_machine *sm, u8 *pos,
 					   "key subelement");
 				return NULL;
 			}
+#ifdef CONFIG_IEEE80211BE
 		} else {
 			u8 *link_key_subelem;
 			size_t link_key_len;
@@ -2933,6 +2934,7 @@ u8 * wpa_sm_write_assoc_resp_ies(struct wpa_state_machine *sm, u8 *pos,
 				subelem_len += link_key_len;
 				os_free(link_key_subelem);
 			}
+#endif /* CONFIG_IEEE80211BE */
 		}
 #ifdef CONFIG_OCV
 		if (wpa_auth_uses_ocv(sm)) {
@@ -4765,6 +4767,7 @@ static int wpa_ft_rrb_rx_resp(struct wpa_authenticator *primary_auth,
 	os_memset(&ctx, 0, sizeof(ctx));
 	ctx.nonce = f_nonce;
 
+#ifdef CONFIG_IEEE80211BE
 	/* Primary auth may not have corresponding sta state machine
 	 * search all the sta of the mld bss for the target wpa_auth */
 	if (primary_auth->is_ml) {
@@ -4776,7 +4779,9 @@ static int wpa_ft_rrb_rx_resp(struct wpa_authenticator *primary_auth,
 			if (wpa_auth_for_each_sta(target_auth, ft_get_sta_cb, &ctx))
 				break;
 		}
-	} else {
+	} else
+#endif /* CONFIG_IEEE80211BE */
+	{
 		if (wpa_auth_for_each_sta(primary_auth, ft_get_sta_cb, &ctx))
 			target_auth = primary_auth;
 	}
@@ -5345,11 +5350,13 @@ void wpa_ft_rrb_oui_rx(struct wpa_authenticator *wpa_auth, const u8 *src_addr,
 		return;
 	}
 
+#ifdef CONFIG_IEEE80211BE
 	if (ether_addr_equal(wpa_auth->mld_addr, dst_addr) && wpa_auth->is_ml &&
 	    !wpa_auth->primary_auth) {
 		wpa_printf(MSG_DEBUG, "MLD: FT: RRB frame handled by primary auth");
 		return;
 	}
+#endif /* CONFIG_IEEE80211BE */
 
 	auth = data + sizeof(u16);
 	wpa_hexdump(MSG_MSGDUMP, "FT: Authenticated payload", auth, alen);
diff --git a/src/ap/wpa_auth_glue.c b/src/ap/wpa_auth_glue.c
index 55e9c69b4..29f69dd8e 100644
--- a/src/ap/wpa_auth_glue.c
+++ b/src/ap/wpa_auth_glue.c
@@ -985,6 +985,7 @@ static int hostapd_wpa_auth_send_oui(void *ctx, const u8 *dst, u8 oui_suffix,
 #ifdef CONFIG_ETH_P_OUI
 	struct hostapd_data *hapd = ctx;
 	struct eth_p_oui_ctx *oui_ctx;
+	u8 *src_addr;
 
 	wpa_printf(MSG_DEBUG, "RRB(%s): send to dst=" MACSTR
 		   " oui_suffix=%u data_len=%u",
@@ -1014,9 +1015,13 @@ static int hostapd_wpa_auth_send_oui(void *ctx, const u8 *dst, u8 oui_suffix,
 		return -1;
 
 	/* TODO handle non-mld sta roaming with mld ap */
-	return eth_p_oui_send(oui_ctx,
-			      hapd->conf->mld_ap ? hapd->mld->mld_addr : hapd->own_addr,
-			      dst, data, data_len);
+#ifdef CONFIG_IEEE80211BE
+	if (hapd->conf->mld_ap)
+		src_addr = hapd->mld->mld_addr;
+	else
+#endif /* CONFIG_IEEE80211BE */
+		src_addr = hapd->own_addr;
+	return eth_p_oui_send(oui_ctx, src_addr, dst, data, data_len);
 #else /* CONFIG_ETH_P_OUI */
 	return -1;
 #endif /* CONFIG_ETH_P_OUI */
@@ -1528,8 +1533,10 @@ static void hostapd_rrb_receive(void *ctx, const u8 *src_addr, const u8 *buf,
 	wpa_printf(MSG_DEBUG, "FT: RRB received packet " MACSTR " -> "
 		   MACSTR, MAC2STR(ethhdr->h_source), MAC2STR(ethhdr->h_dest));
 	if (!is_multicast_ether_addr(ethhdr->h_dest) &&
-	    !ether_addr_equal(hapd->own_addr, ethhdr->h_dest) &&
-	    !(hapd->mld && ether_addr_equal(hapd->mld->mld_addr, ethhdr->h_dest)))
+#ifdef CONFIG_IEEE80211BE
+	    !(hapd->mld && ether_addr_equal(hapd->mld->mld_addr, ethhdr->h_dest)) &&
+#endif /* CONFIG_IEEE80211BE */
+	    !ether_addr_equal(hapd->own_addr, ethhdr->h_dest))
 		return;
 	wpa_ft_rrb_rx(hapd->wpa_auth, ethhdr->h_source, buf + sizeof(*ethhdr),
 		      len - sizeof(*ethhdr));
@@ -1545,8 +1552,10 @@ static void hostapd_rrb_oui_receive(void *ctx, const u8 *src_addr,
 	wpa_printf(MSG_DEBUG, "FT: RRB received packet " MACSTR " -> "
 		   MACSTR, MAC2STR(src_addr), MAC2STR(dst_addr));
 	if (!is_multicast_ether_addr(dst_addr) &&
-	    !ether_addr_equal(hapd->own_addr, dst_addr) &&
-	    !(hapd->mld && ether_addr_equal(hapd->mld->mld_addr, dst_addr)))
+#ifdef CONFIG_IEEE80211BE
+	    !(hapd->mld && ether_addr_equal(hapd->mld->mld_addr, dst_addr)) &&
+#endif /* CONFIG_IEEE80211BE */
+	    !ether_addr_equal(hapd->own_addr, dst_addr))
 		return;
 	wpa_ft_rrb_oui_rx(hapd->wpa_auth, src_addr, dst_addr, oui_suffix, buf,
 			  len);
diff --git a/src/drivers/driver_nl80211.c b/src/drivers/driver_nl80211.c
index b762692f6..252378a8e 100644
--- a/src/drivers/driver_nl80211.c
+++ b/src/drivers/driver_nl80211.c
@@ -17274,8 +17274,10 @@ const struct wpa_driver_ops wpa_driver_nl80211_ops = {
 	.mu_ctrl = nl80211_mu_ctrl,
 	.mu_dump = nl80211_mu_dump,
 	.beacon_ctrl = nl80211_beacon_ctrl,
+#ifdef CONFIG_IEEE80211BE
 	.set_eml_omn = nl80211_set_eml_omn,
 	.set_epcs = nl80211_set_epcs,
+#endif /* CONFIG_IEEE80211BE */
 #ifdef CONFIG_DPP
 	.dpp_listen = nl80211_dpp_listen,
 #endif /* CONFIG_DPP */
-- 
2.45.2

