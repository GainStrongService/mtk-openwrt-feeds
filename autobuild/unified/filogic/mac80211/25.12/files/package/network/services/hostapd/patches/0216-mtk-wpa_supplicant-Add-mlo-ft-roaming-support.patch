From a18c9da000b381e33e823378fdc125385584bc3e Mon Sep 17 00:00:00 2001
From: Allen Ye <allen.ye@mediatek.com>
Date: Fri, 22 Aug 2025 18:06:38 +0800
Subject: [PATCH 216/254] mtk: wpa_supplicant: Add mlo ft roaming support

Add roaming cmd mld support with following cmd:
wpa_cli -i <ifname> roam <target address> [link=link address]
The target address could be mld address. If link address is not
specified the target link would be the first bss with matched mld
address in the scan table.
Add sta process mld ft reassoc ft ie with mld group keys.

Signed-off-by: Allen Ye <allen.ye@mediatek.com>
---
 src/rsn_supp/wpa_ft.c       | 112 +++++++++++++++++++++++++++---------
 wpa_supplicant/bss.c        |  12 +++-
 wpa_supplicant/bss.h        |   3 +-
 wpa_supplicant/ctrl_iface.c |  23 ++++++--
 4 files changed, 113 insertions(+), 37 deletions(-)

diff --git a/src/rsn_supp/wpa_ft.c b/src/rsn_supp/wpa_ft.c
index 5f8d8e431..0730eb58c 100644
--- a/src/rsn_supp/wpa_ft.c
+++ b/src/rsn_supp/wpa_ft.c
@@ -686,6 +686,11 @@ int wpa_ft_process_response(struct wpa_sm *sm, const u8 *ies, size_t ies_len,
 		goto fail;
 	}
 
+	if (sm->mlo.valid_links && !parse.basic_ml) {
+		wpa_printf(MSG_DEBUG, "FT: No basic Multi-Link element");
+		goto fail;
+	}
+
 	os_memcpy(sm->r1kh_id, parse.r1kh_id, FT_R1KH_ID_LEN);
 	wpa_hexdump(MSG_DEBUG, "FT: R1KH-ID", sm->r1kh_id, FT_R1KH_ID_LEN);
 	wpa_hexdump(MSG_DEBUG, "FT: SNonce", sm->snonce, WPA_NONCE_LEN);
@@ -708,7 +713,6 @@ int wpa_ft_process_response(struct wpa_sm *sm, const u8 *ies, size_t ies_len,
 	else
 		kdk_len = 0;
 
-	/* TODO: AP MLD address for MLO */
 	if (wpa_pmk_r1_to_ptk(sm->pmk_r1, sm->pmk_r1_len, sm->snonce,
 			      parse.fte_anonce, sm->own_addr, bssid,
 			      sm->pmk_r1_name, &sm->ptk, ptk_name, sm->key_mgmt,
@@ -798,7 +802,7 @@ void wpa_reset_ft_completed(struct wpa_sm *sm)
 
 
 static int wpa_ft_process_gtk_subelem(struct wpa_sm *sm, const u8 *gtk_elem,
-				      size_t gtk_elem_len)
+				      size_t gtk_elem_len, int link_id)
 {
 	u8 gtk[32];
 	int keyidx;
@@ -806,6 +810,7 @@ static int wpa_ft_process_gtk_subelem(struct wpa_sm *sm, const u8 *gtk_elem,
 	size_t gtk_len, keylen, rsc_len;
 	const u8 *kek;
 	size_t kek_len;
+	size_t hlen;
 
 	if (wpa_key_mgmt_fils(sm->key_mgmt)) {
 		kek = sm->ptk.kek2;
@@ -823,14 +828,16 @@ static int wpa_ft_process_gtk_subelem(struct wpa_sm *sm, const u8 *gtk_elem,
 	wpa_hexdump_key(MSG_DEBUG, "FT: Received GTK in Reassoc Resp",
 			gtk_elem, gtk_elem_len);
 
-	if (gtk_elem_len < 11 + 24 || (gtk_elem_len - 11) % 8 ||
-	    gtk_elem_len - 19 > sizeof(gtk)) {
+	hlen = (link_id < 0) ? 11 : 12;
+
+	if (gtk_elem_len < hlen + 24 || (gtk_elem_len - hlen) % 8 ||
+	    gtk_elem_len - (hlen + 8) > sizeof(gtk)) {
 		wpa_printf(MSG_DEBUG, "FT: Invalid GTK sub-elem "
 			   "length %lu", (unsigned long) gtk_elem_len);
 		return -1;
 	}
-	gtk_len = gtk_elem_len - 19;
-	if (aes_unwrap(kek, kek_len, gtk_len / 8, gtk_elem + 11, gtk)) {
+	gtk_len = gtk_elem_len - (hlen + 8);
+	if (aes_unwrap(kek, kek_len, gtk_len / 8, gtk_elem + hlen, gtk)) {
 		wpa_printf(MSG_WARNING, "FT: AES unwrap failed - could not "
 			   "decrypt GTK");
 		return -1;
@@ -850,14 +857,15 @@ static int wpa_ft_process_gtk_subelem(struct wpa_sm *sm, const u8 *gtk_elem,
 		return -1;
 	}
 
-	/* Key Info[2] | Key Length[1] | RSC[8] | Key[5..32]. */
+	/* Key Info[2] | [Link ID Info[1]] | Key Length[1] | RSC[8] |
+	 * Key[5..32]. */
 
 	keyidx = WPA_GET_LE16(gtk_elem) & 0x03;
 
-	if (gtk_elem[2] != keylen) {
+	if (gtk_elem[hlen - 9] != keylen) {
 		wpa_printf(MSG_DEBUG, "FT: GTK length mismatch: received %d "
 			   "negotiated %lu",
-			   gtk_elem[2], (unsigned long) keylen);
+			   gtk_elem[hlen - 9], (unsigned long) keylen);
 		return -1;
 	}
 
@@ -869,7 +877,7 @@ static int wpa_ft_process_gtk_subelem(struct wpa_sm *sm, const u8 *gtk_elem,
 		os_memcpy(gtk + 16, gtk + 24, 8);
 		os_memcpy(gtk + 24, tmp, 8);
 	}
-	if (wpa_sm_set_key(sm, -1, alg, broadcast_ether_addr, keyidx, 0,
+	if (wpa_sm_set_key(sm, link_id, alg, broadcast_ether_addr, keyidx, 0,
 			   gtk_elem + 3, rsc_len, gtk, keylen,
 			   KEY_FLAG_GROUP_RX) < 0) {
 		wpa_printf(MSG_WARNING, "WPA: Failed to set GTK to the "
@@ -882,13 +890,14 @@ static int wpa_ft_process_gtk_subelem(struct wpa_sm *sm, const u8 *gtk_elem,
 
 
 static int wpa_ft_process_igtk_subelem(struct wpa_sm *sm, const u8 *igtk_elem,
-				       size_t igtk_elem_len)
+				       size_t igtk_elem_len, int link_id)
 {
 	u8 igtk[WPA_IGTK_MAX_LEN];
 	size_t igtk_len;
 	u16 keyidx;
 	const u8 *kek;
 	size_t kek_len;
+	size_t hlen;
 
 	if (wpa_key_mgmt_fils(sm->key_mgmt)) {
 		kek = sm->ptk.kek2;
@@ -913,30 +922,31 @@ static int wpa_ft_process_igtk_subelem(struct wpa_sm *sm, const u8 *igtk_elem,
 			igtk_elem, igtk_elem_len);
 
 	igtk_len = wpa_cipher_key_len(sm->mgmt_group_cipher);
-	if (igtk_elem_len != 2 + 6 + 1 + igtk_len + 8) {
+	hlen = (link_id < 0) ? 9 : 10;
+	if (igtk_elem_len != hlen + igtk_len + 8) {
 		wpa_printf(MSG_DEBUG, "FT: Invalid IGTK sub-elem "
 			   "length %lu", (unsigned long) igtk_elem_len);
 		return -1;
 	}
-	if (igtk_elem[8] != igtk_len) {
+	if (igtk_elem[hlen - 1] != igtk_len) {
 		wpa_printf(MSG_DEBUG, "FT: Invalid IGTK sub-elem Key Length "
-			   "%d", igtk_elem[8]);
+			   "%d", igtk_elem[hlen - 1]);
 		return -1;
 	}
 
-	if (aes_unwrap(kek, kek_len, igtk_len / 8, igtk_elem + 9, igtk)) {
+	if (aes_unwrap(kek, kek_len, igtk_len / 8, igtk_elem + hlen, igtk)) {
 		wpa_printf(MSG_WARNING, "FT: AES unwrap failed - could not "
 			   "decrypt IGTK");
 		return -1;
 	}
 
-	/* KeyID[2] | IPN[6] | Key Length[1] | Key[16+8] */
+	/* KeyID[2] | IPN[6] | [Link ID info[1]] | Key Length[1] | Key[16+8] */
 
 	keyidx = WPA_GET_LE16(igtk_elem);
 
 	wpa_hexdump_key(MSG_DEBUG, "FT: IGTK from Reassoc Resp", igtk,
 			igtk_len);
-	if (wpa_sm_set_key(sm, -1, wpa_cipher_to_alg(sm->mgmt_group_cipher),
+	if (wpa_sm_set_key(sm, link_id, wpa_cipher_to_alg(sm->mgmt_group_cipher),
 			   broadcast_ether_addr, keyidx, 0,
 			   igtk_elem + 2, 6, igtk, igtk_len,
 			   KEY_FLAG_GROUP_RX) < 0) {
@@ -952,13 +962,14 @@ static int wpa_ft_process_igtk_subelem(struct wpa_sm *sm, const u8 *igtk_elem,
 
 
 static int wpa_ft_process_bigtk_subelem(struct wpa_sm *sm, const u8 *bigtk_elem,
-				       size_t bigtk_elem_len)
+					size_t bigtk_elem_len, int link_id)
 {
 	u8 bigtk[WPA_BIGTK_MAX_LEN];
 	size_t bigtk_len;
 	u16 keyidx;
 	const u8 *kek;
 	size_t kek_len;
+	size_t hlen;
 
 	if (!sm->beacon_prot || !bigtk_elem ||
 	    (sm->mgmt_group_cipher != WPA_CIPHER_AES_128_CMAC &&
@@ -979,32 +990,33 @@ static int wpa_ft_process_bigtk_subelem(struct wpa_sm *sm, const u8 *bigtk_elem,
 			bigtk_elem, bigtk_elem_len);
 
 	bigtk_len = wpa_cipher_key_len(sm->mgmt_group_cipher);
-	if (bigtk_elem_len != 2 + 6 + 1 + bigtk_len + 8) {
+	hlen = (link_id < 0) ? 9 : 10;
+	if (bigtk_elem_len != hlen + bigtk_len + 8) {
 		wpa_printf(MSG_DEBUG,
 			   "FT: Invalid BIGTK sub-elem length %lu",
 			   (unsigned long) bigtk_elem_len);
 		return -1;
 	}
-	if (bigtk_elem[8] != bigtk_len) {
+	if (bigtk_elem[hlen - 1] != bigtk_len) {
 		wpa_printf(MSG_DEBUG,
 			   "FT: Invalid BIGTK sub-elem Key Length %d",
-			   bigtk_elem[8]);
+			   bigtk_elem[hlen - 1]);
 		return -1;
 	}
 
-	if (aes_unwrap(kek, kek_len, bigtk_len / 8, bigtk_elem + 9, bigtk)) {
+	if (aes_unwrap(kek, kek_len, bigtk_len / 8, bigtk_elem + hlen, bigtk)) {
 		wpa_printf(MSG_WARNING,
 			   "FT: AES unwrap failed - could not decrypt BIGTK");
 		return -1;
 	}
 
-	/* KeyID[2] | IPN[6] | Key Length[1] | Key[16+8] */
+	/* KeyID[2] | IPN[6] | [Link ID Info[1]] | Key Length[1] | Key[16+8] */
 
 	keyidx = WPA_GET_LE16(bigtk_elem);
 
 	wpa_hexdump_key(MSG_DEBUG, "FT: BIGTK from Reassoc Resp", bigtk,
 			bigtk_len);
-	if (wpa_sm_set_key(sm, -1, wpa_cipher_to_alg(sm->mgmt_group_cipher),
+	if (wpa_sm_set_key(sm, link_id, wpa_cipher_to_alg(sm->mgmt_group_cipher),
 			   broadcast_ether_addr, keyidx, 0,
 			   bigtk_elem + 2, 6, bigtk, bigtk_len,
 			   KEY_FLAG_GROUP_RX) < 0) {
@@ -1019,6 +1031,42 @@ static int wpa_ft_process_bigtk_subelem(struct wpa_sm *sm, const u8 *bigtk_elem,
 }
 
 
+static int wpa_ft_process_mlo_groups_keys(struct wpa_sm *sm,
+					  struct wpa_ft_ies *parse)
+{
+	int link_id = 0;
+
+	for (link_id = 0; link_id < MAX_NUM_MLD_LINKS; link_id++) {
+		if (!(parse->valid_mlo_gtks & BIT(link_id)))
+			continue;
+
+		if (wpa_ft_process_gtk_subelem(sm,
+					       parse->mlo_gtk[link_id],
+					       parse->mlo_gtk_len[link_id],
+					       link_id))
+			return -1;
+
+		if (!(parse->valid_mlo_igtks & BIT(link_id)))
+			continue;
+
+		if (wpa_ft_process_igtk_subelem(sm,
+						parse->mlo_igtk[link_id],
+						parse->mlo_igtk_len[link_id],
+						link_id))
+			return -1;
+
+		if (!(parse->valid_mlo_bigtks & BIT(link_id)))
+			continue;
+
+		if (wpa_ft_process_bigtk_subelem(sm,
+						 parse->mlo_bigtk[link_id],
+						 parse->mlo_bigtk_len[link_id],
+						 link_id))
+			return -1;
+	}
+	return 0;
+}
+
 int wpa_ft_validate_reassoc_resp(struct wpa_sm *sm, const u8 *ies,
 				 size_t ies_len, const u8 *src_addr)
 {
@@ -1250,10 +1298,18 @@ int wpa_ft_validate_reassoc_resp(struct wpa_sm *sm, const u8 *ies,
 
 	sm->ft_reassoc_completed = 1;
 
-	if (wpa_ft_process_gtk_subelem(sm, parse.gtk, parse.gtk_len) < 0 ||
-	    wpa_ft_process_igtk_subelem(sm, parse.igtk, parse.igtk_len) < 0 ||
-	    wpa_ft_process_bigtk_subelem(sm, parse.bigtk, parse.bigtk_len) < 0)
-		goto fail;
+	if (parse.basic_ml) {
+		if (wpa_ft_process_mlo_groups_keys(sm, &parse) < 0)
+			goto fail;
+	} else {
+		if (wpa_ft_process_gtk_subelem(sm, parse.gtk,
+					       parse.gtk_len, -1) < 0 ||
+		    wpa_ft_process_igtk_subelem(sm, parse.igtk,
+						parse.igtk_len, -1) < 0 ||
+		    wpa_ft_process_bigtk_subelem(sm, parse.bigtk,
+						 parse.bigtk_len, -1) < 0)
+			goto fail;
+	}
 
 	if (sm->set_ptk_after_assoc) {
 		wpa_printf(MSG_DEBUG, "FT: Try to set PTK again now that we "
diff --git a/wpa_supplicant/bss.c b/wpa_supplicant/bss.c
index 1fff73c70..c9f9d0ced 100644
--- a/wpa_supplicant/bss.c
+++ b/wpa_supplicant/bss.c
@@ -310,9 +310,10 @@ struct wpa_bss * wpa_bss_get(struct wpa_supplicant *wpa_s, const u8 *bssid,
 /**
  * wpa_bss_get_connection - Fetch a BSS table entry based on BSSID and SSID.
  * @wpa_s: Pointer to wpa_supplicant data
- * @bssid: BSSID, or %NULL to match any BSSID
+ * @bssid: BSSID or MLD address, or %NULL to match any BSSID
  * @ssid: SSID
  * @ssid_len: Length of @ssid
+ * @link_addr: Link address of the bss or NULL for not specify link
  * Returns: Pointer to the BSS entry or %NULL if not found
  *
  * This function is similar to wpa_bss_get() but it will also return OWE
@@ -321,7 +322,8 @@ struct wpa_bss * wpa_bss_get(struct wpa_supplicant *wpa_s, const u8 *bssid,
  */
 struct wpa_bss * wpa_bss_get_connection(struct wpa_supplicant *wpa_s,
 					const u8 *bssid,
-					const u8 *ssid, size_t ssid_len)
+					const u8 *ssid, size_t ssid_len,
+					const u8 *link_addr)
 {
 	struct wpa_bss *bss;
 #ifdef CONFIG_OWE
@@ -332,7 +334,11 @@ struct wpa_bss * wpa_bss_get_connection(struct wpa_supplicant *wpa_s,
 	if (bssid && !wpa_supplicant_filter_bssid_match(wpa_s, bssid))
 		return NULL;
 	dl_list_for_each(bss, &wpa_s->bss, struct wpa_bss, list) {
-		if (bssid && !ether_addr_equal(bss->bssid, bssid))
+		if (bssid && !ether_addr_equal(bss->bssid, bssid) &&
+		    !ether_addr_equal(bss->mld_addr, bssid))
+			continue;
+
+		if (link_addr && !ether_addr_equal(bss->bssid, link_addr))
 			continue;
 
 		if (bss->ssid_len == ssid_len &&
diff --git a/wpa_supplicant/bss.h b/wpa_supplicant/bss.h
index 74ef3c858..3b5a56038 100644
--- a/wpa_supplicant/bss.h
+++ b/wpa_supplicant/bss.h
@@ -164,7 +164,8 @@ struct wpa_bss * wpa_bss_get(struct wpa_supplicant *wpa_s, const u8 *bssid,
 			     const u8 *ssid, size_t ssid_len);
 struct wpa_bss * wpa_bss_get_connection(struct wpa_supplicant *wpa_s,
 					const u8 *bssid,
-					const u8 *ssid, size_t ssid_len);
+					const u8 *ssid, size_t ssid_len,
+					const u8 *link_addr);
 struct wpa_bss * wpa_bss_get_bssid(struct wpa_supplicant *wpa_s,
 				   const u8 *bssid);
 struct wpa_bss * wpa_bss_get_bssid_latest(struct wpa_supplicant *wpa_s,
diff --git a/wpa_supplicant/ctrl_iface.c b/wpa_supplicant/ctrl_iface.c
index 3e48c946c..2a92a5c8b 100644
--- a/wpa_supplicant/ctrl_iface.c
+++ b/wpa_supplicant/ctrl_iface.c
@@ -6047,22 +6047,34 @@ static void wpa_supplicant_ctrl_iface_drop_sa(struct wpa_supplicant *wpa_s)
 
 
 static int wpa_supplicant_ctrl_iface_roam(struct wpa_supplicant *wpa_s,
-					  char *addr)
+					  char *cmd)
 {
 #ifdef CONFIG_NO_SCAN_PROCESSING
 	return -1;
 #else /* CONFIG_NO_SCAN_PROCESSING */
-	u8 bssid[ETH_ALEN];
+	u8 bssid[ETH_ALEN], link_addr[ETH_ALEN];
+	bool set_link_addr = false;
+	char *pos;
 	struct wpa_bss *bss;
 	struct wpa_ssid *ssid = wpa_s->current_ssid;
 	struct wpa_radio_work *already_connecting;
 
-	if (hwaddr_aton(addr, bssid)) {
+	if (hwaddr_aton(cmd, bssid)) {
 		wpa_printf(MSG_DEBUG, "CTRL_IFACE ROAM: invalid "
-			   "address '%s'", addr);
+			   "cmd '%s'", cmd);
 		return -1;
 	}
 
+	pos = os_strstr(cmd, "link=");
+	if (pos) {
+		pos += 5;
+		if (hwaddr_aton(pos, link_addr))
+			wpa_printf(MSG_DEBUG, "CTRL_IFACE ROAM: failed to parse link"
+				   " address from cmd %s", cmd);
+		else
+			set_link_addr = true;
+	}
+
 	wpa_printf(MSG_DEBUG, "CTRL_IFACE ROAM " MACSTR, MAC2STR(bssid));
 
 	if (!ssid) {
@@ -6071,7 +6083,8 @@ static int wpa_supplicant_ctrl_iface_roam(struct wpa_supplicant *wpa_s,
 		return -1;
 	}
 
-	bss = wpa_bss_get_connection(wpa_s, bssid, ssid->ssid, ssid->ssid_len);
+	bss = wpa_bss_get_connection(wpa_s, bssid, ssid->ssid, ssid->ssid_len,
+				     set_link_addr ? link_addr : NULL);
 	if (!bss) {
 		wpa_printf(MSG_DEBUG, "CTRL_IFACE ROAM: Target AP not found "
 			   "from BSS table");
-- 
2.45.2

