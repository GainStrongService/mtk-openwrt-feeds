From c4c2ecab36c93cbbd61f854f5eeeea7af753cd97 Mon Sep 17 00:00:00 2001
From: Howard Hsu <howard-yh.hsu@mediatek.com>
Date: Thu, 4 Dec 2025 09:53:59 +0800
Subject: [PATCH 249/254] mtk: hostapd: add configuration disable_robust_av_scs
 to control scs feature

Add a new hostapd configuration option, "disable_robust_av_scs," to
enable or disable SCS feature, with a default value of 0 to enable it.

For the legacy interface, it will read the corresponding configuration
to decide if this feature is on or off. For the MLD interface, it will
read the first link's configuration to decide if this feature is on or
off.

Signed-off-by: Howard Hsu <howard-yh.hsu@mediatek.com>

Fix possible endianness issue.

Signed-off-by: Howard Hsu <howard-yh.hsu@mediatek.com>
---
 hostapd/config_file.c      |  2 ++
 hostapd/hostapd.conf       |  5 +++++
 src/ap/ap_config.h         |  1 +
 src/ap/hostapd.c           |  3 +++
 src/ap/hostapd.h           |  1 +
 src/ap/ieee802_11.h        |  1 +
 src/ap/ieee802_11_eht.c    |  3 +++
 src/ap/ieee802_11_shared.c | 14 ++++++++++++++
 src/ap/scs.c               |  3 +++
 9 files changed, 33 insertions(+)

diff --git a/hostapd/config_file.c b/hostapd/config_file.c
index 3f7738ac7..37815dd5b 100644
--- a/hostapd/config_file.c
+++ b/hostapd/config_file.c
@@ -5270,6 +5270,8 @@ static int hostapd_config_fill(struct hostapd_config *conf,
 		bss->epcs_disabled = atoi(pos);
 	} else if (os_strcmp(buf, "neg_ttlm_support_mode") == 0) {
 		conf->neg_ttlm_support_mode = atoi(pos);
+	} else if (os_strcmp(buf, "robust_av_scs_disabled") == 0) {
+		bss->robust_av_scs_disabled = !!atoi(pos);
 #ifdef CONFIG_TESTING_OPTIONS
 	} else if (os_strcmp(buf, "eht_oper_puncturing_override") == 0) {
 		if (get_u16(pos, line, &bss->eht_oper_puncturing_override))
diff --git a/hostapd/hostapd.conf b/hostapd/hostapd.conf
index abaa476b5..7184a3f72 100644
--- a/hostapd/hostapd.conf
+++ b/hostapd/hostapd.conf
@@ -1181,6 +1181,11 @@ wmm_ac_vo_acm=0
 # 1 = Disable EPCS priority access on AP MLD
 #epcs_disabled=0
 
+# Boolean (0/1) to disable Robust AV streaming SCS and MSCS procedure support
+# 0 = AP supports handling SCS requests from the STA (default)
+# 1 = AP does not handle any SCS requests
+#robust_av_scs_disabled=0
+
 ##### IEEE 802.1X-2004 related configuration ##################################
 
 # Require IEEE 802.1X authorization
diff --git a/src/ap/ap_config.h b/src/ap/ap_config.h
index ad64b3529..13a721482 100644
--- a/src/ap/ap_config.h
+++ b/src/ap/ap_config.h
@@ -987,6 +987,7 @@ struct hostapd_bss_config {
 	u8 emlsr_on_one_link;
 
 	bool epcs_disabled;
+	bool robust_av_scs_disabled;
 #ifdef CONFIG_TESTING_OPTIONS
 	/*
 	 * If set indicate the AP as disabled in the RNR element included in the
diff --git a/src/ap/hostapd.c b/src/ap/hostapd.c
index af178d130..d04c8cba1 100644
--- a/src/ap/hostapd.c
+++ b/src/ap/hostapd.c
@@ -2760,6 +2760,9 @@ static void hostapd_mld_started(struct hostapd_iface *iface)
 
 		if (hapd->conf->epcs_disabled)
 			hapd->mld->epcs_disabled = hapd->conf->epcs_disabled;
+
+		if (hapd->conf->robust_av_scs_disabled)
+			hapd->mld->robust_av_scs_disabled = hapd->conf->robust_av_scs_disabled;
 	}
 #endif /* CONFIG_IEEE80211BE */
 }
diff --git a/src/ap/hostapd.h b/src/ap/hostapd.h
index f9557e021..8b65b932e 100644
--- a/src/ap/hostapd.h
+++ b/src/ap/hostapd.h
@@ -623,6 +623,7 @@ struct hostapd_mld {
 	u8 dialog_token;
 
 	bool epcs_disabled;
+	bool robust_av_scs_disabled;
 };
 
 #define HOSTAPD_MLD_MAX_REF_COUNT      0xFF
diff --git a/src/ap/ieee802_11.h b/src/ap/ieee802_11.h
index 7cd9d2218..a0064a1ca 100644
--- a/src/ap/ieee802_11.h
+++ b/src/ap/ieee802_11.h
@@ -348,4 +348,5 @@ int ieee802_11_send_epcs_req(struct hostapd_data *hapd, struct mld_info *mld,
 int ieee802_11_send_epcs_resp(struct hostapd_data *hapd, struct mld_info *mld,
 			      u8 dialog_token, u16 status, u16 *wmm_idx_tbl);
 int ieee802_11_send_epcs_teardown(struct hostapd_data *hapd, struct mld_info *mld);
+bool hostapd_is_robust_av_scs_disabled(struct hostapd_data *hapd);
 #endif /* IEEE802_11_H */
diff --git a/src/ap/ieee802_11_eht.c b/src/ap/ieee802_11_eht.c
index 32e919d75..be480ff36 100644
--- a/src/ap/ieee802_11_eht.c
+++ b/src/ap/ieee802_11_eht.c
@@ -144,6 +144,9 @@ u8 * hostapd_eid_eht_capab(struct hostapd_data *hapd, u8 *eid,
 		cap->mac_cap &= ~host_to_le16(EHT_MACCAP_EPCS_PRIO |
 					      EHT_MACCAP_UNSOL_EPCS_PARAM_UPDATE);
 
+	if (hostapd_is_robust_av_scs_disabled(hapd))
+		cap->mac_cap &= ~host_to_le16(EHT_MACCAP_SCS_TRAFFIC_DESC);
+
 	os_memcpy(cap->phy_cap, eht_cap->phy_cap, EHT_PHY_CAPAB_LEN);
 
 	if (!is_6ghz_op_class(hapd->iconf->op_class))
diff --git a/src/ap/ieee802_11_shared.c b/src/ap/ieee802_11_shared.c
index 89d416df8..30ac34bc8 100644
--- a/src/ap/ieee802_11_shared.c
+++ b/src/ap/ieee802_11_shared.c
@@ -532,6 +532,10 @@ u8 * hostapd_eid_ext_capab(struct hostapd_data *hapd, u8 *eid,
 		 * if ieee80211ac is not enabled (mainly 2.4G and 6G) */
 		if (i == 7 && !hapd->iconf->ieee80211ac)
 			*pos &= ~0x40;
+#ifdef CONFIG_IEEE80211BE
+		if (i == 6 && hostapd_is_robust_av_scs_disabled(hapd))
+			*pos &= ~0x40;
+#endif
 	}
 
 	while (len > 0 && eid[1 + len] == 0) {
@@ -1301,3 +1305,13 @@ void hostapd_wfa_capab(struct hostapd_data *hapd, struct sta_info *sta,
 	if (gen_capa)
 		hostapd_wfa_gen_capab(hapd, sta, gen_capa + 2, gen_capa[1]);
 }
+
+#ifdef CONFIG_IEEE80211BE
+bool hostapd_is_robust_av_scs_disabled(struct hostapd_data *hapd)
+{
+	if (hostapd_is_mld_ap(hapd))
+		return hapd->mld && hapd->mld->robust_av_scs_disabled;
+
+	return hapd->conf->robust_av_scs_disabled;
+}
+#endif
diff --git a/src/ap/scs.c b/src/ap/scs.c
index cb0ae8d21..301b80c3b 100644
--- a/src/ap/scs.c
+++ b/src/ap/scs.c
@@ -480,6 +480,9 @@ void hostapd_handle_robust_av_streaming(struct hostapd_data *hapd, const u8 *buf
 {
 	const struct ieee80211_mgmt *mgmt = (const struct ieee80211_mgmt *) buf;
 
+	if (hostapd_is_robust_av_scs_disabled(hapd))
+		return;
+
 	/*
 	 * Check for enough bytes: header + (1B)Category + (1B)Action +
 	 * (1B)Dialog Token.
-- 
2.45.2

