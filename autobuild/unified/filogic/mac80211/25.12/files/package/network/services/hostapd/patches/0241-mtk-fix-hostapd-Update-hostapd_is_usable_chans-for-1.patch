From c3d1c5c14f47dcc12414f48a7d721bc95e3c80f2 Mon Sep 17 00:00:00 2001
From: Allen Ye <allen.ye@mediatek.com>
Date: Mon, 3 Nov 2025 11:45:38 +0800
Subject: [PATCH 241/254] mtk: fix "hostapd: Update hostapd_is_usable_chans for
 {160,320}MHz chan width"

Fix hwsim test cases:
1. ap_ht40_plus_minus1
Add check HT40+ or 40- back.
2. ap_acs_vht80p80
BW 80p80 would not set central, add a central check, if not set we only
check the primary 40 MHz.
3. ap_vht80_to_24g_ht
Add additional secondary channel check.

Signed-off-by: Allen Ye <allen.ye@mediatek.com>
---
 src/ap/hw_features.c | 107 +++++++++++++++++++++++++++++--------------
 1 file changed, 73 insertions(+), 34 deletions(-)

diff --git a/src/ap/hw_features.c b/src/ap/hw_features.c
index cd7c22614..350224c5a 100644
--- a/src/ap/hw_features.c
+++ b/src/ap/hw_features.c
@@ -1069,12 +1069,23 @@ static bool hostapd_is_usable_punct_bitmap(struct hostapd_iface *iface)
  */
 int hostapd_is_usable_chans(struct hostapd_iface *iface)
 {
+	struct hostapd_channel_data *pri_chan;
 	int err, central, oper_chwidth;
 	int start_chan, start_freq, chan_num, i;
+	bool is_24ghz, ht_chwidth, acs_80p80;
 
 	if (!iface->current_mode)
 		return 0;
 
+	pri_chan = hw_get_channel_freq(iface->current_mode->mode,
+				       iface->freq, NULL,
+				       iface->hw_features,
+				       iface->num_hw_features);
+	if (!pri_chan) {
+		wpa_printf(MSG_ERROR, "Primary frequency not present");
+		return 0;
+	}
+
 	err = hostapd_is_usable_edmg(iface);
 	if (err <= 0)
 		return err;
@@ -1083,45 +1094,73 @@ int hostapd_is_usable_chans(struct hostapd_iface *iface)
 		return 0;
 
 	oper_chwidth = hostapd_get_oper_chwidth(iface->conf);
-	if (oper_chwidth == CONF_OPER_CHWIDTH_USE_HT) {
-		int chan = hw_get_chan(iface->current_mode->mode, iface->freq,
-				       iface->hw_features, iface->num_hw_features);
-		if (!chan) {
-			wpa_printf(MSG_ERROR, "Primary channel not present");
-			return 0;
+	central = hostapd_get_oper_centr_freq_seg0_idx(iface->conf);
+
+	is_24ghz = (iface->current_mode->mode <= HOSTAPD_MODE_IEEE80211G);
+	ht_chwidth = (oper_chwidth == CONF_OPER_CHWIDTH_USE_HT);
+	/* The central channel is not filled in acs_adjust_center_freq() after
+	 * ACS of 80p80. In the case we only check the primary 40 MHz */
+	acs_80p80 = (oper_chwidth == CONF_OPER_CHWIDTH_80P80MHZ && !central);
+	if (is_24ghz || ht_chwidth || acs_80p80) {
+		int secondary_freq, err2;
+
+		err = hostapd_is_usable_chan(iface, iface->freq, 0);
+		if (err <= 0 || !iface->conf->secondary_channel)
+			return err;
+
+		secondary_freq =
+			iface->freq + iface->conf->secondary_channel * 20;
+		err = hostapd_is_usable_chan(iface, secondary_freq, 0);
+
+		if (err > 0) {
+			if (iface->conf->secondary_channel == 1 &&
+			    (pri_chan->allowed_bw & HOSTAPD_CHAN_WIDTH_40P))
+				return 1;
+			if (iface->conf->secondary_channel == -1 &&
+			    (pri_chan->allowed_bw & HOSTAPD_CHAN_WIDTH_40M))
+				return 1;
+			err = 0;
 		}
 
-		switch (iface->conf->secondary_channel) {
-			case 1:
-				start_chan = chan;
-				chan_num = 2;
-				break;
-			case -1:
-				start_chan = chan - 4;
-				chan_num = 2;
-				break;
-			default:
-				start_chan = chan;
-				chan_num = 1;
+		if (!iface->conf->ht40_plus_minus_allowed)
+			return err;
+
+		/* Both HT40+ and HT40- are set, check the other secondary 40 */
+		secondary_freq =
+			iface->freq - iface->conf->secondary_channel * 20;
+		err2 = hostapd_is_usable_chan(iface, secondary_freq, 0);
+		if (err2 <= 0)
+			return err;
+
+		if (iface->conf->secondary_channel == 1 &&
+		    (pri_chan->allowed_bw & HOSTAPD_CHAN_WIDTH_40M)) {
+			iface->conf->secondary_channel = -1;
+			return 1;
 		}
-	} else {
-		switch (oper_chwidth) {
-			case CONF_OPER_CHWIDTH_80MHZ:
-			case CONF_OPER_CHWIDTH_80P80MHZ:
-				chan_num = 4;
-				break;
-			case CONF_OPER_CHWIDTH_160MHZ:
-				chan_num = 8;
-				break;
-			case CONF_OPER_CHWIDTH_320MHZ:
-				chan_num = 16;
-				break;
-			default:
-				return 0;
+
+		if (iface->conf->secondary_channel == -1 &&
+		    (pri_chan->allowed_bw & HOSTAPD_CHAN_WIDTH_40P)) {
+			iface->conf->secondary_channel = 1;
+			return 1;
 		}
-		central = hostapd_get_oper_centr_freq_seg0_idx(iface->conf);
-		start_chan = central - chan_num * 2 + 2;
+		return err;
 	}
+
+	switch (oper_chwidth) {
+		case CONF_OPER_CHWIDTH_80MHZ:
+		case CONF_OPER_CHWIDTH_80P80MHZ:
+			chan_num = 4;
+			break;
+		case CONF_OPER_CHWIDTH_160MHZ:
+			chan_num = 8;
+			break;
+		case CONF_OPER_CHWIDTH_320MHZ:
+			chan_num = 16;
+			break;
+		default:
+			return 0;
+	}
+	start_chan = central - chan_num * 2 + 2;
 	start_freq = hw_get_freq(iface->current_mode, start_chan);
 
 	if (!start_freq) {
-- 
2.45.2

