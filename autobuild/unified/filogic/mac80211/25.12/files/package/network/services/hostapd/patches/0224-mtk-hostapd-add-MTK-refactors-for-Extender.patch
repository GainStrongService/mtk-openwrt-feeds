From ce3c8d9783079219a3d11d4070f2d533946b129f Mon Sep 17 00:00:00 2001
From: Michael-CY Lee <michael-cy.lee@mediatek.com>
Date: Mon, 20 Oct 2025 16:27:47 +0800
Subject: [PATCH 224/254] mtk: hostapd: add MTK refactors for Extender

This change includes
1. More logs for debug
2. Bug fixes
3. Channel information synchronization support for
    - Channel width
    - EHT320 offset
    - PP bitmap

Signed-off-by: Michael-CY Lee <michael-cy.lee@mediatek.com>
---
 src/ap/ucode.c         |  52 ++++++++++++++++---
 src/utils/ucode.c      |  21 +++++---
 wpa_supplicant/ucode.c | 112 +++++++++++++++++++++++++++++++++++++++--
 3 files changed, 168 insertions(+), 17 deletions(-)

diff --git a/src/ap/ucode.c b/src/ap/ucode.c
index f376c9c14..45b6ce6d5 100644
--- a/src/ap/ucode.c
+++ b/src/ap/ucode.c
@@ -11,6 +11,7 @@
 #include "acs.h"
 #include "ieee802_11_auth.h"
 #include "neighbor_db.h"
+#include "ieee802_11.h"
 #include <libubox/uloop.h>
 
 static uc_resource_type_t *global_type, *bss_type, *iface_type;
@@ -585,6 +586,9 @@ uc_hostapd_iface_stop(uc_vm_t *vm, size_t nargs)
 	if (!iface)
 		return NULL;
 
+	wpa_printf(MSG_INFO, "ucode: mtk: stop iface for %s in state %s\n",
+		   iface->phy, hostapd_state_text(iface->state));
+
 	if (iface->state != HAPD_IFACE_ENABLED)
 		uc_hostapd_disable_iface(iface);
 
@@ -611,6 +615,9 @@ uc_hostapd_iface_start(uc_vm_t *vm, size_t nargs)
 	if (!iface)
 		return NULL;
 
+	wpa_printf(MSG_INFO, "ucode: mtk: start iface for %s in state %s\n",
+		   iface->phy, hostapd_state_text(iface->state));
+
 	if (!info)
 		goto out;
 
@@ -630,7 +637,13 @@ uc_hostapd_iface_start(uc_vm_t *vm, size_t nargs)
 	UPDATE_VAL(op_class, "op_class");
 	UPDATE_VAL(hw_mode, "hw_mode");
 	UPDATE_VAL(channel, "channel");
-	UPDATE_VAL(secondary_channel, "sec_channel");
+
+	intval = ucv_int64_get(ucv_object_get(info, "sec_channel", NULL));
+	if (!errno) {
+		conf->secondary_channel = intval;
+		changed = true;
+	}
+
 	if (!changed &&
 	    (iface->bss[0]->beacon_set_done ||
 	     iface->state == HAPD_IFACE_DFS))
@@ -648,6 +661,15 @@ uc_hostapd_iface_start(uc_vm_t *vm, size_t nargs)
 	if (!errno)
 		hostapd_set_oper_chwidth(conf, intval);
 
+	intval = ucv_int64_get(ucv_object_get(info, "punct_bitmap", NULL));
+	if (!errno)
+		conf->punct_bitmap = intval;
+
+	conf->pp_mode = PP_USR_MODE;
+	if (iface->state == HAPD_IFACE_ENABLED &&
+	    hostapd_drv_pp_mode_set(iface->bss[0]) != 0)
+		return NULL;
+
 	intval = ucv_int64_get(ucv_object_get(info, "frequency", NULL));
 	if (!errno)
 		iface->freq = intval;
@@ -676,6 +698,17 @@ out:
 		return ucv_boolean_new(true);
 	}
 
+	wpa_printf(MSG_INFO, "ucode: mtk: updated channel information:\n");
+	wpa_printf(MSG_INFO, "    * channel: %d\n", conf->channel);
+	wpa_printf(MSG_INFO, "    * op_class: %d\n", conf->op_class);
+	wpa_printf(MSG_INFO, "    * secondary channel: %d\n", conf->secondary_channel);
+	wpa_printf(MSG_INFO, "    * seg0: %d\n",
+		   hostapd_get_oper_centr_freq_seg0_idx(conf));
+	wpa_printf(MSG_INFO, "    * seg1: %d\n",
+		   hostapd_get_oper_centr_freq_seg1_idx(conf));
+	wpa_printf(MSG_INFO, "    * oper_chwidth: %d\n",
+		   hostapd_get_oper_chwidth(conf));
+
 	for (i = 0; i < iface->num_bss; i++) {
 		struct hostapd_data *hapd = iface->bss[i];
 		int ret;
@@ -711,6 +744,7 @@ uc_hostapd_iface_switch_channel(uc_vm_t *vm, size_t nargs)
 	uint64_t intval;
 	int i, ret = 0;
 
+	wpa_printf(MSG_INFO, "ucode: mtk: channel switch for %s\n", iface->phy);
 	if (!iface || ucv_type(info) != UC_OBJECT)
 		return NULL;
 
@@ -730,7 +764,8 @@ uc_hostapd_iface_switch_channel(uc_vm_t *vm, size_t nargs)
 	if (errno)
 		intval = hostapd_get_oper_chwidth(conf);
 	if (intval)
-		csa.freq_params.bandwidth = 40 << intval;
+		csa.freq_params.bandwidth = 40 <<
+			(intval == CONF_OPER_CHWIDTH_320MHZ ? 3 : intval);
 	else
 		csa.freq_params.bandwidth = csa.freq_params.sec_channel_offset ? 40 : 20;
 
@@ -740,17 +775,20 @@ uc_hostapd_iface_switch_channel(uc_vm_t *vm, size_t nargs)
 		csa.freq_params.center_freq1 = intval;
 	if ((intval = ucv_int64_get(ucv_object_get(info, "center_freq2", NULL))) && !errno)
 		csa.freq_params.center_freq2 = intval;
+	if ((intval = ucv_int64_get(ucv_object_get(info, "punct_bitmap", NULL))) && !errno)
+		csa.freq_params.punct_bitmap = intval;
 
 	wpa_printf(MSG_INFO, "ucode: mtk: switch channel information:\n");
 	wpa_printf(MSG_INFO, "    * freq is %d\n", csa.freq_params.freq);
-	wpa_printf(MSG_INFO, "    * bandwidth is %d\n",
-			csa.freq_params.bandwidth);
+	wpa_printf(MSG_INFO, "    * bandwidth is %d\n", csa.freq_params.bandwidth);
 	wpa_printf(MSG_INFO, "    * sec_chan_offset is %d\n",
-			csa.freq_params.sec_channel_offset);
+		   csa.freq_params.sec_channel_offset);
 	wpa_printf(MSG_INFO, "    * center_freq1 is %d\n",
-			csa.freq_params.center_freq1);
+		   csa.freq_params.center_freq1);
 	wpa_printf(MSG_INFO, "    * center_freq2 is %d\n",
-			csa.freq_params.center_freq2);
+		   csa.freq_params.center_freq2);
+	wpa_printf(MSG_INFO, "    * punct_bitmap is %d\n",
+		   csa.freq_params.punct_bitmap);
 
 	for (i = 0; i < iface->num_bss; i++) {
 		ret = hostapd_switch_channel(iface->bss[i], &csa);
diff --git a/src/utils/ucode.c b/src/utils/ucode.c
index bc714cf22..48678c213 100644
--- a/src/utils/ucode.c
+++ b/src/utils/ucode.c
@@ -105,6 +105,8 @@ uc_value_t *uc_wpa_freq_info(uc_vm_t *vm, size_t nargs)
 	uc_value_t *freq = uc_fn_arg(0);
 	uc_value_t *sec = uc_fn_arg(1);
 	int width = ucv_uint64_get(uc_fn_arg(2));
+	int punct_bitmap = ucv_uint64_get(uc_fn_arg(4));
+	int bw320_offset = 1;
 	int freq_val, center_idx, center_ofs;
 	enum oper_chan_width chanwidth;
 	enum hostapd_hw_mode hw_mode;
@@ -142,6 +144,9 @@ uc_value_t *uc_wpa_freq_info(uc_vm_t *vm, size_t nargs)
 	case 9:
 		width = 3;
 		chanwidth = CONF_OPER_CHWIDTH_320MHZ;
+
+		/* bw320_offset is 1 for 320 MHz-1, and 2 for 320 MHz-2 */
+		bw320_offset = ucv_uint64_get(uc_fn_arg(3));
 		break;
 	default:
 		return NULL;
@@ -173,12 +178,19 @@ uc_value_t *uc_wpa_freq_info(uc_vm_t *vm, size_t nargs)
 	ucv_object_add(ret, "hw_mode_str", ucv_string_new(modestr));
 	ucv_object_add(ret, "sec_channel", ucv_int64_new(sec_channel));
 	ucv_object_add(ret, "frequency", ucv_int64_new(freq_val));
+	ucv_object_add(ret, "oper_chwidth", ucv_int64_new(chanwidth));
+	ucv_object_add(ret, "punct_bitmap", ucv_int64_new(punct_bitmap));
 
-	if (!sec_channel)
+	if (chanwidth == CONF_OPER_CHWIDTH_USE_HT) {
+		center_idx = freq_val < 3000 ? 0 : channel + 2 * sec_channel;
+		ucv_object_add(ret, "center_seg0_idx", ucv_int64_new(center_idx));
+		ucv_object_add(ret, "center_freq1",
+			       ucv_int64_new(freq_val + sec_channel * 10));
 		return ret;
+	}
 
 	if (freq_val >= 5900)
-		center_ofs = 0;
+		center_ofs = 32 * (1 - bw320_offset);
 	else if (freq_val >= 5745)
 		center_ofs = 20;
 	else
@@ -187,10 +199,7 @@ uc_value_t *uc_wpa_freq_info(uc_vm_t *vm, size_t nargs)
 	tmp_channel &= ~((8 << width) - 1);
 	center_idx = tmp_channel + center_ofs + (4 << width) - 1;
 
-	if (freq_val < 3000)
-		ucv_object_add(ret, "center_seg0_idx", ucv_int64_new(0));
-	else
-		ucv_object_add(ret, "center_seg0_idx", ucv_int64_new(center_idx));
+	ucv_object_add(ret, "center_seg0_idx", ucv_int64_new(center_idx));
 	center_idx = (center_idx - channel) * 5 + freq_val;
 	ucv_object_add(ret, "center_freq1", ucv_int64_new(center_idx));
 
diff --git a/wpa_supplicant/ucode.c b/wpa_supplicant/ucode.c
index 35345323c..17d454d68 100644
--- a/wpa_supplicant/ucode.c
+++ b/wpa_supplicant/ucode.c
@@ -9,6 +9,7 @@
 #include "config.h"
 #include "bss.h"
 #include "ucode.h"
+#include "driver_i.h"
 
 static struct wpa_global *wpa_global;
 static uc_resource_type_t *global_type, *iface_type;
@@ -129,8 +130,11 @@ void wpas_ucode_event(struct wpa_supplicant *wpa_s, int event, union wpa_event_d
 {
 	const char *state;
 	uc_value_t *val;
+	enum oper_chan_width oper_chwidth;
+	int control_freq, center_freq1, bw320_offset = 1;
 
-	if (event != EVENT_CH_SWITCH_STARTED)
+	if (event != EVENT_CH_SWITCH_STARTED &&
+	    event != EVENT_LINK_CH_SWITCH_STARTED)
 		return;
 
 	val = wpa_ucode_registry_get(iface_registry, wpa_s->ucode.idx);
@@ -146,12 +150,54 @@ void wpas_ucode_event(struct wpa_supplicant *wpa_s, int event, union wpa_event_d
 	val = ucv_object_new(vm);
 	uc_value_push(ucv_get(val));
 
-	if (event == EVENT_CH_SWITCH_STARTED) {
+	if (event == EVENT_CH_SWITCH_STARTED ||
+	    event == EVENT_LINK_CH_SWITCH_STARTED) {
+		if (wpa_s->wpa_state < WPA_COMPLETED) {
+			wpa_printf(MSG_INFO,
+				   "ucode: mtk: receive channel switch event"
+				   "before association finished, reconnect\n");
+			wpa_supplicant_reconnect(wpa_s);
+			return;
+		}
+
+		control_freq = data->ch_switch.freq;
+		center_freq1 = data->ch_switch.cf1;
+
+		switch (data->ch_switch.ch_width) {
+		case CHAN_WIDTH_80:
+			oper_chwidth = CONF_OPER_CHWIDTH_80MHZ;
+			break;
+		case CHAN_WIDTH_80P80:
+			oper_chwidth = CONF_OPER_CHWIDTH_80P80MHZ;
+			break;
+		case CHAN_WIDTH_160:
+			oper_chwidth = CONF_OPER_CHWIDTH_160MHZ;
+			break;
+		case CHAN_WIDTH_320:
+			oper_chwidth = CONF_OPER_CHWIDTH_320MHZ;
+			break;
+		case CHAN_WIDTH_20_NOHT:
+		case CHAN_WIDTH_20:
+		case CHAN_WIDTH_40:
+		default:
+			oper_chwidth = CONF_OPER_CHWIDTH_USE_HT;
+			break;
+		}
+
+		/* Check bandwidth 320 MHz-2 */
+		if (oper_chwidth == CONF_OPER_CHWIDTH_320MHZ &&
+		    (center_freq1 == 6265) || center_freq1 == 6585 ||
+		     center_freq1 == 6905)
+			bw320_offset = 2;
+
 		ucv_object_add(val, "csa_count", ucv_int64_new(data->ch_switch.count));
 		ucv_object_add(val, "frequency", ucv_int64_new(data->ch_switch.freq));
 		ucv_object_add(val, "sec_chan_offset", ucv_int64_new(data->ch_switch.ch_offset));
-		ucv_object_add(val, "center_freq1", ucv_int64_new(data->ch_switch.cf1));
+		ucv_object_add(val, "center_freq1", ucv_int64_new(center_freq1));
 		ucv_object_add(val, "center_freq2", ucv_int64_new(data->ch_switch.cf2));
+		ucv_object_add(val, "oper_chwidth", ucv_int64_new(oper_chwidth));
+		ucv_object_add(val, "bw320_offset", ucv_int64_new(bw320_offset));
+		ucv_object_add(val, "punct_bitmap", ucv_int64_new(data->ch_switch.punct_bitmap));
 	}
 
 	ucv_put(wpa_ucode_call(4));
@@ -357,6 +403,61 @@ uc_wpas_iface_status_multi_ap(uc_vm_t *vm, uc_value_t *ret, struct wpa_supplican
 	ucv_object_add(obj, "vlanid", ucv_int64_new(multi_ap->vlanid));
 }
 
+static void
+uc_wpas_iface_status_channel_info(struct wpa_supplicant *wpa_s,
+				  uc_value_t *ret, int link_id)
+{
+	enum oper_chan_width oper_chwidth;
+	enum chan_width width;
+	int center_freq1, bw320_offset = 1;
+	u16 punct_bitmap;
+	u32 freq;
+
+	if (link_id >= 0) {
+		freq = wpa_s->links[link_id].freq;
+		center_freq1 = wpa_s->links[link_id].center_freq1;
+		width = wpa_s->links[link_id].width;
+		punct_bitmap = wpa_s->links[link_id].punct_bitmap;
+	} else {
+		struct wpa_channel_info ci;
+
+		wpa_drv_channel_info(wpa_s, &ci);
+		freq = ci.frequency;
+		center_freq1 = ci.center_frq1;
+		width = ci.chanwidth;
+		punct_bitmap = ci.punct_bitmap;
+	}
+
+	switch (width) {
+	case CHAN_WIDTH_80:
+		oper_chwidth = CONF_OPER_CHWIDTH_80MHZ;
+		break;
+	case CHAN_WIDTH_80P80:
+		oper_chwidth = CONF_OPER_CHWIDTH_80P80MHZ;
+		break;
+	case CHAN_WIDTH_160:
+		oper_chwidth = CONF_OPER_CHWIDTH_160MHZ;
+		break;
+	case CHAN_WIDTH_320:
+		oper_chwidth = CONF_OPER_CHWIDTH_320MHZ;
+
+		if (center_freq1 == 6265 || center_freq1 == 6585 ||
+		    center_freq1 == 6905)
+			bw320_offset = 2;
+		break;
+	case CHAN_WIDTH_20_NOHT:
+	case CHAN_WIDTH_20:
+	case CHAN_WIDTH_40:
+	default:
+		oper_chwidth = CONF_OPER_CHWIDTH_USE_HT;
+		break;
+	}
+
+	ucv_object_add(ret, "oper_chwidth", ucv_int64_new(oper_chwidth));
+	ucv_object_add(ret, "bw320_offset", ucv_int64_new(bw320_offset));
+	ucv_object_add(ret, "punct_bitmap", ucv_int64_new(punct_bitmap));
+}
+
 static uc_value_t *
 uc_wpas_iface_status(uc_vm_t *vm, size_t nargs)
 {
@@ -372,8 +473,10 @@ uc_wpas_iface_status(uc_vm_t *vm, size_t nargs)
 	ucv_object_add(ret, "state", ucv_string_new(wpa_supplicant_state_txt(wpa_s->wpa_state)));
 
 	bss = wpa_s->current_bss;
-	if (bss)
+	if (bss) {
 		uc_wpas_iface_status_bss(ret, bss);
+		uc_wpas_iface_status_channel_info(wpa_s, ret, -1);
+	}
 
 	if (wpa_s->valid_links) {
 		unsigned int valid_links = wpa_s->valid_links;
@@ -391,6 +494,7 @@ uc_wpas_iface_status(uc_vm_t *vm, size_t nargs)
 
 			link = ucv_object_new(vm);
 			uc_wpas_iface_status_bss(link, bss);
+			uc_wpas_iface_status_channel_info(wpa_s, link, i);
 			ucv_array_set(links, i, link);
 		}
 
-- 
2.45.2

