From ec0251bf374802ce89cb4320db23040c320e9d9a Mon Sep 17 00:00:00 2001
From: Mason Chang <mason-cw.chang@mediatek.com>
Date: Fri, 12 Dec 2025 10:23:58 +0800
Subject: [PATCH] net: ethernet: mtk_eth_soc: add dynamic rx buffer adjustment
 support

---
 drivers/net/ethernet/mediatek/mtk_eth_soc.c | 66 ++++++++++++++-------
 drivers/net/ethernet/mediatek/mtk_eth_soc.h |  3 +-
 2 files changed, 47 insertions(+), 22 deletions(-)

--- a/drivers/net/ethernet/mediatek/mtk_eth_soc.c
+++ b/drivers/net/ethernet/mediatek/mtk_eth_soc.c
@@ -816,7 +816,7 @@ static void mtk_mac_config(struct phylin
 
 	mac->mode = mode;
 	mac->interface = state->interface;
-	mtk_set_mcr_max_rx(mac, MTK_MAX_RX_LENGTH);
+	mtk_set_mcr_max_rx(mac, eth->rx_buf_len);
 
 	return;
 
@@ -934,6 +934,17 @@ void mtk_shaper_update_refcnt(struct mtk
 		atomic_dec(&eth->qdma_shaper.refcnt[idx]);
 }
 
+static void mtk_set_max_mtu(struct mtk_mac *mac)
+{
+	struct mtk_eth *eth = mac->hw;
+
+	if (MTK_HAS_CAPS(eth->soc->caps, MTK_NETSYS_RX_9K) &&
+	    mtk_interface_mode_is_xgmii(mac->interface))
+		eth->netdev[mac->id]->max_mtu = MTK_MAX_RX_LENGTH_9K - MTK_RX_ETH_HLEN;
+	else
+		eth->netdev[mac->id]->max_mtu = MTK_MAX_RX_LENGTH_2K - MTK_RX_ETH_HLEN;
+}
+
 static void mtk_set_queue_speed(struct mtk_eth *eth, unsigned int idx,
 				int speed)
 {
@@ -1494,22 +1505,22 @@ static void mtk_get_stats64(struct net_d
 	storage->tx_dropped = dev->stats.tx_dropped;
 }
 
-static inline int mtk_max_frag_size(int mtu)
+static inline int mtk_max_frag_size(struct mtk_eth *eth, int mtu)
 {
-	/* make sure buf_size will be at least MTK_MAX_RX_LENGTH */
-	if (mtu + MTK_RX_ETH_HLEN < MTK_MAX_RX_LENGTH)
-		mtu = MTK_MAX_RX_LENGTH - MTK_RX_ETH_HLEN;
+	/* make sure buf_size will be at least max rx buffer length */
+	if (mtu + MTK_RX_ETH_HLEN < eth->rx_buf_len)
+		mtu = eth->rx_buf_len - MTK_RX_ETH_HLEN;
 
 	return SKB_DATA_ALIGN(MTK_RX_HLEN + mtu) +
 		SKB_DATA_ALIGN(sizeof(struct skb_shared_info));
 }
 
-static inline int mtk_max_buf_size(int frag_size)
+static inline int mtk_max_buf_size(struct mtk_eth *eth, int frag_size)
 {
 	int buf_size = frag_size - NET_SKB_PAD - NET_IP_ALIGN -
 		       SKB_DATA_ALIGN(sizeof(struct skb_shared_info));
 
-	WARN_ON(buf_size < MTK_MAX_RX_LENGTH);
+	WARN_ON(buf_size < eth->rx_buf_len);
 
 	return buf_size;
 }
@@ -3099,8 +3110,8 @@ static int mtk_rx_alloc(struct mtk_eth *
 		rx_dma_size = soc->rx.dma_size;
 	}
 
-	ring->frag_size = mtk_max_frag_size(rx_data_len);
-	ring->buf_size = mtk_max_buf_size(ring->frag_size);
+	ring->frag_size = mtk_max_frag_size(eth, rx_data_len);
+	ring->buf_size = mtk_max_buf_size(eth, ring->frag_size);
 	ring->data = kcalloc(rx_dma_size, sizeof(*ring->data),
 			     GFP_KERNEL);
 	if (!ring->data)
@@ -3375,7 +3386,7 @@ static int mtk_hwlro_rx_init(struct mtk_
 
 	if (mtk_is_netsys_v3_or_greater(eth)) {
 		val = mtk_r32(eth, reg_map->pdma.rx_cfg);
-		mtk_w32(eth, val | ((MTK_PDMA_LRO_SDL + MTK_MAX_RX_LENGTH) <<
+		mtk_w32(eth, val | ((MTK_PDMA_LRO_SDL + eth->rx_buf_len) <<
 			MTK_RX_CFG_SDL_OFFSET), reg_map->pdma.rx_cfg);
 
 		lro_ctrl_dw0 |= MTK_PDMA_LRO_SDL << MTK_CTRL_DW0_SDL_OFFSET;
@@ -4371,14 +4382,7 @@ static int mtk_open(struct net_device *d
 	}
 	netif_tx_start_all_queues(dev);
 
-	if (MTK_HAS_CAPS(eth->soc->caps, MTK_NETSYS_RX_9K) &&
-	    MTK_MAX_RX_LENGTH >= MTK_MAX_RX_LENGTH_9K &&
-	    mtk_interface_mode_is_xgmii(mac->interface))
-		eth->netdev[mac->id]->max_mtu = MTK_MAX_RX_LENGTH_9K - MTK_RX_ETH_HLEN;
-	else if (MTK_MAX_RX_LENGTH >= MTK_MAX_RX_LENGTH_2K)
-		eth->netdev[mac->id]->max_mtu = MTK_MAX_RX_LENGTH_2K - MTK_RX_ETH_HLEN;
-	else
-		eth->netdev[mac->id]->max_mtu = MTK_MAX_RX_LENGTH - MTK_RX_ETH_HLEN;
+	mtk_set_max_mtu(mac);
 
 	if (mtk_is_netsys_v2_or_greater(eth))
 		return 0;
@@ -5347,9 +5351,21 @@ static void mtk_uninit(struct net_device
 
 static int mtk_change_mtu(struct net_device *dev, int new_mtu)
 {
-	int length = new_mtu + MTK_RX_ETH_HLEN;
 	struct mtk_mac *mac = netdev_priv(dev);
 	struct mtk_eth *eth = mac->hw;
+	int length, i, max_mtu = 0;
+
+	dev->mtu = new_mtu;
+
+	for (i = 0; i < MTK_MAX_DEVS; i++) {
+		if (!eth->netdev[i])
+			continue;
+
+		if (eth->netdev[i]->mtu > max_mtu)
+			max_mtu = eth->netdev[i]->mtu;
+	}
+
+	length = max_mtu + MTK_RX_ETH_HLEN;
 
 	if (rcu_access_pointer(eth->prog) &&
 	    length > MTK_PP_MAX_BUF_SIZE) {
@@ -5357,8 +5373,12 @@ static int mtk_change_mtu(struct net_dev
 		return -EINVAL;
 	}
 
-	mtk_set_mcr_max_rx(mac, length);
-	dev->mtu = new_mtu;
+	if (length <= MTK_MAX_RX_LENGTH)
+		eth->rx_buf_len = MTK_MAX_RX_LENGTH;
+	else if (length <= MTK_MAX_RX_LENGTH_2K)
+		eth->rx_buf_len = MTK_MAX_RX_LENGTH_2K;
+	else if (length <= MTK_MAX_RX_LENGTH_9K)
+		eth->rx_buf_len = MTK_MAX_RX_LENGTH_9K;
 
 	return 0;
 }
@@ -6455,6 +6475,8 @@ static int mtk_add_mac(struct mtk_eth *e
 	eth->netdev[id]->irq = eth->irq_fe[0];
 	eth->netdev[id]->dev.of_node = np;
 
+	mtk_set_max_mtu(mac);
+
 	if (MTK_HAS_CAPS(eth->soc->caps, MTK_QDMA)) {
 		mac->device_notifier.notifier_call = mtk_device_event;
 		register_netdevice_notifier(&mac->device_notifier);
@@ -6951,6 +6973,8 @@ static int mtk_probe(struct platform_dev
 				   eth->netdev[i]->base_addr, eth->irq_fe[0]);
 	}
 
+	eth->rx_buf_len = MTK_MAX_RX_LENGTH;
+
 	platform_set_drvdata(pdev, eth);
 	schedule_delayed_work(&eth->reset.monitor_work,
 			      MTK_DMA_MONITOR_TIMEOUT);
--- a/drivers/net/ethernet/mediatek/mtk_eth_soc.h
+++ b/drivers/net/ethernet/mediatek/mtk_eth_soc.h
@@ -72,7 +72,7 @@
 				 (((ring_no) > 3) && ((ring_no) < 8)) :		\
 				 (((ring_no) > 0) && ((ring_no) < 4)))
 
-#define	MTK_MAX_LRO_RX_LENGTH		(4096 * 3 + MTK_MAX_RX_LENGTH)
+#define	MTK_MAX_LRO_RX_LENGTH		(4096 * 3 + eth->rx_buf_len)
 #define	MTK_MAX_LRO_IP_CNT		2
 #define	MTK_HW_LRO_TIMER_UNIT		1	/* 20 us */
 #define	MTK_HW_LRO_REFRESH_TIME		50000	/* 1 sec. */
@@ -1696,6 +1696,7 @@ struct mtk_eth {
 
 	spinlock_t			dim_lock;
 
+	u32				rx_buf_len;
 	u32				rx_events;
 	u32				rx_packets;
 	u32				rx_bytes;
