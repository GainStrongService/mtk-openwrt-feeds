From e32bd2c7df6226d509d14551119ac7fffd1b6d0d Mon Sep 17 00:00:00 2001
From: StanleyYP Wang <StanleyYP.Wang@mediatek.com>
Date: Mon, 20 Feb 2023 14:25:24 +0800
Subject: [PATCH 20/87] mtk: mac80211: add sta-assisted DFS state update
 mechanism

Signed-off-by: StanleyYP Wang <StanleyYP.Wang@mediatek.com>

Add cfg80211_any_wiphy_oper_chan check before clearing dfs state.
This avoids STA clearing the dfs state of the channel, which still has
APs/offchain operating on the it.

Signed-off-by: StanleyYP Wang <StanleyYP.Wang@mediatek.com>
---
 include/net/cfg80211.h       | 14 +++++++
 include/uapi/linux/nl80211.h |  6 +++
 net/mac80211/mlme.c          | 14 +++++++
 net/wireless/chan.c          | 72 ++++++++++++++++++++++++++++++++++++
 4 files changed, 106 insertions(+)

diff --git a/include/net/cfg80211.h b/include/net/cfg80211.h
index 5963ad82..cad6c36f 100644
--- a/include/net/cfg80211.h
+++ b/include/net/cfg80211.h
@@ -8785,6 +8785,20 @@ void cfg80211_cac_event(struct net_device *netdev,
 			enum nl80211_radar_event event, gfp_t gfp,
 			unsigned int link_id);
 
+/**
+ * cfg80211_sta_update_dfs_state - Update channel's DFS state during STA channel switch,
+ *				   association, and disassociation
+ * @wdev: the wireless device
+ * @bss_chandef: the current BSS channel definition
+ * @csa_chandef: the CSA channel definition
+ * @associated: whether STA is during association or disassociation process
+ *
+ */
+void cfg80211_sta_update_dfs_state(struct wireless_dev *wdev,
+				   const struct cfg80211_chan_def *bss_chandef,
+				   const struct cfg80211_chan_def *csa_chandef,
+				   bool associated);
+
 /**
  * cfg80211_background_cac_abort - Channel Availability Check offchan abort event
  * @wiphy: the wiphy
diff --git a/include/uapi/linux/nl80211.h b/include/uapi/linux/nl80211.h
index 6d114375..77b30e2e 100644
--- a/include/uapi/linux/nl80211.h
+++ b/include/uapi/linux/nl80211.h
@@ -6850,6 +6850,10 @@ enum nl80211_smps_mode {
  *	applicable for ETSI dfs domain where pre-CAC is valid for ever.
  * @NL80211_RADAR_CAC_STARTED: Channel Availability Check has been started,
  *	should be generated by HW if NL80211_EXT_FEATURE_DFS_OFFLOAD is enabled.
+ * @NL80211_RADAR_STA_CAC_SKIPPED: STA set the DFS state to available
+ *	when receiving CSA/assoc resp
+ * @NL80211_RADAR_STA_CAC_EXPIRED: STA set the DFS state to usable
+ *	when STA is disconnected or leaving the channel
  */
 enum nl80211_radar_event {
 	NL80211_RADAR_DETECTED,
@@ -6858,6 +6862,8 @@ enum nl80211_radar_event {
 	NL80211_RADAR_NOP_FINISHED,
 	NL80211_RADAR_PRE_CAC_EXPIRED,
 	NL80211_RADAR_CAC_STARTED,
+	NL80211_RADAR_STA_CAC_SKIPPED,
+	NL80211_RADAR_STA_CAC_EXPIRED,
 };
 
 /**
diff --git a/net/mac80211/mlme.c b/net/mac80211/mlme.c
index 09e2ec32..f9786b7a 100644
--- a/net/mac80211/mlme.c
+++ b/net/mac80211/mlme.c
@@ -2601,6 +2601,11 @@ ieee80211_sta_process_chanswitch(struct ieee80211_link_data *link,
 	if (csa_ie.mode)
 		ieee80211_vif_block_queues_csa(sdata);
 
+	cfg80211_sta_update_dfs_state(&sdata->wdev,
+				      &link->conf->chanreq.oper,
+				      &link->csa_chanreq.oper,
+				      sdata->vif.cfg.assoc);
+
 	cfg80211_ch_switch_started_notify(sdata->dev, &csa_ie.chanreq.oper,
 					  link->link_id, csa_ie.count,
 					  csa_ie.mode);
@@ -3748,6 +3753,10 @@ static void ieee80211_set_disassoc(struct ieee80211_sub_if_data *sdata,
 		link = sdata_dereference(sdata->link[link_id], sdata);
 		if (!link)
 			continue;
+
+		cfg80211_sta_update_dfs_state(&sdata->wdev,
+					      &link->conf->chanreq.oper,
+					      NULL, sdata->vif.cfg.assoc);
 		ieee80211_link_release_channel(link);
 	}
 
@@ -6027,6 +6036,11 @@ static void ieee80211_rx_mgmt_assoc_resp(struct ieee80211_sub_if_data *sdata,
 		for (ac = 0; ac < IEEE80211_NUM_ACS; ac++)
 			if (link->tx_conf[ac].uapsd)
 				resp.uapsd_queues |= ieee80211_ac_to_qos_mask[ac];
+
+		if (status_code == WLAN_STATUS_SUCCESS)
+			cfg80211_sta_update_dfs_state(&sdata->wdev,
+						      &link->conf->chanreq.oper,
+						      NULL, sdata->vif.cfg.assoc);
 	}
 
 	if (ieee80211_vif_is_mld(&sdata->vif)) {
diff --git a/net/wireless/chan.c b/net/wireless/chan.c
index fca582a0..f8dffd64 100644
--- a/net/wireless/chan.c
+++ b/net/wireless/chan.c
@@ -14,6 +14,7 @@
 #include <net/cfg80211.h>
 #include "core.h"
 #include "rdev-ops.h"
+#include "nl80211.h"
 
 static bool cfg80211_valid_60g_freq(u32 freq)
 {
@@ -1722,6 +1723,77 @@ bool cfg80211_any_usable_channels(struct wiphy *wiphy,
 }
 EXPORT_SYMBOL(cfg80211_any_usable_channels);
 
+static void cfg80211_sta_radar_notify(struct wiphy *wiphy,
+				      const struct cfg80211_chan_def *chandef,
+				      enum nl80211_radar_event event)
+{
+	struct wireless_dev *wdev;
+
+	list_for_each_entry(wdev, &wiphy->wdev_list, list) {
+		if (cfg80211_chandef_dfs_required(wiphy, chandef, wdev->iftype) > 0) {
+			nl80211_radar_notify(wiphy_to_rdev(wiphy), chandef,
+					     event, wdev->netdev, GFP_KERNEL);
+			return;
+		}
+	}
+}
+
+void cfg80211_sta_update_dfs_state(struct wireless_dev *wdev,
+				   const struct cfg80211_chan_def *bss_chandef,
+				   const struct cfg80211_chan_def *csa_chandef,
+				   bool associated)
+{
+	bool csa_active = !!csa_chandef;
+	enum nl80211_dfs_state dfs_state = NL80211_DFS_USABLE;
+	enum nl80211_radar_event event = NL80211_RADAR_STA_CAC_EXPIRED;
+
+	lockdep_assert_wiphy(wdev->wiphy);
+
+	if (!bss_chandef || !bss_chandef->chan ||
+	    bss_chandef->chan->band != NL80211_BAND_5GHZ)
+		return;
+
+	/* assume csa channel is cac completed */
+	if (csa_active &&
+	    (cfg80211_chandef_dfs_usable(wdev->wiphy, csa_chandef) ||
+	    cfg80211_chandef_dfs_available(wdev->wiphy, csa_chandef))) {
+		cfg80211_set_dfs_state(wdev->wiphy, csa_chandef, NL80211_DFS_AVAILABLE);
+		cfg80211_sta_radar_notify(wdev->wiphy, csa_chandef,
+					  NL80211_RADAR_STA_CAC_SKIPPED);
+		netdev_info(wdev->netdev, "Set CSA channel's DFS state to available\n");
+	}
+
+	/* avoid updating the dfs state during nop */
+	if (!cfg80211_chandef_dfs_usable(wdev->wiphy, bss_chandef) &&
+	    !cfg80211_chandef_dfs_available(wdev->wiphy, bss_chandef))
+		return;
+
+	if (associated && !csa_active) {
+		dfs_state = NL80211_DFS_AVAILABLE;
+		event = NL80211_RADAR_STA_CAC_SKIPPED;
+	}
+
+	/* avoid setting the dfs state to usable
+	 * when other interfaces still operate on this channel
+	 */
+	if (dfs_state == NL80211_DFS_USABLE &&
+	    (cfg80211_is_wiphy_oper_chan(wdev->wiphy, bss_chandef->chan) ||
+	     cfg80211_offchan_chain_is_active(wiphy_to_rdev(wdev->wiphy),
+					      bss_chandef->chan)))
+		return;
+
+	cfg80211_set_dfs_state(wdev->wiphy, bss_chandef, dfs_state);
+	cfg80211_sta_radar_notify(wdev->wiphy, bss_chandef, event);
+
+	if (csa_active)
+		netdev_info(wdev->netdev, "Set origin channel's DFS state to usable\n");
+	else
+		netdev_info(wdev->netdev, "Set BSS channel's DFS state to %s due to %s\n",
+			    (dfs_state == NL80211_DFS_USABLE) ? "usable" : "available",
+			    associated ? "association" : "disassociation");
+}
+EXPORT_SYMBOL(cfg80211_sta_update_dfs_state);
+
 struct cfg80211_chan_def *wdev_chandef(struct wireless_dev *wdev,
 				       unsigned int link_id)
 {
-- 
2.45.2

