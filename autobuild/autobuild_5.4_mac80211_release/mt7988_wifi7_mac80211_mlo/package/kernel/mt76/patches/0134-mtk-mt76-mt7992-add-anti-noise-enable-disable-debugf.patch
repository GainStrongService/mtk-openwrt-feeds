From e43c8b8db3f916d5e5fe5b7e769d282a6bf4d74e Mon Sep 17 00:00:00 2001
From: Howard Hsu <howard-yh.hsu@mediatek.com>
Date: Thu, 29 Aug 2024 10:07:07 +0800
Subject: [PATCH 134/146] mtk: mt76: mt7992: add anti-noise enable/disable
 debugfs

Add some debugfs to enable/disable MTK proprietary feature, anti-noise.
This feature is designed to integrate Spatial Reuse, Preanble Puncture,
Universal BW adaption and MRU Probe feature, aiming to mitigate noise
from CCI and ACI. Please noted that anti-noise feature only support on
mt7992.

1. sr_pp_enable: whether apply Preamble Puncture on Spatial Reuse Tx or not.
Value:
1: enable (Default), 0: disable

2. uba_enable: Universal Bw adaption help adjust Tx Bandwidth to smaller
BW. This feature increse performance when interference only affect
station.
Value:
1: enable (Default), 0: disable

3. mru_probe_enable: MRU Probe feature will adjsut Tx bandwidth from MRU
to Full-Bw. This feature increases performance gain when interference
only affect ap side. Please noted that the mcu command to disable mru
probe is same as enable pp as fw mode. So if user wants to disable mru
probe, it shall set pp fw mode by $hostapd_cli set_pp mode 1 rather than
echo 0 to this debugfs.
Value:
1: enable (Default is disable)

Signed-off-by: Howard Hsu <howard-yh.hsu@mediatek.com>

---
 mt7996/mcu.c           |   6 +++
 mt7996/mcu.h           |   1 +
 mt7996/mt7996.h        |   6 +++
 mt7996/mtk_debugfs_i.c | 105 +++++++++++++++++++++++++++++++++++++++++
 mt7996/mtk_mcu.c       |  84 +++++++++++++++++++++++++++++++++
 5 files changed, 202 insertions(+)

diff --git a/mt7996/mcu.c b/mt7996/mcu.c
index 49ac9454..fbdc12b3 100644
--- a/mt7996/mcu.c
+++ b/mt7996/mcu.c
@@ -7596,6 +7596,12 @@ int mt7996_mcu_set_pp_en(struct mt7996_phy *phy, u8 mode, u16 bitmap)
 	phy->punct_bitmap = bitmap;
 	phy->pp_mode = mode;
 
+#ifdef CONFIG_MTK_DEBUG
+	/* Configuring PP would cause FW to disable MRU Probe by default. */
+	if (is_mt7992(&dev->mt76))
+		phy->mru_probe_enable = false;
+#endif
+
 	return mt76_mcu_send_msg(&dev->mt76, MCU_WM_UNI_CMD(PP),
 				 &req, sizeof(req), false);
 }
diff --git a/mt7996/mcu.h b/mt7996/mcu.h
index 368141b0..68dbcb43 100644
--- a/mt7996/mcu.h
+++ b/mt7996/mcu.h
@@ -1586,6 +1586,7 @@ enum {
 	UNI_CMD_PP_EN_CTRL,
 	UNI_CMD_PP_ALG_CTRL,
 	UNI_CMD_PP_DSCB_CTRL,
+	UNI_CMD_PP_CHANGE_CAP_CTRL = 4,
 };
 
 enum pp_mode {
diff --git a/mt7996/mt7996.h b/mt7996/mt7996.h
index 92d49727..9be36aeb 100644
--- a/mt7996/mt7996.h
+++ b/mt7996/mt7996.h
@@ -783,6 +783,7 @@ struct mt7996_phy {
 	bool sr_enable:1;
 	bool enhanced_sr_enable:1;
 	bool thermal_protection_enable:1;
+	bool mru_probe_enable:1;
 #endif
 };
 
@@ -946,6 +947,8 @@ struct mt7996_dev {
 		u32 fid_idx;
 	} dbg;
 	const struct mt7996_dbg_reg_desc *dbg_reg;
+	bool sr_pp_enable:1;
+	bool uba_enable:1;
 #endif
 #ifdef CONFIG_MTK_VENDOR
 	u8 cert_mode;
@@ -1572,6 +1575,9 @@ void mt7996_dump_bmac_txd_info(struct seq_file *s, struct mt7996_dev *dev,
 int mt7996_mtk_init_dev_debugfs_internal(struct mt7996_phy *phy, struct dentry *dir);
 int mt7996_mtk_init_band_debugfs_internal(struct mt7996_phy *phy, struct dentry *dir);
 int mt7996_mcu_mlo_agc(struct mt7996_dev *dev, const void *data, int len);
+int mt7996_mcu_set_sr_pp_en(struct mt7996_dev *dev, u8 enable);
+int mt7996_mcu_set_uba_en(struct mt7996_dev *dev, u8 enable);
+int mt7996_mcu_set_mru_probe_en(struct mt7996_phy *phy);
 #endif
 
 #ifdef CONFIG_NET_MEDIATEK_SOC_WED
diff --git a/mt7996/mtk_debugfs_i.c b/mt7996/mtk_debugfs_i.c
index c9224eee..d9e1ce8f 100644
--- a/mt7996/mtk_debugfs_i.c
+++ b/mt7996/mtk_debugfs_i.c
@@ -977,6 +977,102 @@ static const struct file_operations fops_mlo_agc_trig = {
 	.llseek = default_llseek,
 };
 
+static int
+mt7996_sr_pp_enable_get(void *data, u64 *val)
+{
+	struct mt7996_dev *dev = data;
+
+	*val = dev->sr_pp_enable;
+
+	return 0;
+}
+static int
+mt7996_sr_pp_enable_set(void *data, u64 val)
+{
+	struct mt7996_dev *dev = data;
+	int ret;
+	bool en = !!val;
+
+	if (en == dev->sr_pp_enable)
+		return 0;
+
+	ret = mt7996_mcu_set_sr_pp_en(dev, en);
+	if (ret)
+		return ret;
+
+	dev->sr_pp_enable = en;
+
+	return 0;
+}
+DEFINE_DEBUGFS_ATTRIBUTE(fops_sr_pp_enable, mt7996_sr_pp_enable_get,
+			 mt7996_sr_pp_enable_set, "%lld\n");
+
+static int
+mt7996_uba_enable_get(void *data, u64 *val)
+{
+	struct mt7996_dev *dev = data;
+
+	*val = dev->uba_enable;
+
+	return 0;
+}
+static int
+mt7996_uba_enable_set(void *data, u64 val)
+{
+	struct mt7996_dev *dev = data;
+	int ret;
+	bool en = !!val;
+
+	if (en == dev->uba_enable)
+		return 0;
+
+	ret = mt7996_mcu_set_uba_en(dev, en);
+	if (ret)
+		return ret;
+
+	dev->uba_enable = en;
+
+	return 0;
+}
+DEFINE_DEBUGFS_ATTRIBUTE(fops_uba_enable, mt7996_uba_enable_get,
+			 mt7996_uba_enable_set, "%lld\n");
+
+static int
+mt7996_mru_probe_enable_get(void *data, u64 *val)
+{
+	struct mt7996_phy *phy = data;
+
+	*val = phy->mru_probe_enable;
+
+	return 0;
+}
+static int
+mt7996_mru_probe_enable_set(void *data, u64 val)
+{
+#define MRU_PROBE_ENABLE 1
+	struct mt7996_phy *phy = data;
+	int ret;
+	bool en = !!val;
+
+	if (en == phy->mru_probe_enable)
+		return 0;
+
+	if (en != MRU_PROBE_ENABLE)
+		return 0;
+
+	ret = mt7996_mcu_set_mru_probe_en(phy);
+	if (ret)
+		return ret;
+
+	phy->mru_probe_enable = en;
+	/* When enabling MRU probe, PP would also enter FW mode */
+	phy->pp_mode = PP_FW_MODE;
+
+	return 0;
+}
+DEFINE_DEBUGFS_ATTRIBUTE(fops_mru_probe_enable, mt7996_mru_probe_enable_get,
+			 mt7996_mru_probe_enable_set, "%lld\n");
+
 int mt7996_mtk_init_dev_debugfs_internal(struct mt7996_phy *phy, struct dentry *dir)
 {
 	struct mt7996_dev *dev = phy->dev;
@@ -1003,6 +1099,11 @@ int mt7996_mtk_init_dev_debugfs_internal(struct mt7996_phy *phy, struct dentry *
 	debugfs_create_file("mlo_agc_tx", 0200, dir, dev, &fops_mlo_agc_tx);
 	debugfs_create_file("mlo_agc_trig", 0200, dir, dev, &fops_mlo_agc_trig);
 
+	if (is_mt7992(&dev->mt76)) {
+		debugfs_create_file("sr_pp_enable", 0600, dir, dev,
+				    &fops_sr_pp_enable);
+		debugfs_create_file("uba_enable", 0600, dir, dev, &fops_uba_enable);
+	}
 	return 0;
 }
 
@@ -1012,6 +1113,10 @@ int mt7996_mtk_init_band_debugfs_internal(struct mt7996_phy *phy, struct dentry
 	debugfs_create_file("rmac_table", 0400, dir, phy, &mt7996_rmac_table_fops);
 	debugfs_create_file("agg_table", 0400, dir, phy, &mt7996_agg_table_fops);
 
+	if (is_mt7992(&phy->dev->mt76))
+		debugfs_create_file("mru_probe_enable", 0600, dir, phy,
+				    &fops_mru_probe_enable);
+
 	return 0;
 }
 #endif
diff --git a/mt7996/mtk_mcu.c b/mt7996/mtk_mcu.c
index ff4af090..4dcbdd7f 100644
--- a/mt7996/mtk_mcu.c
+++ b/mt7996/mtk_mcu.c
@@ -1477,4 +1477,88 @@ int mt7996_mcu_set_muru_qos_cfg(struct mt7996_dev *dev, u16 wlan_idx, u8 dir,
 	return mt76_mcu_send_msg(&dev->mt76, MCU_WMWA_UNI_CMD(MURU), &req,
 				 sizeof(req), true);
 }
+
+int mt7996_mcu_set_sr_pp_en(struct mt7996_dev *dev, u8 enable)
+{
+#define SR_PP_MODE 5
+	struct {
+		u8 _rsv1[4];
+
+		__le16 tag;
+		__le16 len;
+
+		__le32 category;
+		__le32 enable;
+		u8 _rsv2[4];
+	} __packed req = {
+		.tag = cpu_to_le16(UNI_CMD_PP_CHANGE_CAP_CTRL),
+		.len = cpu_to_le16(sizeof(req) - 4),
+		.category = cpu_to_le32(SR_PP_MODE),
+		.enable = cpu_to_le32(enable),
+	};
+
+	if (!is_mt7992(&dev->mt76))
+		return -EINVAL;
+
+	return mt76_mcu_send_msg(&dev->mt76, MCU_WM_UNI_CMD(PP),
+				 &req, sizeof(req), false);
+}
+
+int mt7996_mcu_set_uba_en(struct mt7996_dev *dev, u8 enable)
+{
+#define UNI_CMD_RA_OPTION_CTRL 4
+#define UBA_TYPE 3
+	struct {
+		u8 _rsv1[4];
+
+		__le16 tag;
+		__le16 len;
+
+		u8 option_type;
+		u8 val;
+		u8 _rsv2[4];
+	} __packed req = {
+		.tag = cpu_to_le16(UNI_CMD_RA_OPTION_CTRL),
+		.len = cpu_to_le16(sizeof(req) - 4),
+		.option_type = UBA_TYPE,
+		.val = enable,
+	};
+
+	if (!is_mt7992(&dev->mt76))
+		return -EINVAL;
+
+	return mt76_mcu_send_msg(&dev->mt76, MCU_WM_UNI_CMD(RA),
+				 &req, sizeof(req), false);
+}
+
+int mt7996_mcu_set_mru_probe_en(struct mt7996_phy *phy)
+{
+#define MRU_PROBE_MODE 2
+	struct mt7996_dev *dev = phy->dev;
+	struct {
+		u8 _rsv1[4];
+
+		__le16 tag;
+		__le16 len;
+
+		u8 mgmt_mode;
+		u8 band_idx;
+		u8 force_bitmap_ctrl;
+		u8 auto_mode;
+		__le16 bitmap;
+		u8 csa_enable;
+		u8 _rsv2;
+	} __packed req = {
+		.tag = cpu_to_le16(UNI_CMD_PP_EN_CTRL),
+		.len = cpu_to_le16(sizeof(req) - 4),
+		.auto_mode = MRU_PROBE_MODE,
+		.band_idx = phy->mt76->band_idx,
+	};
+
+	if (!is_mt7992(&dev->mt76))
+		return -EINVAL;
+
+	return mt76_mcu_send_msg(&dev->mt76, MCU_WM_UNI_CMD(PP),
+				 &req, sizeof(req), false);
+}
 #endif
-- 
2.45.2

