From 093ac6b9d2f9c79b137f327af1eb0236ba71064a Mon Sep 17 00:00:00 2001
From: MeiChia Chiu <MeiChia.Chiu@mediatek.com>
Date: Thu, 9 May 2024 15:41:18 +0800
Subject: [PATCH 086/126] mtk: hostapd: add support for emlsr

1. Processing the EML capability IE in the association request,
and sending the value of EML field to the kernel.

2. Processing the EML Operating Mode Notification frame,
and sending the EML Operating Mode Notification frame if eml_resp is
true.

Command Usage:
eml_resp -
hostapd_cli -i <interface> eml_resp <enable>

Processing the EML capability IE in the association request,
and sending the value of EML field to the kernel.

The original flow send the mcu command to the firmware using the WCID of
the primary link. Therefore, a  is passed in the hostapd layer
to ensure that the EML OMN is processed and sent to the firmware using
the WCID of the receiving link.

Signed-off-by: MeiChia Chiu <MeiChia.Chiu@mediatek.com>
---
 hostapd/config_file.c             |   4 +
 hostapd/ctrl_iface.c              |  36 +++++++++
 hostapd/hostapd.conf              |  10 +++
 hostapd/hostapd_cli.c             |   8 ++
 src/ap/ap_config.h                |   2 +
 src/ap/ap_drv_ops.c               |  20 ++++-
 src/ap/ap_drv_ops.h               |   4 +-
 src/ap/apup.c                     |   4 +-
 src/ap/ieee802_11.c               |   8 +-
 src/ap/ieee802_11.h               |   4 +-
 src/ap/ieee802_11_eht.c           | 124 ++++++++++++++++++++++++++++--
 src/ap/sta_info.c                 |   2 +-
 src/common/ieee802_11_defs.h      |  34 ++++++++
 src/common/mtk_vendor.h           |  15 ++++
 src/drivers/driver.h              |  12 +++
 src/drivers/driver_nl80211.c      |  53 +++++++++++++
 src/drivers/driver_nl80211.h      |   1 +
 src/drivers/driver_nl80211_capa.c |   3 +
 18 files changed, 331 insertions(+), 13 deletions(-)

diff --git a/hostapd/config_file.c b/hostapd/config_file.c
index 206055b75..38273a4f2 100644
--- a/hostapd/config_file.c
+++ b/hostapd/config_file.c
@@ -5477,6 +5477,10 @@ static int hostapd_config_fill(struct hostapd_config *conf,
 		}
 	} else if (os_strcmp(buf, "eht_bw320_offset") == 0) {
 		conf->eht_bw320_offset = atoi(pos);
+	} else if (os_strcmp(buf, "eml_disable") == 0) {
+		conf->eml_disable = atoi(pos);
+	} else if (os_strcmp(buf, "eml_resp") == 0) {
+		conf->eml_resp = atoi(pos);
 #ifdef CONFIG_TESTING_OPTIONS
 	} else if (os_strcmp(buf, "eht_oper_puncturing_override") == 0) {
 		if (get_u16(pos, line, &bss->eht_oper_puncturing_override))
diff --git a/hostapd/ctrl_iface.c b/hostapd/ctrl_iface.c
index ebe9053cf..d9775e13e 100644
--- a/hostapd/ctrl_iface.c
+++ b/hostapd/ctrl_iface.c
@@ -5104,6 +5104,40 @@ hostapd_ctrl_iface_disable_beacon(struct hostapd_data *hapd, char *value,
 
 }
 
+static int
+hostapd_ctrl_iface_set_eml_resp(struct hostapd_data *hapd, char *value,
+				char *buf, size_t buflen)
+{
+	struct hostapd_data *link;
+	int cnt = 0;
+	u16 *val;
+
+	if (!hostapd_is_mld_ap(hapd))
+		return -1;
+
+	cnt = hostapd_parse_argument_helper(value, &val);
+	if (cnt == -1)
+		goto fail;
+	if (cnt != 1 || val[0] < 0)
+		goto para_fail;
+
+	for_each_mld_link(link, hapd) {
+		link->iconf->eml_resp = val[0];
+		wpa_printf(MSG_ERROR, "Link:%d, Response EML:%d\n",
+			   link->iconf->band_idx, link->iconf->eml_resp);
+	}
+
+	os_free(val);
+
+	return os_snprintf(buf, buflen, "OK\n");
+
+para_fail:
+	os_free(val);
+	wpa_printf(MSG_ERROR, "Input number or value is incorrect\n");
+fail:
+	return os_snprintf(buf, buflen, "FAIL\n");
+}
+
 static int
 hostapd_ctrl_iface_set_csi(struct hostapd_data *hapd, char *cmd,
 					char *buf, size_t buflen)
@@ -6034,6 +6068,8 @@ static int hostapd_ctrl_iface_receive_process(struct hostapd_data *hapd,
 	} else if (os_strncmp(buf, "WMM", 3) == 0) {
 		reply_len = hostapd_ctrl_iface_wmm(hapd, buf + 4,
 						   reply, reply_size);
+	} else if (os_strncmp(buf, "EML_RESP ", 9) == 0) {
+		reply_len = hostapd_ctrl_iface_set_eml_resp(hapd, buf + 9, reply, reply_size);
 	} else {
 		os_memcpy(reply, "UNKNOWN COMMAND\n", 16);
 		reply_len = 16;
diff --git a/hostapd/hostapd.conf b/hostapd/hostapd.conf
index 118754800..d0830eecd 100644
--- a/hostapd/hostapd.conf
+++ b/hostapd/hostapd.conf
@@ -1149,6 +1149,16 @@ wmm_ac_vo_acm=0
 # will be used as the AP MLD MAC address.
 #mld_addr=02:03:04:05:06:07
 
+# EML Capabilities
+# 0 = Enable EML capabilities in Multi-Link Control subfield
+# 1 = Disable EML capabilitites in Multi-Link Control subfield
+#eml_disable=0
+
+# EML Operating Mode Notification frame
+# 0 = AP does not send EML Operating Mode Notification frame to the station
+# 1 = AP sends EML Operating Mode Notification frame to the station
+#eml_resp=1
+
 ##### IEEE 802.1X-2004 related configuration ##################################
 
 # Require IEEE 802.1X authorization
diff --git a/hostapd/hostapd_cli.c b/hostapd/hostapd_cli.c
index e578c5b7e..54fda5c45 100644
--- a/hostapd/hostapd_cli.c
+++ b/hostapd/hostapd_cli.c
@@ -1488,6 +1488,12 @@ static int hostapd_cli_cmd_disable_beacon(struct wpa_ctrl *ctrl, int argc,
 	return hostapd_cli_cmd(ctrl, "NO_BEACON", 1, argc, argv);
 }
 
+static int hostapd_cli_cmd_set_eml_resp(struct wpa_ctrl *ctrl, int argc,
+					char *argv[])
+{
+	return hostapd_cli_cmd(ctrl, "EML_RESP", 1, argc, argv);
+}
+
 #ifdef CONFIG_DPP
 
 static int hostapd_cli_cmd_dpp_qr_code(struct wpa_ctrl *ctrl, int argc,
@@ -1937,6 +1943,8 @@ static const struct hostapd_cli_cmd hostapd_cli_commands[] = {
 		" = show mu onoff value in 0-15 bitmap"},
 	{ "no_beacon", hostapd_cli_cmd_disable_beacon, NULL,
 		"<value> 0: Enable beacon, 1: Disable beacon"},
+	{ "eml_resp", hostapd_cli_cmd_set_eml_resp, NULL,
+		"<value> 0: AP does not send EML Operating Mode Notification frame, 1: AP sends EML OMN frame"},
 #ifdef CONFIG_DPP
 	{ "dpp_qr_code", hostapd_cli_cmd_dpp_qr_code, NULL,
 	  "report a scanned DPP URI from a QR Code" },
diff --git a/src/ap/ap_config.h b/src/ap/ap_config.h
index 15b66ca30..9c3a28cf4 100644
--- a/src/ap/ap_config.h
+++ b/src/ap/ap_config.h
@@ -1281,6 +1281,8 @@ struct hostapd_config {
 	u8 punct_acs_threshold;
 	u8 eht_default_pe_duration;
 	u8 eht_bw320_offset;
+	u8 eml_disable;
+	u8 eml_resp;
 #endif /* CONFIG_IEEE80211BE */
 
 	/* EHT enable/disable config from CHAN_SWITCH */
diff --git a/src/ap/ap_drv_ops.c b/src/ap/ap_drv_ops.c
index fb09a3290..2d2198a44 100644
--- a/src/ap/ap_drv_ops.c
+++ b/src/ap/ap_drv_ops.c
@@ -496,7 +496,8 @@ int hostapd_sta_add(struct hostapd_data *hapd,
 		    size_t eht_capab_len,
 		    const struct ieee80211_he_6ghz_band_cap *he_6ghz_capab,
 		    u32 flags, u8 qosinfo, u8 vht_opmode, int supp_p2p_ps,
-		    int set, const u8 *link_addr, bool mld_link_sta)
+		    int set, const u8 *link_addr, bool mld_link_sta,
+		    u16 eml_capa)
 {
 	struct hostapd_sta_add_params params;
 
@@ -536,6 +537,7 @@ int hostapd_sta_add(struct hostapd_data *hapd,
 		params.mld_link_id = hapd->mld_link_id;
 		params.mld_link_addr = link_addr;
 		params.mld_link_sta = mld_link_sta;
+		params.eml_capa = eml_capa;
 	}
 #endif /* CONFIG_IEEE80211BE */
 
@@ -1448,6 +1450,22 @@ int hostapd_drv_beacon_ctrl(struct hostapd_data *hapd, u8 beacon_mode)
 	return hapd->driver->beacon_ctrl(hapd->drv_priv, beacon_mode);
 }
 
+int hostapd_drv_set_eml_omn(struct hostapd_data *hapd, u8 *mac,
+			    struct eml_omn_element *omn_ie)
+{
+	u8 link_id;
+
+	if (!hapd->driver || !hapd->driver->set_eml_omn)
+		return 0;
+
+	if (!hapd->conf->mld_ap)
+		return 0;
+
+	link_id = hapd->mld_link_id;
+
+	return hapd->driver->set_eml_omn(hapd->drv_priv, link_id, mac, omn_ie);
+}
+
 int hostapd_drv_csi_set(struct hostapd_data *hapd, u8 mode, u8 cfg, u8 v1, u32 v2, u8 *mac)
 {
 	if (!hapd->driver || !hapd->driver->csi_set)
diff --git a/src/ap/ap_drv_ops.h b/src/ap/ap_drv_ops.h
index 9f2e86a9b..ca2efab82 100644
--- a/src/ap/ap_drv_ops.h
+++ b/src/ap/ap_drv_ops.h
@@ -52,7 +52,8 @@ int hostapd_sta_add(struct hostapd_data *hapd,
 		    size_t eht_capab_len,
 		    const struct ieee80211_he_6ghz_band_cap *he_6ghz_capab,
 		    u32 flags, u8 qosinfo, u8 vht_opmode, int supp_p2p_ps,
-		    int set, const u8 *link_addr, bool mld_link_sta);
+		    int set, const u8 *link_addr, bool mld_link_sta,
+		    u16 eml_capa);
 int hostapd_set_privacy(struct hostapd_data *hapd, int enabled);
 int hostapd_set_generic_elem(struct hostapd_data *hapd, const u8 *elem,
 			     size_t elem_len);
@@ -174,6 +175,7 @@ int hostapd_drv_amnt_dump(struct hostapd_data *hapd, u8 amnt_idx, u8 *amnt_dump_
 int hostapd_drv_background_radar_mode(struct hostapd_data *hapd);
 int hostapd_drv_pp_mode_set(struct hostapd_data *hapd);
 int hostapd_drv_beacon_ctrl(struct hostapd_data *hapd, u8 beacon_mode);
+int hostapd_drv_set_eml_omn(struct hostapd_data *hapd, u8 *mac, struct eml_omn_element *omn_ie);
 int hostapd_drv_csi_set(struct hostapd_data *hapd, u8 mode, u8 cfg, u8 v1, u32 v2, u8 *mac);
 int hostapd_drv_csi_dump(struct hostapd_data *hapd, void *dump_buf);
 
diff --git a/src/ap/apup.c b/src/ap/apup.c
index f736ddc8e..cb0264e9e 100644
--- a/src/ap/apup.c
+++ b/src/ap/apup.c
@@ -67,7 +67,7 @@ void apup_process_beacon(struct hostapd_data *hapd,
 	            NULL, 0, 0, NULL, NULL, NULL, 0, NULL, 0, NULL,
 	            sta_ret->flags, 0, 0, 0,
 	            0, // 0 add, 1 set
-	            mld_link_addr, mld_link_sta);
+	            mld_link_addr, mld_link_sta, 0);
 
 	sta_ret->flags |= WLAN_STA_AUTH;
 	wpa_auth_sm_event(sta_ret->wpa_sm, WPA_AUTH);
@@ -141,7 +141,7 @@ void apup_process_beacon(struct hostapd_data *hapd,
 	            sta_ret->vht_opmode,
 	            0, // int supp_p2p_ps
 	            1, // 0 add, 1 set
-	            mld_link_addr, mld_link_sta);
+	            mld_link_addr, mld_link_sta, 0);
 
 	ap_sta_set_authorized(hapd, sta_ret, 1);
 	hostapd_set_sta_flags(hapd, sta_ret);
diff --git a/src/ap/ieee802_11.c b/src/ap/ieee802_11.c
index bb508fe79..09f033e13 100644
--- a/src/ap/ieee802_11.c
+++ b/src/ap/ieee802_11.c
@@ -4763,6 +4763,7 @@ static int add_associated_sta(struct hostapd_data *hapd,
 	int set = 1;
 	const u8 *mld_link_addr = NULL;
 	bool mld_link_sta = false;
+	u16 eml_capa = 0;
 
 #ifdef CONFIG_IEEE80211BE
 	if (ap_sta_is_mld(hapd, sta)) {
@@ -4773,6 +4774,8 @@ static int add_associated_sta(struct hostapd_data *hapd,
 
 		if (hapd->mld_link_id != sta->mld_assoc_link_id)
 			set = 0;
+
+		eml_capa = sta->mld_info.common_info.eml_capa;
 	}
 #endif /* CONFIG_IEEE80211BE */
 
@@ -4861,7 +4864,7 @@ static int add_associated_sta(struct hostapd_data *hapd,
 			    sta->he_6ghz_capab,
 			    sta->flags | WLAN_STA_ASSOC, sta->qosinfo,
 			    sta->vht_opmode, sta->p2p_ie ? 1 : 0,
-			    set, mld_link_addr, mld_link_sta)) {
+			    set, mld_link_addr, mld_link_sta, eml_capa)) {
 		hostapd_logger(hapd, sta->addr,
 			       HOSTAPD_MODULE_IEEE80211, HOSTAPD_LEVEL_NOTICE,
 			       "Could not %s STA to kernel driver",
@@ -6214,6 +6217,9 @@ static int handle_action(struct hostapd_data *hapd,
 		if (hapd->public_action_cb || hapd->public_action_cb2)
 			return 1;
 		break;
+	case WLAN_ACTION_PROTECTED_EHT:
+		ieee802_11_rx_prot_eht(hapd, mgmt, len);
+		return 1;
 	case WLAN_ACTION_VENDOR_SPECIFIC:
 		if (hapd->vendor_action_cb) {
 			if (hapd->vendor_action_cb(hapd->vendor_action_cb_ctx,
diff --git a/src/ap/ieee802_11.h b/src/ap/ieee802_11.h
index 0e13d2940..18f97890b 100644
--- a/src/ap/ieee802_11.h
+++ b/src/ap/ieee802_11.h
@@ -265,5 +265,7 @@ int hostapd_process_assoc_ml_info(struct hostapd_data *hapd,
 				  const u8 *ies, size_t ies_len,
 				  bool reassoc, int tx_link_status,
 				  bool offload);
-
+void ieee802_11_rx_prot_eht(struct hostapd_data *hapd,
+			    const struct ieee80211_mgmt *mgmt,
+			    size_t len);
 #endif /* IEEE802_11_H */
diff --git a/src/ap/ieee802_11_eht.c b/src/ap/ieee802_11_eht.c
index 2b5c06d6d..59ada2f86 100644
--- a/src/ap/ieee802_11_eht.c
+++ b/src/ap/ieee802_11_eht.c
@@ -465,9 +465,11 @@ static u8 * hostapd_eid_eht_basic_ml_common(struct hostapd_data *hapd,
 	control = MULTI_LINK_CONTROL_TYPE_BASIC |
 		BASIC_MULTI_LINK_CTRL_PRES_LINK_ID |
 		BASIC_MULTI_LINK_CTRL_PRES_BSS_PARAM_CH_COUNT |
-		BASIC_MULTI_LINK_CTRL_PRES_EML_CAPA |
 		BASIC_MULTI_LINK_CTRL_PRES_MLD_CAPA;
 
+	if (!hapd->iconf->eml_disable)
+		control |= BASIC_MULTI_LINK_CTRL_PRES_EML_CAPA;
+
 	/*
 	 * Set the basic Multi-Link common information. Hard code the common
 	 * info length to 13 based on the length of the present fields:
@@ -478,6 +480,9 @@ static u8 * hostapd_eid_eht_basic_ml_common(struct hostapd_data *hapd,
 #define EHT_ML_COMMON_INFO_LEN 13
 	common_info_len = EHT_ML_COMMON_INFO_LEN;
 
+	if (hapd->iconf->eml_disable)
+		common_info_len -= 2; /* EML Capabilities (2) */
+
 	if (include_mld_id) {
 		/* AP MLD ID */
 		control |= BASIC_MULTI_LINK_CTRL_PRES_AP_MLD_ID;
@@ -497,9 +502,11 @@ static u8 * hostapd_eid_eht_basic_ml_common(struct hostapd_data *hapd,
 	/* Currently hard code the BSS Parameters Change Count to 0x1 */
 	wpabuf_put_u8(buf, hapd->eht_mld_bss_param_change);
 
-	wpa_printf(MSG_DEBUG, "MLD: EML Capabilities=0x%x",
-		   hapd->iface->mld_eml_capa);
-	wpabuf_put_le16(buf, hapd->iface->mld_eml_capa);
+	if (!hapd->iconf->eml_disable) {
+		wpa_printf(MSG_DEBUG, "MLD: EML Capabilities=0x%x",
+			   hapd->iface->mld_eml_capa);
+		wpabuf_put_le16(buf, hapd->iface->mld_eml_capa);
+	}
 
 	mld_cap = hapd->iface->mld_mld_capa;
 	max_simul_links = mld_cap & EHT_ML_MLD_CAPA_MAX_NUM_SIM_LINKS_MASK;
@@ -744,12 +751,16 @@ static u8 * hostapd_eid_eht_reconf_ml(struct hostapd_data *hapd, u8 *eid)
 
 
 static size_t hostapd_eid_eht_ml_len(struct mld_info *info,
-				     bool include_mld_id)
+				     bool include_mld_id,
+				     u8 eml_disable)
 {
 	size_t len = 0;
 	size_t eht_ml_len = 2 + EHT_ML_COMMON_INFO_LEN;
 	u8 link_id;
 
+	if (eml_disable)
+		eht_ml_len -= 2; /* EML Capabilities (2) */
+
 	if (include_mld_id)
 		eht_ml_len++;
 
@@ -811,7 +822,8 @@ size_t hostapd_eid_eht_ml_beacon_len(struct hostapd_data *hapd,
 				     struct mld_info *info,
 				     bool include_mld_id)
 {
-	return hostapd_eid_eht_ml_len(info, include_mld_id);
+	return hostapd_eid_eht_ml_len(info, include_mld_id,
+				      hapd->iconf->eml_disable);
 }
 
 
@@ -1406,3 +1418,103 @@ out:
 
 	return WLAN_STATUS_SUCCESS;
 }
+
+static void ieee802_11_send_eml_omn(struct hostapd_data *hapd,
+				    const u8 *addr,
+				    struct eml_omn_element *omn_ie,
+				    size_t len)
+{
+	struct wpabuf *buf;
+
+	buf = wpabuf_alloc(2 + len);
+	if (!buf)
+		return;
+
+	wpabuf_put_u8(buf, WLAN_ACTION_PROTECTED_EHT);
+	wpabuf_put_u8(buf, WLAN_PROTECTED_EHT_ACTION_EML_OMN);
+	wpabuf_put_data(buf, omn_ie, len);
+
+	hostapd_drv_send_action(hapd, hapd->iface->freq, 0, addr,
+				wpabuf_head(buf), wpabuf_len(buf));
+
+	wpabuf_free(buf);
+}
+
+static void ieee802_11_rx_eml_omn(struct hostapd_data *hapd,
+				  const u8 *addr, const u8 *frm,
+				  size_t len)
+{
+	struct eml_omn_element *omn_ie;
+
+	if (hapd->iconf->eml_disable) {
+		wpa_printf(MSG_ERROR,
+			   "Ignore EML Operating Mode Notification from "
+			   MACSTR
+			   " since EML Capabilities is disabled",
+			   MAC2STR(addr));
+		return;
+	}
+
+	/* EML Operating Mode Notification IE */
+	omn_ie = os_zalloc(sizeof(struct eml_omn_element));
+	if (omn_ie == NULL)
+		return;
+
+	os_memcpy(omn_ie, frm, len);
+
+	if (omn_ie->control & EHT_EML_OMN_CONTROL_EMLMR_MODE) {
+		wpa_printf(MSG_ERROR,
+			   "EML: Ignore EML Operating Mode Fotification from "
+			   MACSTR
+			   " since doesn't support EMLMR",
+			   MAC2STR(addr));
+		goto out;
+	}
+
+	hostapd_drv_set_eml_omn(hapd, addr, omn_ie);
+
+	omn_ie->control &= ~(EHT_EML_OMN_CONTROL_EMLSR_PARA_UPDATE_COUNT |
+			     EHT_EML_OMN_CONTROL_INDEV_COEX_ACTIVITIES);
+
+	if (hapd->iconf->eml_resp) {
+		ieee802_11_send_eml_omn(hapd, addr, omn_ie, len);
+		wpa_printf(MSG_ERROR, "EML: AP send EML Operating Mode Fotification to "
+				       MACSTR,
+				       MAC2STR(addr));
+	}
+out:
+	os_free(omn_ie);
+	return;
+}
+
+void ieee802_11_rx_prot_eht(struct hostapd_data *hapd,
+			    const struct ieee80211_mgmt *mgmt,
+			    size_t len)
+{
+	u8 action;
+	const u8 *payload;
+	size_t plen;
+
+	if (!hapd->conf->mld_ap)
+		return;
+
+	if (len < IEEE80211_HDRLEN + 2)
+		return;
+
+	payload = mgmt->u.action.u.eht_prot.variable;
+	action = mgmt->u.action.u.eht_prot.action;
+	plen = len - IEEE80211_HDRLEN - 2;
+
+	switch (action) {
+	case WLAN_PROTECTED_EHT_ACTION_EML_OMN:
+		ieee802_11_rx_eml_omn(hapd, mgmt->sa, payload, plen);
+		return;
+	}
+
+	wpa_printf(MSG_ERROR, "EHT: Unsupported Protected EHT Action %u from " MACSTR,
+		   action, MAC2STR(mgmt->sa));
+
+	return;
+
+}
+
diff --git a/src/ap/sta_info.c b/src/ap/sta_info.c
index 44d98d5e0..58e66f555 100644
--- a/src/ap/sta_info.c
+++ b/src/ap/sta_info.c
@@ -1901,7 +1901,7 @@ int ap_sta_re_add(struct hostapd_data *hapd, struct sta_info *sta)
 			    sta->supported_rates_len,
 			    0, NULL, NULL, NULL, 0, NULL, 0, NULL,
 			    sta->flags, 0, 0, 0, 0,
-			    mld_link_addr, mld_link_sta)) {
+			    mld_link_addr, mld_link_sta, 0)) {
 		hostapd_logger(hapd, sta->addr,
 			       HOSTAPD_MODULE_IEEE80211,
 			       HOSTAPD_LEVEL_NOTICE,
diff --git a/src/common/ieee802_11_defs.h b/src/common/ieee802_11_defs.h
index efb584c66..fb481b8b2 100644
--- a/src/common/ieee802_11_defs.h
+++ b/src/common/ieee802_11_defs.h
@@ -775,6 +775,36 @@
 #define WLAN_PROT_FTM 2
 #define WLAN_PROT_FTM_REPORT 3
 
+/* Protected EHT action codes */
+#define WLAN_PROTECTED_EHT_ACTION_EML_OMN 6
+
+/* EML Operating Mode Notification frame */
+#define EHT_EML_OMN_CONTROL_EMLSR_MODE 0x1
+#define EHT_EML_OMN_CONTROL_EMLMR_MODE 0x2
+#define EHT_EML_OMN_CONTROL_EMLSR_PARA_UPDATE_COUNT 0x4
+#define EHT_EML_OMN_CONTROL_INDEV_COEX_ACTIVITIES 0x8
+
+/* EMLSR Parameter Update field */
+#define EHT_EML_OMN_EMLSR_PADDING_DELAY_MASK 0x07
+#define EHT_EML_OMN_EMLSR_TRANSITION_DELAY_MASK 0x38
+
+struct eml_omn_element {
+	u8 dialog_token;
+	u8 control;
+	le16 bitmap;
+	union {
+		struct {
+			u8 emlsr_para_update;
+		} STRUCT_PACKED emlsr_info;
+		struct {
+			u8 mcs_map_count_control;
+			u8 mcs_map_bw80[3];
+			u8 mcs_map_bw160[3];
+			u8 mcs_map_bw320[3];
+		} STRUCT_PACKED emlmr_info;
+	} u;
+} STRUCT_PACKED;
+
 /* Radio Measurement capabilities (from RM Enabled Capabilities element)
  * IEEE Std 802.11-2020, 9.4.2.44, Table 9-179 */
 /* byte 1 (out of 5) */
@@ -1161,6 +1191,10 @@ struct ieee80211_mgmt {
 					u8 dialog_token;
 					u8 variable[];
 				} STRUCT_PACKED rrm;
+				struct {
+					u8 action;
+					u8 variable[];
+				} STRUCT_PACKED eht_prot;
 			} u;
 		} STRUCT_PACKED action;
 	} u;
diff --git a/src/common/mtk_vendor.h b/src/common/mtk_vendor.h
index be516e017..c6de8862b 100644
--- a/src/common/mtk_vendor.h
+++ b/src/common/mtk_vendor.h
@@ -19,6 +19,7 @@ enum mtk_nl80211_vendor_subcmds {
 	MTK_NL80211_VENDOR_SUBCMD_BACKGROUND_RADAR_CTRL = 0xcb,
 	MTK_NL80211_VENDOR_SUBCMD_PP_CTRL = 0xcc,
 	MTK_NL80211_VENDOR_SUBCMD_BEACON_CTRL = 0xcd,
+	MTK_NL80211_VENDOR_SUBCMD_EML_CTRL = 0xd3,
 };
 
 enum mtk_vendor_attr_edcca_ctrl {
@@ -287,6 +288,20 @@ enum mtk_vendor_attr_beacon_ctrl {
 		NUM_MTK_VENDOR_ATTRS_BEACON_CTRL - 1
 };
 
+enum mtk_vendor_attr_eml_ctrl {
+
+	MTK_VENDOR_ATTR_EML_CTRL_UNSPEC,
+
+	MTK_VENDOR_ATTR_EML_LINK_ID,
+	MTK_VENDOR_ATTR_EML_STA_ADDR,
+	MTK_VENDOR_ATTR_EML_CTRL_STRUCT,
+
+	/* keep last */
+	NUM_MTK_VENDOR_ATTRS_EML_CTRL,
+	MTK_VENDOR_ATTR_EML_CTRL_MAX =
+		NUM_MTK_VENDOR_ATTRS_EML_CTRL -1
+};
+
 #define CSI_BW20_DATA_COUNT	64
 #define CSI_BW40_DATA_COUNT	128
 #define CSI_BW80_DATA_COUNT	256
diff --git a/src/drivers/driver.h b/src/drivers/driver.h
index 924a1baba..e7e62c5ad 100644
--- a/src/drivers/driver.h
+++ b/src/drivers/driver.h
@@ -2575,6 +2575,7 @@ struct hostapd_sta_add_params {
 	bool mld_link_sta;
 	s8 mld_link_id;
 	const u8 *mld_link_addr;
+	u16 eml_capa;
 };
 
 struct mac_address {
@@ -5277,6 +5278,17 @@ struct wpa_driver_ops {
 	 */
 	int (*beacon_ctrl)(void *priv, u8 beacon_mode);
 
+	/**
+	 * set eml omn - Send the EML Operating Mode
+	 * 		 Notification content to driver
+	 * @priv: Private driver interface data
+	 * @link_id: MLD link id
+	 * @addr: MLD STA address
+	 * @omn_ie: EML OMN content sent by the MLD STA
+	 */
+	int (*set_eml_omn)(void *priv, u8 link_id,
+			   u8 *addr, struct eml_omn_element *omn_ie);
+
 	/**
 	 * three_wire_ctrl - set three_wire_ctrl mode
 	 * @priv: Private driver interface data
diff --git a/src/drivers/driver_nl80211.c b/src/drivers/driver_nl80211.c
index 555c97bf7..9451714a7 100644
--- a/src/drivers/driver_nl80211.c
+++ b/src/drivers/driver_nl80211.c
@@ -2893,6 +2893,9 @@ static int nl80211_action_subscribe_ap(struct i802_bss *bss)
 	if (nl80211_register_action_frame(bss, (u8 *) "\x12", 1) < 0)
 		ret = -1;
 #endif /* CONFIG_FST */
+	/* Protected EHT */
+	if (nl80211_register_action_frame(bss, (u8 *) "\x25", 1) < 0)
+		ret = -1;
 	/* Vendor-specific */
 	if (nl80211_register_action_frame(bss, (u8 *) "\x7f", 1) < 0)
 		ret = -1;
@@ -5981,6 +5984,14 @@ static int wpa_driver_nl80211_sta_add(void *priv,
 			goto fail;
 	}
 
+	if (params->eml_capa) {
+		wpa_printf(MSG_DEBUG, "  * eml_capa=%u",
+			   params->eml_capa);
+		if (nla_put_u16(msg, NL80211_ATTR_EML_CAPABILITY,
+				params->eml_capa))
+			goto fail;
+	}
+
 	ret = send_and_recv_cmd(drv, msg);
 	msg = NULL;
 	if (ret)
@@ -15261,6 +15272,47 @@ static int nl80211_get_mld_addr(void *priv, u8 *addr)
 
 	return 0;
 }
+
+static int nl80211_set_eml_omn(void *priv, u8 link_id, u8 *addr,
+			       struct eml_omn_element *omn_ie)
+{
+	struct i802_bss *bss = priv;
+	struct wpa_driver_nl80211_data *drv = bss->drv;
+	struct nl_msg *msg;
+	struct nlattr *data;
+	int ret = -ENOBUFS;
+
+	if (!drv->mtk_eml_vendor_cmd_avail) {
+		wpa_printf(MSG_ERROR,
+			   "nl80211: Driver does not support setting EML control");
+		return 0;
+	}
+
+	if (!(msg = nl80211_drv_msg(drv, 0, NL80211_CMD_VENDOR)) ||
+	    nla_put_u32(msg, NL80211_ATTR_VENDOR_ID, OUI_MTK) ||
+	    nla_put_u32(msg, NL80211_ATTR_VENDOR_SUBCMD,
+			MTK_NL80211_VENDOR_SUBCMD_EML_CTRL) ||
+	    !(data = nla_nest_start(msg, NL80211_ATTR_VENDOR_DATA)) ||
+	    nla_put_u8(msg, MTK_VENDOR_ATTR_EML_LINK_ID, link_id) ||
+	    nla_put(msg, MTK_VENDOR_ATTR_EML_STA_ADDR, ETH_ALEN, addr) ||
+	    nla_put(msg, MTK_VENDOR_ATTR_EML_CTRL_STRUCT,
+		    sizeof(struct eml_omn_element), omn_ie))
+		goto fail;
+
+
+	nla_nest_end(msg, data);
+	ret = send_and_recv_cmd(drv, msg);
+
+	if (ret)
+		wpa_printf(MSG_ERROR, "Failed to set EML OMN ctrl. ret = %d (%s)",
+			   ret, strerror(-ret));
+
+	return ret;
+
+fail:
+	nlmsg_free(msg);
+	return ret;
+}
 #endif
 
 static int
@@ -15619,6 +15671,7 @@ const struct wpa_driver_ops wpa_driver_nl80211_ops = {
 	.mu_ctrl = nl80211_mu_ctrl,
 	.mu_dump = nl80211_mu_dump,
 	.beacon_ctrl = nl80211_beacon_ctrl,
+	.set_eml_omn = nl80211_set_eml_omn,
 #ifdef CONFIG_DPP
 	.dpp_listen = nl80211_dpp_listen,
 #endif /* CONFIG_DPP */
diff --git a/src/drivers/driver_nl80211.h b/src/drivers/driver_nl80211.h
index b710b50cd..2cc40e0dc 100644
--- a/src/drivers/driver_nl80211.h
+++ b/src/drivers/driver_nl80211.h
@@ -213,6 +213,7 @@ struct wpa_driver_nl80211_data {
 	unsigned int mtk_pp_vendor_cmd_avail:1;
 	unsigned int mtk_beacon_ctrl_vendor_cmd_avail:1;
 	unsigned int mtk_csi_vendor_cmd_avail:1;
+	unsigned int mtk_eml_vendor_cmd_avail:1;
 
 	u32 ignore_next_local_disconnect;
 	u32 ignore_next_local_deauth;
diff --git a/src/drivers/driver_nl80211_capa.c b/src/drivers/driver_nl80211_capa.c
index 5a53700d1..c1327a679 100644
--- a/src/drivers/driver_nl80211_capa.c
+++ b/src/drivers/driver_nl80211_capa.c
@@ -1176,6 +1176,9 @@ static int wiphy_info_handler(struct nl_msg *msg, void *arg)
 				case MTK_NL80211_VENDOR_SUBCMD_CSI_CTRL:
 					drv->mtk_csi_vendor_cmd_avail = 1;
 					break;
+				case MTK_NL80211_VENDOR_SUBCMD_EML_CTRL:
+					drv->mtk_eml_vendor_cmd_avail = 1;
+					break;
 				}
 			}
 
-- 
2.18.0

