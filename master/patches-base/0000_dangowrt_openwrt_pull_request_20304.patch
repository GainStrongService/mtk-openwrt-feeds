From 64f3576c6110c25b812f65090f1f599631ec2a0d Mon Sep 17 00:00:00 2001
From: Daniel Golle <daniel@makrotopia.org>
Date: Sun, 5 Oct 2025 00:34:42 +0100
Subject: [PATCH 01/11] generic: mtdsplit: fit: improve detecting external-data
 FIT

Currently the detection of external-data FIT images works by checking
if the FIT structure is more than 4 kiB. However, for boards with lots
of different DT-overlays and configurations the FIT structure can
exceed 4 kiB which results in the FIT splitter to fail detecting the
rootfs.
Increase the threshold for external-data FIT to 512 kiB as there aren't
any kernel images smaller than that, and FIT structure less than 512 kiB
will always be an external-data FIT.

Signed-off-by: Daniel Golle <daniel@makrotopia.org>
---
 target/linux/generic/files/drivers/mtd/mtdsplit/mtdsplit_fit.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

--- a/target/linux/generic/files/drivers/mtd/mtdsplit/mtdsplit_fit.c
+++ b/target/linux/generic/files/drivers/mtd/mtdsplit/mtdsplit_fit.c
@@ -258,7 +258,7 @@ mtdsplit_fit_parse(struct mtd_info *mtd,
 	 * hence we need to parse FDT structure to find the end of the
 	 * last external data refernced.
 	 */
-	if (fit_size > 0x1000) {
+	if (fit_size > 0x80000) {
 		enum mtdsplit_part_type type;
 
 		/* Search for the rootfs partition after the FIT image */
--- a/package/boot/arm-trusted-firmware-mediatek/Makefile
+++ b/package/boot/arm-trusted-firmware-mediatek/Makefile
@@ -38,6 +38,7 @@ define Trusted-Firmware-A/Default
   USE_UBI:=
   FIP_OFFSET:=
   FIP_SIZE:=
+  SPIM_CTRL:=
 endef
 
 define Trusted-Firmware-A/mt7622-nor-1ddr
@@ -393,6 +394,61 @@ define Trusted-Firmware-A/mt7986-spim-na
   USE_UBI:=1
 endef
 
+define Trusted-Firmware-A/mt7987-emmc-comb
+  NAME:=MediaTek MT7987 (eMMC)
+  BOOT_DEVICE:=emmc
+  BUILD_SUBTARGET:=filogic
+  PLAT:=mt7987
+  DRAM_USE_COMB:=1
+endef
+
+define Trusted-Firmware-A/mt7987-nor-comb
+  NAME:=MediaTek MT7987 (NOR)
+  BOOT_DEVICE:=nor
+  BUILD_SUBTARGET:=filogic
+  PLAT:=mt7987
+  DRAM_USE_COMB:=1
+endef
+
+define Trusted-Firmware-A/mt7987-sdmmc-comb
+  NAME:=MediaTek MT7987 (SD card)
+  BOOT_DEVICE:=sdmmc
+  BUILD_SUBTARGET:=filogic
+  PLAT:=mt7987
+  DRAM_USE_COMB:=1
+endef
+
+define Trusted-Firmware-A/mt7987-spim-nand0-ubi-comb
+  NAME:=MediaTek MT7987 (SPI-NAND via SPIM, UBI)
+  BOOT_DEVICE:=spim-nand
+  BUILD_SUBTARGET:=filogic
+  PLAT:=mt7987
+  DRAM_USE_COMB:=1
+  USE_UBI:=1
+  SPIM_CTRL:=0
+endef
+
+define Trusted-Firmware-A/mt7987-spim-nand2-ubi-comb
+  NAME:=MediaTek MT7987 (SPI-NAND via SPIM, UBI)
+  BOOT_DEVICE:=spim-nand
+  BUILD_SUBTARGET:=filogic
+  PLAT:=mt7987
+  DRAM_USE_COMB:=1
+  USE_UBI:=1
+  SPIM_CTRL:=2
+endef
+
+define Trusted-Firmware-A/mt7987-ram-comb
+  NAME:=MediaTek MT7987 (RAM)
+  BOOT_DEVICE:=ram
+  BUILD_SUBTARGET:=filogic
+  PLAT:=mt7987
+  DRAM_USE_COMB:=1
+  RAM_BOOT_UART_DL:=1
+  HIDDEN:=
+  DEFAULT:=TARGET_mediatek_filogic
+endef
+
 define Trusted-Firmware-A/mt7988-nor-ddr3
   NAME:=MediaTek MT7988 (SPI-NOR, DDR3)
   BOOT_DEVICE:=nor
@@ -604,6 +660,12 @@ TFA_TARGETS:= \
 	mt7986-spim-nand-ddr4 \
 	mt7986-spim-nand-ubi-ddr4 \
 	mt7986-spim-nand-4k-ddr4 \
+	mt7987-emmc-comb \
+	mt7987-nor-comb \
+	mt7987-sdmmc-comb \
+	mt7987-spim-nand0-ubi-comb \
+	mt7987-spim-nand2-ubi-comb \
+	mt7987-ram-comb \
 	mt7988-emmc-ddr3 \
 	mt7988-nor-ddr3 \
 	mt7988-sdmmc-ddr3 \
@@ -641,6 +703,7 @@ TFA_MAKE_FLAGS += \
 	$(if $(USE_UBI),UBI=1 $(if $(findstring mt7986,$(PLAT)),OVERRIDE_UBI_START_ADDR=0x200000)) \
 	$(if $(FIP_OFFSET),OVERRIDE_FIP_BASE=$(FIP_OFFSET)) \
 	$(if $(FIP_SIZE),OVERRIDE_FIP_SIZE=$(FIP_SIZE)) \
+	$(if $(SPIM_CTRL),SPIM_CTRL=$(SPIM_CTRL)) \
 	$(if $(RAM_BOOT_UART_DL),bl2,all)
 
 define Package/trusted-firmware-a-ram/install
@@ -653,6 +716,7 @@ Package/trusted-firmware-a-mt7981-ram-dd
 Package/trusted-firmware-a-mt7981-ram-ddr4/install = $(Package/trusted-firmware-a-ram/install)
 Package/trusted-firmware-a-mt7986-ram-ddr3/install = $(Package/trusted-firmware-a-ram/install)
 Package/trusted-firmware-a-mt7986-ram-ddr4/install = $(Package/trusted-firmware-a-ram/install)
+Package/trusted-firmware-a-mt7987-ram-comb/install = $(Package/trusted-firmware-a-ram/install)
 Package/trusted-firmware-a-mt7988-ram-comb/install = $(Package/trusted-firmware-a-ram/install)
 Package/trusted-firmware-a-mt7988-ram-ddr4/install = $(Package/trusted-firmware-a-ram/install)
 
--- /dev/null
+++ b/package/boot/arm-trusted-firmware-mediatek/patches/0005-mt7987-make-SPI-controller-configurable.patch
@@ -0,0 +1,128 @@
+From e2e43103c00b5f7ccedbdbdece0f622cb420b4a5 Mon Sep 17 00:00:00 2001
+From: Daniel Golle <daniel@makrotopia.org>
+Date: Fri, 3 Oct 2025 12:53:10 +0100
+Subject: [PATCH] mt7987: make SPI controller configurable
+
+Allow selecting the SPI controller used for SPIM-NAND or SPI-NOR boot
+devices (either SPI0 or SPI2).
+
+Signed-off-by: Daniel Golle <daniel@makrotopia.org>
+---
+ plat/mediatek/apsoc_common/Config.in        |  1 +
+ plat/mediatek/mt7987/Config.in              | 29 +++++++++++++++++++++
+ plat/mediatek/mt7987/bl2/bl2.mk             | 12 +++++++++
+ plat/mediatek/mt7987/bl2/bl2_dev_spi_nand.c | 10 ++++++-
+ plat/mediatek/mt7987/platform.mk            |  4 +--
+ 5 files changed, 53 insertions(+), 3 deletions(-)
+ create mode 100644 plat/mediatek/mt7987/Config.in
+
+--- a/plat/mediatek/apsoc_common/Config.in
++++ b/plat/mediatek/apsoc_common/Config.in
+@@ -783,6 +783,7 @@ config ENABLE_BL31_RUNTIME_LOG
+ 	default 1
+ 	depends on _ENABLE_BL31_RUNTIME_LOG
+ 
++source "plat/mediatek/mt7987/Config.in"
+ source "plat/mediatek/mt7988/Config.in"
+ 
+ endmenu # Platform configurations
+--- /dev/null
++++ b/plat/mediatek/mt7987/Config.in
+@@ -0,0 +1,29 @@
++# SPDX-License-Identifier: BSD-3-Clause
++#
++# Copyright (c) 2025 Daniel Golle <daniel@makrotopia.org>
++#
++# MT7987 platform-specific configurations
++#
++
++if _PLAT_MT7987
++
++choice
++	prompt "SPI controller"
++	depends on (_BOOT_DEVICE_SPIM_NAND || _BOOT_DEVICE_SPI_NOR)
++	default _SPIM_CTRL_0 if _BOOT_DEVICE_SPIM_NAND
++	default _SPIM_CTRL_2 if _BOOT_DEVICE_SPI_NOR
++
++	config _SPIM_CTRL_0
++		bool "0"
++
++	config _SPIM_CTRL_2
++		bool "2"
++
++endchoice
++
++config SPIM_CTRL
++	int
++	default 0 if _SPIM_CTRL_0
++	default 2 if _SPIM_CTRL_2
++
++endif # _PLAT_MT7987
+--- a/plat/mediatek/mt7987/bl2/bl2.mk
++++ b/plat/mediatek/mt7987/bl2/bl2.mk
+@@ -91,7 +91,11 @@ endif # END OF BOOT_DEVICE = ram
+ ifeq ($(BOOT_DEVICE),nor)
+ $(eval $(call BL2_BOOT_NOR))
+ BL2_SOURCES		+=	$(MTK_PLAT_SOC)/bl2/bl2_dev_spi_nor.c
++ifeq ($(SPIM_CTRL),0)
++DTS_NAME		:=	mt7987-spi0
++else
+ DTS_NAME		:=	mt7987-spi2
++endif
+ endif # END OF BOOTDEVICE = nor
+ 
+ ifeq ($(BOOT_DEVICE),emmc)
+@@ -112,10 +116,18 @@ ifeq ($(BOOT_DEVICE),spim-nand)
+ $(eval $(call BL2_BOOT_SPI_NAND,0,0))
+ BL2_SOURCES		+=	$(MTK_PLAT_SOC)/bl2/bl2_dev_spi_nand.c
+ NAND_TYPE		?=	spim:2k+64
++ifeq ($(SPIM_CTRL),2)
++DTS_NAME		:=	mt7987-spi2
++else
+ DTS_NAME		:=	mt7987-spi0
++endif
+ $(eval $(call BL2_BOOT_NAND_TYPE_CHECK,$(NAND_TYPE),spim:2k+64 spim:2k+128 spim:4k+256))
+ endif # END OF BOOTDEVICE = spim-nand
+ 
++ifneq ($(SPIM_CTRL),)
++BL2_CPPFLAGS		+=	-DSPIM_CTRL=$(SPIM_CTRL)
++endif
++
+ ifeq ($(BROM_HEADER_TYPE),)
+ $(error BOOT_DEVICE has invalid value. Please re-check.)
+ endif
+--- a/plat/mediatek/mt7987/bl2/bl2_dev_spi_nand.c
++++ b/plat/mediatek/mt7987/bl2/bl2_dev_spi_nand.c
+@@ -12,10 +12,18 @@
+ 
+ #define MTK_QSPI_SRC_CLK		CB_MPLL_D2
+ 
++#if SPIM_CTRL == 0
++#define SELECTED_SPIM SPIM0
++#elif SPIM_CTRL == 2
++#define SELECTED_SPIM SPIM2
++#else
++#error "Invalid SPI controller selection"
++#endif
++
+ uint32_t mtk_plat_get_qspi_src_clk(void)
+ {
+ 	/* config GPIO pinmux to spi mode */
+-	mtk_spi_gpio_init(SPIM0);
++	mtk_spi_gpio_init(SELECTED_SPIM);
+ 
+ 	/* select 208M clk */
+ 	mtk_spi_source_clock_select(MTK_QSPI_SRC_CLK);
+--- a/plat/mediatek/mt7987/platform.mk
++++ b/plat/mediatek/mt7987/platform.mk
+@@ -56,8 +56,8 @@ include make_helpers/dep.mk
+ 
+ $(call GEN_DEP_RULES,bl2,emicfg bl2_boot_ram bl2_boot_nand_nmbm bl2_dev_mmc bl2_plat_init bl2_plat_setup mt7987_gpio dtb)
+ $(call MAKE_DEP,bl2,emicfg,DDR4_4BG_MODE DRAM_DEBUG_LOG DDR3_FREQ_2133 DDR3_FREQ_1866 DDR4_FREQ_3200 DDR4_FREQ_2666)
+-$(call MAKE_DEP,bl2,bl2_plat_init,BL2_COMPRESS)
+-$(call MAKE_DEP,bl2,bl2_plat_setup,BOOT_DEVICE TRUSTED_BOARD_BOOT BL32_TZRAM_BASE BL32_TZRAM_SIZE BL32_LOAD_OFFSET)
++$(call MAKE_DEP,bl2,bl2_plat_init,BL2_COMPRESS SPIM_CTRL)
++$(call MAKE_DEP,bl2,bl2_plat_setup,BOOT_DEVICE TRUSTED_BOARD_BOOT BL32_TZRAM_BASE BL32_TZRAM_SIZE BL32_LOAD_OFFSET SPIM_CTRL)
+ $(call MAKE_DEP,bl2,bl2_dev_mmc,BOOT_DEVICE)
+ $(call MAKE_DEP,bl2,bl2_boot_ram,RAM_BOOT_DEBUGGER_HOOK RAM_BOOT_UART_DL)
+ $(call MAKE_DEP,bl2,bl2_boot_nand_nmbm,NMBM_MAX_RATIO NMBM_MAX_RESERVED_BLOCKS NMBM_DEFAULT_LOG_LEVEL)
--- /dev/null
+++ b/package/boot/arm-trusted-firmware-mediatek/patches/0006-hack-mt7987-mmc-use-4-bit-bus-width-for-eMMC.patch
@@ -0,0 +1,24 @@
+From 0a09912eb336bee788443b919ea5b99b195f5a91 Mon Sep 17 00:00:00 2001
+From: Daniel Golle <daniel@makrotopia.org>
+Date: Sat, 4 Oct 2025 22:13:49 +0100
+Subject: [PATCH] hack: mt7987: mmc: use 4-bit bus-width for eMMC
+
+The BananaPi R4 Lite has broken DAT5 signal of the MMC bus, which
+results in 8-bit buswidth not working well for the eMMC.
+Reduce to 4-bit buswidth fixes it (and makes all other boards with
+eMMC a tiny bit slower to boot, but it's in the milliseconds).
+---
+ plat/mediatek/mt7987/bl2/bl2_dev_mmc.c | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+--- a/plat/mediatek/mt7987/bl2/bl2_dev_mmc.c
++++ b/plat/mediatek/mt7987/bl2/bl2_dev_mmc.c
+@@ -74,7 +74,7 @@ static const struct mt7987_msdc_conf {
+ 	{
+ 		.base = MSDC0_BASE,
+ 		.top_base = MSDC0_TOP_BASE,
+-		.bus_width = MMC_BUS_WIDTH_8,
++		.bus_width = MMC_BUS_WIDTH_4,
+ 		.type = MMC_IS_EMMC,
+ 		.src_clk = 200000000,
+ 		.dev_comp = &mt7987_msdc_compat,
--- /dev/null
+++ b/package/boot/arm-trusted-firmware-mediatek/patches/0007-hack-mt7987-bl2-move-FIP-offset-to-0x100000.patch
@@ -0,0 +1,27 @@
+From 6725bb3c2aa9330f37a591e1e539badf67021b47 Mon Sep 17 00:00:00 2001
+From: Daniel Golle <daniel@makrotopia.org>
+Date: Sat, 4 Oct 2025 23:59:54 +0100
+Subject: [PATCH] hack: mt7987: bl2: move FIP offset to 0x100000
+
+There is no use in allocating more than 2MB to the factory partition.
+After all, even for WiFi 7 tri-band devices the calibration data is
+still in the kilobytes range.
+Move FIP offset to 0x100000 to not waste so much space on small NOR
+flash.
+
+Signed-off-by: Daniel Golle <daniel@makrotopia.org>
+---
+ plat/mediatek/mt7987/bl2/bl2_dev_spi_nor.c | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+--- a/plat/mediatek/mt7987/bl2/bl2_dev_spi_nor.c
++++ b/plat/mediatek/mt7987/bl2/bl2_dev_spi_nor.c
+@@ -7,7 +7,7 @@
+ #include <stdint.h>
+ #include <boot_spi.h>
+ 
+-#define FIP_BASE			0x250000
++#define FIP_BASE			0x100000
+ #define FIP_SIZE			0x80000
+ 
+ #define MTK_QSPI_SRC_CLK		CB_MPLL_D2
--- a/package/boot/uboot-mediatek/Makefile
+++ b/package/boot/uboot-mediatek/Makefile
@@ -761,6 +761,55 @@ define U-Boot/mt7986_zyxel_ex5601-t0
   DEPENDS:=+trusted-firmware-a-mt7986-spim-nand-4k-ddr4
 endef
 
+define U-Boot/mt7987_bananapi_bpi-r4-lite-emmc
+  NAME:=BananaPi BPi-R4 Lite
+  BUILD_SUBTARGET:=filogic
+  BUILD_DEVICES:=bananapi_bpi-r4-lite
+  UBOOT_CONFIG:=mt7987a_bpi-r4-lite-emmc
+  UBOOT_IMAGE:=u-boot.fip
+  BL2_BOOTDEV:=emmc
+  BL2_SOC:=mt7987
+  BL2_DDRTYPE:=comb
+  DEPENDS:=+trusted-firmware-a-mt7987-emmc-comb
+endef
+
+define U-Boot/mt7987_bananapi_bpi-r4-lite-sdmmc
+  NAME:=BananaPi BPi-R4 Lite
+  BUILD_SUBTARGET:=filogic
+  BUILD_DEVICES:=bananapi_bpi-r4-lite
+  UBOOT_CONFIG:=mt7987a_bpi-r4-lite-sd
+  UBOOT_IMAGE:=u-boot.fip
+  BL2_BOOTDEV:=sdmmc
+  BL2_SOC:=mt7987
+  BL2_DDRTYPE:=comb
+  DEPENDS:=+trusted-firmware-a-mt7987-sdmmc-comb
+endef
+
+define U-Boot/mt7987_bananapi_bpi-r4-lite-snand
+  NAME:=BananaPi BPi-R4 Lite
+  BUILD_SUBTARGET:=filogic
+  BUILD_DEVICES:=bananapi_bpi-r4-lite
+  UBOOT_CONFIG:=mt7987a_bpi-r4-lite-snand
+  UBOOT_IMAGE:=u-boot.fip
+  BL2_BOOTDEV:=spim-nand2-ubi
+  BL2_SOC:=mt7987
+  BL2_DDRTYPE:=comb
+  DEPENDS:=+trusted-firmware-a-mt7987-spim-nand2-ubi-comb
+endef
+
+define U-Boot/mt7987_bananapi_bpi-r4-lite-nor
+  NAME:=BananaPi BPi-R4 Lite
+  BUILD_SUBTARGET:=filogic
+  BUILD_DEVICES:=bananapi_bpi-r4-lite
+  UBOOT_CONFIG:=mt7987a_bpi-r4-lite-nor
+  UBOOT_IMAGE:=u-boot.fip
+  BL2_BOOTDEV:=nor
+  BL2_SOC:=mt7987
+  BL2_DDRTYPE:=comb
+  DEPENDS:=+trusted-firmware-a-mt7987-nor-comb
+  FIP_COMPRESS:=1
+endef
+
 define U-Boot/mt7988_arcadyan_mozart
   NAME:=Arcadyan Mozart
   BUILD_SUBTARGET:=filogic
@@ -857,6 +906,42 @@ define U-Boot/mt7988_bananapi_bpi-r4-poe
   DEPENDS:=+trusted-firmware-a-mt7988-spim-nand-ubi-comb
 endef
 
+define U-Boot/mt7987_rfb-emmc
+  NAME:=MT7987 Reference Board
+  BUILD_SUBTARGET:=filogic
+  BUILD_DEVICES:=mediatek_mt7987a-rfb
+  UBOOT_CONFIG:=mt7987_emmc_rfb
+  UBOOT_IMAGE:=u-boot.fip
+  BL2_BOOTDEV:=sdmmc
+  BL2_SOC:=mt7987
+  BL2_DDRTYPE:=comb
+  DEPENDS:=+trusted-firmware-a-mt7987-emmc-comb
+endef
+
+define U-Boot/mt7987_rfb-spim-nand
+  NAME:=MT7987 Reference Board
+  BUILD_SUBTARGET:=filogic
+  BUILD_DEVICES:=mediatek_mt7987a-rfb
+  UBOOT_CONFIG:=mt7987_rfb
+  UBOOT_IMAGE:=u-boot.fip
+  BL2_BOOTDEV:=spim-nand0-ubi
+  BL2_SOC:=mt7987
+  BL2_DDRTYPE:=comb
+  DEPENDS:=+trusted-firmware-a-mt7987-spim-nand0-ubi-comb
+endef
+
+define U-Boot/mt7987_rfb-sd
+  NAME:=MT7987 Reference Board
+  BUILD_SUBTARGET:=filogic
+  BUILD_DEVICES:=mediatek_mt7987a-rfb
+  UBOOT_CONFIG:=mt7987_sd_rfb
+  UBOOT_IMAGE:=u-boot.fip
+  BL2_BOOTDEV:=sdmmc
+  BL2_SOC:=mt7987
+  BL2_DDRTYPE:=comb
+  DEPENDS:=+trusted-firmware-a-mt7987-sdmmc-comb
+endef
+
 define U-Boot/mt7988_rfb-spim-nand
   NAME:=MT7988 Reference Board
   BUILD_SUBTARGET:=filogic
@@ -983,6 +1068,13 @@ UBOOT_TARGETS := \
 	mt7986_xiaomi_redmi-router-ax6000 \
 	mt7986_zyxel_ex5601-t0 \
 	mt7986_rfb \
+	mt7987_bananapi_bpi-r4-lite-emmc \
+	mt7987_bananapi_bpi-r4-lite-sdmmc \
+	mt7987_bananapi_bpi-r4-lite-snand \
+	mt7987_bananapi_bpi-r4-lite-nor \
+	mt7987_rfb-emmc \
+	mt7987_rfb-sd \
+	mt7987_rfb-spim-nand \
 	mt7988_arcadyan_mozart \
 	mt7988_asus_zenwifi-bt8 \
 	mt7988_bananapi_bpi-r4-emmc \
--- /dev/null
+++ b/package/boot/uboot-mediatek/patches/007-ARM-dts-build-DT-for-MT7987-RFB.patch
@@ -0,0 +1,26 @@
+From a4d4096d6b80a2b6f5bc800426380cdc60d9b037 Mon Sep 17 00:00:00 2001
+From: Daniel Golle <daniel@makrotopia.org>
+Date: Thu, 2 Oct 2025 14:57:16 +0100
+Subject: [PATCH] ARM: dts: build DT for MT7987 RFB
+
+Compile the added device tree sources into blobs, which was forgotten
+when adding the source files.
+
+Fixes: 2d6962e0618 (arm: mediatek: add support for MediaTek MT7987 SoC)
+Signed-off-by: Daniel Golle <daniel@makrotopia.org>
+---
+ arch/arm/dts/Makefile | 3 +++
+ 1 file changed, 3 insertions(+)
+
+--- a/arch/arm/dts/Makefile
++++ b/arch/arm/dts/Makefile
+@@ -1131,6 +1131,9 @@ dtb-$(CONFIG_ARCH_MEDIATEK) += \
+ 	mt7986b-sd-rfb.dtb \
+ 	mt7986a-emmc-rfb.dtb \
+ 	mt7986b-emmc-rfb.dtb \
++	mt7987a-emmc-rfb.dtb \
++	mt7987a-rfb.dtb \
++	mt7987a-sd-rfb.dtb \
+ 	mt7988-rfb.dtb \
+ 	mt7988-sd-rfb.dtb \
+ 	mt8183-pumpkin.dtb \
--- /dev/null
+++ b/package/boot/uboot-mediatek/patches/306-mt7987-generic-reset-button-ignore-env.patch
@@ -0,0 +1,40 @@
+--- a/board/mediatek/mt7987/mt7987_rfb.c
++++ b/board/mediatek/mt7987/mt7987_rfb.c
+@@ -4,3 +4,37 @@
+  * Author: Sam Shih <sam.shih@mediatek.com>
+  */
+ 
++#include <config.h>
++#include <dm.h>
++#include <button.h>
++#include <env.h>
++#include <init.h>
++#include <asm/global_data.h>
++#include <linux/delay.h>
++
++#ifndef CONFIG_RESET_BUTTON_LABEL
++#define CONFIG_RESET_BUTTON_LABEL "reset"
++#endif
++
++int board_late_init(void)
++{
++	gd->env_valid = 1; //to load environment variable from persistent store
++	struct udevice *dev;
++
++	gd->env_valid = ENV_VALID;
++	if (!button_get_by_label(CONFIG_RESET_BUTTON_LABEL, &dev)) {
++		puts("reset button found\n");
++#ifdef CONFIG_RESET_BUTTON_SETTLE_DELAY
++		if (CONFIG_RESET_BUTTON_SETTLE_DELAY > 0) {
++			button_get_state(dev);
++			mdelay(CONFIG_RESET_BUTTON_SETTLE_DELAY);
++		}
++#endif
++		if (button_get_state(dev) == BUTTON_ON) {
++			puts("button pushed, resetting environment\n");
++			gd->env_valid = ENV_INVALID;
++		}
++	}
++	env_relocate();
++	return 0;
++}
--- /dev/null
+++ b/package/boot/uboot-mediatek/patches/315-mt7987-select-rootdisk.patch
@@ -0,0 +1,67 @@
+--- a/board/mediatek/mt7987/mt7987_rfb.c
++++ b/board/mediatek/mt7987/mt7987_rfb.c
+@@ -10,7 +10,9 @@
+ #include <env.h>
+ #include <init.h>
+ #include <asm/global_data.h>
++#include <asm/io.h>
+ #include <linux/delay.h>
++#include <linux/libfdt.h>
+ 
+ #ifndef CONFIG_RESET_BUTTON_LABEL
+ #define CONFIG_RESET_BUTTON_LABEL "reset"
+@@ -38,3 +40,54 @@ int board_late_init(void)
+ 	env_relocate();
+ 	return 0;
+ }
++
++#define	MT7987_BOOT_SD		0
++#define	MT7987_BOOT_NOR		1
++#define	MT7987_BOOT_SPIM_NAND	2
++#define	MT7987_BOOT_EMMC	3
++
++int mtk_ft_system_setup(void *blob, struct bd_info *bd)
++{
++	const u32 *media_handle_p;
++	int chosen, len, ret;
++	const char *media;
++	u32 media_handle;
++
++	switch ((readl(0x1001f6f0) & 0xc0) >> 6) {
++	case MT7987_BOOT_SD:
++		media = "rootdisk-sd";
++		break
++		;;
++	case MT7987_BOOT_NOR:
++		media = "rootdisk-nor";
++		break
++		;;
++	case MT7987_BOOT_SPIM_NAND:
++		media = "rootdisk-spim-nand";
++		break
++		;;
++	case MT7987_BOOT_EMMC:
++		media = "rootdisk-emmc";
++		break
++		;;
++	}
++
++	chosen = fdt_path_offset(blob, "/chosen");
++	if (chosen <= 0)
++		return 0;
++
++	media_handle_p = fdt_getprop(blob, chosen, media, &len);
++	if (media_handle_p <= 0 || len != 4)
++		return 0;
++
++	media_handle = *media_handle_p;
++	ret = fdt_setprop(blob, chosen, "rootdisk", &media_handle, sizeof(media_handle));
++	if (ret) {
++		printf("cannot set media phandle %s as rootdisk /chosen node\n", media);
++		return ret;
++	}
++
++	printf("set /chosen/rootdisk to bootrom media: %s (phandle 0x%08x)\n", media, fdt32_to_cpu(media_handle));
++
++	return 0;
++}
--- /dev/null
+++ b/package/boot/uboot-mediatek/patches/500-adapt-mt7987-rfb.patch
@@ -0,0 +1,30 @@
+--- a/configs/mt7987_rfb_defconfig
++++ b/configs/mt7987_rfb_defconfig
+@@ -70,6 +70,7 @@ CONFIG_SPI_FLASH_XTX=y
+ CONFIG_SPI_FLASH_ZBIT=y
+ CONFIG_SPI_FLASH_MTD=y
+ CONFIG_MTD_UBI=y
++CONFIG_OF_LIBFDT_OVERLAY=y
+ CONFIG_PHY_ETHERNET_ID=y
+ CONFIG_MEDIATEK_ETH=y
+ CONFIG_PINCTRL=y
+--- a/configs/mt7987_emmc_rfb_defconfig
++++ b/configs/mt7987_emmc_rfb_defconfig
+@@ -75,6 +75,7 @@ CONFIG_SPI_FLASH_XTX=y
+ CONFIG_SPI_FLASH_ZBIT=y
+ CONFIG_SPI_FLASH_MTD=y
+ CONFIG_MTD_UBI=y
++CONFIG_OF_LIBFDT_OVERLAY=y
+ CONFIG_PHY_ETHERNET_ID=y
+ CONFIG_MEDIATEK_ETH=y
+ CONFIG_PINCTRL=y
+--- a/configs/mt7987_sd_rfb_defconfig
++++ b/configs/mt7987_sd_rfb_defconfig
+@@ -75,6 +75,7 @@ CONFIG_SPI_FLASH_XTX=y
+ CONFIG_SPI_FLASH_ZBIT=y
+ CONFIG_SPI_FLASH_MTD=y
+ CONFIG_MTD_UBI=y
++CONFIG_OF_LIBFDT_OVERLAY=y
+ CONFIG_PHY_ETHERNET_ID=y
+ CONFIG_MEDIATEK_ETH=y
+ CONFIG_PINCTRL=y
--- a/target/linux/mediatek/filogic/config-6.12
+++ b/target/linux/mediatek/filogic/config-6.12
@@ -72,6 +72,7 @@ CONFIG_COMMON_CLK_MT7981=y
 CONFIG_COMMON_CLK_MT7981_ETHSYS=y
 CONFIG_COMMON_CLK_MT7986=y
 CONFIG_COMMON_CLK_MT7986_ETHSYS=y
+CONFIG_COMMON_CLK_MT7987=y
 CONFIG_COMMON_CLK_MT7988=y
 # CONFIG_COMMON_CLK_MT8173 is not set
 # CONFIG_COMMON_CLK_MT8183 is not set
@@ -394,6 +395,7 @@ CONFIG_PINCTRL=y
 # CONFIG_PINCTRL_MT7622 is not set
 CONFIG_PINCTRL_MT7981=y
 CONFIG_PINCTRL_MT7986=y
+CONFIG_PINCTRL_MT7987=y
 CONFIG_PINCTRL_MT7988=y
 # CONFIG_PINCTRL_MT8173 is not set
 # CONFIG_PINCTRL_MT8183 is not set
--- a/target/linux/mediatek/mt7622/config-6.12
+++ b/target/linux/mediatek/mt7622/config-6.12
@@ -80,6 +80,7 @@ CONFIG_COMMON_CLK_MT7622_ETHSYS=y
 CONFIG_COMMON_CLK_MT7622_HIFSYS=y
 # CONFIG_COMMON_CLK_MT7981 is not set
 # CONFIG_COMMON_CLK_MT7986 is not set
+# CONFIG_COMMON_CLK_MT7987 is not set
 # CONFIG_COMMON_CLK_MT7988 is not set
 # CONFIG_COMMON_CLK_MT8173 is not set
 # CONFIG_COMMON_CLK_MT8183 is not set
@@ -384,6 +385,7 @@ CONFIG_PINCTRL=y
 CONFIG_PINCTRL_MT7622=y
 # CONFIG_PINCTRL_MT7981 is not set
 # CONFIG_PINCTRL_MT7986 is not set
+# CONFIG_PINCTRL_MT7987 is not set
 # CONFIG_PINCTRL_MT7988 is not set
 # CONFIG_PINCTRL_MT8173 is not set
 # CONFIG_PINCTRL_MT8183 is not set
--- a/target/linux/mediatek/mt7623/config-6.12
+++ b/target/linux/mediatek/mt7623/config-6.12
@@ -80,6 +80,7 @@ CONFIG_COMMON_CLK_MT2701_VDECSYS=y
 # CONFIG_COMMON_CLK_MT7629 is not set
 # CONFIG_COMMON_CLK_MT7981 is not set
 # CONFIG_COMMON_CLK_MT7986 is not set
+# CONFIG_COMMON_CLK_MT7987 is not set
 # CONFIG_COMMON_CLK_MT7988 is not set
 # CONFIG_COMMON_CLK_MT8135 is not set
 # CONFIG_COMMON_CLK_MT8365 is not set
--- a/target/linux/mediatek/mt7629/config-6.12
+++ b/target/linux/mediatek/mt7629/config-6.12
@@ -58,6 +58,7 @@ CONFIG_COMMON_CLK_MT7629_ETHSYS=y
 CONFIG_COMMON_CLK_MT7629_HIFSYS=y
 # CONFIG_COMMON_CLK_MT7981 is not set
 # CONFIG_COMMON_CLK_MT7986 is not set
+# CONFIG_COMMON_CLK_MT7987 is not set
 # CONFIG_COMMON_CLK_MT7988 is not set
 # CONFIG_COMMON_CLK_MT8135 is not set
 # CONFIG_COMMON_CLK_MT8365 is not set
--- /dev/null
+++ b/target/linux/mediatek/patches-6.12/360-pinctrl-mediatek-add-mt7987-pinctrl-support.patch
@@ -0,0 +1,793 @@
+From e37d53fb387eb788dff33cdc4c1009543e2ccd5f Mon Sep 17 00:00:00 2001
+From: Sam Shih <sam.shih@mediatek.com>
+Date: Mon, 20 Jan 2025 19:49:34 +0800
+Subject: [PATCH 1/2] pinctrl: mediatek: add mt7987 pinctrl support
+
+Signed-off-by: Daniel Golle <daniel@makrotopia.org>
+---
+ drivers/pinctrl/mediatek/Kconfig          |   6 +
+ drivers/pinctrl/mediatek/Makefile         |   1 +
+ drivers/pinctrl/mediatek/pinctrl-mt7987.c | 752 ++++++++++++++++++++++
+ 3 files changed, 759 insertions(+)
+ create mode 100644 drivers/pinctrl/mediatek/pinctrl-mt7987.c
+
+--- a/drivers/pinctrl/mediatek/Kconfig
++++ b/drivers/pinctrl/mediatek/Kconfig
+@@ -187,6 +187,13 @@ config PINCTRL_MT7986
+ 	default ARM64 && ARCH_MEDIATEK
+ 	select PINCTRL_MTK_MOORE
+ 
++config PINCTRL_MT7987
++	bool "Mediatek MT7987 pin control"
++	depends on OF
++	depends on ARM64 || COMPILE_TEST
++	default ARM64 && ARCH_MEDIATEK
++	select PINCTRL_MTK_MOORE
++
+ config PINCTRL_MT7988
+ 	bool "Mediatek MT7988 pin control"
+ 	depends on OF
+--- a/drivers/pinctrl/mediatek/Makefile
++++ b/drivers/pinctrl/mediatek/Makefile
+@@ -27,6 +27,7 @@ obj-$(CONFIG_PINCTRL_MT7623)		+= pinctrl
+ obj-$(CONFIG_PINCTRL_MT7629)		+= pinctrl-mt7629.o
+ obj-$(CONFIG_PINCTRL_MT7981)		+= pinctrl-mt7981.o
+ obj-$(CONFIG_PINCTRL_MT7986)		+= pinctrl-mt7986.o
++obj-$(CONFIG_PINCTRL_MT7987)		+= pinctrl-mt7987.o
+ obj-$(CONFIG_PINCTRL_MT7988)		+= pinctrl-mt7988.o
+ obj-$(CONFIG_PINCTRL_MT8167)		+= pinctrl-mt8167.o
+ obj-$(CONFIG_PINCTRL_MT8173)		+= pinctrl-mt8173.o
+--- /dev/null
++++ b/drivers/pinctrl/mediatek/pinctrl-mt7987.c
+@@ -0,0 +1,751 @@
++// SPDX-License-Identifier: GPL-2.0
++/*
++ * The MT7987 driver based on Linux generic pinctrl binding.
++ *
++ * Copyright (C) 2020 MediaTek Inc.
++ * Author: Tim.Kuo <Tim.Kuo@mediatek.com>
++ */
++
++#include "pinctrl-moore.h"
++
++enum MT7987_PINCTRL_REG_PAGE {
++	GPIO_BASE,
++	IOCFG_RB_BASE,
++	IOCFG_LB_BASE,
++	IOCFG_RT1_BASE,
++	IOCFG_RT2_BASE,
++	IOCFG_TL_BASE,
++};
++
++#define MT7987_PIN(_number, _name) MTK_PIN(_number, _name, 0, _number, DRV_GRP4)
++
++#define PIN_FIELD_BASE(_s_pin, _e_pin, _i_base, _s_addr, _x_addrs, _s_bit,     \
++		       _x_bits)                                                \
++	PIN_FIELD_CALC(_s_pin, _e_pin, _i_base, _s_addr, _x_addrs, _s_bit,     \
++		       _x_bits, 32, 0)
++
++#define PIN_FIELD_BASE(_s_pin, _e_pin, _i_base, _s_addr, _x_addrs, _s_bit,     \
++		       _x_bits)                                                \
++	PIN_FIELD_CALC(_s_pin, _e_pin, _i_base, _s_addr, _x_addrs, _s_bit,     \
++		       _x_bits, 32, 0)
++
++
++#define PINS_FIELD_BASE(_s_pin, _e_pin, _i_base, _s_addr, _x_addrs, _s_bit,    \
++			_x_bits)                                               \
++	PIN_FIELD_CALC(_s_pin, _e_pin, _i_base, _s_addr, _x_addrs, _s_bit,     \
++		       _x_bits, 32, 1)
++
++static const struct mtk_pin_field_calc mt7987_pin_mode_range[] = {
++	PIN_FIELD(0, 49, 0x300, 0x10, 0, 4),
++};
++
++static const struct mtk_pin_field_calc mt7987_pin_dir_range[] = {
++	PIN_FIELD(0, 49, 0x0, 0x10, 0, 1),
++};
++
++static const struct mtk_pin_field_calc mt7987_pin_di_range[] = {
++	PIN_FIELD(0, 49, 0x200, 0x10, 0, 1),
++};
++
++static const struct mtk_pin_field_calc mt7987_pin_do_range[] = {
++	PIN_FIELD(0, 49, 0x100, 0x10, 0, 1),
++};
++
++static const struct mtk_pin_field_calc mt7987_pin_ies_range[] = {
++	PIN_FIELD_BASE(0, 0, IOCFG_RT2_BASE, 0x20, 0x10, 3, 1),
++	PIN_FIELD_BASE(1, 1, IOCFG_RT2_BASE, 0x20, 0x10, 2, 1),
++	PIN_FIELD_BASE(2, 2, IOCFG_RT2_BASE, 0x20, 0x10, 11, 1),
++	PIN_FIELD_BASE(3, 3, IOCFG_TL_BASE, 0x20, 0x10, 2, 1),
++	PIN_FIELD_BASE(4, 4, IOCFG_TL_BASE, 0x20, 0x10, 1, 1),
++	PIN_FIELD_BASE(5, 5, IOCFG_TL_BASE, 0x20, 0x10, 3, 1),
++	PIN_FIELD_BASE(6, 6, IOCFG_TL_BASE, 0x20, 0x10, 0, 1),
++	PIN_FIELD_BASE(7, 7, IOCFG_TL_BASE, 0x20, 0x10, 4, 1),
++	PIN_FIELD_BASE(8, 8, IOCFG_RB_BASE, 0x10, 0x10, 2, 1),
++	PIN_FIELD_BASE(9, 9, IOCFG_RB_BASE, 0x10, 0x10, 1, 1),
++	PIN_FIELD_BASE(10, 10, IOCFG_RB_BASE, 0x10, 0x10, 0, 1),
++	PIN_FIELD_BASE(11, 11, IOCFG_RB_BASE, 0x10, 0x10, 3, 1),
++	PIN_FIELD_BASE(12, 12, IOCFG_RB_BASE, 0x10, 0x10, 4, 1),
++	PIN_FIELD_BASE(13, 13, IOCFG_RT1_BASE, 0x20, 0x10, 0, 1),
++	PIN_FIELD_BASE(14, 14, IOCFG_RT1_BASE, 0x20, 0x10, 15, 1),
++	PIN_FIELD_BASE(15, 15, IOCFG_RT1_BASE, 0x20, 0x10, 3, 1),
++	PIN_FIELD_BASE(16, 16, IOCFG_RT1_BASE, 0x20, 0x10, 7, 1),
++	PIN_FIELD_BASE(17, 17, IOCFG_RT1_BASE, 0x20, 0x10, 6, 1),
++	PIN_FIELD_BASE(18, 18, IOCFG_RT1_BASE, 0x20, 0x10, 4, 1),
++	PIN_FIELD_BASE(19, 19, IOCFG_RT1_BASE, 0x20, 0x10, 5, 1),
++	PIN_FIELD_BASE(20, 20, IOCFG_RT1_BASE, 0x20, 0x10, 8, 1),
++	PIN_FIELD_BASE(21, 21, IOCFG_RT1_BASE, 0x20, 0x10, 9, 1),
++	PIN_FIELD_BASE(22, 22, IOCFG_RT1_BASE, 0x20, 0x10, 12, 1),
++	PIN_FIELD_BASE(23, 23, IOCFG_RT1_BASE, 0x20, 0x10, 11, 1),
++	PIN_FIELD_BASE(24, 24, IOCFG_RT1_BASE, 0x20, 0x10, 10, 1),
++	PIN_FIELD_BASE(25, 25, IOCFG_RT1_BASE, 0x20, 0x10, 13, 1),
++	PIN_FIELD_BASE(26, 26, IOCFG_RT1_BASE, 0x20, 0x10, 14, 1),
++	PIN_FIELD_BASE(27, 27, IOCFG_RT2_BASE, 0x20, 0x10, 9, 1),
++	PIN_FIELD_BASE(28, 28, IOCFG_RT2_BASE, 0x20, 0x10, 7, 1),
++	PIN_FIELD_BASE(29, 29, IOCFG_RT2_BASE, 0x20, 0x10, 8, 1),
++	PIN_FIELD_BASE(30, 30, IOCFG_RT2_BASE, 0x20, 0x10, 10, 1),
++	PIN_FIELD_BASE(31, 31, IOCFG_TL_BASE, 0x20, 0x10, 5, 1),
++	PIN_FIELD_BASE(32, 32, IOCFG_TL_BASE, 0x20, 0x10, 6, 1),
++	PIN_FIELD_BASE(33, 33, IOCFG_LB_BASE, 0x20, 0x10, 2, 1),
++	PIN_FIELD_BASE(34, 34, IOCFG_LB_BASE, 0x20, 0x10, 0, 1),
++	PIN_FIELD_BASE(35, 35, IOCFG_LB_BASE, 0x20, 0x10, 4, 1),
++	PIN_FIELD_BASE(36, 36, IOCFG_LB_BASE, 0x20, 0x10, 3, 1),
++	PIN_FIELD_BASE(37, 37, IOCFG_LB_BASE, 0x20, 0x10, 1, 1),
++	PIN_FIELD_BASE(38, 38, IOCFG_LB_BASE, 0x20, 0x10, 5, 1),
++	PIN_FIELD_BASE(39, 39, IOCFG_RT1_BASE, 0x20, 0x10, 1, 1),
++	PIN_FIELD_BASE(40, 40, IOCFG_RT1_BASE, 0x20, 0x10, 2, 1),
++	PIN_FIELD_BASE(41, 41, IOCFG_RT2_BASE, 0x20, 0x10, 0, 1),
++	PIN_FIELD_BASE(42, 42, IOCFG_RT2_BASE, 0x20, 0x10, 1, 1),
++	PIN_FIELD_BASE(43, 43, IOCFG_RT2_BASE, 0x20, 0x10, 4, 1),
++	PIN_FIELD_BASE(44, 44, IOCFG_RT2_BASE, 0x20, 0x10, 5, 1),
++	PIN_FIELD_BASE(45, 45, IOCFG_RT2_BASE, 0x20, 0x10, 6, 1),
++	PIN_FIELD_BASE(46, 46, IOCFG_TL_BASE, 0x20, 0x10, 9, 1),
++	PIN_FIELD_BASE(47, 47, IOCFG_TL_BASE, 0x20, 0x10, 10, 1),
++	PIN_FIELD_BASE(48, 48, IOCFG_TL_BASE, 0x20, 0x10, 7, 1),
++	PIN_FIELD_BASE(49, 49, IOCFG_TL_BASE, 0x20, 0x10, 8, 1),
++};
++
++static const struct mtk_pin_field_calc mt7987_pin_smt_range[] = {
++	PIN_FIELD_BASE(0, 0, IOCFG_RT2_BASE, 0x90, 0x10, 3, 1),
++	PIN_FIELD_BASE(1, 1, IOCFG_RT2_BASE, 0x90, 0x10, 2, 1),
++	PIN_FIELD_BASE(2, 2, IOCFG_RT2_BASE, 0x90, 0x10, 11, 1),
++	PIN_FIELD_BASE(3, 3, IOCFG_TL_BASE, 0x90, 0x10, 2, 1),
++	PIN_FIELD_BASE(4, 4, IOCFG_TL_BASE, 0x90, 0x10, 1, 1),
++	PIN_FIELD_BASE(5, 5, IOCFG_TL_BASE, 0x90, 0x10, 3, 1),
++	PIN_FIELD_BASE(6, 6, IOCFG_TL_BASE, 0x90, 0x10, 0, 1),
++	PIN_FIELD_BASE(7, 7, IOCFG_TL_BASE, 0x90, 0x10, 4, 1),
++	PIN_FIELD_BASE(8, 8, IOCFG_RB_BASE, 0x70, 0x10, 2, 1),
++	PIN_FIELD_BASE(9, 9, IOCFG_RB_BASE, 0x70, 0x10, 1, 1),
++	PIN_FIELD_BASE(10, 10, IOCFG_RB_BASE, 0x70, 0x10, 0, 1),
++	PIN_FIELD_BASE(11, 11, IOCFG_RB_BASE, 0x70, 0x10, 3, 1),
++	PIN_FIELD_BASE(12, 12, IOCFG_RB_BASE, 0x70, 0x10, 4, 1),
++	PIN_FIELD_BASE(13, 13, IOCFG_RT1_BASE, 0xA0, 0x10, 0, 1),
++	PIN_FIELD_BASE(14, 14, IOCFG_RT1_BASE, 0xA0, 0x10, 15, 1),
++	PIN_FIELD_BASE(15, 15, IOCFG_RT1_BASE, 0xA0, 0x10, 3, 1),
++	PIN_FIELD_BASE(16, 16, IOCFG_RT1_BASE, 0xA0, 0x10, 7, 1),
++	PIN_FIELD_BASE(17, 17, IOCFG_RT1_BASE, 0xA0, 0x10, 6, 1),
++	PIN_FIELD_BASE(18, 18, IOCFG_RT1_BASE, 0xA0, 0x10, 4, 1),
++	PIN_FIELD_BASE(19, 19, IOCFG_RT1_BASE, 0xA0, 0x10, 5, 1),
++	PIN_FIELD_BASE(20, 20, IOCFG_RT1_BASE, 0xA0, 0x10, 8, 1),
++	PIN_FIELD_BASE(21, 21, IOCFG_RT1_BASE, 0xA0, 0x10, 9, 1),
++	PIN_FIELD_BASE(22, 22, IOCFG_RT1_BASE, 0xA0, 0x10, 12, 1),
++	PIN_FIELD_BASE(23, 23, IOCFG_RT1_BASE, 0xA0, 0x10, 11, 1),
++	PIN_FIELD_BASE(24, 24, IOCFG_RT1_BASE, 0xA0, 0x10, 10, 1),
++	PIN_FIELD_BASE(25, 25, IOCFG_RT1_BASE, 0xA0, 0x10, 13, 1),
++	PIN_FIELD_BASE(26, 26, IOCFG_RT1_BASE, 0xA0, 0x10, 14, 1),
++	PIN_FIELD_BASE(27, 27, IOCFG_RT2_BASE, 0x90, 0x10, 9, 1),
++	PIN_FIELD_BASE(28, 28, IOCFG_RT2_BASE, 0x90, 0x10, 7, 1),
++	PIN_FIELD_BASE(29, 29, IOCFG_RT2_BASE, 0x90, 0x10, 8, 1),
++	PIN_FIELD_BASE(30, 30, IOCFG_RT2_BASE, 0x90, 0x10, 10, 1),
++	PIN_FIELD_BASE(31, 31, IOCFG_TL_BASE, 0x90, 0x10, 5, 1),
++	PIN_FIELD_BASE(32, 32, IOCFG_TL_BASE, 0x90, 0x10, 6, 1),
++	PIN_FIELD_BASE(33, 33, IOCFG_LB_BASE, 0x60, 0x10, 2, 1),
++	PIN_FIELD_BASE(34, 34, IOCFG_LB_BASE, 0x60, 0x10, 0, 1),
++	PIN_FIELD_BASE(35, 35, IOCFG_LB_BASE, 0x60, 0x10, 4, 1),
++	PIN_FIELD_BASE(36, 36, IOCFG_LB_BASE, 0x60, 0x10, 3, 1),
++	PIN_FIELD_BASE(37, 37, IOCFG_LB_BASE, 0x60, 0x10, 1, 1),
++	PIN_FIELD_BASE(38, 38, IOCFG_LB_BASE, 0x60, 0x10, 5, 1),
++	PIN_FIELD_BASE(39, 39, IOCFG_RT1_BASE, 0xA0, 0x10, 1, 1),
++	PIN_FIELD_BASE(40, 40, IOCFG_RT1_BASE, 0xA0, 0x10, 2, 1),
++	PIN_FIELD_BASE(41, 41, IOCFG_RT2_BASE, 0x90, 0x10, 0, 1),
++	PIN_FIELD_BASE(42, 42, IOCFG_RT2_BASE, 0x90, 0x10, 1, 1),
++	PIN_FIELD_BASE(43, 43, IOCFG_RT2_BASE, 0x90, 0x10, 4, 1),
++	PIN_FIELD_BASE(44, 44, IOCFG_RT2_BASE, 0x90, 0x10, 5, 1),
++	PIN_FIELD_BASE(45, 45, IOCFG_RT2_BASE, 0x90, 0x10, 6, 1),
++	PIN_FIELD_BASE(46, 46, IOCFG_TL_BASE, 0x90, 0x10, 9, 1),
++	PIN_FIELD_BASE(47, 47, IOCFG_TL_BASE, 0x90, 0x10, 10, 1),
++	PIN_FIELD_BASE(48, 48, IOCFG_TL_BASE, 0x90, 0x10, 7, 1),
++	PIN_FIELD_BASE(49, 49, IOCFG_TL_BASE, 0x90, 0x10, 8, 1),
++};
++
++static const struct mtk_pin_field_calc mt7987_pin_pu_range[] = {
++	PIN_FIELD_BASE(33, 33, IOCFG_LB_BASE, 0x40, 0x10, 2, 1),
++	PIN_FIELD_BASE(34, 34, IOCFG_LB_BASE, 0x40, 0x10, 0, 1),
++	PIN_FIELD_BASE(35, 35, IOCFG_LB_BASE, 0x40, 0x10, 4, 1),
++	PIN_FIELD_BASE(36, 36, IOCFG_LB_BASE, 0x40, 0x10, 3, 1),
++	PIN_FIELD_BASE(37, 37, IOCFG_LB_BASE, 0x40, 0x10, 1, 1),
++	PIN_FIELD_BASE(38, 38, IOCFG_LB_BASE, 0x40, 0x10, 5, 1),
++};
++
++static const struct mtk_pin_field_calc mt7987_pin_pd_range[] = {
++	PIN_FIELD_BASE(33, 33, IOCFG_LB_BASE, 0x30, 0x10, 2, 1),
++	PIN_FIELD_BASE(34, 34, IOCFG_LB_BASE, 0x30, 0x10, 0, 1),
++	PIN_FIELD_BASE(35, 35, IOCFG_LB_BASE, 0x30, 0x10, 4, 1),
++	PIN_FIELD_BASE(36, 36, IOCFG_LB_BASE, 0x30, 0x10, 3, 1),
++	PIN_FIELD_BASE(37, 37, IOCFG_LB_BASE, 0x30, 0x10, 1, 1),
++	PIN_FIELD_BASE(38, 38, IOCFG_LB_BASE, 0x30, 0x10, 5, 1),
++};
++
++static const struct mtk_pin_field_calc mt7987_pin_drv_range[] = {
++	PIN_FIELD_BASE(0, 0, IOCFG_RT2_BASE, 0x0, 0x10, 9, 3),
++	PIN_FIELD_BASE(1, 1, IOCFG_RT2_BASE, 0x0, 0x10, 6, 3),
++	PIN_FIELD_BASE(2, 2, IOCFG_RT2_BASE, 0x10, 0x10, 3, 3),
++	PIN_FIELD_BASE(3, 3, IOCFG_TL_BASE, 0x0, 0x10, 6, 3),
++	PIN_FIELD_BASE(4, 4, IOCFG_TL_BASE, 0x0, 0x10, 3, 3),
++	PIN_FIELD_BASE(5, 5, IOCFG_TL_BASE, 0x0, 0x10, 9, 3),
++	PIN_FIELD_BASE(6, 6, IOCFG_TL_BASE, 0x0, 0x10, 0, 3),
++	PIN_FIELD_BASE(7, 7, IOCFG_TL_BASE, 0x0, 0x10, 12, 3),
++	PIN_FIELD_BASE(8, 8, IOCFG_RB_BASE, 0x0, 0x10, 6, 3),
++	PIN_FIELD_BASE(9, 9, IOCFG_RB_BASE, 0x0, 0x10, 3, 3),
++	PIN_FIELD_BASE(10, 10, IOCFG_RB_BASE, 0x0, 0x10, 0, 3),
++	PIN_FIELD_BASE(11, 11, IOCFG_RB_BASE, 0x0, 0x10, 9, 3),
++	PIN_FIELD_BASE(12, 12, IOCFG_RB_BASE, 0x0, 0x10, 12, 3),
++	PIN_FIELD_BASE(13, 13, IOCFG_RT1_BASE, 0x0, 0x10, 0, 3),
++	PIN_FIELD_BASE(14, 14, IOCFG_RT1_BASE, 0x10, 0x10, 15, 3),
++	PIN_FIELD_BASE(15, 15, IOCFG_RT1_BASE, 0x0, 0x10, 9, 3),
++	PIN_FIELD_BASE(16, 16, IOCFG_RT1_BASE, 0x0, 0x10, 21, 3),
++	PIN_FIELD_BASE(17, 17, IOCFG_RT1_BASE, 0x0, 0x10, 18, 3),
++	PIN_FIELD_BASE(18, 18, IOCFG_RT1_BASE, 0x0, 0x10, 12, 3),
++	PIN_FIELD_BASE(19, 19, IOCFG_RT1_BASE, 0x0, 0x10, 15, 3),
++	PIN_FIELD_BASE(20, 20, IOCFG_RT1_BASE, 0x0, 0x10, 24, 3),
++	PIN_FIELD_BASE(21, 21, IOCFG_RT1_BASE, 0x0, 0x10, 27, 3),
++	PIN_FIELD_BASE(22, 22, IOCFG_RT1_BASE, 0x10, 0x10, 6, 3),
++	PIN_FIELD_BASE(23, 23, IOCFG_RT1_BASE, 0x10, 0x10, 3, 3),
++	PIN_FIELD_BASE(24, 24, IOCFG_RT1_BASE, 0x10, 0x10, 0, 3),
++	PIN_FIELD_BASE(25, 25, IOCFG_RT1_BASE, 0x10, 0x10, 9, 3),
++	PIN_FIELD_BASE(26, 26, IOCFG_RT1_BASE, 0x10, 0x10, 12, 3),
++	PIN_FIELD_BASE(27, 27, IOCFG_RT2_BASE, 0x0, 0x10, 27, 3),
++	PIN_FIELD_BASE(28, 28, IOCFG_RT2_BASE, 0x0, 0x10, 21, 3),
++	PIN_FIELD_BASE(29, 29, IOCFG_RT2_BASE, 0x0, 0x10, 24, 3),
++	PIN_FIELD_BASE(30, 30, IOCFG_RT2_BASE, 0x10, 0x10, 0, 3),
++	PIN_FIELD_BASE(31, 31, IOCFG_TL_BASE, 0x0, 0x10, 15, 3),
++	PIN_FIELD_BASE(32, 32, IOCFG_TL_BASE, 0x0, 0x10, 18, 3),
++	PIN_FIELD_BASE(33, 33, IOCFG_LB_BASE, 0x0, 0x10, 6, 3),
++	PIN_FIELD_BASE(34, 34, IOCFG_LB_BASE, 0x0, 0x10, 0, 3),
++	PIN_FIELD_BASE(35, 35, IOCFG_LB_BASE, 0x0, 0x10, 12, 3),
++	PIN_FIELD_BASE(36, 36, IOCFG_LB_BASE, 0x0, 0x10, 9, 3),
++	PIN_FIELD_BASE(37, 37, IOCFG_LB_BASE, 0x0, 0x10, 3, 3),
++	PIN_FIELD_BASE(38, 38, IOCFG_LB_BASE, 0x0, 0x10, 15, 3),
++	PIN_FIELD_BASE(39, 39, IOCFG_RT1_BASE, 0x0, 0x10, 3, 3),
++	PIN_FIELD_BASE(40, 40, IOCFG_RT1_BASE, 0x0, 0x10, 6, 3),
++	PIN_FIELD_BASE(41, 41, IOCFG_RT2_BASE, 0x0, 0x10, 0, 3),
++	PIN_FIELD_BASE(42, 42, IOCFG_RT2_BASE, 0x0, 0x10, 3, 3),
++	PIN_FIELD_BASE(43, 43, IOCFG_RT2_BASE, 0x0, 0x10, 12, 3),
++	PIN_FIELD_BASE(44, 44, IOCFG_RT2_BASE, 0x0, 0x10, 15, 3),
++	PIN_FIELD_BASE(45, 45, IOCFG_RT2_BASE, 0x0, 0x10, 18, 3),
++	PIN_FIELD_BASE(46, 46, IOCFG_TL_BASE, 0x0, 0x10, 27, 3),
++	PIN_FIELD_BASE(47, 47, IOCFG_TL_BASE, 0x10, 0x10, 0, 3),
++	PIN_FIELD_BASE(48, 48, IOCFG_TL_BASE, 0x0, 0x10, 21, 3),
++	PIN_FIELD_BASE(49, 49, IOCFG_TL_BASE, 0x0, 0x10, 24, 3),
++};
++
++static const struct mtk_pin_field_calc mt7987_pin_pupd_range[] = {
++	PIN_FIELD_BASE(0, 0, IOCFG_RT2_BASE, 0x30, 0x10, 3, 1),
++	PIN_FIELD_BASE(1, 1, IOCFG_RT2_BASE, 0x30, 0x10, 2, 1),
++	PIN_FIELD_BASE(2, 2, IOCFG_RT2_BASE, 0x30, 0x10, 11, 1),
++	PIN_FIELD_BASE(3, 3, IOCFG_TL_BASE, 0x30, 0x10, 2, 1),
++	PIN_FIELD_BASE(4, 4, IOCFG_TL_BASE, 0x30, 0x10, 1, 1),
++	PIN_FIELD_BASE(5, 5, IOCFG_TL_BASE, 0x30, 0x10, 3, 1),
++	PIN_FIELD_BASE(6, 6, IOCFG_TL_BASE, 0x30, 0x10, 0, 1),
++	PIN_FIELD_BASE(7, 7, IOCFG_TL_BASE, 0x30, 0x10, 4, 1),
++	PIN_FIELD_BASE(8, 8, IOCFG_RB_BASE, 0x20, 0x10, 2, 1),
++	PIN_FIELD_BASE(9, 9, IOCFG_RB_BASE, 0x20, 0x10, 1, 1),
++	PIN_FIELD_BASE(10, 10, IOCFG_RB_BASE, 0x20, 0x10, 0, 1),
++	PIN_FIELD_BASE(11, 11, IOCFG_RB_BASE, 0x20, 0x10, 3, 1),
++	PIN_FIELD_BASE(12, 12, IOCFG_RB_BASE, 0x20, 0x10, 4, 1),
++	PIN_FIELD_BASE(13, 13, IOCFG_RT1_BASE, 0x30, 0x10, 0, 1),
++	PIN_FIELD_BASE(14, 14, IOCFG_RT1_BASE, 0x30, 0x10, 15, 1),
++	PIN_FIELD_BASE(15, 15, IOCFG_RT1_BASE, 0x30, 0x10, 3, 1),
++	PIN_FIELD_BASE(16, 16, IOCFG_RT1_BASE, 0x30, 0x10, 7, 1),
++	PIN_FIELD_BASE(17, 17, IOCFG_RT1_BASE, 0x30, 0x10, 6, 1),
++	PIN_FIELD_BASE(18, 18, IOCFG_RT1_BASE, 0x30, 0x10, 4, 1),
++	PIN_FIELD_BASE(19, 19, IOCFG_RT1_BASE, 0x30, 0x10, 5, 1),
++	PIN_FIELD_BASE(20, 20, IOCFG_RT1_BASE, 0x30, 0x10, 8, 1),
++	PIN_FIELD_BASE(21, 21, IOCFG_RT1_BASE, 0x30, 0x10, 9, 1),
++	PIN_FIELD_BASE(22, 22, IOCFG_RT1_BASE, 0x30, 0x10, 12, 1),
++	PIN_FIELD_BASE(23, 23, IOCFG_RT1_BASE, 0x30, 0x10, 11, 1),
++	PIN_FIELD_BASE(24, 24, IOCFG_RT1_BASE, 0x30, 0x10, 10, 1),
++	PIN_FIELD_BASE(25, 25, IOCFG_RT1_BASE, 0x30, 0x10, 13, 1),
++	PIN_FIELD_BASE(26, 26, IOCFG_RT1_BASE, 0x30, 0x10, 14, 1),
++	PIN_FIELD_BASE(27, 27, IOCFG_RT2_BASE, 0x30, 0x10, 9, 1),
++	PIN_FIELD_BASE(28, 28, IOCFG_RT2_BASE, 0x30, 0x10, 7, 1),
++	PIN_FIELD_BASE(29, 29, IOCFG_RT2_BASE, 0x30, 0x10, 8, 1),
++	PIN_FIELD_BASE(30, 30, IOCFG_RT2_BASE, 0x30, 0x10, 10, 1),
++	PIN_FIELD_BASE(31, 31, IOCFG_TL_BASE, 0x30, 0x10, 5, 1),
++	PIN_FIELD_BASE(32, 32, IOCFG_TL_BASE, 0x30, 0x10, 6, 1),
++
++	PIN_FIELD_BASE(39, 39, IOCFG_RT1_BASE, 0x30, 0x10, 1, 1),
++	PIN_FIELD_BASE(40, 40, IOCFG_RT1_BASE, 0x30, 0x10, 2, 1),
++	PIN_FIELD_BASE(41, 41, IOCFG_RT2_BASE, 0x30, 0x10, 0, 1),
++	PIN_FIELD_BASE(42, 42, IOCFG_RT2_BASE, 0x30, 0x10, 1, 1),
++	PIN_FIELD_BASE(43, 43, IOCFG_RT2_BASE, 0x30, 0x10, 4, 1),
++	PIN_FIELD_BASE(44, 44, IOCFG_RT2_BASE, 0x30, 0x10, 5, 1),
++	PIN_FIELD_BASE(45, 45, IOCFG_RT2_BASE, 0x30, 0x10, 6, 1),
++	PIN_FIELD_BASE(46, 46, IOCFG_TL_BASE, 0x30, 0x10, 9, 1),
++	PIN_FIELD_BASE(47, 47, IOCFG_TL_BASE, 0x30, 0x10, 10, 1),
++	PIN_FIELD_BASE(48, 48, IOCFG_TL_BASE, 0x30, 0x10, 7, 1),
++	PIN_FIELD_BASE(49, 49, IOCFG_TL_BASE, 0x30, 0x10, 8, 1),
++};
++
++static const struct mtk_pin_field_calc mt7987_pin_r0_range[] = {
++	PIN_FIELD_BASE(0, 0, IOCFG_RT2_BASE, 0x40, 0x10, 3, 1),
++	PIN_FIELD_BASE(1, 1, IOCFG_RT2_BASE, 0x40, 0x10, 2, 1),
++	PIN_FIELD_BASE(2, 2, IOCFG_RT2_BASE, 0x40, 0x10, 11, 1),
++	PIN_FIELD_BASE(3, 3, IOCFG_TL_BASE, 0x40, 0x10, 2, 1),
++	PIN_FIELD_BASE(4, 4, IOCFG_TL_BASE, 0x40, 0x10, 1, 1),
++	PIN_FIELD_BASE(5, 5, IOCFG_TL_BASE, 0x40, 0x10, 3, 1),
++	PIN_FIELD_BASE(6, 6, IOCFG_TL_BASE, 0x40, 0x10, 0, 1),
++	PIN_FIELD_BASE(7, 7, IOCFG_TL_BASE, 0x40, 0x10, 4, 1),
++	PIN_FIELD_BASE(8, 8, IOCFG_RB_BASE, 0x30, 0x10, 2, 1),
++	PIN_FIELD_BASE(9, 9, IOCFG_RB_BASE, 0x30, 0x10, 1, 1),
++	PIN_FIELD_BASE(10, 10, IOCFG_RB_BASE, 0x30, 0x10, 0, 1),
++	PIN_FIELD_BASE(11, 11, IOCFG_RB_BASE, 0x30, 0x10, 3, 1),
++	PIN_FIELD_BASE(12, 12, IOCFG_RB_BASE, 0x30, 0x10, 4, 1),
++	PIN_FIELD_BASE(13, 13, IOCFG_RT1_BASE, 0x40, 0x10, 0, 1),
++	PIN_FIELD_BASE(14, 14, IOCFG_RT1_BASE, 0x40, 0x10, 15, 1),
++	PIN_FIELD_BASE(15, 15, IOCFG_RT1_BASE, 0x40, 0x10, 3, 1),
++	PIN_FIELD_BASE(16, 16, IOCFG_RT1_BASE, 0x40, 0x10, 7, 1),
++	PIN_FIELD_BASE(17, 17, IOCFG_RT1_BASE, 0x40, 0x10, 6, 1),
++	PIN_FIELD_BASE(18, 18, IOCFG_RT1_BASE, 0x40, 0x10, 4, 1),
++	PIN_FIELD_BASE(19, 19, IOCFG_RT1_BASE, 0x40, 0x10, 5, 1),
++	PIN_FIELD_BASE(20, 20, IOCFG_RT1_BASE, 0x40, 0x10, 8, 1),
++	PIN_FIELD_BASE(21, 21, IOCFG_RT1_BASE, 0x40, 0x10, 9, 1),
++	PIN_FIELD_BASE(22, 22, IOCFG_RT1_BASE, 0x40, 0x10, 12, 1),
++	PIN_FIELD_BASE(23, 23, IOCFG_RT1_BASE, 0x40, 0x10, 11, 1),
++	PIN_FIELD_BASE(24, 24, IOCFG_RT1_BASE, 0x40, 0x10, 10, 1),
++	PIN_FIELD_BASE(25, 25, IOCFG_RT1_BASE, 0x40, 0x10, 13, 1),
++	PIN_FIELD_BASE(26, 26, IOCFG_RT1_BASE, 0x40, 0x10, 14, 1),
++	PIN_FIELD_BASE(27, 27, IOCFG_RT2_BASE, 0x40, 0x10, 9, 1),
++	PIN_FIELD_BASE(28, 28, IOCFG_RT2_BASE, 0x40, 0x10, 7, 1),
++	PIN_FIELD_BASE(29, 29, IOCFG_RT2_BASE, 0x40, 0x10, 8, 1),
++	PIN_FIELD_BASE(30, 30, IOCFG_RT2_BASE, 0x40, 0x10, 10, 1),
++	PIN_FIELD_BASE(31, 31, IOCFG_TL_BASE, 0x40, 0x10, 5, 1),
++	PIN_FIELD_BASE(32, 32, IOCFG_TL_BASE, 0x40, 0x10, 6, 1),
++
++	PIN_FIELD_BASE(39, 39, IOCFG_RT1_BASE, 0x40, 0x10, 1, 1),
++	PIN_FIELD_BASE(40, 40, IOCFG_RT1_BASE, 0x40, 0x10, 2, 1),
++	PIN_FIELD_BASE(41, 41, IOCFG_RT2_BASE, 0x40, 0x10, 0, 1),
++	PIN_FIELD_BASE(42, 42, IOCFG_RT2_BASE, 0x40, 0x10, 1, 1),
++	PIN_FIELD_BASE(43, 43, IOCFG_RT2_BASE, 0x40, 0x10, 4, 1),
++	PIN_FIELD_BASE(44, 44, IOCFG_RT2_BASE, 0x40, 0x10, 5, 1),
++	PIN_FIELD_BASE(45, 45, IOCFG_RT2_BASE, 0x40, 0x10, 6, 1),
++	PIN_FIELD_BASE(46, 46, IOCFG_TL_BASE, 0x40, 0x10, 9, 1),
++	PIN_FIELD_BASE(47, 47, IOCFG_TL_BASE, 0x40, 0x10, 10, 1),
++	PIN_FIELD_BASE(48, 48, IOCFG_TL_BASE, 0x40, 0x10, 7, 1),
++	PIN_FIELD_BASE(49, 49, IOCFG_TL_BASE, 0x40, 0x10, 8, 1),
++};
++
++static const struct mtk_pin_field_calc mt7987_pin_r1_range[] = {
++	PIN_FIELD_BASE(0, 0, IOCFG_RT2_BASE, 0x50, 0x10, 3, 1),
++	PIN_FIELD_BASE(1, 1, IOCFG_RT2_BASE, 0x50, 0x10, 2, 1),
++	PIN_FIELD_BASE(2, 2, IOCFG_RT2_BASE, 0x50, 0x10, 11, 1),
++	PIN_FIELD_BASE(3, 3, IOCFG_TL_BASE, 0x50, 0x10, 2, 1),
++	PIN_FIELD_BASE(4, 4, IOCFG_TL_BASE, 0x50, 0x10, 1, 1),
++	PIN_FIELD_BASE(5, 5, IOCFG_TL_BASE, 0x50, 0x10, 3, 1),
++	PIN_FIELD_BASE(6, 6, IOCFG_TL_BASE, 0x50, 0x10, 0, 1),
++	PIN_FIELD_BASE(7, 7, IOCFG_TL_BASE, 0x50, 0x10, 4, 1),
++	PIN_FIELD_BASE(8, 8, IOCFG_RB_BASE, 0x40, 0x10, 2, 1),
++	PIN_FIELD_BASE(9, 9, IOCFG_RB_BASE, 0x40, 0x10, 1, 1),
++	PIN_FIELD_BASE(10, 10, IOCFG_RB_BASE, 0x40, 0x10, 0, 1),
++	PIN_FIELD_BASE(11, 11, IOCFG_RB_BASE, 0x40, 0x10, 3, 1),
++	PIN_FIELD_BASE(12, 12, IOCFG_RB_BASE, 0x40, 0x10, 4, 1),
++	PIN_FIELD_BASE(13, 13, IOCFG_RT1_BASE, 0x50, 0x10, 0, 1),
++	PIN_FIELD_BASE(14, 14, IOCFG_RT1_BASE, 0x50, 0x10, 15, 1),
++	PIN_FIELD_BASE(15, 15, IOCFG_RT1_BASE, 0x50, 0x10, 3, 1),
++	PIN_FIELD_BASE(16, 16, IOCFG_RT1_BASE, 0x50, 0x10, 7, 1),
++	PIN_FIELD_BASE(17, 17, IOCFG_RT1_BASE, 0x50, 0x10, 6, 1),
++	PIN_FIELD_BASE(18, 18, IOCFG_RT1_BASE, 0x50, 0x10, 4, 1),
++	PIN_FIELD_BASE(19, 19, IOCFG_RT1_BASE, 0x50, 0x10, 5, 1),
++	PIN_FIELD_BASE(20, 20, IOCFG_RT1_BASE, 0x50, 0x10, 8, 1),
++	PIN_FIELD_BASE(21, 21, IOCFG_RT1_BASE, 0x50, 0x10, 9, 1),
++	PIN_FIELD_BASE(22, 22, IOCFG_RT1_BASE, 0x50, 0x10, 12, 1),
++	PIN_FIELD_BASE(23, 23, IOCFG_RT1_BASE, 0x50, 0x10, 11, 1),
++	PIN_FIELD_BASE(24, 24, IOCFG_RT1_BASE, 0x50, 0x10, 10, 1),
++	PIN_FIELD_BASE(25, 25, IOCFG_RT1_BASE, 0x50, 0x10, 13, 1),
++	PIN_FIELD_BASE(26, 26, IOCFG_RT1_BASE, 0x50, 0x10, 14, 1),
++	PIN_FIELD_BASE(27, 27, IOCFG_RT2_BASE, 0x50, 0x10, 9, 1),
++	PIN_FIELD_BASE(28, 28, IOCFG_RT2_BASE, 0x50, 0x10, 7, 1),
++	PIN_FIELD_BASE(29, 29, IOCFG_RT2_BASE, 0x50, 0x10, 8, 1),
++	PIN_FIELD_BASE(30, 30, IOCFG_RT2_BASE, 0x50, 0x10, 10, 1),
++	PIN_FIELD_BASE(31, 31, IOCFG_TL_BASE, 0x50, 0x10, 5, 1),
++	PIN_FIELD_BASE(32, 32, IOCFG_TL_BASE, 0x50, 0x10, 6, 1),
++
++	PIN_FIELD_BASE(39, 39, IOCFG_RT1_BASE, 0x50, 0x10, 1, 1),
++	PIN_FIELD_BASE(40, 40, IOCFG_RT1_BASE, 0x50, 0x10, 2, 1),
++	PIN_FIELD_BASE(41, 41, IOCFG_RT2_BASE, 0x50, 0x10, 0, 1),
++	PIN_FIELD_BASE(42, 42, IOCFG_RT2_BASE, 0x50, 0x10, 1, 1),
++	PIN_FIELD_BASE(43, 43, IOCFG_RT2_BASE, 0x50, 0x10, 4, 1),
++	PIN_FIELD_BASE(44, 44, IOCFG_RT2_BASE, 0x50, 0x10, 5, 1),
++	PIN_FIELD_BASE(45, 45, IOCFG_RT2_BASE, 0x50, 0x10, 6, 1),
++	PIN_FIELD_BASE(46, 46, IOCFG_TL_BASE, 0x50, 0x10, 9, 1),
++	PIN_FIELD_BASE(47, 47, IOCFG_TL_BASE, 0x50, 0x10, 10, 1),
++	PIN_FIELD_BASE(48, 48, IOCFG_TL_BASE, 0x50, 0x10, 7, 1),
++	PIN_FIELD_BASE(49, 49, IOCFG_TL_BASE, 0x50, 0x10, 8, 1),
++};
++
++static const unsigned int mt7987_pull_type[] = {
++	MTK_PULL_PUPD_R1R0_TYPE,/*0*/ MTK_PULL_PUPD_R1R0_TYPE,/*1*/
++	MTK_PULL_PUPD_R1R0_TYPE,/*2*/ MTK_PULL_PUPD_R1R0_TYPE,/*3*/
++	MTK_PULL_PUPD_R1R0_TYPE,/*4*/ MTK_PULL_PUPD_R1R0_TYPE,/*5*/
++	MTK_PULL_PUPD_R1R0_TYPE,/*6*/ MTK_PULL_PUPD_R1R0_TYPE,/*7*/
++	MTK_PULL_PUPD_R1R0_TYPE,/*8*/ MTK_PULL_PUPD_R1R0_TYPE,/*9*/
++	MTK_PULL_PUPD_R1R0_TYPE,/*10*/ MTK_PULL_PUPD_R1R0_TYPE,/*11*/
++	MTK_PULL_PUPD_R1R0_TYPE,/*12*/ MTK_PULL_PUPD_R1R0_TYPE,/*13*/
++	MTK_PULL_PUPD_R1R0_TYPE,/*14*/ MTK_PULL_PUPD_R1R0_TYPE,/*15*/
++	MTK_PULL_PUPD_R1R0_TYPE,/*16*/ MTK_PULL_PUPD_R1R0_TYPE,/*17*/
++	MTK_PULL_PUPD_R1R0_TYPE,/*18*/ MTK_PULL_PUPD_R1R0_TYPE,/*19*/
++	MTK_PULL_PUPD_R1R0_TYPE,/*20*/ MTK_PULL_PUPD_R1R0_TYPE,/*21*/
++	MTK_PULL_PUPD_R1R0_TYPE,/*22*/ MTK_PULL_PUPD_R1R0_TYPE,/*23*/
++	MTK_PULL_PUPD_R1R0_TYPE,/*24*/ MTK_PULL_PUPD_R1R0_TYPE,/*25*/
++	MTK_PULL_PUPD_R1R0_TYPE,/*26*/ MTK_PULL_PUPD_R1R0_TYPE,/*27*/
++	MTK_PULL_PUPD_R1R0_TYPE,/*28*/ MTK_PULL_PUPD_R1R0_TYPE,/*29*/
++	MTK_PULL_PUPD_R1R0_TYPE,/*30*/ MTK_PULL_PUPD_R1R0_TYPE,/*31*/
++	MTK_PULL_PUPD_R1R0_TYPE,/*32*/ MTK_PULL_PU_PD_TYPE,/*33*/
++	MTK_PULL_PU_PD_TYPE,/*34*/ MTK_PULL_PU_PD_TYPE,/*35*/
++	MTK_PULL_PU_PD_TYPE,/*36*/ MTK_PULL_PU_PD_TYPE,/*37*/
++	MTK_PULL_PU_PD_TYPE,/*38*/ MTK_PULL_PUPD_R1R0_TYPE,/*39*/
++	MTK_PULL_PUPD_R1R0_TYPE,/*40*/ MTK_PULL_PUPD_R1R0_TYPE,/*41*/
++	MTK_PULL_PUPD_R1R0_TYPE,/*42*/ MTK_PULL_PUPD_R1R0_TYPE,/*43*/
++	MTK_PULL_PUPD_R1R0_TYPE,/*44*/ MTK_PULL_PUPD_R1R0_TYPE,/*45*/
++	MTK_PULL_PUPD_R1R0_TYPE,/*46*/ MTK_PULL_PUPD_R1R0_TYPE,/*47*/
++	MTK_PULL_PUPD_R1R0_TYPE,/*48*/ MTK_PULL_PUPD_R1R0_TYPE,/*49*/
++};
++
++static const struct mtk_pin_reg_calc mt7987_reg_cals[] = {
++	[PINCTRL_PIN_REG_MODE] = MTK_RANGE(mt7987_pin_mode_range),
++	[PINCTRL_PIN_REG_DIR] = MTK_RANGE(mt7987_pin_dir_range),
++	[PINCTRL_PIN_REG_DI] = MTK_RANGE(mt7987_pin_di_range),
++	[PINCTRL_PIN_REG_DO] = MTK_RANGE(mt7987_pin_do_range),
++	[PINCTRL_PIN_REG_SMT] = MTK_RANGE(mt7987_pin_smt_range),
++	[PINCTRL_PIN_REG_IES] = MTK_RANGE(mt7987_pin_ies_range),
++	[PINCTRL_PIN_REG_PU] = MTK_RANGE(mt7987_pin_pu_range),
++	[PINCTRL_PIN_REG_PD] = MTK_RANGE(mt7987_pin_pd_range),
++	[PINCTRL_PIN_REG_DRV] = MTK_RANGE(mt7987_pin_drv_range),
++	[PINCTRL_PIN_REG_PUPD] = MTK_RANGE(mt7987_pin_pupd_range),
++	[PINCTRL_PIN_REG_R0] = MTK_RANGE(mt7987_pin_r0_range),
++	[PINCTRL_PIN_REG_R1] = MTK_RANGE(mt7987_pin_r1_range),
++};
++
++static const struct mtk_pin_desc mt7987_pins[] = {
++	MT7987_PIN(0, "GPIO_WPS"),
++	MT7987_PIN(1, "GPIO_RESET"),
++	MT7987_PIN(2, "SYS_WATCHDOG"),
++	MT7987_PIN(3, "JTAG_JTDO"),
++	MT7987_PIN(4, "JTAG_JTDI"),
++	MT7987_PIN(5, "JTAG_JTMS"),
++	MT7987_PIN(6, "JTAG_JTCLK"),
++	MT7987_PIN(7, "JTAG_JTRST_N"),
++	MT7987_PIN(8, "PCM_DTX_I2S_DOUT"),
++	MT7987_PIN(9, "PCM_DRX_I2S_DIN"),
++	MT7987_PIN(10, "PCM_CLK_I2S_BCLK"),
++	MT7987_PIN(11, "PCM_FS_I2S_LRCK"),
++	MT7987_PIN(12, "PCM_MCK_I2S_MCLK"),
++	MT7987_PIN(13, "PWM0"),
++	MT7987_PIN(14, "USB_VBUS"),
++	MT7987_PIN(15, "SPI0_CLK"),
++	MT7987_PIN(16, "SPI0_MOSI"),
++	MT7987_PIN(17, "SPI0_MISO"),
++	MT7987_PIN(18, "SPI0_CS"),
++	MT7987_PIN(19, "SPI0_HOLD"),
++	MT7987_PIN(20, "SPI0_WP"),
++	MT7987_PIN(21, "SPI1_CLK"),
++	MT7987_PIN(22, "SPI1_MOSI"),
++	MT7987_PIN(23, "SPI1_MISO"),
++	MT7987_PIN(24, "SPI1_CS"),
++	MT7987_PIN(25, "SPI2_CLK"),
++	MT7987_PIN(26, "SPI2_MOSI"),
++	MT7987_PIN(27, "SPI2_MISO"),
++	MT7987_PIN(28, "SPI2_CS"),
++	MT7987_PIN(29, "SPI2_HOLD"),
++	MT7987_PIN(30, "SPI2_WP"),
++	MT7987_PIN(31, "UART0_RXD"),
++	MT7987_PIN(32, "UART0_TXD"),
++	MT7987_PIN(33, "PCIE_PERESET_N_0"),
++	MT7987_PIN(34, "PCIE_CLK_REQ_0"),
++	MT7987_PIN(35, "PCIE_WAKE_N_0"),
++	MT7987_PIN(36, "PCIE_PERESET_N_1"),
++	MT7987_PIN(37, "PCIE_CLK_REQ_1"),
++	MT7987_PIN(38, "PCIE_WAKE_N_1"),
++	MT7987_PIN(39, "SMI_MDC"),
++	MT7987_PIN(40, "SMI_MDIO"),
++	MT7987_PIN(41, "GBE_INT"),
++	MT7987_PIN(42, "GBE_RESET"),
++	MT7987_PIN(43, "I2C_SCLK"),
++	MT7987_PIN(44, "I2C_SDATA"),
++	MT7987_PIN(45, "2P5G_LED0"),
++	MT7987_PIN(46, "UART1_RXD"),
++	MT7987_PIN(47, "UART1_TXD"),
++	MT7987_PIN(48, "UART1_CTS"),
++	MT7987_PIN(49, "UART1_RTS"),
++};
++
++/* watchdog */
++static int mt7987_watchdog_pins[] = {2};
++static int mt7987_watchdog_funcs[] = {1};
++
++/* jtag */
++static int mt7987_jtag_pins[] = {3, 4, 5, 6, 7};
++static int mt7987_jtag_funcs[] = {1, 1, 1, 1, 1};
++
++/* i2s */
++static int mt7987_i2s_pins[] = { 8, 9, 10, 11, 12 };
++static int mt7987_i2s_funcs[] = { 1, 1, 1, 1, 1 };
++
++/* pcm */
++static int mt7987_pcm_pins[] = { 8, 9, 10, 11 };
++static int mt7987_pcm_funcs[] = { 1, 1, 1, 1 };
++
++/* uart */
++static int mt7987_uart0_pins[] = {31, 32};
++static int mt7987_uart0_funcs[] = {1, 1};
++
++static int mt7987_uart1_0_pins[] = {3, 4, 5, 6};
++static int mt7987_uart1_0_funcs[] = {3, 3, 3, 3};
++
++static int mt7987_uart1_0_lite_pins[] = {3, 4};
++static int mt7987_uart1_0_lite_funcs[] = {3, 3};
++
++static int mt7987_uart1_1_pins[] = {21, 22, 23, 24};
++static int mt7987_uart1_1_funcs[] = {3, 3, 3, 3};
++
++static int mt7987_uart1_2_pins[] = {46, 47, 48, 49};
++static int mt7987_uart1_2_funcs[] = {1, 1, 1, 1};
++
++static int mt7987_uart2_0_pins[] = {8, 9, 10, 11};
++static int mt7987_uart2_0_funcs[] = {2, 2, 2, 2};
++
++static int mt7987_uart2_1_pins[] = {25, 26, 27, 28};
++static int mt7987_uart2_1_funcs[] = {2, 2, 2, 2};
++
++/* pwm */
++static int mt7987_pwm0_pins[] = {13};
++static int mt7987_pwm0_funcs[] = {1};
++
++static int mt7987_pwm1_0_pins[] = {7};
++static int mt7987_pwm1_0_funcs[] = {3};
++
++static int mt7987_pwm1_1_pins[] = {43};
++static int mt7987_pwm1_1_funcs[] = {2};
++
++static int mt7987_pwm2_0_pins[] = {12};
++static int mt7987_pwm2_0_funcs[] = {2};
++
++static int mt7987_pwm2_1_pins[] = {44};
++static int mt7987_pwm2_1_funcs[] = {2};
++
++/* vbus */
++static int mt7987_drv_vbus_p1_pins[] = {14};
++static int mt7987_drv_vbus_p1_funcs[] = {1};
++
++static int mt7987_drv_vbus_pins[] = {48};
++static int mt7987_drv_vbus_funcs[] = {3};
++
++/* 2p5gbe_led */
++static int mt7987_2p5gbe_led0_pins[] = {45};
++static int mt7987_2p5gbe_led0_funcs[] = {1};
++
++static int mt7987_2p5gbe_led1_0_pins[] = {13};
++static int mt7987_2p5gbe_led1_0_funcs[] = {2};
++
++static int mt7987_2p5gbe_led1_1_pins[] = {49};
++static int mt7987_2p5gbe_led1_1_funcs[] = {3};
++
++/* mdc, mdio */
++static int mt7987_2p5g_ext_mdc_mdio_pins[] = {23, 24};
++static int mt7987_2p5g_ext_mdc_mdio_funcs[] = {4, 4};
++
++static int mt7987_mdc_mdio_pins[] = {39, 40};
++static int mt7987_mdc_mdio_funcs[] = {1, 1};
++
++/* spi */
++static int mt7987_spi0_pins[] = {15, 16, 17, 18};
++static int mt7987_spi0_funcs[] = {1, 1, 1, 1};
++
++static int mt7987_spi0_wp_hold_pins[] = {19, 20};
++static int mt7987_spi0_wp_hold_funcs[] = {1, 1};
++
++static int mt7987_spi1_pins[] = {21, 22, 23, 24};
++static int mt7987_spi1_funcs[] = {1, 1, 1, 1};
++
++static int mt7987_spi1_1_pins[] = {46, 47, 48, 49};
++static int mt7987_spi1_1_funcs[] = {2, 2, 2, 2};
++
++static int mt7987_spi2_pins[] = {25, 26, 27, 28};
++static int mt7987_spi2_funcs[] = {1, 1, 1, 1};
++
++static int mt7987_spi2_wp_hold_pins[] = {29, 30};
++static int mt7987_spi2_wp_hold_funcs[] = {1, 1};
++
++/* emmc */
++static int mt7987_emmc_45_pins[] = {14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24};
++static int mt7987_emmc_45_funcs[] = {2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2};
++
++/* sd */
++static int mt7987_sd_pins[] = {15, 16, 17, 18, 23, 24};
++static int mt7987_sd_funcs[] = {2, 2, 2, 2, 2, 2};
++
++/* i2c */
++static int mt7987_i2c0_0_pins[] = {29, 30};
++static int mt7987_i2c0_0_funcs[] = {2, 2};
++
++static int mt7987_i2c0_1_pins[] = {39, 40};
++static int mt7987_i2c0_1_funcs[] = {2, 2};
++
++static int mt7987_i2c0_2_pins[] = {43, 44};
++static int mt7987_i2c0_2_funcs[] = {1, 1};
++
++/* pcie */
++static int mt7987_pcie0_pereset_pins[] = {33};
++static int mt7987_pcie0_pereset_funcs[] = {1};
++
++static int mt7987_pcie0_clkreq_pins[] = {34};
++static int mt7987_pcie0_clkreq_funcs[] = {1};
++
++static int mt7987_pcie0_wake_pins[] = {35};
++static int mt7987_pcie0_wake_funcs[] = {1};
++
++static int mt7987_pcie1_pereset_pins[] = {36};
++static int mt7987_pcie1_pereset_funcs[] = {1};
++
++static int mt7987_pcie1_clkreq_pins[] = {37};
++static int mt7987_pcie1_clkreq_funcs[] = {1};
++
++static int mt7987_pcie1_wake_pins[] = {38};
++static int mt7987_pcie1_wake_funcs[] = {1};
++
++static int mt7987_pcie_phy_i2c_pins[] = {43, 44};
++static int mt7987_pcie_phy_i2c_funcs[] = {3, 3};
++
++static const struct group_desc mt7987_groups[] = {
++	PINCTRL_PIN_GROUP("watchdog", mt7987_watchdog),
++	PINCTRL_PIN_GROUP("jtag", mt7987_jtag),
++	PINCTRL_PIN_GROUP("i2s", mt7987_i2s),
++	PINCTRL_PIN_GROUP("pcm", mt7987_pcm),
++	PINCTRL_PIN_GROUP("uart0", mt7987_uart0),
++	PINCTRL_PIN_GROUP("uart1_0", mt7987_uart1_0),
++	PINCTRL_PIN_GROUP("uart1_0_lite", mt7987_uart1_0_lite),
++	PINCTRL_PIN_GROUP("uart1_1", mt7987_uart1_1),
++	PINCTRL_PIN_GROUP("uart1_2", mt7987_uart1_2),
++	PINCTRL_PIN_GROUP("uart2_0", mt7987_uart2_0),
++	PINCTRL_PIN_GROUP("uart2_1", mt7987_uart2_1),
++	PINCTRL_PIN_GROUP("pwm0", mt7987_pwm0),
++	PINCTRL_PIN_GROUP("pwm1_0", mt7987_pwm1_0),
++	PINCTRL_PIN_GROUP("pwm1_1", mt7987_pwm1_1),
++	PINCTRL_PIN_GROUP("pwm2_0", mt7987_pwm2_0),
++	PINCTRL_PIN_GROUP("pwm2_1", mt7987_pwm2_1),
++	PINCTRL_PIN_GROUP("drv_vbus_p1", mt7987_drv_vbus_p1),
++	PINCTRL_PIN_GROUP("drv_vbus", mt7987_drv_vbus),
++	PINCTRL_PIN_GROUP("2p5gbe_led0", mt7987_2p5gbe_led0),
++	PINCTRL_PIN_GROUP("2p5gbe_led1_0", mt7987_2p5gbe_led1_0),
++	PINCTRL_PIN_GROUP("2p5gbe_led1_1", mt7987_2p5gbe_led1_1),
++	PINCTRL_PIN_GROUP("2p5g_ext_mdc_mdio", mt7987_2p5g_ext_mdc_mdio),
++	PINCTRL_PIN_GROUP("mdc_mdio", mt7987_mdc_mdio),
++	PINCTRL_PIN_GROUP("spi0", mt7987_spi0),
++	PINCTRL_PIN_GROUP("spi0_wp_hold", mt7987_spi0_wp_hold),
++	PINCTRL_PIN_GROUP("spi1", mt7987_spi1),
++	PINCTRL_PIN_GROUP("spi1_1", mt7987_spi1_1),
++	PINCTRL_PIN_GROUP("spi2", mt7987_spi2),
++	PINCTRL_PIN_GROUP("spi2_wp_hold", mt7987_spi2_wp_hold),
++	PINCTRL_PIN_GROUP("emmc_45", mt7987_emmc_45),
++	PINCTRL_PIN_GROUP("sd", mt7987_sd),
++	PINCTRL_PIN_GROUP("i2c0_0", mt7987_i2c0_0),
++	PINCTRL_PIN_GROUP("i2c0_1", mt7987_i2c0_1),
++	PINCTRL_PIN_GROUP("i2c0_2", mt7987_i2c0_2),
++	PINCTRL_PIN_GROUP("pcie0_pereset", mt7987_pcie0_pereset),
++	PINCTRL_PIN_GROUP("pcie0_clkreq", mt7987_pcie0_clkreq),
++	PINCTRL_PIN_GROUP("pcie0_wake", mt7987_pcie0_wake),
++	PINCTRL_PIN_GROUP("pcie1_pereset", mt7987_pcie1_pereset),
++	PINCTRL_PIN_GROUP("pcie1_clkreq", mt7987_pcie1_clkreq),
++	PINCTRL_PIN_GROUP("pcie1_wake", mt7987_pcie1_wake),
++	PINCTRL_PIN_GROUP("pcie1_pcie_phy_i2c", mt7987_pcie_phy_i2c),
++};
++
++static const char *const mt7987_audio_groups[] = {"i2s", "pcm",};
++static const char *const mt7987_wdt_groups[] = {"watchdog",};
++static const char *const mt7987_jtag_groups[] = {"jtag",};
++static const char *const mt7987_uart_groups[] = {"uart0", "uart1_0",
++						 "uart1_0_lite", "uart1_1",
++						 "uart1_2", "uart2_0",
++						 "uart2_1",};
++static const char *const mt7987_pwm_groups[] = {"pwm0", "pwm1_0", "pwm1_1", "pwm2_0",
++					       "pwm2_1",};
++static const char *const mt7987_usb_groups[] = {"drv_vbus_p1", "drv_vbus",};
++static const char *const mt7987_led_groups[] = {"2p5gbe_led0", "2p5gbe_led1_0",
++					       "2p5gbe_led1_1",};
++static const char *const mt7987_ethernet_groups[] = {"2p5g_ext_mdc_mdio", "mdc_mdio",};
++static const char *const mt7987_spi_groups[] = {"spi0", "spi0_wp_hold", "spi1",
++						"spi1_1", "spi2", "spi2_wp_hold",};
++static const char *const mt7987_flash_groups[] = {"emmc_45", "sd",};
++static const char *const mt7987_i2c_groups[] = {"i2c0_0", "i2c0_1", "i2c0_2",};
++static const char *const mt7987_pcie_groups[] = {"pcie_phy_i2c", "pcie0_pereset",
++						 "pcie0_clkreq", "pcie0_wake",
++						 "pcie1_pereset", "pcie1_clkreq",
++						 "pcie1_wake",};
++
++
++static const struct function_desc mt7987_functions[] = {
++	{ {"audio", mt7987_audio_groups, ARRAY_SIZE(mt7987_audio_groups)}, NULL },
++	{ {"wdt", mt7987_wdt_groups, ARRAY_SIZE(mt7987_wdt_groups)}, NULL },
++	{ {"jtag", mt7987_jtag_groups, ARRAY_SIZE(mt7987_jtag_groups)}, NULL },
++	{ {"uart", mt7987_uart_groups, ARRAY_SIZE(mt7987_uart_groups)}, NULL },
++	{ {"pwm", mt7987_pwm_groups, ARRAY_SIZE(mt7987_pwm_groups)}, NULL },
++	{ {"usb", mt7987_usb_groups, ARRAY_SIZE(mt7987_usb_groups)}, NULL },
++	{ {"led", mt7987_led_groups, ARRAY_SIZE(mt7987_led_groups)}, NULL },
++	{ {"eth", mt7987_ethernet_groups, ARRAY_SIZE(mt7987_ethernet_groups)}, NULL },
++	{ {"spi", mt7987_spi_groups, ARRAY_SIZE(mt7987_spi_groups)}, NULL },
++	{ {"flash", mt7987_flash_groups, ARRAY_SIZE(mt7987_flash_groups)}, NULL },
++	{ {"i2c", mt7987_i2c_groups, ARRAY_SIZE(mt7987_i2c_groups)}, NULL },
++	{ {"pcie", mt7987_pcie_groups, ARRAY_SIZE(mt7987_pcie_groups)}, NULL },
++};
++
++static const struct mtk_eint_hw mt7987_eint_hw = {
++	.port_mask = 7,
++	.ports = 7,
++	.ap_num = ARRAY_SIZE(mt7987_pins),
++	.db_cnt = 16,
++};
++
++static const char * const mt7987_pinctrl_register_base_names[] = {
++	"gpio", "iocfg_rb", "iocfg_lb", "iocfg_rt1", "iocfg_rt2", "iocfg_tl",
++};
++
++static struct mtk_pin_soc mt7987_data = {
++	.reg_cal = mt7987_reg_cals,
++	.pins = mt7987_pins,
++	.npins = ARRAY_SIZE(mt7987_pins),
++	.grps = mt7987_groups,
++	.ngrps = ARRAY_SIZE(mt7987_groups),
++	.funcs = mt7987_functions,
++	.nfuncs = ARRAY_SIZE(mt7987_functions),
++	.eint_hw = &mt7987_eint_hw,
++	.gpio_m = 0,
++	.ies_present = false,
++	.base_names = mt7987_pinctrl_register_base_names,
++	.nbase_names = ARRAY_SIZE(mt7987_pinctrl_register_base_names),
++	.bias_disable_set = mtk_pinconf_bias_disable_set,
++	.bias_disable_get = mtk_pinconf_bias_disable_get,
++	.bias_set = mtk_pinconf_bias_set,
++	.bias_get = mtk_pinconf_bias_get,
++	.pull_type = mt7987_pull_type,
++	.bias_set_combo = mtk_pinconf_bias_set_combo,
++	.bias_get_combo = mtk_pinconf_bias_get_combo,
++	.drive_set = mtk_pinconf_drive_set_rev1,
++	.drive_get = mtk_pinconf_drive_get_rev1,
++	.adv_pull_get = mtk_pinconf_adv_pull_get,
++	.adv_pull_set = mtk_pinconf_adv_pull_set,
++};
++
++static const struct of_device_id mt7987_pinctrl_of_match[] = {
++	{
++		.compatible = "mediatek,mt7987-pinctrl",
++	},
++	{}
++};
++
++static int mt7987_pinctrl_probe(struct platform_device *pdev)
++{
++	return mtk_moore_pinctrl_probe(pdev, &mt7987_data);
++}
++
++static struct platform_driver mt7987_pinctrl_driver = {
++	.driver = {
++		.name = "mt7987-pinctrl",
++		.of_match_table = mt7987_pinctrl_of_match,
++	},
++	.probe = mt7987_pinctrl_probe,
++};
++
++static int __init mt7987_pinctrl_init(void)
++{
++	return platform_driver_register(&mt7987_pinctrl_driver);
++}
++arch_initcall(mt7987_pinctrl_init);
--- /dev/null
+++ b/target/linux/mediatek/patches-6.12/361-clk-mediatek-add-mt7987-clock-drivers-support.patch
@@ -0,0 +1,1190 @@
+From 08b3847982f4c470ff1ac0761bed0d8d83f1fd49 Mon Sep 17 00:00:00 2001
+From: Sam Shih <sam.shih@mediatek.com>
+Date: Mon, 20 Jan 2025 19:50:03 +0800
+Subject: [PATCH 2/2] clk: mediatek: add mt7987 clock drivers support
+
+Signed-off-by: Daniel Golle <daniel@makrotopia.org>
+---
+ drivers/clk/mediatek/Kconfig                  |   9 +
+ drivers/clk/mediatek/Makefile                 |   5 +
+ drivers/clk/mediatek/clk-mt7987-apmixed.c     | 116 +++++++
+ drivers/clk/mediatek/clk-mt7987-eth.c         |  94 +++++
+ drivers/clk/mediatek/clk-mt7987-infracfg.c    | 328 ++++++++++++++++++
+ drivers/clk/mediatek/clk-mt7987-mcusys.c      |  47 +++
+ drivers/clk/mediatek/clk-mt7987-topckgen.c    | 311 +++++++++++++++++
+ .../dt-bindings/clock/mediatek,mt7987-clk.h   | 206 +++++++++++
+ .../reset/mediatek,mt7987-resets.h            |  10 +
+ 9 files changed, 1126 insertions(+)
+ create mode 100644 drivers/clk/mediatek/clk-mt7987-apmixed.c
+ create mode 100644 drivers/clk/mediatek/clk-mt7987-eth.c
+ create mode 100644 drivers/clk/mediatek/clk-mt7987-infracfg.c
+ create mode 100644 drivers/clk/mediatek/clk-mt7987-mcusys.c
+ create mode 100644 drivers/clk/mediatek/clk-mt7987-topckgen.c
+ create mode 100644 include/dt-bindings/clock/mediatek,mt7987-clk.h
+ create mode 100644 include/dt-bindings/reset/mediatek,mt7987-resets.h
+
+--- a/drivers/clk/mediatek/Kconfig
++++ b/drivers/clk/mediatek/Kconfig
+@@ -423,6 +423,15 @@ config COMMON_CLK_MT7986_ETHSYS
+ 	  This driver adds support for clocks for Ethernet and SGMII
+ 	  required on MediaTek MT7986 SoC.
+ 
++config COMMON_CLK_MT7987
++	tristate "Clock driver for MediaTek MT7987"
++	depends on ARCH_MEDIATEK || COMPILE_TEST
++	select COMMON_CLK_MEDIATEK
++	default ARCH_MEDIATEK
++	help
++	  This driver supports MediaTek MT7987 basic clocks and clocks
++	  required for various periperals found on this SoC.
++
+ config COMMON_CLK_MT7988
+ 	tristate "Clock driver for MediaTek MT7988"
+ 	depends on ARCH_MEDIATEK || COMPILE_TEST
+--- a/drivers/clk/mediatek/Makefile
++++ b/drivers/clk/mediatek/Makefile
+@@ -62,6 +62,11 @@ obj-$(CONFIG_COMMON_CLK_MT7986) += clk-m
+ obj-$(CONFIG_COMMON_CLK_MT7986) += clk-mt7986-topckgen.o
+ obj-$(CONFIG_COMMON_CLK_MT7986) += clk-mt7986-infracfg.o
+ obj-$(CONFIG_COMMON_CLK_MT7986_ETHSYS) += clk-mt7986-eth.o
++obj-$(CONFIG_COMMON_CLK_MT7987) += clk-mt7987-apmixed.o
++obj-$(CONFIG_COMMON_CLK_MT7987) += clk-mt7987-eth.o
++obj-$(CONFIG_COMMON_CLK_MT7987) += clk-mt7987-infracfg.o
++obj-$(CONFIG_COMMON_CLK_MT7987) += clk-mt7987-mcusys.o
++obj-$(CONFIG_COMMON_CLK_MT7987) += clk-mt7987-topckgen.o
+ obj-$(CONFIG_COMMON_CLK_MT7988) += clk-mt7988-apmixed.o
+ obj-$(CONFIG_COMMON_CLK_MT7988) += clk-mt7988-topckgen.o
+ obj-$(CONFIG_COMMON_CLK_MT7988) += clk-mt7988-infracfg.o
+--- /dev/null
++++ b/drivers/clk/mediatek/clk-mt7987-apmixed.c
+@@ -0,0 +1,116 @@
++// SPDX-License-Identifier: GPL-2.0
++/*
++ * Copyright (c) 2024 MediaTek Inc.
++ * Author: Lu Tang <Lu.Tang@mediatek.com>
++ * Author: Sam Shih <sam.shih@mediatek.com>
++ */
++
++#include <linux/clk-provider.h>
++#include <linux/of.h>
++#include <linux/of_address.h>
++#include <linux/of_device.h>
++#include <linux/platform_device.h>
++#include "clk-mtk.h"
++#include "clk-gate.h"
++#include "clk-mux.h"
++#include "clk-pll.h"
++#include <dt-bindings/clock/mediatek,mt7987-clk.h>
++
++#define MT7987_PLL_FMAX (2500UL * MHZ)
++#define MT7987_PCW_CHG_SHIFT 2
++
++#define PLL_B(_id, _name, _reg, _pwr_reg, _en_mask, _flags, _rst_bar_mask,     \
++	      _pcwbits, _pd_reg, _pd_shift, _tuner_reg, _tuner_en_reg,         \
++	      _tuner_en_bit, _pcw_reg, _pcw_shift, _pcw_chg_reg, _div_table,   \
++	      _parent_name)                                                    \
++	{                                                                      \
++		.id = _id, .name = _name, .reg = _reg, .pwr_reg = _pwr_reg,    \
++		.en_mask = _en_mask, .flags = _flags,                          \
++		.rst_bar_mask = BIT(_rst_bar_mask), .fmax = MT7987_PLL_FMAX,   \
++		.pcwbits = _pcwbits, .pd_reg = _pd_reg, .pd_shift = _pd_shift, \
++		.tuner_reg = _tuner_reg, .tuner_en_reg = _tuner_en_reg,        \
++		.tuner_en_bit = _tuner_en_bit, .pcw_reg = _pcw_reg,            \
++		.pcw_shift = _pcw_shift, .pcw_chg_reg = _pcw_chg_reg,          \
++		.pcw_chg_bit = MT7987_PCW_CHG_SHIFT,                           \
++		.div_table = _div_table, .parent_name = _parent_name,          \
++	}
++
++#define PLL(_id, _name, _reg, _pwr_reg, _en_mask, _flags, _rst_bar_mask,     \
++	    _pcwbits, _pd_reg, _pd_shift, _tuner_reg, _tuner_en_reg,         \
++	    _tuner_en_bit, _pcw_reg, _pcw_shift, _pcw_chg_reg, _parent_name) \
++	PLL_B(_id, _name, _reg, _pwr_reg, _en_mask, _flags, _rst_bar_mask,   \
++	      _pcwbits, _pd_reg, _pd_shift, _tuner_reg, _tuner_en_reg,       \
++	      _tuner_en_bit, _pcw_reg, _pcw_shift, _pcw_chg_reg, NULL,       \
++	      _parent_name)
++
++static const struct mtk_pll_div_table mt7987_arm_ll_div[] = {
++	{ .div = 0, .freq = 2000000000 },
++	{ .div = 1, .freq = 1500000000 },
++	{ .div = 2, .freq = 750000000 },
++	{ .div = 3, .freq = 375000000 },
++	{} /* sentinel */
++};
++
++static const struct mtk_pll_data plls[] = {
++	PLL(CLK_APMIXED_MPLL, "mpll", 0x0114, 0x0120, 0xff000001, HAVE_RST_BAR,
++	    23, 32, 0x0114, 4, 0, 0, 0, 0x0118, 0, 0x0114, "clkxtal"),
++	PLL(CLK_APMIXED_APLL2, "apll2", 0x0134, 0x0140, 0x00000001, 0, 0, 32,
++	    0x0134, 4, 0x0704, 0x0700, 1, 0x0138, 0, 0x0134, "clkxtal"),
++	PLL(CLK_APMIXED_NET1PLL, "net1pll", 0x0144, 0x0150, 0xff000001,
++	    HAVE_RST_BAR | PLL_AO, 23, 32, 0x0144, 4, 0, 0, 0, 0x0148, 0,
++	    0x0144, "clkxtal"),
++	PLL(CLK_APMIXED_NET2PLL, "net2pll", 0x0154, 0x0160, 0xff000001,
++	    HAVE_RST_BAR | PLL_AO, 23, 32, 0x0154, 4, 0, 0, 0, 0x0158, 0,
++	    0x0154, "clkxtal"),
++	PLL(CLK_APMIXED_WEDMCUPLL, "wedmcupll", 0x0164, 0x0170, 0x00000001, 0,
++	    0, 32, 0x0164, 4, 0, 0, 0, 0x0168, 0, 0x0164, "clkxtal"),
++	PLL(CLK_APMIXED_SGMPLL, "sgmpll", 0x0174, 0x0180, 0x00000001, 0, 0, 32,
++	    0x0174, 4, 0, 0, 0, 0x0178, 0, 0x0174, "clkxtal"),
++	PLL_B(CLK_APMIXED_ARM_LL, "arm_ll", 0x0104, 0x0110, 0x00000001,
++	      PLL_AO, 0, 32, 0x0104, 4, 0, 0, 0, 0x0108, 0, 0x0104,
++	      mt7987_arm_ll_div, "clkxtal"),
++	PLL(CLK_APMIXED_MSDCPLL, "msdcpll", 0x0124, 0x0130, 0x00000001, 0, 0,
++	    32, 0x0124, 4, 0, 0, 0, 0x0128, 0, 0x0124, "clkxtal"),
++};
++
++static const struct of_device_id of_match_clk_mt7987_apmixed[] = {
++	{ .compatible = "mediatek,mt7987-apmixedsys" },
++	{ /* sentinel */ }
++};
++
++static int clk_mt7987_apmixed_probe(struct platform_device *pdev)
++{
++	struct clk_hw_onecell_data *clk_data;
++	struct device_node *node = pdev->dev.of_node;
++	int r;
++
++	clk_data = mtk_alloc_clk_data(ARRAY_SIZE(plls));
++	if (!clk_data)
++		return -ENOMEM;
++
++	r = mtk_clk_register_plls(node, plls, ARRAY_SIZE(plls), clk_data);
++	if (r)
++		goto free_apmixed_data;
++
++	r = of_clk_add_hw_provider(node, of_clk_hw_onecell_get, clk_data);
++	if (r)
++		goto unregister_plls;
++
++	return r;
++
++unregister_plls:
++	mtk_clk_unregister_plls(plls, ARRAY_SIZE(plls), clk_data);
++free_apmixed_data:
++	mtk_free_clk_data(clk_data);
++	return r;
++}
++
++static struct platform_driver clk_mt7987_apmixed_drv = {
++	.probe = clk_mt7987_apmixed_probe,
++	.driver = {
++		.name = "mt7987-apmixedsys",
++		.of_match_table = of_match_clk_mt7987_apmixed,
++	},
++};
++builtin_platform_driver(clk_mt7987_apmixed_drv);
++MODULE_LICENSE("GPL");
+--- /dev/null
++++ b/drivers/clk/mediatek/clk-mt7987-eth.c
+@@ -0,0 +1,94 @@
++// SPDX-License-Identifier: GPL-2.0
++/*
++ * Copyright (c) 2024 MediaTek Inc.
++ * Author: Lu Tang <Lu.Tang@mediatek.com>
++ * Author: Sam Shih <sam.shih@mediatek.com>
++ */
++
++#include <linux/clk-provider.h>
++#include <linux/of.h>
++#include <linux/of_address.h>
++#include <linux/of_device.h>
++#include <linux/platform_device.h>
++#include "clk-mtk.h"
++#include "clk-gate.h"
++#include <dt-bindings/clock/mediatek,mt7987-clk.h>
++
++static const struct mtk_gate_regs ethdma_cg_regs = {
++	.set_ofs = 0x30,
++	.clr_ofs = 0x30,
++	.sta_ofs = 0x30,
++};
++
++#define GATE_ETHDMA(_id, _name, _parent, _shift)                  \
++	{                                                         \
++		.id = _id, .name = _name, .parent_name = _parent, \
++		.regs = &ethdma_cg_regs, .shift = _shift,         \
++		.ops = &mtk_clk_gate_ops_no_setclr_inv,           \
++	}
++
++static const struct mtk_gate ethdma_clks[] = {
++	GATE_ETHDMA(CLK_ETHDMA_FE_EN, "ethdma_fe_en", "netsys_2x_sel", 6),
++	GATE_ETHDMA(CLK_ETHDMA_GP2_EN, "ethdma_gp2_en", "netsys_500m_sel", 7),
++	GATE_ETHDMA(CLK_ETHDMA_GP1_EN, "ethdma_gp1_en", "netsys_500m_sel", 8),
++	GATE_ETHDMA(CLK_ETHDMA_GP3_EN, "ethdma_gp3_en", "netsys_500m_sel", 10),
++};
++
++static const struct mtk_clk_desc ethdma_desc = {
++	.clks = ethdma_clks,
++	.num_clks = ARRAY_SIZE(ethdma_clks),
++};
++
++static const struct mtk_gate_regs sgmii_cg_regs = {
++	.set_ofs = 0xe4,
++	.clr_ofs = 0xe4,
++	.sta_ofs = 0xe4,
++};
++
++#define GATE_SGMII(_id, _name, _parent, _shift)                   \
++	{                                                         \
++		.id = _id, .name = _name, .parent_name = _parent, \
++		.regs = &sgmii_cg_regs, .shift = _shift,          \
++		.ops = &mtk_clk_gate_ops_no_setclr_inv,           \
++	}
++
++static const struct mtk_gate sgmii0_clks[] = {
++	GATE_SGMII(CLK_SGM0_TX_EN, "sgm0_tx_en", "clkxtal", 2),
++	GATE_SGMII(CLK_SGM0_RX_EN, "sgm0_rx_en", "clkxtal", 3),
++};
++
++static const struct mtk_clk_desc sgmii0_desc = {
++	.clks = sgmii0_clks,
++	.num_clks = ARRAY_SIZE(sgmii0_clks),
++};
++
++static const struct mtk_gate sgmii1_clks[] = {
++	GATE_SGMII(CLK_SGM1_TX_EN, "sgm1_tx_en", "clkxtal", 2),
++	GATE_SGMII(CLK_SGM1_RX_EN, "sgm1_rx_en", "clkxtal", 3),
++};
++
++static const struct mtk_clk_desc sgmii1_desc = {
++	.clks = sgmii1_clks,
++	.num_clks = ARRAY_SIZE(sgmii1_clks),
++};
++
++static const struct of_device_id of_match_clk_mt7987_eth[] = {
++	{ .compatible = "mediatek,mt7987-ethsys", .data = &ethdma_desc },
++	{ .compatible = "mediatek,mt7987-sgmiisys0", .data = &sgmii0_desc },
++	{ .compatible = "mediatek,mt7987-sgmiisys1", .data = &sgmii1_desc },
++	{ /* sentinel */ }
++};
++MODULE_DEVICE_TABLE(of, of_match_clk_mt7987_eth);
++
++static struct platform_driver clk_mt7987_eth_drv = {
++	.driver = {
++		.name = "clk-mt7987-eth",
++		.of_match_table = of_match_clk_mt7987_eth,
++	},
++	.probe = mtk_clk_simple_probe,
++	.remove_new = mtk_clk_simple_remove,
++};
++module_platform_driver(clk_mt7987_eth_drv);
++
++MODULE_DESCRIPTION("MediaTek MT7987 Ethernet clocks driver");
++MODULE_LICENSE("GPL");
+--- /dev/null
++++ b/drivers/clk/mediatek/clk-mt7987-infracfg.c
+@@ -0,0 +1,328 @@
++// SPDX-License-Identifier: GPL-2.0
++/*
++ * Copyright (c) 2024 MediaTek Inc.
++ * Author: Lu Tang <Lu.Tang@mediatek.com>
++ * Author: Sam Shih <sam.shih@mediatek.com>
++ */
++
++#include <linux/clk.h>
++#include <linux/delay.h>
++#include <linux/of.h>
++#include <linux/of_address.h>
++#include <linux/of_device.h>
++#include <linux/platform_device.h>
++#include <linux/slab.h>
++#include <linux/mfd/syscon.h>
++#include "clk-mtk.h"
++#include "clk-mux.h"
++#include "clk-gate.h"
++#include <dt-bindings/clock/mediatek,mt7987-clk.h>
++#include <dt-bindings/reset/mediatek,mt7987-resets.h>
++
++#define MT7987_INFRA_RST0_SET_OFFSET	0x70
++#define MT7987_INFRA_RST1_SET_OFFSET	0x80
++
++static DEFINE_SPINLOCK(mt7987_clk_lock);
++
++static const char *const infra_mux_uart0_parents[] = { "csw_infra_f26m_sel",
++						       "infra_hf_66m_uart0_pck",
++						       "uart_sel" };
++
++static const char *const infra_mux_uart1_parents[] = { "csw_infra_f26m_sel",
++						       "infra_hf_66m_uart1_pck",
++						       "uart_sel" };
++
++static const char *const infra_mux_uart2_parents[] = { "csw_infra_f26m_sel",
++						       "infra_hf_66m_uart1_pck",
++						       "uart_sel" };
++
++static const char *const infra_mux_spi0_parents[] = {
++	"i2c_sel",
++	"spi_sel"
++};
++
++static const char *const infra_mux_spi1_parents[] = {
++	"i2c_sel",
++	"spim_mst_sel"
++};
++
++static const char *const infra_mux_spi2_bck_parents[] = {
++	"i2c_sel",
++	"spi_sel"
++};
++
++static const char *const infra_pwm_bck_parents[] = { "cb_rtc_32p7k",
++						     "csw_infra_f26m_sel",
++						     "sysaxi_sel", "pwm_sel" };
++
++static const char *const infra_pcie_gfmux_tl_ck_o_p0_parents[] = {
++	"cb_rtc_32p7k", "csw_infra_f26m_sel", "csw_infra_f26m_sel",
++	"pextp_tl_ck_sel"
++};
++
++static const char *const infra_pcie_gfmux_tl_ck_o_p1_parents[] = {
++	"cb_rtc_32p7k", "csw_infra_f26m_sel", "csw_infra_f26m_sel",
++	"pextp_tl_ck_p1_sel"
++};
++
++static struct mtk_mux infra_muxes[] = {
++	/* MODULE_CLK_SEL_0 */
++	MUX_GATE_CLR_SET_UPD(CLK_INFRA_MUX_UART0_SEL, "infra_mux_uart0_sel",
++			     infra_mux_uart0_parents, 0x0018, 0x0010, 0x0014,
++			     0, 1, -1, -1, -1),
++	MUX_GATE_CLR_SET_UPD(CLK_INFRA_MUX_UART1_SEL, "infra_mux_uart1_sel",
++			     infra_mux_uart1_parents, 0x0018, 0x0010, 0x0014,
++			     1, 1, -1, -1, -1),
++	MUX_GATE_CLR_SET_UPD(CLK_INFRA_MUX_UART2_SEL, "infra_mux_uart2_sel",
++			     infra_mux_uart2_parents, 0x0018, 0x0010, 0x0014,
++			     2, 1, -1, -1, -1),
++	MUX_GATE_CLR_SET_UPD(CLK_INFRA_MUX_SPI0_SEL, "infra_mux_spi0_sel",
++			     infra_mux_spi0_parents, 0x0018, 0x0010, 0x0014, 4,
++			     1, -1, -1, -1),
++	MUX_GATE_CLR_SET_UPD(CLK_INFRA_MUX_SPI1_SEL, "infra_mux_spi1_sel",
++			     infra_mux_spi1_parents, 0x0018, 0x0010, 0x0014, 5,
++			     1, -1, -1, -1),
++	MUX_GATE_CLR_SET_UPD(CLK_INFRA_MUX_SPI2_BCK_SEL,
++			     "infra_mux_spi2_bck_sel",
++			     infra_mux_spi2_bck_parents, 0x0018, 0x0010,
++			     0x0014, 6, 1, -1, -1, -1),
++	MUX_GATE_CLR_SET_UPD(CLK_INFRA_PWM_BCK_SEL, "infra_pwm_bck_sel",
++			     infra_pwm_bck_parents, 0x0018, 0x0010, 0x0014, 14,
++			     2, -1, -1, -1),
++	/* MODULE_CLK_SEL_1 */
++	MUX_GATE_CLR_SET_UPD(CLK_INFRA_PCIE_GFMUX_TL_O_P0_SEL,
++			     "infra_pcie_gfmux_tl_ck_o_p0_sel",
++			     infra_pcie_gfmux_tl_ck_o_p0_parents, 0x0028,
++			     0x0020, 0x0024, 0, 2, -1, -1, -1),
++	MUX_GATE_CLR_SET_UPD(CLK_INFRA_PCIE_GFMUX_TL_O_P1_SEL,
++			     "infra_pcie_gfmux_tl_ck_o_p1_sel",
++			     infra_pcie_gfmux_tl_ck_o_p1_parents, 0x0028,
++			     0x0020, 0x0024, 2, 2, -1, -1, -1),
++};
++
++static const struct mtk_gate_regs infra0_cg_regs = {
++	.set_ofs = 0x10,
++	.clr_ofs = 0x14,
++	.sta_ofs = 0x18,
++};
++
++static const struct mtk_gate_regs infra1_cg_regs = {
++	.set_ofs = 0x40,
++	.clr_ofs = 0x44,
++	.sta_ofs = 0x48,
++};
++
++static const struct mtk_gate_regs infra2_cg_regs = {
++	.set_ofs = 0x50,
++	.clr_ofs = 0x54,
++	.sta_ofs = 0x58,
++};
++
++static const struct mtk_gate_regs infra3_cg_regs = {
++	.set_ofs = 0x60,
++	.clr_ofs = 0x64,
++	.sta_ofs = 0x68,
++};
++
++#define GATE_INFRA0(_id, _name, _parent, _shift)                  \
++	{                                                         \
++		.id = _id, .name = _name, .parent_name = _parent, \
++		.regs = &infra0_cg_regs, .shift = _shift,         \
++		.ops = &mtk_clk_gate_ops_setclr,                  \
++	}
++
++#define GATE_INFRA1(_id, _name, _parent, _shift)                  \
++	{                                                         \
++		.id = _id, .name = _name, .parent_name = _parent, \
++		.regs = &infra1_cg_regs, .shift = _shift,         \
++		.ops = &mtk_clk_gate_ops_setclr,                  \
++	}
++
++#define GATE_INFRA2(_id, _name, _parent, _shift)                  \
++	{                                                         \
++		.id = _id, .name = _name, .parent_name = _parent, \
++		.regs = &infra2_cg_regs, .shift = _shift,         \
++		.ops = &mtk_clk_gate_ops_setclr,                  \
++	}
++
++#define GATE_INFRA3(_id, _name, _parent, _shift)                  \
++	{                                                         \
++		.id = _id, .name = _name, .parent_name = _parent, \
++		.regs = &infra3_cg_regs, .shift = _shift,         \
++		.ops = &mtk_clk_gate_ops_setclr,                  \
++	}
++
++#define GATE_CRITICAL(_id, _name, _parent, _regs, _shift)                 \
++	{                                                                 \
++		.id = _id, .name = _name, .parent_name = _parent,         \
++		.regs = _regs, .shift = _shift, .flags = CLK_IS_CRITICAL, \
++		.ops = &mtk_clk_gate_ops_setclr,                          \
++	}
++
++static const struct mtk_gate infra_clks[] __initconst = {
++	/* INFRA1 */
++	GATE_INFRA1(CLK_INFRA_66M_GPT_BCK, "infra_hf_66m_gpt_bck",
++		    "sysaxi_sel", 0),
++	GATE_INFRA1(CLK_INFRA_66M_PWM_HCK, "infra_hf_66m_pwm_hck",
++		    "sysaxi_sel", 1),
++	GATE_INFRA1(CLK_INFRA_66M_PWM_BCK, "infra_hf_66m_pwm_bck",
++		    "infra_pwm_bck_sel", 2),
++	GATE_INFRA1(CLK_INFRA_133M_CQDMA_BCK, "infra_hf_133m_cqdma_bck",
++		    "sysaxi_sel", 12),
++	GATE_INFRA1(CLK_INFRA_66M_AUD_SLV_BCK, "infra_66m_aud_slv_bck",
++		    "sysaxi_sel", 13),
++	GATE_INFRA1(CLK_INFRA_AUD_26M, "infra_f_faud_26m",
++		    "csw_infra_f26m_sel", 14),
++	GATE_INFRA1(CLK_INFRA_AUD_L, "infra_f_faud_l", "aud_l_sel", 15),
++	GATE_INFRA1(CLK_INFRA_AUD_AUD, "infra_f_aud_aud", "a1sys_sel", 16),
++	GATE_INFRA1(CLK_INFRA_AUD_EG2, "infra_f_faud_eg2", "a_tuner_sel", 18),
++	GATE_INFRA1(CLK_INFRA_DRAMC_F26M, "infra_dramc_f26m",
++		    "csw_infra_f26m_sel", 19),
++	GATE_CRITICAL(CLK_INFRA_133M_DBG_ACKM, "infra_hf_133m_dbg_ackm",
++		      "sysaxi_sel", &infra1_cg_regs, 20),
++	GATE_INFRA1(CLK_INFRA_66M_AP_DMA_BCK, "infra_66m_ap_dma_bck",
++		    "sysaxi_sel", 21),
++	GATE_INFRA1(CLK_INFRA_MSDC200_SRC, "infra_f_fmsdc200_src",
++		    "emmc_200m_sel", 28),
++	GATE_CRITICAL(CLK_INFRA_66M_SEJ_BCK, "infra_hf_66m_sej_bck",
++		      "sysaxi_sel", &infra1_cg_regs, 29),
++	GATE_CRITICAL(CLK_INFRA_PRE_CK_SEJ_F13M, "infra_pre_ck_sej_f13m",
++		    "csw_infra_f26m_sel", &infra1_cg_regs, 30),
++	GATE_CRITICAL(CLK_INFRA_66M_TRNG, "infra_hf_66m_trng", "sysaxi_sel",
++		      &infra1_cg_regs, 31),
++	/* INFRA2 */
++	GATE_INFRA2(CLK_INFRA_26M_THERM_SYSTEM, "infra_hf_26m_therm_system",
++		    "csw_infra_f26m_sel", 0),
++	GATE_INFRA2(CLK_INFRA_I2C_BCK, "infra_i2c_bck", "i2c_sel", 1),
++	GATE_INFRA2(CLK_INFRA_66M_UART0_PCK, "infra_hf_66m_uart0_pck",
++		    "sysaxi_sel", 3),
++	GATE_INFRA2(CLK_INFRA_66M_UART1_PCK, "infra_hf_66m_uart1_pck",
++		    "sysaxi_sel", 4),
++	GATE_INFRA2(CLK_INFRA_66M_UART2_PCK, "infra_hf_66m_uart2_pck",
++		    "sysaxi_sel", 5),
++	GATE_INFRA2(CLK_INFRA_52M_UART0_CK, "infra_f_52m_uart0",
++		    "infra_mux_uart0_sel", 3),
++	GATE_INFRA2(CLK_INFRA_52M_UART1_CK, "infra_f_52m_uart1",
++		    "infra_mux_uart1_sel", 4),
++	GATE_INFRA2(CLK_INFRA_52M_UART2_CK, "infra_f_52m_uart2",
++		    "infra_mux_uart2_sel", 5),
++	GATE_INFRA2(CLK_INFRA_NFI, "infra_f_fnfi", "nfi_sel", 9),
++	GATE_CRITICAL(CLK_INFRA_66M_NFI_HCK, "infra_hf_66m_nfi_hck",
++		      "sysaxi_sel", &infra2_cg_regs, 11),
++	GATE_INFRA2(CLK_INFRA_104M_SPI0, "infra_hf_104m_spi0",
++		    "infra_mux_spi0_sel", 12),
++	GATE_INFRA2(CLK_INFRA_104M_SPI1, "infra_hf_104m_spi1",
++		    "infra_mux_spi1_sel", 13),
++	GATE_INFRA2(CLK_INFRA_104M_SPI2_BCK, "infra_hf_104m_spi2_bck",
++		    "infra_mux_spi2_bck_sel", 14),
++	GATE_INFRA2(CLK_INFRA_66M_SPI0_HCK, "infra_hf_66m_spi0_hck",
++		    "sysaxi_sel", 15),
++	GATE_INFRA2(CLK_INFRA_66M_SPI1_HCK, "infra_hf_66m_spi1_hck",
++		    "sysaxi_sel", 16),
++	GATE_INFRA2(CLK_INFRA_66M_SPI2_HCK, "infra_hf_66m_spi2_hck",
++		    "sysaxi_sel", 17),
++	GATE_INFRA2(CLK_INFRA_66M_FLASHIF_AXI, "infra_hf_66m_flashif_axi",
++		    "sysaxi_sel", 18),
++	GATE_CRITICAL(CLK_INFRA_RTC, "infra_f_frtc", "cb_rtc_32k",
++		      &infra2_cg_regs, 19),
++	GATE_INFRA2(CLK_INFRA_26M_ADC_BCK, "infra_f_26m_adc_bck",
++		    "csw_infra_f26m_sel", 20),
++	GATE_INFRA2(CLK_INFRA_RC_ADC, "infra_f_frc_adc", "infra_f_26m_adc_bck",
++		    21),
++	GATE_INFRA2(CLK_INFRA_MSDC400, "infra_f_fmsdc400", "emmc_400m_sel",
++		    22),
++	GATE_INFRA2(CLK_INFRA_MSDC2_HCK, "infra_f_fmsdc2_hck", "emmc_250m_sel",
++		    23),
++	GATE_INFRA2(CLK_INFRA_133M_MSDC_0_HCK, "infra_hf_133m_msdc_0_hck",
++		    "sysaxi_sel", 24),
++	GATE_INFRA2(CLK_INFRA_66M_MSDC_0_HCK, "infra_66m_msdc_0_hck",
++		    "sysaxi_sel", 25),
++	GATE_INFRA2(CLK_INFRA_133M_CPUM_BCK, "infra_hf_133m_cpum_bck",
++		    "sysaxi_sel", 26),
++	GATE_INFRA2(CLK_INFRA_BIST2FPC, "infra_hf_fbist2fpc", "nfi_sel", 27),
++	GATE_INFRA2(CLK_INFRA_I2C_X16W_MCK_CK_P1,
++		    "infra_hf_i2c_x16w_mck_ck_p1", "sysaxi_sel", 29),
++	GATE_INFRA2(CLK_INFRA_I2C_X16W_PCK_CK_P1,
++		    "infra_hf_i2c_x16w_pck_ck_p1", "sysaxi_sel", 31),
++	/* INFRA3 */
++	GATE_INFRA3(CLK_INFRA_133M_USB_HCK, "infra_133m_usb_hck", "sysaxi_sel",
++		    0),
++	GATE_INFRA3(CLK_INFRA_133M_USB_HCK_CK_P1, "infra_133m_usb_hck_ck_p1",
++		    "sysaxi_sel", 1),
++	GATE_INFRA3(CLK_INFRA_66M_USB_HCK, "infra_66m_usb_hck", "sysaxi_sel",
++		    2),
++	GATE_INFRA3(CLK_INFRA_66M_USB_HCK_CK_P1, "infra_66m_usb_hck_ck_p1",
++		    "sysaxi_sel", 3),
++	GATE_INFRA3(CLK_INFRA_USB_SYS_CK_P1, "infra_usb_sys_ck_p1",
++		    "usb_sys_p1_sel", 5),
++	GATE_INFRA3(CLK_INFRA_USB_CK_P1, "infra_usb_ck_p1", "cb_cksq_40m", 7),
++	GATE_CRITICAL(CLK_INFRA_USB_FRMCNT_CK_P1, "infra_usb_frmcnt_ck_p1",
++		      "cksq_40m_d2", &infra3_cg_regs, 9),
++	GATE_CRITICAL(CLK_INFRA_USB_PIPE_CK_P1, "infra_usb_pipe_ck_p1",
++		      "usb_phy_sel", &infra3_cg_regs, 11),
++	GATE_INFRA3(CLK_INFRA_USB_UTMI_CK_P1, "infra_usb_utmi_ck_p1",
++		    "clkxtal", 13),
++	GATE_INFRA3(CLK_INFRA_USB_XHCI_CK_P1, "infra_usb_xhci_ck_p1",
++		    "usb_xhci_p1_sel", 15),
++	GATE_INFRA3(CLK_INFRA_PCIE_GFMUX_TL_P0, "infra_pcie_gfmux_tl_ck_p0",
++		    "infra_pcie_gfmux_tl_ck_o_p0_sel", 20),
++	GATE_INFRA3(CLK_INFRA_PCIE_GFMUX_TL_P1, "infra_pcie_gfmux_tl_ck_p1",
++		    "infra_pcie_gfmux_tl_ck_o_p1_sel", 21),
++	GATE_INFRA3(CLK_INFRA_PCIE_PIPE_P0, "infra_pcie_pipe_ck_p0", "clkxtal",
++		    24),
++	GATE_INFRA3(CLK_INFRA_PCIE_PIPE_P1, "infra_pcie_pipe_ck_p1", "clkxtal",
++		    25),
++	GATE_INFRA3(CLK_INFRA_133M_PCIE_CK_P0, "infra_133m_pcie_ck_p0",
++		    "sysaxi_sel", 28),
++	GATE_INFRA3(CLK_INFRA_133M_PCIE_CK_P1, "infra_133m_pcie_ck_p1",
++		    "sysaxi_sel", 29),
++	/* INFRA0 */
++	GATE_INFRA0(CLK_INFRA_PCIE_PERI_26M_CK_P0,
++		    "infra_pcie_peri_ck_26m_ck_p0", "csw_infra_f26m_sel", 7),
++	GATE_INFRA0(CLK_INFRA_PCIE_PERI_26M_CK_P1,
++		    "infra_pcie_peri_ck_26m_ck_p1", "csw_infra_f26m_sel", 8),
++};
++
++static u16 infra_rst_ofs[] = {
++	MT7987_INFRA_RST0_SET_OFFSET,
++	MT7987_INFRA_RST1_SET_OFFSET,
++};
++
++static u16 infra_idx_map[] = {
++	[MT7987_INFRA_RST0_PEXTP_MAC_SWRST] = 0 * RST_NR_PER_BANK + 6,
++	[MT7987_INFRA_RST1_THERM_CTRL_SWRST] = 1 * RST_NR_PER_BANK + 9,
++};
++
++static struct mtk_clk_rst_desc infra_rst_desc = {
++	.version = MTK_RST_SET_CLR,
++	.rst_bank_ofs = infra_rst_ofs,
++	.rst_bank_nr = ARRAY_SIZE(infra_rst_ofs),
++	.rst_idx_map = infra_idx_map,
++	.rst_idx_map_nr = ARRAY_SIZE(infra_idx_map),
++};
++
++static const struct mtk_clk_desc infra_desc = {
++	.clks = infra_clks,
++	.num_clks = ARRAY_SIZE(infra_clks),
++	.mux_clks = infra_muxes,
++	.num_mux_clks = ARRAY_SIZE(infra_muxes),
++	.clk_lock = &mt7987_clk_lock,
++	.rst_desc = &infra_rst_desc,
++};
++
++static const struct of_device_id of_match_clk_mt7987_infracfg[] = {
++	{ .compatible = "mediatek,mt7987-infracfg", .data = &infra_desc },
++	{ /* sentinel */ }
++};
++MODULE_DEVICE_TABLE(of, of_match_clk_mt7987_infracfg);
++
++static struct platform_driver clk_mt7987_infracfg_drv = {
++	.driver = {
++		.name = "clk-mt7987-infracfg",
++		.of_match_table = of_match_clk_mt7987_infracfg,
++	},
++	.probe = mtk_clk_simple_probe,
++	.remove_new = mtk_clk_simple_remove,
++};
++module_platform_driver(clk_mt7987_infracfg_drv);
++MODULE_LICENSE("GPL");
+--- /dev/null
++++ b/drivers/clk/mediatek/clk-mt7987-mcusys.c
+@@ -0,0 +1,47 @@
++// SPDX-License-Identifier: GPL-2.0
++/*
++ * Copyright (c) 2024 MediaTek Inc.
++ * Author: Lu Tang <Lu.Tang@mediatek.com>
++ * Author: Sam Shih <sam.shih@mediatek.com>
++ */
++
++#include <linux/clk-provider.h>
++#include <linux/of.h>
++#include <linux/of_address.h>
++#include <linux/of_device.h>
++#include <linux/platform_device.h>
++#include "clk-mtk.h"
++#include "clk-gate.h"
++#include "clk-mux.h"
++#include <dt-bindings/clock/mediatek,mt7987-clk.h>
++
++static DEFINE_SPINLOCK(mt7987_clk_lock);
++static const char *const mcu_bus_div_parents[] = { "cb_cksq_40m", "arm_ll" };
++
++static struct mtk_composite mcu_muxes[] = {
++	MUX_GATE_FLAGS(CLK_MCU_BUS_DIV_SEL, "mcu_bus_div_sel",
++		       mcu_bus_div_parents, 0x7C0, 9, 1, -1, CLK_IS_CRITICAL),
++};
++
++static const struct mtk_clk_desc mcusys_desc = {
++	.composite_clks = mcu_muxes,
++	.num_composite_clks = ARRAY_SIZE(mcu_muxes),
++	.clk_lock = &mt7987_clk_lock,
++};
++
++static const struct of_device_id of_match_clk_mt7987_mcusys[] = {
++	{ .compatible = "mediatek,mt7987-mcusys", .data = &mcusys_desc },
++	{ /* sentinel */ }
++};
++MODULE_DEVICE_TABLE(of, of_match_clk_mt7987_mcusys);
++
++static struct platform_driver clk_mt7987_mcusys_drv = {
++	.driver = {
++		.name = "clk-mt7987-mcusys",
++		.of_match_table = of_match_clk_mt7987_mcusys,
++	},
++	.probe = mtk_clk_simple_probe,
++	.remove_new = mtk_clk_simple_remove,
++};
++module_platform_driver(clk_mt7987_mcusys_drv);
++MODULE_LICENSE("GPL");
+--- /dev/null
++++ b/drivers/clk/mediatek/clk-mt7987-topckgen.c
+@@ -0,0 +1,311 @@
++// SPDX-License-Identifier: GPL-2.0
++/*
++ * Copyright (c) 2024 MediaTek Inc.
++ * Author: Lu Tang <Lu.Tang@mediatek.com>
++ * Author: Sam Shih <sam.shih@mediatek.com>
++ */
++
++#include <linux/clk-provider.h>
++#include <linux/of.h>
++#include <linux/of_address.h>
++#include <linux/of_device.h>
++#include <linux/platform_device.h>
++#include "clk-mtk.h"
++#include "clk-gate.h"
++#include "clk-mux.h"
++#include <dt-bindings/clock/mediatek,mt7987-clk.h>
++
++static DEFINE_SPINLOCK(mt7987_clk_lock);
++
++static const struct mtk_fixed_factor top_divs[] __initconst = {
++	FACTOR(CLK_TOP_CB_M_D2, "cb_m_d2", "mpll", 1, 2),
++	FACTOR(CLK_TOP_CB_M_D3, "cb_m_d3", "mpll", 1, 3),
++	FACTOR(CLK_TOP_M_D3_D2, "m_d3_d2", "mpll", 1, 6),
++	FACTOR(CLK_TOP_CB_M_D4, "cb_m_d4", "mpll", 1, 4),
++	FACTOR(CLK_TOP_CB_M_D8, "cb_m_d8", "mpll", 1, 8),
++	FACTOR(CLK_TOP_M_D8_D2, "m_d8_d2", "mpll", 1, 16),
++	FACTOR(CLK_TOP_CB_APLL2_D4, "cb_apll2_d4", "apll2", 1, 4),
++	FACTOR(CLK_TOP_CB_NET1_D3, "cb_net1_d3", "net1pll", 1, 3),
++	FACTOR(CLK_TOP_CB_NET1_D4, "cb_net1_d4", "net1pll", 1, 4),
++	FACTOR(CLK_TOP_CB_NET1_D5, "cb_net1_d5", "net1pll", 1, 5),
++	FACTOR(CLK_TOP_NET1_D5_D2, "net1_d5_d2", "net1pll", 1, 10),
++	FACTOR(CLK_TOP_NET1_D5_D4, "net1_d5_d4", "net1pll", 1, 20),
++	FACTOR(CLK_TOP_CB_NET1_D7, "cb_net1_d7", "net1pll", 1, 7),
++	FACTOR(CLK_TOP_NET1_D7_D2, "net1_d7_d2", "net1pll", 1, 14),
++	FACTOR(CLK_TOP_NET1_D7_D4, "net1_d7_d4", "net1pll", 1, 28),
++	FACTOR(CLK_TOP_NET1_D8_D2, "net1_d8_d2", "net1pll", 1, 16),
++	FACTOR(CLK_TOP_NET1_D8_D4, "net1_d8_d4", "net1pll", 1, 32),
++	FACTOR(CLK_TOP_NET1_D8_D8, "net1_d8_d8", "net1pll", 1, 64),
++	FACTOR(CLK_TOP_NET1_D8_D16, "net1_d8_d16", "net1pll", 1, 128),
++	FACTOR(CLK_TOP_CB_NET2_D2, "cb_net2_d2", "net2pll", 1, 2),
++	FACTOR(CLK_TOP_CB_NET2_D4, "cb_net2_d4", "net2pll", 1, 4),
++	FACTOR(CLK_TOP_NET2_D4_D4, "net2_d4_d4", "net2pll", 1, 16),
++	FACTOR(CLK_TOP_NET2_D4_D8, "net2_d4_d8", "net2pll", 1, 32),
++	FACTOR(CLK_TOP_CB_NET2_D6, "cb_net2_d6", "net2pll", 1, 6),
++	FACTOR(CLK_TOP_NET2_D7_D2, "net2_d7_d2", "net2pll", 1, 14),
++	FACTOR(CLK_TOP_CB_NET2_D8, "cb_net2_d8", "net2pll", 1, 8),
++	FACTOR(CLK_TOP_MSDC_D2, "msdc_d2", "msdcpll", 1, 2),
++	FACTOR(CLK_TOP_CB_CKSQ_40M, "cb_cksq_40m", "clkxtal", 1, 1),
++	FACTOR(CLK_TOP_CKSQ_40M_D2, "cksq_40m_d2", "cb_cksq_40m", 1, 2),
++	FACTOR(CLK_TOP_CB_RTC_32K, "cb_rtc_32k", "cb_cksq_40m", 1, 1250),
++	FACTOR(CLK_TOP_CB_RTC_32P7K, "cb_rtc_32p7k", "cb_cksq_40m", 1, 1221),
++};
++
++static const char *const netsys_parents[] = { "cb_cksq_40m", "cb_net2_d2" };
++
++static const char *const netsys_500m_parents[] = { "cb_cksq_40m", "cb_net1_d5",
++						   "net1_d5_d2" };
++
++static const char *const netsys_2x_parents[] = { "cb_cksq_40m", "net2pll" };
++
++static const char *const eth_gmii_parents[] = { "cb_cksq_40m", "net1_d5_d4" };
++
++static const char *const eip_parents[] = { "cb_cksq_40m", "cb_net1_d3",
++					   "net2pll", "cb_net1_d4",
++					   "cb_net1_d5" };
++
++static const char *const axi_infra_parents[] = { "cb_cksq_40m", "net1_d8_d2" };
++
++static const char *const uart_parents[] = { "cb_cksq_40m", "cb_m_d8",
++					    "m_d8_d2" };
++
++static const char *const emmc_250m_parents[] = { "cb_cksq_40m", "net1_d5_d2",
++						 "net1_d7_d2" };
++
++static const char *const emmc_400m_parents[] = { "cb_cksq_40m", "msdcpll",
++						 "cb_net1_d7",	"cb_m_d2",
++						 "net1_d7_d2",	"cb_net2_d6" };
++
++static const char *const spi_parents[] = { "cb_cksq_40m", "cb_m_d2",
++					   "net1_d7_d2",  "net1_d8_d2",
++					   "cb_net2_d6",  "net1_d5_d4",
++					   "cb_m_d4",	  "net1_d8_d4" };
++
++static const char *const nfi_parents[] = {
++	"cksq_40m_d2", "net1_d8_d2", "cb_m_d3", "net1_d5_d4", "cb_m_d4",
++	"net1_d7_d4",  "net1_d8_d4", "m_d3_d2", "net2_d7_d2", "cb_m_d8"
++};
++
++static const char *const pwm_parents[] = { "cb_cksq_40m", "net1_d8_d2",
++					   "net1_d5_d4",  "cb_m_d4",
++					   "m_d8_d2",	  "cb_rtc_32k" };
++
++static const char *const i2c_parents[] = { "cb_cksq_40m", "net1_d5_d4",
++					   "cb_m_d4", "net1_d8_d4" };
++
++static const char *const pcie_mbist_250m_parents[] = { "cb_cksq_40m",
++						       "net1_d5_d2" };
++
++static const char *const pextp_tl_ck_parents[] = { "cb_cksq_40m", "cb_net2_d6",
++						   "net1_d7_d4", "m_d8_d2",
++						   "cb_rtc_32k" };
++
++static const char *const aud_parents[] = { "cb_cksq_40m", "apll2" };
++
++static const char *const a1sys_parents[] = { "cb_cksq_40m", "cb_apll2_d4" };
++
++static const char *const aud_l_parents[] = { "cb_cksq_40m", "apll2",
++					     "m_d8_d2" };
++
++static const char *const usb_phy_parents[] = { "cksq_40m_d2", "m_d8_d2" };
++
++static const char *const sgm_0_parents[] = { "cb_cksq_40m", "sgmpll" };
++
++static const char *const sgm_sbus_0_parents[] = { "cb_cksq_40m",
++						  "net1_d8_d4" };
++
++static const char *const sysapb_parents[] = { "cb_cksq_40m", "m_d3_d2" };
++
++static const char *const eth_refck_50m_parents[] = { "cb_cksq_40m",
++						     "net2_d4_d4" };
++
++static const char *const eth_sys_200m_parents[] = { "cb_cksq_40m",
++						    "cb_net2_d4" };
++
++static const char *const eth_xgmii_parents[] = { "cksq_40m_d2", "net1_d8_d8",
++						 "net1_d8_d16" };
++
++static const char *const dramc_md32_parents[] = { "cb_cksq_40m", "cb_m_d2",
++						  "wedmcupll" };
++
++static const char *const da_xtp_glb_p0_parents[] = { "cb_cksq_40m",
++						     "cb_net2_d8" };
++
++static const char *const da_ckm_xtal_parents[] = { "cb_cksq_40m", "m_d8_d2" };
++
++static const char *const eth_mii_parents[] = { "cksq_40m_d2", "net2_d4_d8" };
++
++static const char *const emmc_200m_parents[] = { "cb_cksq_40m", "msdc_d2",
++						 "net1_d7_d2", "cb_net2_d6",
++						 "net1_d7_d4" };
++
++static struct mtk_mux top_muxes[] = {
++	/* CLK_CFG_0 */
++	MUX_GATE_CLR_SET_UPD(CLK_TOP_NETSYS_SEL, "netsys_sel", netsys_parents,
++			     0x000, 0x004, 0x008, 0, 1, 7, 0x1C0, 0),
++	MUX_GATE_CLR_SET_UPD(CLK_TOP_NETSYS_500M_SEL, "netsys_500m_sel",
++			     netsys_500m_parents, 0x000, 0x004, 0x008, 8, 2,
++			     15, 0x1C0, 1),
++	MUX_GATE_CLR_SET_UPD(CLK_TOP_NETSYS_2X_SEL, "netsys_2x_sel",
++			     netsys_2x_parents, 0x000, 0x004, 0x008, 16, 1, 23,
++			     0x1C0, 2),
++	MUX_GATE_CLR_SET_UPD(CLK_TOP_ETH_GMII_SEL, "eth_gmii_sel",
++			     eth_gmii_parents, 0x000, 0x004, 0x008, 24, 1, 31,
++			     0x1C0, 3),
++	/* CLK_CFG_1 */
++	MUX_GATE_CLR_SET_UPD_FLAGS(CLK_TOP_EIP_SEL, "eip_sel", eip_parents,
++				   0x010, 0x014, 0x018, 0, 3, 7, 0x1C0, 4,
++				   CLK_IS_CRITICAL),
++	MUX_GATE_CLR_SET_UPD_FLAGS(CLK_TOP_AXI_INFRA_SEL, "axi_infra_sel",
++				   axi_infra_parents, 0x010, 0x014, 0x018, 8,
++				   1, 15, 0x1C0, 5, CLK_IS_CRITICAL),
++	MUX_GATE_CLR_SET_UPD(CLK_TOP_UART_SEL, "uart_sel", uart_parents, 0x010,
++			     0x014, 0x018, 16, 2, 23, 0x1C0, 6),
++	MUX_GATE_CLR_SET_UPD(CLK_TOP_EMMC_250M_SEL, "emmc_250m_sel",
++			     emmc_250m_parents, 0x010, 0x014, 0x018, 24, 2, 31,
++			     0x1C0, 7),
++	/* CLK_CFG_2 */
++	MUX_GATE_CLR_SET_UPD(CLK_TOP_EMMC_400M_SEL, "emmc_400m_sel",
++			     emmc_400m_parents, 0x020, 0x024, 0x028, 0, 3, 7,
++			     0x1C0, 8),
++	MUX_GATE_CLR_SET_UPD(CLK_TOP_SPI_SEL, "spi_sel", spi_parents, 0x020,
++			     0x024, 0x028, 8, 3, 15, 0x1C0, 9),
++	MUX_GATE_CLR_SET_UPD(CLK_TOP_SPIM_MST_SEL, "spim_mst_sel", spi_parents,
++			     0x020, 0x024, 0x028, 16, 3, 23, 0x1C0, 10),
++	MUX_GATE_CLR_SET_UPD(CLK_TOP_NFI_SEL, "nfi_sel", nfi_parents, 0x020,
++			     0x024, 0x028, 24, 4, 31, 0x1C0, 11),
++	/* CLK_CFG_3 */
++	MUX_GATE_CLR_SET_UPD(CLK_TOP_PWM_SEL, "pwm_sel", pwm_parents, 0x030,
++			     0x034, 0x038, 0, 3, 7, 0x1C0, 12),
++	MUX_GATE_CLR_SET_UPD(CLK_TOP_I2C_SEL, "i2c_sel", i2c_parents, 0x030,
++			     0x034, 0x038, 8, 2, 15, 0x1C0, 13),
++	MUX_GATE_CLR_SET_UPD(CLK_TOP_PCIE_MBIST_250M_SEL,
++			     "pcie_mbist_250m_sel", pcie_mbist_250m_parents,
++			     0x030, 0x034, 0x038, 16, 1, 23, 0x1C0, 14),
++	MUX_GATE_CLR_SET_UPD(CLK_TOP_PEXTP_TL_SEL, "pextp_tl_ck_sel",
++			     pextp_tl_ck_parents, 0x030, 0x034, 0x038, 24, 3,
++			     31, 0x1C0, 15),
++	/* CLK_CFG_4 */
++	MUX_GATE_CLR_SET_UPD(CLK_TOP_PEXTP_TL_P1_SEL, "pextp_tl_ck_p1_sel",
++			     pextp_tl_ck_parents, 0x040, 0x044, 0x048, 0, 3, 7,
++			     0x1C0, 16),
++	MUX_GATE_CLR_SET_UPD(CLK_TOP_USB_SYS_P1_SEL, "usb_sys_p1_sel",
++			     eth_gmii_parents, 0x040, 0x044, 0x048, 8, 1, 15,
++			     0x1C0, 17),
++	MUX_GATE_CLR_SET_UPD(CLK_TOP_USB_XHCI_P1_SEL, "usb_xhci_p1_sel",
++			     eth_gmii_parents, 0x040, 0x044, 0x048, 16, 1, 23,
++			     0x1C0, 18),
++	MUX_GATE_CLR_SET_UPD(CLK_TOP_AUD_SEL, "aud_sel", aud_parents, 0x040,
++			     0x044, 0x048, 24, 1, 31, 0x1C0, 19),
++	/* CLK_CFG_5 */
++	MUX_GATE_CLR_SET_UPD(CLK_TOP_A1SYS_SEL, "a1sys_sel", a1sys_parents,
++			     0x050, 0x054, 0x058, 0, 1, 7, 0x1C0, 20),
++	MUX_GATE_CLR_SET_UPD(CLK_TOP_AUD_L_SEL, "aud_l_sel", aud_l_parents,
++			     0x050, 0x054, 0x058, 8, 2, 15, 0x1C0, 21),
++	MUX_GATE_CLR_SET_UPD(CLK_TOP_A_TUNER_SEL, "a_tuner_sel", a1sys_parents,
++			     0x050, 0x054, 0x058, 16, 1, 23, 0x1C0, 22),
++	MUX_GATE_CLR_SET_UPD(CLK_TOP_USB_PHY_SEL, "usb_phy_sel",
++			     usb_phy_parents, 0x050, 0x054, 0x058, 24, 1, 31,
++			     0x1C0, 23),
++	/* CLK_CFG_6 */
++	MUX_GATE_CLR_SET_UPD(CLK_TOP_SGM_0_SEL, "sgm_0_sel", sgm_0_parents,
++			     0x060, 0x064, 0x068, 0, 1, 7, 0x1C0, 24),
++	MUX_GATE_CLR_SET_UPD_FLAGS(CLK_TOP_SGM_SBUS_0_SEL, "sgm_sbus_0_sel",
++				   sgm_sbus_0_parents, 0x060, 0x064, 0x068, 8,
++				   1, 15, 0x1C0, 25, CLK_IS_CRITICAL),
++	MUX_GATE_CLR_SET_UPD(CLK_TOP_SGM_1_SEL, "sgm_1_sel", sgm_0_parents,
++			     0x060, 0x064, 0x068, 16, 1, 23, 0x1C0, 26),
++	MUX_GATE_CLR_SET_UPD_FLAGS(CLK_TOP_SGM_SBUS_1_SEL, "sgm_sbus_1_sel",
++				   sgm_sbus_0_parents, 0x060, 0x064, 0x068, 24,
++				   1, 31, 0x1C0, 27, CLK_IS_CRITICAL),
++	/* CLK_CFG_7 */
++	MUX_GATE_CLR_SET_UPD_FLAGS(CLK_TOP_SYSAXI_SEL, "sysaxi_sel",
++				   axi_infra_parents, 0x070, 0x074, 0x078, 0,
++				   1, 7, 0x1C0, 28, CLK_IS_CRITICAL),
++	MUX_GATE_CLR_SET_UPD_FLAGS(CLK_TOP_SYSAPB_SEL, "sysapb_sel",
++				   sysapb_parents, 0x070, 0x074, 0x078, 8, 1,
++				   15, 0x1C0, 29, CLK_IS_CRITICAL),
++	MUX_GATE_CLR_SET_UPD(CLK_TOP_ETH_REFCK_50M_SEL, "eth_refck_50m_sel",
++			     eth_refck_50m_parents, 0x070, 0x074, 0x078, 16, 1,
++			     23, 0x1C0, 30),
++	MUX_GATE_CLR_SET_UPD(CLK_TOP_ETH_SYS_200M_SEL, "eth_sys_200m_sel",
++			     eth_sys_200m_parents, 0x070, 0x074, 0x078, 24, 1,
++			     31, 0x1C4, 0),
++	/* CLK_CFG_8 */
++	MUX_GATE_CLR_SET_UPD(CLK_TOP_ETH_SYS_SEL, "eth_sys_sel",
++			     pcie_mbist_250m_parents, 0x080, 0x084, 0x088, 0,
++			     1, 7, 0x1C4, 1),
++	MUX_GATE_CLR_SET_UPD(CLK_TOP_ETH_XGMII_SEL, "eth_xgmii_sel",
++			     eth_xgmii_parents, 0x080, 0x084, 0x088, 8, 2, 15,
++			     0x1C4, 2),
++	MUX_GATE_CLR_SET_UPD_FLAGS(CLK_TOP_DRAMC_SEL, "dramc_sel",
++				   usb_phy_parents, 0x080, 0x084, 0x088, 16, 1,
++				   23, 0x1C4, 3, CLK_IS_CRITICAL),
++	MUX_GATE_CLR_SET_UPD_FLAGS(CLK_TOP_DRAMC_MD32_SEL, "dramc_md32_sel",
++				   dramc_md32_parents, 0x080, 0x084, 0x088, 24,
++				   2, 31, 0x1C4, 4, CLK_IS_CRITICAL),
++	/* CLK_CFG_9 */
++	MUX_GATE_CLR_SET_UPD_FLAGS(CLK_TOP_INFRA_F26M_SEL,
++				   "csw_infra_f26m_sel", usb_phy_parents,
++				   0x090, 0x094, 0x098, 0, 1, 7, 0x1C4, 5,
++				   CLK_IS_CRITICAL),
++	MUX_GATE_CLR_SET_UPD_FLAGS(CLK_TOP_PEXTP_P0_SEL, "pextp_p0_sel",
++				   usb_phy_parents, 0x090, 0x094, 0x098, 8, 1,
++				   15, 0x1C4, 6, CLK_IS_CRITICAL),
++	MUX_GATE_CLR_SET_UPD_FLAGS(CLK_TOP_PEXTP_P1_SEL, "pextp_p1_sel",
++				   usb_phy_parents, 0x090, 0x094, 0x098, 16, 1,
++				   23, 0x1C4, 7, CLK_IS_CRITICAL),
++	MUX_GATE_CLR_SET_UPD(CLK_TOP_DA_XTP_GLB_P0_SEL, "da_xtp_glb_p0_sel",
++			     da_xtp_glb_p0_parents, 0x090, 0x094, 0x098, 24, 1,
++			     31, 0x1C4, 8),
++	/* CLK_CFG_10 */
++	MUX_GATE_CLR_SET_UPD(CLK_TOP_DA_XTP_GLB_P1_SEL, "da_xtp_glb_p1_sel",
++			     da_xtp_glb_p0_parents, 0x0A0, 0x0A4, 0x0A8, 0, 1,
++			     7, 0x1C4, 9),
++	MUX_GATE_CLR_SET_UPD(CLK_TOP_CKM_SEL, "ckm_sel", usb_phy_parents,
++			     0x0A0, 0x0A4, 0x0A8, 8, 1, 15, 0x1C4, 10),
++	MUX_GATE_CLR_SET_UPD(CLK_TOP_DA_CKM_XTAL_SEL, "da_ckm_xtal_sel",
++			     da_ckm_xtal_parents, 0x0A0, 0x0A4, 0x0A8, 16, 1,
++			     23, 0x1C4, 11),
++	MUX_GATE_CLR_SET_UPD(CLK_TOP_PEXTP_SEL, "pextp_sel", usb_phy_parents,
++			     0x0A0, 0x0A4, 0x0A8, 24, 1, 31, 0x1C4, 12),
++	/* CLK_CFG_11 */
++	MUX_GATE_CLR_SET_UPD(CLK_TOP_ETH_MII_SEL, "eth_mii_sel",
++			     eth_mii_parents, 0x0B0, 0x0B4, 0x0B8, 0, 1, 7,
++			     0x1C4, 13),
++	MUX_GATE_CLR_SET_UPD(CLK_TOP_EMMC_200M_SEL, "emmc_200m_sel",
++			     emmc_200m_parents, 0x0B0, 0x0B4, 0x0B8, 8, 3, 15,
++			     0x1C4, 14),
++};
++
++static const struct mtk_composite top_adj_divs[] = {
++	DIV_GATE(CLK_TOP_AUD_I2S_M, "aud_i2s_m", "aud_sel", 0x0420, 0, 0x0420,
++		 8, 8),
++};
++
++static const struct mtk_clk_desc topck_desc = {
++	.factor_clks = top_divs,
++	.num_factor_clks = ARRAY_SIZE(top_divs),
++	.mux_clks = top_muxes,
++	.num_mux_clks = ARRAY_SIZE(top_muxes),
++	.composite_clks = top_adj_divs,
++	.num_composite_clks = ARRAY_SIZE(top_adj_divs),
++	.clk_lock = &mt7987_clk_lock,
++};
++
++static const struct of_device_id of_match_clk_mt7987_topckgen[] = {
++	{ .compatible = "mediatek,mt7987-topckgen", .data = &topck_desc },
++	{ /* sentinel */ }
++};
++MODULE_DEVICE_TABLE(of, of_match_clk_mt7987_topckgen);
++
++static struct platform_driver clk_mt7987_topckgen_drv = {
++	.probe = mtk_clk_simple_probe,
++	.remove_new = mtk_clk_simple_remove,
++	.driver = {
++		.name = "clk-mt7987-topckgen",
++		.of_match_table = of_match_clk_mt7987_topckgen,
++	},
++};
++module_platform_driver(clk_mt7987_topckgen_drv);
++MODULE_LICENSE("GPL");
+--- /dev/null
++++ b/include/dt-bindings/clock/mediatek,mt7987-clk.h
+@@ -0,0 +1,206 @@
++/* SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause) */
++/*
++ * Copyright (c) 2024 MediaTek Inc.
++ * Author: Lu Tang <Lu.Tang@mediatek.com>
++ * Author: Sam Shih <sam.shih@mediatek.com>
++ */
++
++#ifndef _DT_BINDINGS_CLK_MT7987_H
++#define _DT_BINDINGS_CLK_MT7987_H
++
++/* INFRACFG */
++
++#define CLK_INFRA_MUX_UART0_SEL			0
++#define CLK_INFRA_MUX_UART1_SEL			1
++#define CLK_INFRA_MUX_UART2_SEL			2
++#define CLK_INFRA_MUX_SPI0_SEL			3
++#define CLK_INFRA_MUX_SPI1_SEL			4
++#define CLK_INFRA_MUX_SPI2_BCK_SEL		5
++#define CLK_INFRA_PWM_BCK_SEL			6
++#define CLK_INFRA_PCIE_GFMUX_TL_O_P0_SEL	7
++#define CLK_INFRA_PCIE_GFMUX_TL_O_P1_SEL	8
++#define CLK_INFRA_66M_GPT_BCK			9
++#define CLK_INFRA_66M_PWM_HCK			10
++#define CLK_INFRA_66M_PWM_BCK			11
++#define CLK_INFRA_133M_CQDMA_BCK		12
++#define CLK_INFRA_66M_AUD_SLV_BCK		13
++#define CLK_INFRA_AUD_26M			14
++#define CLK_INFRA_AUD_L				15
++#define CLK_INFRA_AUD_AUD			16
++#define CLK_INFRA_AUD_EG2			17
++#define CLK_INFRA_DRAMC_F26M			18
++#define CLK_INFRA_133M_DBG_ACKM			19
++#define CLK_INFRA_66M_AP_DMA_BCK		20
++#define CLK_INFRA_MSDC200_SRC			21
++#define CLK_INFRA_66M_SEJ_BCK			22
++#define CLK_INFRA_PRE_CK_SEJ_F13M		23
++#define CLK_INFRA_66M_TRNG			24
++#define CLK_INFRA_26M_THERM_SYSTEM		25
++#define CLK_INFRA_I2C_BCK			26
++#define CLK_INFRA_66M_UART0_PCK			27
++#define CLK_INFRA_66M_UART1_PCK			28
++#define CLK_INFRA_66M_UART2_PCK			29
++#define CLK_INFRA_52M_UART0_CK			30
++#define CLK_INFRA_52M_UART1_CK			31
++#define CLK_INFRA_52M_UART2_CK			32
++#define CLK_INFRA_NFI				33
++#define CLK_INFRA_66M_NFI_HCK			34
++#define CLK_INFRA_104M_SPI0			35
++#define CLK_INFRA_104M_SPI1			36
++#define CLK_INFRA_104M_SPI2_BCK			37
++#define CLK_INFRA_66M_SPI0_HCK			38
++#define CLK_INFRA_66M_SPI1_HCK			39
++#define CLK_INFRA_66M_SPI2_HCK			40
++#define CLK_INFRA_66M_FLASHIF_AXI		41
++#define CLK_INFRA_RTC				42
++#define CLK_INFRA_26M_ADC_BCK			43
++#define CLK_INFRA_RC_ADC			44
++#define CLK_INFRA_MSDC400			45
++#define CLK_INFRA_MSDC2_HCK			46
++#define CLK_INFRA_133M_MSDC_0_HCK		47
++#define CLK_INFRA_66M_MSDC_0_HCK		48
++#define CLK_INFRA_133M_CPUM_BCK			49
++#define CLK_INFRA_BIST2FPC			50
++#define CLK_INFRA_I2C_X16W_MCK_CK_P1		51
++#define CLK_INFRA_I2C_X16W_PCK_CK_P1		52
++#define CLK_INFRA_133M_USB_HCK			53
++#define CLK_INFRA_133M_USB_HCK_CK_P1		54
++#define CLK_INFRA_66M_USB_HCK			55
++#define CLK_INFRA_66M_USB_HCK_CK_P1		56
++#define CLK_INFRA_USB_SYS_CK_P1			57
++#define CLK_INFRA_USB_CK_P1			58
++#define CLK_INFRA_USB_FRMCNT_CK_P1		59
++#define CLK_INFRA_USB_PIPE_CK_P1		60
++#define CLK_INFRA_USB_UTMI_CK_P1		61
++#define CLK_INFRA_USB_XHCI_CK_P1		62
++#define CLK_INFRA_PCIE_GFMUX_TL_P0		63
++#define CLK_INFRA_PCIE_GFMUX_TL_P1		64
++#define CLK_INFRA_PCIE_PIPE_P0			65
++#define CLK_INFRA_PCIE_PIPE_P1			66
++#define CLK_INFRA_133M_PCIE_CK_P0		67
++#define CLK_INFRA_133M_PCIE_CK_P1		68
++#define CLK_INFRA_PCIE_PERI_26M_CK_P0		69
++#define CLK_INFRA_PCIE_PERI_26M_CK_P1		70
++#define CLK_INFRA_NR_CLK			71
++
++/* TOPCKGEN */
++
++#define CLK_TOP_CB_M_D2				0
++#define CLK_TOP_CB_M_D3				1
++#define CLK_TOP_M_D3_D2				2
++#define CLK_TOP_CB_M_D4				3
++#define CLK_TOP_CB_M_D8				4
++#define CLK_TOP_M_D8_D2				5
++#define CLK_TOP_CB_APLL2_D4			6
++#define CLK_TOP_CB_NET1_D3			7
++#define CLK_TOP_CB_NET1_D4			8
++#define CLK_TOP_CB_NET1_D5			9
++#define CLK_TOP_NET1_D5_D2			10
++#define CLK_TOP_NET1_D5_D4			11
++#define CLK_TOP_CB_NET1_D7			12
++#define CLK_TOP_NET1_D7_D2			13
++#define CLK_TOP_NET1_D7_D4			14
++#define CLK_TOP_NET1_D8_D2			15
++#define CLK_TOP_NET1_D8_D4			16
++#define CLK_TOP_NET1_D8_D8			17
++#define CLK_TOP_NET1_D8_D16			18
++#define CLK_TOP_CB_NET2_D2			19
++#define CLK_TOP_CB_NET2_D4			20
++#define CLK_TOP_NET2_D4_D4			21
++#define CLK_TOP_NET2_D4_D8			22
++#define CLK_TOP_CB_NET2_D6			23
++#define CLK_TOP_NET2_D7_D2			24
++#define CLK_TOP_CB_NET2_D8			25
++#define CLK_TOP_MSDC_D2				26
++#define CLK_TOP_CB_CKSQ_40M			27
++#define CLK_TOP_CKSQ_40M_D2			28
++#define CLK_TOP_CB_RTC_32K			29
++#define CLK_TOP_CB_RTC_32P7K			30
++#define CLK_TOP_NETSYS_SEL			31
++#define CLK_TOP_NETSYS_500M_SEL			32
++#define CLK_TOP_NETSYS_2X_SEL			33
++#define CLK_TOP_ETH_GMII_SEL			34
++#define CLK_TOP_EIP_SEL				35
++#define CLK_TOP_AXI_INFRA_SEL			36
++#define CLK_TOP_UART_SEL			37
++#define CLK_TOP_EMMC_250M_SEL			38
++#define CLK_TOP_EMMC_400M_SEL			39
++#define CLK_TOP_SPI_SEL				40
++#define CLK_TOP_SPIM_MST_SEL			41
++#define CLK_TOP_NFI_SEL				42
++#define CLK_TOP_PWM_SEL				43
++#define CLK_TOP_I2C_SEL				44
++#define CLK_TOP_PCIE_MBIST_250M_SEL		45
++#define CLK_TOP_PEXTP_TL_SEL			46
++#define CLK_TOP_PEXTP_TL_P1_SEL			47
++#define CLK_TOP_USB_SYS_P1_SEL			48
++#define CLK_TOP_USB_XHCI_P1_SEL			49
++#define CLK_TOP_AUD_SEL				50
++#define CLK_TOP_A1SYS_SEL			51
++#define CLK_TOP_AUD_L_SEL			52
++#define CLK_TOP_A_TUNER_SEL			53
++#define CLK_TOP_USB_PHY_SEL			54
++#define CLK_TOP_SGM_0_SEL			55
++#define CLK_TOP_SGM_SBUS_0_SEL			56
++#define CLK_TOP_SGM_1_SEL			57
++#define CLK_TOP_SGM_SBUS_1_SEL			58
++#define CLK_TOP_SYSAXI_SEL			59
++#define CLK_TOP_SYSAPB_SEL			60
++#define CLK_TOP_ETH_REFCK_50M_SEL		61
++#define CLK_TOP_ETH_SYS_200M_SEL		62
++#define CLK_TOP_ETH_SYS_SEL			63
++#define CLK_TOP_ETH_XGMII_SEL			64
++#define CLK_TOP_DRAMC_SEL			65
++#define CLK_TOP_DRAMC_MD32_SEL			66
++#define CLK_TOP_INFRA_F26M_SEL			67
++#define CLK_TOP_PEXTP_P0_SEL			68
++#define CLK_TOP_PEXTP_P1_SEL			69
++#define CLK_TOP_DA_XTP_GLB_P0_SEL		70
++#define CLK_TOP_DA_XTP_GLB_P1_SEL		71
++#define CLK_TOP_CKM_SEL				72
++#define CLK_TOP_DA_CKM_XTAL_SEL			73
++#define CLK_TOP_PEXTP_SEL			74
++#define CLK_TOP_ETH_MII_SEL			75
++#define CLK_TOP_EMMC_200M_SEL			76
++#define CLK_TOP_AUD_I2S_M			77
++#define CLK_TOP_NR_CLK				78
++
++/* APMIXEDSYS */
++
++#define CLK_APMIXED_MPLL			0
++#define CLK_APMIXED_APLL2			1
++#define CLK_APMIXED_NET1PLL			2
++#define CLK_APMIXED_NET2PLL			3
++#define CLK_APMIXED_WEDMCUPLL			4
++#define CLK_APMIXED_SGMPLL			5
++#define CLK_APMIXED_ARM_LL			6
++#define CLK_APMIXED_MSDCPLL			7
++#define CLK_APMIXED_NR_CLK			8
++
++/* MCUSYS */
++
++#define CLK_MCU_BUS_DIV_SEL			0
++#define CLK_MCU_NR_CLK				1
++
++/* SGMIISYS_0 */
++
++#define CLK_SGM0_TX_EN				0
++#define CLK_SGM0_RX_EN				1
++#define CLK_SGMII0_NR_CLK			2
++
++/* SGMIISYS_1 */
++
++#define CLK_SGM1_TX_EN				0
++#define CLK_SGM1_RX_EN				1
++#define CLK_SGMII1_NR_CLK			2
++
++/* ETHDMA */
++
++#define CLK_ETHDMA_FE_EN			0
++#define CLK_ETHDMA_GP2_EN			1
++#define CLK_ETHDMA_GP1_EN			2
++#define CLK_ETHDMA_GP3_EN			3
++#define CLK_ETHDMA_NR_CLK			4
++
++#endif /* _DT_BINDINGS_CLK_MT7987_H */
++
+--- /dev/null
++++ b/include/dt-bindings/reset/mediatek,mt7987-resets.h
+@@ -0,0 +1,10 @@
++/* SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause) */
++
++#ifndef _DT_BINDINGS_RESET_CONTROLLER_MT7987
++#define _DT_BINDINGS_RESET_CONTROLLER_MT7987
++
++/* INFRA resets */
++#define MT7987_INFRA_RST0_PEXTP_MAC_SWRST	0
++#define MT7987_INFRA_RST1_THERM_CTRL_SWRST	1
++
++#endif  /* _DT_BINDINGS_RESET_CONTROLLER_MT7987 */
--- /dev/null
+++ b/target/linux/mediatek/patches-6.12/810-tty-serial-8250_mtk-enable-baud-clock.patch
@@ -0,0 +1,54 @@
+From e924479ebc284f591e90049c03aeef6da7786318 Mon Sep 17 00:00:00 2001
+From: Daniel Golle <daniel@makrotopia.org>
+Date: Mon, 15 Sep 2025 12:05:06 +0100
+Subject: [PATCH] tty: serial: 8250_mtk: enable baud clock
+
+Some MediaTek SoCs got a gated UART baud clock, which currently gets
+disabled as the clk subsystem believes it would be unused. This results in
+the uart freezing right after "clk: Disabling unused clocks" on those
+platforms.
+
+To fix this request the baud clock to be prepared and enabled during probe,
+and also prepare and enable the baud clock when resume the port while
+disabling and unpreparing it when suspending.
+
+Fixes: e32a83c70cf9 ("serial: 8250-mtk: modify mtk uart power and clock management")
+Signed-off-by: Daniel Golle <daniel@makrotopia.org>
+---
+ drivers/tty/serial/8250/8250_mtk.c | 6 ++++--
+ 1 file changed, 4 insertions(+), 2 deletions(-)
+
+--- a/drivers/tty/serial/8250/8250_mtk.c
++++ b/drivers/tty/serial/8250/8250_mtk.c
+@@ -435,6 +435,7 @@ static int __maybe_unused mtk8250_runtim
+ 	while
+ 		(serial_in(up, MTK_UART_DEBUG0));
+ 
++	clk_disable_unprepare(data->uart_clk);
+ 	clk_disable_unprepare(data->bus_clk);
+ 
+ 	return 0;
+@@ -445,6 +446,7 @@ static int __maybe_unused mtk8250_runtim
+ 	struct mtk8250_data *data = dev_get_drvdata(dev);
+ 
+ 	clk_prepare_enable(data->bus_clk);
++	clk_prepare_enable(data->uart_clk);
+ 
+ 	return 0;
+ }
+@@ -475,13 +477,13 @@ static int mtk8250_probe_of(struct platf
+ 	int dmacnt;
+ #endif
+ 
+-	data->uart_clk = devm_clk_get(&pdev->dev, "baud");
++	data->uart_clk = devm_clk_get_enabled(&pdev->dev, "baud");
+ 	if (IS_ERR(data->uart_clk)) {
+ 		/*
+ 		 * For compatibility with older device trees try unnamed
+ 		 * clk when no baud clk can be found.
+ 		 */
+-		data->uart_clk = devm_clk_get(&pdev->dev, NULL);
++		data->uart_clk = devm_clk_get_enabled(&pdev->dev, NULL);
+ 		if (IS_ERR(data->uart_clk)) {
+ 			dev_warn(&pdev->dev, "Can't get uart clock\n");
+ 			return PTR_ERR(data->uart_clk);
--- /dev/null
+++ b/target/linux/mediatek/patches-6.12/821-add-pwm-feature-for-mt7987.patch
@@ -0,0 +1,44 @@
+From 7f4532a2bffdb0aebcabc2a672c4b97670e002a5 Mon Sep 17 00:00:00 2001
+From: Sam Shih <sam.shih@mediatek.com>
+Date: Mon, 3 Mar 2025 14:33:33 +0800
+Subject: [PATCH] add pwm reg-v3 support for mt7987
+
+---
+ drivers/pwm/pwm-mediatek.c | 20 ++++++++++++++++++++
+ 1 file changed, 20 insertions(+)
+
+--- a/drivers/pwm/pwm-mediatek.c
++++ b/drivers/pwm/pwm-mediatek.c
+@@ -64,6 +64,10 @@ static const unsigned int mtk_pwm_reg_of
+ 	0x0080, 0x00c0, 0x0100, 0x0140, 0x0180, 0x01c0, 0x0200, 0x0240
+ };
+ 
++static const unsigned int mtk_pwm_reg_offset_v3[] = {
++	0x0100, 0x0200, 0x0300, 0x0400, 0x0500, 0x600, 0x700, 0x0800
++};
++
+ static inline struct pwm_mediatek_chip *
+ to_pwm_mediatek_chip(struct pwm_chip *chip)
+ {
+@@ -350,6 +354,13 @@ static const struct pwm_mediatek_of_data
+ 	.reg_offset = mtk_pwm_reg_offset_v1,
+ };
+ 
++static const struct pwm_mediatek_of_data mt7987_pwm_data = {
++	.num_pwms = 3,
++	.pwm45_fixup = false,
++	.has_ck_26m_sel = false,
++	.reg_offset = mtk_pwm_reg_offset_v3,
++};
++
+ static const struct pwm_mediatek_of_data mt7988_pwm_data = {
+ 	.num_pwms = 8,
+ 	.pwm45_fixup = false,
+@@ -387,6 +398,7 @@ static const struct of_device_id pwm_med
+ 	{ .compatible = "mediatek,mt7629-pwm", .data = &mt7629_pwm_data },
+ 	{ .compatible = "mediatek,mt7981-pwm", .data = &mt7981_pwm_data },
+ 	{ .compatible = "mediatek,mt7986-pwm", .data = &mt7986_pwm_data },
++	{ .compatible = "mediatek,mt7987-pwm", .data = &mt7987_pwm_data },
+ 	{ .compatible = "mediatek,mt7988-pwm", .data = &mt7988_pwm_data },
+ 	{ .compatible = "mediatek,mt8183-pwm", .data = &mt8183_pwm_data },
+ 	{ .compatible = "mediatek,mt8365-pwm", .data = &mt8365_pwm_data },
--- a/target/linux/generic/pending-6.12/737-net-ethernet-mtk_eth_soc-add-paths-and-SerDes-modes-.patch
+++ b/target/linux/generic/pending-6.12/737-net-ethernet-mtk_eth_soc-add-paths-and-SerDes-modes-.patch
@@ -544,7 +544,7 @@ Signed-off-by: Daniel Golle <daniel@makr
 +	}
 +
 +	if (mtk_is_netsys_v3_or_greater(eth) && (mac->sgmii_pcs || mac->usxgmii_pcs)) {
-+		mac->pextp = devm_of_phy_get(eth->dev, mac->of_node, NULL);
++		mac->pextp = devm_of_phy_optional_get(eth->dev, mac->of_node, NULL);
 +		if (IS_ERR(mac->pextp)) {
 +			if (PTR_ERR(mac->pextp) != -EPROBE_DEFER)
 +				dev_err(eth->dev, "cannot get PHY, error %ld\n",
--- /dev/null
+++ b/target/linux/mediatek/patches-6.12/740-net-pcs-mtk_lynxi-add-mt7987-support.patch
@@ -0,0 +1,36 @@
+From 6e9ec5ade644eeb136c6b827d72fac80bf2c3817 Mon Sep 17 00:00:00 2001
+From: Bo-Cun Chen <bc-bocun.chen@mediatek.com>
+Date: Fri, 9 May 2025 13:22:14 +0800
+Subject: [PATCH] net: pcs: mtk_lynxi add mt7987 support
+
+Signed-off-by: Bo-Cun Chen <bc-bocun.chen@mediatek.com>
+---
+ drivers/net/pcs/pcs-mtk-lynxi.c | 10 +++++++---
+ 1 file changed, 7 insertions(+), 3 deletions(-)
+
+--- a/drivers/net/pcs/pcs-mtk-lynxi.c
++++ b/drivers/net/pcs/pcs-mtk-lynxi.c
+@@ -413,9 +413,12 @@ static int mtk_pcs_lynxi_probe(struct pl
+ 	if (of_property_read_bool(np->parent, "mediatek,pnswap"))
+ 		flags |= MTK_SGMII_FLAG_PN_SWAP;
+ 
+-	mpcs->rstc = of_reset_control_get_shared(np->parent, NULL);
+-	if (IS_ERR(mpcs->rstc))
+-		return PTR_ERR(mpcs->rstc);
++	if (of_parse_phandle(np->parent, "resets", 0)) {
++		mpcs->rstc = of_reset_control_get_shared(np->parent, NULL);
++		if (IS_ERR(mpcs->rstc))
++			return PTR_ERR(mpcs->rstc);
++	} else
++		mpcs->rstc = NULL;
+ 
+ 	reset_control_deassert(mpcs->rstc);
+ 	mpcs->sgmii_sel = devm_clk_get_enabled(dev, "sgmii_sel");
+@@ -462,6 +465,7 @@ static void mtk_pcs_lynxi_remove(struct
+ }
+ 
+ static const struct of_device_id mtk_pcs_lynxi_of_match[] = {
++	{ .compatible = "mediatek,mt7987-sgmii", .data = (void *)MTK_NETSYS_V3_AMA_RGC3 },
+ 	{ .compatible = "mediatek,mt7988-sgmii", .data = (void *)MTK_NETSYS_V3_AMA_RGC3 },
+ 	{ /* sentinel */ },
+ };
--- /dev/null
+++ b/target/linux/mediatek/patches-6.12/741-net-pcs-mtk-lynxi-add-phya-tx-rx-clock-path.patch
@@ -0,0 +1,89 @@
+From be193994deca7cc3ca6ddedc6efd06182b032f21 Mon Sep 17 00:00:00 2001
+From: Bo-Cun Chen <bc-bocun.chen@mediatek.com>
+Date: Tue, 6 May 2025 12:53:37 +0800
+Subject: [PATCH] net: pcs: mtk-lynxi: add phya tx rx clock path
+
+In NETSYSv3.1, the SGMII hardware introduces a new clock path from PHYA.
+Consequently, users can switch the SGMII PCS to this new clock source
+for better performance on the MT7987.
+
+Signed-off-by: Bo-Cun Chen <bc-bocun.chen@mediatek.com>
+---
+--- a/drivers/net/pcs/pcs-mtk-lynxi.c
++++ b/drivers/net/pcs/pcs-mtk-lynxi.c
+@@ -25,6 +25,7 @@
+ #define SGMSYS_PCS_CONTROL_1		0x0
+ #define SGMII_BMCR			GENMASK(15, 0)
+ #define SGMII_BMSR			GENMASK(31, 16)
++#define SGMII_REF_CK_SEL		BIT(24)
+ 
+ #define SGMSYS_PCS_DEVICE_ID		0x4
+ #define SGMII_LYNXI_DEV_ID		0x4d544950
+@@ -52,6 +53,8 @@
+ #define SGMII_SPEED_1000		FIELD_PREP(SGMII_SPEED_MASK, 2)
+ #define SGMII_DUPLEX_HALF		BIT(4)
+ #define SGMII_REMOTE_FAULT_DIS		BIT(8)
++#define SGMII_TRXBUF_THR_MASK		GENMASK(31, 16)
++#define SGMII_TRXBUF_THR(x)		FIELD_PREP(SGMII_TRXBUF_THR_MASK, (x))
+ 
+ /* Register to reset SGMII design */
+ #define SGMSYS_RESERVED_0		0x34
+@@ -166,7 +169,7 @@ static int mtk_pcs_lynxi_config(struct p
+ {
+ 	struct mtk_pcs_lynxi *mpcs = pcs_to_mtk_pcs_lynxi(pcs);
+ 	bool mode_changed = false, changed;
+-	unsigned int rgc3, sgm_mode, bmcr = 0;
++	unsigned int rgc3, sgm_mode, bmcr = 0, trxbuf_thr = 0x3112;
+ 	int advertise, link_timer;
+ 
+ 	advertise = phylink_mii_c22_pcs_encode_advertisement(interface,
+@@ -193,6 +196,12 @@ static int mtk_pcs_lynxi_config(struct p
+ 			bmcr = BMCR_ANENABLE;
+ 	}
+ 
++	/* Configure SGMII PCS clock source */
++	if (mpcs->flags & MTK_SGMII_FLAG_PHYA_TRX_CK) {
++		bmcr |= SGMII_REF_CK_SEL;
++		trxbuf_thr = 0x2111;
++	}
++
+ 	if (mpcs->interface != interface) {
+ 		link_timer = phylink_get_link_timer_ns(interface);
+ 		if (link_timer < 0)
+@@ -235,12 +244,14 @@ static int mtk_pcs_lynxi_config(struct p
+ 
+ 	/* Update the sgmsys mode register */
+ 	regmap_update_bits(mpcs->regmap, SGMSYS_SGMII_MODE,
++			   SGMII_TRXBUF_THR_MASK |
+ 			   SGMII_REMOTE_FAULT_DIS | SGMII_SPEED_DUPLEX_AN |
+-			   SGMII_IF_MODE_SGMII, sgm_mode);
++			   SGMII_IF_MODE_SGMII,
++			   SGMII_TRXBUF_THR(trxbuf_thr) | sgm_mode);
+ 
+ 	/* Update the BMCR */
+ 	regmap_update_bits(mpcs->regmap, SGMSYS_PCS_CONTROL_1,
+-			   BMCR_ANENABLE, bmcr);
++			   SGMII_REF_CK_SEL | BMCR_ANENABLE, bmcr);
+ 
+ 	/* Release PHYA power down state
+ 	 * Only removing bit SGMII_PHYA_PWD isn't enough.
+@@ -413,6 +424,9 @@ static int mtk_pcs_lynxi_probe(struct pl
+ 	if (of_property_read_bool(np->parent, "mediatek,pnswap"))
+ 		flags |= MTK_SGMII_FLAG_PN_SWAP;
+ 
++	if (of_property_read_bool(np->parent, "mediatek,phya_trx_ck"))
++		flags |= MTK_SGMII_FLAG_PHYA_TRX_CK;
++
+ 	if (of_parse_phandle(np->parent, "resets", 0)) {
+ 		mpcs->rstc = of_reset_control_get_shared(np->parent, NULL);
+ 		if (IS_ERR(mpcs->rstc))
+--- a/include/linux/pcs/pcs-mtk-lynxi.h
++++ b/include/linux/pcs/pcs-mtk-lynxi.h
+@@ -6,6 +6,7 @@
+ #include <linux/regmap.h>
+ 
+ #define MTK_SGMII_FLAG_PN_SWAP BIT(0)
++#define MTK_SGMII_FLAG_PHYA_TRX_CK BIT(2)
+ struct phylink_pcs *mtk_pcs_lynxi_create(struct device *dev,
+ 					 struct regmap *regmap,
+ 					 u32 ana_rgc3, u32 flags);
--- /dev/null
+++ b/target/linux/mediatek/patches-6.12/750-net-ethernet-mtk_eth_soc-add-mt7987-support.patch
@@ -0,0 +1,325 @@
+From 56973433cbea9f91f5f7eddebbc361ffc2bd6156 Mon Sep 17 00:00:00 2001
+From: Bo-Cun Chen <bc-bocun.chen@mediatek.com>
+Date: Mon, 26 May 2025 13:20:42 +0800
+Subject: [PATCH] net: ethernet: mtk_eth_soc: add mt7987 support
+
+Without this patch, users are unable to bring up ETH driver on the
+mt7987.
+
+Signed-off-by: Bo-Cun Chen <bc-bocun.chen@mediatek.com>
+---
+ drivers/net/ethernet/mediatek/mtk_eth_path.c |   9 +-
+ drivers/net/ethernet/mediatek/mtk_eth_soc.c  | 138 ++++++++++++++++---
+ drivers/net/ethernet/mediatek/mtk_eth_soc.h  |  70 ++++++++--
+ 3 files changed, 179 insertions(+), 38 deletions(-)
+
+--- a/drivers/net/ethernet/mediatek/mtk_eth_path.c
++++ b/drivers/net/ethernet/mediatek/mtk_eth_path.c
+@@ -106,13 +106,14 @@ static int set_mux_gmac2_gmac0_to_gephy(
+ 	return 0;
+ }
+ 
+-static int set_mux_u3_gmac2_to_qphy(struct mtk_eth *eth, u64 path)
++static int set_mux_u3_gmac23_to_qphy(struct mtk_eth *eth, u64 path)
+ {
+ 	unsigned int val = 0, mask = 0, reg = 0;
+ 	bool updated = true;
+ 
+ 	switch (path) {
+ 	case MTK_ETH_PATH_GMAC2_SGMII:
++	case MTK_ETH_PATH_GMAC3_SGMII:
+ 		if (MTK_HAS_CAPS(eth->soc->caps, MTK_U3_COPHY_V2)) {
+ 			reg = USB_PHY_SWITCH_REG;
+ 			val = SGMII_QPHY_SEL;
+@@ -281,9 +282,9 @@ static const struct mtk_eth_muxc mtk_eth
+ 		.cap_bit = MTK_ETH_MUX_GMAC2_GMAC0_TO_GEPHY,
+ 		.set_path = set_mux_gmac2_gmac0_to_gephy,
+ 	}, {
+-		.name = "mux_u3_gmac2_to_qphy",
+-		.cap_bit = MTK_ETH_MUX_U3_GMAC2_TO_QPHY,
+-		.set_path = set_mux_u3_gmac2_to_qphy,
++		.name = "mux_u3_gmac23_to_qphy",
++		.cap_bit = MTK_ETH_MUX_U3_GMAC23_TO_QPHY,
++		.set_path = set_mux_u3_gmac23_to_qphy,
+ 	}, {
+ 		.name = "mux_gmac2_to_2p5gphy",
+ 		.cap_bit = MTK_ETH_MUX_GMAC2_TO_2P5GPHY,
+--- a/drivers/net/ethernet/mediatek/mtk_eth_soc.c
++++ b/drivers/net/ethernet/mediatek/mtk_eth_soc.c
+@@ -817,10 +817,16 @@ static void mtk_set_queue_speed(struct m
+ 		return;
+ 
+ 	val = MTK_QTX_SCH_MIN_RATE_EN |
+-	      /* minimum: 10 Mbps */
+-	      FIELD_PREP(MTK_QTX_SCH_MIN_RATE_MAN, 1) |
+-	      FIELD_PREP(MTK_QTX_SCH_MIN_RATE_EXP, 4) |
+ 	      MTK_QTX_SCH_LEAKY_BUCKET_SIZE;
++	/* minimum: 10 Mbps */
++	if (mtk_is_netsys_v3_or_greater(eth) &&
++	    (eth->soc->caps != MT7988_CAPS)) {
++		val |= FIELD_PREP(MTK_QTX_SCH_MIN_RATE_MAN_V3, 1) |
++		       FIELD_PREP(MTK_QTX_SCH_MIN_RATE_EXP_V3, 4);
++	} else {
++		val |= FIELD_PREP(MTK_QTX_SCH_MIN_RATE_MAN, 1) |
++		       FIELD_PREP(MTK_QTX_SCH_MIN_RATE_EXP, 4);
++	}
+ 	if (mtk_is_netsys_v1(eth))
+ 		val |= MTK_QTX_SCH_LEAKY_BUCKET_EN;
+ 
+@@ -847,6 +853,30 @@ static void mtk_set_queue_speed(struct m
+ 		default:
+ 			break;
+ 		}
++	} else if (mtk_is_netsys_v3_or_greater(eth) &&
++		   (eth->soc->caps != MT7988_CAPS)) {
++		switch (speed) {
++		case SPEED_10:
++			val |= MTK_QTX_SCH_MAX_RATE_EN_V3 |
++			       FIELD_PREP(MTK_QTX_SCH_MAX_RATE_MAN_V3, 1) |
++			       FIELD_PREP(MTK_QTX_SCH_MAX_RATE_EXP_V3, 4) |
++			       FIELD_PREP(MTK_QTX_SCH_MAX_RATE_WEIGHT_V3, 1);
++			break;
++		case SPEED_100:
++			val |= MTK_QTX_SCH_MAX_RATE_EN_V3 |
++			       FIELD_PREP(MTK_QTX_SCH_MAX_RATE_MAN_V3, 1) |
++			       FIELD_PREP(MTK_QTX_SCH_MAX_RATE_EXP_V3, 5) |
++			       FIELD_PREP(MTK_QTX_SCH_MAX_RATE_WEIGHT_V3, 1);
++			break;
++		case SPEED_1000:
++			val |= MTK_QTX_SCH_MAX_RATE_EN_V3 |
++			       FIELD_PREP(MTK_QTX_SCH_MAX_RATE_MAN_V3, 1) |
++			       FIELD_PREP(MTK_QTX_SCH_MAX_RATE_EXP_V3, 6) |
++			       FIELD_PREP(MTK_QTX_SCH_MAX_RATE_WEIGHT_V3, 10);
++			break;
++		default:
++			break;
++		}
+ 	} else {
+ 		switch (speed) {
+ 		case SPEED_10:
+@@ -935,7 +965,7 @@ static void mtk_xgdm_mac_link_up(struct
+ 		return;
+ 
+ 	/* Eliminate the interference(before link-up) caused by PHY noise */
+-	mtk_m32(mac->hw, XMAC_LOGIC_RST, 0, MTK_XMAC_LOGIC_RST(mac->id));
++	mtk_m32(mac->hw, XMAC_LOGIC_RST, 0, MTK_XMAC_LOGIC_RST(mac->hw, mac->id));
+ 	mdelay(20);
+ 	mtk_m32(mac->hw, XMAC_GLB_CNTCLR, XMAC_GLB_CNTCLR, MTK_XMAC_CNT_CTRL(mac->id));
+ 
+@@ -2898,10 +2928,16 @@ static int mtk_tx_alloc(struct mtk_eth *
+ 			mtk_w32(eth, val, soc->reg_map->qdma.qtx_cfg + ofs);
+ 
+ 			val = MTK_QTX_SCH_MIN_RATE_EN |
+-			      /* minimum: 10 Mbps */
+-			      FIELD_PREP(MTK_QTX_SCH_MIN_RATE_MAN, 1) |
+-			      FIELD_PREP(MTK_QTX_SCH_MIN_RATE_EXP, 4) |
+ 			      MTK_QTX_SCH_LEAKY_BUCKET_SIZE;
++			/* minimum: 10 Mbps */
++			if (mtk_is_netsys_v3_or_greater(eth) &&
++			    (eth->soc->caps != MT7988_CAPS)) {
++				val |= FIELD_PREP(MTK_QTX_SCH_MIN_RATE_MAN_V3, 1) |
++				       FIELD_PREP(MTK_QTX_SCH_MIN_RATE_EXP_V3, 4);
++			} else {
++				val |= FIELD_PREP(MTK_QTX_SCH_MIN_RATE_MAN, 1) |
++				       FIELD_PREP(MTK_QTX_SCH_MIN_RATE_EXP, 4);
++			}
+ 			if (mtk_is_netsys_v1(eth))
+ 				val |= MTK_QTX_SCH_LEAKY_BUCKET_EN;
+ 			mtk_w32(eth, val, soc->reg_map->qdma.qtx_sch + ofs);
+@@ -5870,6 +5906,36 @@ static const struct mtk_soc_data mt7986_
+ 	},
+ };
+ 
++static const struct mtk_soc_data mt7987_data = {
++	.reg_map = &mt7988_reg_map,
++	.ana_rgc3 = 0x128,
++	.caps = MT7987_CAPS,
++	.hw_features = MTK_HW_FEATURES,
++	.required_clks = MT7987_CLKS_BITMAP,
++	.required_pctl = false,
++	.version = 3,
++	.offload_version = 2,
++	.ppe_num = 2,
++	.hash_offset = 4,
++	.has_accounting = true,
++	.foe_entry_size = MTK_FOE_ENTRY_V3_SIZE,
++	.tx = {
++		DESC_SIZE(struct mtk_tx_dma_v2),
++		.dma_max_len = MTK_TX_DMA_BUF_LEN_V2,
++		.dma_len_offset = 8,
++		.dma_size = MTK_DMA_SIZE(2K),
++		.fq_dma_size = MTK_DMA_SIZE(4K),
++	},
++	.rx = {
++		DESC_SIZE(struct mtk_rx_dma_v2),
++		.irq_done_mask = MTK_RX_DONE_INT_V2,
++		.dma_l4_valid = RX_DMA_L4_VALID_V2,
++		.dma_max_len = MTK_TX_DMA_BUF_LEN_V2,
++		.dma_len_offset = 8,
++		.dma_size = MTK_DMA_SIZE(2K),
++	},
++};
++
+ static const struct mtk_soc_data mt7988_data = {
+ 	.reg_map = &mt7988_reg_map,
+ 	.ana_rgc3 = 0x128,
+@@ -5931,6 +5997,7 @@ const struct of_device_id of_mtk_match[]
+ 	{ .compatible = "mediatek,mt7629-eth", .data = &mt7629_data },
+ 	{ .compatible = "mediatek,mt7981-eth", .data = &mt7981_data },
+ 	{ .compatible = "mediatek,mt7986-eth", .data = &mt7986_data },
++	{ .compatible = "mediatek,mt7987-eth", .data = &mt7987_data },
+ 	{ .compatible = "mediatek,mt7988-eth", .data = &mt7988_data },
+ 	{ .compatible = "ralink,rt5350-eth", .data = &rt5350_data },
+ 	{},
+--- a/drivers/net/ethernet/mediatek/mtk_eth_soc.h
++++ b/drivers/net/ethernet/mediatek/mtk_eth_soc.h
+@@ -262,6 +262,13 @@
+ #define MTK_QTX_SCH_MAX_RATE_MAN	GENMASK(10, 4)
+ #define MTK_QTX_SCH_MAX_RATE_EXP	GENMASK(3, 0)
+ 
++#define MTK_QTX_SCH_MAX_RATE_EN_V3	BIT(26)
++#define MTK_QTX_SCH_MIN_RATE_MAN_V3	GENMASK(25, 19)
++#define MTK_QTX_SCH_MIN_RATE_EXP_V3	GENMASK(18, 16)
++#define MTK_QTX_SCH_MAX_RATE_WEIGHT_V3	GENMASK(15, 10)
++#define MTK_QTX_SCH_MAX_RATE_MAN_V3	GENMASK(9, 3)
++#define MTK_QTX_SCH_MAX_RATE_EXP_V3	GENMASK(2, 0)
++
+ /* QDMA TX Scheduler Rate Control Register */
+ #define MTK_QDMA_TX_SCH_MAX_WFQ		BIT(15)
+ 
+@@ -536,9 +543,23 @@
+ #define XMAC_MCR_FORCE_RX_FC	BIT(4)
+ 
+ /* XFI Mac logic reset registers */
+-#define MTK_XMAC_LOGIC_RST(x)	(MTK_XMAC_BASE(x) + 0x10)
++#define MTK_XMAC_LOGIC_RST(eth, x)	(MTK_XMAC_BASE(x) +				\
++					(MTK_HAS_CAPS((eth)->soc->caps, MTK_XGMAC_V2) ?	\
++					0x820 : 0x10))
+ #define XMAC_LOGIC_RST		BIT(0)
+ 
++/* XFI Mac status force registers */
++#define MTK_XMAC_STS(x)		(MTK_XMAC_MCR(x) + 0x14)
++
++/* XFI Mac status force registers */
++#define MTK_XMAC_STS_FRC(x)	(MTK_XMAC_MCR(x) + 0x18)
++#define XMAC_FORCE_RX_FC_MODE	BIT(13)
++#define XMAC_FORCE_TX_FC_MODE	BIT(12)
++#define XMAC_FORCE_LINK_MODE	BIT(8)
++#define XMAC_FORCE_RX_FC	BIT(5)
++#define XMAC_FORCE_TX_FC	BIT(4)
++#define XMAC_FORCE_LINK		BIT(0)
++
+ /* XFI Mac count global control */
+ #define MTK_XMAC_CNT_CTRL(x)	(MTK_XMAC_BASE(x) + 0x100)
+ #define XMAC_GLB_CNTCLR		BIT(0)
+@@ -834,6 +855,17 @@ enum mtk_clks_map {
+ 				 BIT_ULL(MTK_CLK_SGMII2_RX_250M) | \
+ 				 BIT_ULL(MTK_CLK_SGMII2_CDR_REF) | \
+ 				 BIT_ULL(MTK_CLK_SGMII2_CDR_FB))
++#define MT7987_CLKS_BITMAP	(BIT_ULL(MTK_CLK_FE) |  BIT_ULL(MTK_CLK_GP1) | \
++				 BIT_ULL(MTK_CLK_GP2) | BIT_ULL(MTK_CLK_GP3) | \
++				 BIT_ULL(MTK_CLK_TOP_ETH_GMII_SEL) | \
++				 BIT_ULL(MTK_CLK_TOP_ETH_REFCK_50M_SEL) | \
++				 BIT_ULL(MTK_CLK_TOP_ETH_SYS_200M_SEL) | \
++				 BIT_ULL(MTK_CLK_TOP_ETH_SYS_SEL) | \
++				 BIT_ULL(MTK_CLK_TOP_ETH_XGMII_SEL) | \
++				 BIT_ULL(MTK_CLK_TOP_ETH_MII_SEL) | \
++				 BIT_ULL(MTK_CLK_TOP_NETSYS_SEL) | \
++				 BIT_ULL(MTK_CLK_TOP_NETSYS_500M_SEL) | \
++				 BIT_ULL(MTK_CLK_TOP_NETSYS_PAO_2X_SEL))
+ #define MT7988_CLKS_BITMAP	(BIT_ULL(MTK_CLK_FE) | BIT_ULL(MTK_CLK_ESW) | \
+ 				 BIT_ULL(MTK_CLK_GP1) | BIT_ULL(MTK_CLK_GP2) | \
+ 				 BIT_ULL(MTK_CLK_GP3) | BIT_ULL(MTK_CLK_XGP1) | \
+@@ -990,12 +1022,14 @@ enum mkt_eth_capabilities {
+ 	MTK_RSTCTRL_PPE2_BIT,
+ 	MTK_U3_COPHY_V2_BIT,
+ 	MTK_SRAM_BIT,
++	MTK_XGMAC_BIT,
++	MTK_XGMAC_V2_BIT,
+ 	MTK_36BIT_DMA_BIT,
+ 
+ 	/* MUX BITS*/
+ 	MTK_ETH_MUX_GDM1_TO_GMAC1_ESW_BIT,
+ 	MTK_ETH_MUX_GMAC2_GMAC0_TO_GEPHY_BIT,
+-	MTK_ETH_MUX_U3_GMAC2_TO_QPHY_BIT,
++	MTK_ETH_MUX_U3_GMAC23_TO_QPHY_BIT,
+ 	MTK_ETH_MUX_GMAC2_TO_2P5GPHY_BIT,
+ 	MTK_ETH_MUX_GMAC1_GMAC2_TO_SGMII_RGMII_BIT,
+ 	MTK_ETH_MUX_GMAC12_TO_GEPHY_SGMII_BIT,
+@@ -1037,14 +1071,16 @@ enum mkt_eth_capabilities {
+ #define MTK_RSTCTRL_PPE2	BIT_ULL(MTK_RSTCTRL_PPE2_BIT)
+ #define MTK_U3_COPHY_V2		BIT_ULL(MTK_U3_COPHY_V2_BIT)
+ #define MTK_SRAM		BIT_ULL(MTK_SRAM_BIT)
++#define MTK_XGMAC		BIT_ULL(MTK_XGMAC_BIT)
++#define MTK_XGMAC_V2		BIT_ULL(MTK_XGMAC_V2_BIT)
+ #define MTK_36BIT_DMA	BIT_ULL(MTK_36BIT_DMA_BIT)
+ 
+ #define MTK_ETH_MUX_GDM1_TO_GMAC1_ESW		\
+ 	BIT_ULL(MTK_ETH_MUX_GDM1_TO_GMAC1_ESW_BIT)
+ #define MTK_ETH_MUX_GMAC2_GMAC0_TO_GEPHY	\
+ 	BIT_ULL(MTK_ETH_MUX_GMAC2_GMAC0_TO_GEPHY_BIT)
+-#define MTK_ETH_MUX_U3_GMAC2_TO_QPHY		\
+-	BIT_ULL(MTK_ETH_MUX_U3_GMAC2_TO_QPHY_BIT)
++#define MTK_ETH_MUX_U3_GMAC23_TO_QPHY		\
++	BIT_ULL(MTK_ETH_MUX_U3_GMAC23_TO_QPHY_BIT)
+ #define MTK_ETH_MUX_GMAC2_TO_2P5GPHY		\
+ 	BIT_ULL(MTK_ETH_MUX_GMAC2_TO_2P5GPHY_BIT)
+ #define MTK_ETH_MUX_GMAC1_GMAC2_TO_SGMII_RGMII	\
+@@ -1076,12 +1112,13 @@ enum mkt_eth_capabilities {
+ #define MTK_GMAC2_RGMII		(MTK_ETH_PATH_GMAC2_RGMII | MTK_RGMII)
+ #define MTK_GMAC2_SGMII		(MTK_ETH_PATH_GMAC2_SGMII | MTK_SGMII)
+ #define MTK_GMAC2_GEPHY		(MTK_ETH_PATH_GMAC2_GEPHY | MTK_GEPHY)
+-#define MTK_GMAC2_2P5GPHY	(MTK_ETH_PATH_GMAC2_2P5GPHY | MTK_2P5GPHY)
++#define MTK_GMAC2_2P5GPHY	(MTK_ETH_PATH_GMAC2_2P5GPHY | MTK_2P5GPHY | MTK_XGMAC)
++#define MTK_GMAC2_2P5GPHY_V2	(MTK_ETH_PATH_GMAC2_2P5GPHY | MTK_2P5GPHY | MTK_XGMAC_V2)
+ #define MTK_GMAC3_SGMII		(MTK_ETH_PATH_GMAC3_SGMII | MTK_SGMII)
+ #define MTK_GDM1_ESW		(MTK_ETH_PATH_GDM1_ESW | MTK_ESW)
+-#define MTK_GMAC1_USXGMII	(MTK_ETH_PATH_GMAC1_USXGMII | MTK_USXGMII)
+-#define MTK_GMAC2_USXGMII	(MTK_ETH_PATH_GMAC2_USXGMII | MTK_USXGMII)
+-#define MTK_GMAC3_USXGMII	(MTK_ETH_PATH_GMAC3_USXGMII | MTK_USXGMII)
++#define MTK_GMAC1_USXGMII	(MTK_ETH_PATH_GMAC1_USXGMII | MTK_USXGMII | MTK_XGMAC)
++#define MTK_GMAC2_USXGMII	(MTK_ETH_PATH_GMAC2_USXGMII | MTK_USXGMII | MTK_XGMAC)
++#define MTK_GMAC3_USXGMII	(MTK_ETH_PATH_GMAC3_USXGMII | MTK_USXGMII | MTK_XGMAC)
+ 
+ /* MUXes present on SoCs */
+ /* 0: GDM1 -> GMAC1, 1: GDM1 -> ESW */
+@@ -1091,9 +1128,9 @@ enum mkt_eth_capabilities {
+ #define MTK_MUX_GMAC2_GMAC0_TO_GEPHY    \
+ 	(MTK_ETH_MUX_GMAC2_GMAC0_TO_GEPHY | MTK_MUX | MTK_INFRA)
+ 
+-/* 0: U3 -> QPHY, 1: GMAC2 -> QPHY */
+-#define MTK_MUX_U3_GMAC2_TO_QPHY        \
+-	(MTK_ETH_MUX_U3_GMAC2_TO_QPHY | MTK_MUX | MTK_INFRA)
++/* 0: U3 -> QPHY, 1: GMACx -> QPHY where x is 2 or 3 */
++#define MTK_MUX_U3_GMAC23_TO_QPHY        \
++	(MTK_ETH_MUX_U3_GMAC23_TO_QPHY | MTK_MUX | MTK_INFRA)
+ 
+ /* 2: GMAC1 -> SGMII, 3: GMAC2 -> SGMII */
+ #define MTK_MUX_GMAC1_GMAC2_TO_SGMII_RGMII      \
+@@ -1133,18 +1170,24 @@ enum mkt_eth_capabilities {
+ #define MT7629_CAPS  (MTK_GMAC1_SGMII | MTK_GMAC2_SGMII | MTK_GMAC2_GEPHY | \
+ 		      MTK_GDM1_ESW | MTK_MUX_GDM1_TO_GMAC1_ESW | \
+ 		      MTK_MUX_GMAC2_GMAC0_TO_GEPHY | \
+-		      MTK_MUX_U3_GMAC2_TO_QPHY | \
++		      MTK_MUX_U3_GMAC23_TO_QPHY | \
+ 		      MTK_MUX_GMAC12_TO_GEPHY_SGMII | MTK_QDMA)
+ 
+ #define MT7981_CAPS  (MTK_GMAC1_SGMII | MTK_GMAC2_SGMII | MTK_GMAC2_GEPHY | \
+ 		      MTK_MUX_GMAC12_TO_GEPHY_SGMII | MTK_QDMA | \
+-		      MTK_MUX_U3_GMAC2_TO_QPHY | MTK_U3_COPHY_V2 | \
++		      MTK_MUX_U3_GMAC23_TO_QPHY | MTK_U3_COPHY_V2 | \
+ 		      MTK_RSTCTRL_PPE1 | MTK_SRAM)
+ 
+ #define MT7986_CAPS  (MTK_GMAC1_SGMII | MTK_GMAC2_SGMII | \
+ 		      MTK_MUX_GMAC12_TO_GEPHY_SGMII | MTK_QDMA | \
+ 		      MTK_RSTCTRL_PPE1 | MTK_SRAM)
+ 
++#define MT7987_CAPS  (MTK_36BIT_DMA | MTK_GMAC1_SGMII | \
++		      MTK_GMAC2_2P5GPHY_V2 | MTK_GMAC2_SGMII | MTK_GMAC3_SGMII | \
++		      MTK_MUX_GMAC123_TO_GEPHY_SGMII | MTK_MUX_GMAC2_TO_2P5GPHY | \
++		      MTK_MUX_U3_GMAC23_TO_QPHY | MTK_U3_COPHY_V2 | \
++		      MTK_QDMA | MTK_RSTCTRL_PPE1)
++
+ #define MT7988_CAPS  (MTK_36BIT_DMA | MTK_GDM1_ESW | MTK_GMAC1_SGMII | \
+ 		      MTK_GMAC2_2P5GPHY | MTK_GMAC2_SGMII | MTK_GMAC2_USXGMII | \
+ 		      MTK_GMAC3_SGMII | MTK_GMAC3_USXGMII | \
--- /dev/null
+++ b/target/linux/mediatek/patches-6.12/751-net-ethernet-mtk_eth_soc-revise-hardware-configuration-for-mt7987.patch
@@ -0,0 +1,79 @@
+From 5ef0b04d30efff8f171e30bfbe876c00e3b9036a Mon Sep 17 00:00:00 2001
+From: Bo-Cun Chen <bc-bocun.chen@mediatek.com>
+Date: Fri, 9 May 2025 09:49:04 +0800
+Subject: [PATCH] net: ethernet: mtk_eth_soc: revise hardware configuration for
+ mt7987
+
+Change hardware configuration for the MT7987.
+ - Enable PSE drop mechanism when the WDMA Rx ring full
+ - Enable PSE no-drop mechanism for packets from the WDMA Tx
+
+Signed-off-by: Bo-Cun Chen <bc-bocun.chen@mediatek.com>
+---
+ drivers/net/ethernet/mediatek/mtk_eth_soc.c | 49 +++++++++++++--------
+ 1 file changed, 31 insertions(+), 18 deletions(-)
+
+--- a/drivers/net/ethernet/mediatek/mtk_eth_soc.c
++++ b/drivers/net/ethernet/mediatek/mtk_eth_soc.c
+@@ -4442,27 +4442,40 @@ static int mtk_hw_init(struct mtk_eth *e
+ 		mtk_w32(eth, PSE_DUMMY_WORK_GDM(1) | PSE_DUMMY_WORK_GDM(2) |
+ 			PSE_DUMMY_WORK_GDM(3) | DUMMY_PAGE_THR, PSE_DUMY_REQ);
+ 
+-		/* PSE free buffer drop threshold */
+-		mtk_w32(eth, 0x00600009, PSE_IQ_REV(8));
+-
+-		/* PSE should not drop port8, port9 and port13 packets from
+-		 * WDMA Tx
+-		 */
+-		mtk_w32(eth, 0x00002300, PSE_DROP_CFG);
+-
+-		/* PSE should drop packets to port8, port9 and port13 on WDMA Rx
+-		 * ring full
+-		 */
+-		mtk_w32(eth, 0x00002300, PSE_PPE_DROP(0));
+-		mtk_w32(eth, 0x00002300, PSE_PPE_DROP(1));
+-		mtk_w32(eth, 0x00002300, PSE_PPE_DROP(2));
+-
+-		/* GDM and CDM Threshold */
+-		mtk_w32(eth, 0x08000707, MTK_CDMW0_THRES);
+-		mtk_w32(eth, 0x00000077, MTK_CDMW1_THRES);
+-
+-		/* Disable GDM1 RX CRC stripping */
+-		mtk_m32(eth, MTK_GDMA_STRP_CRC, 0, MTK_GDMA_FWD_CFG(0));
++		if (eth->soc->caps == MT7988_CAPS) {
++			/* PSE free buffer drop threshold */
++			mtk_w32(eth, 0x00600009, PSE_IQ_REV(8));
++
++			/* PSE should not drop port8, port9 and port13 packets
++			 * from WDMA Tx
++			 */
++			mtk_w32(eth, 0x00002300, PSE_DROP_CFG);
++
++			/* PSE should drop packets to port8, port9 and port13
++			 * on WDMA Rx ring full
++			 */
++			mtk_w32(eth, 0x00002300, PSE_PPE_DROP(0));
++			mtk_w32(eth, 0x00002300, PSE_PPE_DROP(1));
++			mtk_w32(eth, 0x00002300, PSE_PPE_DROP(2));
++
++			/* GDM and CDM Threshold */
++			mtk_w32(eth, 0x08000707, MTK_CDMW0_THRES);
++			mtk_w32(eth, 0x00000077, MTK_CDMW1_THRES);
++		} else if (eth->soc->caps == MT7987_CAPS) {
++			/* PSE should not drop port8 packets from WDMA Tx */
++			mtk_w32(eth, 0x00000100, PSE_DROP_CFG);
++
++			/* PSE should drop packets to port8 on WDMA Rx ring
++			 * full
++			 */
++			mtk_w32(eth, 0x00000100, PSE_PPE_DROP(0));
++			mtk_w32(eth, 0x00000100, PSE_PPE_DROP(1));
++		}
++
++		if (MTK_HAS_CAPS(eth->soc->caps, MTK_ESW)) {
++			/* Disable GDM1 RX CRC stripping */
++			mtk_m32(eth, MTK_GDMA_STRP_CRC, 0, MTK_GDMA_FWD_CFG(0));
++		}
+ 
+ 		/* PSE GDM3 MIB counter has incorrect hw default values,
+ 		 * so the driver ought to read clear the values beforehand
--- /dev/null
+++ b/target/linux/mediatek/patches-6.12/752-net-phy-mediatek-i2p5g-add-support-for-mt7987.patch
@@ -0,0 +1,397 @@
+--- a/drivers/net/phy/mediatek/mtk-2p5ge.c
++++ b/drivers/net/phy/mediatek/mtk-2p5ge.c
+@@ -12,13 +12,77 @@
+ 
+ #include "mtk.h"
+ 
++#define MTK_2P5GPHY_ID_MT7987	(0x00339c91)
+ #define MTK_2P5GPHY_ID_MT7988	(0x00339c11)
+ 
++#define MT7987_2P5GE_PMB_FW		"mediatek/mt7987/i2p5ge-phy-pmb.bin"
++#define MT7987_2P5GE_PMB_FW_SIZE	(0x18000)
++#define MT7987_2P5GE_DSPBITTB \
++	"mediatek/mt7987/i2p5ge-phy-DSPBitTb.bin"
++#define MT7987_2P5GE_DSPBITTB_SIZE	(0x7000)
++
+ #define MT7988_2P5GE_PMB_FW		"mediatek/mt7988/i2p5ge-phy-pmb.bin"
+ #define MT7988_2P5GE_PMB_FW_SIZE	(0x20000)
++
++#define MTK_2P5GPHY_PMD_REG_BASE	(0x0f010000)
++#define MTK_2P5GPHY_PMD_REG_LEN		(0x210)
++#define DO_NOT_RESET			(0x28)
++#define   DO_NOT_RESET_XBZ		BIT(0)
++#define   DO_NOT_RESET_PMA		BIT(3)
++#define   DO_NOT_RESET_RX		BIT(5)
++#define FNPLL_PWR_CTRL1			(0x208)
++#define   RG_SPEED_MASK			GENMASK(3, 0)
++#define   RG_SPEED_2500			BIT(3)
++#define   RG_SPEED_100			BIT(0)
++#define FNPLL_PWR_CTRL_STATUS		(0x20c)
++#define   RG_STABLE_MASK		GENMASK(3, 0)
++#define   RG_SPEED_2500_STABLE		BIT(3)
++#define   RG_SPEED_100_STABLE		BIT(0)
++
++#define MTK_2P5GPHY_XBZ_PCS_REG_BASE	(0x0f030000)
++#define MTK_2P5GPHY_XBZ_PCS_REG_LEN	(0x844)
++#define PHY_CTRL_CONFIG			(0x200)
++#define PMU_WP				(0x800)
++#define   WRITE_PROTECT_KEY		(0xCAFEF00D)
++#define PMU_PMA_AUTO_CFG		(0x820)
++#define   POWER_ON_AUTO_MODE		BIT(16)
++#define   PMU_AUTO_MODE_EN		BIT(0)
++#define PMU_PMA_STATUS			(0x840)
++#define   CLK_IS_DISABLED		BIT(3)
++
++#define MTK_2P5GPHY_XBZ_PMA_RX_BASE	(0x0f080000)
++#define MTK_2P5GPHY_XBZ_PMA_RX_LEN	(0x5228)
++#define SMEM_WDAT0			(0x5000)
++#define SMEM_WDAT1			(0x5004)
++#define SMEM_WDAT2			(0x5008)
++#define SMEM_WDAT3			(0x500c)
++#define SMEM_CTRL			(0x5024)
++#define   SMEM_HW_RDATA_ZERO		BIT(24)
++#define SMEM_ADDR_REF_ADDR		(0x502c)
++#define CM_CTRL_P01			(0x5100)
++#define CM_CTRL_P23			(0x5124)
++#define DM_CTRL_P01			(0x5200)
++#define DM_CTRL_P23			(0x5224)
++
++#define MTK_2P5GPHY_CHIP_SCU_BASE	(0x0f0cf800)
++#define MTK_2P5GPHY_CHIP_SCU_LEN	(0x12c)
++#define SYS_SW_RESET			(0x128)
++#define   RESET_RST_CNT			BIT(0)
++
++#define MTK_2P5GPHY_MCU_CSR_BASE	(0x0f0f0000)
++#define MTK_2P5GPHY_MCU_CSR_LEN		(0x20)
+ #define MD32_EN_CFG			(0x18)
+ #define   MD32_EN			BIT(0)
+ 
++#define MTK_2P5GPHY_PMB_FW_BASE		(0x0f100000)
++//#define MTK_2P5GPHY_PMB_FW_LEN		MT7988_2P5GE_PMB_FW_SIZE
++
++#define MTK_2P5GPHY_APB_BASE		(0x11c30000)
++#define MTK_2P5GPHY_APB_LEN		(0x9c)
++#define SW_RESET			(0x94)
++#define   MD32_RESTART_EN_CLEAR		BIT(9)
++
++
+ #define BASE100T_STATUS_EXTEND		(0x10)
+ #define BASE1000T_STATUS_EXTEND		(0x11)
+ #define EXTEND_CTRL_AND_STATUS		(0x16)
+@@ -31,6 +95,14 @@
+ #define MTK_PHY_LPI_PCS_DSP_CTRL		(0x121)
+ #define   MTK_PHY_LPI_SIG_EN_LO_THRESH100_MASK	GENMASK(12, 8)
+ 
++#define MTK_PHY_LINK_STATUS_RELATED		(0x147)
++#define   MTK_PHY_BYPASS_LINK_STATUS_OK		BIT(4)
++#define   MTK_PHY_FORCE_LINK_STATUS_HCD		BIT(3)
++
++#define MTK_PHY_AN_FORCE_SPEED_REG		(0x313)
++#define   MTK_PHY_MASTER_FORCE_SPEED_SEL_EN	BIT(7)
++#define   MTK_PHY_MASTER_FORCE_SPEED_SEL_MASK	GENMASK(6, 0)
++
+ #define MTK_PHY_HOST_CMD1		0x800e
+ #define MTK_PHY_HOST_CMD2		0x800f
+ /* Registers on Token Ring debug nodes */
+@@ -48,7 +120,249 @@ enum {
+ 	PHY_AUX_SPD_2500,
+ };
+ 
+-static int mt798x_2p5ge_phy_load_fw(struct phy_device *phydev)
++static int mt7987_2p5ge_phy_load_fw(struct phy_device *phydev)
++{
++	struct mtk_i2p5ge_phy_priv *priv = phydev->priv;
++	struct device *dev = &phydev->mdio.dev;
++	void __iomem *xbz_pcs_reg_base;
++	void __iomem *xbz_pma_rx_base;
++	void __iomem *chip_scu_base;
++	void __iomem *pmd_reg_base;
++	void __iomem *mcu_csr_base;
++	const struct firmware *fw;
++	void __iomem *apb_base;
++	void __iomem *pmb_addr;
++	int ret, i;
++	u32 reg;
++
++	if (priv->fw_loaded)
++		return 0;
++
++	apb_base = ioremap(MTK_2P5GPHY_APB_BASE,
++			   MTK_2P5GPHY_APB_LEN);
++	if (!apb_base)
++		return -ENOMEM;
++
++	pmd_reg_base = ioremap(MTK_2P5GPHY_PMD_REG_BASE,
++			       MTK_2P5GPHY_PMD_REG_LEN);
++	if (!pmd_reg_base) {
++		ret = -ENOMEM;
++		goto free_apb;
++	}
++
++	xbz_pcs_reg_base = ioremap(MTK_2P5GPHY_XBZ_PCS_REG_BASE,
++				   MTK_2P5GPHY_XBZ_PCS_REG_LEN);
++	if (!xbz_pcs_reg_base) {
++		ret = -ENOMEM;
++		goto free_pmd;
++	}
++
++	xbz_pma_rx_base = ioremap(MTK_2P5GPHY_XBZ_PMA_RX_BASE,
++				  MTK_2P5GPHY_XBZ_PMA_RX_LEN);
++	if (!xbz_pma_rx_base) {
++		ret = -ENOMEM;
++		goto free_pcs;
++	}
++
++	chip_scu_base = ioremap(MTK_2P5GPHY_CHIP_SCU_BASE,
++				MTK_2P5GPHY_CHIP_SCU_LEN);
++	if (!chip_scu_base) {
++		ret = -ENOMEM;
++		goto free_pma;
++	}
++
++	mcu_csr_base = ioremap(MTK_2P5GPHY_MCU_CSR_BASE,
++			       MTK_2P5GPHY_MCU_CSR_LEN);
++	if (!mcu_csr_base) {
++		ret = -ENOMEM;
++		goto free_chip_scu;
++	}
++
++	pmb_addr = ioremap(MTK_2P5GPHY_PMB_FW_BASE, MT7987_2P5GE_PMB_FW_SIZE);
++	if (!pmb_addr) {
++		return -ENOMEM;
++		goto free_mcu_csr;
++	}
++
++	ret = request_firmware(&fw, MT7987_2P5GE_PMB_FW, dev);
++	if (ret) {
++		dev_err(dev, "failed to load firmware: %s, ret: %d\n",
++			MT7987_2P5GE_PMB_FW, ret);
++		goto free_pmb_addr;
++	}
++
++	if (fw->size != MT7987_2P5GE_PMB_FW_SIZE) {
++		dev_err(dev, "PMb firmware size 0x%zx != 0x%x\n",
++			fw->size, MT7987_2P5GE_PMB_FW_SIZE);
++		ret = -EINVAL;
++		goto release_fw;
++	}
++
++	/* Force 2.5Gphy back to AN state */
++	phy_set_bits(phydev, MII_BMCR, BMCR_RESET);
++	usleep_range(5000, 6000);
++	phy_set_bits(phydev, MII_BMCR, BMCR_PDOWN);
++
++	reg = readw(apb_base + SW_RESET);
++	writew(reg & ~MD32_RESTART_EN_CLEAR, apb_base + SW_RESET);
++	writew(reg | MD32_RESTART_EN_CLEAR, apb_base + SW_RESET);
++	writew(reg & ~MD32_RESTART_EN_CLEAR, apb_base + SW_RESET);
++
++	reg = readw(mcu_csr_base + MD32_EN_CFG);
++	writew(reg & ~MD32_EN, mcu_csr_base + MD32_EN_CFG);
++
++	for (i = 0; i < MT7987_2P5GE_PMB_FW_SIZE - 1; i += 4)
++		writel(*((uint32_t *)(fw->data + i)), pmb_addr + i);
++	dev_info(dev, "Firmware date code: %x/%x/%x, version: %x.%x\n",
++		 be16_to_cpu(*((__be16 *)(fw->data +
++					  MT7987_2P5GE_PMB_FW_SIZE - 8))),
++		 *(fw->data + MT7987_2P5GE_PMB_FW_SIZE - 6),
++		 *(fw->data + MT7987_2P5GE_PMB_FW_SIZE - 5),
++		 *(fw->data + MT7987_2P5GE_PMB_FW_SIZE - 2),
++		 *(fw->data + MT7987_2P5GE_PMB_FW_SIZE - 1));
++	release_firmware(fw);
++
++	/* Enable 100Mbps module clock. */
++	writel(FIELD_PREP(RG_SPEED_MASK, RG_SPEED_100),
++	       pmd_reg_base + FNPLL_PWR_CTRL1);
++
++	/* Check if 100Mbps module clock is ready. */
++	ret = readl_poll_timeout(pmd_reg_base + FNPLL_PWR_CTRL_STATUS, reg,
++				 reg & RG_SPEED_100_STABLE, 1, 10000);
++	if (ret)
++		dev_err(dev, "Fail to enable 100Mbps module clock: %d\n", ret);
++
++	/* Enable 2.5Gbps module clock. */
++	writel(FIELD_PREP(RG_SPEED_MASK, RG_SPEED_2500),
++	       pmd_reg_base + FNPLL_PWR_CTRL1);
++
++	/* Check if 2.5Gbps module clock is ready. */
++	ret = readl_poll_timeout(pmd_reg_base + FNPLL_PWR_CTRL_STATUS, reg,
++				 reg & RG_SPEED_2500_STABLE, 1, 10000);
++
++	if (ret)
++		dev_err(dev, "Fail to enable 2.5Gbps module clock: %d\n", ret);
++
++	/* Disable AN */
++	phy_clear_bits(phydev, MII_BMCR, BMCR_ANENABLE);
++
++	/* Force to run at 2.5G speed */
++	phy_modify_mmd(phydev, MDIO_MMD_VEND1, MTK_PHY_AN_FORCE_SPEED_REG,
++		       MTK_PHY_MASTER_FORCE_SPEED_SEL_MASK,
++		       MTK_PHY_MASTER_FORCE_SPEED_SEL_EN |
++		       FIELD_PREP(MTK_PHY_MASTER_FORCE_SPEED_SEL_MASK, 0x1b));
++
++	phy_set_bits_mmd(phydev, MDIO_MMD_VEND1, MTK_PHY_LINK_STATUS_RELATED,
++			 MTK_PHY_BYPASS_LINK_STATUS_OK |
++			 MTK_PHY_FORCE_LINK_STATUS_HCD);
++
++	/* Set xbz, pma and rx as "do not reset" in order to input DSP code. */
++	reg = readl(pmd_reg_base + DO_NOT_RESET);
++	reg |= DO_NOT_RESET_XBZ | DO_NOT_RESET_PMA | DO_NOT_RESET_RX;
++	writel(reg, pmd_reg_base + DO_NOT_RESET);
++
++	reg = readl(chip_scu_base + SYS_SW_RESET);
++	writel(reg & ~RESET_RST_CNT, chip_scu_base + SYS_SW_RESET);
++
++	writel(WRITE_PROTECT_KEY, xbz_pcs_reg_base + PMU_WP);
++
++	reg = readl(xbz_pcs_reg_base + PMU_PMA_AUTO_CFG);
++	reg |= PMU_AUTO_MODE_EN | POWER_ON_AUTO_MODE;
++	writel(reg, xbz_pcs_reg_base + PMU_PMA_AUTO_CFG);
++
++	/* Check if clock in auto mode is disabled. */
++	ret = readl_poll_timeout(xbz_pcs_reg_base + PMU_PMA_STATUS, reg,
++				 (reg & CLK_IS_DISABLED) == 0x0, 1, 100000);
++	if (ret)
++		dev_err(dev, "Clock isn't disabled in auto mode: %d\n", ret);
++
++	reg = readl(xbz_pma_rx_base + SMEM_CTRL);
++	writel(reg | SMEM_HW_RDATA_ZERO, xbz_pma_rx_base + SMEM_CTRL);
++
++	reg = readl(xbz_pcs_reg_base + PHY_CTRL_CONFIG);
++	writel(reg | BIT(16), xbz_pcs_reg_base + PHY_CTRL_CONFIG);
++
++	/* Initialize data memory */
++	reg = readl(xbz_pma_rx_base + DM_CTRL_P01);
++	writel(reg | BIT(28), xbz_pma_rx_base + DM_CTRL_P01);
++	reg = readl(xbz_pma_rx_base + DM_CTRL_P23);
++	writel(reg | BIT(28), xbz_pma_rx_base + DM_CTRL_P23);
++
++	/* Initialize coefficient memory */
++	reg = readl(xbz_pma_rx_base + CM_CTRL_P01);
++	writel(reg | BIT(28), xbz_pma_rx_base + CM_CTRL_P01);
++	reg = readl(xbz_pma_rx_base + CM_CTRL_P23);
++	writel(reg | BIT(28), xbz_pma_rx_base + CM_CTRL_P23);
++
++	/* Initilize PM offset */
++	writel(0, xbz_pma_rx_base + SMEM_ADDR_REF_ADDR);
++
++	ret = request_firmware(&fw, MT7987_2P5GE_DSPBITTB, dev);
++	if (ret) {
++		dev_err(dev, "failed to load firmware: %s, ret: %d\n",
++			MT7987_2P5GE_DSPBITTB, ret);
++		goto free_pmb_addr;
++	}
++	if (fw->size != MT7987_2P5GE_DSPBITTB_SIZE) {
++		dev_err(dev, "DSPBITTB size 0x%zx != 0x%x\n",
++			fw->size, MT7987_2P5GE_DSPBITTB_SIZE);
++		ret = -EINVAL;
++		goto release_fw;
++	}
++
++	for (i = 0; i < fw->size - 1; i += 16) {
++		writel(*((uint32_t *)(fw->data + i)),
++		       xbz_pma_rx_base + SMEM_WDAT0);
++		writel(*((uint32_t *)(fw->data + i + 0x4)),
++		       xbz_pma_rx_base + SMEM_WDAT1);
++		writel(*((uint32_t *)(fw->data + i + 0x8)),
++		       xbz_pma_rx_base + SMEM_WDAT2);
++		writel(*((uint32_t *)(fw->data + i + 0xc)),
++		       xbz_pma_rx_base + SMEM_WDAT3);
++	}
++
++	reg = readl(xbz_pma_rx_base + DM_CTRL_P01);
++	writel(reg & ~BIT(28), xbz_pma_rx_base + DM_CTRL_P01);
++
++	reg = readl(xbz_pma_rx_base + DM_CTRL_P23);
++	writel(reg & ~BIT(28), xbz_pma_rx_base + DM_CTRL_P23);
++
++	reg = readl(xbz_pma_rx_base + CM_CTRL_P01);
++	writel(reg & ~BIT(28), xbz_pma_rx_base + CM_CTRL_P01);
++
++	reg = readl(xbz_pma_rx_base + CM_CTRL_P23);
++	writel(reg & ~BIT(28), xbz_pma_rx_base + CM_CTRL_P23);
++
++	reg = readw(mcu_csr_base + MD32_EN_CFG);
++	writew(reg | MD32_EN, mcu_csr_base + MD32_EN_CFG);
++	phy_set_bits(phydev, MII_BMCR, BMCR_RESET);
++	/* We need a delay here to stabilize initialization of MCU */
++	usleep_range(7000, 8000);
++	dev_info(dev, "Firmware loading/trigger ok.\n");
++
++	priv->fw_loaded = true;
++
++release_fw:
++	release_firmware(fw);
++free_pmb_addr:
++	iounmap(pmb_addr);
++free_mcu_csr:
++	iounmap(mcu_csr_base);
++free_chip_scu:
++	iounmap(chip_scu_base);
++free_pma:
++	iounmap(xbz_pma_rx_base);
++free_pcs:
++	iounmap(xbz_pcs_reg_base);
++free_pmd:
++	iounmap(pmd_reg_base);
++free_apb:
++	iounmap(apb_base);
++
++	return ret;
++}
++
++static int mt7988_2p5ge_phy_load_fw(struct phy_device *phydev)
+ {
+ 	struct mtk_i2p5ge_phy_priv *priv = phydev->priv;
+ 	void __iomem *mcu_csr_base, *pmb_addr;
+@@ -135,7 +449,20 @@ static int mt798x_2p5ge_phy_config_init(
+ 	if (phydev->interface != PHY_INTERFACE_MODE_INTERNAL)
+ 		return -ENODEV;
+ 
+-	ret = mt798x_2p5ge_phy_load_fw(phydev);
++	switch (phydev->drv->phy_id) {
++	case MTK_2P5GPHY_ID_MT7987:
++		ret = mt7987_2p5ge_phy_load_fw(phydev);
++		phy_clear_bits_mmd(phydev, MDIO_MMD_VEND2, MTK_PHY_LED0_ON_CTRL,
++				   MTK_PHY_LED_ON_POLARITY);
++		break;
++	case MTK_2P5GPHY_ID_MT7988:
++		ret = mt7988_2p5ge_phy_load_fw(phydev);
++		phy_set_bits_mmd(phydev, MDIO_MMD_VEND2, MTK_PHY_LED0_ON_CTRL,
++				 MTK_PHY_LED_ON_POLARITY);
++		break;
++	default:
++		return -EINVAL;
++	}
+ 	if (ret < 0)
+ 		return ret;
+ 
+@@ -293,6 +620,7 @@ static int mt798x_2p5ge_phy_probe(struct
+ 		return -ENOMEM;
+ 
+ 	switch (phydev->drv->phy_id) {
++	case MTK_2P5GPHY_ID_MT7987:
+ 	case MTK_2P5GPHY_ID_MT7988:
+ 		/* The original hardware only sets MDIO_DEVS_PMAPMD */
+ 		phydev->c45_ids.mmds_present |= MDIO_DEVS_PCS |
+@@ -312,6 +640,20 @@ static int mt798x_2p5ge_phy_probe(struct
+ 
+ static struct phy_driver mtk_2p5gephy_driver[] = {
+ 	{
++		PHY_ID_MATCH_MODEL(MTK_2P5GPHY_ID_MT7987),
++		.name = "MediaTek MT7987 2.5GbE PHY",
++		.probe = mt798x_2p5ge_phy_probe,
++		.config_init = mt798x_2p5ge_phy_config_init,
++		.config_aneg = mt798x_2p5ge_phy_config_aneg,
++		.get_features = mt798x_2p5ge_phy_get_features,
++		.read_status = mt798x_2p5ge_phy_read_status,
++		.get_rate_matching = mt798x_2p5ge_phy_get_rate_matching,
++		.suspend = genphy_suspend,
++		.resume = genphy_resume,
++		.read_page = mtk_phy_read_page,
++		.write_page = mtk_phy_write_page,
++	},
++	{
+ 		PHY_ID_MATCH_MODEL(MTK_2P5GPHY_ID_MT7988),
+ 		.name = "MediaTek MT7988 2.5GbE PHY",
+ 		.probe = mt798x_2p5ge_phy_probe,
--- /dev/null
+++ b/target/linux/mediatek/patches-6.12/830-thermal-drivers-mediatek-lvts_thermal-Add-irq_enable-support.patch
@@ -0,0 +1,148 @@
+From: Chad Monroe <chad@monroe.io>
+Date: Mon, 01 Sep 2025 06:42:10 -0700
+Subject: [PATCH] thermal/drivers/mediatek/lvts_thermal: Add irq_enable
+ support.
+
+Allow interrupt support to be disabled as some SoCs don't support it.
+
+Signed-off-by: Chad Monroe <chad@monroe.io>
+---
+ drivers/thermal/mediatek/lvts_thermal.c |   33 ++++++++++++++++------
+ 1 file changed, 25 insertions(+), 8 deletions(-)
+
+--- a/drivers/thermal/mediatek/lvts_thermal.c
++++ b/drivers/thermal/mediatek/lvts_thermal.c
+@@ -127,6 +127,7 @@ struct lvts_data {
+ 	const struct lvts_ctrl_data *lvts_ctrl;
+ 	const u32 *conn_cmd;
+ 	const u32 *init_cmd;
++	bool irq_enable;
+ 	int num_lvts_ctrl;
+ 	int num_conn_cmd;
+ 	int num_init_cmd;
+@@ -408,6 +409,10 @@ static int lvts_set_trips(struct thermal
+ 		lvts_ctrl->high_thresh = high;
+ 		lvts_ctrl->low_thresh = low;
+ 	}
++
++	if (!lvts_data->irq_enable)
++		return 0;
++
+ 	lvts_update_irq_mask(lvts_ctrl);
+ 
+ 	if (!should_update_thresh)
+@@ -921,6 +926,8 @@ static void lvts_write_config(struct lvt
+ 
+ static int lvts_irq_init(struct lvts_ctrl *lvts_ctrl)
+ {
++	const struct lvts_data *lvts_data = lvts_ctrl->lvts_data;
++
+ 	/*
+ 	 * LVTS_PROTCTL : Thermal Protection Sensor Selection
+ 	 *
+@@ -954,7 +961,8 @@ static int lvts_irq_init(struct lvts_ctr
+ 	 * The LVTS_MONINT register layout is the same as the LVTS_MONINTSTS
+ 	 * register, except we set the bits to enable the interrupt.
+ 	 */
+-	writel(0, LVTS_MONINT(lvts_ctrl->base));
++	if (lvts_data->irq_enable)
++		writel(0, LVTS_MONINT(lvts_ctrl->base));
+ 
+ 	return 0;
+ }
+@@ -1338,9 +1346,11 @@ static int lvts_probe(struct platform_de
+ 	if (IS_ERR(lvts_td->reset))
+ 		return dev_err_probe(dev, PTR_ERR(lvts_td->reset), "Failed to get reset control\n");
+ 
+-	irq = platform_get_irq(pdev, 0);
+-	if (irq < 0)
+-		return irq;
++	if (lvts_data->irq_enable) {
++		irq = platform_get_irq(pdev, 0);
++		if (irq < 0)
++			return irq;
++	}
+ 
+ 	golden_temp_offset = lvts_data->temp_offset;
+ 
+@@ -1352,10 +1362,12 @@ static int lvts_probe(struct platform_de
+ 	 * At this point the LVTS is initialized and enabled. We can
+ 	 * safely enable the interrupt.
+ 	 */
+-	ret = devm_request_threaded_irq(dev, irq, NULL, lvts_irq_handler,
+-					IRQF_ONESHOT, dev_name(dev), lvts_td);
+-	if (ret)
+-		return dev_err_probe(dev, ret, "Failed to request interrupt\n");
++	if (lvts_data->irq_enable) {
++		ret = devm_request_threaded_irq(dev, irq, NULL, lvts_irq_handler,
++						IRQF_ONESHOT, dev_name(dev), lvts_td);
++		if (ret)
++			return dev_err_probe(dev, ret, "Failed to request interrupt\n");
++	}
+ 
+ 	platform_set_drvdata(pdev, lvts_td);
+ 
+@@ -1754,6 +1766,7 @@ static const struct lvts_ctrl_data mt819
+ };
+ 
+ static const struct lvts_data mt7988_lvts_ap_data = {
++	.irq_enable	= true,
+ 	.lvts_ctrl	= mt7988_lvts_ap_data_ctrl,
+ 	.conn_cmd	= mt7988_conn_cmds,
+ 	.init_cmd	= mt7988_init_cmds,
+@@ -1766,6 +1779,7 @@ static const struct lvts_data mt7988_lvt
+ };
+ 
+ static const struct lvts_data mt8186_lvts_data = {
++	.irq_enable	= true,
+ 	.lvts_ctrl	= mt8186_lvts_data_ctrl,
+ 	.conn_cmd	= default_conn_cmds,
+ 	.init_cmd	= default_init_cmds,
+@@ -1779,6 +1793,7 @@ static const struct lvts_data mt8186_lvt
+ };
+ 
+ static const struct lvts_data mt8188_lvts_mcu_data = {
++	.irq_enable	= true,
+ 	.lvts_ctrl	= mt8188_lvts_mcu_data_ctrl,
+ 	.conn_cmd	= default_conn_cmds,
+ 	.init_cmd	= default_init_cmds,
+@@ -1792,6 +1807,7 @@ static const struct lvts_data mt8188_lvt
+ };
+ 
+ static const struct lvts_data mt8188_lvts_ap_data = {
++	.irq_enable	= true,
+ 	.lvts_ctrl	= mt8188_lvts_ap_data_ctrl,
+ 	.conn_cmd	= default_conn_cmds,
+ 	.init_cmd	= default_init_cmds,
+@@ -1805,6 +1821,7 @@ static const struct lvts_data mt8188_lvt
+ };
+ 
+ static const struct lvts_data mt8192_lvts_mcu_data = {
++	.irq_enable	= true,
+ 	.lvts_ctrl	= mt8192_lvts_mcu_data_ctrl,
+ 	.conn_cmd	= default_conn_cmds,
+ 	.init_cmd	= default_init_cmds,
+@@ -1818,6 +1835,7 @@ static const struct lvts_data mt8192_lvt
+ };
+ 
+ static const struct lvts_data mt8192_lvts_ap_data = {
++	.irq_enable	= true,
+ 	.lvts_ctrl	= mt8192_lvts_ap_data_ctrl,
+ 	.conn_cmd	= default_conn_cmds,
+ 	.init_cmd	= default_init_cmds,
+@@ -1831,6 +1849,7 @@ static const struct lvts_data mt8192_lvt
+ };
+ 
+ static const struct lvts_data mt8195_lvts_mcu_data = {
++	.irq_enable	= true,
+ 	.lvts_ctrl	= mt8195_lvts_mcu_data_ctrl,
+ 	.conn_cmd	= default_conn_cmds,
+ 	.init_cmd	= default_init_cmds,
+@@ -1844,6 +1863,7 @@ static const struct lvts_data mt8195_lvt
+ };
+ 
+ static const struct lvts_data mt8195_lvts_ap_data = {
++	.irq_enable	= true,
+ 	.lvts_ctrl	= mt8195_lvts_ap_data_ctrl,
+ 	.conn_cmd	= default_conn_cmds,
+ 	.init_cmd	= default_init_cmds,
--- /dev/null
+++ b/target/linux/mediatek/patches-6.12/831-thermal-drivers-mediatek-lvts_thermal-Add-MT7987-support.patch
@@ -0,0 +1,106 @@
+From: Chad Monroe <chad@monroe.io>
+Date: Mon, 01 Sep 2025 06:44:04 -0700
+Subject: [PATCH] thermal/drivers/mediatek/lvts_thermal: Add MT7987 support 
+
+Add support for Mediatek MT7987 LVTS. Based patch[1] from vendor  SDK.
+
+1: https://git01.mediatek.com/plugins/gitiles/openwrt/feeds/mtk-openwrt-feeds/+/742007e189ffcc95783924cea1150f574b6eb71e
+
+Signed-off-by: Chad Monroe <chad@monroe.io>
+---
+ drivers/thermal/mediatek/lvts_thermal.c             |   36 ++++++++++
+ include/dt-bindings/thermal/mediatek,lvts-thermal.h |    3 
+ 2 files changed, 39 insertions(+)
+
+--- a/drivers/thermal/mediatek/lvts_thermal.c
++++ b/drivers/thermal/mediatek/lvts_thermal.c
+@@ -87,6 +87,8 @@
+ #define LVTS_COEFF_B_MT8195			250460
+ #define LVTS_COEFF_A_MT7988			-204650
+ #define LVTS_COEFF_B_MT7988			204650
++#define LVTS_COEFF_A_MT7987			-204650
++#define LVTS_COEFF_B_MT7987			204650
+ 
+ #define LVTS_MSR_IMMEDIATE_MODE		0
+ #define LVTS_MSR_FILTERED_MODE		1
+@@ -1385,6 +1387,19 @@ static void lvts_remove(struct platform_
+ 		lvts_ctrl_set_enable(&lvts_td->lvts_ctrl[i], false);
+ }
+ 
++static const struct lvts_ctrl_data mt7987_lvts_ap_data_ctrl[] = {
++	{
++		.lvts_sensor = {
++			{ .dt_id = MT7987_CPU,
++			  .cal_offsets = { 0x04, 0x05, 0x06 } },
++			{ .dt_id = MT7987_ETH2P5G,
++			  .cal_offsets = { 0x08, 0x09, 0x0a } },
++		},
++		VALID_SENSOR_MAP(1, 1, 0, 0),
++		.offset = 0x0,
++	},
++};
++
+ static const struct lvts_ctrl_data mt7988_lvts_ap_data_ctrl[] = {
+ 	{
+ 		.lvts_sensor = {
+@@ -1455,6 +1470,7 @@ static int lvts_resume(struct device *de
+ }
+ 
+ static const u32 default_conn_cmds[] = { 0xC103FFFF, 0xC502FF55 };
++static const u32 mt7987_conn_cmds[] = { 0xC103FFFF, 0xC502FC55 };
+ static const u32 mt7988_conn_cmds[] = { 0xC103FFFF, 0xC502FC55 };
+ 
+ /*
+@@ -1467,6 +1483,12 @@ static const u32 default_init_cmds[] = {
+ 	0xC10300FC, 0xC103009D, 0xC10300F1, 0xC10300E1
+ };
+ 
++static const u32 mt7987_init_cmds[] = {
++	0xC1030300, 0xC1030420, 0xC1030500, 0xC10307A6, 0xC10308C7,
++	0xC103098D, 0xC1030C7C, 0xC1030AA8, 0xC10308CE, 0xC10308C7,
++	0xC1030B04, 0xC1030E01, 0xC10306B8
++};
++
+ static const u32 mt7988_init_cmds[] = {
+ 	0xC1030300, 0xC1030420, 0xC1030500, 0xC10307A6, 0xC1030CFC,
+ 	0xC1030A8C, 0xC103098D, 0xC10308F1, 0xC1030B04, 0xC1030E01,
+@@ -1765,6 +1787,19 @@ static const struct lvts_ctrl_data mt819
+ 	}
+ };
+ 
++static const struct lvts_data mt7987_lvts_ap_data = {
++	.irq_enable	= false,
++	.lvts_ctrl	= mt7987_lvts_ap_data_ctrl,
++	.conn_cmd	= mt7987_conn_cmds,
++	.init_cmd	= mt7987_init_cmds,
++	.num_lvts_ctrl	= ARRAY_SIZE(mt7987_lvts_ap_data_ctrl),
++	.num_conn_cmd	= ARRAY_SIZE(mt7987_conn_cmds),
++	.num_init_cmd	= ARRAY_SIZE(mt7987_init_cmds),
++	.temp_factor	= LVTS_COEFF_A_MT7987,
++	.temp_offset	= LVTS_COEFF_B_MT7987,
++	.gt_calib_bit_offset = 24,
++};
++
+ static const struct lvts_data mt7988_lvts_ap_data = {
+ 	.irq_enable	= true,
+ 	.lvts_ctrl	= mt7988_lvts_ap_data_ctrl,
+@@ -1877,6 +1912,7 @@ static const struct lvts_data mt8195_lvt
+ };
+ 
+ static const struct of_device_id lvts_of_match[] = {
++	{ .compatible = "mediatek,mt7987-lvts-ap", .data = &mt7987_lvts_ap_data },
+ 	{ .compatible = "mediatek,mt7988-lvts-ap", .data = &mt7988_lvts_ap_data },
+ 	{ .compatible = "mediatek,mt8186-lvts", .data = &mt8186_lvts_data },
+ 	{ .compatible = "mediatek,mt8188-lvts-mcu", .data = &mt8188_lvts_mcu_data },
+--- a/include/dt-bindings/thermal/mediatek,lvts-thermal.h
++++ b/include/dt-bindings/thermal/mediatek,lvts-thermal.h
+@@ -7,6 +7,9 @@
+ #ifndef __MEDIATEK_LVTS_DT_H
+ #define __MEDIATEK_LVTS_DT_H
+ 
++#define MT7987_CPU		0
++#define MT7987_ETH2P5G		1
++
+ #define MT7988_CPU_0		0
+ #define MT7988_CPU_1		1
+ #define MT7988_ETH2P5G_0	2
--- /dev/null
+++ b/target/linux/mediatek/patches-6.12/840-cpufreq-add-support-to-adjust-cpu-volt-by-efuse-cali.patch
@@ -0,0 +1,106 @@
+From fbb1d181782f990c0ac5f39d4aa9eda5c39cb442 Mon Sep 17 00:00:00 2001
+From: Sam Shih <sam.shih@mediatek.com>
+Date: Tue, 4 Mar 2025 19:28:14 +0800
+Subject: [PATCH 1/2] cpufreq: add support to adjust cpu volt by efuse
+ calibration data
+
+---
+ drivers/cpufreq/mediatek-cpufreq.c | 81 ++++++++++++++++++++++++++++--
+ 1 file changed, 76 insertions(+), 5 deletions(-)
+
+--- a/drivers/cpufreq/mediatek-cpufreq.c
++++ b/drivers/cpufreq/mediatek-cpufreq.c
+@@ -15,14 +15,26 @@
+ #include <linux/platform_device.h>
+ #include <linux/pm_opp.h>
+ #include <linux/regulator/consumer.h>
++#include <linux/nvmem-consumer.h>
++
++struct mtk_cpufreq_corr_data {
++	unsigned int freq;
++	unsigned int vbase;
++	unsigned int vscale;
++	unsigned int vmax;
++};
+ 
+ struct mtk_cpufreq_platform_data {
++	/* cpufreq correction data specification */
++	const struct mtk_cpufreq_corr_data *corr_data;
+ 	int min_volt_shift;
+ 	int max_volt_shift;
+ 	int proc_max_volt;
+ 	int sram_min_volt;
+ 	int sram_max_volt;
+ 	bool ccifreq_supported;
++	/* whether voltage correction via nvmem is supported */
++	bool nvmem_volt_corr;
+ };
+ 
+ /*
+@@ -197,6 +209,50 @@ static bool is_ccifreq_ready(struct mtk_
+ 	return true;
+ }
+ 
++static int mtk_cpufreq_nvmem_volt_corr(struct mtk_cpu_dvfs_info *info,
++				      struct cpufreq_policy *policy)
++{
++	const struct mtk_cpufreq_corr_data *corr_data;
++	unsigned int target_voltage;
++	struct nvmem_cell *cell;
++	unsigned int cal_data;
++	const u8 *buf;
++	size_t len;
++	int i;
++
++	cell = nvmem_cell_get(info->cpu_dev, "calibration-data");
++	if (IS_ERR(cell))
++		return PTR_ERR(cell);
++
++	buf = nvmem_cell_read(cell, &len);
++	nvmem_cell_put(cell);
++	if (IS_ERR(buf))
++		return PTR_ERR(buf);
++
++	cal_data = buf[0] & 0x1f;
++	pr_debug("%s: read vbinning value: %d\n", __func__, cal_data);
++	kfree(buf);
++	if (!info->soc_data->corr_data) {
++		pr_err("voltage correction data not found\n");
++		return -EINVAL;
++	}
++
++	corr_data = &info->soc_data->corr_data[0];
++	for (i = 0 ; i < corr_data->freq ; i++) {
++		target_voltage =  corr_data->vbase + cal_data * corr_data->vscale;
++		if (target_voltage > corr_data->vmax) {
++			pr_warn("freq %u exceeds max voltage\n", corr_data->freq);
++			pr_warn("force update voltage to %u\n", corr_data->vmax);
++			target_voltage = corr_data->vmax;
++		}
++		dev_pm_opp_remove(info->cpu_dev, corr_data->freq);
++		dev_pm_opp_add(info->cpu_dev, corr_data->freq, target_voltage);
++		corr_data = &info->soc_data->corr_data[i + 1];
++	}
++
++	return 0;
++}
++
+ static int mtk_cpufreq_set_target(struct cpufreq_policy *policy,
+ 				  unsigned int index)
+ {
+@@ -584,6 +640,15 @@ static int mtk_cpufreq_init(struct cpufr
+ 		return -EINVAL;
+ 	}
+ 
++	if (info->soc_data->nvmem_volt_corr) {
++		ret = mtk_cpufreq_nvmem_volt_corr(info, policy);
++		if (ret) {
++			pr_err("failed to correction voltage for cpu%d: %d\n",
++			       policy->cpu, ret);
++			return ret;
++		}
++	}
++
+ 	ret = dev_pm_opp_init_cpufreq_table(info->cpu_dev, &freq_table);
+ 	if (ret) {
+ 		dev_err(info->cpu_dev,
--- /dev/null
+++ b/target/linux/mediatek/patches-6.12/841-cpufreq-add-cpu-volt-correction-support-for-mt7988.patch
@@ -0,0 +1,33 @@
+--- a/drivers/cpufreq/mediatek-cpufreq.c
++++ b/drivers/cpufreq/mediatek-cpufreq.c
+@@ -741,6 +741,16 @@ static struct platform_driver mtk_cpufre
+ 	.probe		= mtk_cpufreq_probe,
+ };
+ 
++struct mtk_cpufreq_corr_data mt7988_volt_corr_data[] = {
++	{
++		.freq = 1800000000,
++		.vbase = 850000,
++		.vscale = 10000,
++		.vmax = 1120000,
++	},
++	{ } /* sentinel */
++};
++
+ static const struct mtk_cpufreq_platform_data mt2701_platform_data = {
+ 	.min_volt_shift = 100000,
+ 	.max_volt_shift = 200000,
+@@ -769,10 +779,12 @@ static const struct mtk_cpufreq_platform
+ static const struct mtk_cpufreq_platform_data mt7988_platform_data = {
+ 	.min_volt_shift = 100000,
+ 	.max_volt_shift = 200000,
+-	.proc_max_volt = 900000,
++	.proc_max_volt = 1120000,
+ 	.sram_min_volt = 0,
+ 	.sram_max_volt = 1150000,
+ 	.ccifreq_supported = true,
++	.nvmem_volt_corr = 1,
++	.corr_data = mt7988_volt_corr_data,
+ };
+ 
+ static const struct mtk_cpufreq_platform_data mt8183_platform_data = {
--- /dev/null
+++ b/target/linux/mediatek/patches-6.12/842-mediatek-enable-using-efuse-cali-data-for-mt7988-cpu-volt.patch
@@ -0,0 +1,48 @@
+From c776eb44070d009375559d8c6eb8790edfe129a9 Mon Sep 17 00:00:00 2001
+From: Sam Shih <sam.shih@mediatek.com>
+Date: Tue, 4 Mar 2025 19:35:14 +0800
+Subject: [PATCH 2/2] cpufreq: mt7988: enable using efuse calibration data for
+ adjusting cpu volt
+
+---
+ arch/arm64/boot/dts/mediatek/mt7988a.dtsi | 8 ++++++++
+ 1 file changed, 8 insertions(+)
+
+--- a/arch/arm64/boot/dts/mediatek/mt7988a.dtsi
++++ b/arch/arm64/boot/dts/mediatek/mt7988a.dtsi
+@@ -55,6 +55,8 @@
+ 				 <&topckgen CLK_TOP_XTAL>;
+ 			clock-names = "cpu", "intermediate";
+ 			operating-points-v2 = <&cluster0_opp>;
++			nvmem-cells = <&cpufreq_calibration>;
++			nvmem-cell-names = "calibration-data";
+ 			mediatek,cci = <&cci>;
+ 		};
+ 
+@@ -67,6 +69,8 @@
+ 				 <&topckgen CLK_TOP_XTAL>;
+ 			clock-names = "cpu", "intermediate";
+ 			operating-points-v2 = <&cluster0_opp>;
++			nvmem-cells = <&cpufreq_calibration>;
++			nvmem-cell-names = "calibration-data";
+ 			mediatek,cci = <&cci>;
+ 		};
+ 
+@@ -79,6 +83,8 @@
+ 				 <&topckgen CLK_TOP_XTAL>;
+ 			clock-names = "cpu", "intermediate";
+ 			operating-points-v2 = <&cluster0_opp>;
++			nvmem-cells = <&cpufreq_calibration>;
++			nvmem-cell-names = "calibration-data";
+ 			mediatek,cci = <&cci>;
+ 		};
+ 
+@@ -91,6 +97,8 @@
+ 				 <&topckgen CLK_TOP_XTAL>;
+ 			clock-names = "cpu", "intermediate";
+ 			operating-points-v2 = <&cluster0_opp>;
++			nvmem-cells = <&cpufreq_calibration>;
++			nvmem-cell-names = "calibration-data";
+ 			mediatek,cci = <&cci>;
+ 		};
+ 
--- /dev/null
+++ b/target/linux/mediatek/patches-6.12/843-cpufreq-add-support-to-fix-voltage-cpu.patch
@@ -0,0 +1,21 @@
+--- a/drivers/cpufreq/mediatek-cpufreq.c
++++ b/drivers/cpufreq/mediatek-cpufreq.c
+@@ -35,6 +35,8 @@ struct mtk_cpufreq_platform_data {
+ 	bool ccifreq_supported;
+ 	/* whether voltage correction via nvmem is supported */
+ 	bool nvmem_volt_corr;
++	/* Flag indicating whether the processor voltage is fixed */
++	bool proc_fixed_volt;
+ };
+ 
+ /*
+@@ -176,6 +178,9 @@ static int mtk_cpufreq_set_voltage(struc
+ 	const struct mtk_cpufreq_platform_data *soc_data = info->soc_data;
+ 	int ret;
+ 
++	if (soc_data->proc_fixed_volt)
++		return 0;
++
+ 	if (info->need_voltage_tracking)
+ 		ret = mtk_cpufreq_voltage_tracking(info, vproc);
+ 	else
--- /dev/null
+++ b/target/linux/mediatek/patches-6.12/844-cpufreq-mediatek-Add-support-for-MT7987.patch
@@ -0,0 +1,23 @@
+--- a/drivers/cpufreq/mediatek-cpufreq.c
++++ b/drivers/cpufreq/mediatek-cpufreq.c
+@@ -781,6 +781,12 @@ static const struct mtk_cpufreq_platform
+ 	.ccifreq_supported = false,
+ };
+ 
++static const struct mtk_cpufreq_platform_data mt7987_platform_data = {
++	.proc_max_volt = 1023000,
++	.ccifreq_supported = false,
++	.proc_fixed_volt = true,
++};
++
+ static const struct mtk_cpufreq_platform_data mt7988_platform_data = {
+ 	.min_volt_shift = 100000,
+ 	.max_volt_shift = 200000,
+@@ -825,6 +831,7 @@ static const struct of_device_id mtk_cpu
+ 	{ .compatible = "mediatek,mt2712", .data = &mt2701_platform_data },
+ 	{ .compatible = "mediatek,mt7622", .data = &mt7622_platform_data },
+ 	{ .compatible = "mediatek,mt7623", .data = &mt7623_platform_data },
++	{ .compatible = "mediatek,mt7987", .data = &mt7987_platform_data },
+ 	{ .compatible = "mediatek,mt7988a", .data = &mt7988_platform_data },
+ 	{ .compatible = "mediatek,mt7988d", .data = &mt7988_platform_data },
+ 	{ .compatible = "mediatek,mt8167", .data = &mt8516_platform_data },
--- a/target/linux/mediatek/patches-6.12/965-dts-mt7988a-add-trng-support.patch
+++ b/target/linux/mediatek/patches-6.12/965-dts-mt7988a-add-trng-support.patch
@@ -8,7 +8,7 @@ Signed-off-by: Marcos Alano <marcoshalan
 ---
 --- a/arch/arm64/boot/dts/mediatek/mt7988a.dtsi
 +++ b/arch/arm64/boot/dts/mediatek/mt7988a.dtsi
-@@ -1319,4 +1319,8 @@
+@@ -1327,4 +1327,8 @@
  			     <GIC_PPI 11 IRQ_TYPE_LEVEL_LOW>,
  			     <GIC_PPI 10 IRQ_TYPE_LEVEL_LOW>;
  	};
--- /dev/null
+++ b/target/linux/mediatek/dts/mt7987-emmc.dtso
@@ -0,0 +1,101 @@
+// SPDX-License-Identifier: (GPL-2.0 OR MIT)
+
+/dts-v1/;
+/plugin/;
+
+/ {
+	fragment@0 {
+		target-path = "/";
+		__overlay__ {
+			reg_3p3v: regulator-3p3v {
+				compatible = "regulator-fixed";
+				regulator-name = "fixed-3.3V";
+				regulator-min-microvolt = <3300000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+		};
+	};
+
+	fragment@1 {
+		target-path = "/soc/spi@11007800";
+		__overlay__ {
+			status = "disabled";
+		};
+	};
+
+	fragment@2 {
+		target-path = "/soc/mmc@11230000";
+		__overlay__ {
+			pinctrl-names = "default", "state_uhs";
+			pinctrl-0 = <&mmc_pins_default>;
+			pinctrl-1 = <&mmc_pins_uhs>;
+			bus-width = <8>;
+			max-frequency = <48000000>;
+			cap-mmc-highspeed;
+			vmmc-supply = <&reg_3p3v>;
+			non-removable;
+			status = "okay";
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			card@0 {
+				compatible = "mmc-card";
+				reg = <0>;
+
+				block {
+					compatible = "block-device";
+					partitions {
+						block-partition-env {
+							partname = "ubootenv";
+							nvmem-layout {
+								compatible = "u-boot,env";
+							};
+						};
+
+						block-partition-factory {
+							partname = "factory";
+
+							nvmem-layout {
+								compatible = "fixed-layout";
+								#address-cells = <1>;
+								#size-cells = <1>;
+
+								eeprom_factory_0: eeprom@0 {
+									reg = <0x0 0x1e00>;
+								};
+							};
+						};
+
+						emmc_rootfs: block-partition-production {
+							partname = "production";
+						};
+					};
+				};
+			};
+		};
+	};
+
+        fragment@3 {
+		target-path = "/chosen";
+		__overlay__ {
+			rootdisk-emmc = <&emmc_rootfs>;
+		};
+	};
+
+	fragment@4 {
+		target = <&pcie0>;
+		__overlay__ {
+			slot0: pcie@0,0 {
+				reg = <0x0000 0 0 0 0>;
+				mt7996@0,0 {
+					reg = <0x0000 0 0 0 0>;
+					nvmem-cells = <&eeprom_factory_0>;
+					nvmem-cell-names = "eeprom";
+				};
+			};
+		};
+	};
+};
+
--- /dev/null
+++ b/target/linux/mediatek/dts/mt7987-netsys-eth0-an8801sb.dtso
@@ -0,0 +1,40 @@
+// SPDX-License-Identifier: (GPL-2.0 OR MIT)
+
+/dts-v1/;
+/plugin/;
+
+/ {
+	fragment@0 {
+		target = <&gmac0>;
+		__overlay__ {
+			phy-mode = "sgmii";
+			phy-handle = <&phy31>;
+			status = "okay";
+		};
+	};
+
+	fragment@1 {
+		target-path = "/soc_netsys/ethernet@15100000/mdio-bus";
+		__overlay__ {
+			phy31: phy@31 {
+				compatible = "ethernet-phy-idc0ff.0421";
+				reg = <31>;
+				reset-gpios = <&pio 48 1>;
+				reset-assert-us = <10000>;
+				reset-deassert-us = <10000>;
+				phy-mode = "sgmii";
+				airoha,sgmii-mode = <1>;
+				eee-broken-100tx;
+				eee-broken-1000t;
+			};
+		};
+	};
+
+	fragment@2 {
+		target-path = "/soc_netsys/hnat@15000000";
+		__overlay__ {
+			mtketh-lan = "eth0";
+		};
+	};
+};
+
--- /dev/null
+++ b/target/linux/mediatek/dts/mt7987-netsys-eth0-an8855-gsw.dtso
@@ -0,0 +1,61 @@
+// SPDX-License-Identifier: (GPL-2.0 OR MIT)
+
+/dts-v1/;
+/plugin/;
+
+#include <dt-bindings/interrupt-controller/irq.h>
+#include <dt-bindings/gpio/gpio.h>
+
+/ {
+	fragment@0 {
+		target = <&gmac0>;
+		__overlay__ {
+			phy-mode = "2500base-x";
+			status = "okay";
+			fixed-link {
+				speed = <2500>;
+				full-duplex;
+				pause;
+			};
+		};
+	};
+
+	fragment@1 {
+		target-path = "/";
+		__overlay__ {
+			gsw_an8855: gsw@1 {
+				compatible = "airoha,an8855";
+				#mediatek,ethsys = <&ethsys>;
+				#address-cells = <1>;
+				#size-cells = <0>;
+
+				airoha,mdio = <&mdio>;
+				airoha,portmap = "lllll";
+				airoha,intr = <6>;
+				airoha,extSurge = <1>;
+				reset-gpios = <&pio 42 0>;
+				interrupt-parent = <&pio>;
+				interrupts = <41 IRQ_TYPE_LEVEL_HIGH>;
+				status = "okay";
+
+				port5: port@5 {
+					compatible = "airoha,an8855-port";
+					reg = <5>;
+					phy-mode = "2500base-x";
+
+					fixed-link {
+						speed = <2500>;
+						full-duplex;
+					};
+				};
+			};
+		};
+	};
+
+	fragment@2 {
+		target-path = "/soc_netsys/hnat@15000000";
+		__overlay__ {
+			mtketh-lan = "eth0";
+		};
+	};
+};
--- /dev/null
+++ b/target/linux/mediatek/dts/mt7987-netsys-eth0-an8855.dtso
@@ -0,0 +1,206 @@
+// SPDX-License-Identifier: (GPL-2.0 OR MIT)
+
+/dts-v1/;
+/plugin/;
+
+#include <dt-bindings/gpio/gpio.h>
+
+/ {
+	fragment@0 {
+		target = <&gmac0>;
+		__overlay__ {
+			phy-mode = "2500base-x";
+			status = "okay";
+			fixed-link {
+				speed = <2500>;
+				full-duplex;
+				pause;
+			};
+		};
+
+	};
+
+	fragment@1 {
+		target-path = "/soc_netsys/ethernet@15100000/mdio-bus";
+		__overlay__ {
+			mfd: mfd@1 {
+				compatible = "airoha,an8855-mfd";
+				reg = <1>;
+				status = "okay";
+
+				efuse {
+					compatible = "airoha,an8855-efuse";
+					#nvmem-cell-cells = <0>;
+
+					nvmem-layout {
+						compatible = "fixed-layout";
+						#address-cells = <1>;
+						#size-cells = <1>;
+
+						shift_sel_port0_tx_a: shift-sel-port0-tx-a@c {
+							reg = <0xc 0x4>;
+						};
+
+						shift_sel_port0_tx_b: shift-sel-port0-tx-b@10 {
+							reg = <0x10 0x4>;
+						};
+
+						shift_sel_port0_tx_c: shift-sel-port0-tx-c@14 {
+							reg = <0x14 0x4>;
+						};
+
+						shift_sel_port0_tx_d: shift-sel-port0-tx-d@18 {
+							reg = <0x18 0x4>;
+						};
+
+						shift_sel_port1_tx_a: shift-sel-port1-tx-a@1c {
+							reg = <0x1c 0x4>;
+						};
+
+						shift_sel_port1_tx_b: shift-sel-port1-tx-b@20 {
+							reg = <0x20 0x4>;
+						};
+
+						shift_sel_port1_tx_c: shift-sel-port1-tx-c@24 {
+							reg = <0x24 0x4>;
+						};
+
+						shift_sel_port1_tx_d: shift-sel-port1-tx-d@28 {
+							reg = <0x28 0x4>;
+						};
+
+						shift_sel_port2_tx_a: shift-sel-port2-tx-a@2c {
+							reg = <0x2c 0x4>;
+						};
+
+						shift_sel_port2_tx_b: shift-sel-port2-tx-b@30 {
+							reg = <0x30 0x4>;
+						};
+
+						shift_sel_port2_tx_c: shift-sel-port2-tx-c@34 {
+							reg = <0x34 0x4>;
+						};
+
+						shift_sel_port2_tx_d: shift-sel-port2-tx-d@38 {
+							reg = <0x38 0x4>;
+						};
+
+						shift_sel_port3_tx_a: shift-sel-port3-tx-a@4c {
+							reg = <0x4c 0x4>;
+						};
+
+						shift_sel_port3_tx_b: shift-sel-port3-tx-b@50 {
+							reg = <0x50 0x4>;
+						};
+
+						shift_sel_port3_tx_c: shift-sel-port3-tx-c@54 {
+							reg = <0x54 0x4>;
+						};
+
+						shift_sel_port3_tx_d: shift-sel-port3-tx-d@58 {
+							reg = <0x58 0x4>;
+						};
+					};
+				};
+
+				ethernet-switch {
+					compatible = "airoha,an8855-switch";
+					reset-gpios = <&pio 42 GPIO_ACTIVE_HIGH>;
+					airoha,ext-surge;
+
+					ports {
+						#address-cells = <1>;
+						#size-cells = <0>;
+
+						port@0 {
+							reg = <0>;
+							label = "lan0";
+							phy-mode = "internal";
+							phy-handle = <&internal_phy1>;
+						};
+
+						port@1 {
+							reg = <1>;
+							label = "lan1";
+							phy-mode = "internal";
+							phy-handle = <&internal_phy2>;
+						};
+
+						port@2 {
+							reg = <2>;
+							label = "lan2";
+							phy-mode = "internal";
+							phy-handle = <&internal_phy3>;
+						};
+
+						port@3 {
+							reg = <3>;
+							label = "lan3";
+							phy-mode = "internal";
+							phy-handle = <&internal_phy4>;
+						};
+
+						port@5 {
+							reg = <5>;
+							ethernet = <&gmac0>;
+							phy-mode = "2500base-x";
+
+							fixed-link {
+								speed = <2500>;
+								full-duplex;
+								pause;
+							};
+						};
+					};
+				};
+
+				mdio {
+					compatible = "airoha,an8855-mdio";
+					#address-cells = <1>;
+					#size-cells = <0>;
+
+					internal_phy1: phy@1 {
+						reg = <1>;
+
+						nvmem-cells = <&shift_sel_port0_tx_a>,
+								<&shift_sel_port0_tx_b>,
+								<&shift_sel_port0_tx_c>,
+								<&shift_sel_port0_tx_d>;
+						nvmem-cell-names = "tx_a", "tx_b", "tx_c", "tx_d";
+					};
+
+					internal_phy2: phy@2 {
+						reg = <2>;
+
+						nvmem-cells = <&shift_sel_port1_tx_a>,
+								<&shift_sel_port1_tx_b>,
+								<&shift_sel_port1_tx_c>,
+								<&shift_sel_port1_tx_d>;
+						nvmem-cell-names = "tx_a", "tx_b", "tx_c", "tx_d";
+					};
+
+					internal_phy3: phy@3 {
+						reg = <3>;
+
+						nvmem-cells = <&shift_sel_port2_tx_a>,
+								<&shift_sel_port2_tx_b>,
+								<&shift_sel_port2_tx_c>,
+								<&shift_sel_port2_tx_d>;
+						nvmem-cell-names = "tx_a", "tx_b", "tx_c", "tx_d";
+					};
+
+					internal_phy4: phy@4 {
+						reg = <4>;
+
+						nvmem-cells = <&shift_sel_port3_tx_a>,
+								<&shift_sel_port3_tx_b>,
+								<&shift_sel_port3_tx_c>,
+								<&shift_sel_port3_tx_d>;
+						nvmem-cell-names = "tx_a", "tx_b", "tx_c", "tx_d";
+					};
+				};
+			};
+		};
+	};
+};
+
--- /dev/null
+++ b/target/linux/mediatek/dts/mt7987-netsys-eth0-e2p5g.dtso
@@ -0,0 +1,40 @@
+// SPDX-License-Identifier: (GPL-2.0 OR MIT)
+
+/dts-v1/;
+/plugin/;
+
+/ {
+	fragment@0 {
+		target = <&gmac0>;
+		__overlay__ {
+			phy-mode = "2500base-x";
+			phy-handle = <&phy12>;
+			status = "okay";
+		};
+	};
+
+	fragment@1 {
+		target-path = "/soc_netsys/ethernet@15100000/mdio-bus";
+		__overlay__ {
+			phy12: phy@12 {
+				compatible = "ethernet-phy-id03a2.a411";
+				reg = <12>;
+				reset-gpios = <&pio 49 1>;
+				reset-assert-us = <10000>;
+				reset-deassert-us = <10000>;
+				phy-mode = "2500base-x";
+				full-duplex;
+				pause;
+				airoha,phy-handle;
+			};
+		};
+	};
+
+	fragment@2 {
+		target-path = "/soc_netsys/hnat@15000000";
+		__overlay__ {
+			mtketh-lan = "eth0";
+		};
+	};
+};
+
--- /dev/null
+++ b/target/linux/mediatek/dts/mt7987-netsys-eth0-mt7531-gsw.dtso
@@ -0,0 +1,87 @@
+// SPDX-License-Identifier: (GPL-2.0 OR MIT)
+
+/dts-v1/;
+/plugin/;
+
+#include <dt-bindings/interrupt-controller/irq.h>
+
+/ {
+	fragment@0 {
+		target = <&gmac0>;
+		__overlay__ {
+			phy-mode = "2500base-x";
+			status = "okay";
+			fixed-link {
+				speed = <2500>;
+				full-duplex;
+				pause;
+			};
+		};
+	};
+
+	fragment@1 {
+		target-path = "/soc_netsys/ethernet@15100000/mdio-bus";
+		__overlay__ {
+			phy12: phy@12 {
+				compatible = "ethernet-phy-id03a2.a411";
+				reg = <12>;
+				reset-gpios = <&pio 49 1>;
+				reset-assert-us = <10000>;
+				reset-deassert-us = <10000>;
+				phy-mode = "2500base-x";
+				full-duplex;
+				pause;
+				airoha,pnswap-rx;
+			};
+		};
+	};
+
+	fragment@2 {
+		target-path = "/";
+		__overlay__ {
+			gsw_mt753x: gsw@0 {
+				compatible = "mediatek,mt753x";
+				mediatek,ethsys = <&ethsys>;
+				#address-cells = <1>;
+				#size-cells = <0>;
+
+				mediatek,mdio = <&mdio>;
+				mediatek,portmap = "lllll";
+				mediatek,mdio_master_pinmux = <1>;
+				reset-gpios = <&pio 42 0>;
+				interrupt-parent = <&pio>;
+				interrupts = <41 IRQ_TYPE_LEVEL_HIGH>;
+				status = "okay";
+
+				port5: port@5 {
+					compatible = "mediatek,mt753x-port";
+					reg = <5>;
+					phy-mode = "2500base-x";
+
+					fixed-link {
+						speed = <2500>;
+						full-duplex;
+					};
+				};
+
+				port6: port@6 {
+					compatible = "mediatek,mt753x-port";
+					reg = <6>;
+					phy-mode = "2500base-x";
+
+					fixed-link {
+						speed = <2500>;
+						full-duplex;
+					};
+				};
+			};
+		};
+	};
+
+	fragment@3 {
+		target-path = "/soc_netsys/hnat@15000000";
+		__overlay__ {
+			mtketh-lan = "eth0";
+		};
+	};
+};
--- /dev/null
+++ b/target/linux/mediatek/dts/mt7987-netsys-eth0-mt7531.dtso
@@ -0,0 +1,91 @@
+// SPDX-License-Identifier: (GPL-2.0 OR MIT)
+
+/dts-v1/;
+/plugin/;
+
+/ {
+	fragment@0 {
+		target = <&gmac0>;
+		__overlay__ {
+			phy-mode = "2500base-x";
+			status = "okay";
+			fixed-link {
+				speed = <2500>;
+				full-duplex;
+				pause;
+			};
+		};
+	};
+
+	fragment@1 {
+		target-path = "/soc_netsys/ethernet@15100000/mdio-bus";
+		__overlay__ {
+			phy12: phy@12 {
+				compatible = "ethernet-phy-id03a2.a411";
+				reg = <12>;
+				reset-gpios = <&pio 49 1>;
+				reset-assert-us = <10000>;
+				reset-deassert-us = <10000>;
+				phy-mode = "2500base-x";
+				full-duplex;
+				pause;
+				airoha,pnswap-rx;
+				airoha,phy-handle;
+			};
+
+			switch31: switch@31 {
+				compatible = "mediatek,mt7531";
+				reg = <31>;
+				reset-gpios = <&pio 42 0>;
+				status = "okay";
+
+				ports {
+					#address-cells = <1>;
+					#size-cells = <0>;
+
+					port@0 {
+						reg = <0>;
+						label = "lan0";
+					};
+
+					port@1 {
+						reg = <1>;
+						label = "lan1";
+					};
+
+					port@2 {
+						reg = <2>;
+						label = "lan2";
+					};
+
+					port@3 {
+						reg = <3>;
+						label = "lan3";
+					};
+
+					port@5 {
+						reg = <5>;
+						label = "lan5";
+						phy-mode = "2500base-x";
+						phy-handle = <&phy12>;
+					};
+
+					port@6 {
+						reg = <6>;
+						label = "cpu";
+						ethernet = <&gmac0>;
+						phy-mode = "2500base-x";
+
+						fixed-link {
+							speed = <2500>;
+							full-duplex;
+							pause;
+						};
+					};
+				};
+
+			};
+		};
+	};
+};
+
--- /dev/null
+++ b/target/linux/mediatek/dts/mt7987-netsys-eth1-i2p5g.dtso
@@ -0,0 +1,30 @@
+// SPDX-License-Identifier: (GPL-2.0 OR MIT)
+
+/dts-v1/;
+/plugin/;
+
+/ {
+	fragment@0 {
+		target = <&gmac1>;
+		__overlay__ {
+			phy-mode = "internal";
+			phy-handle = <&phy15>;
+			status = "okay";
+		};
+	};
+
+	fragment@1 {
+		target-path = "/soc_netsys/ethernet@15100000/mdio-bus";
+		__overlay__ {
+			/* built-in 2.5G Ethernet PHY */
+			phy15: phy@15 {
+				pinctrl-names = "i2p5gbe-led";
+				pinctrl-0 = <&i2p5gbe_led0_pins>;
+				compatible = "ethernet-phy-ieee802.3-c45";
+				reg = <15>;
+				phy-mode = "internal";
+			};
+		};
+	};
+};
+
--- /dev/null
+++ b/target/linux/mediatek/dts/mt7987-netsys-eth2-an8801sb.dtso
@@ -0,0 +1,41 @@
+// SPDX-License-Identifier: (GPL-2.0 OR MIT)
+
+/dts-v1/;
+/plugin/;
+
+/ {
+	fragment@0 {
+		target = <&gmac2>;
+		__overlay__ {
+			phy-mode = "sgmii";
+			phy-handle = <&phy31>;
+			status = "okay";
+		};
+	};
+
+	fragment@1 {
+		target-path = "/soc_netsys/hnat@15000000";
+		__overlay__ {
+			mtketh-lan2 = "eth2";
+			mtketh-max-gmac = <3>;
+		};
+	};
+
+	fragment@2 {
+		target-path = "/soc_netsys/ethernet@15100000/mdio-bus";
+		__overlay__ {
+			phy31: phy@31 {
+				compatible = "ethernet-phy-idc0ff.0421";
+				reg = <31>;
+				reset-gpios = <&pio 48 1>;
+				reset-assert-us = <10000>;
+				reset-deassert-us = <10000>;
+				phy-mode = "sgmii";
+				airoha,sgmii-mode = <1>;
+				eee-broken-100tx;
+				eee-broken-1000t;
+			};
+		};
+	};
+};
+
--- /dev/null
+++ b/target/linux/mediatek/dts/mt7987-netsys-eth2-e2p5g.dtso
@@ -0,0 +1,39 @@
+// SPDX-License-Identifier: (GPL-2.0 OR MIT)
+
+/dts-v1/;
+/plugin/;
+
+/ {
+	fragment@0 {
+		target = <&gmac2>;
+		__overlay__ {
+			phy-mode = "2500base-x";
+			phy-handle = <&phy11>;
+			status = "okay";
+		};
+	};
+
+	fragment@1 {
+		target-path = "/soc_netsys/hnat@15000000";
+		__overlay__ {
+			mtketh-lan2 = "eth2";
+			mtketh-max-gmac = <3>;
+		};
+	};
+
+	fragment@2 {
+		target-path = "/soc_netsys/ethernet@15100000/mdio-bus";
+		__overlay__ {
+			reset-gpios = <&pio 48 1>;
+			reset-delay-us = <10000>;
+
+			phy11: phy@11 {
+				compatible = "ethernet-phy-id03a2.a411";
+				reg = <11>;
+				phy-mode = "2500base-x";
+				airoha,phy-handle;
+			};
+		};
+	};
+};
+
--- /dev/null
+++ b/target/linux/mediatek/dts/mt7987-netsys-eth2-sfp.dtso
@@ -0,0 +1,50 @@
+// SPDX-License-Identifier: (GPL-2.0 OR MIT)
+
+/dts-v1/;
+/plugin/;
+
+#include <dt-bindings/gpio/gpio.h>
+
+/ {
+	fragment@0 {
+		target-path = "/";
+		__overlay__ {
+			sfp_cage0: sfp@0 {
+				compatible = "sff,sfp";
+				i2c-bus = <&i2c0>;
+				mod-def0-gpios = <&pio 49 GPIO_ACTIVE_LOW>;
+				los-gpios = <&pio 46 GPIO_ACTIVE_HIGH>;
+				tx-disable-gpios = <&pio 48 GPIO_ACTIVE_HIGH>;
+				maximum-power-milliwatt = <3000>;
+			};
+		};
+	};
+
+	fragment@1 {
+		target = <&gmac2>;
+		__overlay__ {
+			phy-mode = "2500base-x";
+			managed = "in-band-status";
+			sfp = <&sfp_cage0>;
+			status = "okay";
+		};
+	};
+
+	fragment@2 {
+		target-path = "/soc_netsys/hnat@15000000";
+		__overlay__ {
+			mtketh-lan2 = "eth2";
+			mtketh-max-gmac = <3>;
+		};
+	};
+
+	fragment@3 {
+		target-path = "/soc/i2c@11003000";
+		__overlay__ {
+			pinctrl-names = "default";
+			pinctrl-0 = <&i2c0_pins>;
+			status = "okay";
+		};
+	};
+};
+
--- /dev/null
+++ b/target/linux/mediatek/dts/mt7987-netsys-eth2-usb.dtso
@@ -0,0 +1,25 @@
+// SPDX-License-Identifier: (GPL-2.0 OR MIT)
+
+/dts-v1/;
+/plugin/;
+
+#include <dt-bindings/phy/phy.h>
+
+/ {
+	fragment@0 {
+		target-path = "/soc/usb-phy@11c50000/usb-phy@11c50700";
+		__overlay__ {
+			status = "okay";
+		};
+	};
+
+	fragment@1 {
+		target-path = "/soc/usb@11200000";
+		__overlay__ {
+			phys = <&tphyu2port0 PHY_TYPE_USB2>,
+			       <&tphyu3port0 PHY_TYPE_USB3>;
+			mediatek,u3p-dis-msk=<0>;
+		};
+	};
+};
+
--- /dev/null
+++ b/target/linux/mediatek/dts/mt7987-sd.dtso
@@ -0,0 +1,74 @@
+// SPDX-License-Identifier: (GPL-2.0 OR MIT)
+
+/dts-v1/;
+/plugin/;
+
+/ {
+	fragment@0 {
+		target-path = "/";
+		__overlay__ {
+			reg_3p3v: regulator-3p3v {
+				compatible = "regulator-fixed";
+				regulator-name = "fixed-3.3V";
+				regulator-min-microvolt = <3300000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+		};
+	};
+
+	fragment@1 {
+		target-path = "/soc/spi@11007800";
+		__overlay__ {
+			status = "disabled";
+		};
+	};
+
+	fragment@2 {
+		target-path = "/soc/mmc@11230000";
+		__overlay__ {
+			pinctrl-names = "default", "state_uhs";
+			pinctrl-0 = <&sd_pins_default>;
+			pinctrl-1 = <&sd_pins_uhs>;
+			bus-width = <4>;
+			max-frequency = <48000000>;
+			cap-sd-highspeed;
+			vmmc-supply = <&reg_3p3v>;
+			vqmmc-supply = <&reg_3p3v>;
+			no-mmc;
+			no-sdio;
+			status = "okay";
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			card@0 {
+				compatible = "mmc-card";
+				reg = <0>;
+
+				block {
+					compatible = "block-device";
+					partitions {
+						block-partition-env {
+							partname = "ubootenv";
+							nvmem-layout {
+								compatible = "u-boot,env";
+							};
+						};
+						sd_rootfs: block-partition-production {
+							partname = "production";
+						};
+					};
+				};
+			};
+		};
+	};
+
+        fragment@3 {
+		target-path = "/chosen";
+		__overlay__ {
+			rootdisk-sd = <&sd_rootfs>;
+		};
+	};
+};
+
--- /dev/null
+++ b/target/linux/mediatek/dts/mt7987-spidev.dtso
@@ -0,0 +1,28 @@
+// SPDX-License-Identifier: (GPL-2.0 OR MIT)
+/*
+ * Copyright (C) 2025 MediaTek Inc.
+ * Author: Tim.Kuo <Tim.Kuo@mediatek.com>
+ */
+
+/dts-v1/;
+/plugin/;
+
+/ {
+	fragment@1 {
+		target = <&spi1>;
+		__overlay__ {
+			pinctrl-names = "default";
+			pinctrl-0 = <&spic_pins>;
+			status = "okay";
+
+			spi_dev1: spi@0 {
+				compatible = "rohm,dh2228fv";
+				reg = <0>;
+				spi-max-frequency = <52000000>;
+				spi-cs-setup-delay-ns = <90>;
+				spi-cs-hold-delay-ns = <90>;
+				spi-cs-inactive-delay-ns = <90>;
+			};
+		};
+	};
+};
--- /dev/null
+++ b/target/linux/mediatek/dts/mt7987-spim-nand.dtso
@@ -0,0 +1,130 @@
+// SPDX-License-Identifier: (GPL-2.0 OR MIT)
+
+/dts-v1/;
+/plugin/;
+
+/ {
+	fragment@0 {
+		target-path = "/soc/spi@11007800";
+		__overlay__ {
+			pinctrl-names = "default";
+			pinctrl-0 = <&spi0_flash_pins>;
+			status = "okay";
+
+			flash@0 {
+				compatible = "spi-nand";
+				reg = <0>;
+				spi-max-frequency = <52000000>;
+				spi-tx-bus-width = <4>;
+				spi-rx-bus-width = <4>;
+				mediatek,nmbm;
+				mediatek,bmt-max-ratio = <1>;
+				mediatek,bmt-max-reserved-blocks = <64>;
+
+				partitions {
+					compatible = "fixed-partitions";
+					#address-cells = <1>;
+					#size-cells = <1>;
+
+					partition@0 {
+						label = "BL2";
+						reg = <0x00000 0x0100000>;
+						read-only;
+					};
+
+					partition@100000 {
+						label = "u-boot-env";
+						reg = <0x0100000 0x0080000>;
+					};
+
+					factory: partition@180000 {
+						label = "Factory";
+						reg = <0x180000 0x0400000>;
+
+						nvmem-layout {
+							compatible = "fixed-layout";
+							#address-cells = <1>;
+							#size-cells = <1>;
+
+							gmac2_mac: eeprom@fffee {
+								reg = <0xfffee 0x6>;
+							};
+
+							gmac1_mac: eeprom@ffffa {
+								reg = <0xffffa 0x6>;
+							};
+
+							gmac0_mac: eeprom@ffff4 {
+								reg = <0xffff4 0x6>;
+							};
+						};
+					};
+
+					partition@580000 {
+						label = "FIP";
+						reg = <0x580000 0x0200000>;
+					};
+
+					partition@780000 {
+						label = "ubi";
+						reg = <0x780000 0x7080000>;
+						compatible = "linux,ubi";
+
+						volumes {
+							ubi_rootfs: ubi-volume-fit {
+								volname = "firmware";
+							};
+						};
+					};
+				};
+			};
+		};
+	};
+
+	fragment@1 {
+		target-path = "/chosen";
+		__overlay__ {
+			rootdisk-spim-nand = <&ubi_rootfs>;
+		};
+	};
+
+	fragment@2 {
+		target = <&pcie0>;
+		__overlay__ {
+			slot0: pcie@0,0 {
+				reg = <0x0000 0 0 0 0>;
+
+				mt7996@0,0 {
+					compatible = "mediatek,mt76";
+					reg = <0x0000 0 0 0 0>;
+					device_type = "pci";
+					mediatek,mtd-eeprom = <&factory 0x0>;
+				};
+			};
+		};
+	};
+
+	fragment@3 {
+		target = <&gmac0>;
+		__overlay__ {
+			nvmem-cell-names = "mac-address";
+			nvmem-cells = <&gmac0_mac>;
+		};
+	};
+
+	fragment@4 {
+		target = <&gmac1>;
+		__overlay__ {
+			nvmem-cell-names = "mac-address";
+			nvmem-cells = <&gmac1_mac>;
+		};
+	};
+
+	fragment@5 {
+		target = <&gmac2>;
+		__overlay__ {
+			nvmem-cell-names = "mac-address";
+			nvmem-cells = <&gmac2_mac>;
+		};
+	};
+};
--- /dev/null
+++ b/target/linux/mediatek/dts/mt7987-spim-nor.dtso
@@ -0,0 +1,61 @@
+// SPDX-License-Identifier: (GPL-2.0 OR MIT)
+
+/dts-v1/;
+/plugin/;
+
+/ {
+	fragment@0 {
+		target-path = "/soc/spi@11009800";
+		__overlay__ {
+			pinctrl-names = "default";
+			pinctrl-0 = <&spi2_flash_pins>;
+			status = "okay";
+
+			flash@0 {
+				#address-cells = <1>;
+				#size-cells = <1>;
+				compatible = "jedec,spi-nor";
+				spi-cal-enable;
+				spi-cal-mode = "read-data";
+				spi-cal-datalen = <7>;
+				spi-cal-data = /bits/ 8 <
+					0x53 0x46 0x5F 0x42 0x4F 0x4F 0x54>;
+				spi-cal-addrlen = <1>;
+				spi-cal-addr = /bits/ 32 <0x0>;
+				reg = <0>;
+				spi-max-frequency = <52000000>;
+				spi-tx-bus-width = <4>;
+				spi-rx-bus-width = <4>;
+
+				partition@00000 {
+					label = "BL2";
+					reg = <0x00000 0x0040000>;
+				};
+				partition@40000 {
+					label = "u-boot-env";
+					reg = <0x40000 0x0010000>;
+				};
+				partition@50000 {
+					label = "Factory";
+					reg = <0x50000 0x0200000>;
+				};
+				partition@250000 {
+					label = "FIP";
+					reg = <0x250000 0x0080000>;
+				};
+				nor_rootdisk: partition@2D0000 {
+					label = "firmware";
+					reg = <0x2D0000 0x1D30000>;
+				};
+			};
+		};
+	};
+
+	fragment@1 {
+		target-path = "/chosen";
+		__overlay__ {
+			rootdisk-nor = <&nor_rootdisk>;
+		};
+	};
+};
+
--- /dev/null
+++ b/target/linux/mediatek/dts/mt7987.dtsi
@@ -0,0 +1,1153 @@
+// SPDX-License-Identifier: (GPL-2.0 OR MIT)
+/*
+ * Copyright (C) 2023 MediaTek Inc.
+ * Author: Sam.Shih <sam.shih@mediatek.com>
+ */
+
+#include <dt-bindings/interrupt-controller/irq.h>
+#include <dt-bindings/interrupt-controller/arm-gic.h>
+#include <dt-bindings/phy/phy.h>
+#include <dt-bindings/reset/ti-syscon.h>
+#include <dt-bindings/clock/mediatek,mt7987-clk.h>
+#include <dt-bindings/pinctrl/mt65xx.h>
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/thermal/thermal.h>
+#include <dt-bindings/reset/mediatek,mt7987-resets.h>
+#include <dt-bindings/regulator/richtek,rt5190a-regulator.h>
+
+/* TOPRGU resets */
+#define MT7987_TOPRGU_SGMII0_GRST		1
+#define MT7987_TOPRGU_SGMII1_GRST		2
+
+/ {
+	compatible = "mediatek,mt7987";
+	interrupt-parent = <&gic>;
+	#address-cells = <2>;
+	#size-cells = <2>;
+
+	clkxtal: oscillator@0 {
+		compatible = "fixed-clock";
+		#clock-cells = <0>;
+		clock-frequency = <40000000>;
+		clock-output-names = "clkxtal";
+	};
+
+	vproc: regulator-vproc {
+		compatible = "regulator-fixed";
+		regulator-name = "proc";
+		regulator-min-microvolt = <8500000>;
+		regulator-max-microvolt = <8500000>;
+		regulator-boot-on;
+		regulator-always-on;
+	};
+
+	firmware {
+		optee {
+			method = "smc";
+			compatible = "linaro,optee-tz";
+			status = "okay";
+		};
+	};
+
+	cpus {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		cpu0: cpu@0 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a53";
+			enable-method = "psci";
+			next-level-cache = <&l2_cache>;
+			reg = <0x0>;
+			clocks = <&mcusys CLK_MCU_BUS_DIV_SEL>,
+				 <&topckgen CLK_TOP_CB_CKSQ_40M>,
+				 <&apmixedsys CLK_APMIXED_ARM_LL>;
+			clock-names = "cpu", "intermediate", "armpll";
+			operating-points-v2 = <&cluster0_opp>;
+			#cooling-cells = <2>;
+		};
+
+		cpu1: cpu@1 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a53";
+			enable-method = "psci";
+			next-level-cache = <&l2_cache>;
+			reg = <0x1>;
+			clocks = <&mcusys CLK_MCU_BUS_DIV_SEL>,
+				 <&topckgen CLK_TOP_CB_CKSQ_40M>,
+				 <&apmixedsys CLK_APMIXED_ARM_LL>;
+			clock-names = "cpu", "intermediate", "armpll";
+			operating-points-v2 = <&cluster0_opp>;
+			#cooling-cells = <2>;
+		};
+
+		cpu2: cpu@2 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a53";
+			enable-method = "psci";
+			next-level-cache = <&l2_cache>;
+			reg = <0x2>;
+			clocks = <&mcusys CLK_MCU_BUS_DIV_SEL>,
+				 <&topckgen CLK_TOP_CB_CKSQ_40M>,
+				 <&apmixedsys CLK_APMIXED_ARM_LL>;
+			clock-names = "cpu", "intermediate", "armpll";
+			operating-points-v2 = <&cluster0_opp>;
+			#cooling-cells = <2>;
+		};
+
+		cpu3: cpu@3 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a53";
+			enable-method = "psci";
+			next-level-cache = <&l2_cache>;
+			reg = <0x3>;
+			clocks = <&mcusys CLK_MCU_BUS_DIV_SEL>,
+				 <&topckgen CLK_TOP_CB_CKSQ_40M>,
+				 <&apmixedsys CLK_APMIXED_ARM_LL>;
+			clock-names = "cpu", "intermediate", "armpll";
+			operating-points-v2 = <&cluster0_opp>;
+			#cooling-cells = <2>;
+		};
+
+		cluster0_opp: opp_table0 {
+			compatible = "operating-points-v2";
+			opp-shared;
+			opp00 {
+				opp-hz = /bits/ 64 <500000000>;
+				opp-microvolt = <850000>;
+			};
+			opp01 {
+				opp-hz = /bits/ 64 <1300000000>;
+				opp-microvolt = <850000>;
+			};
+			opp02 {
+				opp-hz = /bits/ 64 <1600000000>;
+				opp-microvolt = <850000>;
+			};
+			opp03 {
+				opp-hz = /bits/ 64 <2000000000>;
+				opp-microvolt = <850000>;
+			};
+		};
+
+		l2_cache: l2-cache {
+			compatible = "cache";
+			cache-level = <2>;
+		};
+	};
+
+	clk40m: clk40m {
+		compatible = "fixed-clock";
+		#clock-cells = <0>;
+		clock-frequency = <40000000>;
+	};
+
+	clkitg: clkitg {
+		compatible = "simple-bus";
+		status = "disabled";
+	};
+
+	clksys: soc_clksys {
+		#address-cells = <2>;
+		#size-cells = <2>;
+		compatible = "simple-bus";
+		ranges;
+
+		infracfg: infracfg@10001000 {
+			compatible = "mediatek,mt7987-infracfg", "syscon";
+			reg = <0 0x10001000 0 0x1000>;
+			#clock-cells = <1>;
+			#reset-cells = <1>;
+		};
+
+		topckgen: topckgen@1001b000 {
+			compatible = "mediatek,mt7987-topckgen", "syscon";
+			reg = <0 0x1001b000 0 0x1000>;
+			#clock-cells = <1>;
+		};
+
+		apmixedsys: apmixedsys@1001e000 {
+			compatible = "mediatek,mt7987-apmixedsys", "syscon";
+			reg = <0 0x1001e000 0 0x1000>;
+			#clock-cells = <1>;
+		};
+
+		sgmiisys0: syscon@10060000 {
+			compatible = "mediatek,mt7987-sgmiisys",
+				     "mediatek,mt7987-sgmiisys0",
+				     "syscon",
+				     "simple-mfd";
+			reg = <0 0x10060000 0 0x1000>;
+			resets = <&watchdog MT7987_TOPRGU_SGMII0_GRST>;
+			mediatek,phya_trx_ck;
+			#clock-cells = <1>;
+
+			sgmiipcs0: pcs {
+				compatible = "mediatek,mt7987-sgmii";
+				clocks = <&topckgen CLK_TOP_SGM_0_SEL>,
+					 <&sgmiisys0 CLK_SGM0_TX_EN>,
+					 <&sgmiisys0 CLK_SGM0_RX_EN>;
+				clock-names = "sgmii_sel", "sgmii_tx", "sgmii_rx";
+			};
+		};
+
+		sgmiisys1: syscon@10070000 {
+			compatible = "mediatek,mt7987-sgmiisys",
+				     "mediatek,mt7987-sgmiisys1",
+				     "syscon",
+				     "simple-mfd";
+			reg = <0 0x10070000 0 0x1000>;
+			resets = <&watchdog MT7987_TOPRGU_SGMII1_GRST>;
+			mediatek,phya_trx_ck;
+			#clock-cells = <1>;
+
+			sgmiipcs1: pcs {
+				compatible = "mediatek,mt7987-sgmii";
+				clocks = <&topckgen CLK_TOP_SGM_1_SEL>,
+					 <&sgmiisys1 CLK_SGM1_TX_EN>,
+					 <&sgmiisys1 CLK_SGM1_RX_EN>;
+				clock-names = "sgmii_sel", "sgmii_tx", "sgmii_rx";
+			};
+		};
+
+		mcusys: mcusys@10400000 {
+			compatible = "mediatek,mt7987-mcusys", "syscon";
+			reg = <0 0x10400000 0 0x1000>;
+			#clock-cells = <1>;
+		};
+
+		ethsys: syscon@15000000 {
+			#address-cells = <1>;
+			#size-cells = <1>;
+			compatible = "mediatek,mt7987-ethdma",
+				     "mediatek,mt7987-ethsys",
+				     "syscon";
+			reg = <0 0x15000000 0 0x1000>;
+			#clock-cells = <1>;
+			#reset-cells = <1>;
+			ethsysrst: reset-controller {
+				compatible = "ti,syscon-reset";
+				#reset-cells = <1>;
+				ti,reset-bits =
+					<0x34 4 0x34 4 0x34 4
+					(ASSERT_SET | DEASSERT_CLEAR |
+					 STATUS_SET)>;
+			};
+		};
+	};
+
+	fan: pwm-fan {
+		compatible = "pwm-fan";
+		cooling-levels = <0 128 255>;
+		#cooling-cells = <2>;
+		#thermal-sensor-cells = <1>;
+		status = "disabled";
+	};
+
+	pmu: pmu {
+		compatible = "arm,cortex-a53-pmu";
+		interrupt-parent = <&gic>;
+		interrupts = <GIC_PPI 7 IRQ_TYPE_LEVEL_LOW>;
+	};
+
+	psci {
+		compatible  = "arm,psci-0.2";
+		method      = "smc";
+	};
+
+	reserved-memory {
+		#address-cells = <2>;
+		#size-cells = <2>;
+		ranges;
+
+		wmcpu_emi: wmcpu-reserved@50000000 {
+			compatible = "mediatek,wmcpu-reserved";
+			no-map;
+			reg = <0 0x50000000 0 0x00100000>;
+		};
+	};
+
+	thermal-zones {
+		cpu_thermal: cpu-thermal {
+			polling-delay-passive = <1000>;
+			polling-delay = <1000>;
+			thermal-sensors = <&lvts 0>;
+
+			trips {
+				cpu_trip_crit: crit {
+					temperature = <125000>;
+					hysteresis = <2000>;
+					type = "critical";
+				};
+
+				cpu_trip_hot: hot {
+					temperature = <120000>;
+					hysteresis = <2000>;
+					type = "hot";
+				};
+
+				cpu_trip_active_hot: active-hot {
+					temperature = <117000>;
+					hysteresis = <2000>;
+					type = "active";
+				};
+
+				cpu_trip_active_high: active-high {
+					temperature = <115000>;
+					hysteresis = <2000>;
+					type = "active";
+				};
+
+				cpu_trip_active_med: active-med {
+					temperature = <85000>;
+					hysteresis = <2000>;
+					type = "active";
+				};
+
+				cpu_trip_active_low: active-low {
+					temperature = <40000>;
+					hysteresis = <2000>;
+					type = "active";
+				};
+			};
+
+			cooling-maps {
+				cpu-active-hot {
+				/* active: dynamic cpu frequency scaling */
+					cooling-device = <&cpu0 THERMAL_NO_LIMIT THERMAL_NO_LIMIT>,
+							 <&cpu1 THERMAL_NO_LIMIT THERMAL_NO_LIMIT>,
+							 <&cpu2 THERMAL_NO_LIMIT THERMAL_NO_LIMIT>,
+							 <&cpu3 THERMAL_NO_LIMIT THERMAL_NO_LIMIT>;
+					trip = <&cpu_trip_active_hot>;
+				};
+
+				cpu-active-high {
+				/* active: set fan to cooling level 2 */
+					cooling-device = <&fan 3 3>;
+					trip = <&cpu_trip_active_high>;
+				};
+
+				cpu-active-low {
+				/* active: set fan to cooling level 1 */
+					cooling-device = <&fan 2 2>;
+					trip = <&cpu_trip_active_med>;
+				};
+
+				cpu-passive {
+				/* passive: set fan to cooling level 0 */
+					cooling-device = <&fan 1 1>;
+					trip = <&cpu_trip_active_low>;
+				};
+			};
+		};
+	};
+
+	timer {
+		compatible = "arm,armv8-timer";
+		interrupt-parent = <&gic>;
+		interrupts = <GIC_PPI 13 IRQ_TYPE_LEVEL_LOW>,
+			     <GIC_PPI 14 IRQ_TYPE_LEVEL_LOW>,
+			     <GIC_PPI 11 IRQ_TYPE_LEVEL_LOW>,
+			     <GIC_PPI 10 IRQ_TYPE_LEVEL_LOW>;
+	};
+
+	soc: soc {
+		#address-cells = <2>;
+		#size-cells = <2>;
+		compatible = "simple-bus";
+		ranges;
+
+		hwver: hwver@8000000 {
+			compatible = "mediatek,hwver", "syscon";
+			reg = <0 0x8000000 0 0x1000>;
+		};
+
+		gic: interrupt-controller@c000000 {
+			compatible = "arm,gic-v3";
+			#interrupt-cells = <3>;
+			interrupt-parent = <&gic>;
+			interrupt-controller;
+			reg = <0 0x0c000000 0 0x40000>,  /* GICD */
+			      <0 0x0c080000 0 0x200000>, /* GICR */
+			      <0 0x0c400000 0 0x2000>,   /* GICC */
+			      <0 0x0c410000 0 0x1000>,   /* GICH */
+			      <0 0x0c420000 0 0x2000>;   /* GICV */
+			interrupts = <GIC_PPI 9 IRQ_TYPE_LEVEL_HIGH>;
+		};
+
+		infra_bus_prot: infra_bus_prot@1000310c {
+			compatible = "mediatek,infracfg_ao_bus_hang_prot";
+			reg = <0 0x1000310c 0 0x14>;
+			status = "disabled";
+		};
+
+		watchdog: watchdog@1001c000 {
+			compatible = "mediatek,mt7987-wdt",
+				     "mediatek,mt7988-wdt",
+				     "mediatek,mt6589-wdt",
+				     "syscon";
+			reg = <0 0x1001c000 0 0x1000>;
+			interrupts = <GIC_SPI 74 IRQ_TYPE_LEVEL_HIGH>;
+			#reset-cells = <1>;
+		};
+
+		pio: pinctrl@1001f000 {
+			compatible = "mediatek,mt7987-pinctrl";
+			reg = <0 0x1001f000 0 0x1000>,
+			      <0 0x11d00000 0 0x1000>,
+			      <0 0x11e00000 0 0x1000>,
+			      <0 0x11f00000 0 0x1000>,
+			      <0 0x11f40000 0 0x1000>,
+			      <0 0x11f60000 0 0x1000>,
+			      <0 0x1000b000 0 0x1000>;
+			reg-names = "gpio", "iocfg_rb", "iocfg_lb", "iocfg_rt1",
+				    "iocfg_rt2", "iocfg_tl", "eint";
+			gpio-controller;
+			#gpio-cells = <2>;
+			gpio-ranges = <&pio 0 0 50>;
+			interrupt-controller;
+			interrupts = <GIC_SPI 225 IRQ_TYPE_LEVEL_HIGH>;
+			interrupt-parent = <&gic>;
+			#interrupt-cells = <2>;
+
+			mmc_pins_default: mmc-pins-default {
+				mux {
+					function = "flash";
+					groups = "emmc_45";
+				};
+				conf-cmd-dat {
+					pins = "SPI0_CLK", "SPI0_MOSI", "SPI0_MISO",
+					       "SPI0_CS", "SPI0_HOLD", "SPI0_WP",
+					       "SPI1_CLK", "SPI1_MOSI", "SPI1_MISO";
+					input-enable;
+					drive-strength = <MTK_DRIVE_4mA>;
+					mediatek,pull-up-adv = <1>;	/* pull-up 10K */
+				};
+				conf-clk {
+					pins = "SPI1_CS";
+					drive-strength = <MTK_DRIVE_6mA>;
+					mediatek,pull-down-adv = <2>;	/* pull-down 50K */
+				};
+				conf-rst {
+					pins = "USB_VBUS";
+					drive-strength = <MTK_DRIVE_4mA>;
+					mediatek,pull-up-adv = <1>;	/* pull-up 10K */
+				};
+			};
+
+			mmc_pins_uhs: mmc-pins-uhs {
+				mux {
+					function = "flash";
+					groups = "emmc_45";
+				};
+				conf-cmd-dat {
+					pins = "SPI0_CLK", "SPI0_MOSI", "SPI0_MISO",
+					       "SPI0_CS", "SPI0_HOLD", "SPI0_WP",
+					       "SPI1_CLK", "SPI1_MOSI", "SPI1_MISO";
+					input-enable;
+					drive-strength = <MTK_DRIVE_4mA>;
+					mediatek,pull-up-adv = <1>;	/* pull-up 10K */
+				};
+				conf-clk {
+					pins = "SPI1_CS";
+					drive-strength = <MTK_DRIVE_6mA>;
+					mediatek,pull-down-adv = <2>;	/* pull-down 50K */
+				};
+				conf-rst {
+					pins = "USB_VBUS";
+					drive-strength = <MTK_DRIVE_4mA>;
+					mediatek,pull-up-adv = <1>;	/* pull-up 10K */
+				};
+			};
+
+			sd_pins_default: sd-pins-default {
+				mux {
+					function = "flash";
+					groups = "sd";
+				};
+				conf-cmd-dat {
+					pins = "SPI0_CLK", "SPI0_MOSI", "SPI0_MISO",
+					       "SPI0_CS", "SPI1_MISO";
+					input-enable;
+					drive-strength = <MTK_DRIVE_4mA>;
+					mediatek,pull-up-adv = <1>;	/* pull-up 10K */
+				};
+				conf-clk {
+					pins = "SPI1_CS";
+					drive-strength = <MTK_DRIVE_6mA>;
+					mediatek,pull-down-adv = <2>;	/* pull-down 50K */
+				};
+			};
+
+			sd_pins_uhs: sd-pins-uhs {
+				mux {
+					function = "flash";
+					groups = "sd";
+				};
+				conf-cmd-dat {
+					pins = "SPI0_CLK", "SPI0_MOSI", "SPI0_MISO",
+					       "SPI0_CS", "SPI1_MISO";
+					input-enable;
+					drive-strength = <MTK_DRIVE_4mA>;
+					mediatek,pull-up-adv = <1>;	/* pull-up 10K */
+				};
+				conf-clk {
+					pins = "SPI1_CS";
+					drive-strength = <MTK_DRIVE_6mA>;
+					mediatek,pull-down-adv = <2>;	/* pull-down 50K */
+				};
+			};
+
+			mdio0_pins: mdio0-pins {
+				mux {
+					function = "eth";
+					groups = "mdc_mdio";
+				};
+
+				conf {
+					groups = "mdc_mdio";
+					drive-strength = <MTK_DRIVE_6mA>;
+				};
+			};
+
+			i2p5gbe_led0_pins: i2p5gbe0-pins {
+				mux {
+					function = "led";
+					groups = "2p5gbe_led0";
+				};
+			};
+
+			i2p5gbe_led1_0_pins: i2p5gbe1-pins {
+				mux {
+					function = "led";
+					groups = "2p5gbe_led1_0";
+				};
+			};
+
+			i2p5gbe_led1_1_pins: i2p5gbe2-pins {
+				mux {
+					function = "led";
+					groups = "2p5gbe_led1_1";
+				};
+			};
+
+			i2c0_pins: i2c0-pins-g2 {
+				mux {
+					function = "i2c";
+					groups = "i2c0_2";
+				};
+			};
+
+			pcie0_pins: pcie0-pins {
+				mux {
+					function = "pcie";
+					groups = "pcie0_pereset", "pcie0_clkreq",
+						 "pcie0_wake";
+				};
+			};
+
+			pcie1_pins: pcie1-pins {
+				mux {
+					function = "pcie";
+					groups = "pcie1_pereset", "pcie1_clkreq",
+						 "pcie1_wake";
+				};
+			};
+
+			spi0_flash_pins: spi0-pins {
+				mux {
+					function = "spi";
+					groups = "spi0", "spi0_wp_hold";
+				};
+
+				conf-pu {
+					pins = "SPI0_CS", "SPI0_HOLD", "SPI0_WP";
+					drive-strength = <MTK_DRIVE_4mA>;
+					bias-pull-up = <MTK_PUPD_SET_R1R0_11>;
+				};
+
+				conf-pd {
+					pins = "SPI0_CLK", "SPI0_MOSI", "SPI0_MISO";
+					drive-strength = <MTK_DRIVE_4mA>;
+					bias-pull-down = <MTK_PUPD_SET_R1R0_11>;
+				};
+			};
+
+			spic_pins: spi1-pins {
+				mux {
+					function = "spi";
+					groups = "spi1";
+				};
+			};
+
+			spi2_flash_pins: spi2-pins {
+				mux {
+					function = "spi";
+					groups = "spi2", "spi2_wp_hold";
+				};
+			};
+
+			i2c1_pins: i2c1-pins {
+				mux {
+					function = "i2c";
+					groups = "i2c0_2";
+				};
+			};
+
+			i2s_pins: i2s-pins {
+				mux {
+					function = "i2s";
+					groups = "pcm0_1";
+				};
+			};
+
+			pcm_pins: pcm-pins {
+				mux {
+					function = "pcm";
+					groups = "pcm0_1";
+				};
+			};
+
+			pwm_pins: pwm-pins {
+				mux {
+					/*
+					 * - pwm0   : PWM0@PIN13
+					 * - pwm1_0 : PWM1@PIN7  (share with JTAG)
+					 *   pwm1_1 : PWM1@PIN43 (share with i2c0)
+					 * - pwm2_0 : PWM2@PIN12 (share with PCM)
+					 *   pwm2_1 : PWM2@PIN44 (share with i2c0)
+					 */
+					function = "pwm";
+					groups = "pwm0";
+				};
+			};
+
+			pwm_rgb_pins: pwm-rgb-pins {
+				mux {
+					/*
+					* - pwm0 1  : PWM0@PIN13
+					* - pwm1_0 :; PWM@PIN7  (share with JTAG)
+					*   pwm1_1 : PWM1@PIN43 (share with i2c0)
+					* - pwm2_0 : PWM2@PIN12 (share with PCM)
+					*   pwm2_1 : PWM2@PIN44 (share with i2c0)
+					*/
+					function = "pwm";
+					groups = "pwm0", "pwm1_0", "pwm2_0";
+				};
+			};
+
+			uart0_pins: uart0-pins {
+				mux {
+					function = "uart";
+					groups = "uart0";
+				};
+			};
+
+			uart1_pins: uart1-pins {
+				mux {
+					function = "uart";
+					groups = "uart1_2";
+				};
+			};
+		};
+
+		boottrap: boottrap@1001f6f0 {
+			compatible = "mediatek,boottrap";
+			reg = <0 0x1001f6f0 0 0x20>;
+			status = "disabled";
+		};
+
+		trng: trng@1020f000 {
+			compatible = "mediatek,mt7987-rng";
+			status = "disabled";
+		};
+
+		pwm: pwm@10048000 {
+			compatible = "mediatek,mt7987-pwm";
+			reg = <0 0x10048000 0 0x1000>;
+			#pwm-cells = <2>;
+			clocks = <&infracfg CLK_INFRA_66M_PWM_BCK>,
+				 <&infracfg CLK_INFRA_66M_PWM_HCK>,
+				 <&infracfg CLK_INFRA_66M_PWM_HCK>,
+				 <&infracfg CLK_INFRA_66M_PWM_HCK>,
+				 <&infracfg CLK_INFRA_66M_PWM_HCK>;
+			clock-names = "top", "main", "pwm1", "pwm2", "pwm3";
+			status = "disabled";
+		};
+
+		uart0: serial@11000000 {
+			compatible = "mediatek,mt7986-uart",
+				     "mediatek,mt6577-uart";
+			reg = <0 0x11000000 0 0x100>;
+			interrupts = <GIC_SPI 123 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&topckgen CLK_TOP_UART_SEL>,
+				 <&infracfg CLK_INFRA_52M_UART0_CK>;
+			clock-names = "baud", "bus";
+			status = "disabled";
+		};
+
+		uart1: serial@11000100 {
+			compatible = "mediatek,mt7986-uart",
+				     "mediatek,mt6577-uart";
+			reg = <0 0x11000100 0 0x100>;
+			interrupts = <GIC_SPI 124 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&infracfg CLK_INFRA_52M_UART1_CK>,
+				 <&infracfg CLK_INFRA_66M_UART1_PCK>;
+			clock-names = "baud", "bus";
+			assigned-clocks = <&topckgen CLK_TOP_UART_SEL>,
+					  <&infracfg CLK_INFRA_MUX_UART1_SEL>;
+			assigned-clock-parents = <&topckgen
+						  CLK_TOP_CB_CKSQ_40M>,
+						 <&topckgen CLK_TOP_UART_SEL>;
+			status = "disabled";
+		};
+
+		uart2: serial@11000200 {
+			compatible = "mediatek,mt7986-uart",
+				     "mediatek,mt6577-uart";
+			reg = <0 0x11000200 0 0x100>;
+			interrupts = <GIC_SPI 125 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&infracfg CLK_INFRA_52M_UART2_CK>,
+				 <&infracfg CLK_INFRA_66M_UART2_PCK>;
+			clock-names = "baud", "bus";
+			assigned-clocks = <&topckgen CLK_TOP_UART_SEL>,
+					  <&infracfg CLK_INFRA_MUX_UART2_SEL>;
+			assigned-clock-parents = <&topckgen
+						  CLK_TOP_CB_CKSQ_40M>,
+						 <&topckgen CLK_TOP_UART_SEL>;
+			status = "disabled";
+		};
+
+		i2c0: i2c@11003000 {
+			compatible = "mediatek,mt7988-i2c",
+				     "mediatek,mt7981-i2c";
+			reg = <0 0x11003000 0 0x1000>,
+			<0 0x10217080 0 0x80>;
+			interrupts = <GIC_SPI 136 IRQ_TYPE_LEVEL_HIGH>;
+			clock-div = <1>;
+			clocks = <&infracfg CLK_INFRA_I2C_BCK>,
+				 <&infracfg CLK_INFRA_66M_AP_DMA_BCK>;
+			clock-names = "main", "dma";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			status = "disabled";
+		};
+
+		spi0: spi@11007800 {
+			compatible = "mediatek,ipm-spi-quad",
+				     "mediatek,spi-ipm";
+			reg = <0 0x11007800 0 0x100>;
+			interrupts = <GIC_SPI 140 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&topckgen CLK_TOP_CB_M_D2>,
+				 <&topckgen CLK_TOP_SPI_SEL>,
+				 <&infracfg CLK_INFRA_104M_SPI0>,
+				 <&infracfg CLK_INFRA_66M_SPI0_HCK>;
+			assigned-clocks = <&topckgen CLK_TOP_SPI_SEL>,
+					  <&infracfg CLK_INFRA_MUX_SPI0_SEL>;
+			assigned-clock-parents = <&topckgen CLK_TOP_CB_M_D2>,
+						 <&topckgen CLK_TOP_SPI_SEL>;
+			clock-names = "parent-clk", "sel-clk", "spi-clk",
+				      "hclk";
+			status = "disabled";
+		};
+
+		spi1: spi@11008800 {
+			compatible = "mediatek,ipm-spi-single",
+				     "mediatek,spi-ipm";
+			reg = <0 0x11008800 0 0x100>;
+			interrupts = <GIC_SPI 141 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&topckgen CLK_TOP_CB_M_D2>,
+				 <&topckgen CLK_TOP_SPI_SEL>,
+				 <&infracfg CLK_INFRA_104M_SPI1>,
+				 <&infracfg CLK_INFRA_66M_SPI1_HCK>;
+			assigned-clocks = <&topckgen CLK_TOP_SPIM_MST_SEL>,
+					  <&infracfg CLK_INFRA_MUX_SPI1_SEL>;
+			assigned-clock-parents = <&topckgen CLK_TOP_CB_M_D2>,
+						 <&topckgen
+						  CLK_TOP_SPIM_MST_SEL>;
+			clock-names = "parent-clk", "sel-clk", "spi-clk",
+				      "hclk";
+			status = "disabled";
+		};
+
+		spi2: spi@11009800 {
+			compatible = "mediatek,ipm-spi-quad",
+				     "mediatek,spi-ipm";
+			reg = <0 0x11009800 0 0x100>;
+			interrupts = <GIC_SPI 142 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&topckgen CLK_TOP_CB_M_D2>,
+				<&topckgen CLK_TOP_SPI_SEL>,
+				<&infracfg CLK_INFRA_104M_SPI2_BCK>,
+				<&infracfg CLK_INFRA_66M_SPI2_HCK>;
+			assigned-clocks = <&topckgen CLK_TOP_SPI_SEL>,
+					  <&infracfg
+					   CLK_INFRA_MUX_SPI2_BCK_SEL>;
+			assigned-clock-parents = <&topckgen CLK_TOP_CB_M_D2>,
+						 <&topckgen CLK_TOP_SPI_SEL>;
+			clock-names = "parent-clk", "sel-clk", "spi-clk",
+				      "hclk";
+			status = "disabled";
+		};
+
+		lvts: lvts@1100a000 {
+			compatible = "mediatek,mt7987-lvts-ap";
+			reg = <0 0x1100a000 0 0x1000>;
+			clocks = <&infracfg CLK_INFRA_26M_THERM_SYSTEM>;
+			clock-names = "lvts_clk";
+			resets = <&infracfg MT7987_INFRA_RST1_THERM_CTRL_SWRST>;
+			nvmem-cells = <&lvts_calibration>;
+			nvmem-cell-names = "lvts-calib-data-1";
+			#thermal-sensor-cells = <1>;
+			status = "disabled";
+		};
+
+		usbtphy: usb-phy@11c50000 {
+			compatible = "mediatek,mt7987",
+				     "mediatek,generic-tphy-v2";
+			#address-cells = <2>;
+			#size-cells = <2>;
+			ranges;
+
+			tphyu2port0: usb-phy@11c50000 {
+				reg = <0 0x11c50000 0 0x700>;
+				clocks = <&infracfg CLK_INFRA_USB_UTMI_CK_P1>;
+				clock-names = "ref";
+				#phy-cells = <1>;
+				auto_load_valid;
+				nvmem-cells = <&u2_intr_p0>,
+					      <&u2_auto_load_valid_p0>;
+				nvmem-cell-names = "intr", "auto_load_valid";
+			};
+			tphyu3port0: usb-phy@11c50700 {
+				reg = <0 0x11c50700 0 0x900>;
+				clocks = <&infracfg CLK_INFRA_USB_PIPE_CK_P1>;
+				clock-names = "ref";
+				#phy-cells = <1>;
+				auto_load_valid;
+				nvmem-cells = <&comb_intr_p0>,
+					      <&comb_rx_imp_p0>,
+					      <&comb_tx_imp_p0>,
+					      <&comb_auto_load_valid>;
+				nvmem-cell-names = "intr", "rx_imp", "tx_imp",
+						   "auto_load_valid";
+				mediatek,syscon-type = <&topmisc 0x218 0>;
+				status = "disabled";
+			};
+		};
+
+		ssusb: usb@11200000 {
+			compatible = "mediatek,mt7987-xhci",
+				     "mediatek,mtk-xhci";
+			reg = <0 0x11200000 0 0x2e00>,
+			      <0 0x11203e00 0 0x0100>;
+			reg-names = "mac", "ippc";
+			interrupts = <GIC_SPI 172 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&infracfg CLK_INFRA_USB_SYS_CK_P1>,
+				 <&infracfg CLK_INFRA_USB_XHCI_CK_P1>,
+				 <&infracfg CLK_INFRA_USB_CK_P1>,
+				 <&infracfg CLK_INFRA_66M_USB_HCK_CK_P1>,
+				 <&infracfg CLK_INFRA_133M_USB_HCK_CK_P1>;
+			clock-names = "sys_ck",
+				      "xhci_ck",
+				      "ref_ck",
+				      "mcu_ck",
+				      "dma_ck";
+			#address-cells = <2>;
+			#size-cells = <2>;
+			phys = <&tphyu2port0 PHY_TYPE_USB2>;
+			usb2-lpm-disable;
+			mediatek,u3p-dis-msk=<1>;
+			status = "disabled";
+		};
+
+		afe: audio-controller@11210000 {
+			compatible = "mediatek,mt7987-afe",
+				     "mediatek,mt7986-afe";
+			reg = <0 0x11210000 0 0x9000>;
+			interrupts = <GIC_SPI 106 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&infracfg CLK_INFRA_66M_AUD_SLV_BCK>,
+				 <&infracfg CLK_INFRA_AUD_26M>,
+				 <&infracfg CLK_INFRA_AUD_L>,
+				 <&infracfg CLK_INFRA_AUD_AUD>,
+				 <&infracfg CLK_INFRA_AUD_EG2>,
+				 <&topckgen CLK_TOP_AUD_SEL>,
+				 <&topckgen CLK_TOP_AUD_I2S_M>;
+			clock-names = "aud_bus_ck",
+				      "aud_26m_ck",
+				      "aud_l_ck",
+				      "aud_aud_ck",
+				      "aud_eg2_ck",
+				      "aud_sel", /* Not used in the driver */
+				      "aud_i2s_m"; /* Not used in the driver */
+			assigned-clocks = <&topckgen CLK_TOP_AUD_SEL>,
+					  <&topckgen CLK_TOP_A1SYS_SEL>,
+					  <&topckgen CLK_TOP_AUD_L_SEL>,
+					  <&topckgen CLK_TOP_A_TUNER_SEL>;
+			assigned-clock-parents = <&apmixedsys
+						  CLK_APMIXED_APLL2>,
+						 <&topckgen
+						  CLK_TOP_CB_APLL2_D4>,
+						 <&apmixedsys
+						  CLK_APMIXED_APLL2>,
+						 <&topckgen
+						  CLK_TOP_CB_APLL2_D4>;
+			status = "disabled";
+		};
+
+		mmc0: mmc@11230000 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			compatible = "mediatek,mt7986-mmc";
+			reg = <0 0x11230000 0 0x1000>,
+				<0 0x11f50000 0 0x1000>;
+			interrupts = <GIC_SPI 143 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&topckgen CLK_TOP_EMMC_200M_SEL>,
+				 <&infracfg CLK_INFRA_MSDC400>,
+				 <&infracfg CLK_INFRA_133M_MSDC_0_HCK>,
+				 <&infracfg CLK_INFRA_MSDC2_HCK>,
+				 <&infracfg CLK_INFRA_MSDC200_SRC>,
+				 <&infracfg CLK_INFRA_66M_MSDC_0_HCK>;
+			clock-names = "source", "bus_clk", "axi_cg", "hclk",
+				      "source_cg", "ahb_cg";
+			status = "disabled";
+		};
+
+		wed0: wed@15010000 {
+			compatible = "mediatek,mt7987-wed",
+				     "syscon";
+			reg = <0 0x15010000 0 0x2000>;
+			interrupt-parent = <&gic>;
+			interrupts = <GIC_SPI 205 IRQ_TYPE_LEVEL_HIGH>;
+		};
+
+		wdma: wdma@15104800 {
+			compatible = "mediatek,wed-wdma";
+			reg = <0 0x15104800 0 0x400>;
+		};
+
+		pcie0: pcie@11280000 {
+			compatible = "mediatek,mt7987-pcie",
+				     "mediatek,mt8192-pcie";
+			device_type = "pci";
+			#address-cells = <3>;
+			#size-cells = <2>;
+			reg = <0 0x11280000 0 0x2000>;
+			reg-names = "pcie-mac";
+			linux,pci-domain = <0>;
+			interrupts = <GIC_SPI 168 IRQ_TYPE_LEVEL_HIGH>;
+			bus-range = <0x00 0xff>;
+			ranges = <0x81000000 0x00 0x20000000 0x00
+				  0x20000000 0x00 0x00200000>,
+				 <0x82000000 0x00 0x20200000 0x00
+				  0x20200000 0x00 0x0fe00000>;
+			clocks = <&infracfg CLK_INFRA_PCIE_PIPE_P0>,
+				 <&infracfg CLK_INFRA_PCIE_GFMUX_TL_P0>,
+				 <&infracfg CLK_INFRA_PCIE_PERI_26M_CK_P0>,
+				 <&infracfg CLK_INFRA_133M_PCIE_CK_P0>,
+				 <&topckgen CLK_TOP_PEXTP_TL_SEL>;
+			clock-names = "pl_250m", "tl_26m", "peri_26m",
+				      "top_133m", "pextp_clk";
+			status = "disabled";
+			#interrupt-cells = <1>;
+			interrupt-map-mask = <0 0 0 0x7>;
+			interrupt-map = <0 0 0 1 &pcie_intc2 0>,
+					<0 0 0 2 &pcie_intc2 1>,
+					<0 0 0 3 &pcie_intc2 2>,
+					<0 0 0 4 &pcie_intc2 3>;
+			pcie_intc2: interrupt-controller {
+				#address-cells = <0>;
+				#interrupt-cells = <1>;
+				interrupt-controller;
+			};
+		};
+
+		pcie1: pcie@11290000 {
+			compatible = "mediatek,mt7988-pcie",
+				     "mediatek,mt7988-pcie",
+				     "mediatek,mt7986-pcie",
+				     "mediatek,mt8192-pcie";
+			device_type = "pci";
+			#address-cells = <3>;
+			#size-cells = <2>;
+			reg = <0 0x11290000 0 0x2000>;
+			reg-names = "pcie-mac";
+			linux,pci-domain = <1>;
+			interrupts = <GIC_SPI 169 IRQ_TYPE_LEVEL_HIGH>;
+			bus-range = <0x00 0xff>;
+			ranges = <0x81000000 0x00 0x30000000 0x00
+				  0x30000000 0x00 0x00200000>,
+				 <0x82000000 0x00 0x30200000 0x00
+				  0x30200000 0x00 0x0fe00000>;
+			clocks = <&infracfg CLK_INFRA_PCIE_PIPE_P1>,
+				 <&infracfg CLK_INFRA_PCIE_GFMUX_TL_P1>,
+				 <&infracfg CLK_INFRA_PCIE_PERI_26M_CK_P1>,
+				 <&infracfg CLK_INFRA_133M_PCIE_CK_P1>,
+				 <&topckgen CLK_TOP_PEXTP_TL_P1_SEL>;
+			clock-names = "pl_250m", "tl_26m", "peri_26m",
+				      "top_133m", "pextp_clk";
+			status = "disabled";
+			#interrupt-cells = <1>;
+			interrupt-map-mask = <0 0 0 0x7>;
+			interrupt-map = <0 0 0 1 &pcie_intc1 0>,
+					<0 0 0 2 &pcie_intc1 1>,
+					<0 0 0 3 &pcie_intc1 2>,
+					<0 0 0 4 &pcie_intc1 3>;
+			pcie_intc1: interrupt-controller {
+				#address-cells = <0>;
+				#interrupt-cells = <1>;
+				interrupt-controller;
+			};
+			slot1: pcie@0,0 {
+				reg = <0x0000 0 0 0 0>;
+			};
+		};
+
+		topmisc: topmisc@10021000 {
+			compatible = "mediatek,mt7987-topmisc", "syscon",
+				     "mediatek,mt7987-power-controller";
+			reg = <0 0x10021000 0 0x10000>;
+			#clock-cells = <1>;
+			#power-domain-cells = <1>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			/* power domain of the SoC */
+			/* eth2p5@MT7988_POWER_DOMAIN_ETH2P5 {
+			 *	reg = <MT7988_POWER_DOMAIN_ETH2P5>;
+			 *	#power-domain-cells = <0>;
+			 * };
+			 */
+		};
+
+		efuse: efuse@11d30000 {
+			compatible = "mediatek,efuse";
+			reg = <0 0x11d30000 0 0x1000>;
+			#address-cells = <1>;
+			#size-cells = <1>;
+
+			lvts_calibration: calib@918 {
+				reg = <0x918 0x10>;
+			};
+
+			comb_auto_load_valid: usb3-alv-imp@8ee {
+				reg = <0x8ee 1>;
+				bits = <0 1>;
+			};
+
+			comb_rx_imp_p0: usb3-rx-imp@8ec,1 {
+				reg = <0x8ec 1>;
+				bits = <0 5>;
+			};
+
+			comb_tx_imp_p0: usb3-tx-imp@8ec,2 {
+				reg = <0x8ec 2>;
+				bits = <5 5>;
+			};
+
+			comb_intr_p0: usb3-intr@8ec,3 {
+				reg = <0x8ed 1>;
+				bits = <2 6>;
+			};
+
+			u2_auto_load_valid_p0: usb2-alv-p0@8cc,1 {
+				reg  = <0x8cc 1>;
+				bits = <0 1>;
+			};
+
+			u2_intr_p0: usb2-intr-p0@8cc,2 {
+				reg  = <0x8cc 1>;
+				bits = <1 5>;
+			};
+		};
+
+		devapc: devapc@1a110000 {
+			compatible = "mediatek,mt7987-devapc";
+			reg = <0 0x1a110000 0 0x1000>;
+			interrupts = <GIC_SPI 174 IRQ_TYPE_LEVEL_HIGH>;
+		};
+
+		ethwarp: syscon@15031000 {
+			compatible = "mediatek,mt7988-ethwarp", "syscon";
+			reg = <0 0x15031000 0 0x1000>;
+			#clock-cells = <1>;
+		};
+
+		eth: ethernet@15100000 {
+			compatible = "mediatek,mt7987-eth";
+			reg = <0 0x15100000 0 0x80000>,
+			      <0 0x15400000 0 0x20000>;
+			interrupts = <GIC_SPI 196 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 197 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 198 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 199 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&ethsys CLK_ETHDMA_FE_EN>,
+				 <&ethsys CLK_ETHDMA_GP2_EN>,
+				 <&ethsys CLK_ETHDMA_GP1_EN>,
+				 <&ethsys CLK_ETHDMA_GP3_EN>,
+				 <&topckgen CLK_TOP_ETH_GMII_SEL>,
+				 <&topckgen CLK_TOP_ETH_REFCK_50M_SEL>,
+				 <&topckgen CLK_TOP_ETH_SYS_200M_SEL>,
+				 <&topckgen CLK_TOP_ETH_SYS_SEL>,
+				 <&topckgen CLK_TOP_ETH_XGMII_SEL>,
+				 <&topckgen CLK_TOP_ETH_MII_SEL>,
+				 <&topckgen CLK_TOP_NETSYS_SEL>,
+				 <&topckgen CLK_TOP_NETSYS_500M_SEL>,
+				 <&topckgen CLK_TOP_NETSYS_2X_SEL>;
+			clock-names = "fe", "gp2", "gp1", "gp3",
+				      "top_eth_gmii_sel", "top_eth_refck_50m_sel",
+				      "top_eth_sys_200m_sel", "top_eth_sys_sel",
+				      "top_eth_xgmii_sel", "top_eth_mii_sel",
+				      "top_netsys_sel", "top_netsys_500m_sel",
+				      "top_netsys_pao_2x_sel";
+			assigned-clocks = <&topckgen CLK_TOP_NETSYS_2X_SEL>,
+					  <&topckgen CLK_TOP_SGM_0_SEL>,
+					  <&topckgen CLK_TOP_SGM_1_SEL>;
+			assigned-clock-parents = <&apmixedsys CLK_APMIXED_NET2PLL>,
+						 <&apmixedsys CLK_APMIXED_SGMPLL>,
+						 <&apmixedsys CLK_APMIXED_SGMPLL>;
+			mediatek,ethsys = <&ethsys>;
+			mediatek,wed = <&wed0>;
+			mediatek,infracfg = <&topmisc>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&mdio0_pins>;
+			#reset-cells = <1>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			gmac0: mac@0 {
+				compatible = "mediatek,eth-mac";
+				reg = <0>;
+				pcs-handle = <&sgmiipcs0>;
+				status = "disabled";
+			};
+
+			gmac1: mac@1 {
+				compatible = "mediatek,eth-mac";
+				reg = <1>;
+				status = "disabled";
+			};
+
+			gmac2: mac@2 {
+				compatible = "mediatek,eth-mac";
+				reg = <2>;
+				pcs-handle = <&sgmiipcs1>;
+				status = "disabled";
+			};
+
+			mdio: mdio-bus {
+				#address-cells = <1>;
+				#size-cells = <0>;
+			};
+		};
+
+		crypto: crypto@15600000 {
+			compatible = "inside-secure,safexcel-eip197b",
+				     "security-ip-197-srv";
+			reg = <0 0x15600000 0 0x180000>;
+			interrupts = <GIC_SPI 214 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 215 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 216 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 217 IRQ_TYPE_LEVEL_HIGH>;
+			interrupt-names = "ring0", "ring1", "ring2", "ring3";
+			eth = <&eth>;
+		};
+	};
+};
--- /dev/null
+++ b/target/linux/mediatek/dts/mt7987a-rfb.dts
@@ -0,0 +1,87 @@
+// SPDX-License-Identifier: (GPL-2.0 OR MIT)
+/*
+ * Copyright (C) 2025 MediaTek Inc.
+ * Author: Sam.Shih <sam.shih@mediatek.com>
+ */
+
+/dts-v1/;
+#include "mt7987a.dtsi"
+#include <dt-bindings/input/input.h>
+
+/* MT7987A RFB DTS for DT overlay-based device tree */
+/ {
+	model = "MediaTek MT7987A RFB";
+	compatible = "mediatek,mt7987a", "mediatek,mt7987";
+
+	chosen {
+		bootargs = "console=ttyS0,115200n1 \
+			    earlycon=uart8250,mmio32,0x11000000 \
+			    pci=pcie_bus_perf ubi.block=0,firmware \
+			    root=/dev/fit0 rootwait nosmp";
+	};
+
+	gpio-keys {
+		compatible = "gpio-keys";
+
+		reset {
+			label = "reset";
+			linux,code = <KEY_RESTART>;
+			gpios = <&pio 1 GPIO_ACTIVE_LOW>;
+			debounce-interval = <10>;
+		};
+
+		wps {
+			label = "wps";
+			linux,code = <KEY_WPS_BUTTON>;
+			gpios = <&pio 0 GPIO_ACTIVE_LOW>;
+			debounce-interval = <10>;
+		};
+	};
+
+	/* use pwm0 as led: share with fan/pwm_rgb */
+	pwm_led {
+		pinctrl-names = "default";
+		pinctrl-0 = <&pwm_pins>;
+		status = "okay";
+
+		led {
+			pwms = <&pwm 0 50000 0>;
+			max-brightness = <255>;
+			active-low;
+			linux,default-trigger = "default-on";
+		};
+	};
+
+	/* use pwm0/1/2 as multicolor LED: share with fan/pwm_led */
+	pwm_rgb {
+		pinctrl-names = "default";
+		pinctrl-0 = <&pwm_rgb_pins>;
+		status = "disabled";
+
+		multi-led {
+			color = <LED_COLOR_ID_RGB>;
+			function = LED_FUNCTION_INDICATOR;
+			max-brightness = <255>;
+
+			led-red {
+				pwms = <&pwm 0 50000>;
+				color = <LED_COLOR_ID_RED>;
+			};
+
+			led-green {
+				pwms = <&pwm 1 50000>;
+				color = <LED_COLOR_ID_GREEN>;
+			};
+
+			led-blue {
+				pwms = <&pwm 2 50000>;
+				color = <LED_COLOR_ID_BLUE>;
+			};
+		};
+	};
+};
+
+&fan {
+	pwms = <&pwm 0 50000 0>;
+	status = "disabled";
+};
--- /dev/null
+++ b/target/linux/mediatek/dts/mt7987a.dtsi
@@ -0,0 +1,70 @@
+// SPDX-License-Identifier: (GPL-2.0 OR MIT)
+/*
+ * Copyright (C) 2023 MediaTek Inc.
+ * Author: Sam.Shih <sam.shih@mediatek.com>
+ */
+
+/dts-v1/;
+#include <dt-bindings/leds/common.h>
+#include "mt7987.dtsi"
+
+/ {
+	compatible = "mediatek,mt7987a", "mediatek,mt7987";
+
+	memory {
+		reg = <0 0x40000000 0 0x10000000>;
+	};
+
+};
+
+&boottrap {
+	status = "okay";
+};
+
+&i2c0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&i2c0_pins>;
+	status = "okay";
+};
+
+&infra_bus_prot {
+	status = "okay";
+};
+
+&lvts {
+	status = "okay";
+};
+
+&pcie0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pcie0_pins>;
+	status = "okay";
+};
+
+&pcie1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pcie1_pins>;
+	status = "disabled";
+};
+
+&pwm {
+	status = "okay";
+};
+
+&trng {
+	status = "okay";
+};
+
+&uart0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&uart0_pins>;
+	status = "okay";
+};
+
+&watchdog {
+	status = "okay";
+};
+
+&ssusb {
+	status = "okay";
+};
--- /dev/null
+++ b/target/linux/mediatek/dts/mt7987b.dtsi
@@ -0,0 +1,31 @@
+// SPDX-License-Identifier: (GPL-2.0 OR MIT)
+/*
+ * Copyright (C) 2023 MediaTek Inc.
+ * Author: Sam.Shih <sam.shih@mediatek.com>
+ */
+
+/dts-v1/;
+#include "mt7987a.dtsi"
+#include "mt7987-netsys-eth2-usb.dtsi"
+
+/ {
+	compatible = "mediatek,mt7987b", "mediatek,mt7987";
+
+	memory {
+		reg = <0 0x40000000 0 0x10000000>;
+	};
+
+	cpus {
+		/delete-node/ cpu@2;
+		/delete-node/ cpu@3;
+	};
+};
+
+&cpu_thermal {
+	cooling-maps {
+		cpu-active-hot {
+			cooling-device = <&cpu0 THERMAL_NO_LIMIT THERMAL_NO_LIMIT>,
+					 <&cpu1 THERMAL_NO_LIMIT THERMAL_NO_LIMIT>;
+		};
+	};
+};
--- a/target/linux/mediatek/image/filogic.mk
+++ b/target/linux/mediatek/image/filogic.mk
@@ -24,6 +24,14 @@ define Build/mt7986-bl31-uboot
 	cat $(STAGING_DIR_IMAGE)/mt7986_$1-u-boot.fip >> $@
 endef
 
+define Build/mt7987-bl2
+	cat $(STAGING_DIR_IMAGE)/mt7987-$1-bl2.img >> $@
+endef
+
+define Build/mt7987-bl31-uboot
+	cat $(STAGING_DIR_IMAGE)/mt7987_$1-u-boot.fip >> $@
+endef
+
 define Build/mt7988-bl2
 	cat $(STAGING_DIR_IMAGE)/mt7988-$1-bl2.img >> $@
 endef
@@ -576,7 +584,7 @@ define Device/bananapi_bpi-r4-common
   KERNEL			:= kernel-bin | gzip
   KERNEL_INITRAMFS := kernel-bin | lzma | \
 	fit lzma $$(KDIR)/image-$$(firstword $$(DEVICE_DTS)).dtb with-initrd | pad-to 64k
-  IMAGE/sysupgrade.itb := append-kernel | fit gzip $$(KDIR)/image-$$(firstword $$(DEVICE_DTS)).dtb external-with-rootfs | pad-rootfs | append-metadata
+ IMAGE/sysupgrade.itb := append-kernel | fit gzip $$(KDIR)/image-$$(firstword $$(DEVICE_DTS)).dtb external-with-rootfs | pad-rootfs | append-metadata
 endef
 
 define Device/bananapi_bpi-r4
@@ -601,6 +609,67 @@ endif
 endef
 TARGET_DEVICES += bananapi_bpi-r4-poe
 
+define Device/bananapi_bpi-r4-lite
+  DEVICE_VENDOR := Bananapi
+  DEVICE_MODEL := BPi-R4 Lite
+  DEVICE_DTS := mt7987a-bananapi-bpi-r4-lite
+  DEVICE_DTS_OVERLAY:= mt7987a-bananapi-bpi-r4-lite-1pcie-2L mt7987a-bananapi-bpi-r4-lite-2pcie-1L \
+		       mt7987a-bananapi-bpi-r4-lite-emmc mt7987a-bananapi-bpi-r4-lite-sd \
+		       mt7987a-bananapi-bpi-r4-lite-nand mt7987a-bananapi-bpi-r4-lite-nor
+  DEVICE_DTS_CONFIG := config-mt7987a-bananapi-bpi-r4-lite
+  DEVICE_DTC_FLAGS := --pad 4096
+  DEVICE_DTS_DIR := ../dts
+  DEVICE_DTS_LOADADDR := 0x4ff00000
+  DEVICE_PACKAGES := mt7987-2p5g-phy-firmware-internal kmod-eeprom-at24 \
+		     kmod-gpio-pca953x kmod-i2c-mux-pca954x kmod-rtc-pcf8563 \
+		     kmod-sfp e2fsprogs mkf2fs
+  BLOCKSIZE := 128k
+  PAGESIZE := 2048
+  KERNEL_IN_UBI := 1
+  UBOOTENV_IN_UBI := 1
+  KERNEL_LOADADDR := 0x40000000
+  KERNEL := kernel-bin | gzip
+  KERNEL_INITRAMFS := kernel-bin | lzma | \
+        fit lzma $$(KDIR)/image-$$(firstword $$(DEVICE_DTS)).dtb with-initrd | pad-to 64k
+  IMAGES := sysupgrade.itb
+  KERNEL_INITRAMFS_SUFFIX := -recovery.itb
+  KERNEL_IN_UBI := 1
+  IMAGES := sysupgrade.itb
+  IMAGE/sysupgrade.itb := append-kernel | fit gzip $$(KDIR)/image-$$(firstword $$(DEVICE_DTS)).dtb external-with-rootfs | pad-rootfs | append-metadata
+  ARTIFACTS := \
+	       emmc-preloader.bin emmc-bl31-uboot.fip \
+	       nor-preloader.bin nor-bl31-uboot.fip \
+	       sdcard.img.gz \
+	       snand-preloader.bin snand-bl31-uboot.fip
+  ARTIFACT/emmc-preloader.bin	:= mt7987-bl2 emmc-comb
+  ARTIFACT/emmc-bl31-uboot.fip	:= mt7987-bl31-uboot bananapi_bpi-r4-lite-emmc
+  ARTIFACT/nor-preloader.bin	:= mt7987-bl2 nor-comb
+  ARTIFACT/nor-bl31-uboot.fip	:= mt7987-bl31-uboot bananapi_bpi-r4-lite-nor
+  ARTIFACT/snand-preloader.bin	:= mt7987-bl2 spim-nand2-ubi-comb
+  ARTIFACT/snand-bl31-uboot.fip	:= mt7987-bl31-uboot bananapi_bpi-r4-lite-snand
+  ARTIFACT/sdcard.img.gz	:= mt798x-gpt sdmmc |\
+				   pad-to 17k | mt7987-bl2 sdmmc-comb |\
+				   pad-to 6656k | mt7987-bl31-uboot bananapi_bpi-r4-lite-sdmmc |\
+				$(if $(CONFIG_TARGET_ROOTFS_INITRAMFS),\
+				   pad-to 12M | append-image-stage initramfs-recovery.itb | check-size 44m |\
+				) \
+				   pad-to 44M | mt7987-bl2 spim-nand2-ubi-comb |\
+				   pad-to 45M | mt7987-bl31-uboot bananapi_bpi-r4-lite-snand |\
+				   pad-to 49M | mt7987-bl2 nor-comb |\
+				   pad-to 50M | mt7987-bl31-uboot bananapi_bpi-r4-lite-nor |\
+				   pad-to 51M | mt7987-bl2 emmc-comb |\
+				   pad-to 52M | mt7987-bl31-uboot bananapi_bpi-r4-lite-emmc |\
+				   pad-to 56M | mt798x-gpt emmc |\
+				$(if $(CONFIG_TARGET_ROOTFS_SQUASHFS),\
+				   pad-to 64M | append-image squashfs-sysupgrade.itb | check-size |\
+				) \
+				  gzip
+ifeq ($(DUMP),)
+  IMAGE_SIZE := $$(shell expr 64 + $$(CONFIG_TARGET_ROOTFS_PARTSIZE))m
+endif
+endef
+TARGET_DEVICES += bananapi_bpi-r4-lite
+
 define Device/buffalo_wsr-6000ax8
   DEVICE_MODEL := WSR-6000AX8
   DEVICE_VENDOR := Buffalo
@@ -1551,6 +1620,60 @@ define Device/mediatek_mt7986b-rfb
 endef
 TARGET_DEVICES += mediatek_mt7986b-rfb
 
+define Device/mediatek_mt7987a-rfb
+  DEVICE_VENDOR := MediaTek
+  DEVICE_MODEL := MT7987A rfb (DT-overlay)
+  DEVICE_DTS := mt7987a-rfb
+  DEVICE_DTS_OVERLAY:= \
+	mt7987-spim-nand \
+	mt7987-spidev \
+	mt7987-spim-nor \
+	mt7987-emmc \
+	mt7987-sd \
+	mt7987-netsys-eth0-an8801sb \
+	mt7987-netsys-eth0-an8855 \
+	mt7987-netsys-eth0-an8855-gsw \
+	mt7987-netsys-eth0-e2p5g \
+	mt7987-netsys-eth0-mt7531 \
+	mt7987-netsys-eth0-mt7531-gsw \
+	mt7987-netsys-eth1-i2p5g \
+	mt7987-netsys-eth2-an8801sb \
+	mt7987-netsys-eth2-e2p5g \
+	mt7987-netsys-eth2-sfp \
+	mt7987-netsys-eth2-usb
+  DEVICE_DTS_DIR := ../dts
+  DEVICE_DTC_FLAGS := --pad 4096
+  DEVICE_DTS_LOADADDR := 0x4ff00000
+  DEVICE_PACKAGES := mt798x-2p5g-phy-firmware-internal kmod-sfp blkid
+  KERNEL_LOADADDR := 0x40000000
+  KERNEL := kernel-bin | gzip
+  KERNEL_INITRAMFS := kernel-bin | lzma | \
+        fit lzma $$(KDIR)/image-$$(firstword $$(DEVICE_DTS)).dtb with-initrd | pad-to 64k
+  IMAGES := sysupgrade.itb
+  KERNEL_INITRAMFS_SUFFIX := .itb
+  KERNEL_IN_UBI := 1
+  IMAGE_SIZE := $$(shell expr 64 + $$(CONFIG_TARGET_ROOTFS_PARTSIZE))m
+  IMAGES := sysupgrade.itb
+  IMAGE/sysupgrade.itb := append-kernel | fit gzip $$(KDIR)/image-$$(firstword $$(DEVICE_DTS)).dtb external-with-rootfs | pad-rootfs | append-metadata
+  ARTIFACTS := \
+	snand-preloader.bin \
+	snand-bl31-uboot.fip \
+	sdcard.img.gz
+  ARTIFACT/snand-preloader.bin	:= mt7987-bl2 spim-nand0-ubi-comb
+  ARTIFACT/snand-bl31-uboot.fip	:= mt7987-bl31-uboot rfb-spim-nand
+  ARTIFACT/sdcard.img.gz	:= mt798x-gpt sdmmc |\
+				   pad-to 17k | mt7987-bl2 sdmmc-comb |\
+				   pad-to 6656k | mt7987-bl31-uboot rfb-sd |\
+				$(if $(CONFIG_TARGET_ROOTFS_INITRAMFS),\
+				  pad-to 12M | append-image-stage initramfs.itb | check-size 44m |\
+				) \
+				$(if $(CONFIG_TARGET_ROOTFS_SQUASHFS),\
+				  pad-to 64M | append-image squashfs-sysupgrade.itb | check-size |\
+				) \
+				  gzip
+endef
+TARGET_DEVICES += mediatek_mt7987a-rfb
+
 define Device/mediatek_mt7988a-rfb
   DEVICE_VENDOR := MediaTek
   DEVICE_MODEL := MT7988A rfb
--- /dev/null
+++ b/package/boot/uboot-mediatek/patches/470-add-bpi-r4-lite.patch
@@ -0,0 +1,1349 @@
+--- /dev/null
++++ b/configs/mt7987a_bpi-r4-lite-emmc_defconfig
+@@ -0,0 +1,155 @@
++CONFIG_ARM=y
++CONFIG_SYS_HAS_NONCACHED_MEMORY=y
++CONFIG_POSITION_INDEPENDENT=y
++CONFIG_ARCH_MEDIATEK=y
++CONFIG_TEXT_BASE=0x41e00000
++CONFIG_SYS_MALLOC_F_LEN=0x4000
++CONFIG_NR_DRAM_BANKS=1
++CONFIG_DEFAULT_DEVICE_TREE="mt7987a-bpi-r4-lite-emmc"
++CONFIG_OF_LIBFDT_OVERLAY=y
++CONFIG_TARGET_MT7987=y
++CONFIG_CPU_ARMV8=y
++CONFIG_SYS_BOOTM_LEN=0x6000000
++CONFIG_SYS_LOAD_ADDR=0x48000000
++CONFIG_PRE_CON_BUF_ADDR=0x4007EF00
++CONFIG_DEBUG_UART_BASE=0x11000000
++CONFIG_DEBUG_UART_CLOCK=40000000
++CONFIG_DEBUG_UART=y
++CONFIG_FIT=y
++CONFIG_AUTOBOOT_MENU_SHOW=y
++CONFIG_DEFAULT_FDT_FILE="mt7987a-bpi-r4-lite-emmc"
++CONFIG_SYS_CBSIZE=512
++CONFIG_SYS_PBSIZE=1049
++CONFIG_LOGLEVEL=7
++CONFIG_PRE_CONSOLE_BUFFER=y
++CONFIG_LOG=y
++# CONFIG_BOARD_INIT is not set
++CONFIG_BOARD_LATE_INIT=y
++CONFIG_HUSH_PARSER=y
++CONFIG_SYS_PROMPT="MT7987> "
++CONFIG_CMD_LICENSE=y
++# CONFIG_BOOTM_NETBSD is not set
++# CONFIG_BOOTM_PLAN9 is not set
++# CONFIG_BOOTM_RTEMS is not set
++# CONFIG_BOOTM_VXWORKS is not set
++# CONFIG_CMD_BOOTEFI_BOOTMGR is not set
++CONFIG_CMD_BOOTMENU=y
++# CONFIG_CMD_XIMG is not set
++CONFIG_CMD_ASKENV=y
++CONFIG_CMD_ERASEENV=y
++CONFIG_CMD_ENV_FLAGS=y
++CONFIG_CMD_STRINGS=y
++CONFIG_CMD_CPU=y
++CONFIG_CMD_DM=y
++CONFIG_CMD_GPIO=y
++CONFIG_CMD_PWM=y
++CONFIG_CMD_GPT=y
++CONFIG_CMD_I2C=y
++CONFIG_CMD_MMC=y
++CONFIG_CMD_MTD=y
++CONFIG_CMD_PART=y
++CONFIG_CMD_PCI=y
++CONFIG_CMD_USB=y
++CONFIG_CMD_TFTPSRV=y
++CONFIG_CMD_RARP=y
++CONFIG_CMD_CDP=y
++CONFIG_CMD_SNTP=y
++CONFIG_CMD_LINK_LOCAL=y
++CONFIG_CMD_DHCP=y
++CONFIG_CMD_DNS=y
++CONFIG_CMD_PING=y
++CONFIG_CMD_PXE=y
++CONFIG_CMD_CACHE=y
++CONFIG_CMD_PSTORE=y
++CONFIG_CMD_PSTORE_MEM_ADDR=0x42ff0000
++CONFIG_CMD_UUID=y
++CONFIG_CMD_HASH=y
++CONFIG_CMD_SMC=y
++CONFIG_CMD_EXT4=y
++CONFIG_CMD_FAT=y
++CONFIG_CMD_FS_GENERIC=y
++CONFIG_CMD_FS_UUID=y
++CONFIG_CMD_SF_TEST=y
++CONFIG_CMD_UBI=y
++CONFIG_CMD_UBI_RENAME=y
++CONFIG_ENV_OVERWRITE=y
++CONFIG_ENV_IS_IN_MMC=y
++CONFIG_ENV_SIZE=0x40000
++CONFIG_ENV_OFFSET=0x400000
++CONFIG_ENV_OFFSET_REDUND=0x440000
++CONFIG_ENV_REDUNDANT=y
++CONFIG_ENV_USE_DEFAULT_ENV_TEXT_FILE=y
++CONFIG_ENV_DEFAULT_ENV_TEXT_FILE="defenvs/bananapi_bpi-r4-lite_emmc_env"
++CONFIG_ENV_VARS_UBOOT_RUNTIME_CONFIG=y
++CONFIG_VERSION_VARIABLE=y
++CONFIG_NETCONSOLE=y
++CONFIG_USE_IPADDR=y
++CONFIG_IPADDR="192.168.1.1"
++CONFIG_USE_NETMASK=y
++CONFIG_NETMASK="255.255.255.0"
++CONFIG_USE_SERVERIP=y
++CONFIG_SERVERIP="192.168.1.254"
++CONFIG_NET_RANDOM_ETHADDR=y
++CONFIG_BUTTON=y
++CONFIG_BUTTON_GPIO=y
++CONFIG_CLK=y
++CONFIG_DM_I2C=y
++CONFIG_SYS_I2C_MTK=y
++CONFIG_LED=y
++CONFIG_LED_BLINK=y
++CONFIG_LED_GPIO=y
++CONFIG_SUPPORT_EMMC_BOOT=y
++CONFIG_MMC_HS200_SUPPORT=y
++CONFIG_MMC_MTK=y
++CONFIG_MTD=y
++CONFIG_DM_MTD=y
++CONFIG_MTD_SPI_NAND=y
++CONFIG_DM_SPI_FLASH=y
++CONFIG_SPI_FLASH_SFDP_SUPPORT=y
++CONFIG_SPI_FLASH_ATMEL=y
++CONFIG_SPI_FLASH_EON=y
++CONFIG_SPI_FLASH_GIGADEVICE=y
++CONFIG_SPI_FLASH_ISSI=y
++CONFIG_SPI_FLASH_MACRONIX=y
++CONFIG_SPI_FLASH_PUYA=y
++CONFIG_SPI_FLASH_SILICONKAISER=y
++CONFIG_SPI_FLASH_SPANSION=y
++CONFIG_SPI_FLASH_STMICRO=y
++CONFIG_SPI_FLASH_WINBOND=y
++CONFIG_SPI_FLASH_XMC=y
++CONFIG_SPI_FLASH_XTX=y
++CONFIG_SPI_FLASH_ZBIT=y
++CONFIG_SPI_FLASH_MTD=y
++# CONFIG_SPI_FLASH_USE_4K_SECTORS is not set
++CONFIG_MTD_UBI_FASTMAP=y
++CONFIG_PHY_ETHERNET_ID=y
++CONFIG_PHY_FIXED=y
++CONFIG_MEDIATEK_ETH=y
++CONFIG_PHY=y
++CONFIG_PHY_MTK_TPHY=y
++CONFIG_PINCTRL=y
++CONFIG_PINCONF=y
++CONFIG_PINCTRL_MT7987=y
++CONFIG_POWER_DOMAIN=y
++CONFIG_MTK_POWER_DOMAIN=y
++CONFIG_DM_REGULATOR=y
++CONFIG_DM_REGULATOR_FIXED=y
++CONFIG_DM_REGULATOR_GPIO=y
++CONFIG_DM_PWM=y
++CONFIG_PWM_MTK=y
++CONFIG_SCSI=y
++CONFIG_DM_SERIAL=y
++CONFIG_SERIAL_RX_BUFFER=y
++CONFIG_MTK_SERIAL=y
++CONFIG_SPI=y
++CONFIG_DM_SPI=y
++CONFIG_MTK_SPIM=y
++CONFIG_USB=y
++CONFIG_USB_XHCI_HCD=y
++CONFIG_USB_XHCI_MTK=y
++CONFIG_USB_STORAGE=y
++CONFIG_ZSTD=y
++CONFIG_HEXDUMP=y
++# CONFIG_TOOLS_LIBCRYPTO is not set
++# CONFIG_TOOLS_KWBIMAGE is not set
++# CONFIG_TOOLS_MKEFICAPSULE is not set
+--- /dev/null
++++ b/configs/mt7987a_bpi-r4-lite-nor_defconfig
+@@ -0,0 +1,156 @@
++CONFIG_ARM=y
++CONFIG_SYS_HAS_NONCACHED_MEMORY=y
++CONFIG_POSITION_INDEPENDENT=y
++CONFIG_ARCH_MEDIATEK=y
++CONFIG_TEXT_BASE=0x41e00000
++CONFIG_SYS_MALLOC_F_LEN=0x4000
++CONFIG_NR_DRAM_BANKS=1
++CONFIG_DEFAULT_DEVICE_TREE="mt7987a-bpi-r4-lite-emmc"
++CONFIG_OF_LIBFDT_OVERLAY=y
++CONFIG_TARGET_MT7987=y
++CONFIG_CPU_ARMV8=y
++CONFIG_SYS_BOOTM_LEN=0x6000000
++CONFIG_SYS_LOAD_ADDR=0x48000000
++CONFIG_PRE_CON_BUF_ADDR=0x4007EF00
++CONFIG_DEBUG_UART_BASE=0x11000000
++CONFIG_DEBUG_UART_CLOCK=40000000
++CONFIG_DEBUG_UART=y
++CONFIG_FIT=y
++CONFIG_AUTOBOOT_MENU_SHOW=y
++CONFIG_DEFAULT_FDT_FILE="mt7987a-bpi-r4-lite-emmc"
++CONFIG_SYS_CBSIZE=512
++CONFIG_SYS_PBSIZE=1049
++CONFIG_LOGLEVEL=7
++CONFIG_PRE_CONSOLE_BUFFER=y
++CONFIG_LOG=y
++# CONFIG_BOARD_INIT is not set
++CONFIG_BOARD_LATE_INIT=y
++CONFIG_HUSH_PARSER=y
++CONFIG_SYS_PROMPT="MT7987> "
++CONFIG_CMD_LICENSE=y
++# CONFIG_BOOTM_NETBSD is not set
++# CONFIG_BOOTM_PLAN9 is not set
++# CONFIG_BOOTM_RTEMS is not set
++# CONFIG_BOOTM_VXWORKS is not set
++# CONFIG_CMD_BOOTEFI_BOOTMGR is not set
++CONFIG_CMD_BOOTMENU=y
++# CONFIG_CMD_XIMG is not set
++CONFIG_CMD_ASKENV=y
++CONFIG_CMD_ERASEENV=y
++CONFIG_CMD_ENV_FLAGS=y
++CONFIG_CMD_STRINGS=y
++CONFIG_CMD_CPU=y
++CONFIG_CMD_DM=y
++CONFIG_CMD_GPIO=y
++CONFIG_CMD_PWM=y
++CONFIG_CMD_GPT=y
++CONFIG_CMD_I2C=y
++CONFIG_CMD_MMC=y
++CONFIG_CMD_MTD=y
++CONFIG_CMD_PART=y
++CONFIG_CMD_PCI=y
++CONFIG_CMD_USB=y
++CONFIG_CMD_TFTPSRV=y
++CONFIG_CMD_RARP=y
++CONFIG_CMD_CDP=y
++CONFIG_CMD_SNTP=y
++CONFIG_CMD_LINK_LOCAL=y
++CONFIG_CMD_DHCP=y
++CONFIG_CMD_DNS=y
++CONFIG_CMD_PING=y
++CONFIG_CMD_PXE=y
++CONFIG_CMD_CACHE=y
++CONFIG_CMD_PSTORE=y
++CONFIG_CMD_PSTORE_MEM_ADDR=0x42ff0000
++CONFIG_CMD_UUID=y
++CONFIG_CMD_HASH=y
++CONFIG_CMD_SMC=y
++CONFIG_CMD_EXT4=y
++CONFIG_CMD_FAT=y
++CONFIG_CMD_FS_GENERIC=y
++CONFIG_CMD_FS_UUID=y
++CONFIG_CMD_SF_TEST=y
++CONFIG_CMD_UBI=y
++CONFIG_CMD_UBI_RENAME=y
++CONFIG_ENV_OVERWRITE=y
++CONFIG_ENV_IS_IN_MTD=y
++CONFIG_ENV_REDUNDANT=y
++CONFIG_ENV_MTD_DEV="u-boot-env"
++CONFIG_ENV_SIZE=0x20000
++CONFIG_ENV_OFFSET=0x0
++CONFIG_ENV_OFFSET_REDUND=0x20000
++CONFIG_ENV_USE_DEFAULT_ENV_TEXT_FILE=y
++CONFIG_ENV_DEFAULT_ENV_TEXT_FILE="defenvs/bananapi_bpi-r4-lite_nor_env"
++CONFIG_ENV_VARS_UBOOT_RUNTIME_CONFIG=y
++CONFIG_VERSION_VARIABLE=y
++CONFIG_NETCONSOLE=y
++CONFIG_USE_IPADDR=y
++CONFIG_IPADDR="192.168.1.1"
++CONFIG_USE_NETMASK=y
++CONFIG_NETMASK="255.255.255.0"
++CONFIG_USE_SERVERIP=y
++CONFIG_SERVERIP="192.168.1.254"
++CONFIG_NET_RANDOM_ETHADDR=y
++CONFIG_BUTTON=y
++CONFIG_BUTTON_GPIO=y
++CONFIG_CLK=y
++CONFIG_DM_I2C=y
++CONFIG_SYS_I2C_MTK=y
++CONFIG_LED=y
++CONFIG_LED_BLINK=y
++CONFIG_LED_GPIO=y
++CONFIG_SUPPORT_EMMC_BOOT=y
++CONFIG_MMC_HS200_SUPPORT=y
++CONFIG_MMC_MTK=y
++CONFIG_MTD=y
++CONFIG_DM_MTD=y
++CONFIG_MTD_SPI_NAND=y
++CONFIG_DM_SPI_FLASH=y
++CONFIG_SPI_FLASH_SFDP_SUPPORT=y
++CONFIG_SPI_FLASH_ATMEL=y
++CONFIG_SPI_FLASH_EON=y
++CONFIG_SPI_FLASH_GIGADEVICE=y
++CONFIG_SPI_FLASH_ISSI=y
++CONFIG_SPI_FLASH_MACRONIX=y
++CONFIG_SPI_FLASH_PUYA=y
++CONFIG_SPI_FLASH_SILICONKAISER=y
++CONFIG_SPI_FLASH_SPANSION=y
++CONFIG_SPI_FLASH_STMICRO=y
++CONFIG_SPI_FLASH_WINBOND=y
++CONFIG_SPI_FLASH_XMC=y
++CONFIG_SPI_FLASH_XTX=y
++CONFIG_SPI_FLASH_ZBIT=y
++CONFIG_SPI_FLASH_MTD=y
++# CONFIG_SPI_FLASH_USE_4K_SECTORS is not set
++CONFIG_MTD_UBI_FASTMAP=y
++CONFIG_PHY_ETHERNET_ID=y
++CONFIG_PHY_FIXED=y
++CONFIG_MEDIATEK_ETH=y
++CONFIG_PHY=y
++CONFIG_PHY_MTK_TPHY=y
++CONFIG_PINCTRL=y
++CONFIG_PINCONF=y
++CONFIG_PINCTRL_MT7987=y
++CONFIG_POWER_DOMAIN=y
++CONFIG_MTK_POWER_DOMAIN=y
++CONFIG_DM_REGULATOR=y
++CONFIG_DM_REGULATOR_FIXED=y
++CONFIG_DM_REGULATOR_GPIO=y
++CONFIG_DM_PWM=y
++CONFIG_PWM_MTK=y
++CONFIG_SCSI=y
++CONFIG_DM_SERIAL=y
++CONFIG_SERIAL_RX_BUFFER=y
++CONFIG_MTK_SERIAL=y
++CONFIG_SPI=y
++CONFIG_DM_SPI=y
++CONFIG_MTK_SPIM=y
++CONFIG_USB=y
++CONFIG_USB_XHCI_HCD=y
++CONFIG_USB_XHCI_MTK=y
++CONFIG_USB_STORAGE=y
++CONFIG_ZSTD=y
++CONFIG_HEXDUMP=y
++# CONFIG_TOOLS_LIBCRYPTO is not set
++# CONFIG_TOOLS_KWBIMAGE is not set
++# CONFIG_TOOLS_MKEFICAPSULE is not set
+--- /dev/null
++++ b/configs/mt7987a_bpi-r4-lite-sd_defconfig
+@@ -0,0 +1,155 @@
++CONFIG_ARM=y
++CONFIG_SYS_HAS_NONCACHED_MEMORY=y
++CONFIG_POSITION_INDEPENDENT=y
++CONFIG_ARCH_MEDIATEK=y
++CONFIG_TEXT_BASE=0x41e00000
++CONFIG_SYS_MALLOC_F_LEN=0x4000
++CONFIG_NR_DRAM_BANKS=1
++CONFIG_DEFAULT_DEVICE_TREE="mt7987a-bpi-r4-lite-sd"
++CONFIG_OF_LIBFDT_OVERLAY=y
++CONFIG_TARGET_MT7987=y
++CONFIG_CPU_ARMV8=y
++CONFIG_SYS_BOOTM_LEN=0x6000000
++CONFIG_SYS_LOAD_ADDR=0x48000000
++CONFIG_PRE_CON_BUF_ADDR=0x4007EF00
++CONFIG_DEBUG_UART_BASE=0x11000000
++CONFIG_DEBUG_UART_CLOCK=40000000
++CONFIG_DEBUG_UART=y
++CONFIG_FIT=y
++CONFIG_AUTOBOOT_MENU_SHOW=y
++CONFIG_DEFAULT_FDT_FILE="mt7987a-bpi-r4-lite-sd"
++CONFIG_SYS_CBSIZE=512
++CONFIG_SYS_PBSIZE=1049
++CONFIG_LOGLEVEL=7
++CONFIG_PRE_CONSOLE_BUFFER=y
++CONFIG_LOG=y
++# CONFIG_BOARD_INIT is not set
++CONFIG_BOARD_LATE_INIT=y
++CONFIG_HUSH_PARSER=y
++CONFIG_SYS_PROMPT="MT7987> "
++CONFIG_CMD_LICENSE=y
++# CONFIG_BOOTM_NETBSD is not set
++# CONFIG_BOOTM_PLAN9 is not set
++# CONFIG_BOOTM_RTEMS is not set
++# CONFIG_BOOTM_VXWORKS is not set
++# CONFIG_CMD_BOOTEFI_BOOTMGR is not set
++CONFIG_CMD_BOOTMENU=y
++# CONFIG_CMD_XIMG is not set
++CONFIG_CMD_ASKENV=y
++CONFIG_CMD_ERASEENV=y
++CONFIG_CMD_ENV_FLAGS=y
++CONFIG_CMD_STRINGS=y
++CONFIG_CMD_CPU=y
++CONFIG_CMD_DM=y
++CONFIG_CMD_GPIO=y
++CONFIG_CMD_PWM=y
++CONFIG_CMD_GPT=y
++CONFIG_CMD_I2C=y
++CONFIG_CMD_MMC=y
++CONFIG_CMD_MTD=y
++CONFIG_CMD_PART=y
++CONFIG_CMD_PCI=y
++CONFIG_CMD_SF_TEST=y
++CONFIG_CMD_USB=y
++CONFIG_CMD_TFTPSRV=y
++CONFIG_CMD_RARP=y
++CONFIG_CMD_CDP=y
++CONFIG_CMD_SNTP=y
++CONFIG_CMD_LINK_LOCAL=y
++CONFIG_CMD_DHCP=y
++CONFIG_CMD_DNS=y
++CONFIG_CMD_PING=y
++CONFIG_CMD_PXE=y
++CONFIG_CMD_CACHE=y
++CONFIG_CMD_PSTORE=y
++CONFIG_CMD_PSTORE_MEM_ADDR=0x42ff0000
++CONFIG_CMD_UUID=y
++CONFIG_CMD_HASH=y
++CONFIG_CMD_SMC=y
++CONFIG_CMD_EXT4=y
++CONFIG_CMD_FAT=y
++CONFIG_CMD_FS_GENERIC=y
++CONFIG_CMD_FS_UUID=y
++CONFIG_CMD_UBI=y
++CONFIG_CMD_UBI_RENAME=y
++CONFIG_ENV_OVERWRITE=y
++CONFIG_ENV_IS_IN_MMC=y
++CONFIG_ENV_SIZE=0x40000
++CONFIG_ENV_OFFSET=0x400000
++CONFIG_ENV_OFFSET_REDUND=0x440000
++CONFIG_ENV_REDUNDANT=y
++CONFIG_ENV_USE_DEFAULT_ENV_TEXT_FILE=y
++CONFIG_ENV_DEFAULT_ENV_TEXT_FILE="defenvs/bananapi_bpi-r4-lite_sdmmc_env"
++CONFIG_ENV_VARS_UBOOT_RUNTIME_CONFIG=y
++CONFIG_VERSION_VARIABLE=y
++CONFIG_NETCONSOLE=y
++CONFIG_USE_IPADDR=y
++CONFIG_IPADDR="192.168.1.1"
++CONFIG_USE_NETMASK=y
++CONFIG_NETMASK="255.255.255.0"
++CONFIG_USE_SERVERIP=y
++CONFIG_SERVERIP="192.168.1.254"
++CONFIG_NET_RANDOM_ETHADDR=y
++CONFIG_BUTTON=y
++CONFIG_BUTTON_GPIO=y
++CONFIG_CLK=y
++CONFIG_DM_I2C=y
++CONFIG_SYS_I2C_MTK=y
++CONFIG_LED=y
++CONFIG_LED_BLINK=y
++CONFIG_LED_GPIO=y
++CONFIG_SUPPORT_EMMC_BOOT=y
++CONFIG_MMC_HS200_SUPPORT=y
++CONFIG_MMC_MTK=y
++CONFIG_MTD=y
++CONFIG_DM_MTD=y
++CONFIG_MTD_SPI_NAND=y
++CONFIG_DM_SPI_FLASH=y
++CONFIG_SPI_FLASH_SFDP_SUPPORT=y
++CONFIG_SPI_FLASH_ATMEL=y
++CONFIG_SPI_FLASH_EON=y
++CONFIG_SPI_FLASH_GIGADEVICE=y
++CONFIG_SPI_FLASH_ISSI=y
++CONFIG_SPI_FLASH_MACRONIX=y
++CONFIG_SPI_FLASH_PUYA=y
++CONFIG_SPI_FLASH_SILICONKAISER=y
++CONFIG_SPI_FLASH_SPANSION=y
++CONFIG_SPI_FLASH_STMICRO=y
++CONFIG_SPI_FLASH_WINBOND=y
++CONFIG_SPI_FLASH_XMC=y
++CONFIG_SPI_FLASH_XTX=y
++CONFIG_SPI_FLASH_ZBIT=y
++CONFIG_SPI_FLASH_MTD=y
++# CONFIG_SPI_FLASH_USE_4K_SECTORS is not set
++CONFIG_MTD_UBI_FASTMAP=y
++CONFIG_PHY_ETHERNET_ID=y
++CONFIG_PHY_FIXED=y
++CONFIG_MEDIATEK_ETH=y
++CONFIG_PHY=y
++CONFIG_PHY_MTK_TPHY=y
++CONFIG_PINCTRL=y
++CONFIG_PINCONF=y
++CONFIG_PINCTRL_MT7987=y
++CONFIG_POWER_DOMAIN=y
++CONFIG_MTK_POWER_DOMAIN=y
++CONFIG_DM_REGULATOR=y
++CONFIG_DM_REGULATOR_FIXED=y
++CONFIG_DM_REGULATOR_GPIO=y
++CONFIG_DM_PWM=y
++CONFIG_PWM_MTK=y
++CONFIG_SCSI=y
++CONFIG_DM_SERIAL=y
++CONFIG_SERIAL_RX_BUFFER=y
++CONFIG_MTK_SERIAL=y
++CONFIG_SPI=y
++CONFIG_DM_SPI=y
++CONFIG_MTK_SPIM=y
++CONFIG_USB=y
++CONFIG_USB_XHCI_HCD=y
++CONFIG_USB_XHCI_MTK=y
++CONFIG_USB_STORAGE=y
++CONFIG_ZSTD=y
++CONFIG_HEXDUMP=y
++# CONFIG_TOOLS_LIBCRYPTO is not set
++# CONFIG_TOOLS_KWBIMAGE is not set
++# CONFIG_TOOLS_MKEFICAPSULE is not set
+--- /dev/null
++++ b/configs/mt7987a_bpi-r4-lite-snand_defconfig
+@@ -0,0 +1,155 @@
++CONFIG_ARM=y
++CONFIG_SYS_HAS_NONCACHED_MEMORY=y
++CONFIG_POSITION_INDEPENDENT=y
++CONFIG_ARCH_MEDIATEK=y
++CONFIG_TEXT_BASE=0x41e00000
++CONFIG_SYS_MALLOC_F_LEN=0x4000
++CONFIG_NR_DRAM_BANKS=1
++CONFIG_DEFAULT_DEVICE_TREE="mt7987a-bpi-r4-lite-spim-nand"
++CONFIG_OF_LIBFDT_OVERLAY=y
++CONFIG_TARGET_MT7987=y
++CONFIG_CPU_ARMV8=y
++CONFIG_SYS_BOOTM_LEN=0x6000000
++CONFIG_SYS_LOAD_ADDR=0x48000000
++CONFIG_PRE_CON_BUF_ADDR=0x4007EF00
++CONFIG_DEBUG_UART_BASE=0x11000000
++CONFIG_DEBUG_UART_CLOCK=40000000
++CONFIG_DEBUG_UART=y
++CONFIG_FIT=y
++CONFIG_AUTOBOOT_MENU_SHOW=y
++CONFIG_DEFAULT_FDT_FILE="mt7987a-bpi-r4-lite-emmc-spim-nand"
++CONFIG_SYS_CBSIZE=512
++CONFIG_SYS_PBSIZE=1049
++CONFIG_LOGLEVEL=7
++CONFIG_PRE_CONSOLE_BUFFER=y
++CONFIG_LOG=y
++# CONFIG_BOARD_INIT is not set
++CONFIG_BOARD_LATE_INIT=y
++CONFIG_HUSH_PARSER=y
++CONFIG_SYS_PROMPT="MT7987> "
++CONFIG_CMD_LICENSE=y
++# CONFIG_BOOTM_NETBSD is not set
++# CONFIG_BOOTM_PLAN9 is not set
++# CONFIG_BOOTM_RTEMS is not set
++# CONFIG_BOOTM_VXWORKS is not set
++# CONFIG_CMD_BOOTEFI_BOOTMGR is not set
++CONFIG_CMD_BOOTMENU=y
++# CONFIG_CMD_XIMG is not set
++CONFIG_CMD_ASKENV=y
++CONFIG_CMD_ERASEENV=y
++CONFIG_CMD_ENV_FLAGS=y
++CONFIG_CMD_STRINGS=y
++CONFIG_CMD_CPU=y
++CONFIG_CMD_DM=y
++CONFIG_CMD_GPIO=y
++CONFIG_CMD_PWM=y
++CONFIG_CMD_GPT=y
++CONFIG_CMD_I2C=y
++CONFIG_CMD_MMC=y
++CONFIG_CMD_MTD=y
++CONFIG_CMD_PART=y
++CONFIG_CMD_PCI=y
++CONFIG_CMD_USB=y
++CONFIG_CMD_TFTPSRV=y
++CONFIG_CMD_RARP=y
++CONFIG_CMD_CDP=y
++CONFIG_CMD_SNTP=y
++CONFIG_CMD_LINK_LOCAL=y
++CONFIG_CMD_DHCP=y
++CONFIG_CMD_DNS=y
++CONFIG_CMD_PING=y
++CONFIG_CMD_PXE=y
++CONFIG_CMD_CACHE=y
++CONFIG_CMD_PSTORE=y
++CONFIG_CMD_PSTORE_MEM_ADDR=0x42ff0000
++CONFIG_CMD_UUID=y
++CONFIG_CMD_HASH=y
++CONFIG_CMD_SMC=y
++CONFIG_CMD_EXT4=y
++CONFIG_CMD_FAT=y
++CONFIG_CMD_FS_GENERIC=y
++CONFIG_CMD_FS_UUID=y
++CONFIG_CMD_SF_TEST=y
++CONFIG_CMD_UBI=y
++CONFIG_CMD_UBI_RENAME=y
++CONFIG_ENV_OVERWRITE=y
++CONFIG_ENV_IS_IN_UBI=y
++CONFIG_ENV_REDUNDANT=y
++CONFIG_ENV_UBI_PART="ubi"
++CONFIG_ENV_UBI_VOLUME="ubootenv"
++CONFIG_ENV_UBI_VOLUME_REDUND="ubootenv2"
++CONFIG_ENV_USE_DEFAULT_ENV_TEXT_FILE=y
++CONFIG_ENV_DEFAULT_ENV_TEXT_FILE="defenvs/bananapi_bpi-r4-lite_snand_env"
++CONFIG_ENV_VARS_UBOOT_RUNTIME_CONFIG=y
++CONFIG_VERSION_VARIABLE=y
++CONFIG_NETCONSOLE=y
++CONFIG_USE_IPADDR=y
++CONFIG_IPADDR="192.168.1.1"
++CONFIG_USE_NETMASK=y
++CONFIG_NETMASK="255.255.255.0"
++CONFIG_USE_SERVERIP=y
++CONFIG_SERVERIP="192.168.1.254"
++CONFIG_NET_RANDOM_ETHADDR=y
++CONFIG_BUTTON=y
++CONFIG_BUTTON_GPIO=y
++CONFIG_CLK=y
++CONFIG_DM_I2C=y
++CONFIG_SYS_I2C_MTK=y
++CONFIG_LED=y
++CONFIG_LED_BLINK=y
++CONFIG_LED_GPIO=y
++CONFIG_SUPPORT_EMMC_BOOT=y
++CONFIG_MMC_HS200_SUPPORT=y
++CONFIG_MMC_MTK=y
++CONFIG_MTD=y
++CONFIG_DM_MTD=y
++CONFIG_MTD_SPI_NAND=y
++CONFIG_DM_SPI_FLASH=y
++CONFIG_SPI_FLASH_SFDP_SUPPORT=y
++CONFIG_SPI_FLASH_ATMEL=y
++CONFIG_SPI_FLASH_EON=y
++CONFIG_SPI_FLASH_GIGADEVICE=y
++CONFIG_SPI_FLASH_ISSI=y
++CONFIG_SPI_FLASH_MACRONIX=y
++CONFIG_SPI_FLASH_PUYA=y
++CONFIG_SPI_FLASH_SILICONKAISER=y
++CONFIG_SPI_FLASH_SPANSION=y
++CONFIG_SPI_FLASH_STMICRO=y
++CONFIG_SPI_FLASH_WINBOND=y
++CONFIG_SPI_FLASH_XMC=y
++CONFIG_SPI_FLASH_XTX=y
++CONFIG_SPI_FLASH_ZBIT=y
++CONFIG_SPI_FLASH_MTD=y
++# CONFIG_SPI_FLASH_USE_4K_SECTORS is not set
++CONFIG_MTD_UBI_FASTMAP=y
++CONFIG_PHY_ETHERNET_ID=y
++CONFIG_PHY_FIXED=y
++CONFIG_MEDIATEK_ETH=y
++CONFIG_PHY=y
++CONFIG_PHY_MTK_TPHY=y
++CONFIG_PINCTRL=y
++CONFIG_PINCONF=y
++CONFIG_PINCTRL_MT7987=y
++CONFIG_POWER_DOMAIN=y
++CONFIG_MTK_POWER_DOMAIN=y
++CONFIG_DM_REGULATOR=y
++CONFIG_DM_REGULATOR_FIXED=y
++CONFIG_DM_REGULATOR_GPIO=y
++CONFIG_DM_PWM=y
++CONFIG_PWM_MTK=y
++CONFIG_SCSI=y
++CONFIG_DM_SERIAL=y
++CONFIG_SERIAL_RX_BUFFER=y
++CONFIG_MTK_SERIAL=y
++CONFIG_SPI=y
++CONFIG_DM_SPI=y
++CONFIG_MTK_SPIM=y
++CONFIG_USB=y
++CONFIG_USB_XHCI_HCD=y
++CONFIG_USB_XHCI_MTK=y
++CONFIG_USB_STORAGE=y
++CONFIG_ZSTD=y
++CONFIG_HEXDUMP=y
++# CONFIG_TOOLS_LIBCRYPTO is not set
++# CONFIG_TOOLS_KWBIMAGE is not set
++# CONFIG_TOOLS_MKEFICAPSULE is not set
+--- /dev/null
++++ b/defenvs/bananapi_bpi-r4-lite_sdmmc_env
+@@ -0,0 +1,80 @@
++ipaddr=192.168.1.1
++serverip=192.168.1.254
++loadaddr=0x48000000
++console=earlycon=uart8250,mmio32,0x11000000 console=ttyS0
++bootcmd=if pstore check ; then run boot_recovery ; else run boot_sdmmc ; fi
++bootconf=config-mt7987a-bananapi-bpi-r4-lite
++bootconf_base=config-mt7987a-bananapi-bpi-r4-lite#mt7987a-bananapi-bpi-r4-lite-1pcie-2L
++bootconf_nor=mt7987a-bananapi-bpi-r4-lite-nor
++bootconf_nand=mt7987a-bananapi-bpi-r4-lite-nand
++bootconf_sd=mt7987a-bananapi-bpi-r4-lite-sd
++bootconf_emmc=mt7987a-bananapi-bpi-r4-lite-emmc
++bootdelay=0
++bootfile=openwrt-mediatek-filogic-bananapi_bpi-r4-lite-initramfs-recovery.itb
++bootfile_upg=openwrt-mediatek-filogic-bananapi_bpi-r4-lite-squashfs-sysupgrade.itb
++bootled_pwr=green:status
++bootled_rec=blue:status
++bootmenu_confirm_return=askenv - Press ENTER to return to menu ; bootmenu 60
++bootmenu_default=0
++bootmenu_delay=0
++bootmenu_title=      [0;34m( ( ( [1;39mOpenWrt[0;34m ) ) )  [0;36m[SD card][0m
++bootmenu_0=Initialize environment.=run _firstboot
++bootmenu_0d=Run default boot command.=run boot_default
++bootmenu_1=Boot system via TFTP.=run boot_tftp ; run bootmenu_confirm_return
++bootmenu_2=Boot production system from SD card.=run boot_production ; run bootmenu_confirm_return
++bootmenu_3=Boot recovery system from SD card.=run boot_recovery ; run bootmenu_confirm_return
++bootmenu_4=Load production system via TFTP then write to SD card.=setenv noboot 1 ; setenv replacevol 1 ; run boot_tftp_production ; setenv noboot ; setenv replacevol ; run bootmenu_confirm_return
++bootmenu_5=Load recovery system via TFTP then write to SD card.=setenv noboot 1 ; setenv replacevol 1 ; run boot_tftp_recovery ; setenv noboot ; setenv replacevol ; run bootmenu_confirm_return
++bootmenu_6=[31mInstall bootloader, recovery and production to NOR.[0m=if sf probe ; then run nor_init ; else echo "NOR not detected" ; fi ; run bootmenu_confirm_return
++bootmenu_7=[31mInstall bootloader, recovery and production to NAND.[0m=if nand info ; then run ubi_init ; else echo "NAND not detected" ; fi ; run bootmenu_confirm_return
++bootmenu_8=Reboot.=reset
++bootmenu_9=Reset all settings to factory defaults.=run reset_factory ; reset
++boot_update_conf=if nand info ; then setenv bootconf $bootconf_base#$bootconf_sd#$bootconf_nand ; else if sf probe ; then setenv bootconf $bootconf_base#$bootconf_sd#$bootconf_nor ; else setenv bootconf $bootconf_base#$bootconf_sd ; fi ; fi
++boot_first=if button reset ; then led $bootled_rec on ; run boot_tftp_recovery ; setenv flag_recover 1 ; run boot_default ; fi ; bootmenu
++boot_default=if env exists flag_recover ; then else run bootcmd ; fi ; run boot_recovery ; setenv replacevol 1 ; run boot_tftp_forever
++boot_production=led $bootled_pwr on ; run boot_update_conf ; run sdmmc_read_production && bootm $loadaddr#$bootconf ; led $bootled_pwr off
++boot_recovery=led $bootled_rec on ; run boot_update_conf ; run sdmmc_read_recovery && bootm $loadaddr#$bootconf ; led $bootled_rec off
++boot_sdmmc=run boot_production ; run boot_recovery
++boot_tftp_forever=led $bootled_rec on ; while true ; do run boot_tftp_recovery ; sleep 1 ; done
++boot_tftp_production=run boot_update_conf ; tftpboot $loadaddr $bootfile_upg && env exists replacevol && iminfo $loadaddr && run sdmmc_write_production ; if env exists noboot ; then else bootm $loadaddr#$bootconf ; fi
++boot_tftp_recovery=run boot_update_conf ; tftpboot $loadaddr $bootfile && env exists replacevol && iminfo $loadaddr && run sdmmc_write_recovery ; if env exists noboot ; then else bootm $loadaddr#$bootconf ; fi
++boot_tftp=run boot_update_conf ; tftpboot $loadaddr $bootfile && bootm $loadaddr#$bootconf
++mmc_write_vol=imszb $loadaddr image_size && test 0x$image_size -le 0x$part_size && mmc erase 0x$part_addr 0x$image_size && mmc write $loadaddr 0x$part_addr 0x$image_size
++mmc_read_vol=mmc read $loadaddr $part_addr 0x100 && imszb $loadaddr image_size && test 0x$image_size -le 0x$part_size && mmc read $loadaddr 0x$part_addr 0x$image_size && setexpr filesize $image_size * 0x200
++part_default=production
++part_recovery=recovery
++reset_factory=eraseenv && reset
++sdmmc_read_production=part start mmc 0 $part_default part_addr && part size mmc 0 $part_default part_size && run mmc_read_vol
++sdmmc_read_recovery=part start mmc 0 $part_recovery part_addr && part size mmc 0 $part_recovery part_size && run mmc_read_vol
++sdmmc_read_snand_bl2=part start mmc 0 install part_addr && mmc read $loadaddr $part_addr 0x400
++sdmmc_read_snand_fip=part start mmc 0 install part_addr && setexpr offset $part_addr + 0x800 && mmc read $loadaddr $offset 0x1000
++sdmmc_read_nor_bl2=part start mmc 0 install part_addr && setexpr offset $part_addr + 0x2800 && mmc read $loadaddr $offset 0x400
++sdmmc_read_nor_fip=part start mmc 0 install part_addr && setexpr offset $part_addr + 0x3000 && mmc read $loadaddr $offset 0x1000
++sdmmc_read_emmc_install=part start mmc 0 install part_addr && setexpr offset $part_addr + 0x3800 && mmc read $loadaddr $offset 0x4000
++sdmmc_write_production=part start mmc 0 $part_default part_addr && part size mmc 0 $part_default part_size && run mmc_write_vol
++sdmmc_write_recovery=part start mmc 0 $part_recovery part_addr && part size mmc 0 $part_recovery part_size && run mmc_write_vol
++snand_write_bl2=mtd erase bl2-nand && mtd write bl2-nand $loadaddr 0x0 0x80000 && mtd write bl2-nand $loadaddr 0x80000 0x80000 && mtd write bl2-nand $loadaddr 0x100000 0x80000 && mtd write bl2-nand $loadaddr 0x180000 0x80000
++nor_write_bl2=mtd erase bl2-nor && mtd write bl2-nor $loadaddr
++nor_write_fip=mtd erase fip && mtd write fip $loadaddr
++nor_pad_size=imsz $loadaddr image_size ; setexpr image_eb 0x$image_size / 0x10000 ; setexpr tmp1 0x$image_size % 0x10000 ; test 0x$tmp1 -gt 0 && setexpr image_eb 0x$image_eb + 1 ; setexpr image_eb $image_eb * 0x10000
++nor_erase_env=mtd erase u-boot-env
++nor_write_production=run nor_pad_size ; test 0x$image_eb -le 0xfc0000 && mtd erase fit && mtd write fit $loadaddr 0x0 $image_eb
++nor_write_recovery=run nor_pad_size ; test 0x$image_eb -le 0xe80000 && mtd erase recovery 0x0 0x$image_eb && mtd write recovery $loadaddr 0x0 $image_eb
++nor_init=run nor_init_bl && run nor_init_openwrt
++nor_init_bl=run sdmmc_read_nor_bl2 && run nor_write_bl2 && run sdmmc_read_nor_fip && run nor_write_fip && run nor_erase_env
++nor_init_openwrt=run sdmmc_read_recovery && iminfo $loadaddr && run nor_write_recovery ; run sdmmc_read_production && iminfo $loadaddr && run nor_write_production
++ubi_format=ubi detach ; mtd erase ubi && ubi part ubi
++ubi_init=run ubi_format && run ubi_init_bl && run ubi_init_openwrt && run ubi_init_emmc_install
++ubi_init_openwrt=run sdmmc_read_recovery && iminfo $loadaddr && run ubi_write_recovery ; run sdmmc_read_production && iminfo $loadaddr && run ubi_write_production
++ubi_init_bl=run sdmmc_read_snand_bl2 && run snand_write_bl2 && run sdmmc_read_snand_fip && run ubi_write_fip
++ubi_init_emmc_install=run sdmmc_read_emmc_install && run ubi_write_emmc_install
++ubi_prepare_rootfs=if ubi check rootfs_data ; then else if env exists rootfs_data_max ; then ubi create rootfs_data $rootfs_data_max dynamic || ubi create rootfs_data - dynamic ; else ubi create rootfs_data - dynamic ; fi ; fi
++ubi_remove_rootfs=ubi check rootfs_data && ubi remove rootfs_data
++ubi_write_fip=run ubi_remove_rootfs ; ubi check fip && ubi remove fip ; ubi create fip 0x200000 static ; ubi write $loadaddr fip 0x200000
++ubi_write_emmc_install=ubi check emmc_install && ubi remove emmc_install ; ubi create emmc_install 0x800000 dynamic ; ubi write $loadaddr emmc_install 0x800000
++ubi_write_production=ubi check fit && ubi remove fit ; run ubi_remove_rootfs ; ubi create fit $filesize dynamic && ubi write $loadaddr fit $filesize
++ubi_write_recovery=ubi check recovery && ubi remove recovery ; run ubi_remove_rootfs ; ubi create recovery $filesize dynamic && ubi write $loadaddr recovery $filesize
++_init_env=setenv _init_env ; setenv _create_env ; saveenv ; saveenv
++_firstboot=setenv _firstboot ; run _switch_to_menu ; run _init_env ; run boot_first
++_switch_to_menu=setenv _switch_to_menu ; setenv bootdelay 3 ; setenv bootmenu_delay 3 ; setenv bootmenu_0 $bootmenu_0d ; setenv bootmenu_0d ; run _bootmenu_update_title
++_bootmenu_update_title=setenv _bootmenu_update_title ; setenv bootmenu_title "$bootmenu_title       [33m$ver[0m"
+--- /dev/null
++++ b/defenvs/bananapi_bpi-r4-lite_nor_env
+@@ -0,0 +1,59 @@
++ipaddr=192.168.1.1
++serverip=192.168.1.254
++loadaddr=0x48000000
++console=earlycon=uart8250,mmio32,0x11000000 console=ttyS0
++bootcmd=if pstore check ; then run boot_recovery ; else run boot_nor ; fi
++bootconf=config-mt7987a-bananapi-bpi-r4-lite
++bootconf_base=config-mt7987a-bananapi-bpi-r4-lite#mt7987a-bananapi-bpi-r4-lite-1pcie-2L
++bootconf_nor=mt7987a-bananapi-bpi-r4-lite-nor
++bootconf_nand=mt7987a-bananapi-bpi-r4-lite-nand
++bootconf_sd=mt7987a-bananapi-bpi-r4-lite-sd
++bootconf_emmc=mt7987a-bananapi-bpi-r4-lite-emmc
++bootdelay=0
++bootfile=openwrt-mediatek-filogic-bananapi_bpi-r4-lite-initramfs-recovery.itb
++bootfile_bl2=openwrt-mediatek-filogic-bananapi_bpi-r4-lite-nor-preloader.bin
++bootfile_fip=openwrt-mediatek-filogic-bananapi_bpi-r4-lite-nor-bl31-uboot.fip
++bootfile_upg=openwrt-mediatek-filogic-bananapi_bpi-r4-lite-squashfs-sysupgrade.itb
++bootled_pwr=green:status
++bootled_rec=blue:status
++bootmenu_confirm_return=askenv - Press ENTER to return to menu ; bootmenu 60
++bootmenu_default=0
++bootmenu_delay=0
++bootmenu_title=      [0;34m( ( ( [1;39mOpenWrt[0;34m ) ) )  [0;36m[SPI-NOR][0m
++bootmenu_0=Initialize environment.=run _firstboot
++bootmenu_0d=Run default boot command.=run boot_default
++bootmenu_1=Boot system via TFTP.=run boot_tftp ; run bootmenu_confirm_return
++bootmenu_2=Boot production system from flash.=run boot_production ; run bootmenu_confirm_return
++bootmenu_3=Boot recovery system from flash.=run boot_recovery ; run bootmenu_confirm_return
++bootmenu_4=Load production system via TFTP then write to flash.=setenv noboot 1 ; setenv replacevol 1 ; run boot_tftp_production ; setenv noboot ; setenv replacevol ; run bootmenu_confirm_return
++bootmenu_5=Load recovery system via TFTP then write to flash.=setenv noboot 1 ; setenv replacevol 1 ; run boot_tftp_recovery ; setenv noboot ; setenv replacevol ; run bootmenu_confirm_return
++bootmenu_6=[31mLoad BL31+U-Boot FIP via TFTP then write to flash.[0m=run boot_tftp_write_fip ; run bootmenu_confirm_return
++bootmenu_7=[31mLoad BL2 preloader via TFTP then write to flash.[0m=run boot_tftp_write_bl2 ; run bootmenu_confirm_return
++bootmenu_8=Reboot.=reset
++bootmenu_9=Reset all settings to factory defaults.=run reset_factory ; reset
++boot_first=if button reset ; then led $bootled_rec on ; run boot_tftp_recovery ; setenv flag_recover 1 ; run boot_default ; fi ; bootmenu
++boot_default=if env exists flag_recover ; then else run bootcmd ; fi ; run boot_recovery ; setenv replacevol 1 ; run boot_tftp_forever
++boot_production=run boot_update_conf ; led $bootled_pwr on ; run nor_read_production && bootm $loadaddr#$bootconf ; led $bootled_pwr off
++boot_recovery=run boot_update_conf ; led $bootled_rec on ; run nor_read_recovery ; bootm $loadaddr#$bootconf ; led $bootled_rec off
++boot_serial_write_fip=loadx $loadaddr 115200 && run boot_write_fip
++boot_serial_write_preloader=loadx $loadaddr 115200 && run boot_write_preloader
++boot_tftp_forever=led $bootled_rec on ; while true ; do run boot_tftp_recovery ; sleep 1 ; done
++boot_tftp_production=run boot_update_conf ; tftpboot $loadaddr $bootfile_upg && env exists replacevol && iminfo $loadaddr && run nor_write_production ; if env exists noboot ; then else bootm $loadaddr#$bootconf ; fi
++boot_tftp_recovery=run boot_update_conf ; tftpboot $loadaddr $bootfile && env exists replacevol && iminfo $loadaddr && run nor_write_recovery ; if env exists noboot ; then else bootm $loadaddr#$bootconf ; fi
++boot_tftp=run boot_update_conf ; tftpboot $loadaddr $bootfile && bootm $loadaddr#$bootconf
++boot_tftp_write_fip=tftpboot $loadaddr $bootfile_fip && run nor_write_fip
++boot_tftp_write_bl2=tftpboot $loadaddr $bootfile_bl2 && run nor_write_bl2
++boot_update_conf=if mmc partconf 0 ; then setenv bootconf $bootconf_base#$bootconf_nor#$bootconf_emmc ; else setenv bootconf $bootconf_base#$bootconf_nor#$bootconf_sd ; fi
++boot_nor=run boot_production ; run boot_recovery
++reset_factory=mtd erase u-boot-env
++nor_write_fip=mtd erase fip && mtd write fip $loadaddr
++nor_write_bl2=mtd erase bl2-nor && mtd write bl2-nor $loadaddr
++nor_read_production=mtd read fit $loadaddr 0x0 0x20000 && imsz $loadaddr image_size && mtd read fit $loadaddr 0x0 $image_size
++nor_read_recovery=mtd read recovery $loadaddr 0x0 0x20000 && imsz $loadaddr image_size && mtd read recovery $loadaddr 0x0 $image_size
++nor_pad_size=imsz $loadaddr image_size ; setexpr image_eb 0x$image_size / 0x10000 ; setexpr tmp1 0x$image_size % 0x10000 ; test 0x$tmp1 -gt 0 && setexpr image_eb 0x$image_eb + 1 ; setexpr image_eb $image_eb * 0x10000
++nor_write_production=run nor_pad_size ; test 0x$image_eb -le 0xfc0000 && mtd erase fit && mtd write fit $loadaddr 0x0 $image_eb
++nor_write_recovery=run nor_pad_size ; test 0x$image_eb -le 0xe80000 && mtd erase recovery 0x0 0x$image_eb && mtd write recovery $loadaddr 0x0 $image_eb
++_init_env=setenv _init_env ; saveenv
++_firstboot=setenv _firstboot ; run _switch_to_menu ; run _init_env ; run boot_first
++_switch_to_menu=setenv _switch_to_menu ; setenv bootdelay 3 ; setenv bootmenu_delay 3 ; setenv bootmenu_0 $bootmenu_0d ; setenv bootmenu_0d ; run _bootmenu_update_title
++_bootmenu_update_title=setenv _bootmenu_update_title ; setenv bootmenu_title "$bootmenu_title       [33m$ver[0m"
+--- /dev/null
++++ b/defenvs/bananapi_bpi-r4-lite_snand_env
+@@ -0,0 +1,72 @@
++ipaddr=192.168.1.1
++serverip=192.168.1.254
++loadaddr=0x48000000
++console=earlycon=uart8250,mmio32,0x11000000 console=ttyS0
++bootconf=config-mt7987a-bananapi-bpi-r4-lite
++bootconf_base=config-mt7987a-bananapi-bpi-r4-lite#mt7987a-bananapi-bpi-r4-lite-1pcie-2L
++bootconf_nor=mt7987a-bananapi-bpi-r4-lite-nor
++bootconf_nand=mt7987a-bananapi-bpi-r4-lite-nand
++bootconf_sd=mt7987a-bananapi-bpi-r4-lite-sd
++bootconf_emmc=mt7987a-bananapi-bpi-r4-lite-emmc
++bootcmd=if pstore check ; then run boot_recovery ; else run boot_ubi ; fi
++bootdelay=0
++bootfile=openwrt-mediatek-filogic-bananapi_bpi-r4-lite-initramfs-recovery.itb
++bootfile_bl2=openwrt-mediatek-filogic-bananapi_bpi-r4-lite-snand-preloader.bin
++bootfile_fip=openwrt-mediatek-filogic-bananapi_bpi-r4-lite-snand-bl31-uboot.fip
++bootfile_upg=openwrt-mediatek-filogic-bananapi_bpi-r4-lite-squashfs-sysupgrade.itb
++bootled_pwr=green:status
++bootled_rec=blue:status
++bootmenu_confirm_return=askenv - Press ENTER to return to menu ; bootmenu 60
++bootmenu_default=0
++bootmenu_delay=0
++bootmenu_title=      [0;34m( ( ( [1;39mOpenWrt[0;34m ) ) )  [0;36m[SPI-NAND][0m
++bootmenu_0=Initialize environment.=run _firstboot
++bootmenu_0d=Run default boot command.=run boot_default
++bootmenu_1=Boot system via TFTP.=run boot_tftp ; run bootmenu_confirm_return
++bootmenu_2=Boot production system from NAND.=run boot_production ; run bootmenu_confirm_return
++bootmenu_3=Boot recovery system from NAND.=run boot_recovery ; run bootmenu_confirm_return
++bootmenu_4=Load production system via TFTP then write to NAND.=setenv noboot 1 ; setenv replacevol 1 ; run boot_tftp_production ; setenv noboot ; setenv replacevol ; run bootmenu_confirm_return
++bootmenu_5=Load recovery system via TFTP then write to NAND.=setenv noboot 1 ; setenv replacevol 1 ; run boot_tftp_recovery ; setenv noboot ; setenv replacevol ; run bootmenu_confirm_return
++bootmenu_6=[31mLoad BL31+U-Boot FIP via TFTP then write to NAND.[0m=run boot_tftp_write_fip ; run bootmenu_confirm_return
++bootmenu_7=[31mLoad BL2 preloader via TFTP then write to NAND.[0m=run boot_tftp_write_bl2 ; run bootmenu_confirm_return
++bootmenu_8=[31mInstall bootloader, recovery and production to eMMC.[0m=if mmc partconf 0 ; then run emmc_init ; else echo "eMMC not detected" ; fi ; run bootmenu_confirm_return
++bootmenu_9=Reboot.=reset
++bootmenu_10=Reset all settings to factory defaults.=run reset_factory ; reset
++boot_first=if button reset ; then led $bootled_rec on ; run boot_tftp_recovery ; setenv flag_recover 1 ; run boot_default ; fi ; bootmenu
++boot_default=if env exists flag_recover ; then else run bootcmd ; fi ; run boot_recovery ; setenv replacevol 1 ; run boot_tftp_forever
++boot_production=run boot_update_conf ; led $bootled_pwr on ; run ubi_read_production && bootm $loadaddr#$bootconf ; led $bootled_pwr off
++boot_recovery=run boot_update_conf ; led $bootled_rec on ; run ubi_read_recovery && bootm $loadaddr#$bootconf ; led $bootled_rec off
++boot_ubi=run boot_production ; run boot_recovery
++boot_tftp_forever=led $bootled_rec on ; while true ; do run boot_tftp_recovery ; sleep 1 ; done
++boot_tftp_production=run boot_update_conf ; tftpboot $loadaddr $bootfile_upg && env exists replacevol && iminfo $loadaddr && run ubi_write_production ; if env exists noboot ; then else bootm $loadaddr#$bootconf ; fi
++boot_tftp_recovery=run boot_update_conf ; tftpboot $loadaddr $bootfile && env exists replacevol && iminfo $loadaddr && run ubi_write_recovery ; if env exists noboot ; then else bootm $loadaddr#$bootconf ; fi
++boot_tftp=run boot_update_conf ; tftpboot $loadaddr $bootfile && bootm $loadaddr#$bootconf
++boot_tftp_write_fip=tftpboot $loadaddr $bootfile_fip && run ubi_write_fip && run reset_factory
++boot_tftp_write_bl2=tftpboot $loadaddr $bootfile_bl2 && run snand_write_bl2
++boot_update_conf=if mmc partconf 0 ; then setenv bootconf $bootconf_base#$bootconf_nand#$bootconf_emmc ; else setenv bootconf $bootconf_base#$bootconf_nand#$bootconf_sd ; fi
++part_default=production
++part_recovery=recovery
++reset_factory=ubi part ubi ; mw $loadaddr 0xff 0x1f000 ; ubi write $loadaddr ubootenv 0x1f000 ; ubi write $loadaddr ubootenv2 0x1f000
++snand_write_bl2=mtd erase bl2-nand && mtd write bl2-nand $loadaddr 0x0 0x80000 && mtd write bl2-nand $loadaddr 0x80000 0x80000 && mtd write bl2-nand $loadaddr 0x100000 0x80000 && mtd write bl2-nand $loadaddr 0x180000 0x80000
++ubi_create_env=ubi check ubootenv || ubi create ubootenv 0x1f000 dynamic ; ubi check ubootenv2 || ubi create ubootenv2 0x1f000 dynamic
++ubi_prepare_rootfs=if ubi check rootfs_data ; then else if env exists rootfs_data_max ; then ubi create rootfs_data $rootfs_data_max dynamic || ubi create rootfs_data - dynamic ; else ubi create rootfs_data - dynamic ; fi ; fi
++ubi_read_production=ubi read $loadaddr fit && iminfo $loadaddr && run ubi_prepare_rootfs
++ubi_read_recovery=ubi check recovery && ubi read $loadaddr recovery
++ubi_read_emmc_install=ubi check emmc_install && ubi read $loadaddr emmc_install
++ubi_remove_rootfs=ubi check rootfs_data && ubi remove rootfs_data
++ubi_write_fip=run ubi_remove_rootfs ; ubi check fip && ubi remove fip ; ubi create fip 0x200000 static ; ubi write $loadaddr fip 0x200000
++ubi_write_production=ubi check fit && ubi remove fit ; run ubi_remove_rootfs ; ubi create fit $filesize dynamic && ubi write $loadaddr fit $filesize
++ubi_write_recovery=ubi check recovery && ubi remove recovery ; run ubi_remove_rootfs ; ubi create recovery $filesize dynamic && ubi write $loadaddr recovery $filesize
++mmc_write_vol=imszb $loadaddr image_size && test 0x$image_size -le 0x$part_size && mmc erase 0x$part_addr 0x$image_size && mmc write $loadaddr 0x$part_addr 0x$image_size
++emmc_init=mmc dev 0 && run emmc_init_bl && run emmc_init_openwrt ; env default bootcmd ; saveenv ; saveenv
++emmc_init_bl=run ubi_read_emmc_install && setenv fileaddr $loadaddr && run emmc_write_bl2 && setexpr fileaddr $loadaddr + 0x100000 && run emmc_write_fip && setexpr fileaddr $loadaddr + 0x500000 && run emmc_write_hdr
++emmc_init_openwrt=run ubi_read_recovery && iminfo $loadaddr && run emmc_write_recovery ; run ubi_read_production && iminfo $loadaddr && run emmc_write_production
++emmc_write_bl2=mmc partconf 0 1 1 1 && mmc erase 0x0 0x400 && mmc write $fileaddr 0x0 0x400 ; mmc partconf 0 1 1 0
++emmc_write_fip=mmc erase 0x3400 0x2000 && mmc write $fileaddr 0x3400 0x2000 && mmc erase 0x2000 0x800
++emmc_write_hdr=mmc erase 0x0 0x40 && mmc write $fileaddr 0x0 0x40
++emmc_write_production=part start mmc 0 $part_default part_addr && part size mmc 0 $part_default part_size && run mmc_write_vol
++emmc_write_recovery=part start mmc 0 $part_recovery part_addr && part size mmc 0 $part_recovery part_size && run mmc_write_vol
++_init_env=setenv _init_env ; run ubi_create_env ; saveenv ; saveenv
++_firstboot=setenv _firstboot ; run _switch_to_menu ; run _init_env ; run boot_first
++_switch_to_menu=setenv _switch_to_menu ; setenv bootdelay 3 ; setenv bootmenu_delay 3 ; setenv bootmenu_0 $bootmenu_0d ; setenv bootmenu_0d ; run _bootmenu_update_title
++_bootmenu_update_title=setenv _bootmenu_update_title ; setenv bootmenu_title "$bootmenu_title       [33m$ver[0m"
+--- /dev/null
++++ b/defenvs/bananapi_bpi-r4-lite_emmc_env
+@@ -0,0 +1,60 @@
++ipaddr=192.168.1.1
++serverip=192.168.1.254
++loadaddr=0x48000000
++console=earlycon=uart8250,mmio32,0x11000000 console=ttyS0
++bootcmd=if pstore check ; then run boot_recovery ; else run boot_emmc ; fi
++bootconf=config-mt7987a-bananapi-bpi-r4-lite
++bootconf_base=config-mt7987a-bananapi-bpi-r4-lite#mt7987a-bananapi-bpi-r4-lite-1pcie-2L
++bootconf_nor=mt7987a-bananapi-bpi-r4-lite-nor
++bootconf_nand=mt7987a-bananapi-bpi-r4-lite-nand
++bootconf_sd=mt7987a-bananapi-bpi-r4-lite-sd
++bootconf_emmc=mt7987a-bananapi-bpi-r4-lite-emmc
++bootdelay=0
++bootfile=openwrt-mediatek-filogic-bananapi_bpi-r4-lite-initramfs-recovery.itb
++bootfile_bl2=openwrt-mediatek-filogic-bananapi_bpi-r4-lite-emmc-preloader.bin
++bootfile_fip=openwrt-mediatek-filogic-bananapi_bpi-r4-lite-emmc-bl31-uboot.fip
++bootfile_upg=openwrt-mediatek-filogic-bananapi_bpi-r4-lite-squashfs-sysupgrade.itb
++bootled_pwr=green:status
++bootled_rec=blue:status
++bootmenu_confirm_return=askenv - Press ENTER to return to menu ; bootmenu 60
++bootmenu_default=0
++bootmenu_delay=0
++bootmenu_title=      [0;34m( ( ( [1;39mOpenWrt[0;34m ) ) )  [0;36m[eMMC][0m
++bootmenu_0=Initialize environment.=run _firstboot
++bootmenu_0d=Run default boot command.=run boot_default
++bootmenu_1=Boot system via TFTP.=run boot_tftp ; run bootmenu_confirm_return
++bootmenu_2=Boot production system from eMMC.=run boot_production ; run bootmenu_confirm_return
++bootmenu_3=Boot recovery system from eMMC.=run boot_recovery ; run bootmenu_confirm_return
++bootmenu_4=Load production system via TFTP then write to eMMC.=setenv noboot 1 ; setenv replacevol 1 ; run boot_tftp_production ; setenv noboot ; setenv replacevol ; run bootmenu_confirm_return
++bootmenu_5=Load recovery system via TFTP then write to eMMC.=setenv noboot 1 ; setenv replacevol 1 ; run boot_tftp_recovery ; setenv noboot ; setenv replacevol ; run bootmenu_confirm_return
++bootmenu_6=[31mLoad BL31+U-Boot FIP via TFTP then write to eMMC.[0m=run boot_tftp_write_fip ; run bootmenu_confirm_return
++bootmenu_7=[31mLoad BL2 preloader via TFTP then write to eMMC.[0m=run boot_tftp_write_bl2 ; run bootmenu_confirm_return
++bootmenu_8=Reboot.=reset
++bootmenu_9=Reset all settings to factory defaults.=run reset_factory ; reset
++boot_first=if button reset ; then led $bootled_rec on ; run boot_tftp_recovery ; setenv flag_recover 1 ; run boot_default ; fi ; bootmenu
++boot_default=if env exists flag_recover ; then else run bootcmd ; fi ; run boot_recovery ; setenv replacevol 1 ; run boot_tftp_forever
++boot_production=run boot_update_conf ; led $bootled_pwr on ; run emmc_read_production && bootm $loadaddr#$bootconf ; led $bootled_pwr off
++boot_recovery=run boot_update_conf ; led $bootled_rec on ; run emmc_read_recovery && bootm $loadaddr#$bootconf ; led $bootled_rec off
++boot_emmc=run boot_production ; run boot_recovery
++boot_tftp_forever=led $bootled_rec on ; while true ; do run boot_tftp_recovery ; sleep 1 ; done
++boot_tftp_production=run boot_update_conf ; tftpboot $loadaddr $bootfile_upg && env exists replacevol && iminfo $loadaddr && run emmc_write_production ; if env exists noboot ; then else bootm $loadaddr#$bootconf ; fi
++boot_tftp_recovery=run boot_update_conf ; tftpboot $loadaddr $bootfile && env exists replacevol && iminfo $loadaddr && run emmc_write_recovery ; if env exists noboot ; then else bootm $loadaddr#$bootconf ; fi
++boot_tftp_write_fip=tftpboot $loadaddr $bootfile_fip && run emmc_write_fip
++boot_tftp_write_bl2=tftpboot $loadaddr $bootfile_bl2 && run emmc_write_bl2
++boot_tftp=run boot_update_conf ; tftpboot $loadaddr $bootfile && bootm $loadaddr#$bootconf
++boot_update_conf=if nand info ; then setenv bootconf $bootconf_base#$bootconf_emmc#$bootconf_nand ; else setenv bootconf $bootconf_base#$bootconf_emmc#$bootconf_nor ; fi
++mmc_write_vol=imszb $loadaddr image_size && test 0x$image_size -le 0x$part_size && mmc erase 0x$part_addr 0x$image_size && mmc write $loadaddr 0x$part_addr 0x$image_size
++mmc_read_vol=mmc read $loadaddr $part_addr 0x100 && imszb $loadaddr image_size && test 0x$image_size -le 0x$part_size && mmc read $loadaddr 0x$part_addr 0x$image_size && setexpr filesize $image_size * 0x200
++part_default=production
++part_recovery=recovery
++reset_factory=eraseenv && reset
++emmc_read_production=part start mmc 0 $part_default part_addr && part size mmc 0 $part_default part_size && run mmc_read_vol
++emmc_read_recovery=part start mmc 0 $part_recovery part_addr && part size mmc 0 $part_recovery part_size && run mmc_read_vol
++emmc_write_bl2=mmc partconf 0 1 1 1 && mmc erase 0x0 0x400 && mmc write $fileaddr 0x0 0x400 ; mmc partconf 0 1 1 0
++emmc_write_fip=mmc erase 0x3400 0x2000 && mmc write $fileaddr 0x3400 0x2000 && mmc erase 0x2000 0x800
++emmc_write_production=part start mmc 0 $part_default part_addr && part size mmc 0 $part_default part_size && run mmc_write_vol
++emmc_write_recovery=part start mmc 0 $part_recovery part_addr && part size mmc 0 $part_recovery part_size && run mmc_write_vol
++_init_env=setenv _init_env ; setenv _create_env ; saveenv ; saveenv
++_firstboot=setenv _firstboot ; run _switch_to_menu ; run _init_env ; run boot_first
++_switch_to_menu=setenv _switch_to_menu ; setenv bootdelay 3 ; setenv bootmenu_delay 3 ; setenv bootmenu_0 $bootmenu_0d ; setenv bootmenu_0d ; run _bootmenu_update_title
++_bootmenu_update_title=setenv _bootmenu_update_title ; setenv bootmenu_title "$bootmenu_title       [33m$ver[0m"
+--- /dev/null
++++ b/arch/arm/dts/mt7987a-bpi-r4-lite-sd.dts
+@@ -0,0 +1,30 @@
++// SPDX-License-Identifier: (GPL-2.0 OR MIT)
++
++/dts-v1/;
++#include "mt7987a.dtsi"
++#include "mt7987-sd.dtsi"
++#include <dt-bindings/input/input.h>
++
++/ {
++	model = "BananaPi BPi-R4 Lite";
++	compatible = "mediatek,mt7987a-sd",
++		     "mediatek,mt7987a", "mediatek,mt7987";
++
++	gpio-keys {
++		compatible = "gpio-keys";
++
++		reset {
++			label = "reset";
++			linux,code = <KEY_RESTART>;
++			gpios = <&pio 1 GPIO_ACTIVE_LOW>;
++			debounce-interval = <10>;
++		};
++
++		wps {
++			label = "wps";
++			linux,code = <KEY_WPS_BUTTON>;
++			gpios = <&pio 0 GPIO_ACTIVE_LOW>;
++			debounce-interval = <10>;
++		};
++	};
++};
+--- /dev/null
++++ b/arch/arm/dts/mt7987a-bpi-r4-lite-spim-nand.dts
+@@ -0,0 +1,30 @@
++// SPDX-License-Identifier: (GPL-2.0 OR MIT)
++
++/dts-v1/;
++#include "mt7987a.dtsi"
++#include "mt7987-emmc.dtsi"
++#include <dt-bindings/input/input.h>
++
++/ {
++	model = "BananaPi BPi-R4 Lite";
++	compatible = "mediatek,mt7987a-emmc",
++		     "mediatek,mt7987a", "mediatek,mt7987";
++
++	gpio-keys {
++		compatible = "gpio-keys";
++
++		reset {
++			label = "reset";
++			linux,code = <KEY_RESTART>;
++			gpios = <&pio 1 GPIO_ACTIVE_LOW>;
++			debounce-interval = <10>;
++		};
++
++		wps {
++			label = "wps";
++			linux,code = <KEY_WPS_BUTTON>;
++			gpios = <&pio 0 GPIO_ACTIVE_LOW>;
++			debounce-interval = <10>;
++		};
++	};
++};
+--- /dev/null
++++ b/arch/arm/dts/mt7987a-bpi-r4-lite-emmc.dts
+@@ -0,0 +1,30 @@
++// SPDX-License-Identifier: (GPL-2.0 OR MIT)
++
++/dts-v1/;
++#include "mt7987a.dtsi"
++#include "mt7987-emmc.dtsi"
++#include <dt-bindings/input/input.h>
++
++/ {
++	model = "BananaPi BPi-R4 Lite";
++	compatible = "mediatek,mt7987a-emmc",
++		     "mediatek,mt7987a", "mediatek,mt7987";
++
++	gpio-keys {
++		compatible = "gpio-keys";
++
++		reset {
++			label = "reset";
++			linux,code = <KEY_RESTART>;
++			gpios = <&pio 1 GPIO_ACTIVE_LOW>;
++			debounce-interval = <10>;
++		};
++
++		wps {
++			label = "wps";
++			linux,code = <KEY_WPS_BUTTON>;
++			gpios = <&pio 0 GPIO_ACTIVE_LOW>;
++			debounce-interval = <10>;
++		};
++	};
++};
+--- a/arch/arm/dts/Makefile
++++ b/arch/arm/dts/Makefile
+@@ -1136,6 +1136,9 @@ dtb-$(CONFIG_ARCH_MEDIATEK) += \
+ 	mt7986b-sd-rfb.dtb \
+ 	mt7986a-emmc-rfb.dtb \
+ 	mt7986b-emmc-rfb.dtb \
++	mt7987a-bpi-r4-lite-spim-nand.dtb \
++	mt7987a-bpi-r4-lite-emmc.dtb \
++	mt7987a-bpi-r4-lite-sd.dtb \
+ 	mt7987a-emmc-rfb.dtb \
+ 	mt7987a-rfb.dtb \
+ 	mt7987a-sd-rfb.dtb \
+--- /dev/null
++++ b/arch/arm/dts/mt7987a-bpi-r4-lite-emmc-u-boot.dtsi
+@@ -0,0 +1,123 @@
++// SPDX-License-Identifier: GPL-2.0
++
++#include "mt7987a-u-boot.dtsi"
++#include "mt7987-netsys-u-boot.dtsi"
++
++/ {
++	model = "mt7987";
++	compatible = "bananapi,bpi-r4-lite-emmc", "mediatek,mt7987";
++};
++
++&eth0 {
++	status = "okay";
++	pinctrl-names = "default";
++	pinctrl-0 = <&mdio0_pins>;
++	phy-mode = "2500base-x";
++	mediatek,switch = "auto";
++	reset-gpios = <&pio 42 GPIO_ACTIVE_HIGH>;
++
++	fixed-link {
++		speed = <2500>;
++		full-duplex;
++		pause;
++	};
++};
++
++&mmc0 {
++	pinctrl-names = "default";
++	pinctrl-0 = <&mmc_pins_default>;
++	max-frequency = <48000000>;
++	bus-width = <4>;
++	cap-mmc-highspeed;
++	cap-mmc-hw-reset;
++	vmmc-supply = <&reg_3p3v>;
++	vqmmc-supply = <&reg_3p3v>;
++	non-removable;
++	status = "okay";
++};
++
++&spi2 {
++	pinctrl-names = "default";
++	pinctrl-0 = <&spi2_flash_pins>;
++	#address-cells = <1>;
++	#size-cells = <0>;
++	status = "okay";
++	must_tx;
++	enhance_timing;
++	dma_ext;
++	ipm_design;
++	support_quad;
++	tick_dly = <2>;
++	sample_sel = <0>;
++
++	/delete-node/ spi_nor@0;
++	spi_nor@0 {
++		compatible = "jedec,spi-nor";
++		reg = <0>;
++		spi-max-frequency = <52000000>;
++		spi-rx-bus-width = <4>;
++		spi-tx-bus-width = <4>;
++
++		partitions {
++			compatible = "fixed-partitions";
++			#address-cells = <1>;
++			#size-cells = <1>;
++
++			partition@0 {
++				label = "bl2-nor";
++				reg = <0x0 0x40000>;
++			};
++
++			partition@40000 {
++				label = "u-boot-env";
++				reg = <0x40000 0x40000>;
++			};
++
++			partition@50000 {
++				label = "factory";
++				reg = <0x80000 0x80000>;
++				read-only;
++			};
++
++			partition@100000 {
++				label = "fip";
++				reg = <0x100000 0x80000>;
++			};
++
++			partition@180000 {
++				label = "recovery";
++				reg = <0x180000 0xe80000>;
++			};
++
++			partition@1000000 {
++				label = "fit";
++				reg = <0x1000000 0x1000000>;
++			};
++		};
++	};
++
++	spi_nand@0 {
++		compatible = "spi-nand";
++		reg = <0>;
++		spi-max-frequency = <52000000>;
++		spi-rx-bus-width = <4>;
++		spi-tx-bus-width = <4>;
++
++		partitions {
++			compatible = "fixed-partitions";
++			#address-cells = <1>;
++			#size-cells = <1>;
++
++			partition@0 {
++				label = "bl2-nand";
++				reg = <0x0 0x200000>;
++			};
++
++			partition@200000 {
++				label = "ubi";
++				reg = <0x200000 0xfe00000>;
++				compatible = "linux,ubi";
++			};
++		};
++	};
++};
+--- /dev/null
++++ b/arch/arm/dts/mt7987a-bpi-r4-lite-spim-nand-u-boot.dtsi
+@@ -0,0 +1,69 @@
++// SPDX-License-Identifier: GPL-2.0
++/*
++ * Copyright (c) 2025 MediaTek Inc.
++ * Author: Sam Shih <sam.shih@mediatek.com>
++ */
++
++#include "mt7987a-u-boot.dtsi"
++#include "mt7987-netsys-u-boot.dtsi"
++
++/ {
++	model = "mt7987";
++	compatible = "bananapi,bpi-r4-lite-spim-nand", "mediatek,mt7987";
++};
++
++&eth0 {
++	status = "okay";
++	pinctrl-names = "default";
++	pinctrl-0 = <&mdio0_pins>;
++	phy-mode = "2500base-x";
++	mediatek,switch = "auto";
++	reset-gpios = <&pio 42 GPIO_ACTIVE_HIGH>;
++
++	fixed-link {
++		speed = <2500>;
++		full-duplex;
++		pause;
++	};
++};
++
++&spi2 {
++	pinctrl-names = "default";
++	pinctrl-0 = <&spi2_flash_pins>;
++	#address-cells = <1>;
++	#size-cells = <0>;
++	status = "okay";
++	must_tx;
++	enhance_timing;
++	dma_ext;
++	ipm_design;
++	support_quad;
++	tick_dly = <2>;
++	sample_sel = <0>;
++
++	/delete-node/ spi_nor@0;
++	spi_nand@0 {
++		compatible = "spi-nand";
++		reg = <0>;
++		spi-max-frequency = <52000000>;
++		spi-rx-bus-width = <4>;
++		spi-tx-bus-width = <4>;
++
++		partitions {
++			compatible = "fixed-partitions";
++			#address-cells = <1>;
++			#size-cells = <1>;
++
++			partition@0 {
++				label = "bl2-nand";
++				reg = <0x0 0x200000>;
++			};
++
++			partition@200000 {
++				label = "ubi";
++				reg = <0x200000 0xfe00000>;
++				compatible = "linux,ubi";
++			};
++		};
++	};
++};
+--- /dev/null
++++ b/arch/arm/dts/mt7987a-bpi-r4-lite-sd-u-boot.dtsi
+@@ -0,0 +1,121 @@
++// SPDX-License-Identifier: GPL-2.0
++
++#include "mt7987a-u-boot.dtsi"
++#include "mt7987-netsys-u-boot.dtsi"
++
++/ {
++	model = "mt7987";
++	compatible = "bananapi,bpi-r4-lite-sd", "mediatek,mt7987";
++};
++
++&eth0 {
++	status = "okay";
++	pinctrl-names = "default";
++	pinctrl-0 = <&mdio0_pins>;
++	phy-mode = "2500base-x";
++	mediatek,switch = "auto";
++	reset-gpios = <&pio 42 GPIO_ACTIVE_HIGH>;
++
++	fixed-link {
++		speed = <2500>;
++		full-duplex;
++		pause;
++	};
++};
++
++&mmc0 {
++	pinctrl-names = "default";
++	pinctrl-0 = <&sd_pins_default>;
++	max-frequency = <48000000>;
++	bus-width = <4>;
++	cap-sd-highspeed;
++	vmmc-supply = <&reg_3p3v>;
++	vqmmc-supply = <&reg_3p3v>;
++	status = "okay";
++};
++
++&spi2 {
++	pinctrl-names = "default";
++	pinctrl-0 = <&spi2_flash_pins>;
++	#address-cells = <1>;
++	#size-cells = <0>;
++	status = "okay";
++	must_tx;
++	enhance_timing;
++	dma_ext;
++	ipm_design;
++	support_quad;
++	tick_dly = <2>;
++	sample_sel = <0>;
++
++	/delete-node/ spi_nor@0;
++	spi_nor@0 {
++		compatible = "jedec,spi-nor";
++		reg = <0>;
++		spi-max-frequency = <52000000>;
++		spi-rx-bus-width = <4>;
++		spi-tx-bus-width = <4>;
++
++		partitions {
++			compatible = "fixed-partitions";
++			#address-cells = <1>;
++			#size-cells = <1>;
++
++			partition@0 {
++				label = "bl2-nor";
++				reg = <0x0 0x40000>;
++			};
++
++			partition@40000 {
++				label = "u-boot-env";
++				reg = <0x40000 0x40000>;
++			};
++
++			partition@50000 {
++				label = "factory";
++				reg = <0x80000 0x80000>;
++				read-only;
++			};
++
++			partition@100000 {
++				label = "fip";
++				reg = <0x100000 0x80000>;
++			};
++
++			partition@180000 {
++				label = "recovery";
++				reg = <0x180000 0xe80000>;
++			};
++
++			partition@1000000 {
++				label = "fit";
++				reg = <0x1000000 0x1000000>;
++			};
++		};
++	};
++
++	spi_nand@0 {
++		compatible = "spi-nand";
++		reg = <0>;
++		spi-max-frequency = <52000000>;
++		spi-rx-bus-width = <4>;
++		spi-tx-bus-width = <4>;
++
++		partitions {
++			compatible = "fixed-partitions";
++			#address-cells = <1>;
++			#size-cells = <1>;
++
++			partition@0 {
++				label = "bl2-nand";
++				reg = <0x0 0x200000>;
++			};
++
++			partition@200000 {
++				label = "ubi";
++				reg = <0x200000 0xfe00000>;
++				compatible = "linux,ubi";
++			};
++		};
++	};
++};
--- a/target/linux/mediatek/base-files/etc/uci-defaults/99_fwenv-store-ethaddr.sh
+++ b/target/linux/mediatek/base-files/etc/uci-defaults/99_fwenv-store-ethaddr.sh
@@ -13,6 +13,7 @@ bananapi,bpi-r3|\
 bananapi,bpi-r3-mini|\
 bananapi,bpi-r4|\
 bananapi,bpi-r4-2g5|\
+bananapi,bpi-r4-lite|\
 bananapi,bpi-r4-poe)
 	[ -z "$(fw_printenv -n ethaddr 2>/dev/null)" ] &&
 		fw_setenv ethaddr "$(cat /sys/class/net/eth0/address)"
--- /dev/null
+++ b/target/linux/mediatek/dts/mt7987a-bananapi-bpi-r4-lite-1pcie-2L.dtso
@@ -0,0 +1,35 @@
+// SPDX-License-Identifier: (GPL-2.0 OR MIT)
+/*
+ * Copyright (C) 2025 MediaTek Inc.
+ * Author: Sam.Shih <sam.shih@mediatek.com>
+ */
+
+/dts-v1/;
+/plugin/;
+
+#include <dt-bindings/gpio/gpio.h>
+
+/ {
+	compatible = "bananapi,bpi-r4-lite",
+		     "mediatek,mt7987a", "mediatek,mt7987";
+};
+
+/ {
+	fragment@0 {
+		target-path = "/soc/pinctrl@1001f000";
+		__overlay__ {
+			pcie_sel: aw35710qnr_sel {
+				gpio-hog;
+				gpios = <11 GPIO_ACTIVE_HIGH>;
+				output-high;
+			};
+		};
+	};
+
+	fragment@1 {
+		target-path = "/soc/pcie@11290000";
+		__overlay__ {
+			status = "disabled";
+		};
+	};
+};
--- /dev/null
+++ b/target/linux/mediatek/dts/mt7987a-bananapi-bpi-r4-lite-2pcie-1L.dtso
@@ -0,0 +1,36 @@
+// SPDX-License-Identifier: (GPL-2.0 OR MIT)
+/*
+ * Copyright (C) 2025 MediaTek Inc.
+ * Author: Sam.Shih <sam.shih@mediatek.com>
+ */
+
+/dts-v1/;
+/plugin/;
+
+#include <dt-bindings/gpio/gpio.h>
+
+/ {
+	compatible = "bananapi,bpi-r4-lite",
+		     "mediatek,mt7987a", "mediatek,mt7987";
+};
+
+/ {
+	fragment@0 {
+		target-path = "/soc/pinctrl@1001f000";
+		__overlay__ {
+			pcie_sel: aw35710qnr_sel {
+				gpio-hog;
+				gpios = <11 GPIO_ACTIVE_HIGH>;
+				output-low;
+			};
+		};
+	};
+
+	fragment@1 {
+		target-path = "/soc/pcie@11290000";
+		__overlay__ {
+			status = "okay";
+		};
+	};
+};
+
--- /dev/null
+++ b/target/linux/mediatek/dts/mt7987a-bananapi-bpi-r4-lite-emmc.dtso
@@ -0,0 +1,56 @@
+/dts-v1/;
+/plugin/;
+
+#include <dt-bindings/gpio/gpio.h>
+
+/ {
+	compatible = "bananapi,bpi-r4-lite",
+		     "mediatek,mt7987a", "mediatek,mt7987";
+};
+
+&{/soc/mmc@11230000} {
+	pinctrl-names = "default", "state_uhs";
+	pinctrl-0 = <&mmc_pins_default>;
+	pinctrl-1 = <&mmc_pins_uhs>;
+	reset-gpios = <&pio 14 GPIO_ACTIVE_LOW>;
+
+	bus-width = <4>; /* interference from shared DAT5<->SD-CD pin */
+	max-frequency = <48000000>;
+	cap-mmc-highspeed;
+//	mmc-ddr-1_8v;
+//	mmc-hs200-1_8v;
+	non-removable;
+	no-sd;
+	no-sdio;
+	vmmc-supply = <&reg_3p3v>;
+	vqmmc-supply = <&reg_3p3v>;
+
+	#address-cells = <1>;
+	#size-cells = <0>;
+
+	status = "okay";
+
+	card@0 {
+		compatible = "mmc-card";
+		reg = <0>;
+
+		partitions {
+			compatible = "gpt-partitions";
+
+			block-partition-env {
+				partname = "ubootenv";
+				nvmem-layout {
+					compatible = "u-boot,env-layout";
+				};
+			};
+
+			emmc_rootfs: block-partition-production {
+				partname = "production";
+			};
+		};
+	};
+};
+
+&{/chosen} {
+	rootdisk-emmc = <&emmc_rootfs>;
+};
--- /dev/null
+++ b/target/linux/mediatek/dts/mt7987a-bananapi-bpi-r4-lite-mikrobus.dtsi
@@ -0,0 +1,134 @@
+// SPDX-License-Identifier: (GPL-2.0 OR MIT)
+/*
+ * Copyright (C) 2025 MediaTek Inc.
+ * Author: Sam.Shih <sam.shih@mediatek.com>
+ */
+
+#include <dt-bindings/gpio/gpio.h>
+
+/*
+ * --------------- Bananapi Bpi R4 Lite MikroBus ----------------
+ * | 9  |                           GPIO7/PWM1              | 8 |
+ * | 10 | GPIO6/PCM_FS/UART1_RTS    GPIO5/PCM_CLK/UART1_CTS | 7 |
+ * | 11 | GPIO49/SPI1_CS            GPIO3/PCM_DTX/UART1_RXD | 6 |
+ * | 12 | GPIO46/SPI1_CLK           GPIO4/PCM_DRX/UART1_TXD | 5 |
+ * | 13 | GPIO48/SPI1_MISO          I2C3 SCL (PCA9548)      | 4 |
+ * | 14 | GPIO47/SPI1_MOSI          I2C3 SDA (PCA9548)      | 3 |
+ * | 15 | +3.3V                     +5V                     | 2 |
+ * | 16 | GND                       GND                     | 1 |
+ * --------------------------------------------------------------
+ */
+
+/ {
+	mikrobus: MikroBus {
+		compatible = "simple-bus";
+
+		/* MikroBus pins 5,6,7,8 as GPIOs */
+		mikrobus_gpios_0: gpio-export@0 {
+			compatible = "gpio-export";
+			status = "disabled";
+
+			gpio-3 {
+				gpio-export,name = "mikrobus-gpio-RX";
+				gpio-export,output = <1>;
+				gpios = <&pio 3 GPIO_ACTIVE_HIGH>;
+			};
+
+			gpio-4 {
+				gpio-export,name = "mikrobus-gpio-TX";
+				gpio-export,output = <1>;
+				gpios = <&pio 4 GPIO_ACTIVE_HIGH>;
+			};
+
+			gpio-5 {
+				gpio-export,name = "mikrobus-gpio-INT";
+				gpio-export,output = <1>;
+				gpios = <&pio 5 GPIO_ACTIVE_HIGH>;
+			};
+
+			gpio-6 {
+				gpio-export,name = "mikrobus-gpio-INT";
+				gpio-export,output = <1>;
+				gpios = <&pio 5 GPIO_ACTIVE_HIGH>;
+			};
+		};
+
+		/* MikroBus pins 11,12,13,14 as GPIOs */
+		mikrobus_gpios_1: gpio-export@1 {
+			compatible = "gpio-export";
+			status = "disabled";
+
+			gpio-46 {
+				gpio-export,name = "mikrobus-gpio-CS";
+				gpio-export,output = <1>;
+				gpios = <&pio 46 GPIO_ACTIVE_HIGH>;
+			};
+
+			gpio-47 {
+				gpio-export,name = "mikrobus-gpio-MOSI";
+				gpio-export,output = <1>;
+				gpios = <&pio 47 GPIO_ACTIVE_HIGH>;
+			};
+
+			gpio-48 {
+				gpio-export,name = "mikrobus-gpio-MISO";
+				gpio-export,output = <1>;
+				gpios = <&pio 48 GPIO_ACTIVE_HIGH>;
+			};
+
+			gpio-49 {
+				gpio-export,name = "mikrobus-gpio-SCK";
+				gpio-export,output = <1>;
+				gpios = <&pio 49 GPIO_ACTIVE_HIGH>;
+			};
+		};
+	};
+};
+
+/* MikroBus pins 3,4 as I2C3 (Provided by PCA9548 i2c-mux) */
+/* Please refer to &imux2_MikroBus device tree node */
+
+/* MikroBus pins 5,6,7,10 as PCM function */
+&afe {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pcm_pins>;
+	status = "disabled";
+};
+
+&pcm_pins {
+	mux {
+		function = "pcm";
+		groups = "pcm0_0";
+	};
+};
+
+/* MikroBus pins 5,6,7,10 as UART1 function */
+&uart1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&uart1_pins>;
+	status = "okay";
+};
+
+&uart1_pins {
+	mux {
+		function = "uart";
+		groups = "uart1_0";
+	};
+};
+
+/* MikroBus pins 8 as PWM1 */
+/* Please refer to &pwm device tree node */
+
+/* MikroBus pins 11,12,13,14 as SPI1 function */
+&spi1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&spic_pins>;
+	status = "okay";
+};
+
+&spic_pins {
+	mux {
+		function = "spi";
+		groups = "spi1_1";
+	};
+};
--- /dev/null
+++ b/target/linux/mediatek/dts/mt7987a-bananapi-bpi-r4-lite-nand.dtso
@@ -0,0 +1,61 @@
+/dts-v1/;
+/plugin/;
+
+/ {
+	compatible = "bananapi,bpi-r4-lite",
+		     "mediatek,mt7987a", "mediatek,mt7987";
+};
+
+&{/soc/spi@11009800} {
+	#address-cells = <1>;
+	#size-cells = <0>;
+
+	flash@0 {
+		compatible = "spi-nand";
+		reg = <0>;
+		spi-max-frequency = <52000000>;
+		spi-rx-bus-width = <4>;
+		spi-tx-bus-width = <4>;
+
+		partitions {
+			compatible = "fixed-partitions";
+			#address-cells = <1>;
+			#size-cells = <1>;
+
+			partition@0 {
+				label = "bl2-nand";
+				reg = <0x0 0x200000>;
+			};
+
+			partition@200000 {
+				label = "ubi";
+				reg = <0x200000 0xfe00000>;
+				compatible = "linux,ubi";
+
+				volumes {
+					ubi-volume-ubootenv {
+						volname = "ubootenv";
+						nvmem-layout {
+							compatible = "u-boot,env-redundant-bool-layout";
+						};
+					};
+
+					ubi-volume-ubootenv2 {
+						volname = "ubootenv2";
+						nvmem-layout {
+							compatible = "u-boot,env-redundant-bool-layout";
+						};
+					};
+
+					ubi_rootfs: ubi-volume-fit {
+						volname = "fit";
+					};
+				};
+			};
+		};
+	};
+};
+
+&{/chosen} {
+	rootdisk-spim-nand = <&ubi_rootfs>;
+};
--- /dev/null
+++ b/target/linux/mediatek/dts/mt7987a-bananapi-bpi-r4-lite-nor.dtso
@@ -0,0 +1,63 @@
+/dts-v1/;
+/plugin/;
+
+/ {
+	compatible = "bananapi,bpi-r4-lite",
+		     "mediatek,mt7987a", "mediatek,mt7987";
+};
+
+&{/soc/spi@11009800} {
+	#address-cells = <1>;
+	#size-cells = <0>;
+
+	flash@0 {
+		compatible = "jedec,spi-nor";
+		reg = <0>;
+		spi-max-frequency = <52000000>;
+		spi-rx-bus-width = <4>;
+		spi-tx-bus-width = <4>;
+
+		partitions {
+			compatible = "fixed-partitions";
+			#address-cells = <1>;
+			#size-cells = <1>;
+
+			partition@0 {
+				label = "bl2-nor";
+				reg = <0x0 0x40000>;
+				read-only;
+			};
+
+			partition@40000 {
+				label = "u-boot-env";
+				reg = <0x40000 0x40000>;
+			};
+
+			partition@50000 {
+				label = "factory";
+				reg = <0x80000 0x80000>;
+				read-only;
+			};
+
+			partition@100000 {
+				label = "fip";
+				reg = <0x100000 0x80000>;
+			};
+
+			partition@180000 {
+				label = "recovery";
+				reg = <0x180000 0xe80000>;
+			};
+
+			nor_rootfs: partition@1000000 {
+				label = "fit";
+				reg = <0x1000000 0x1000000>;
+				compatible = "denx,fit";
+			};
+		};
+	};
+};
+
+&{/chosen} {
+	rootdisk-nor = <&nor_rootfs>;
+};
--- /dev/null
+++ b/target/linux/mediatek/dts/mt7987a-bananapi-bpi-r4-lite-sd.dtso
@@ -0,0 +1,53 @@
+/dts-v1/;
+/plugin/;
+
+#include <dt-bindings/gpio/gpio.h>
+
+/ {
+	compatible = "bananapi,bpi-r4-lite",
+		     "mediatek,mt7987a", "mediatek,mt7987";
+};
+
+&{/soc/mmc@11230000} {
+	pinctrl-names = "default", "state_uhs";
+	pinctrl-0 = <&sd_pins_default>;
+	pinctrl-1 = <&sd_pins_uhs>;
+	cd-gpios = <&pio 20 GPIO_ACTIVE_LOW>;
+
+	bus-width = <4>;
+	max-frequency = <48000000>;
+	cap-sd-highspeed;
+	no-mmc;
+	no-sdio;
+	vmmc-supply = <&reg_3p3v>;
+	vqmmc-supply = <&reg_3p3v>;
+
+	#address-cells = <1>;
+	#size-cells = <0>;
+
+	status = "okay";
+
+	card@0 {
+		compatible = "mmc-card";
+		reg = <0>;
+
+		partitions {
+			compatible = "gpt-partitions";
+
+			block-partition-env {
+				partname = "ubootenv";
+				nvmem-layout {
+					compatible = "u-boot,env-layout";
+				};
+			};
+
+			sd_rootfs: block-partition-production {
+				partname = "production";
+			};
+		};
+	};
+};
+
+&{/chosen} {
+	rootdisk-sd = <&sd_rootfs>;
+};
--- /dev/null
+++ b/target/linux/mediatek/dts/mt7987a-bananapi-bpi-r4-lite.dts
@@ -0,0 +1,321 @@
+// SPDX-License-Identifier: (GPL-2.0 OR MIT)
+/*
+ * Copyright (C) 2025 MediaTek Inc.
+ * Author: Sam.Shih <sam.shih@mediatek.com>
+ */
+
+/dts-v1/;
+#include "mt7987a.dtsi"
+#include <dt-bindings/input/input.h>
+#include <dt-bindings/leds/common.h>
+#include "mt7987a-bananapi-bpi-r4-lite-mikrobus.dtsi"
+
+/ {
+	model = "Bananapi BPI-R4-LITE";
+	compatible = "bananapi,bpi-r4-lite",
+		     "mediatek,mt7987a", "mediatek,mt7987";
+
+	aliases {
+		/* mt7987 I2C0 */
+		i2c0 = &i2c0;
+		/* PCA9548 (0-0070) provides 4 i2c channels */
+		i2c1 = &imux0_rtc;
+		i2c2 = &imux1_sfp;
+		i2c3 = &imux2_MikroBus;
+		i2c4 = &imux3;
+		led-boot = &sys_led_blue;
+		led-failsafe = &sys_led_blue;
+		led-running = &sys_led_blue;
+		led-upgrade = &sys_led_blue;
+		serial0 = &uart0;
+	};
+
+	chosen {
+		bootargs = "console=ttyS0,115200n1 earlycon=uart8250,mmio32,0x11000000 \
+			    ubi.block=0,firmware root=/dev/fit0 rootwait";
+		stdout-path = "serial0:115200n8";
+	};
+
+	gpio-keys {
+		compatible = "gpio-keys";
+
+		reset {
+			label = "reset";
+			linux,code = <KEY_RESTART>;
+			gpios = <&pio 1 GPIO_ACTIVE_LOW>;
+			debounce-interval = <10>;
+		};
+
+		wps {
+			label = "wps";
+			linux,code = <KEY_WPS_BUTTON>;
+			gpios = <&pio 0 GPIO_ACTIVE_LOW>;
+			debounce-interval = <10>;
+		};
+	};
+
+	gpio-leds {
+		compatible = "gpio-leds";
+
+		sfp-led {
+			gpios = <&pca9555 11 GPIO_ACTIVE_LOW>;
+			function = "sfp";
+			color = <LED_COLOR_ID_GREEN>;
+		};
+	};
+
+	pwm-leds {
+		compatible = "pwm-leds";
+		status = "okay";
+
+		/* ACT LED on bpi-r4-lite */
+		sys_led_blue: sys-led {
+			color = <LED_COLOR_ID_BLUE>;
+			function = LED_FUNCTION_STATUS;
+			pwms = <&pwm 0 50000>;
+			max-brightness = <255>;
+			active-high;
+			linux,default-trigger = "default-on";
+		};
+	};
+
+	sfp: sfp@0 {
+		compatible = "sff,sfp";
+		i2c-bus = <&imux1_sfp>;
+		los-gpios = <&pio 10 GPIO_ACTIVE_HIGH>;
+		mod-def0-gpios = <&pio 9 GPIO_ACTIVE_LOW>;
+		tx-disable-gpios = <&pio 8 GPIO_ACTIVE_HIGH>;
+		tx-fault-gpios = <&pca9555 12 GPIO_ACTIVE_HIGH>;
+		rate-select0-gpios = <&pca9555 13 GPIO_ACTIVE_HIGH>;
+		rate-select1-gpios = <&pca9555 14 GPIO_ACTIVE_HIGH>;
+		maximum-power-milliwatt = <3000>;
+	};
+
+	reg_3p3v: regulator-3p3v {
+		compatible = "regulator-fixed";
+		regulator-name = "fixed-3.3V";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		regulator-boot-on;
+		regulator-always-on;
+	};
+
+	reg_usb_5v: regulator-usb-5v {
+		compatible = "regulator-fixed";
+		regulator-name = "usb-5v";
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		gpio = <&pca9555 9 GPIO_ACTIVE_HIGH>;
+	};
+
+	usb-vbus-regulator {
+		compatible = "regulator-output";
+		vout-supply = <&reg_usb_5v>;
+	};
+};
+
+&fan {
+	pwms = <&pwm 2 50000>;
+	status = "okay";
+};
+
+&gmac0 {
+	phy-mode = "2500base-x";
+	status = "okay";
+	fixed-link {
+		speed = <2500>;
+		full-duplex;
+		pause;
+	};
+};
+
+&gmac1 {
+	phy-mode = "internal";
+	phy-handle = <&phy15>;
+	status = "okay";
+};
+
+&pwm {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pwm_pins>;
+	status = "okay";
+};
+
+&pwm_pins {
+	mux {
+		/*
+		 * - pwm0   : PWM0@PIN13
+		 * - pwm1_0 : PWM@PIN7  (share with JTAG)
+		 * - pwm2_0 : PWM2@PIN12 (share with PCM)
+		 */
+		function = "pwm";
+		groups = "pwm0", "pwm1_0", "pwm2_0";
+	};
+};
+
+&i2c0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&i2c0_pins>;
+	status = "okay";
+
+	pca9545@70 {
+		compatible = "nxp,pca9545";
+		reg = <0x70>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		imux0_rtc: i2c@0 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			reg = <0x0>;
+
+			rtc@51 {
+				compatible = "nxp,pcf8563";
+				reg = <0x51>;
+			};
+
+			eeprom@57 {
+				compatible = "atmel,24c02";
+				reg = <0x57>;
+				address-bits = <8>;
+				page-size = <8>;
+				size = <256>;
+			};
+		};
+
+		imux1_sfp: i2c@1 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			reg = <0x1>;
+		};
+
+		imux2_MikroBus: i2c@2 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			reg = <0x2>;
+		};
+
+		imux3: i2c@3 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			reg = <0x3>;
+
+			pca9555: i2c-gpio-expander@20 {
+				compatible = "nxp,pca9555";
+				interrupt-controller;
+				interrupt-parent = <&pio>;
+				interrupts = <2 IRQ_TYPE_LEVEL_LOW>;
+				gpio-controller;
+				#gpio-cells = <2>;
+				reg = <0x20>;
+			};
+
+			wifi_eeprom@50 {
+				compatible = "atmel,24c02";
+				reg = <0x50>;
+				wp-gpios = <&pca9555 10 GPIO_ACTIVE_LOW>;
+				address-bits = <8>;
+				page-size = <8>;
+				size = <256>;
+			};
+		};
+	};
+};
+
+&mdio {
+	/* built-in 2.5G Ethernet PHY */
+	phy15: phy@15 {
+		pinctrl-names = "i2p5gbe-led";
+		pinctrl-0 = <&i2p5gbe_led0_pins>;
+		compatible = "ethernet-phy-ieee802.3-c45";
+		reg = <15>;
+		phy-mode = "internal";
+	};
+
+	switch31: switch@31 {
+		compatible = "mediatek,mt7531";
+		reg = <31>;
+		reset-gpios = <&pio 42 GPIO_ACTIVE_HIGH>;
+		interrupt-controller;
+		#interrupt-cells = <1>;
+		interrupt-parent = <&pio>;
+		interrupts = <41 IRQ_TYPE_LEVEL_HIGH>;
+		status = "okay";
+	};
+};
+
+&ssusb {
+	mediatek,u3p-dis-msk=<0>;
+	phys = <&tphyu2port0 PHY_TYPE_USB2>,
+	       <&tphyu3port0 PHY_TYPE_USB3>;
+
+	/*
+	 * VIA VL817 USB3.1/USB2.0 hub
+	 * ports:
+	 * 1 - mPCIe B (SIM3)
+	 * 2 - NGFF-KEYB (SIM1)
+	 * 3 - USB-A connector
+	 * 4 - mPCIe A (SIM4)
+	 */
+
+	// reset-gpios = <&pca9555 8 GPIO_ACTIVE_HIGH>;
+};
+
+&switch31 {
+	ports {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		port@0 {
+			reg = <0>;
+			label = "lan0";
+		};
+
+		port@1 {
+			reg = <1>;
+			label = "lan1";
+		};
+
+		port@2 {
+			reg = <2>;
+			label = "lan2";
+		};
+
+		port@3 {
+			reg = <3>;
+			label = "lan3";
+		};
+
+		port@5 {
+			reg = <5>;
+			label = "sfp0";
+			phy-mode = "2500base-x";
+			sfp = <&sfp>;
+			managed = "in-band-status";
+		};
+
+		port@6 {
+			reg = <6>;
+			label = "cpu";
+			ethernet = <&gmac0>;
+			phy-mode = "2500base-x";
+
+			fixed-link {
+				speed = <2500>;
+				full-duplex;
+				pause;
+			};
+		};
+	};
+};
+
+&tphyu3port0 {
+	status = "okay";
+};
+
+&spi2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&spi2_flash_pins>;
+
+	status = "okay";
+};
--- a/target/linux/mediatek/filogic/base-files/etc/board.d/01_leds
+++ b/target/linux/mediatek/filogic/base-files/etc/board.d/01_leds
@@ -52,6 +52,9 @@ bananapi,bpi-r4-poe)
 	ucidef_set_led_netdev "lan2" "lan2" "mt7530-0:02:green:lan" "lan2" "link tx rx"
 	ucidef_set_led_netdev "lan3" "lan3" "mt7530-0:03:green:lan" "lan3" "link tx rx"
 	;;
+bananapi,bpi-r4-lite)
+	ucidef_set_led_netdev "sfp0" "sfp0" "green:sfp" "sfp0" "link tx rx"
+	;;
 cudy,re3000-v1|\
 wavlink,wl-wn573hx3)
 	ucidef_set_led_netdev "lan" "lan" "green:lan" "eth0" "link tx rx"
--- a/target/linux/mediatek/filogic/base-files/etc/board.d/02_network
+++ b/target/linux/mediatek/filogic/base-files/etc/board.d/02_network
@@ -89,6 +89,9 @@ mediatek_setup_interfaces()
 	bananapi,bpi-r4)
 		ucidef_set_interfaces_lan_wan "lan1 lan2 lan3 sfp-lan" "wan sfp-wan"
 		;;
+	bananapi,bpi-r4-lite)
+		ucidef_set_interfaces_lan_wan "lan0 lan1 lan2 lan3 sfp0" "eth1"
+		;;
 	bananapi,bpi-r4-2g5|\
 	bananapi,bpi-r4-poe)
 		ucidef_set_interfaces_lan_wan "lan1 lan2 lan3 lan4" "wan sfp-wan"
--- a/target/linux/mediatek/filogic/base-files/lib/upgrade/platform.sh
+++ b/target/linux/mediatek/filogic/base-files/lib/upgrade/platform.sh
@@ -85,6 +85,7 @@ platform_do_upgrade() {
 	bananapi,bpi-r4|\
 	bananapi,bpi-r4-2g5|\
 	bananapi,bpi-r4-poe|\
+	bananapi,bpi-r4-lite|\
 	cmcc,a10-ubootmod|\
 	cmcc,rax3000m|\
 	cudy,tr3000-v1-ubootmod|\
@@ -248,6 +249,7 @@ platform_check_image() {
 	bananapi,bpi-r4|\
 	bananapi,bpi-r4-2g5|\
 	bananapi,bpi-r4-poe|\
+	bananapi,bpi-r4-lite|\
 	cmcc,a10-ubootmod|\
 	cmcc,rax3000m|\
 	cudy,tr3000-v1-ubootmod|\
@@ -303,6 +305,7 @@ platform_copy_config() {
 	bananapi,bpi-r4|\
 	bananapi,bpi-r4-2g5|\
 	bananapi,bpi-r4-poe|\
+	bananapi,bpi-r4-lite|\
 	cmcc,rax3000m|\
 	gatonetworks,gdsp|\
 	mediatek,mt7988a-rfb)
--- a/package/boot/uboot-tools/uboot-envtools/files/mediatek_filogic
+++ b/package/boot/uboot-tools/uboot-envtools/files/mediatek_filogic
@@ -63,6 +63,7 @@ asus,rt-ax59u)
 bananapi,bpi-r3|\
 bananapi,bpi-r3-mini|\
 bananapi,bpi-r4|\
+bananapi,bpi-r4-lite|\
 bananapi,bpi-r4-poe|\
 cmcc,rax3000m|\
 jdcloud,re-cp-03)
