From 77dc9b81ec0b745cd209afa02e8e916c8342a164 Mon Sep 17 00:00:00 2001
From: Bo-Cun Chen <bc-bocun.chen@mediatek.com>
Date: Mon, 10 Nov 2025 09:05:12 +0800
Subject: [PATCH] net: phy: as21xxx: update driver to v1.9.0

This patch also introduces an as21xx_bbu_api, which allows users to use
debugfs to get or set the PHY mode for debugging purposes.

Signed-off-by: Bo-Cun Chen <bc-bocun.chen@mediatek.com>
---
 drivers/net/phy/Makefile                      |    3 +-
 drivers/net/phy/as21xx_bbu_api/as21xx_api.c   | 1626 ++++++++++
 drivers/net/phy/as21xx_bbu_api/as21xx_api.h   | 1133 +++++++
 .../net/phy/as21xx_bbu_api/as21xx_debugfs.c   | 2820 +++++++++++++++++
 .../net/phy/as21xx_bbu_api/as21xx_debugfs.h   |   27 +
 drivers/net/phy/as21xxx.c                     |  781 +++--
 drivers/net/phy/as21xxx.h                     |   65 +
 7 files changed, 6223 insertions(+), 232 deletions(-)
 create mode 100644 drivers/net/phy/as21xx_bbu_api/as21xx_api.c
 create mode 100644 drivers/net/phy/as21xx_bbu_api/as21xx_api.h
 create mode 100644 drivers/net/phy/as21xx_bbu_api/as21xx_debugfs.c
 create mode 100644 drivers/net/phy/as21xx_bbu_api/as21xx_debugfs.h
 create mode 100644 drivers/net/phy/as21xxx.h

diff --git a/drivers/net/phy/Makefile b/drivers/net/phy/Makefile
index 192cb34..d977358 100644
--- a/drivers/net/phy/Makefile
+++ b/drivers/net/phy/Makefile
@@ -57,7 +57,8 @@ obj-$(CONFIG_AIR_EN8811H_PHY)   += air_en8811h.o
 obj-$(CONFIG_AMD_PHY)		+= amd.o
 obj-$(CONFIG_AMCC_QT2025_PHY)	+= qt2025.o
 obj-$(CONFIG_AQUANTIA_PHY)	+= aquantia/
-obj-$(CONFIG_AS21XXX_PHY)	+= as21xxx.o
+obj-$(CONFIG_AS21XXX_PHY)	+= aeon_as21xxx.o
+aeon_as21xxx-objs	:= as21xxx.o as21xx_bbu_api/as21xx_debugfs.o as21xx_bbu_api/as21xx_api.o
 ifdef CONFIG_AX88796B_RUST_PHY
   obj-$(CONFIG_AX88796B_PHY)	+= ax88796b_rust.o
 else
diff --git a/drivers/net/phy/as21xx_bbu_api/as21xx_api.c b/drivers/net/phy/as21xx_bbu_api/as21xx_api.c
new file mode 100644
index 0000000..014ee81
--- /dev/null
+++ b/drivers/net/phy/as21xx_bbu_api/as21xx_api.c
@@ -0,0 +1,1626 @@
+/******************************************************************************
+ *
+ * AEONSEMI CONFIDENTIAL
+ * _____________________
+ *
+ * Aeonsemi Inc., 2023
+ * All Rights Reserved.
+ *
+ * NOTICE:  All information contained herein is, and remains the property of
+ * Aeonsemi Inc. and its subsidiaries, if any. The intellectual and technical
+ * concepts contained herein are proprietary to Aeonsemi Inc. and its
+ * subsidiaries and may be covered by U.S. and Foreign Patents, patents in
+ * process, and are protected by trade secret or copyright law. Dissemination
+ * of this information or reproduction of this material is strictly forbidden
+ * unless prior written permission is obtained from Aeonsemi Inc.
+ *
+ *
+ *****************************************************************************/
+#include <linux/of_mdio.h>
+#include <linux/of_address.h>
+#include <linux/mii.h>
+#include <linux/phy.h>
+#include <linux/time.h>
+#include <linux/module.h>
+#include <../kernel/time/timekeeping.h>
+#include <linux/timekeeping.h>
+#include <linux/timex.h>
+#include <linux/delay.h>
+#include <linux/firmware.h>
+#include <linux/crc32.h>
+#include <linux/kernel.h>
+#include <linux/spinlock.h>
+#include <linux/interrupt.h>
+#include "../as21xxx.h"
+#include "as21xx_api.h"
+#include <linux/slab.h>
+#include <linux/string.h>
+
+MODULE_DESCRIPTION("Aeonsemi AS21XX PHY api drivers");
+MODULE_AUTHOR("Aeonsemi");
+MODULE_LICENSE("GPL");
+
+static unsigned short aeon_mdio_read_reg(struct phy_device *phydev,
+					 unsigned int reg_addr)
+{
+	unsigned short val = 0;
+	unsigned short dev_addr = (reg_addr >> 17) & 0x1F;
+	unsigned short phy_reg = (reg_addr >> 1) & 0xFFFF;
+
+	val = aeon_cl45_read(phydev, dev_addr, phy_reg);
+	return val;
+}
+
+static void aeon_mdio_write_reg(struct phy_device *phydev, unsigned int reg_addr,
+				unsigned short value)
+{
+	unsigned short dev_addr = (reg_addr >> 17) & 0x1F;
+	unsigned short phy_reg = (reg_addr >> 1) & 0xFFFF;
+
+	aeon_cl45_write(phydev, dev_addr, phy_reg, value);
+}
+
+static unsigned short aeon_mdio_read_reg_field(struct phy_device *phydev, unsigned int reg_addr,
+					       unsigned short field)
+{
+	unsigned short val = aeon_mdio_read_reg(phydev, reg_addr);
+	unsigned short width = (field & 0xFF);
+	unsigned short offset = ((field >> 8) & 0xFF);
+	unsigned short mask = ((1 << width) - 1);
+
+	return ((val >> offset) & mask);
+}
+
+static void aeon_mdio_write_reg_field(struct phy_device *phydev, unsigned int reg_addr,
+				      unsigned short field, unsigned short value)
+{
+	unsigned short val = aeon_mdio_read_reg(phydev, reg_addr);
+	unsigned short width = (field & 0xFF);
+	unsigned short offset = ((field >> 8) & 0xFF);
+	unsigned short mask = ((1 << width) - 1) << offset;
+
+	val = (val & ~mask) | ((value & ((1 << width) - 1)) << offset);
+	aeon_mdio_write_reg(phydev, reg_addr, val);
+}
+
+static void aeon_send_ipc_cmd(struct phy_device *phydev, unsigned short cmd)
+{
+	aeon_mdio_write_reg(phydev, IPC_CMD_BASEADDR, cmd);
+}
+
+static void aeon_set_ipc_data_reg(struct phy_device *phydev, unsigned int len,
+				  unsigned short *val)
+{
+	int ii;
+
+	if (len >= 8)
+		len = 8;
+	for (ii = 0; ii < len; ii++) {
+		aeon_mdio_write_reg(phydev, IPC_DATA0_BASEADDR + 2 * ii,
+				    *(val + ii));
+	}
+}
+
+static unsigned short aeon_get_ipc_status(struct phy_device *phydev)
+{
+	unsigned short val;
+
+	val = aeon_mdio_read_reg(phydev, IPC_STS_BASEADDR);
+
+	return val;
+}
+
+static void aeon_ipc_parse_sts(unsigned short sts, unsigned short *status,
+			       unsigned short *opcode, unsigned short *size,
+			       unsigned short *parity)
+{
+	/*
+	 * """Parse the 16-bit full status into components.
+	 * 16-bit status register is laid out as follows:
+	 * [1 parity][5 size][6 opcode][4 status]
+	 */
+	unsigned short status_mask = (1 << IPC_NB_STATUS) - 1;
+	unsigned short opcode_mask = (1 << IPC_NB_OPCODE) - 1;
+	unsigned short size_mask = (1 << IPC_PAYLOAD_NB) - 1;
+	// Clip off status bits
+	*status = sts & status_mask;
+	sts = (sts >> IPC_NB_STATUS);
+	// Clip off opcode
+	*opcode = (sts & opcode_mask);
+	sts = (sts >> IPC_NB_OPCODE);
+	// Clip off size
+	*size = (sts & size_mask);
+	sts = (sts >> IPC_PAYLOAD_NB);
+	// Get parity bit
+	*parity = sts & 1;
+}
+
+void aeon_receive_ipc_data(struct phy_device *phydev, unsigned short len,
+			   unsigned short *data)
+{
+	int ii;
+
+	if (len > 8)
+		len = 8;
+	for (ii = 0; ii < len; ii++) {
+		*(data + ii) = aeon_mdio_read_reg(phydev, IPC_DATA0_BASEADDR +
+								  (ii << 1));
+	}
+}
+
+void aeon_send_ipc_msg(struct phy_device *phydev, unsigned int len,
+		       unsigned short *val, short opcode, short size)
+{
+	unsigned short cmd;
+
+	aeon_set_ipc_data_reg(phydev, len, val);
+	aeon_ipc_build_cmd(&cmd, opcode, size);
+	aeon_send_ipc_cmd(phydev, cmd);
+}
+
+/* IPC Layer functions */
+static unsigned int ipc_cmd_num;
+static unsigned int get_par(void)
+{
+	return ipc_cmd_num & 0x1;
+}
+
+void aeon_ipc_build_cmd(unsigned short *cmd, short opcode, short size)
+{
+	/*
+	 * """Construct the full command word.
+	 * 16-bit register is laid out as follows:
+	 * [1 cmd par][4 reserved][5 size][6 opcode]
+	 */
+
+	unsigned short opcode_mask = (1 << IPC_NB_OPCODE) - 1;
+	unsigned short size_mask = (1 << IPC_PAYLOAD_NB) - 1;
+	unsigned short opcode_bits = opcode & opcode_mask;
+	unsigned short size_bits = size & size_mask;
+	unsigned short _cmd = 0;
+
+	_cmd = (size_bits << IPC_NB_OPCODE) + opcode_bits;
+
+	if (get_par() == 0)
+		_cmd &= ~IPC_CMD_PARITY;
+	else
+		_cmd |= IPC_CMD_PARITY;
+
+	*cmd = _cmd;
+	ipc_cmd_num++;
+}
+
+unsigned short aeon_ipc_wait_cmd_done(struct phy_device *phydev,
+				      unsigned long *ns,
+				      unsigned short *ret_size)
+{
+	/*
+	 * """Wait until IPC status handshake returns DONE or READY.
+	 * timeout : seconds
+	 * Returns
+	 * -------
+	 *  status : int
+	 *  Return status:
+	 *  opcode : int
+	 *  serviced.
+	 *  ret_size : int
+	 *  Number of bytes in the return.
+	 */
+	struct timespec64 t1, t2;
+	unsigned long _to, _ns = 0;
+	unsigned short sts, opcode, ret_par;
+	unsigned short status = 0, par = 0;
+
+	if (ns)
+		_to = *ns;
+	else
+		_to = IPC_TIMEOUT;
+
+	ktime_get_real_ts64(&t1);
+	while ((par == 0) || ((status != IPC_STS_CMD_SUCCESS) &&
+			      (status != IPC_STS_CMD_ERROR))) {
+		mdelay(10);
+		sts = aeon_get_ipc_status(phydev);
+		aeon_ipc_parse_sts(sts, &status, &opcode, ret_size, &ret_par);
+		par = (get_par() != ret_par);
+
+		// Check return status
+		if (status == IPC_STS_CMD_ERROR)
+			break;
+
+		// Check timeout
+		ktime_get_real_ts64(&t2);
+		_ns = (t2.tv_sec - t1.tv_sec) * 1000000000 + t2.tv_nsec -
+		      t1.tv_nsec;
+		if (_ns > _to)
+			break;
+	}
+
+	return status;
+}
+
+void aeon_ipc_sync_parity(struct phy_device *phydev)
+{
+	unsigned long noop_to = 20;
+	struct timespec64 t1, t2;
+	unsigned long _to = IPC_TIMEOUT, _ns = 0;
+	unsigned short cmd, par = 0;
+	unsigned short sts, status, opcode, size, ret_par;
+	struct device *dev = phydev_dev(phydev);
+
+	// Send first noop, no need to wait reply
+	aeon_ipc_build_cmd(&cmd, IPC_CMD_NOOP, 0);
+	aeon_send_ipc_cmd(phydev, cmd);
+	mdelay(noop_to);
+
+	// Send second noop, expect the correct parity to return
+	aeon_ipc_build_cmd(&cmd, IPC_CMD_NOOP, 0);
+	aeon_send_ipc_cmd(phydev, cmd);
+	par = 0;
+	ktime_get_real_ts64(&t1);
+	while (par == 0) {
+		mdelay(10);
+		sts = aeon_get_ipc_status(phydev);
+		aeon_ipc_parse_sts(sts, &status, &opcode, &size, &ret_par);
+		par = (get_par() != ret_par);
+
+		// Check timeout
+		ktime_get_real_ts64(&t2);
+		_ns = (t2.tv_sec - t1.tv_sec) * 1000000000 + t2.tv_nsec -
+		      t1.tv_nsec;
+		if (_ns > _to)
+			break;
+	}
+
+	if (par == 0) {
+		dev_err(dev, "IPC sync failure: NOOP 3, sts: %x\n",
+			aeon_get_ipc_status(phydev));
+	}
+}
+
+void aeon_ipc_get_fw_version(char *version, struct phy_device *phydev)
+{
+	unsigned short status, ret_size;
+	unsigned short data = IPC_CMD_INFO_VERSION;
+	struct device *dev = phydev_dev(phydev);
+
+	aeon_send_ipc_msg(phydev, 1, &data, IPC_CMD_INFO, 2);
+
+	status = aeon_ipc_wait_cmd_done(phydev, NULL, &ret_size);
+	if (status != IPC_STS_CMD_SUCCESS) {
+		dev_err(dev, "get FW version command failed %x\n", status);
+		return;
+	}
+	aeon_receive_ipc_data(phydev, 8, (unsigned short *)version);
+}
+
+void aeon_ipc_send_bulk_write(unsigned int mem_addr, unsigned int size,
+			      struct phy_device *phydev)
+{
+	unsigned short status, ret_size;
+	unsigned short msg[4] = { mem_addr & 0xffff, mem_addr >> 16,
+				  size & 0xffff, size >> 16 };
+	struct device *dev = phydev_dev(phydev);
+
+	aeon_send_ipc_msg(phydev, 4, msg, IPC_CMD_BULK_WRITE, 8);
+
+	status = aeon_ipc_wait_cmd_done(phydev, NULL, &ret_size);
+	if (status != IPC_STS_CMD_SUCCESS) {
+		dev_err(dev, "IPC send bulk write command failed %x\n", status);
+		return;
+	}
+}
+
+void aeon_ipc_send_bulk_data(unsigned short bw_type, unsigned short size,
+			     void *data, struct phy_device *phydev)
+{
+	unsigned short status, ret_size;
+	struct device *dev = phydev_dev(phydev);
+	// ipc data register is 16 bits, total 16 bytes per call.
+	switch (bw_type) {
+	case BW8:
+		size = (size + 1) / 2;
+		break;
+	case BW32:
+		size = size * 2;
+		break;
+	case BW16:
+	default:
+		break;
+	}
+
+	aeon_send_ipc_msg(phydev, size, (unsigned short *)data,
+			  IPC_CMD_BULK_DATA, size * 2);
+
+	status = aeon_ipc_wait_cmd_done(phydev, NULL, &ret_size);
+	if (status != IPC_STS_CMD_SUCCESS) {
+		dev_err(dev, "IPC Bulk data command failed: %x\n", status);
+		return;
+	}
+}
+
+void aeon_ipc_cfg_param_direct(unsigned int data_len, unsigned short *data,
+			       struct phy_device *phydev)
+{
+	unsigned short _data = IPC_CMD_CFG_DIRECT;
+	unsigned short cmd, status, ret_size;
+	struct device *dev = phydev_dev(phydev);
+
+	aeon_set_ipc_data_reg(phydev, data_len + 1, data - 1);
+	aeon_set_ipc_data_reg(phydev, 1, &_data);
+
+	aeon_ipc_build_cmd(&cmd, IPC_CMD_CFG_PARAM, 2 * (data_len + 1));
+	aeon_send_ipc_cmd(phydev, cmd);
+
+	status = aeon_ipc_wait_cmd_done(phydev, NULL, &ret_size);
+	if (status != IPC_STS_CMD_SUCCESS) {
+		dev_err(dev, "IPC cfg param direct return status: %x\n",
+			status);
+		return;
+	}
+}
+
+static unsigned short aeon_ipc_dbg_cmd(struct phy_device *phydev, unsigned short dbg_sec,
+				       unsigned short dbg_cmd, unsigned short size)
+{
+	unsigned short data[8] = {0}, status, ret_size;
+
+	data[0] = (dbg_sec << 8) | dbg_cmd;
+	data[1] = size;
+	data[2] = 0;
+	aeon_send_ipc_msg(phydev, 3, data, IPC_OPCODE_DBGCMD, 6);
+	status = aeon_ipc_wait_cmd_done(phydev, NULL, &ret_size);
+	if (status != IPC_STS_CMD_SUCCESS)
+		return IPC_STS_CMD_ERROR;
+
+	return IPC_STS_CMD_SUCCESS;
+}
+
+static unsigned short aeon_ipc_wbuf(struct phy_device *phydev, void *write_data,
+				    unsigned short write_size, ipc_data_type_t write_type,
+				    unsigned short write_size_bytes, unsigned short write_size_words)
+{
+	unsigned short write_ipc_data_array[8] = {0};
+	unsigned short *write_ipc_data = (unsigned short *)write_ipc_data_array;
+	unsigned short ret_size, status;
+	unsigned char *src;
+	unsigned int *src_int;
+	unsigned short *src_short;
+	int i;
+
+	if (write_data && write_size > 0) {
+		if (write_type == IPC_DATA_UINT16) {
+			for (i = 0; i < write_size; i++) {
+				src_short = (unsigned short *)write_data;
+				write_ipc_data[i] = src_short[i];
+			}
+		} else {
+			if (write_type == IPC_DATA_UINT8) {
+				src = (unsigned char *)write_data;
+				for (i = 0; i < write_size; i += 2) {
+					write_ipc_data[i/2] = src[i];
+					if (i + 1 < write_size)
+						write_ipc_data[i/2] |= (src[i+1] << 8);
+				}
+			} else if (write_type == IPC_DATA_UINT32) {
+				src_int = (unsigned int *)write_data;
+				for (i = 0; i < write_size; i++) {
+					write_ipc_data[i*2] = src_int[i] & 0xFFFF;
+					write_ipc_data[i*2+1] = (src_int[i] >> 16) & 0xFFFF;
+				}
+			}
+		}
+
+		aeon_send_ipc_msg(phydev, write_size_words, write_ipc_data, IPC_OPCODE_WBUF,
+				  write_size_bytes);
+		status = aeon_ipc_wait_cmd_done(phydev, NULL, &ret_size);
+		if (status != IPC_STS_CMD_SUCCESS) {
+			phydev_err(phydev, "Write buffer command failed %x\n", status);
+			return IPC_STS_CMD_ERROR;
+		}
+	}
+
+	return IPC_STS_CMD_SUCCESS;
+}
+
+static unsigned short aeon_ipc_poll(struct phy_device *phydev)
+{
+	unsigned short done = 0, iter = 0, status = 0, ret_size = 0, cmd = 0;
+
+	while ((done == 0) && (iter < MAX_POLL)) {
+		aeon_ipc_build_cmd(&cmd, IPC_OPCODE_POLL, 0);
+		aeon_send_ipc_cmd(phydev, cmd);
+		status = aeon_ipc_wait_cmd_done(phydev, NULL, &ret_size);
+		if (status != IPC_STS_CMD_SUCCESS) {
+			phydev_err(phydev, "Read buffer command failed %x\n", status);
+			return IPC_STS_CMD_ERROR;
+		}
+		done = aeon_mdio_read_reg(phydev, IPC_DATA0_BASEADDR);
+
+		iter++;
+	}
+
+	return IPC_STS_CMD_SUCCESS;
+}
+
+static unsigned short aeon_ipc_recv(struct phy_device *phydev, void *recv_buf, unsigned short recv_size,
+				    ipc_data_type_t recv_type)
+{
+	unsigned char *temp_buf = NULL;
+	unsigned char *read_target, *p_data;
+	unsigned short ctr = 0, status, reg_val, cmd, ret_size;
+	unsigned short *dst;
+	unsigned int *dst_int;
+	int i;
+
+	if (recv_buf && recv_size > 0) {
+		if (recv_type != IPC_DATA_UINT8) {
+			temp_buf = kmalloc(recv_size, GFP_KERNEL);
+			if (!temp_buf) {
+				phydev_err(phydev, "Failed to allocate temporary buffer\n");
+				return IPC_STS_CMD_ERROR;
+			}
+			read_target = temp_buf;
+		} else
+			read_target = (unsigned char *)recv_buf;
+
+		while (recv_size > ctr) {
+			p_data = read_target + ctr;
+			aeon_ipc_build_cmd(&cmd, IPC_OPCODE_RBUF, 0);
+			aeon_send_ipc_cmd(phydev, cmd);
+			status = aeon_ipc_wait_cmd_done(phydev, NULL, &ret_size);
+
+			if (status != IPC_STS_CMD_SUCCESS) {
+				phydev_err(phydev, "Read buffer command failed %x\n", status);
+				return IPC_STS_CMD_ERROR;
+			}
+
+			for (i = 0; i < IPC_PAYLOAD_WORDS; ++i) {
+				reg_val = aeon_mdio_read_reg(phydev, IPC_DATA0_BASEADDR + (i << 1));
+				p_data[i * 2] = reg_val & 0xFF;
+				p_data[i * 2 + 1] = (reg_val >> 8) & 0xFF;
+			}
+
+			ctr += IPC_PAYLOAD_SIZE;
+		}
+
+		if (recv_type != IPC_DATA_UINT8) {
+			if (recv_type == IPC_DATA_UINT16) {
+				dst = (unsigned short *)recv_buf;
+				for (i = 0; i < recv_size / 2; i++)
+					dst[i] = temp_buf[i*2] | (temp_buf[i*2+1] << 8);
+			} else if (recv_type == IPC_DATA_UINT32) {
+				dst_int = (unsigned int *)recv_buf;
+				for (i = 0; i < recv_size / 4; i++) {
+					dst_int[i] = temp_buf[i*4] |
+						     (temp_buf[i*4+1] << 8) |
+						     (temp_buf[i*4+2] << 16) |
+						     (temp_buf[i*4+3] << 24);
+				}
+			}
+			kfree(temp_buf);
+		}
+	}
+
+	return IPC_STS_CMD_SUCCESS;
+}
+
+static unsigned short aeon_ipc_operation(struct phy_device *phydev, unsigned short dbg_sec,
+					 unsigned short dbg_cmd, void *write_data,
+					 unsigned short write_size, ipc_data_type_t write_type,
+					 void *recv_buf, unsigned short recv_size,
+					 ipc_data_type_t recv_type)
+{
+	unsigned short ret;
+	unsigned short write_size_bytes = 0;
+	unsigned short write_size_words = 0;
+
+	if (write_data && write_size > 0) {
+		write_size_bytes = write_size * write_type;
+		write_size_words = (write_size_bytes + 1) / 2;
+	}
+
+	// Step 1
+	ret = aeon_ipc_dbg_cmd(phydev, dbg_sec, dbg_cmd, write_size_bytes);
+	if (ret != IPC_STS_CMD_SUCCESS) {
+		phydev_err(phydev, "AS21xx debug command failed %x\n", ret);
+		return IPC_STS_CMD_ERROR;
+	}
+
+	aeon_ipc_sync_parity(phydev);
+
+	// Step 2
+	ret = aeon_ipc_wbuf(phydev, write_data, write_size, write_type, write_size_bytes,
+			    write_size_words);
+	if (ret != IPC_STS_CMD_SUCCESS) {
+		phydev_err(phydev, "AS21xx write buffer command failed %x\n", ret);
+		return IPC_STS_CMD_ERROR;
+	}
+
+	aeon_ipc_sync_parity(phydev);
+
+	ret = aeon_ipc_poll(phydev);
+	if (ret != IPC_STS_CMD_SUCCESS) {
+		phydev_err(phydev, "AS21xx ipc poll command failed %x\n", ret);
+		return IPC_STS_CMD_ERROR;
+	}
+	// Step 3
+	aeon_ipc_recv(phydev, recv_buf, recv_size, recv_type);
+
+	aeon_ipc_sync_parity(phydev);
+
+	return IPC_STS_CMD_SUCCESS;
+}
+
+void aeon_cu_an_set_top_spd(unsigned short top_spd, struct phy_device *phydev)
+{
+	unsigned short data[8], reg_num = 3;
+
+	data[0] = CFG_CU_AN;
+	data[1] = IPC_CMD_CU_AN_TOP_SPD;
+	data[2] = top_spd;
+
+	aeon_ipc_cfg_param_direct(reg_num, data, phydev);
+}
+
+void aeon_cu_an_restart(struct phy_device *phydev)
+{
+	unsigned short data[8], reg_num = 2;
+
+	data[0] = CFG_CU_AN;
+	data[1] = MDI_CFG_CU_AN_RESTART;
+
+	aeon_ipc_cfg_param_direct(reg_num, data, phydev);
+}
+
+void aeon_cu_an_set_eee_spd(unsigned short speed_mode,
+			    struct phy_device *phydev)
+{
+	unsigned short data[8], reg_num = 3;
+
+	data[0] = CFG_CU_AN;
+	data[1] = MDI_CFG_CU_AN_EEE_SPD;
+	data[2] = speed_mode;
+
+	aeon_ipc_cfg_param_direct(reg_num, data, phydev);
+}
+
+void aeon_cu_an_set_trd_swap(unsigned short en, unsigned short trd_swap, struct phy_device *phydev)
+{
+	unsigned short data[8], reg_num = 4;
+
+	data[0] = CFG_CU_AN;
+	data[1] = IPC_CMD_CU_AN_TRD_SWAP;
+	data[2] = en;
+	data[3] = trd_swap;
+
+	aeon_ipc_cfg_param_direct(reg_num, data, phydev);
+}
+
+void aeon_cu_an_set_ms_cfg(unsigned short port_type, unsigned short ms_man_en,
+			   unsigned short ms_man_val, struct phy_device *phydev)
+{
+	unsigned short data[8], reg_num = 5;
+
+	data[0] = CFG_CU_AN;
+	data[1] = IPC_CMD_CU_AN_MS_CFG;
+	data[2] = port_type;
+	data[3] = ms_man_en;
+	data[4] = ms_man_val;
+
+	aeon_ipc_cfg_param_direct(reg_num, data, phydev);
+}
+
+void aeon_cu_an_get_ms_cfg(unsigned short *ms_related_cfg,
+			   struct phy_device *phydev)
+{
+	unsigned short data[8], reg_num = 2;
+
+	data[0] = CFG_CU_AN;
+	data[1] = IPC_CMD_CU_AN_GET_MS_CFG;
+
+	aeon_ipc_cfg_param_direct(reg_num, data, phydev);
+	aeon_receive_ipc_data(phydev, 3, (unsigned short *)ms_related_cfg);
+}
+
+void aeon_cu_an_set_cfr(unsigned short cfr, struct phy_device *phydev)
+{
+	unsigned short data[8], reg_num = 3;
+
+	data[0] = CFG_CU_AN;
+	data[1] = IPC_CMD_CU_AN_CFR;
+	data[2] = cfr;
+
+	aeon_ipc_cfg_param_direct(reg_num, data, phydev);
+}
+
+void aeon_cu_an_set_fast_retrain(unsigned short speed_mode,
+				 unsigned short thp_bypass,
+				 struct phy_device *phydev)
+{
+	unsigned short data[8], reg_num = 4;
+
+	data[0] = CFG_CU_AN;
+	data[1] = MDI_CFG_CU_AN_FR_SPD;
+	data[2] = speed_mode >> 4;
+	data[3] = thp_bypass;
+
+	aeon_ipc_cfg_param_direct(reg_num, data, phydev);
+}
+
+void aeon_cu_an_enable_downshift(unsigned short enable,
+				 unsigned short retry_limit,
+				 struct phy_device *phydev)
+{
+	unsigned short data[8], reg_num = 4;
+
+	data[0] = CFG_CU_AN;
+	data[1] = MDI_CFG_CU_AN_DS;
+	data[2] = enable;
+	data[3] = retry_limit;
+
+	aeon_ipc_cfg_param_direct(reg_num, data, phydev);
+}
+
+void aeon_sds_pcs_set_cfg(unsigned short pcs_mode, unsigned short sds_spd,
+			  struct phy_device *phydev)
+{
+	unsigned short data[8], reg_num = 4;
+	// the order should match firmware cfg parameter sequence.
+	data[0] = CFG_SDS_PCS;
+	data[1] = CFG_SDS_PCS;
+	data[2] = pcs_mode;
+	data[3] = sds_spd;
+
+	aeon_ipc_cfg_param_direct(reg_num, data, phydev);
+}
+
+void aeon_sds_pma_set_cfg(unsigned short vga_adapt, unsigned short slc_adapt,
+			  unsigned short ctle_adapt, unsigned short dfe_adapt,
+			  struct phy_device *phydev)
+{
+	unsigned short data[8], reg_num = 6;
+	// the order should match firmware cfg parameter sequence.
+	data[0] = CFG_SDS_PMA;
+	data[1] = CFG_SDS_PMA;
+	data[2] = vga_adapt;
+	data[3] = slc_adapt;
+	data[4] = ctle_adapt;
+	data[5] = dfe_adapt;
+
+	aeon_ipc_cfg_param_direct(reg_num, data, phydev);
+}
+
+void aeon_cu_an_enable_aeon_oui(unsigned short nstd_pbo,
+				struct phy_device *phydev)
+{
+	unsigned short data[8], reg_num = 3;
+
+	data[0] = CFG_CU_AN;
+	data[1] = MDI_CFG_CU_AN_AEON_OUI;
+	data[2] = nstd_pbo;
+
+	aeon_ipc_cfg_param_direct(reg_num, data, phydev);
+}
+
+void aeon_auto_eee_cfg(unsigned short enable, unsigned int idle_th,
+		       struct phy_device *phydev)
+{
+	unsigned short data[8], reg_num = 5;
+
+	data[0] = CFG_AUTO_EEE;
+	data[1] = CFG_AUTO_EEE;
+	data[2] = enable;
+	data[3] = idle_th & 0xFFFF;
+	data[4] = (idle_th >> 16) & 0xFFFF;
+
+	aeon_ipc_cfg_param_direct(reg_num, data, phydev);
+}
+
+void aeon_ipc_temp_monitor(unsigned short sub_cmd, unsigned short params,
+			   unsigned short *temperature,
+			   struct phy_device *phydev)
+{
+	unsigned short data[8], reg_num = 3;
+
+	data[0] = CFG_TEMP_MON;
+	data[1] = sub_cmd;
+	data[2] = params;
+
+	aeon_ipc_cfg_param_direct(reg_num, data, phydev);
+	if (sub_cmd == 0x4)
+		aeon_receive_ipc_data(phydev, 3, (unsigned short *)temperature);
+}
+
+void aeon_dpc_ra_enable(struct phy_device *phydev)
+{
+	unsigned short data[8], reg_num = 1;
+
+	data[0] = CFG_DPC_RA;
+
+	aeon_ipc_cfg_param_direct(reg_num, data, phydev);
+}
+
+void aeon_ipc_set_led_cfg(unsigned short led0, unsigned short led1,
+			  unsigned short led2, unsigned short led3,
+			  unsigned short led4, unsigned short polarity,
+			  unsigned short blink, struct phy_device *phydev)
+{
+	unsigned short status, ret_size;
+	unsigned short cfg[7] = {
+		led0, led1, led2, led3, led4, polarity, blink
+	};
+	struct device *dev = phydev_dev(phydev);
+
+	aeon_send_ipc_msg(phydev, 7, cfg, IPC_CMD_SET_LED, 14);
+
+	status = aeon_ipc_wait_cmd_done(phydev, NULL, &ret_size);
+	if (status != IPC_STS_CMD_SUCCESS) {
+		dev_err(dev, "set led command failed %x\n", status);
+		return;
+	}
+}
+
+int aeon_read_status(struct phy_device *phydev)
+{
+	int ret = 0, reg = 0;
+	char hcd_status = 0;
+	struct device *dev = phydev_dev(phydev);
+
+	phydev->speed = SPEED_UNKNOWN;
+	phydev->duplex = DUPLEX_UNKNOWN;
+	phydev->pause = 1;
+	phydev->asym_pause = 1;
+
+	reg = aeon_mdio_read_reg(phydev, AN_REG_GIGA_STD_STATUS_BASEADDR);
+	if (reg < 0) {
+		dev_err(dev, "MII_BMSR reg %d!\n", reg);
+		return reg;
+	}
+	if (reg & BMSR_LSTATUS) {
+		phydev->link = 1;
+		hcd_status = aeon_mdio_read_reg_field(phydev, 0xF0010, 0x804);
+		switch (hcd_status) {
+		case 0xE:
+			phydev->speed = SPEED_10000;
+			phydev->duplex = DUPLEX_FULL;
+			break;
+		case 0xD:
+			phydev->speed = SPEED_5000;
+			phydev->duplex = DUPLEX_FULL;
+			break;
+		case 0xC:
+			phydev->speed = SPEED_2500;
+			phydev->duplex = DUPLEX_FULL;
+			break;
+		case 0xB:
+			phydev->speed = SPEED_1000;
+			phydev->duplex = DUPLEX_FULL;
+			break;
+		case 0xA:
+			phydev->speed = SPEED_100;
+			phydev->duplex = DUPLEX_FULL;
+			break;
+		case 0x3:
+			phydev->speed = SPEED_1000;
+			phydev->duplex = DUPLEX_HALF;
+			break;
+		case 0x2:
+			phydev->speed = SPEED_100;
+			phydev->duplex = DUPLEX_HALF;
+			break;
+		default:
+			break;
+		}
+	}
+
+	return ret;
+}
+
+void aeon_ipc_set_sys_reboot(struct phy_device *phydev)
+{
+	unsigned short data = IPC_CMD_SYS_REBOOT;
+
+	aeon_send_ipc_msg(phydev, 1, &data, IPC_CMD_SYS_CPU, 2);
+}
+
+void aeon_pkt_chk_cfg(unsigned short enable, struct phy_device *phydev)
+{
+	unsigned short data[8], reg_num = 4;
+
+	data[0] = CFG_DPC_PKT_CHK;
+	data[1] = CFG_DPC_PKT_CHK;
+	data[2] = enable;
+	data[3] = 0;
+
+	aeon_ipc_cfg_param_direct(reg_num, data, phydev);
+}
+
+void aeon_sds_wait_eth_cfg(unsigned short sds_wait_eth_delay,
+			   struct phy_device *phydev)
+{
+	unsigned short data[8], reg_num = 5;
+
+	data[0] = CFG_DPC_SDS_WAIT_ETH;
+	data[1] = CFG_DPC_SDS_WAIT_ETH;
+	data[2] = sds_wait_eth_delay;
+	data[3] = 2;
+	data[4] = 1;
+
+	aeon_ipc_cfg_param_direct(reg_num, data, phydev);
+}
+
+void aeon_ipc_phy_enable_mode(unsigned short enable, struct phy_device *phydev)
+{
+	unsigned short status, ret_size;
+	unsigned short cfg[2] = { IPC_CMD_SYS_CPU_PHY_ENABLE, enable };
+	struct device *dev = phydev_dev(phydev);
+
+	aeon_send_ipc_msg(phydev, 2, cfg, IPC_CMD_SYS_CPU, 4);
+
+	status = aeon_ipc_wait_cmd_done(phydev, NULL, &ret_size);
+	if (status != IPC_STS_CMD_SUCCESS) {
+		dev_err(dev, "IPC set phy return status: %x\n", status);
+		return;
+	}
+}
+
+#ifdef DUAL_FLASH
+int aeon_ipc_sys_cpu_info(unsigned short sub_cmd, unsigned int flash_addr,
+			  unsigned int mem_addr, struct phy_device *phydev)
+{
+	unsigned short status, ret_size;
+	unsigned short cfg[5] = { 0 };
+	int val = 0;
+	struct device *dev = phydev_dev(phydev);
+
+	cfg[0] = sub_cmd;
+	if (sub_cmd == IPC_CMD_SYS_CPU_IMAGE_CHECK) {
+		cfg[1] = flash_addr & 0xFFFF;
+		cfg[2] = (flash_addr >> 16) & 0xFFFF;
+		cfg[3] = mem_addr & 0xFFFF;
+		cfg[4] = (mem_addr >> 16) & 0xFFFF;
+	}
+
+	aeon_send_ipc_msg(phydev, 5, cfg, IPC_CMD_SYS_CPU, 10);
+
+	status = aeon_ipc_wait_cmd_done(phydev, NULL, &ret_size);
+	if (status != IPC_STS_CMD_SUCCESS) {
+		dev_err(dev, "spu info command failed %x\n", status);
+		return 1;
+	}
+	if (sub_cmd == IPC_CMD_SYS_CPU_IMAGE_CHECK) {
+		aeon_receive_ipc_data(phydev, 1, cfg);
+		val = cfg[0];
+	} else if (sub_cmd == IPC_CMD_SYS_IMAGE_OFST) {
+		aeon_receive_ipc_data(phydev, 2, cfg);
+		val = cfg[0] + (cfg[1] << 16);
+	}
+	return val;
+}
+
+void aeon_ipc_set_fsm_mode(unsigned short fsm, unsigned short mode,
+			   struct phy_device *phydev)
+{
+	unsigned short data[8], reg_num = 4;
+
+	data[0] = CFG_NG_PHYCTRL;
+	data[1] = IPC_CMD_CFG_PHYCTRL_PAUSED;
+	data[2] = fsm;
+	data[3] = mode;
+
+	aeon_ipc_cfg_param_direct(reg_num, data, phydev);
+}
+
+void aeon_ipc_write_flash(unsigned int flash_addr, unsigned int mem_addr,
+			  unsigned short size, struct phy_device *phydev)
+{
+	unsigned short status, ret_size;
+	unsigned short cfg[5] = { 0 };
+	struct device *dev = phydev_dev(phydev);
+
+	cfg[0] = flash_addr & 0xFFFF;
+	cfg[1] = flash_addr >> 16;
+	cfg[2] = mem_addr & 0xFFFF;
+	cfg[3] = mem_addr >> 16;
+	cfg[4] = size;
+
+	aeon_send_ipc_msg(phydev, 5, cfg, IPC_CMD_FLASH_WRITE, 10);
+
+	status = aeon_ipc_wait_cmd_done(phydev, NULL, &ret_size);
+	if (status != IPC_STS_CMD_SUCCESS) {
+		dev_err(dev, "write flash command failed %x\n", status);
+		return;
+	}
+}
+
+void aeon_ipc_erase_flash(unsigned int flash_addr, unsigned int size,
+			  unsigned short mode, struct phy_device *phydev)
+{
+	unsigned short status, ret_size;
+	unsigned long ts = 6000000000;
+	unsigned long *_to = &ts;
+	unsigned short cfg[5] = { 0 };
+	struct device *dev = phydev_dev(phydev);
+
+	if ((flash_addr + size) >= FLASH_CHIP_SIZE)
+		size = FLASH_CHIP_SIZE - flash_addr - 1;
+
+	cfg[0] = flash_addr & 0xFFFF;
+	cfg[1] = flash_addr >> 16;
+	cfg[2] = size & 0xFFFF;
+	cfg[3] = size >> 16;
+	cfg[4] = mode;
+
+	aeon_send_ipc_msg(phydev, 5, cfg, IPC_CMD_FLASH_ERASE, 10);
+	status = aeon_ipc_wait_cmd_done(phydev, _to, &ret_size);
+	if (status != IPC_STS_CMD_SUCCESS) {
+		dev_err(dev, "erase flash command failed %x\n", status);
+		return;
+	}
+}
+
+void aeon_update_flash(const char *firmware, unsigned int flash_start,
+		       struct phy_device *phydev)
+{
+	int sector_ofst, total, ret, data_ofst;
+	unsigned char buf[FLASH_SECTOR_SIZE] = { 0 };
+	unsigned short *wdata = (unsigned short *)buf;
+	unsigned int temp_mem_addr = 0x33e000, flash_addr, image_size;
+	unsigned short crc, dlen;
+	const struct firmware *fw;
+	struct device *dev = phydev_dev(phydev);
+
+	aeon_ipc_set_fsm_mode(CFG_FSM_NGPHY, 0, phydev);
+	aeon_ipc_set_fsm_mode(CFG_FSM_GPHY, 0, phydev);
+	aeon_ipc_set_fsm_mode(CFG_FSM_CU_AN, 0, phydev);
+	aeon_ipc_set_fsm_mode(CFG_FSM_DPC, 0, phydev);
+	aeon_ipc_set_fsm_mode(CFG_FSM_SS, 0, phydev);
+
+	ret = request_firmware_direct(&fw, firmware, dev);
+	if (ret < 0) {
+		dev_err(dev, "failed to load flash bin %s, ret: %d\n", firmware,
+			ret);
+		return;
+	}
+	crc = ~crc32(~0, fw->data, fw->size);
+	dev_info(dev, "%s: crc32=0x%x\n", firmware, crc);
+	// pad length so that fsm won't stuck at read back
+	image_size = (fw->size + 3) & 0xFFFFFFFC;
+
+	// erase first
+	sector_ofst = 0;
+	aeon_ipc_erase_flash(flash_start, image_size, ERASE_MODE_BLOCK, phydev);
+
+	while ((sector_ofst << 12) < image_size) {
+		flash_addr = flash_start + FLASH_SECTOR_SIZE * sector_ofst;
+		dlen = 0;
+		total = (image_size - (sector_ofst << 12)) >> 1;
+		data_ofst = sector_ofst * FLASH_SECTOR_SIZE;
+		memcpy(buf, fw->data + data_ofst, FLASH_SECTOR_SIZE);
+
+		if (total > (FLASH_SECTOR_SIZE >> 1))
+			total = (FLASH_SECTOR_SIZE >> 1);
+
+		dev_info(dev, "sector_ofst : %u", sector_ofst);
+		dev_info(dev, "  data_ofst : 0x%x\n", data_ofst);
+		dev_info(dev, "flash_addr : 0x%x\n", flash_addr);
+
+		dev_info(dev, "Origin params : %u  %u  %u  %u  %u  %u  %u  %u\n",
+		       *(wdata), *(wdata + 1), *(wdata + 2), *(wdata + 3),
+		       *(wdata + 4), *(wdata + 5), *(wdata + 6), *(wdata + 7));
+
+		aeon_ipc_send_bulk_write(temp_mem_addr, FLASH_SECTOR_SIZE,
+					 phydev);
+		// upload to system memory
+		while (dlen < total) {
+			if ((total - dlen) > 8) {
+				aeon_ipc_send_bulk_data(BW16, 8, wdata + dlen,
+							phydev);
+				dlen += 8;
+			} else if ((total - dlen) > 0) {
+				aeon_ipc_send_bulk_data(BW16, total - dlen,
+							wdata + dlen, phydev);
+				dlen = total;
+			}
+		}
+		sector_ofst++;
+
+		// write to flash
+		aeon_ipc_write_flash(flash_addr, temp_mem_addr,
+				     FLASH_SECTOR_SIZE, phydev);
+	}
+	release_firmware(fw);
+}
+
+void aeon_burn_image(unsigned char include_bootloader,
+		     struct phy_device *phydev)
+{
+	unsigned int new_addr = 0, old_addr = 0;
+	struct device *dev = phydev_dev(phydev);
+	int ofst;
+	// Disable WDT
+	aeon_ipc_set_wdt(0, phydev);
+	if (include_bootloader == 0) {
+		ofst = aeon_ipc_sys_cpu_info(IPC_CMD_SYS_IMAGE_OFST, new_addr,
+					     old_addr, phydev);
+		if ((ofst == 0) || (ofst == IMAGE2_OFST)) {
+			new_addr = IMAGE1_HDR_OFST;
+			old_addr = IMAGE2_HDR_OFST;
+		} else if (ofst == IMAGE1_OFST) {
+			new_addr = IMAGE2_HDR_OFST;
+			old_addr = IMAGE1_HDR_OFST;
+		}
+		dev_info(dev, "new_addr: %u, old_addr : %u\n", new_addr, old_addr);
+		aeon_update_flash(FLASH_BIN, new_addr, phydev);
+		ofst = aeon_ipc_sys_cpu_info(IPC_CMD_SYS_CPU_IMAGE_CHECK,
+					     new_addr, 0x33d000, phydev);
+		if (ofst) {
+			aeon_update_flash(CLR_FLASH_IMAGE, old_addr, phydev);
+		} else {
+			dev_err(dev, "check image failed\n");
+			return;
+		}
+	} else {
+		aeon_update_flash(BOOT_LOADER_BIN, new_addr, phydev);
+	}
+	// Enable WDT
+	aeon_ipc_set_wdt(1, phydev);
+}
+#endif
+
+void aeon_sds_restart_an(struct phy_device *phydev)
+{
+	unsigned short data[8], reg_num = 1;
+
+	data[0] = CFG_SDS_RESTART_AN;
+
+	aeon_ipc_cfg_param_direct(reg_num, data, phydev);
+}
+
+void aeon_ipc_ng_test_mode(unsigned short test_mode, unsigned short tone,
+			   struct phy_device *phydev)
+{
+	unsigned short data[8], reg_num = 4;
+
+	data[0] = CFG_NG_PHYCTRL;
+	data[1] = IPC_CMD_CFG_NG_TESTMODE;
+	data[2] = test_mode;
+	data[3] = tone;
+
+	aeon_ipc_cfg_param_direct(reg_num, data, phydev);
+}
+
+void aeon_cu_an_enable(unsigned short enable, struct phy_device *phydev)
+{
+	unsigned short data[8], reg_num = 3;
+
+	data[0] = CFG_CU_AN;
+	data[1] = MDI_CFG_CU_AN_ENABLE;
+	data[2] = enable;
+
+	aeon_ipc_cfg_param_direct(reg_num, data, phydev);
+}
+
+void aeon_set_man_mdi(struct phy_device *phydev)
+{
+	unsigned short data[8], reg_num = 4;
+
+	data[0] = CFG_CU_AN;
+	data[1] = MDI_CFG_MAN_MDI;
+	data[2] = 1;
+	data[3] = MDI;
+
+	aeon_ipc_cfg_param_direct(reg_num, data, phydev);
+}
+
+void aeon_set_man_mdix(struct phy_device *phydev)
+{
+	unsigned short data[8], reg_num = 4;
+
+	data[0] = CFG_CU_AN;
+	data[1] = MDI_CFG_MAN_MDI;
+	data[2] = 1;
+	data[3] = MDIX;
+
+	aeon_ipc_cfg_param_direct(reg_num, data, phydev);
+}
+
+void aeon_set_man_duplex(unsigned short duplex, struct phy_device *phydev)
+{
+	unsigned short data[8], reg_num = 4;
+
+	data[0] = CFG_CU_AN;
+	data[1] = MDI_CFG_CU_AN_DUPLEX;
+	data[2] = 1;
+	data[3] = duplex;
+
+	aeon_ipc_cfg_param_direct(reg_num, data, phydev);
+}
+
+void aeon_ipc_set_tx_power_lvl(unsigned short gain, struct phy_device *phydev)
+{
+	unsigned short data[8], data_size;
+
+	data[0] = gain;
+	data_size = 1;
+
+	aeon_ipc_operation(phydev, IPC_DBGCMD_NGPHY, CFG_TM5_GAIN_IDX, data,
+			   data_size, 2, NULL, 0, 1);
+}
+
+void aeon_ng_test_mode(unsigned short top_spd, unsigned short test_mode,
+		       unsigned short tone, struct phy_device *phydev)
+{
+	unsigned short ms = 1;
+
+	aeon_ipc_ng_test_mode(0, 0, phydev);
+	// switch speed
+	aeon_cu_an_set_top_spd(top_spd, phydev);
+	// enable AN
+	aeon_cu_an_enable(1, phydev);
+	// restart AN
+	aeon_cu_an_restart(phydev);
+	mdelay(500);
+	if (test_mode == 3)
+		ms = 0;
+	aeon_cu_an_set_ms_cfg(0, 1, ms, phydev);
+	aeon_set_man_mdi(phydev);
+	aeon_ipc_ng_test_mode(test_mode, tone, phydev);
+	mdelay(10);
+	// disable AN
+	aeon_cu_an_enable(0, phydev);
+	mdelay(10);
+	aeon_mdio_write_reg_field(phydev, 0xF014E, 0x4, 0);
+	aeon_mdio_write_reg_field(phydev, 0xF014C, 0xC01, 1);
+	mdelay(10);
+	aeon_mdio_write_reg_field(phydev, 0xF014C, 0xC01, 0);
+}
+
+void aeon_1g_test_mode(unsigned short test_mode, struct phy_device *phydev)
+{
+	unsigned short ms = 1;
+	// enable AN
+	aeon_cu_an_enable(1, phydev);
+	aeon_mdio_write_reg_field(phydev, 0xFFFD2, 0xD03, 0);
+	// restart AN
+	aeon_cu_an_restart(phydev);
+	mdelay(500);
+	if (test_mode == 3)
+		ms = 0;
+	aeon_cu_an_set_ms_cfg(0, 1, ms, phydev);
+	aeon_set_man_mdi(phydev);
+	// switch speed
+	aeon_cu_an_set_top_spd(MDI_CFG_SPD_T1G, phydev);
+	aeon_mdio_write_reg_field(phydev, 0xFFFD2, 0xD03, test_mode);
+	// disable AN
+	aeon_cu_an_enable(0, phydev);
+}
+
+void aeon_man_configure(struct phy_device *phydev)
+{
+	unsigned short coeffs[12] = { 50, 200, 250, 250, 200, 50,
+				      0,  0,   0,   0,   0,   0 };
+	int i, j;
+
+	aeon_mdio_write_reg_field(phydev, 0x3C208C, 0xB, 0x20);
+	aeon_mdio_write_reg_field(phydev, 0x3C2002, 0x106, 6);
+	aeon_mdio_write_reg_field(phydev, 0x3C2078, 0x306, 4);
+	aeon_mdio_write_reg_field(phydev, 0xF0026, 0xC01, 1);
+	aeon_mdio_write_reg_field(phydev, 0x3C201E, 0x201, 1);
+
+	aeon_mdio_write_reg_field(phydev, 0xFFFE0, 0x501, 1);
+	aeon_mdio_write_reg_field(phydev, 0xFFFE0, 0x401, 0);
+	aeon_mdio_write_reg_field(phydev, 0xFFFE0, 0xA01, 1);
+	aeon_mdio_write_reg_field(phydev, 0xFFFE0, 0x201, 0);
+	aeon_mdio_write_reg_field(phydev, 0xFFFE0, 0x101, 0);
+
+	aeon_mdio_write_reg_field(phydev, 0x3C1602, 0xF01, 1);
+	aeon_mdio_write_reg_field(phydev, 0x3C1602, 0xE01, 1);
+	aeon_mdio_write_reg_field(phydev, 0x3C1602, 0xF01, 0);
+	aeon_mdio_write_reg_field(phydev, 0x3C1602, 0xE01, 0);
+
+	aeon_mdio_write_reg_field(phydev, 0x3C2020, 0x901, 1);
+	aeon_mdio_write_reg_field(phydev, 0x3C2020, 0x901, 0);
+
+	for (i = 0; i < 4; i++) {
+		aeon_mdio_write_reg_field(phydev, 0x41402 + i * 0x200, 0x901,
+					  1);
+		for (j = 0; j < 12; j++) {
+			aeon_mdio_write_reg_field(phydev, 0x41402 + i * 0x200,
+						  0x9, coeffs[j] & 0x1FF);
+			aeon_mdio_write_reg_field(phydev, 0x41400 + i * 0x200,
+						  0x104, j);
+			aeon_mdio_write_reg_field(phydev, 0x41400 + i * 0x200,
+						  0x1, 1);
+			aeon_mdio_write_reg_field(phydev, 0x41400 + i * 0x200,
+						  0x1, 0);
+		}
+	}
+}
+
+void aeon_100m_test_mode(struct phy_device *phydev)
+{
+	// enable AN
+	aeon_cu_an_enable(1, phydev);
+	aeon_cu_an_set_ms_cfg(0, 1, 0, phydev);
+	aeon_set_man_mdi(phydev);
+	// set half duplex
+	aeon_set_man_duplex(0, phydev);
+	// switch speed
+	aeon_cu_an_set_top_spd(MDI_CFG_SPD_T100, phydev);
+	// disable AN
+	aeon_cu_an_enable(0, phydev);
+	aeon_man_configure(phydev);
+}
+
+void aeon_ipc_set_tx_fullscale_delta(unsigned short speed,
+				     unsigned short *delta,
+				     struct phy_device *phydev)
+{
+	unsigned short data[8], reg_num = 5, i = 0;
+
+	data[0] = CFG_NG_PHYCTRL;
+	data[1] = IPC_CMD_CFG_TX_FULLSCALE;
+	data[2] = speed;
+	for (i = 0; i < 4; i++) {
+		data[3] = i;
+		data[4] = *(delta + i);
+
+		aeon_ipc_cfg_param_direct(reg_num, data, phydev);
+	}
+}
+
+void aeon_ipc_set_wol(unsigned short en, unsigned short *val,
+		      struct phy_device *phydev)
+{
+	unsigned short data[8], reg_num = 5;
+
+	data[0] = CFG_WOL;
+	data[1] = en;
+	data[2] = val[0];
+	data[3] = val[1];
+	data[4] = val[2];
+
+	aeon_ipc_cfg_param_direct(reg_num, data, phydev);
+}
+
+void aeon_ipc_smi_command(unsigned short *val, struct phy_device *phydev)
+{
+	unsigned short data[8], reg_num = 3;
+
+	data[0] = CFG_SMI_COMMAND;
+	data[1] = val[0];
+	data[2] = val[1];
+
+	aeon_ipc_cfg_param_direct(reg_num, data, phydev);
+}
+
+void aeon_ipc_irq_en(unsigned short *val, struct phy_device *phydev)
+{
+	struct device *dev = phydev_dev(phydev);
+	unsigned short status = 0;
+	unsigned short ret_size;
+	unsigned short data[8], reg_num = 5;
+
+	data[0] = IPC_CMD_IRQ_EN;
+	data[1] = val[0];
+	data[2] = val[1];
+	data[3] = val[2];
+	data[4] = val[3];
+
+	aeon_send_ipc_msg(phydev, reg_num, data, IPC_CMD_CFG_IRQ, reg_num * 2);
+	status = aeon_ipc_wait_cmd_done(phydev, NULL, &ret_size);
+	if (status != IPC_STS_CMD_SUCCESS) {
+		dev_err(dev, "set irq en command failed %x\n", status);
+		return;
+	}
+}
+
+void aeon_ipc_irq_clr(unsigned short val, struct phy_device *phydev)
+{
+	struct device *dev = phydev_dev(phydev);
+	unsigned short status = 0;
+	unsigned short ret_size;
+	unsigned short data[8], reg_num = 2;
+
+	data[0] = IPC_CMD_IRQ_CLR;
+	data[1] = val;
+
+	aeon_send_ipc_msg(phydev, reg_num, data, IPC_CMD_CFG_IRQ, reg_num * 2);
+	status = aeon_ipc_wait_cmd_done(phydev, NULL, &ret_size);
+	if (status != IPC_STS_CMD_SUCCESS) {
+		dev_err(dev, "set irq clr command failed %x\n", status);
+		return;
+	}
+}
+
+void aeon_ipc_irq_query(unsigned short *irq, struct phy_device *phydev)
+{
+	struct device *dev = phydev_dev(phydev);
+	unsigned short status = 0;
+	unsigned short ret_size;
+	unsigned short data[8], reg_num = 1;
+
+	data[0] = IPC_CMD_IRQ_QUERY;
+
+	aeon_send_ipc_msg(phydev, reg_num, data, IPC_CMD_CFG_IRQ, reg_num * 2);
+	status = aeon_ipc_wait_cmd_done(phydev, NULL, &ret_size);
+	if (status != IPC_STS_CMD_SUCCESS) {
+		dev_err(dev, "set irq query command failed %x\n", status);
+		return;
+	}
+	aeon_receive_ipc_data(phydev, 1, (unsigned short *)irq);
+}
+
+void aeon_ipc_get_tx_fullscale_delta(unsigned short speed,
+				     unsigned short *delta,
+				     struct phy_device *phydev)
+{
+	unsigned short data[8], reg_num = 3;
+
+	data[0] = CFG_NG_PHYCTRL;
+	data[1] = IPC_CMD_GET_TX_FULLSCALE;
+	data[2] = speed;
+
+	aeon_ipc_cfg_param_direct(reg_num, data, phydev);
+	aeon_receive_ipc_data(phydev, 4, (unsigned short *)delta);
+}
+
+void aeon_ipc_clear_log(struct phy_device *phydev)
+{
+	unsigned short status, ret_size;
+	unsigned short cfg[1] = { IPC_CMD_READ_LOG_CLEAR };
+	struct device *dev = phydev_dev(phydev);
+
+	aeon_send_ipc_msg(phydev, 1, cfg, IPC_CMD_LOG, 2);
+
+	status = aeon_ipc_wait_cmd_done(phydev, NULL, &ret_size);
+	if (status != IPC_STS_CMD_SUCCESS) {
+		dev_err(dev, "clear log command failed %x\n", status);
+		return;
+	}
+}
+
+void aeon_ipc_set_wdt(unsigned short en, struct phy_device *phydev)
+{
+	unsigned short data[8], reg_num = 2;
+
+	data[0] = CFG_WDT;
+	data[1] = en;
+
+	aeon_ipc_cfg_param_direct(reg_num, data, phydev);
+}
+
+void aeon_ipc_eye_scan(unsigned char sds_id, unsigned char grp,
+		       unsigned char *revc_buf, struct phy_device *phydev)
+{
+	unsigned char data[8], data_size;
+
+	data[0] = sds_id;
+	data[1] = grp;
+	data_size = 2;
+
+	aeon_ipc_operation(phydev, IPC_DBGCMD_SDS, CFG_SDS_EYE_SCAN, data,
+			   data_size, 1, revc_buf, EYE_STRIDE, 1);
+}
+
+void aeon_ipc_read_mem(unsigned short addr1, unsigned short addr2,
+		       unsigned short num, unsigned short *params, struct phy_device *phydev)
+{
+	unsigned short status, ret_size;
+	unsigned short cfg[3] = {addr1, addr2, num};
+	struct device *dev = phydev_dev(phydev);
+
+	aeon_send_ipc_msg(phydev, 3, cfg, IPC_CMD_RMEM16, 6);
+
+	status = aeon_ipc_wait_cmd_done(phydev, NULL, &ret_size);
+	if (status != IPC_STS_CMD_SUCCESS) {
+		dev_err(dev, "read mem command failed %x\n", status);
+		return;
+	}
+	aeon_receive_ipc_data(phydev, num, (unsigned short *)params);
+}
+
+void aeon_ipc_set_mac_cnt(unsigned long long mac_tot_cnt, unsigned long long mac_crc_cnt,
+			  struct phy_device *phydev)
+{
+	unsigned short data[8], reg_num = 6;
+
+	data[0] = CFG_MAC_CNT;
+	data[1] = IPC_CMD_MAC_TOT;
+	data[2] = mac_tot_cnt & 0xFFFF;
+	data[3] = (mac_tot_cnt >> 16) & 0xFFFF;
+	data[4] = (mac_tot_cnt >> 32) & 0xFFFF;
+	data[5] = (mac_tot_cnt >> 48) & 0xFFFF;
+
+	aeon_ipc_cfg_param_direct(reg_num, data, phydev);
+	mdelay(2);
+
+	data[0] = CFG_MAC_CNT;
+	data[1] = IPC_CMD_MAC_CRC;
+	data[2] = mac_crc_cnt & 0xFFFF;
+	data[3] = (mac_crc_cnt >> 16) & 0xFFFF;
+	data[4] = (mac_crc_cnt >> 32) & 0xFFFF;
+	data[5] = (mac_crc_cnt >> 48) & 0xFFFF;
+
+	aeon_ipc_cfg_param_direct(reg_num, data, phydev);
+}
+
+
+void aeon_sds2nd_mode_cfg(unsigned short pcs_mode, unsigned short sds_spd, unsigned short op_mode,
+			  struct phy_device *phydev)
+{
+	unsigned short data[8], reg_num = 5;
+	// the order should match firmware cfg parameter sequence.
+	data[0] = CFG_SDS2ND_MODE;
+	data[1] = CFG_SDS2ND_MODE;
+	data[2] = pcs_mode;
+	data[3] = sds_spd;
+	data[4] = op_mode;
+
+	aeon_ipc_cfg_param_direct(reg_num, data, phydev);
+}
+
+
+void aeon_sds2nd_enable(unsigned short enable, struct phy_device *phydev)
+{
+	unsigned short data[8], reg_num = 3;
+	// the order should match firmware cfg parameter sequence.
+	data[0] = CFG_SDS2ND_EN;
+	data[1] = CFG_SDS2ND_EN;
+	data[2] = enable;
+
+	aeon_ipc_cfg_param_direct(reg_num, data, phydev);
+}
+
+void aeon_sds2nd_eq_cfg(unsigned short vga, unsigned short slc, unsigned short ctle,
+			unsigned short dfe,
+			struct phy_device *phydev)
+{
+	unsigned short data[8], reg_num = 6;
+	// the order should match firmware cfg parameter sequence.
+	data[0] = CFG_SDS2ND_EQ;
+	data[1] = CFG_SDS2ND_EQ;
+	data[2] = vga;
+	data[3] = slc;
+	data[4] = ctle;
+	data[5] = dfe;
+
+	aeon_ipc_cfg_param_direct(reg_num, data, phydev);
+}
+
+void aeon_ipc_cable_diag(unsigned short sub_cmd, unsigned short *data_rcv, unsigned short mode,
+			 struct phy_device *phydev)
+{
+	unsigned short data[8], data_size = 0, data_num = 0;
+
+	data[0] = mode;
+
+	switch (sub_cmd) {
+	case IPC_CMD_CABLE_DIAG_CHAN_LEN:
+		data_num = 8;
+		break;
+	case IPC_CMD_CABLE_DIAG_PPM_OFST:
+		data_num = 8;
+		break;
+	case IPC_CMD_CABLE_DIAG_SNR_MARG:
+	case IPC_CMD_CABLE_DIAG_CHAN_SKW:
+		data_num = 16;
+		break;
+	case IPC_CMD_CABLE_DIAG_GET:
+		data_num = 10;
+		break;
+	case IPC_CMD_CABLE_DIAG_SET:
+		data_size = 1;
+		break;
+	}
+
+	aeon_ipc_operation(phydev, CFG_CABLE_DIAG, sub_cmd, data,
+			   data_size, 2, data_rcv, data_num, 2);
+
+}
+
+void aeon_normal_retrain_cfg(unsigned short enable, struct phy_device *phydev)
+{
+	unsigned short data[8], data_size;
+
+	data[0] = enable;
+	data_size = 1;
+
+	aeon_ipc_operation(phydev, IPC_DBGCMD_NGPHY, CFG_NORMAL_RETRAIN_ABI, data,
+			   data_size, 2, NULL, 0, 1);
+}
+
+void aeon_ipc_sds_txfir(unsigned char sds_id, unsigned char pre, unsigned char main,
+			unsigned char post, struct phy_device *phydev)
+{
+	unsigned char data[8], data_size;
+
+	data[0] = sds_id;
+	data[1] = pre;
+	data[2] = main;
+	data[3] = post;
+	data_size = 4;
+
+	aeon_ipc_operation(phydev, IPC_DBGCMD_SDS, CFG_SDS_TXFIR_SET, data,
+			   data_size, 1, NULL, 0, 1);
+}
+
+void aeon_ipc_auto_link_ena(unsigned char enable, struct phy_device *phydev)
+{
+	unsigned char data[8], data_size;
+
+	data[0] = enable;
+	data_size = 1;
+
+	aeon_ipc_operation(phydev, IPC_DBGCMD_AUTO_LINK, CFG_AUTO_LINK_ENA, data,
+			   data_size, 1, NULL, 0, 1);
+}
+
+
+void aeon_ipc_auto_link_cfg(unsigned char link_type, struct phy_device *phydev)
+{
+	unsigned char data[8], data_size;
+
+	data[0] = link_type;
+	data_size = 1;
+
+	aeon_ipc_operation(phydev, IPC_DBGCMD_AUTO_LINK, CFG_AUTO_LINK_CFG, data,
+			   data_size, 1, NULL, 0, 1);
+}
+
+void aeon_synce_enable_cfg(unsigned char enable, struct phy_device *phydev)
+{
+	unsigned char data[8], data_size;
+
+	data[0] = enable;
+	data_size = 1;
+
+	aeon_ipc_operation(phydev, IPC_DBGCMD_SYNCE, IPC_SYNCE_ENABLE, data,
+			   data_size, 1, NULL, 0, 1);
+}
+
+void aeon_synce_mode_cfg(unsigned char ms, struct phy_device *phydev)
+{
+	unsigned char data[8], data_size;
+
+	data[0] = ms;
+	data_size = 1;
+
+	aeon_ipc_operation(phydev, IPC_DBGCMD_SYNCE, IPC_SYNCE_MODE, data,
+			   data_size, 1, NULL, 0, 1);
+}
+
+void aeon_synce_user_bw(unsigned char bw, struct phy_device *phydev)
+{
+	unsigned short data[8], data_size;
+
+	data[0] = bw;
+	data_size = 1;
+
+	aeon_ipc_operation(phydev, IPC_DBGCMD_SYNCE, IPC_SYNCE_USER_BW, data,
+			   data_size, 1, NULL, 0, 1);
+}
+
+void aeon_synce_slave_output_ctrl_cfg(unsigned char oc, struct phy_device *phydev)
+{
+	unsigned short data[8], data_size;
+
+	data[0] = oc;
+	data_size = 1;
+
+	aeon_ipc_operation(phydev, IPC_DBGCMD_SYNCE, IPC_SYNCE_SLAVE_CLK_OUTPUT_CTRL, data,
+			   data_size, 1, NULL, 0, 1);
+}
+
+void aeon_parallel_det(unsigned char enable, struct phy_device *phydev)
+{
+	unsigned short data[8], data_size;
+
+	data[0] = enable;
+	data_size = 1;
+
+	aeon_ipc_operation(phydev, IPC_DBGCMD_CU_AN, IPC_CMD_CU_AN_PARA_DET, data,
+			   data_size, 1, NULL, 0, 1);
+}
diff --git a/drivers/net/phy/as21xx_bbu_api/as21xx_api.h b/drivers/net/phy/as21xx_bbu_api/as21xx_api.h
new file mode 100644
index 0000000..becea6d
--- /dev/null
+++ b/drivers/net/phy/as21xx_bbu_api/as21xx_api.h
@@ -0,0 +1,1133 @@
+/******************************************************************************
+ *
+ * AEONSEMI CONFIDENTIAL
+ * _____________________
+ *
+ * Aeonsemi Inc., 2023
+ * All Rights Reserved.
+ *
+ * NOTICE:  All information contained herein is, and remains the property of
+ * Aeonsemi Inc. and its subsidiaries, if any. The intellectual and technical
+ * concepts contained herein are proprietary to Aeonsemi Inc. and its
+ * subsidiaries and may be covered by U.S. and Foreign Patents, patents in
+ * process, and are protected by trade secret or copyright law. Dissemination
+ * of this information or reproduction of this material is strictly forbidden
+ * unless prior written permission is obtained from Aeonsemi Inc.
+ *
+ *
+ *****************************************************************************/
+#ifndef _AS21XX_API_H
+#define _AS21XX_API_H
+
+#include <linux/mii.h>
+#include <linux/phy.h>
+#include <linux/version.h>
+
+typedef enum {
+	DATA_UINT8 = 1,
+	DATA_UINT16 = 2,
+	DATA_UINT32 = 4,
+} ipc_data_type_t;
+
+#define AS21XX_PHY_NUM 2
+#define MAX_POLL 100
+
+#if (KERNEL_VERSION(4, 5, 0) > LINUX_VERSION_CODE)
+#define phydev_mdio_bus(_dev) (_dev->bus)
+#define phydev_addr(_dev) (_dev->addr)
+#define phydev_dev(_dev) (&_dev->dev)
+#else
+#define phydev_mdio_bus(_dev) (_dev->mdio.bus)
+#define phydev_addr(_dev) (_dev->mdio.addr)
+#define phydev_dev(_dev) (&_dev->mdio.dev)
+#endif
+
+#define IPC_DATA_UINT8 1
+#define IPC_DATA_UINT16 2
+#define IPC_DATA_UINT32 4
+
+#define FLASH_CHIP_SIZE 0x00200000
+#define IMAGE1_HDR_OFST 0x10000
+#define IMAGE1_OFST 0x10400
+#define IMAGE2_HDR_OFST 0x80000
+#define IMAGE2_OFST 0x80400
+#define MEM_WORD_SIZE 4
+#define BOOT_LOADER_BIN "bootloader_all.bin"
+#define FLASH_BIN "flash_burn.bin"
+#define CLR_FLASH_IMAGE "clr_flash_image.bin"
+#define ERASE_MODE_SECTOR 1
+#define ERASE_MODE_BLOCK 2
+#define FLASH_SECTOR_SIZE 4096
+
+/**
+ * @Regsiter addresses and fields
+ * @Registers used in MDIO boot
+ */
+#define AEON_REG_ADDR_OFFSET 0xEA000000
+#define AN_REG_GIGA_STD_STATUS_BASEADDR (AEON_REG_ADDR_OFFSET + 0xFFFC2)
+#define IPC_CMD_BASEADDR (AEON_REG_ADDR_OFFSET + 0x3CB002)
+#define IPC_STS_BASEADDR (AEON_REG_ADDR_OFFSET + 0x3CB004)
+#define IPC_DATA0_BASEADDR (AEON_REG_ADDR_OFFSET + 0x3CB010)
+
+/**
+ * @name Opcode
+ * @brief Introduction of opcodes.
+ * @brief 16-bit register IPC_CMD_BASEADDR is laid out as follows:
+ * @brief [1 bit parity][4 bits reserved][5 bits size][6 bits opcode].
+ *
+ * The following opcodes indicate the last 6 bits above:
+ * @IPC_CMD_NOOP: Do nothing
+ * @IPC_CMD_INFO: Get Firmware Version
+ * @IPC_CMD_SYS_CPU: SYS_CPU
+ * @IPC_CMD_RMEM16: Read date from MEM
+ * @IPC_CMD_BULK_DATA: Pass bulk data in ipc registers
+ * @IPC_CMD_BULK_WRITE: Write bulk data to memory
+ * @IPC_CMD_FLASH_WRITE: Write memory data to flash
+ * @IPC_CMD_FLASH_ERASE: Erase flash
+ * @IPC_CMD_LOG: Read log
+ * @IPC_OPCODE_POLL
+ * @IPC_CMD_CFG_PARAM: Write config parameters to memory
+ * @IPC_CMD_CFG_IRQ: Cfg IRQ Output
+ * @IPC_CMD_SET_LED: Set led
+ * @IPC_OPCODE_DBGCMD
+ * @IPC_OPCODE_WBUF
+ * @IPC_OPCODE_RBUF
+ */
+#define IPC_CMD_NOOP 0x0
+#define IPC_CMD_INFO 0x1
+#define IPC_CMD_SYS_CPU 0x2
+#define IPC_CMD_RMEM16 0x3
+#define IPC_CMD_BULK_DATA 0xA
+#define IPC_CMD_BULK_WRITE 0xC
+#define IPC_CMD_FLASH_WRITE 0xE
+#define IPC_CMD_FLASH_ERASE 0xF
+#define IPC_CMD_LOG 0x13
+#define IPC_OPCODE_DBGCMD 0x16
+#define IPC_OPCODE_POLL 0x17
+#define IPC_OPCODE_WBUF 0x18
+#define IPC_OPCODE_RBUF 0x19
+#define IPC_CMD_CFG_PARAM 0x1A
+#define IPC_CMD_CFG_IRQ 0x22
+#define IPC_CMD_SET_LED 0x23
+
+/**
+ * @name Cfg_module
+ * @brief Introduction of modules of sub_commands
+ */
+enum custom_direct_cfg_module {
+	CFG_NG_PHYCTRL = 1,
+	CFG_CU_AN = 2,
+	CFG_SDS_PCS = 3,
+	CFG_AUTO_EEE = 4,
+	CFG_SDS_PMA = 5,
+	CFG_DPC_RA = 6,
+	CFG_DPC_PKT_CHK = 7,
+	CFG_DPC_SDS_WAIT_ETH = 8,
+	CFG_WDT = 9,
+	CFG_SDS_RESTART_AN = 10,
+	CFG_TEMP_MON = 11,
+	CFG_WOL = 12,
+	CFG_SMI_COMMAND = 13,
+	CFG_EYE_DRAW = 15,
+	CFG_MAC_CNT = 16,
+	CFG_SDS2ND_EN = 17,
+	CFG_SDS2ND_MODE = 18,
+	CFG_SDS2ND_EQ = 19,
+};
+
+/**
+ * @name Cfg_irq
+ * @brief Introduction of modules of sub_commands
+ */
+enum custom_irq_cfg_module {
+	IPC_CMD_IRQ_EN = 0x0,
+	IPC_CMD_IRQ_QUERY = 0x1,
+	IPC_CMD_IRQ_CLR = 0x2,
+};
+
+/**
+ * @name Cfg_synce
+ * @brief Introduction of modules of sub_commands
+ */
+enum custom_synce_cfg_module {
+	IPC_SYNCE_ENABLE = 0x0,
+	IPC_SYNCE_MODE = 0x1,
+	IPC_SYNCE_USER_BW = 0x2,
+	IPC_SYNCE_SLAVE_CLK_OUTPUT_CTRL = 0x3,
+};
+
+/**
+ * @name Sub_command
+ * @brief Introduction of sub_commands of opcodes
+ */
+/**
+ * @name Sub_command
+ * @brief Introduction of sub_commands of opcodes
+ *
+ * @IPC_CMD_INFO_VERSION: Sub-command of IPC_CMD_INFO
+ * @IPC_CMD_SYS_REBOOT: Sub-command of IPC_CMD_SYS_CPU, reboot phy
+ * @IPC_CMD_SYS_IMAGE_OFST: Sub-command of IPC_CMD_SYS_CPU, get flash image offset
+ * @IPC_CMD_SYS_CPU_IMAGE_CHECK: Sub-command of IPC_CMD_SYS_CPU, CRC check after upgrading
+ *                               flash image
+ * @IPC_CMD_SYS_CPU_PHY_ENABLE: Sub-command of IPC_CMD_SYS_CPU, enable/disable phy
+ * @IPC_CMD_CFG_DIRECT: Sub-command of IPC_CMD_CFG_PARAM, configure parameters of AN, DPC, phy_ctrl
+ * @IPC_CMD_READ_LOG_CLEAR: Sub-command of IPC_CMD_LOG
+ * @CFG_NORMAL_RETRAIN_ABI
+ * @CFG_TM5_GAIN_IDX
+ * @CFG_SDS_TXFIR_SET: Sub-command of CFG_SDS
+ * @CFG_AUTO_LINK_ENA: Sub-command of CFG_AUTO_LINK
+ * @CFG_AUTO_LINK_CFG: Sub-command of CFG_AUTO_LINK
+ */
+#define IPC_CMD_INFO_VERSION 0x1
+#define IPC_CMD_SYS_REBOOT 0x3
+#define IPC_CMD_SYS_IMAGE_OFST 0x4
+#define IPC_CMD_SYS_CPU_IMAGE_CHECK 0x5
+#define IPC_CMD_SYS_CPU_PHY_ENABLE 0x6
+#define IPC_CMD_CFG_DIRECT 0x4
+#define IPC_CMD_READ_LOG_CLEAR 0x3
+#define CFG_NORMAL_RETRAIN_ABI 13
+#define CFG_TM5_GAIN_IDX 14
+#define CFG_SDS_EYE_SCAN 1
+#define CFG_SDS_TXFIR_SET 27
+#define CFG_AUTO_LINK_ENA 0
+#define CFG_AUTO_LINK_CFG 1
+#define IPC_CMD_CABLE_DIAG_CHAN_LEN 0
+#define IPC_CMD_CABLE_DIAG_PPM_OFST 1
+#define IPC_CMD_CABLE_DIAG_SNR_MARG 2
+#define IPC_CMD_CABLE_DIAG_CHAN_SKW 3
+#define IPC_CMD_CABLE_DIAG_SET 11
+#define IPC_CMD_CABLE_DIAG_GET 12
+#define IPC_CMD_CU_AN_PARA_DET 8
+
+/**
+ * @name Feature
+ * @brief Introduction of features of modules
+ */
+#define IPC_CMD_CFG_PHYCTRL_PAUSED 0x2
+#define IPC_CMD_CFG_TX_FULLSCALE 0x3
+#define IPC_CMD_CFG_NG_TESTMODE 0x4
+#define IPC_CMD_GET_TX_FULLSCALE 0x5
+#define MDI_CFG_MAN_MDI 0x0
+#define MDI_CFG_CU_AN_ENABLE 0x1
+#define MDI_CFG_CU_AN_DUPLEX 0x2
+#define MDI_CFG_CU_AN_EEE_SPD 0x3
+#define MDI_CFG_CU_AN_FR_SPD 0x4
+#define MDI_CFG_CU_AN_DS 0x6
+#define MDI_CFG_CU_AN_RESTART 0xa
+#define MDI_CFG_CU_AN_AEON_OUI 0xb
+#define IPC_CMD_CU_AN_TOP_SPD 0xc
+#define IPC_CMD_CU_AN_MS_CFG 0xd
+#define IPC_CMD_CU_AN_TRD_SWAP 0xe
+#define IPC_CMD_CU_AN_GET_MS_CFG 0xf
+#define IPC_CMD_CU_AN_CFR 0x10
+#define IPC_CMD_MAC_TOT 0x0
+#define IPC_CMD_MAC_CRC 0x1
+/** @} */
+
+/**
+ * @name Status
+ * @brief Introduction of IPC status
+ * 16-bit register IPC_STS_BASEADDR is laid out as follows:
+ * [1 bit parity][5 bits size][6 bits opcode][4 bits status]
+ *
+ * The following status indicates the last 4 bits above.
+ */
+#define IPC_STS_CMD_RCVD 0x1
+#define IPC_STS_CMD_PROCESS 0x2
+#define IPC_STS_CMD_SUCCESS 0x4
+#define IPC_STS_CMD_ERROR 0x8
+#define IPC_STS_SYS_BUSY 0xE
+#define IPC_STS_SYS_READY 0xF
+
+extern int aeon_cl45_read(struct phy_device *phydev, int dev_addr,
+			  unsigned int phy_reg);
+extern void aeon_cl45_write(struct phy_device *phydev, int dev_addr,
+			    unsigned int phy_reg, unsigned short phy_data);
+/** @} */
+/** @name IPC Function
+ * @brief Introduction of IPC functions
+ * @{
+ *
+ 1. **Opcode : IPC_CMD_NOOP**
+ *
+ * Api : void aeon_ipc_sync_parity(struct phy_device *phydev);
+ *
+ 2. **Opcode : IPC_CMD_INFO**
+ *
+ * Sub-command : IPC_CMD_INFO_VERSION
+ *
+ * Api : void aeon_ipc_get_fw_version(char *version, struct phy_device *phydev);
+ *
+ * param : version The string to get FW version.
+ *
+ 3. **Opcode : IPC_CMD_SYS_CPU**
+ *
+ * 3.1 Sub-command : IPC_CMD_SYS_REBOOT
+ *
+ * Api : void aeon_ipc_set_sys_reboot(struct phy_device *phydev);
+ *
+ * 3.2 Sub-command : IPC_CMD_SYS_CPU_PHY_ENABLE
+ *
+ * Api : void aeon_ipc_phy_enable_mode(unsigned short enable, struct phy_device *phydev);
+ *
+ * param : enable Enable/disable PHY.
+ *
+ * 3.3 Sub-command : IPC_CMD_SYS_CPU_IMAGE_CHECK, IPC_CMD_SYS_IMAGE_OFST
+ *
+ * Api : int aeon_ipc_sys_cpu_info(unsigned short sub_cmd, unsigned int flash_addr,
+ *                                 unsigned int mem_addr, struct phy_device *phydev)
+ *
+ * param : sub_cmd IPC_CMD_SYS_CPU_IMAGE_CHECK / IPC_CMD_SYS_IMAGE_OFST
+ *
+ * param : flash_addr Flash address to write.
+ *
+ * param : mem_addr Memory address to write.
+ *
+ 4. **Opcode : IPC_CMD_BULK_DATA**
+ *
+ * Api : void aeon_ipc_send_bulk_data(unsigned short bw_type, unsigned short size,
+ *                                    void *data, struct phy_device *phydev);
+ *
+ * param : bw_type Type of bit-width of data.
+ *
+ * param : size Size of data.
+ *
+ * param : data Data to write to IPC data registers.
+ *
+ 5. **Opcode : IPC_CMD_BULK_WRITE**
+ *
+ * Api : void aeon_ipc_send_bulk_write(unsigned int mem_addr, unsigned int size,
+ *                                     struct phy_device *phydev);
+ *
+ * param : mem_addr Memory address to write.
+ *
+ * param : size Size of data.
+ *
+ 6. **Opcode : IPC_CMD_FLASH_WRITE**
+ *
+ * Api : void aeon_ipc_write_flash(unsigned int flash_addr, unsigned int mem_addr,
+ *                                 unsigned short size, struct phy_device *phydev);
+ *
+ * param : flash_addr Flash address to write.
+ *
+ * param : mem_addr Memory address of the data we want to write to flash.
+ *
+ * param : size Size of data.
+ *
+ 7. **Opcode : IPC_CMD_FLASH_ERASE**
+ *
+ * Api : void aeon_ipc_erase_flash(unsigned int flash_addr, unsigned int size,
+ *                                 unsigned short mode, struct phy_device *phydev);
+ *
+ * param : flash_addr Flash address to erase.
+ *
+ * param : size Size of data.
+ *
+ * param : mode Mode of erasing. 1 : sector erase, 2 : block erase.
+ *
+ 8. **Opcode : IPC_CMD_CFG_PARAM**
+ *
+ * Sub-command : IPC_CMD_CFG_DIRECT
+ *
+ * 8.1 Cfg-module : CFG_NG_PHYCTRL
+ *
+ * 8.1.1 Feature : IPC_CMD_CFG_PHYCTRL_PAUSED
+ *
+ * Api : void aeon_ipc_set_fsm_mode(unsigned short fsm, unsigned short mode,
+ *                                  struct phy_device *phydev);
+ *
+ * param : fsm Macro of FSMs.
+ *
+ * param : mode FSM running mode.
+ *
+ * 8.1.2 Feature : IPC_CMD_CFG_TX_FULLSCALE
+ *
+ * Api : void aeon_ipc_set_tx_fullscale_delta(unsigned short speed, unsigned short *delta,
+ *                                            struct phy_device *phydev);
+ *
+ * param : 4(100M), 8(1G), 16(2.5G), 32(5G), 64(10G).
+ *
+ * param : Value to set.
+ *
+ * 8.1.3 Feature : IPC_CMD_CFG_NG_TESTMODE
+ *
+ * Api : void aeon_ipc_ng_test_mode(unsigned short test_mode, unsigned short tone,
+ *                                  struct phy_device *phydev);
+ *
+ * param : test_mode Test mode to be set.
+ *
+ * param : tone Test tone to be set.
+ *
+ * 8.1.4 Feature : IPC_CMD_GET_TX_FULLSCALE
+ *
+ * Api : void aeon_ipc_get_tx_fullscale_delta(unsigned short speed, unsigned short *delta,
+ *                                            struct phy_device *phydev);
+ *
+ * param : speed Speed mode.
+ *
+ * param : delta Array to get tx_fullscale.
+ *
+ * 8.2 Cfg-module : CFG_CU_AN
+ *
+ * 8.2.1 Feature : MDI_CFG_CU_AN_EEE_SPD
+ *
+ * Api : void aeon_cu_an_set_eee_spd(unsigned short speed_mode, struct phy_device *phydev);
+ *
+ * param : speed_mode 7 bits [10G eee en] [5G eee en] [2.5G eee en] [1G eee en] [100m eee] [0] [0].
+ *
+ * note : If you set EEE abilities of all speeds, speed_mode = 0b1111100(0x7C).
+ *
+ * 8.2.2 Feature : MDI_CFG_CU_AN_FR_SPD
+ *
+ * Api : void aeon_cu_an_set_fast_retrain(unsigned short speed_mode, unsigned short thp_bypass,
+ *                                        struct phy_device *phydev);
+ *
+ * param : speed_mode 7 bits [10G fr] [5G fr] [2.5G fr] [0] [0] [0] [0].
+ *
+ * param : thp_bypass 2 bits [5G thp_bypass] [2.5G thp_bypass]
+ *
+ * note : If you set FR abilities and thp_bypass of all speeds, speed_mode = 0b1110000(0x70),
+ *        thp_bypass = 3.
+ *
+ * 8.2.3 Feature : MDI_CFG_CU_AN_DS
+ *
+ * Api : void aeon_cu_an_enable_downshift(unsigned short enable, unsigned short retry_limit,
+ *                                        struct phy_device *phydev);
+ *
+ * param : enable Enable/disable downshift.
+ *
+ * param : retry_limit Limited failure times of training.
+ *
+ * 8.2.4 Feature : MDI_CFG_CU_AN_RESTART
+ *
+ * Api : void aeon_cu_an_restart(struct phy_device *phydev);
+ *
+ * 8.2.5 Feature : MDI_CFG_CU_AN_AEON_OUI
+ *
+ * Api : void aeon_cu_an_enable_aeon_oui(unsigned short nstd_pbo, struct phy_device *phydev);
+ *
+ * param : nstd_pbo 2 bits [max_pbo] [min_pbo]
+ *
+ * note : If you want to enable max_pbo and min_pbo, nstd_pbo = 3.
+ *
+ * 8.2.6 Feature : IPC_CMD_CU_AN_TOP_SPD
+ *
+ * Fucntion : void aeon_cu_an_set_top_spd(unsigned short top_spd, struct phy_device *phydev);
+ *
+ * param : top_spd 7 bits [10G] [5G] [2.5G] [1G] [100m] [0] [0].
+ *
+ * 8.2.7 Feature : IPC_CMD_CU_AN_MS_CFG
+ *
+ * Api : void aeon_cu_an_set_ms_cfg(unsigned short port_type, unsigned short ms_man_en,
+ *                                  unsigned short ms_man_val, struct phy_device *phydev);
+ *
+ * param : port_type 0: single port, 1: multi port.
+ *
+ * param : ms_man_en 0: disable manual m/s, 1: enable manual m/s.
+ *
+ * param : ms_man_val 0: slave, 1: master
+ *
+ * 8.2.8 Feature : IPC_CMD_CU_AN_TRD_SWAP
+ *
+ * Api : void aeon_cu_an_set_trd_swap(unsigned short en, unsigned short trd_swap,
+ *                                    struct phy_device *phydev);
+ *
+ * param : trd_swap 1 : enable TRD swap, 0 : disable TRD swap.
+ *
+ * 8.2.9 Feature : IPC_CMD_CU_AN_GET_MS_CFG
+ *
+ * Api : void aeon_cu_an_get_ms_cfg(unsigned short *ms_related_cfg, struct phy_device *phydev);
+ *
+ * param : ms_related_cfg Array to put ms_cfg, ms_related_cfg[0] indicate port_type,
+ *         ms_related_cfg[1] indicates ms_man_en, ms_related_cfg[2] indicates ms_man_val.
+ *
+ * 8.2.10 Feature : IPC_CMD_CU_AN_CFR
+ *
+ * Api : void aeon_cu_an_set_cfr(unsigned short cfr, struct phy_device *phydev);
+ *
+ * param : cfr 1 : enable CFR, 0 : disable CFR.
+ *
+ * 8.3 Cfg-module : CFG_SDS_PCS
+ *
+ * Api : void aeon_sds_pcs_set_cfg(unsigned short pcs_mode, unsigned short sds_spd,
+ *                                 struct phy_device *phydev);
+ *
+ * param : pcs_mode 1 : 64/66B, 0 : 8B/10B.
+ *
+ * param : sds_spd 3 : 10G, 2 : 5G, 1 : 2.5G, 0 : 1G.
+ *
+ * 8.4 Cfg-module : CFG_AUTO_EEE
+ *
+ * Api : void aeon_auto_eee_cfg(unsigned short enable, unsigned int idle_th,
+ *                              struct phy_device *phydev);
+ *
+ * param : enable 1 : enable auto-eee, 0 : disable auto-eee.
+ *
+ * param : idle_th idle threshhold
+ *
+ * 8.5 Cfg-module : CFG_SDS_PMA
+ *
+ * Api : void aeon_sds_pma_set_cfg(unsigned short vga_adapt, unsigned short slc_adapt,
+ *                                 unsigned short ctle_adapt, unsigned short dfe_adapt,
+ *                                 struct phy_device *phydev);
+ *
+ * param : vga_adapt 1 : enable VGA adaptation, 0 : disable VGA adaptation.
+ *
+ * param : slc_adapt 1 : enable slicer adaptation, 0 : disable slicer adaptation.
+ *
+ * param : ctle_adapt 1 : enable CTLE adaptation, 0 : disable CTLE adaptation.
+ *
+ * param : dfe_adapt 1 : enable DFE adaptation, 0 : disable DFE adaptation.
+ *
+ * 8.6 Cfg-module : CFG_DPC_RA
+ *
+ * Api : void aeon_dpc_ra_enable(struct phy_device *phydev);
+ *
+ * 8.7 Cfg-module : CFG_DPC_PKT_CHK
+ *
+ * Api : void aeon_pkt_chk_cfg(unsigned short enable, struct phy_device *phydev);
+ *
+ * param : enable Enable/disable packet checker.
+ *
+ * 8.8 Cfg-module : CFG_DPC_SDS_WAIT_ETH
+ *
+ * Api : void aeon_sds_wait_eth_cfg(unsigned short sds_wait_eth_delay, struct phy_device *phydev);
+ *
+ * param : sds_wait_eth_delay Delay.
+ *
+ * 8.9 Cfg-module : CFG_WDT
+ *
+ * Api : void aeon_ipc_set_wdt(unsigned short en, struct phy_device *phydev);
+ *
+ * param : en Enable/disable WDT.
+ *
+ * 8.10 Cfg-module : CFG_SDS_RESTART_AN
+ *
+ * Api : void aeon_sds_restart_an(struct phy_device *phydev);
+ *
+ * 8.11 Cfg-module : IPC_CMD_TEMP_MON
+ *
+ * Api : void aeon_ipc_temp_monitor(unsigned short sub_cmd, unsigned short params,
+ *                                  unsigned short *temperature, struct phy_device *phydev);
+ *
+ * param : sub_cmd 1 : start, 2 : stop, 3 : set configuration, 4 : get temperature,
+ *                 5 : set threshhold
+ *
+ * param : params For sub_cmd = 3, 1 indicates continuous sampling, 0 indicates a single sample.
+ *
+ * For sub_cmd = 5, params indicates the temperature threshold to be set.
+ *
+ * param : temperature To save current temperature got from ipc command.
+ *
+ * 8.12 Cfg-module : CFG_WOL
+ *
+ * Api : void aeon_ipc_set_wol(unsigned short en, unsigned short *val, struct phy_device *phydev);
+ *
+ * param : en 0 : mac addr and passwd return default value, 1 : cfg mac addr, 2 : cfg passwd,
+ *                                                          3 : cfg mac addr.
+ *
+ * param : val mac addr and passwd for wol.
+ *
+ * 8.13 Cfg-module : CFG_SMI_COMMAND
+ *
+ * Api : void aeon_ipc_smi_command(unsigned short *val, struct phy_device *phydev);
+ *
+ * param : val SMI Command Value.
+ *
+ * 8.15 Cfg-module : CFG_SDS2ND_EN
+ *
+ * Api : void aeon_sds2nd_enable(unsigned short en, struct phy_device *phydev);
+ *
+ * param : en 1 : enable 2nd serdes, 0 : 2nd serdes.
+ *
+ * 8.16 Cfg-module : CFG_SDS2ND_MODE
+ *
+ * Api : void aeon_sds2nd_mode_cfg(unsigned short pcs_mode, unsigned short sds_spd,
+ *                                 unsigned short op_mode, struct phy_device *phydev);
+ *
+ * param : pcs_mode 1 : 64/66B, 0 : 8B/10B.
+ *
+ * param : sds_spd 3 : 10G, 2 : 5G, 1 : 2.5G, 0 : 1G.
+ *
+ * 8.17 Cfg-module : CFG_SDS2ND_EQ
+ *
+ * Api : void aeon_sds2nd_eq_cfg(unsigned short vga, unsigned short slc, unsigned short ctle,
+ *                               unsigned short dfe, struct phy_device *phydev);
+ *
+ * param : vga 1 : enable VGA adaptation, 0 : disable VGA adaptation.
+ *
+ * param : slc 1 : enable slicer adaptation, 0 : disable slicer adaptation.
+ *
+ * param : ctle 1 : enable CTLE adaptation, 0 : disable CTLE adaptation.
+ *
+ * param : dfe 1 : enable DFE adaptation, 0 : disable DFE adaptation.
+ *
+ 9. **Opcode : IPC_CMD_SET_LED**
+ *
+ * Api : void aeon_ipc_set_led_cfg(unsigned short led0, unsigned short led1,
+ *                                 unsigned short led2, unsigned short led3,
+ *                                 unsigned short led4, unsigned short polarity,
+ *                                 unsigned short blink, struct phy_device *phydev);
+ *
+ * param : led0 Behavior of LED0.
+ *
+ * param : led1 Behavior of LED1.
+ *
+ * param : led2 Behavior of LED2.
+ *
+ * param : led3 Behavior of LED3.
+ *
+ * param : led4 Behavior of LED4.
+ *
+ * param : led5 Behavior of LED5.
+ *
+ * param : polarity cfg of these leds.
+ *
+ * param : blink Blink rate of these leds.
+ *
+ 10. **Opcode : IPC_CMD_CFG_IRQ**
+ *
+ * 10.1 Cfg-module : IPC_CMD_IRQ_EN
+ *
+ * Api : aeon_ipc_irq_en(unsigned short *irq, struct phy_device *phydev);
+ *
+ * param : val[0] enable irq index, val[0] enable irq value.
+ *
+ * 10.2 Cfg-module : IPC_CMD_IRQ_QUERY
+ *
+ * Api : aeon_ipc_irq_query(unsigned short *irq, struct phy_device *phydev);
+ *
+ * param : irq trigger .
+ *
+ * 10.3 Cfg-module : IPC_CMD_IRQ_CLR
+ *
+ * Api : void aeon_ipc_irq_clr(unsigned short val, struct phy_device *phydev);
+ *
+ * param : val clear irq index.
+ *
+ */
+#define IPC_PAYLOAD_SIZE 16
+#define IPC_PAYLOAD_WORDS (IPC_PAYLOAD_SIZE / 2)
+#define IPC_NB_OPCODE 0x6
+#define IPC_PAYLOAD_NB 0x5
+#define IPC_NB_STATUS 0x4
+#define IPC_CMD_PARITY 0x8000
+#define IPC_TIMEOUT 2000000000
+/// The MSB of the status bit is used as a parity bit, toggling each time an
+/// IPC command is serviced.
+#define IPC_STS_PAR_MASK 0x8000
+/// The data layout for the sub-fields in the IPC status register
+#define IPC_STS_STS_WIDTH 4
+/** @} */
+
+#define PCS_SPEED_SEL_T10G 0x0
+#define PCS_SPEED_SEL_T5G 0x8
+#define PCS_SPEED_SEL_T2P5G 0x7
+
+#define MDI_CFG_SPD_T10 0x2
+#define MDI_CFG_SPD_T100 0x4
+#define MDI_CFG_SPD_T1G 0x8
+#define MDI_CFG_SPD_T2P5G 0x10
+#define MDI_CFG_SPD_T5G 0x20
+#define MDI_CFG_SPD_T10G 0x40
+
+#define PCS_MODE_8B_10B 0
+#define PCS_MODE_64B_66B 1
+
+#define SDS_DATARATE_1G 0
+#define SDS_DATARATE_2P5G 1
+#define SDS_DATARATE_5G 2
+#define SDS_DATARATE_10G 3
+
+#define SDS_RA_XFI 0
+#define SDS_RA_USXGMII 1
+
+#define CFG_FSM_NGPHY 0x81
+#define CFG_FSM_GPHY 0x8c
+#define CFG_FSM_CU_AN 0x8d
+#define CFG_FSM_DPC 0x8e
+#define CFG_FSM_SS 0x91
+#define CFG_CABLE_DIAG 0xa4
+
+#define IPC_DBGCMD_NGPHY 0x80
+#define IPC_DBGCMD_SDS 0x96
+#define IPC_DBGCMD_AUTO_LINK 0xA9
+#define IPC_DBGCMD_SYNCE 0xAC
+#define IPC_DBGCMD_CU_AN 0xA0
+
+#define MDI 1
+#define MDIX 0
+
+enum bitwidth_type {
+	BW8 = 0,
+	BW16 = 1,
+	BW32 = 2,
+};
+
+/** @name AEON's private function related to IPC
+ * @note These functions shouldn't be called individually
+ * @{
+*/
+/**
+ * @brief Get data from to IPC_DATA registers.
+ * @param len Data size.
+ * @param data Data array to be assigned.
+ */
+void aeon_receive_ipc_data(struct phy_device *phydev, unsigned short len,
+			   unsigned short *data);
+
+/**
+ * @brief Build IPC cmd.
+ * @note Construct the full command word.
+ * 16-bit register is laid out as follows:
+ * [1 cmd par][4 reserved][5 size][6 opcode]
+ */
+void aeon_ipc_build_cmd(unsigned short *cmd, short opcode, short size);
+
+/**
+ * @brief Wait until IPC status handshake returns DONE or READY.
+ * @return Current IPC status.
+ */
+unsigned short aeon_ipc_wait_cmd_done(struct phy_device *phydev,
+				      unsigned long *ns,
+				      unsigned short *ret_size);
+
+/**
+ * @brief Write bulk data to some memory.
+ * @param mem_addr The memory address to write data.
+ * @param size Data size.
+ */
+void aeon_ipc_send_bulk_write(unsigned int mem_addr, unsigned int size,
+			      struct phy_device *phydev);
+
+/**
+ * @brief Send bulk data.
+ * @param bw_type Type of bit-width.
+ * @param size Data size.
+ */
+void aeon_ipc_send_bulk_data(unsigned short bw_type, unsigned short size,
+			     void *data, struct phy_device *phydev);
+
+/**
+ * @brief Send IPC commands.
+ */
+void aeon_send_ipc_msg(struct phy_device *phydev, unsigned int len,
+		       unsigned short *val, short opcode, short size);
+
+/** @} */
+
+/** @name AEON's public function related to IPC
+ * @note These functions could be called individually
+ * @{
+*/
+/** 3 : get snr margin, 4 : get channel skew.
+ * @brief Send IPC command to sync parity.
+ */
+void aeon_ipc_sync_parity(struct phy_device *phydev);
+
+/**
+ * @brief Send IPC command to get FW version.
+ */
+void aeon_ipc_get_fw_version(char *version, struct phy_device *phydev);
+
+/**
+ * @brief Set eee abilities.
+ * @param speed_mode 7 bits [10G eee] [5G eee] [2.5G eee] [1G eee] [100m eee] [0] [0].
+ */
+void aeon_cu_an_set_eee_spd(unsigned short speed_mode,
+			    struct phy_device *phydev);
+
+/**
+ * @brief Set fast retrain abilities.
+ * @param speed_mode 7 bits [10G fr] [5G fr] [2.5G fr] [0] [0] [0] [0].
+ * @param thp_bypass 2 bits [5G thp_bypass] [2.5G thp_bypass]
+ */
+void aeon_cu_an_set_fast_retrain(unsigned short speed_mode,
+				 unsigned short thp_bypass,
+				 struct phy_device *phydev);
+
+/**
+ * @brief Configure donwshift.
+ * @param enable Enable/disable downshift.
+ * @param retry_limit Limited failure times of training.
+ */
+void aeon_cu_an_enable_downshift(unsigned short enable,
+				 unsigned short retry_limit,
+				 struct phy_device *phydev);
+
+/**
+ * @brief Send command to restart AN.
+ */
+void aeon_cu_an_restart(struct phy_device *phydev);
+
+/**
+ * @brief Configure PCS mode and speed of serdes.
+ * @param pcs_mode 1 : 64/66B, 0 : 8B/10B.
+ * @param sds_spd 3 : 10G, 2 : 5G, 1 : 2.5G, 0 : 1G.
+ */
+void aeon_sds_pcs_set_cfg(unsigned short pcs_mode, unsigned short sds_spd,
+			  struct phy_device *phydev);
+
+/**
+ * @brief Set non-standard PBO mode.
+ * @param nstd_pbo 2 bits [max_pbo] [min_pbo]
+ */
+void aeon_cu_an_enable_aeon_oui(unsigned short nstd_pbo,
+				struct phy_device *phydev);
+
+/**
+ * @brief Set auto-eee configuration.
+ * @param enable 1 : enable auto-eee, 0 : disable auto-eee.
+ * @param idle_th idle threshhold
+ */
+void aeon_auto_eee_cfg(unsigned short enable, unsigned int idle_th,
+		       struct phy_device *phydev);
+
+/**
+ * @brief Set ipc command to temperature monitor.
+ * @param sub_cmd 1 : start, 2 : stop, 3 : set configuration,
+ *  4 : get temperature, 5 : set threshhold
+ * @param params For sub_cmd = 3, 1 indicates continuous sampling, 0 indicates a single sample.
+ * For sub_cmd = 5, params indicates the temperature threshold to be set.
+ * @param temperature To save current temperature got from ipc command.
+ */
+void aeon_ipc_temp_monitor(unsigned short sub_cmd, unsigned short params,
+			   unsigned short *temperature,
+			   struct phy_device *phydev);
+
+/**
+ * @brief Set serdes adaptations.
+ * @param vga_adapt 1 : enable VGA adaptation, 0 : disable VGA adaptation.
+ * @param slc_adapt 1 : enable slicer adaptation, 0 : disable slicer adaptation.
+ * @param ctle_adapt 1 : enable CTLE adaptation, 0 : disable CTLE adaptation.
+ * @param dfe_adapt 1 : enable DFE adaptation, 0 : disable DFE adaptation.
+ */
+void aeon_sds_pma_set_cfg(unsigned short vga_adapt, unsigned short slc_adapt,
+			  unsigned short ctle_adapt, unsigned short dfe_adapt,
+			  struct phy_device *phydev);
+
+/**
+ * @brief Set USXGMII mode.
+ */
+void aeon_dpc_ra_enable(struct phy_device *phydev);
+
+/**
+ * @brief Set led configuration.
+ */
+void aeon_ipc_set_led_cfg(unsigned short led0, unsigned short led1,
+			  unsigned short led2, unsigned short led3,
+			  unsigned short led4, unsigned short polarity,
+			  unsigned short blink, struct phy_device *phydev);
+
+/**
+ * @brief Send command to set top_speed.
+ * @param top_spd 7 bits [10G] [5G] [2.5G] [1G] [100m] [0] [0].
+ */
+void aeon_cu_an_set_top_spd(unsigned short top_spd, struct phy_device *phydev);
+
+/**
+ * @brief Send command to set trd_swap mode.
+ * @param en 1 : override, 0 : no overriding.
+ * @param trd_swap 1 : enable TRD swap, 0 : disable TRD swap.
+ */
+void aeon_cu_an_set_trd_swap(unsigned short en, unsigned short trd_swap,
+			     struct phy_device *phydev);
+
+/**
+ * @brief Send command to set manual master/slave.
+ * @param port_type 0: single port, 1: multi port.
+ * @param ms_man_en 0: disable manual m/s, 1: enable manual m/s.
+ * @param ms_man_val 0: slave, 1: master
+ */
+void aeon_cu_an_set_ms_cfg(unsigned short port_type, unsigned short ms_man_en,
+			   unsigned short ms_man_val,
+			   struct phy_device *phydev);
+
+/**
+ * @brief Send command to get m/s-related configuration.
+ */
+void aeon_cu_an_get_ms_cfg(unsigned short *ms_related_cfg,
+			   struct phy_device *phydev);
+
+/**
+ * @brief Send command to reboot phy.
+ */
+void aeon_ipc_set_sys_reboot(struct phy_device *phydev);
+
+/**
+ * @brief Send command to enable/disable packet checker.
+ * @param enable Enable/disable packet checker.
+ */
+void aeon_pkt_chk_cfg(unsigned short enable, struct phy_device *phydev);
+
+/**
+ * @brief Set sds_wait_eth configuration.
+ * @param sds_wait_eth_delay Delay.
+ */
+void aeon_sds_wait_eth_cfg(unsigned short sds_wait_eth_delay,
+			   struct phy_device *phydev);
+
+/**
+ * @brief Enable/disable phy.
+ */
+void aeon_ipc_phy_enable_mode(unsigned short enable, struct phy_device *phydev);
+
+/**
+ * @brief Write data from memory to flash.
+ * @param flash_addr Flash address to write to.
+ * @param mem_addr Memory address of data to write.
+ * @param size Size of data.
+ */
+void aeon_ipc_write_flash(unsigned int flash_addr, unsigned int mem_addr,
+			  unsigned short size, struct phy_device *phydev);
+
+/**
+ * @brief Erase flash.
+ * @param flash_addr Flash address to erase.
+ * @param size Size of data.
+ * @param mode Mode of erasing. 1 : sector erase, 2 : block erase.
+ */
+void aeon_ipc_erase_flash(unsigned int flash_addr, unsigned int size,
+			  unsigned short mode, struct phy_device *phydev);
+
+/**
+ * @brief Set WDT.
+ * @param en Enable/disable WDT.
+ */
+void aeon_ipc_set_wdt(unsigned short en, struct phy_device *phydev);
+
+/**
+ * @brief Update image.
+ * @param include_bootloader 1/0.
+ * @note This a demo for dual flash programming feature.
+ */
+void aeon_burn_image(unsigned char include_bootloader,
+		     struct phy_device *phydev);
+
+/**
+ * @brief Send short config parameter list to firmware directly.
+ */
+void aeon_ipc_cfg_param_direct(unsigned int data_len, unsigned short *data,
+			       struct phy_device *phydev);
+
+/**
+ * @brief Set IPC commands related to CPU INFO.
+ */
+int aeon_ipc_sys_cpu_info(unsigned short sub_cmd, unsigned int flash_addr,
+			  unsigned int mem_addr, struct phy_device *phydev);
+
+/**
+ * @brief Set FW FSM running mode.
+ */
+void aeon_ipc_set_fsm_mode(unsigned short fsm, unsigned short mode,
+			   struct phy_device *phydev);
+
+/**
+ * @brief Update flash image.
+ */
+void aeon_update_flash(const char *firmware, unsigned int flash_start,
+		       struct phy_device *phydev);
+
+/**
+ * @brief Set ipc command for restarting serdes AN.
+ */
+void aeon_sds_restart_an(struct phy_device *phydev);
+
+/**
+ * @brief Set ipc command for NG test mode.
+ */
+void aeon_ipc_ng_test_mode(unsigned short test_mode, unsigned short tone,
+			   struct phy_device *phydev);
+
+/**
+ * @brief Enable NG test mode for specific speed mode.
+ */
+void aeon_ng_test_mode(unsigned short top_spd, unsigned short test_mode,
+		       unsigned short tone, struct phy_device *phydev);
+
+/**
+ * @brief Enable 1G test mode.
+ */
+void aeon_1g_test_mode(unsigned short test_mode, struct phy_device *phydev);
+
+/**
+ * @brief Enable 100M test mode.
+ */
+void aeon_100m_test_mode(struct phy_device *phydev);
+
+/**
+ * @brief Set WOL.
+ * @param en Enable/disable WOL.
+ */
+void aeon_ipc_set_wol(unsigned short en, unsigned short *val,
+	struct phy_device *phydev);
+
+/**
+* @brief Set SMI Command.
+* @param val command value.
+*/
+void aeon_ipc_smi_command(unsigned short *val, struct phy_device *phydev);
+
+/**
+* @brief Set irq enable.
+* @param val irq index and en.
+*/
+void aeon_ipc_irq_en(unsigned short *val, struct phy_device *phydev);
+
+/**
+* @brief Set irq clr.
+* @param val irq index.
+*/
+void aeon_ipc_irq_clr(unsigned short val, struct phy_device *phydev);
+
+/**
+* @brief get irq status.
+* @param val irq status.
+*/
+void aeon_ipc_irq_query(unsigned short *irq, struct phy_device *phydev);
+
+/**
+* @brief Set IPC commands related to cable diag lite.
+*/
+void aeon_ipc_cable_diag(unsigned short sub_cmd, unsigned short *data,
+			 unsigned short mode, struct phy_device *phydev);
+
+/**
+* @brief Configure CISCO fast-retrain.
+*/
+void aeon_cu_an_set_cfr(unsigned short cfr, struct phy_device *phydev);
+
+/**
+ * @brief Set tx fullscale.
+ */
+void aeon_ipc_set_tx_fullscale_delta(unsigned short speed, unsigned short *delta,
+				     struct phy_device *phydev);
+
+/**
+ * @brief Get tx_full scale.
+ */
+void aeon_ipc_get_tx_fullscale_delta(unsigned short speed, unsigned short *delta,
+				     struct phy_device *phydev);
+
+/**
+ * @brief Get data from memory.
+ */
+void aeon_ipc_read_mem(unsigned short addr1, unsigned short addr2, unsigned short num,
+		       unsigned short *params, struct phy_device *phydev);
+/**
+ * @brief Clear log.
+ */
+void aeon_ipc_clear_log(struct phy_device *phydev);
+
+/**
+ * @brief Set mac count.
+ */
+void aeon_ipc_set_mac_cnt(unsigned long long mac_tot_cnt, unsigned long long mac_crc_cnt,
+			  struct phy_device *phydev);
+
+/**
+ * @brief Enable second Serdes
+ */
+void aeon_sds2nd_enable(unsigned short en, struct phy_device *phydev);
+
+/**
+ * @brief Set Seccond Serdes PCS, Datarate and Operation Mode.
+ */
+void aeon_sds2nd_mode_cfg(unsigned short pcs_mode, unsigned short sds_spd, unsigned short op_mode,
+			  struct phy_device *phydev);
+
+/**
+ * @brief Set Seccond Serdes Equalization.
+ */
+void aeon_sds2nd_eq_cfg(unsigned short vga, unsigned short slc, unsigned short ctle,
+			unsigned short dfe,
+			struct phy_device *phydev);
+
+/**
+ * @brief Set duplex mode.
+ */
+void aeon_set_man_duplex(unsigned short duplex, struct phy_device *phydev);
+
+/**
+ * @brief Enable/disable AN.
+ */
+void aeon_cu_an_enable(unsigned short enable, struct phy_device *phydev);
+
+/**
+ * @brief Serdes Eye Scan.
+ */
+void aeon_ipc_eye_scan(unsigned char sds_id, unsigned char grp, unsigned char *rev_buf,
+		       struct phy_device *phydev);
+
+/**
+ * @brief Disable/enable normal retrain.
+ */
+void aeon_normal_retrain_cfg(unsigned short enable, struct phy_device *phydev);
+
+/**
+ * @brief Set Serdes Tx Fir 3 cursors
+ */
+void aeon_ipc_sds_txfir(unsigned char sds_id, unsigned char pre, unsigned char main,
+			unsigned char post, struct phy_device *phydev);
+
+/**
+ * @brief Enable Auto Link Detection.
+ */
+void aeon_ipc_auto_link_ena(unsigned char enable, struct phy_device *phydev);
+
+/**
+ * @brief Enable Auto Link Type Configuration.
+ */
+void aeon_ipc_auto_link_cfg(unsigned char link_type, struct phy_device *phydev);
+
+/**
+ * @brief Set gain.
+ */
+void aeon_ipc_set_tx_power_lvl(unsigned short gain, struct phy_device *phydev);
+
+/**
+ * @brief Force MDI mode.
+ */
+void aeon_set_man_mdi(struct phy_device *phydev);
+
+/**
+ * @brief Force MDIX mode.
+ */
+void aeon_set_man_mdix(struct phy_device *phydev);
+
+/**
+ * @brief Set synce enable.
+ */
+void aeon_synce_enable_cfg(unsigned char enable, struct phy_device *phydev);
+
+/**
+ * @brief Set synce master/slave.
+ */
+void aeon_synce_mode_cfg(unsigned char ms, struct phy_device *phydev);
+
+/**
+ * @brief Set synce user bw
+ */
+void aeon_synce_user_bw(unsigned char bw, struct phy_device *phydev);
+
+/**
+ * @brief Set synce slave output pin
+ */
+void aeon_synce_slave_output_ctrl_cfg(unsigned char oc, struct phy_device *phydev);
+/** @} */
+
+/**
+ * @brief Get phy link status.
+ */
+int aeon_read_status(struct phy_device *phydev);
+
+/**
+ * @brief Register configuration for test mode.
+ */
+void aeon_man_configure(struct phy_device *phydev);
+
+/**
+ * @brief Set parallel detection.
+ */
+void aeon_parallel_det(unsigned char enable, struct phy_device *phydev);
+#endif
diff --git a/drivers/net/phy/as21xx_bbu_api/as21xx_debugfs.c b/drivers/net/phy/as21xx_bbu_api/as21xx_debugfs.c
new file mode 100644
index 0000000..aff7758
--- /dev/null
+++ b/drivers/net/phy/as21xx_bbu_api/as21xx_debugfs.c
@@ -0,0 +1,2820 @@
+/******************************************************************************
+ * AEONSEMI CONFIDENTIAL
+ * _____________________
+ *
+ * Aeonsemi Inc., 2023
+ * All Rights Reserved.
+ *
+ * NOTICE:  All information contained herein is, and remains the property of
+ * Aeonsemi Inc. and its subsidiaries, if any. The intellectual and technical
+ * concepts contained herein are proprietary to Aeonsemi Inc. and its
+ * subsidiaries and may be covered by U.S. and Foreign Patents, patents in
+ * process, and are protected by trade secret or copyright law. Dissemination
+ * of this information or reproduction of this material is strictly forbidden
+ * unless prior written permission is obtained from Aeonsemi Inc.
+ *
+ *
+ *****************************************************************************/
+/* FILE NAME:  as21xx_debugfs.c
+ * PURPOSE:
+ *    It provides as21xx phy debugfs definations.
+ *
+ * NOTES:
+ *
+ */
+
+/************************************************************************
+*                  I N C L U D E S
+*************************************************************************
+*/
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/debugfs.h>
+#include <linux/printk.h>
+#include <linux/fs.h>
+#include <linux/proc_fs.h>
+#include <linux/phy.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include "../as21xxx.h"
+#include "as21xx_debugfs.h"
+#include "as21xx_api.h"
+#include <linux/timekeeping.h>
+#include <linux/timex.h>
+#include <linux/string.h>
+
+/************************************************************************
+*                  D E F I N E S   &   C O N S T A N T S
+*************************************************************************
+*/
+#define MAX_BUF     64
+#define MAX_CMD_LEN 32
+#define MAX_ARGS    10
+
+struct parsed_cmd {
+	char cmd[MAX_CMD_LEN];
+	long args[MAX_ARGS];
+	int argc;
+};
+
+/************************************************************************
+*                  D A T A   D E C L A R A T I O N S
+*************************************************************************
+*/
+const char *IMP_TYPE_STR[CHAN_NUM] = {
+	"Null", "Open", "Short", "Load"
+};
+
+/************************************************************************
+*    STATIC    I N L I N E    F U N C T I O N   D E F I N I T I O N S
+*************************************************************************
+*/
+static int parse_cmd_args(const char *input, struct parsed_cmd *result, int max_args)
+{
+	char buffer[MAX_BUF];
+	char *token, *ptr;
+	int count = 0;
+	size_t len;
+
+	if (!input || !result || max_args > MAX_ARGS)
+		return -EINVAL;
+
+	strncpy(buffer, input, sizeof(buffer));
+	buffer[sizeof(buffer) - 1] = '\0';
+
+	// clear '\n'
+	len = strlen(buffer);
+	if (len > 0 && buffer[len - 1] == '\n')
+		buffer[len - 1] = '\0';
+
+	ptr = buffer;
+
+	token = strsep(&ptr, " ");
+	while (token && *token == '\0')
+		token = strsep(&ptr, " ");
+
+	if (!token)
+		return -EINVAL;
+
+	strncpy(result->cmd, token, sizeof(result->cmd) - 1);
+	result->cmd[sizeof(result->cmd) - 1] = '\0';
+
+	while ((token = strsep(&ptr, " ")) != NULL && count < max_args) {
+		if (*token == '\0')
+			continue;
+
+		if (kstrtol(token, 0, &result->args[count]) != 0)
+			return -EINVAL;
+
+		count++;
+	}
+
+	result->argc = count;
+	return 0;
+}
+
+static inline void printk_force_speed_usage(void)
+{
+	pr_info("================Please input:===================\n");
+	pr_info("Set 10G FD: echo 10Gbps > /sys/kernel/debug/{MDIOBUS}/aeon_set_speed_mode\n");
+	pr_info("Set 5G FD: echo 5Gbps > /sys/kernel/debug/{MDIOBUS}/aeon_set_speed_mode\n");
+	pr_info("Set 2.5G FD: echo 2.5Gbps > /sys/kernel/debug/{MDIOBUS}/aeon_set_speed_mode\n");
+	pr_info("Set 1G FD: echo 1Gbps   > /sys/kernel/debug/{MDIOBUS}/aeon_set_speed_mode\n");
+	pr_info("Set 100M FD: echo 100Mbps > /sys/kernel/debug/{MDIOBUS}/aeon_set_speed_mode\n\n");
+}
+
+static inline void printk_restart_an_usage(void)
+{
+	pr_info("================Please input:===================\n");
+	pr_info("Restart AN: echo RestartAN > /sys/kernel/debug/{MDIOBUS}/aeon_restart_an\n");
+}
+
+static inline void printk_mdi_cfg_usage(void)
+{
+	pr_info("================Please input:===================\n");
+	pr_info("Set FastRetrain: echo FastRetrain [speed] [thp_bypass]> /sys/kernel/debug/{MDIOBUS}/aeon_set_mdi_cfg\n");
+	pr_info("Set EEE: echo EEE [speed] > /sys/kernel/debug/{MDIOBUS}/aeon_set_mdi_cfg\n");
+	pr_info("Set AeonOUI: echo AeonOUI [pbo_option]> /sys/kernel/debug/{MDIOBUS}/aeon_set_mdi_cfg\n");
+	pr_info("Set Manual M/S enable: echo ManualMS [value] > /sys/kernel/debug/{MDIOBUS}/aeon_set_mdi_cfg\n");
+	pr_info("Set M/S: echo SetMS [value] > /sys/kernel/debug/{MDIOBUS}/aeon_set_mdi_cfg\n");
+	pr_info("Set Port Type: echo PortType [value] > /sys/kernel/debug/{MDIOBUS}/aeon_set_mdi_cfg\n");
+	pr_info("Set SmartSpd: echo Smartspd [en] [retry_limit] > /sys/kernel/debug/{MDIOBUS}/aeon_set_mdi_cfg\n");
+	pr_info("Set Trd Swap: echo TrdSwap [value] > /sys/kernel/debug/{MDIOBUS}/aeon_set_mdi_cfg\n");
+	pr_info("Set CFR: echo CFR [value] > /sys/kernel/debug/{MDIOBUS}/aeon_set_mdi_cfg\n\n");
+}
+
+static inline void printk_sds_pcs_cfg_usage(void)
+{
+	pr_info("================Please input:===================\n");
+	pr_info("Set sds pcs cfg: echo SdsPcs [pcsMode] [sdsSpd] > /sys/kernel/debug/{MDIOBUS}/aeon_set_sds_pcs_cfg\n");
+	pr_info("Set sds ra enable: echo SdsRA > /sys/kernel/debug/{MDIOBUS}/aeon_set_sds_pcs_cfg\n\n");
+}
+
+static inline void printk_auto_eee_cfg_usage(void)
+{
+	pr_info("================Please input:===================\n");
+	pr_info("Set auto-eee: echo AutoEEE [enable] [idle_th] > /sys/kernel/debug/{MDIOBUS}/aeon_auto_eee_cfg\n\n");
+}
+
+static inline void printk_sds_pma_cfg_usage(void)
+{
+	pr_info("================Please input:===================\n");
+	pr_info("Set sds pma: echo SdsPma [vga_adapt] [ctle_adapt] [dfe_adapt] [slc_adapt]> /sys/kernel/debug/{MDIOBUS}/aeon_set_sds_pma_cfg\n\n");
+}
+
+static inline void printk_get_fw_version_usage(void)
+{
+	pr_info("================Please input:===================\n");
+	pr_info("Get fw version: echo ver > /sys/kernel/debug/{MDIOBUS}/aeon_fw_version\n\n");
+}
+
+static inline void printk_temp_monitor_usage(void)
+{
+	pr_info("================Please input:===================\n");
+	pr_info("Set temperature monitor: echo temp [subcommand] [param] > /sys/kernel/debug/{MDIOBUS}/aeon_temp_monitor\n\n");
+}
+
+static inline void printk_set_led_usage(void)
+{
+	pr_info("================Please input:===================\n");
+	pr_info("Set led: echo led [led0] [led1] [led2] [led3] [led4] [polarity] [blink] > /sys/kernel/debug/{MDIOBUS}/aeon_set_led\n\n");
+}
+
+static inline void printk_sys_reboot_usage(void)
+{
+	pr_info("================Please input:===================\n");
+	pr_info("Reboot: echo reboot > /sys/kernel/debug/{MDIOBUS}/aeon_set_sys_reboot\n\n");
+}
+
+static inline void printk_read_reg_usage(void)
+{
+	pr_info("================Please input:===================\n");
+	pr_info("echo ReadReg [dev_addr] [phy_reg] > /sys/kernel/debug/{MDIOBUS}/aeon_read_reg\n\n");
+}
+
+static inline void printk_write_reg_usage(void)
+{
+	pr_info("================Please input:===================\n");
+	pr_info("echo WriteReg [dev_addr] [phy_reg] [value] > /sys/kernel/debug/{MDIOBUS}/aeon_write_reg\n\n");
+}
+
+static inline void printk_eth_status_usage(void)
+{
+	pr_info("================Please input:===================\n");
+	pr_info("echo ethstatus > /sys/kernel/debug/{MDIOBUS}/aeon_get_eth_status\n\n");
+}
+
+static inline void printk_pkt_chk_cfg_usage(void)
+{
+	pr_info("================Please input:===================\n");
+	pr_info("Set pkt chk: echo PktChk [mode] > /sys/kernel/debug/{MDIOBUS}/aeon_pkt_chk_cfg\n\n");
+}
+
+static inline void printk_mdc_timing_usage(void)
+{
+	pr_info("================Please input:===================\n");
+	pr_info("echo MdcTiming [mode] > /sys/kernel/debug/{MDIOBUS}/aeon_mdc_timing\n\n");
+}
+
+static inline void printk_sds_wait_eth_cfg_usage(void)
+{
+	pr_info("================Please input:===================\n");
+	pr_info("echo SdsWaitEth [sds_waith_eth] > /sys/kernel/debug/{MDIOBUS}/aeon_sds_wait_eth\n\n");
+}
+
+static inline void printk_phy_enable_usage(void)
+{
+	pr_info("================Please input:===================\n");
+	pr_info("echo phyenable [enable] > /sys/kernel/debug/{MDIOBUS}/aeon_phy_enable\n\n");
+}
+
+#ifdef DUAL_FLASH
+static inline void printk_sys_dual_flash(void)
+{
+	pr_info("================Please input:===================\n");
+	pr_info("echo flash [include_bootloader] > /sys/kernel/debug/{MDIOBUS}/aeon_burn_flash_image\n\n");
+}
+
+static inline void printk_erase_flash(void)
+{
+	pr_info("================Please input:===================\n");
+	pr_info("echo erase [flash_addr] [size] > /sys/kernel/debug/{MDIOBUS}/aeon_erase_flash\n\n");
+}
+#endif
+
+static inline void printk_sds_restart_an_usage(void)
+{
+	pr_info("================Please input:===================\n");
+	pr_info("echo sdsan > /sys/kernel/debug/{MDIOBUS}/aeon_sds_restart_an\n\n");
+}
+
+static inline void printk_test_mode_usage(void)
+{
+	pr_info("================Please input:===================\n");
+	pr_info("Set NG testmode: echo ngtest [speed] [test_mode] [test_tone(if test_mode == 4)] > /sys/kernel/debug/{MDIOBUS}/aeon_test_mode\n");
+	pr_info("Set 1G testmode: echo 1gtest [test_mode] > /sys/kernel/debug/{MDIOBUS}/aeon_test_mode\n");
+	pr_info("Set 100M testmode: echo 100mtest > /sys/kernel/debug/{MDIOBUS}/aeon_test_mode\n\n");
+}
+
+static inline void printk_tx_fullscale_usage(void)
+{
+	pr_info("================Please input:===================\n");
+	pr_info("echo txfullscale [speed] [val0 val1 val2 val3] > /sys/kernel/debug/{MDIOBUS}/aeon_tx_fullscale\n");
+	pr_info("echo get [speed] > /sys/kernel/debug/{MDIOBUS}/aeon_tx_fullscale\n\n");
+}
+
+static inline void printk_wol_ctrl_usage(void)
+{
+	pr_info("================Please input:===================\n");
+	pr_info("echo wolctrl [value0] [value1] [value2] [value3]> /sys/kernel/debug/{MDIOBUS}/aeon_wol_ctrl\n\n");
+}
+
+static inline void printk_smi_ctrl_usage(void)
+{
+	pr_info("================Please input:===================\n");
+	pr_info("echo smicommand [value0] [value1]> /sys/kernel/debug/{MDIOBUS}/aeon_smi_command\n\n");
+}
+
+static inline void printk_set_irq_en_usage(void)
+{
+	pr_info("================Please input:===================\n");
+	pr_info("echo setirqen [value0] [value1] [value2] [value3] > /sys/kernel/debug/{MDIOBUS}/aeon_setirq_en\n\n");
+}
+
+static inline void printk_set_irq_clr_usage(void)
+{
+	pr_info("================Please input:===================\n");
+	pr_info("echo setirqclr [value0] > /sys/kernel/debug/{MDIOBUS}/aeon_setirq_clr\n\n");
+}
+
+static inline void printk_query_irq_status_usage(void)
+{
+	pr_info("================Please input:===================\n");
+	pr_info("echo queryirq > /sys/kernel/debug/{MDIOBUS}/aeon_query_irq\n\n");
+}
+
+static inline void printk_cable_diag_usage(void)
+{
+	pr_info("================Please input:===================\n");
+	pr_info("echo chanlen > /sys/kernel/debug/{MDIOBUS}/aeon_cable_diag\n");
+	pr_info("echo ppmofst > /sys/kernel/debug/{MDIOBUS}/aeon_cable_diag\n");
+	pr_info("echo snrmargin > /sys/kernel/debug/{MDIOBUS}/aeon_cable_diag\n");
+	pr_info("echo chanskew > /sys/kernel/debug/{MDIOBUS}/aeon_cable_diag\n");
+	pr_info("echo set [mode] > /sys/kernel/debug/{MDIOBUS}/aeon_cable_diag\n");
+	pr_info("echo get > /sys/kernel/debug/{MDIOBUS}/aeon_cable_diag\n\n");
+}
+
+static inline void printk_sds_eye_diagram_usage(void)
+{
+	pr_info("================Please input:===================\n");
+	pr_info("echo eyescan [part] > /sys/kernel/debug/{MDIOBUS}/aeon_eye_diagram_data\n");
+	pr_info("echo eyeshow > /sys/kernel/debug/{MDIOBUS}/aeon_eye_diagram_data\n");
+}
+
+static inline void printk_sds2nd_cfg_usage(void)
+{
+	pr_info("================Please input:===================\n");
+	pr_info("Enable Second Serdes: echo Sds2ndEn [enable] > /sys/kernel/debug/{MDIOBUS}/aeon_sds2nd_enable\n");
+	pr_info("Config Second Serdes Equlization: echo Sds2ndEq [vga] [slc] [ctle] [dfe] > /sys/kernel/debug/{MDIOBUS}/aeon_sds2nd_eq_cfg\n");
+	pr_info("Config Second Serdes PCS Mode and Datarate: echo Sds2ndMode [pcsMode] [sdsSpd] > /sys/kernel/debug/{MDIOBUS}/aeon_sds2nd_mode_cfg\n");
+
+}
+
+static inline void printk_sds2nd_eye_diagram_usage(void)
+{
+	pr_info("================Please input:===================\n");
+	pr_info("echo eyescan [part] > /sys/kernel/debug/{MDIOBUS}/aeon_sds2nd_eye_diagram_data\n");
+	pr_info("echo eyeshow > /sys/kernel/debug/{MDIOBUS}/aeon_sds2nd_eye_diagram_data\n");
+}
+
+static inline void printk_force_mode_usage(void)
+{
+	pr_info("================Please input:===================\n");
+	pr_info("echo force100M [duplex] > /sys/kernel/debug/{MDIOBUS}/aeon_force_mode\n\n");
+}
+
+static inline void printk_parallel_det_usage(void)
+{
+	pr_info("================Please input:===================\n");
+	pr_info("echo paradet [enable] > /proc/tc3162/aeon_parallel_det\n\n");
+}
+
+static inline void printk_normal_retrain_usage(void)
+{
+	pr_info("================Please input:===================\n");
+	pr_info("echo nr [enable] > /sys/kernel/debug/{MDIOBUS}/aeon_normal_retrain\n\n");
+}
+
+static inline void printk_sds_txfir_usage(void)
+{
+	pr_info("================Please input:===================\n");
+	pr_info("echo SdsTxFir [pre] [main] [post] > /sys/kernel/debug/{MDIOBUS}/aeon_sds_txfir\n\n");
+}
+
+static inline void printk_auto_link_usage(void)
+{
+	pr_info("================Please input:===================\n");
+	pr_info("echo AutoLinkEna [enable] > /sys/kernel/debug/{MDIOBUS}/aeon_auto_link\n");
+	pr_info("echo AutoLinkCfg [linktype] > /sys/kernel/debug/{MDIOBUS}/aeon_auto_link\n\n");
+}
+
+static inline void printk_force_mdi_mode_usage(void)
+{
+	pr_info("================Please input:===================\n");
+	pr_info("echo mdi [val] > /sys/kernel/debug/{MDIOBUS}/aeon_force_mdi_mode\n\n");
+}
+
+static inline void printk_tx_power_lvl_usage(void)
+{
+	pr_info("================Please input:===================\n");
+	pr_info("echo txgain [val] > /sys/kernel/debug/{MDIOBUS}/aeon_tx_power_lvl\n\n");
+}
+
+static inline void printk_synce_master_mode_usage(void)
+{
+	pr_info("================Please input:===================\n");
+	pr_info("echo synce_master [enable] [bw] > /sys/kernel/debug/{MDIOBUS}/aeon_synce_master_mode\n\n");
+}
+
+static inline void printk_synce_slave_mode1_usage(void)
+{
+	pr_info("================Please input:===================\n");
+	pr_info("echo synce_slave_mode1 [enable] [oc] > /sys/kernel/debug/{MDIOBUS}/aeon_synce_slave_mode1\n\n");
+}
+
+static inline void printk_synce_slave_mode2_usage(void)
+{
+	pr_info("================Please input:===================\n");
+	pr_info("echo synce_slave_mode2 [enable] [bw] [oc] > /sys/kernel/debug/{MDIOBUS}/aeon_synce_slave_mode2\n\n");
+}
+
+static ssize_t aeon_mdc_timing_read_proc(struct file *file, char __user *buf,
+					 size_t size, loff_t *ppos)
+{
+	printk_mdc_timing_usage();
+	return 0;
+}
+
+static ssize_t aeon_mdc_timing_write_proc(struct file *file, const char __user *buffer,
+					  size_t count, loff_t *pos)
+{
+	struct phy_device *phydev = file->private_data;
+	char val_string[MAX_BUF] = { 0 };
+	struct parsed_cmd cmdinfo = { 0 };
+
+	if (count >= sizeof(val_string))
+		return -EINVAL;
+
+	if (copy_from_user(val_string, buffer, count))
+		return -EFAULT;
+
+	val_string[count] = '\0';
+
+	if (parse_cmd_args(val_string, &cmdinfo, 1) != 0)
+		return -EINVAL;
+
+	if (!strcmp(cmdinfo.cmd, "MdcTiming")) {
+		if (cmdinfo.argc != 1)
+			return -EINVAL;
+
+		if (cmdinfo.args[0] == 1) {
+			phy_write_mmd(phydev, 0x1E, 0x53, 0xFFFF);
+			phy_write_mmd(phydev, 0x1E, 0x54, 0xFFFF);
+			phy_write_mmd(phydev, 0x1E, 0x55, 0xFFFF);
+		} else {
+			phy_write_mmd(phydev, 0x1E, 0x53, 0x0);
+			phy_write_mmd(phydev, 0x1E, 0x54, 0x0);
+			phy_write_mmd(phydev, 0x1E, 0x55, 0x0);
+		}
+		pr_info("Set MDC timing successfully!\n");
+	} else
+		printk_mdc_timing_usage();
+
+	return count;
+}
+
+static ssize_t aeon_sds_wait_eth_cfg_read_proc(struct file *file, char __user *buf,
+					       size_t size, loff_t *ppos)
+{
+	printk_sds_wait_eth_cfg_usage();
+	return 0;
+}
+
+static ssize_t aeon_sds_wait_eth_cfg_write_proc(struct file *file,
+						const char __user *buffer,
+						size_t count, loff_t *pos)
+{
+	struct phy_device *phydev = file->private_data;
+	char val_string[MAX_BUF] = { 0 };
+	struct parsed_cmd cmdinfo = { 0 };
+
+	if (count >= sizeof(val_string))
+		return -EINVAL;
+
+	if (copy_from_user(val_string, buffer, count))
+		return -EFAULT;
+
+	val_string[count] = '\0';
+
+	if (parse_cmd_args(val_string, &cmdinfo, 1) != 0)
+		return -EINVAL;
+
+	if (!strcmp(cmdinfo.cmd, "SdsWaitEth")) {
+		if (cmdinfo.argc != 1)
+			return -EINVAL;
+
+		aeon_ipc_sync_parity(phydev);
+		aeon_sds_wait_eth_cfg(cmdinfo.args[0], phydev);
+		pr_info("Set Sds wait Eth cfg successfully!\n");
+	} else
+		printk_sds_wait_eth_cfg_usage();
+
+	return count;
+}
+
+static ssize_t aeon_pkt_chk_cfg_read_proc(struct file *file, char __user *buf,
+					  size_t size, loff_t *ppos)
+{
+	printk_pkt_chk_cfg_usage();
+	return 0;
+}
+
+static ssize_t aeon_pkt_chk_cfg_write_proc(struct file *file,
+					   const char __user *buffer, size_t count,
+					   loff_t *pos)
+{
+	struct phy_device *phydev = file->private_data;
+	char val_string[MAX_BUF] = { 0 };
+	struct parsed_cmd cmdinfo = { 0 };
+
+	if (count >= sizeof(val_string))
+		return -EINVAL;
+
+	if (copy_from_user(val_string, buffer, count))
+		return -EFAULT;
+
+	val_string[count] = '\0';
+
+	if (parse_cmd_args(val_string, &cmdinfo, 1) != 0)
+		return -EINVAL;
+
+	if (!strcmp(cmdinfo.cmd, "PktChk")) {
+		if (cmdinfo.argc != 1)
+			return -EINVAL;
+
+		aeon_ipc_sync_parity(phydev);
+		aeon_pkt_chk_cfg(cmdinfo.args[0], phydev);
+		pr_info("Set Pkt Checker successfully!\n");
+	} else
+		printk_pkt_chk_cfg_usage();
+
+	return count;
+}
+
+static ssize_t aeon_read_reg_read_proc(struct file *file, char __user *buf,
+				       size_t size, loff_t *ppos)
+{
+	printk_read_reg_usage();
+	return 0;
+}
+
+static ssize_t aeon_read_reg_write_proc(struct file *file, const char __user *buffer,
+					size_t count, loff_t *pos)
+{
+	struct phy_device *phydev = file->private_data;
+	char val_string[MAX_BUF] = { 0 };
+	struct parsed_cmd cmdinfo = { 0 };
+	unsigned short value = 0;
+
+	if (count >= sizeof(val_string))
+		return -EINVAL;
+
+	if (copy_from_user(val_string, buffer, count))
+		return -EFAULT;
+
+	val_string[count] = '\0';
+
+	if (parse_cmd_args(val_string, &cmdinfo, 2) != 0)
+		return -EINVAL;
+
+	if (!strcmp(cmdinfo.cmd, "ReadReg")) {
+		if (cmdinfo.argc != 2)
+			return -EINVAL;
+
+		value = aeon_cl45_read(phydev, cmdinfo.args[0], cmdinfo.args[1]);
+		pr_info("Read register value: 0x%x\n", value);
+	} else
+		printk_read_reg_usage();
+
+	return count;
+}
+
+static ssize_t aeon_write_reg_read_proc(struct file *file, char __user *buf,
+					size_t size, loff_t *ppos)
+{
+	printk_write_reg_usage();
+	return 0;
+}
+
+static ssize_t aeon_write_reg_write_proc(struct file *file, const char __user *buffer,
+					 size_t count, loff_t *pos)
+{
+	struct phy_device *phydev = file->private_data;
+	char val_string[MAX_BUF] = { 0 };
+	struct parsed_cmd cmdinfo = { 0 };
+
+	if (count >= sizeof(val_string))
+		return -EINVAL;
+
+	if (copy_from_user(val_string, buffer, count))
+		return -EFAULT;
+
+	val_string[count] = '\0';
+
+	if (parse_cmd_args(val_string, &cmdinfo, 3) != 0)
+		return -EINVAL;
+
+	if (!strcmp(cmdinfo.cmd, "WriteReg")) {
+		if (cmdinfo.argc != 3)
+			return -EINVAL;
+
+		phy_write_mmd(phydev, cmdinfo.args[0], cmdinfo.args[1], cmdinfo.args[2]);
+		pr_info("Write register successfully!\n");
+	} else
+		printk_write_reg_usage();
+
+	return count;
+}
+
+static ssize_t aeon_eth_status_read_proc(struct file *file, char __user *buf,
+					 size_t size, loff_t *ppos)
+{
+	printk_eth_status_usage();
+	return 0;
+}
+
+static ssize_t aeon_eth_status_write_proc(struct file *file, const char __user *buffer,
+					  size_t count, loff_t *pos)
+{
+	struct phy_device *phydev = file->private_data;
+	char val_string[MAX_BUF] = { 0 };
+	struct parsed_cmd cmdinfo = { 0 };
+	unsigned short link_status, speed, value;
+
+	if (count >= sizeof(val_string))
+		return -EINVAL;
+
+	if (copy_from_user(val_string, buffer, count))
+		return -EFAULT;
+
+	val_string[count] = '\0';
+
+	if (parse_cmd_args(val_string, &cmdinfo, 0) != 0)
+		return -EINVAL;
+
+	if (!strcmp(cmdinfo.cmd, "ethstatus")) {
+		if (cmdinfo.argc != 0)
+			return -EINVAL;
+
+		value = aeon_cl45_read(phydev, 0x7, 0x8005);
+		link_status = ((value & 0xF000) >> 12) == 9;
+		pr_info("Link Status : %d\n", link_status);
+		if (link_status) {
+			value = aeon_cl45_read(phydev, 0x1E, 0x4002);
+			speed = value & 0xFF;
+			if (speed == 0x3)
+				pr_info("Link up at 10G\n");
+			else if (speed == 0x5)
+				pr_info("Link up at 5G\n");
+			else if (speed == 0x9)
+				pr_info("Link up at 2.5G\n");
+			else if (speed == 0x10)
+				pr_info("Link up at 1G\n");
+			else if (speed == 0x20)
+				pr_info("Link up at 100M\n");
+		}
+	} else
+		printk_eth_status_usage();
+
+	return count;
+}
+
+static ssize_t aeon_restart_an_read_proc(struct file *file, char __user *buf,
+					 size_t size, loff_t *ppos)
+{
+	printk_restart_an_usage();
+	return 0;
+}
+
+static ssize_t aeon_restart_an_write_proc(struct file *file, const char __user *buffer,
+					  size_t count, loff_t *pos)
+{
+	struct phy_device *phydev = file->private_data;
+	struct as21xxx_priv *priv = phydev->priv;
+	struct an_mdi_cfg *__priv_data = &priv->mdi_cfg;
+	char val_string[MAX_BUF] = { 0 };
+	struct parsed_cmd cmdinfo = { 0 };
+	unsigned short ms_related_cfg[4] = { 0 };
+
+	if (count >= sizeof(val_string))
+		return -EINVAL;
+
+	if (copy_from_user(val_string, buffer, count))
+		return -EFAULT;
+
+	val_string[count] = '\0';
+
+	if (parse_cmd_args(val_string, &cmdinfo, 0) != 0)
+		return -EINVAL;
+
+	if (!strcmp(cmdinfo.cmd, "RestartAN")) {
+		if (cmdinfo.argc != 0)
+			return -EINVAL;
+
+		aeon_cu_an_get_ms_cfg(ms_related_cfg, phydev);
+		if (__priv_data->top_spd != 0xF)
+			aeon_cu_an_set_top_spd(__priv_data->top_spd, phydev);
+		if (__priv_data->eee_spd != 0xFF)
+			aeon_cu_an_set_eee_spd(__priv_data->eee_spd, phydev);
+		if (__priv_data->ms_en != 0xF) {
+			ms_related_cfg[1] = __priv_data->ms_en;
+			aeon_cu_an_set_ms_cfg(ms_related_cfg[0],
+				ms_related_cfg[1], ms_related_cfg[2], phydev);
+		}
+		if (__priv_data->ms_config != 0xF) {
+			ms_related_cfg[2] = __priv_data->ms_config;
+			aeon_cu_an_set_ms_cfg(ms_related_cfg[0],
+				ms_related_cfg[1], ms_related_cfg[2], phydev);
+		}
+		if (__priv_data->port_type != 0xF) {
+			ms_related_cfg[0] = __priv_data->port_type;
+			aeon_cu_an_set_ms_cfg(ms_related_cfg[0],
+				ms_related_cfg[1], ms_related_cfg[2], phydev);
+		}
+		if ((__priv_data->smt_spd.enable != 0xF) ||
+		    (__priv_data->smt_spd.retry_limit != 0xF)) {
+			aeon_cu_an_enable_downshift(__priv_data->smt_spd.enable,
+				__priv_data->smt_spd.retry_limit, phydev);
+		}
+		if (__priv_data->nstd_pbo != 0xFF)
+			aeon_cu_an_enable_aeon_oui(__priv_data->nstd_pbo, phydev);
+		if ((__priv_data->trd_swap != 0xF) ||
+		    (__priv_data->trd_ovrd != 0xF))
+			aeon_cu_an_set_trd_swap(__priv_data->trd_ovrd, __priv_data->trd_swap,
+						phydev);
+		if (__priv_data->cfr != 0xF)
+			aeon_cu_an_set_cfr(__priv_data->cfr, phydev);
+		aeon_ipc_sync_parity(phydev);
+		aeon_cu_an_restart(phydev);
+		pr_info("AN-related CFG finish, restart AN successfully!\n");
+	} else
+		printk_restart_an_usage();
+
+	return count;
+}
+
+static ssize_t aeon_speed_mode_read_proc(struct file *file, char __user *buf,
+					 size_t size, loff_t *ppos)
+{
+	printk_force_speed_usage();
+	return 0;
+}
+
+static ssize_t aeon_speed_mode_write_proc(struct file *file, const char __user *buffer,
+					  size_t count, loff_t *pos)
+{
+	struct phy_device *phydev = file->private_data;
+	struct as21xxx_priv *priv = phydev->priv;
+	struct an_mdi_cfg *__priv_data = &priv->mdi_cfg;
+	char val_string[MAX_BUF] = { 0 };
+	struct parsed_cmd cmdinfo = { 0 };
+
+	if (count >= sizeof(val_string))
+		return -EINVAL;
+
+	if (copy_from_user(val_string, buffer, count))
+		return -EFAULT;
+
+	val_string[count] = '\0';
+
+	if (parse_cmd_args(val_string, &cmdinfo, 0) != 0)
+		return -EINVAL;
+
+	if (cmdinfo.argc != 0)
+		return -EINVAL;
+
+	if (!strcmp(cmdinfo.cmd, "10Gbps")) {
+		__priv_data->top_spd = MDI_CFG_SPD_T10G;
+		pr_info("Set 10Gbps successfully!\n");
+	} else if (!strcmp(cmdinfo.cmd, "5Gbps")) {
+		__priv_data->top_spd = MDI_CFG_SPD_T5G;
+		pr_info("Set 5Gbps successfully!\n");
+	} else if (!strcmp(cmdinfo.cmd, "2.5Gbps")) {
+		__priv_data->top_spd = MDI_CFG_SPD_T2P5G;
+		pr_info("Set 2.5Gbps successfully!\n");
+	} else if (!strcmp(cmdinfo.cmd, "1Gbps")) {
+		__priv_data->top_spd = MDI_CFG_SPD_T1G;
+		pr_info("Set 1Gbps successfully!\n");
+	} else if (!strcmp(cmdinfo.cmd, "100Mbps")) {
+		__priv_data->top_spd = MDI_CFG_SPD_T100;
+		pr_info("Set 100Mbps successfully!\n");
+	} else
+		printk_force_speed_usage();
+
+	return count;
+}
+
+static ssize_t aeon_mdi_cfg_read_proc(struct file *file, char __user *buf, size_t size,
+				      loff_t *ppos)
+{
+	printk_mdi_cfg_usage();
+	return 0;
+}
+
+static ssize_t aeon_mdi_cfg_write_proc(struct file *file, const char __user *buffer,
+				       size_t count, loff_t *pos)
+{
+	struct phy_device *phydev = file->private_data;
+	struct as21xxx_priv *priv = phydev->priv;
+	struct an_mdi_cfg *__priv_data = &priv->mdi_cfg;
+	char val_string[MAX_BUF] = { 0 };
+	struct parsed_cmd cmdinfo = { 0 };
+
+	if (count >= sizeof(val_string))
+		return -EINVAL;
+
+	if (copy_from_user(val_string, buffer, count))
+		return -EFAULT;
+
+	val_string[count] = '\0';
+
+	if (parse_cmd_args(val_string, &cmdinfo, 2) != 0)
+		return -EINVAL;
+
+	if (!strcmp(cmdinfo.cmd, "FastRetrain")) {
+		if (cmdinfo.argc != 2)
+			return -EINVAL;
+		__priv_data->fr_spd = cmdinfo.args[0];
+		__priv_data->thp_byp = cmdinfo.args[1];
+		aeon_cu_an_set_fast_retrain(__priv_data->fr_spd, __priv_data->thp_byp, phydev);
+		pr_info("CFG Fast Retrain successfully!\n");
+	} else if (!strcmp(cmdinfo.cmd, "EEE")) {
+		if (cmdinfo.argc != 1)
+			return -EINVAL;
+		__priv_data->eee_spd = cmdinfo.args[0];
+		pr_info("CFG EEE successfully!\n");
+	} else if (!strcmp(cmdinfo.cmd, "ManualMS")) {
+		if (cmdinfo.argc != 1)
+			return -EINVAL;
+		__priv_data->ms_en = cmdinfo.args[0];
+		pr_info("CFG Manual M/S enable successfully!\n");
+	} else if (!strcmp(cmdinfo.cmd, "SetMS")) {
+		if (cmdinfo.argc != 1)
+			return -EINVAL;
+		__priv_data->ms_config = cmdinfo.args[0];
+		pr_info("CFG M/S successfully!\n");
+	} else if (!strcmp(cmdinfo.cmd, "PortType")) {
+		if (cmdinfo.argc != 1)
+			return -EINVAL;
+		__priv_data->port_type = cmdinfo.args[0];
+		pr_info("CFG Port Type successfully!\n");
+	} else if (!strcmp(cmdinfo.cmd, "Smartspd")) {
+		if (cmdinfo.argc != 2)
+			return -EINVAL;
+		__priv_data->smt_spd.enable = cmdinfo.args[0];
+		__priv_data->smt_spd.retry_limit = cmdinfo.args[1];
+		pr_info("CFG Smartspd successfully!\n");
+	} else if (!strcmp(cmdinfo.cmd, "AeonOUI")) {
+		if (cmdinfo.argc != 1)
+			return -EINVAL;
+		__priv_data->nstd_pbo = cmdinfo.args[0];
+		pr_info("CFG aeon oui successfully!\n");
+	} else if (!strcmp(cmdinfo.cmd, "TrdSwap")) {
+		if (cmdinfo.argc != 2)
+			return -EINVAL;
+		__priv_data->trd_ovrd = cmdinfo.args[0];
+		__priv_data->trd_swap = cmdinfo.args[1];
+		pr_info("CFG Trd Swap successfully!\n");
+	} else if (!strcmp(cmdinfo.cmd, "CFR")) {
+		if (cmdinfo.argc != 1)
+			return -EINVAL;
+		__priv_data->cfr = cmdinfo.args[0];
+		pr_info("CFG CFR successfully!\n");
+	} else
+		printk_mdi_cfg_usage();
+
+	return count;
+}
+
+static ssize_t aeon_sds_pcs_cfg_read_proc(struct file *file, char __user *buf,
+					  size_t size, loff_t *ppos)
+{
+	printk_sds_pcs_cfg_usage();
+	return 0;
+}
+
+static ssize_t aeon_sds_pcs_cfg_write_proc(struct file *file,
+					   const char __user *buffer, size_t count,
+					   loff_t *pos)
+{
+	struct phy_device *phydev = file->private_data;
+	char val_string[MAX_BUF] = { 0 };
+	struct parsed_cmd cmdinfo = { 0 };
+
+	if (count >= sizeof(val_string))
+		return -EINVAL;
+
+	if (copy_from_user(val_string, buffer, count))
+		return -EFAULT;
+
+	val_string[count] = '\0';
+
+	if (parse_cmd_args(val_string, &cmdinfo, 2) != 0)
+		return -EINVAL;
+
+	if (!strcmp(cmdinfo.cmd, "SdsRA")) {
+		if (cmdinfo.argc != 0)
+			return -EINVAL;
+
+		aeon_ipc_sync_parity(phydev);
+		aeon_dpc_ra_enable(phydev);
+		pr_info("Set Sds Rate Adaptation successfully!\n");
+	} else if (!strcmp(cmdinfo.cmd, "SdsPcs")) {
+		if (cmdinfo.argc != 2)
+			return -EINVAL;
+
+		aeon_ipc_sync_parity(phydev);
+		aeon_sds_pcs_set_cfg(cmdinfo.args[0], cmdinfo.args[1], phydev);
+		pr_info("Set Sds Pcs successfully!\n");
+	} else
+		printk_sds_pcs_cfg_usage();
+
+	return count;
+}
+
+static ssize_t aeon_auto_eee_cfg_read_proc(struct file *file, char __user *buf,
+					   size_t size, loff_t *ppos)
+{
+	printk_auto_eee_cfg_usage();
+	return 0;
+}
+
+static ssize_t aeon_auto_eee_cfg_write_proc(struct file *file,
+					    const char __user *buffer, size_t count,
+					    loff_t *pos)
+{
+	struct phy_device *phydev = file->private_data;
+	char val_string[MAX_BUF] = { 0 };
+	struct parsed_cmd cmdinfo = { 0 };
+
+	if (count >= sizeof(val_string))
+		return -EINVAL;
+
+	if (copy_from_user(val_string, buffer, count))
+		return -EFAULT;
+
+	val_string[count] = '\0';
+
+	if (parse_cmd_args(val_string, &cmdinfo, 2) != 0)
+		return -EINVAL;
+
+	if (!strcmp(cmdinfo.cmd, "AutoEEE")) {
+		if (cmdinfo.argc != 2)
+			return -EINVAL;
+
+		aeon_ipc_sync_parity(phydev);
+		aeon_auto_eee_cfg(cmdinfo.args[0], cmdinfo.args[1], phydev);
+		pr_info("Set Auto EEE successfully!\n");
+	} else
+		printk_auto_eee_cfg_usage();
+
+	return count;
+}
+
+static ssize_t aeon_phy_enable_read_proc(struct file *file, char __user *buf,
+					 size_t size, loff_t *ppos)
+{
+	printk_phy_enable_usage();
+	return 0;
+}
+
+static ssize_t aeon_phy_enable_write_proc(struct file *file, const char __user *buffer,
+					  size_t count, loff_t *pos)
+{
+	struct phy_device *phydev = file->private_data;
+	char val_string[MAX_BUF] = { 0 };
+	struct parsed_cmd cmdinfo = { 0 };
+
+	if (count >= sizeof(val_string))
+		return -EINVAL;
+
+	if (copy_from_user(val_string, buffer, count))
+		return -EFAULT;
+
+	val_string[count] = '\0';
+
+	if (parse_cmd_args(val_string, &cmdinfo, 1) != 0)
+		return -EINVAL;
+
+	if (!strcmp(cmdinfo.cmd, "phyenable")) {
+		if (cmdinfo.argc != 1)
+			return -EINVAL;
+
+		aeon_ipc_sync_parity(phydev);
+		aeon_ipc_phy_enable_mode(cmdinfo.args[0], phydev);
+		pr_info("Set phy successfully!\n");
+	} else
+		printk_phy_enable_usage();
+
+	return count;
+}
+
+static ssize_t aeon_set_led_read_proc(struct file *file, char __user *buf, size_t size,
+				      loff_t *ppos)
+{
+	printk_set_led_usage();
+	return 0;
+}
+
+static ssize_t aeon_set_led_write_proc(struct file *file, const char __user *buffer,
+				       size_t count, loff_t *pos)
+{
+	struct phy_device *phydev = file->private_data;
+	char val_string[MAX_BUF] = { 0 };
+	struct parsed_cmd cmdinfo = { 0 };
+
+	if (count >= sizeof(val_string))
+		return -EINVAL;
+
+	if (copy_from_user(val_string, buffer, count))
+		return -EFAULT;
+
+	val_string[count] = '\0';
+
+	if (parse_cmd_args(val_string, &cmdinfo, 7) != 0)
+		return -EINVAL;
+
+	if (!strcmp(cmdinfo.cmd, "led")) {
+		if (cmdinfo.argc != 7)
+			return -EINVAL;
+
+		aeon_ipc_sync_parity(phydev);
+		aeon_ipc_set_led_cfg(cmdinfo.args[0], cmdinfo.args[1], cmdinfo.args[2],
+				     cmdinfo.args[3], cmdinfo.args[4], cmdinfo.args[5],
+				     cmdinfo.args[6], phydev);
+		pr_info("Set LED successfully!\n");
+	} else
+		printk_set_led_usage();
+
+	return count;
+}
+
+static ssize_t aeon_sds_pma_cfg_read_proc(struct file *file, char __user *buf,
+					  size_t size, loff_t *ppos)
+{
+	printk_sds_pma_cfg_usage();
+	return 0;
+}
+
+static ssize_t aeon_sds_pma_cfg_write_proc(struct file *file,
+					   const char __user *buffer, size_t count,
+					   loff_t *pos)
+{
+	struct phy_device *phydev = file->private_data;
+	char val_string[MAX_BUF] = { 0 };
+	struct parsed_cmd cmdinfo = { 0 };
+
+	if (count >= sizeof(val_string))
+		return -EINVAL;
+
+	if (copy_from_user(val_string, buffer, count))
+		return -EFAULT;
+
+	val_string[count] = '\0';
+
+	if (parse_cmd_args(val_string, &cmdinfo, 4) != 0)
+		return -EINVAL;
+
+	if (!strcmp(cmdinfo.cmd, "SdsPma")) {
+		if (cmdinfo.argc != 4)
+			return -EINVAL;
+
+		aeon_ipc_sync_parity(phydev);
+		aeon_sds_pma_set_cfg(cmdinfo.args[0], cmdinfo.args[1], cmdinfo.args[2],
+				     cmdinfo.args[3], phydev);
+		pr_info("Set Sds PMA successfully!\n");
+	} else
+		printk_sds_pma_cfg_usage();
+
+	return count;
+}
+
+static ssize_t aeon_fw_version_read_proc(struct file *file, char __user *buf,
+					 size_t size, loff_t *ppos)
+{
+	printk_get_fw_version_usage();
+	return 0;
+}
+
+static ssize_t aeon_fw_version_write_proc(struct file *file, const char __user *buffer,
+					  size_t count, loff_t *pos)
+{
+	struct phy_device *phydev = file->private_data;
+	char val_string[MAX_BUF] = { 0 }, version1[16] = { 0 };
+	struct parsed_cmd cmdinfo = { 0 };
+
+	if (count >= sizeof(val_string))
+		return -EINVAL;
+
+	if (copy_from_user(val_string, buffer, count))
+		return -EFAULT;
+
+	val_string[count] = '\0';
+
+	if (parse_cmd_args(val_string, &cmdinfo, 0) != 0)
+		return -EINVAL;
+
+	if (!strcmp(cmdinfo.cmd, "ver")) {
+		if (cmdinfo.argc != 0)
+			return -EINVAL;
+
+		aeon_ipc_sync_parity(phydev);
+		aeon_ipc_get_fw_version(version1, phydev);
+		pr_info("Get FW version : %32s\n", version1);
+	} else
+		printk_get_fw_version_usage();
+
+	return count;
+}
+
+static ssize_t aeon_temp_monitor_read_proc(struct file *file, char __user *buf,
+					   size_t size, loff_t *ppos)
+{
+	printk_temp_monitor_usage();
+	return 0;
+}
+
+static ssize_t aeon_temp_monitor_write_proc(struct file *file,
+					    const char __user *buffer, size_t count,
+					    loff_t *pos)
+{
+	struct phy_device *phydev = file->private_data;
+	char val_string[MAX_BUF] = { 0 };
+	struct parsed_cmd cmdinfo = { 0 };
+	unsigned short tempnow[16] = { 0 }, temperature = 0;
+	unsigned int params;
+
+	if (count >= sizeof(val_string))
+		return -EINVAL;
+
+	if (copy_from_user(val_string, buffer, count))
+		return -EFAULT;
+
+	val_string[count] = '\0';
+
+	if (parse_cmd_args(val_string, &cmdinfo, 2) != 0)
+		return -EINVAL;
+
+	if (!strcmp(cmdinfo.cmd, "temp")) {
+		aeon_ipc_sync_parity(phydev);
+		aeon_ipc_temp_monitor(cmdinfo.args[0], cmdinfo.args[1], tempnow, phydev);
+		pr_info("Set temperature monitor successfully!\n");
+		if (cmdinfo.args[0] == 0x4) {
+			params = (unsigned long)(tempnow[1] | (tempnow[2] << 16));
+			temperature = params / 65536;
+			if (temperature > 32768)
+				temperature = temperature - 1 - 0xFFFF;
+			pr_info("Get temperature : %u celsius\n", temperature);
+		}
+	} else
+		printk_temp_monitor_usage();
+
+	return count;
+}
+
+static ssize_t aeon_sys_reboot_read_proc(struct file *file, char __user *buf,
+					 size_t size, loff_t *ppos)
+{
+	printk_sys_reboot_usage();
+	return 0;
+}
+
+static ssize_t aeon_sys_reboot_write_proc(struct file *file, const char __user *buffer,
+					  size_t count, loff_t *pos)
+{
+	struct phy_device *phydev = file->private_data;
+	char val_string[MAX_BUF] = { 0 };
+	struct parsed_cmd cmdinfo = { 0 };
+
+	if (count >= sizeof(val_string))
+		return -EINVAL;
+
+	if (copy_from_user(val_string, buffer, count))
+		return -EFAULT;
+
+	val_string[count] = '\0';
+
+	if (parse_cmd_args(val_string, &cmdinfo, 0) != 0)
+		return -EINVAL;
+
+	if (!strcmp(cmdinfo.cmd, "reboot")) {
+		if (cmdinfo.argc != 0)
+			return -EINVAL;
+
+		aeon_ipc_sync_parity(phydev);
+		aeon_ipc_set_sys_reboot(phydev);
+		pr_info("Reboot successfully!\n");
+	} else
+		printk_sys_reboot_usage();
+
+	return count;
+}
+
+#ifdef DUAL_FLASH
+static ssize_t aeon_burn_flash_read_proc(struct file *file, char __user *buf,
+					 size_t size, loff_t *ppos)
+{
+	printk_sys_dual_flash();
+	return 0;
+}
+
+static ssize_t aeon_burn_flash_write_proc(struct file *file, const char __user *buffer,
+					  size_t count, loff_t *pos)
+{
+	struct phy_device *phydev = file->private_data;
+	char val_string[MAX_BUF] = { 0 };
+	struct parsed_cmd cmdinfo = { 0 };
+
+	if (count >= sizeof(val_string))
+		return -EINVAL;
+
+	if (copy_from_user(val_string, buffer, count))
+		return -EFAULT;
+
+	val_string[count] = '\0';
+
+	if (parse_cmd_args(val_string, &cmdinfo, 1) != 0)
+		return -EINVAL;
+
+	if (!strcmp(cmdinfo.cmd, "flash")) {
+		if (cmdinfo.argc != 1)
+			return -EINVAL;
+
+		aeon_ipc_sync_parity(phydev);
+		aeon_burn_image(cmdinfo.args[0], phydev);
+		pr_info("Set flash_burning successfully!\n");
+	} else
+		printk_sys_dual_flash();
+
+	return count;
+}
+
+static ssize_t aeon_erase_flash_read_proc(struct file *file, char __user *buf,
+					  size_t size, loff_t *ppos)
+{
+	printk_erase_flash();
+	return 0;
+}
+
+static ssize_t aeon_erase_flash_write_proc(struct file *file,
+					   const char __user *buffer, size_t count,
+					   loff_t *pos)
+{
+	struct phy_device *phydev = file->private_data;
+	char val_string[MAX_BUF] = { 0 };
+	struct parsed_cmd cmdinfo = { 0 };
+
+	if (count >= sizeof(val_string))
+		return -EINVAL;
+
+	if (copy_from_user(val_string, buffer, count))
+		return -EFAULT;
+
+	val_string[count] = '\0';
+
+	if (parse_cmd_args(val_string, &cmdinfo, 2) != 0)
+		return -EINVAL;
+
+	if (!strcmp(cmdinfo.cmd, "erase")) {
+		if (cmdinfo.argc != 2)
+			return -EINVAL;
+
+		aeon_ipc_sync_parity(phydev);
+		aeon_ipc_erase_flash(cmdinfo.args[0], cmdinfo.args[1], 2, phydev);
+		pr_info("Erase flash successfully!\n");
+	} else
+		printk_erase_flash();
+
+	return count;
+}
+#endif
+
+static ssize_t aeon_sds_restart_an_read_proc(struct file *file, char __user *buf,
+					     size_t size, loff_t *ppos)
+{
+	printk_sds_restart_an_usage();
+	return 0;
+}
+
+static ssize_t aeon_sds_restart_an_write_proc(struct file *file,
+					      const char __user *buffer, size_t count,
+					      loff_t *pos)
+{
+	struct phy_device *phydev = file->private_data;
+	char val_string[MAX_BUF] = { 0 };
+	struct parsed_cmd cmdinfo = { 0 };
+
+	if (count >= sizeof(val_string))
+		return -EINVAL;
+
+	if (copy_from_user(val_string, buffer, count))
+		return -EFAULT;
+
+	val_string[count] = '\0';
+
+	if (parse_cmd_args(val_string, &cmdinfo, 0) != 0)
+		return -EINVAL;
+
+	if (!strcmp(cmdinfo.cmd, "sdsan")) {
+		if (cmdinfo.argc != 0)
+			return -EINVAL;
+
+		aeon_ipc_sync_parity(phydev);
+		aeon_sds_restart_an(phydev);
+		pr_info("Restart sds AN successfully!\n");
+	} else
+		printk_sds_restart_an_usage();
+
+	return count;
+}
+
+static ssize_t aeon_test_mode_read_proc(struct file *file, char __user *buf,
+					size_t size, loff_t *ppos)
+{
+	printk_test_mode_usage();
+	return 0;
+}
+
+static ssize_t aeon_test_mode_write_proc(struct file *file, const char __user *buffer,
+					 size_t count, loff_t *pos)
+{
+	struct phy_device *phydev = file->private_data;
+	char val_string[MAX_BUF] = { 0 };
+	struct parsed_cmd cmdinfo = { 0 };
+	unsigned short input1;
+
+	if (count >= sizeof(val_string))
+		return -EINVAL;
+
+	if (copy_from_user(val_string, buffer, count))
+		return -EFAULT;
+
+	val_string[count] = '\0';
+
+	if (parse_cmd_args(val_string, &cmdinfo, 3) != 0)
+		return -EINVAL;
+
+	if (!strcmp(cmdinfo.cmd, "100mtest")) {
+		if (cmdinfo.argc != 0)
+			return -EINVAL;
+		aeon_ipc_sync_parity(phydev);
+		aeon_100m_test_mode(phydev);
+		pr_info("Set 100M test mode successfully!\n");
+	} else if (!strcmp(cmdinfo.cmd, "1gtest")) {
+		if (cmdinfo.argc != 1)
+			return -EINVAL;
+		aeon_ipc_sync_parity(phydev);
+		aeon_1g_test_mode(cmdinfo.args[0], phydev);
+		pr_info("Set 1G test mode successfully!\n");
+	} else if (!strcmp(cmdinfo.cmd, "ngtest")) {
+		// Get top_speed
+		if (cmdinfo.args[0] == 1)
+			input1 = MDI_CFG_SPD_T2P5G;
+		else if (cmdinfo.args[0] == 2)
+			input1 = MDI_CFG_SPD_T5G;
+		else if (cmdinfo.args[0] == 3)
+			input1 = MDI_CFG_SPD_T10G;
+		if ((cmdinfo.args[1] == 4) && (cmdinfo.argc == 2)) {
+			pr_info("Please input test tone!\n");
+			printk_test_mode_usage();
+			return -EINVAL;
+		}
+		if ((cmdinfo.argc == 3) && (cmdinfo.args[1] != 4)) {
+			pr_info("Test tone is useless here!\n");
+			printk_test_mode_usage();
+			return -EINVAL;
+		}
+		aeon_ipc_sync_parity(phydev);
+		aeon_ng_test_mode(input1, cmdinfo.args[1], cmdinfo.args[2], phydev);
+		pr_info("Set NG test mode successfully!\n");
+	} else
+		printk_test_mode_usage();
+
+	return count;
+}
+
+static ssize_t aeon_tx_fullscale_read_proc(struct file *file, char __user *buffer,
+					   size_t count, loff_t *pos)
+{
+	printk_tx_fullscale_usage();
+	return 0;
+}
+
+
+static ssize_t aeon_tx_fullscale_write_proc(struct file *file,
+					    const char __user *buffer, size_t count,
+					    loff_t *pos)
+{
+	struct phy_device *phydev = file->private_data;
+	char val_string[MAX_BUF] = { 0 };
+	struct parsed_cmd cmdinfo = { 0 };
+	unsigned short short_delta[4] = { 0 }, speed_all[5] = {4, 8, 16, 32, 64}, i = 0;
+
+	if (count >= sizeof(val_string))
+		return -EINVAL;
+
+	if (copy_from_user(val_string, buffer, count))
+		return -EFAULT;
+
+	val_string[count] = '\0';
+
+	if (parse_cmd_args(val_string, &cmdinfo, 5) != 0)
+		return -EINVAL;
+
+	if (!strcmp(cmdinfo.cmd, "txfullscale")) {
+		if (cmdinfo.argc != 5)
+			return -EINVAL;
+
+		for (i = 0; i < 4; i++)
+			short_delta[i] = (unsigned short)(cmdinfo.args[i+1] + 32678);
+		aeon_ipc_sync_parity(phydev);
+		aeon_ipc_set_tx_fullscale_delta(cmdinfo.args[0], short_delta, phydev);
+		pr_info("Set TX full scale successfully!\n");
+	} else if (!strcmp(cmdinfo.cmd, "get")) {
+		if (cmdinfo.argc != 0)
+			return -EINVAL;
+
+		for (i = 0; i < 5; i++) {
+			aeon_ipc_sync_parity(phydev);
+			aeon_ipc_get_tx_fullscale_delta(speed_all[i], short_delta, phydev);
+			pr_info("speed : %u, tx_fullscale : %d %d %d %d\n", speed_all[i],
+					(short)short_delta[0], (short)short_delta[1],
+					(short)short_delta[2], (short)short_delta[3]);
+		}
+		pr_info("Get TX full scale successfully!\n");
+	} else
+		printk_tx_fullscale_usage();
+
+	return count;
+}
+
+static ssize_t aeon_wol_ctrl_read_proc(struct file *file, char __user *buffer,
+				       size_t count, loff_t *pos)
+{
+	printk_wol_ctrl_usage();
+	return 0;
+}
+
+static ssize_t aeon_wol_ctrl_write_proc(struct file *file, const char __user *buffer,
+					size_t count, loff_t *pos)
+{
+	struct phy_device *phydev = file->private_data;
+	char val_string[MAX_BUF] = { 0 };
+	struct parsed_cmd cmdinfo = { 0 };
+	unsigned short short_delta[3] = { 0 }, i = 0;
+
+	if (count >= sizeof(val_string))
+		return -EINVAL;
+
+	if (copy_from_user(val_string, buffer, count))
+		return -EFAULT;
+
+	val_string[count] = '\0';
+
+	if (parse_cmd_args(val_string, &cmdinfo, 4) != 0)
+		return -EINVAL;
+
+	if (!strcmp(cmdinfo.cmd, "wolctrl")) {
+		if (cmdinfo.argc != 4)
+			return -EINVAL;
+
+		for (i = 0; i < 3; i++)
+			short_delta[i] = (unsigned short)cmdinfo.args[i+1];
+		aeon_ipc_sync_parity(phydev);
+		aeon_ipc_set_wol(cmdinfo.args[0], short_delta, phydev);
+		pr_info("Set wol successfully!\n");
+	} else
+		printk_wol_ctrl_usage();
+
+	return count;
+}
+
+static ssize_t aeon_smi_command_read_proc(struct file *file, char __user *buffer,
+					  size_t count, loff_t *pos)
+{
+	printk_smi_ctrl_usage();
+	return 0;
+}
+
+static ssize_t aeon_smi_command_write_proc(struct file *file,
+					   const char __user *buffer, size_t count,
+					   loff_t *pos)
+{
+	struct phy_device *phydev = file->private_data;
+	char val_string[MAX_BUF] = { 0 };
+	struct parsed_cmd cmdinfo = { 0 };
+	unsigned short short_delta[3] = { 0 }, i = 0;
+
+	if (count >= sizeof(val_string))
+		return -EINVAL;
+
+	if (copy_from_user(val_string, buffer, count))
+		return -EFAULT;
+
+	val_string[count] = '\0';
+
+	if (parse_cmd_args(val_string, &cmdinfo, 2) != 0)
+		return -EINVAL;
+
+	if (!strcmp(cmdinfo.cmd, "smicommand")) {
+		if (cmdinfo.argc != 2)
+			return -EINVAL;
+
+		for (i = 0; i < 2; i++)
+			short_delta[i] = (unsigned short)cmdinfo.args[i];
+		aeon_ipc_sync_parity(phydev);
+		aeon_ipc_smi_command(short_delta, phydev);
+		pr_info("Set SMI Command successfully!\n");
+	} else
+		printk_smi_ctrl_usage();
+
+	return count;
+}
+
+static ssize_t aeon_set_irq_en_read_proc(struct file *file, char __user *buffer,
+					 size_t count, loff_t *pos)
+{
+	printk_set_irq_en_usage();
+	return 0;
+}
+
+static ssize_t aeon_set_irq_en_write_proc(struct file *file, const char __user *buffer,
+					  size_t count, loff_t *pos)
+{
+	struct phy_device *phydev = file->private_data;
+	char val_string[MAX_BUF] = { 0 };
+	struct parsed_cmd cmdinfo = { 0 };
+	unsigned short short_delta[6] = { 0 }, i = 0;
+
+	if (count >= sizeof(val_string))
+		return -EINVAL;
+
+	if (copy_from_user(val_string, buffer, count))
+		return -EFAULT;
+
+	val_string[count] = '\0';
+
+	if (parse_cmd_args(val_string, &cmdinfo, 4) != 0)
+		return -EINVAL;
+
+	if (!strcmp(cmdinfo.cmd, "setirqen")) {
+		if (cmdinfo.argc != 4)
+			return -EINVAL;
+
+		for (i = 0; i < 5; i++)
+			short_delta[i] = (unsigned short)cmdinfo.args[i];
+		aeon_ipc_sync_parity(phydev);
+		aeon_ipc_irq_en(short_delta, phydev);
+		pr_info("Set irq en successfully!\n");
+	} else
+		printk_set_irq_en_usage();
+
+	return count;
+}
+
+static ssize_t aeon_set_irq_clr_read_proc(struct file *file, char __user *buffer,
+					  size_t count, loff_t *pos)
+{
+	printk_set_irq_clr_usage();
+	return 0;
+}
+
+static ssize_t aeon_set_irq_clr_write_proc(struct file *file,
+					   const char __user *buffer, size_t count,
+					   loff_t *pos)
+{
+	struct phy_device *phydev = file->private_data;
+	char val_string[MAX_BUF] = { 0 };
+	struct parsed_cmd cmdinfo = { 0 };
+
+	if (count >= sizeof(val_string))
+		return -EINVAL;
+
+	if (copy_from_user(val_string, buffer, count))
+		return -EFAULT;
+
+	val_string[count] = '\0';
+
+	if (parse_cmd_args(val_string, &cmdinfo, 1) != 0)
+		return -EINVAL;
+
+	if (!strcmp(cmdinfo.cmd, "setirqclr")) {
+		if (cmdinfo.argc != 1)
+			return -EINVAL;
+
+		aeon_ipc_sync_parity(phydev);
+		aeon_ipc_irq_clr(cmdinfo.args[0], phydev);
+		pr_info("Set irq clr successfully!\n");
+	} else
+		printk_set_irq_clr_usage();
+
+	return count;
+}
+
+static ssize_t aeon_query_irq_read_proc(struct file *file, char __user *buffer,
+					size_t count, loff_t *pos)
+{
+	printk_query_irq_status_usage();
+
+	return 0;
+}
+
+static ssize_t aeon_query_irq_write_proc(struct file *file, const char __user *buffer,
+					 size_t count, loff_t *pos)
+{
+	struct phy_device *phydev = file->private_data;
+	char val_string[MAX_BUF] = { 0 };
+	struct parsed_cmd cmdinfo = { 0 };
+	unsigned short param = 0;
+	irq_stats_t stats;
+
+	if (count >= sizeof(val_string))
+		return -EINVAL;
+
+	if (copy_from_user(val_string, buffer, count))
+		return -EFAULT;
+
+	val_string[count] = '\0';
+
+	if (parse_cmd_args(val_string, &cmdinfo, 0) != 0)
+		return -EINVAL;
+
+	if (!strcmp(cmdinfo.cmd, "queryirq")) {
+		if (cmdinfo.argc != 0)
+			return -EINVAL;
+
+		aeon_ipc_sync_parity(phydev);
+		aeon_ipc_irq_query(&param, phydev);
+		pr_info("query irq status is 0x%x!\n", param);
+		*(unsigned char *)&stats = (unsigned char)param;
+		pr_info("wol_sts: %u, link_sts: %u\n", stats.wol_sts, stats.link_sts);
+	} else
+		printk_query_irq_status_usage();
+
+	return count;
+}
+
+static ssize_t aeon_cable_diag_read_proc(struct file *file, char __user *buffer,
+					 size_t count, loff_t *pos)
+{
+	printk_cable_diag_usage();
+	return 0;
+}
+
+static ssize_t aeon_cable_diag_write_proc(struct file *file, const char __user *buffer,
+					  size_t count, loff_t *pos)
+{
+	struct phy_device *phydev = file->private_data;
+	char val_string[MAX_BUF] = { 0 };
+	struct parsed_cmd cmdinfo = { 0 };
+	unsigned short ii = 0, temp[8] = { 0 }, mode = 0;
+	int output = 0;
+
+	if (count >= sizeof(val_string))
+		return -EINVAL;
+
+	if (copy_from_user(val_string, buffer, count))
+		return -EFAULT;
+
+	val_string[count] = '\0';
+
+	if (parse_cmd_args(val_string, &cmdinfo, 1) != 0)
+		return -EINVAL;
+
+	if (cmdinfo.argc > 1)
+		return -EINVAL;
+
+	if (!strcmp(cmdinfo.cmd, "chanlen")) {
+		aeon_ipc_sync_parity(phydev);
+		aeon_ipc_cable_diag(IPC_CMD_CABLE_DIAG_CHAN_LEN, temp, mode, phydev);
+		pr_info("channel length(m) : ");
+		for (ii = 0; ii < CHAN_NUM/2; ii++)
+			pr_info("%u  %u  ", temp[ii] & 0xff, (temp[ii] >> 8));
+		pr_info("\n");
+	} else if (!strcmp(cmdinfo.cmd, "ppmofst")) {
+		aeon_ipc_sync_parity(phydev);
+		aeon_ipc_cable_diag(IPC_CMD_CABLE_DIAG_PPM_OFST, temp, mode, phydev);
+		output = temp[0] | (temp[1] << 16);
+		pr_info("frequency offset : %d\n", output);
+	} else if (!strcmp(cmdinfo.cmd, "snrmargin")) {
+		aeon_ipc_sync_parity(phydev);
+		aeon_ipc_cable_diag(IPC_CMD_CABLE_DIAG_SNR_MARG, temp, mode, phydev);
+		pr_info("SNR margin : ");
+		for (ii = 0; ii < 2 * CHAN_NUM; ii++) {
+			output = temp[ii];
+			++ii;
+			output |= (temp[ii] << 16);
+			pr_info("%d  ", output);
+		}
+		pr_info("\n");
+	} else if (!strcmp(cmdinfo.cmd, "chanskew")) {
+		aeon_ipc_sync_parity(phydev);
+		aeon_ipc_cable_diag(IPC_CMD_CABLE_DIAG_CHAN_SKW, temp, mode, phydev);
+		pr_info("channel skew : ");
+		for (ii = 0; ii < 2 * CHAN_NUM; ii++) {
+			output = temp[ii];
+			++ii;
+			output |= (temp[ii] << 16);
+			pr_info("%d  ", output);
+		}
+		pr_info("\n");
+	} else if (!strcmp(cmdinfo.cmd, "set")) {
+		mode = cmdinfo.args[0];
+		aeon_ipc_sync_parity(phydev);
+		aeon_ipc_cable_diag(IPC_CMD_CABLE_DIAG_SET, temp, mode, phydev);
+	} else if (!strcmp(cmdinfo.cmd, "get")) {
+		aeon_ipc_sync_parity(phydev);
+		aeon_ipc_cable_diag(IPC_CMD_CABLE_DIAG_GET, temp, mode, phydev);
+		pr_info("channel length(m) : ");
+		for (ii = 0; ii < CHAN_NUM/2; ii++)
+			pr_info("%u  %u  ", temp[ii] & 0xff, (temp[ii] >> 8));
+		pr_info("\nimp_type : ");
+		for (ii = 0; ii < CHAN_NUM/2; ii++) {
+			pr_info("%s  %s  ", IMP_TYPE_STR[temp[ii+CHAN_NUM/2] & 0xff],
+				IMP_TYPE_STR[(temp[ii+CHAN_NUM/2] >> 8)]);
+		}
+		pr_info("\nres_conf : ");
+		pr_info("0x%x\n", temp[CHAN_NUM] & 0xff);
+	} else {
+		printk_cable_diag_usage();
+	}
+
+	return count;
+}
+
+
+static ssize_t aeon_eye_diagram_read_proc(struct file *file, char __user *buffer,
+					  size_t count, loff_t *pos)
+{
+	printk_sds_eye_diagram_usage();
+	return 0;
+}
+
+static ssize_t aeon_eye_diagram_write_proc(struct file *file, const char __user *buffer,
+					   size_t count, loff_t *pos)
+{
+	struct phy_device *phydev = file->private_data;
+	struct as21xxx_priv *priv = phydev->priv;
+	unsigned char *raw_eye_data = priv->raw_eye_data;
+	char val_string[MAX_BUF] = {  0};
+	struct parsed_cmd cmdinfo = { 0 };
+	unsigned short ii, grp, part;
+
+	if (count >= sizeof(val_string))
+		return -EINVAL;
+
+	if (copy_from_user(val_string, buffer, count))
+		return -EFAULT;
+
+	val_string[count] = '\0';
+
+	if (parse_cmd_args(val_string, &cmdinfo, 1) != 0)
+		return -EINVAL;
+
+	if (!strcmp(cmdinfo.cmd, "eyescan")) {
+		part = cmdinfo.args[0];
+		if (part == EYE_PART_0) {
+			for (grp = 0; grp < EYE_PART_0_GRPS ; ++grp) {
+				aeon_ipc_sync_parity(phydev);
+				aeon_ipc_eye_scan(0, grp, &raw_eye_data[grp * EYE_STRIDE], phydev);
+			}
+		} else if (part == EYE_PART_1) {
+			for (grp = EYE_PART_0_GRPS; grp < EYE_GRPS ; ++grp) {
+				aeon_ipc_sync_parity(phydev);
+				aeon_ipc_eye_scan(0, grp, &raw_eye_data[grp * EYE_STRIDE], phydev);
+			}
+		} else {
+			return -EINVAL;
+		}
+	} else if (!strcmp(cmdinfo.cmd, "eyeshow")) {
+		pr_info("RAW EYE data:\n");
+		for (ii = 0; ii < EYE_TOTAL_BYTES; ++ii) {
+			if (ii % 16 == 0) {
+				pr_info("\n");
+			}
+			pr_info("0x%02x ", raw_eye_data[ii]);
+		}
+		pr_info("\n");
+
+		memset(raw_eye_data, 0, EYE_TOTAL_BYTES);
+	} else {
+		printk_sds_eye_diagram_usage();
+	}
+	return count;
+}
+
+static ssize_t aeon_sds2nd_mode_read_proc(struct file *file, char __user *buffer,
+					  size_t count, loff_t *pos)
+{
+	printk_sds2nd_cfg_usage();
+	return 0;
+}
+
+static ssize_t aeon_sds2nd_mode_write_proc(struct file *file, const char __user *buffer,
+					   size_t count, loff_t *pos)
+{
+	struct phy_device *phydev = file->private_data;
+	char val_string[MAX_BUF] = { 0 };
+	struct parsed_cmd cmdinfo = { 0 };
+
+	if (count >= sizeof(val_string))
+		return -EINVAL;
+
+	if (copy_from_user(val_string, buffer, count))
+		return -EFAULT;
+
+	val_string[count] = '\0';
+
+	if (parse_cmd_args(val_string, &cmdinfo, 2) != 0)
+		return -EINVAL;
+
+	if (!strcmp(cmdinfo.cmd, "Sds2ndMode")) {
+		if (cmdinfo.argc != 2)
+			return -EINVAL;
+
+		aeon_ipc_sync_parity(phydev);
+		aeon_sds2nd_mode_cfg(cmdinfo.args[0], cmdinfo.args[1], 0, phydev);
+	} else {
+		printk_sds2nd_cfg_usage();
+	}
+
+	return count;
+}
+
+static ssize_t aeon_sds2nd_eq_read_proc(struct file *file, char __user *buffer,
+					size_t count, loff_t *pos)
+{
+	printk_sds2nd_cfg_usage();
+	return 0;
+}
+
+static ssize_t aeon_sds2nd_eq_write_proc(struct file *file, const char __user *buffer,
+					 size_t count, loff_t *pos)
+{
+	struct phy_device *phydev = file->private_data;
+	char val_string[MAX_BUF] = { 0 };
+	struct parsed_cmd cmdinfo = { 0 };
+
+	if (count >= sizeof(val_string))
+		return -EINVAL;
+
+	if (copy_from_user(val_string, buffer, count))
+		return -EFAULT;
+
+	val_string[count] = '\0';
+
+	if (parse_cmd_args(val_string, &cmdinfo, 4) != 0)
+		return -EINVAL;
+
+	if (!strcmp(cmdinfo.cmd, "Sds2ndEq")) {
+		if (cmdinfo.argc != 4)
+			return -EINVAL;
+
+		aeon_ipc_sync_parity(phydev);
+		aeon_sds2nd_eq_cfg(cmdinfo.args[0], cmdinfo.args[1], cmdinfo.args[2],
+				   cmdinfo.args[3], phydev);
+	} else
+		printk_sds2nd_cfg_usage();
+
+	return count;
+}
+
+static ssize_t aeon_sds2nd_enable_read_proc(struct file *file, char __user *buffer,
+					    size_t count, loff_t *pos)
+{
+	printk_sds2nd_cfg_usage();
+	return 0;
+}
+
+static ssize_t aeon_sds2nd_enable_write_proc(struct file *file, const char __user *buffer,
+					     size_t count, loff_t *pos)
+{
+	struct phy_device *phydev = file->private_data;
+	char val_string[MAX_BUF] = { 0 };
+	struct parsed_cmd cmdinfo = { 0 };
+
+	if (count >= sizeof(val_string))
+		return -EINVAL;
+
+	if (copy_from_user(val_string, buffer, count))
+		return -EFAULT;
+
+	val_string[count] = '\0';
+
+	if (parse_cmd_args(val_string, &cmdinfo, 1) != 0)
+		return -EINVAL;
+
+	if (!strcmp(cmdinfo.cmd, "Sds2ndEn")) {
+		if (cmdinfo.argc != 1)
+			return -EINVAL;
+
+		aeon_ipc_sync_parity(phydev);
+		aeon_sds2nd_enable(cmdinfo.args[0], phydev);
+	} else
+		printk_sds2nd_cfg_usage();
+
+	return count;
+}
+
+static ssize_t aeon_sds2nd_eye_diagram_read_proc(struct file *file, char __user *buffer,
+						 size_t count, loff_t *pos)
+{
+	printk_sds2nd_eye_diagram_usage();
+
+	return 0;
+}
+
+static ssize_t aeon_sds2nd_eye_diagram_write_proc(struct file *file, const char __user *buffer,
+						  size_t count, loff_t *pos)
+{
+	struct phy_device *phydev = file->private_data;
+	struct as21xxx_priv *priv = phydev->priv;
+	unsigned char *raw_eye_data = priv->raw_eye_data;
+	char val_string[MAX_BUF] = { 0 };
+	struct parsed_cmd cmdinfo = { 0 };
+	unsigned short ii, grp, part;
+
+	if (count >= sizeof(val_string))
+		return -EINVAL;
+
+	if (copy_from_user(val_string, buffer, count))
+		return -EFAULT;
+
+	val_string[count] = '\0';
+
+	if (parse_cmd_args(val_string, &cmdinfo, 1) != 0)
+		return -EINVAL;
+
+	if (!strcmp(cmdinfo.cmd, "eyescan")) {
+		part = cmdinfo.args[0];
+		if (part == EYE_PART_0) {
+			for (grp = 0; grp < EYE_PART_0_GRPS ; ++grp) {
+				aeon_ipc_sync_parity(phydev);
+				aeon_ipc_eye_scan(1, grp, &raw_eye_data[grp * EYE_STRIDE], phydev);
+			}
+		} else if (part == EYE_PART_1) {
+			for (grp = EYE_PART_0_GRPS; grp < EYE_GRPS ; ++grp) {
+				aeon_ipc_sync_parity(phydev);
+				aeon_ipc_eye_scan(1, grp, &raw_eye_data[grp * EYE_STRIDE], phydev);
+			}
+		} else {
+			return -EINVAL;
+		}
+	} else if (!strcmp(cmdinfo.cmd, "eyeshow")) {
+		pr_info("RAW EYE data:\n");
+		for (ii = 0; ii < EYE_TOTAL_BYTES; ++ii) {
+			if (ii % 16 == 0)
+				pr_info("\n");
+			pr_info("0x%02x ", raw_eye_data[ii]);
+		}
+		pr_info("\n");
+
+		memset(raw_eye_data, 0, EYE_TOTAL_BYTES);
+	} else {
+		printk_sds2nd_eye_diagram_usage();
+	}
+
+	return count;
+}
+
+static ssize_t aeon_force_mode_read_proc(struct file *file, char __user *buffer,
+					 size_t count, loff_t *pos)
+{
+	printk_force_mode_usage();
+
+	return 0;
+}
+
+static ssize_t aeon_force_mode_write_proc(struct file *file, const char __user *buffer,
+					  size_t count, loff_t *pos)
+{
+	struct phy_device *phydev = file->private_data;
+	char val_string[MAX_BUF] = { 0 };
+	struct parsed_cmd cmdinfo = { 0 };
+
+	if (count >= sizeof(val_string))
+		return -EINVAL;
+
+	if (copy_from_user(val_string, buffer, count))
+		return -EFAULT;
+
+	val_string[count] = '\0';
+
+	if (parse_cmd_args(val_string, &cmdinfo, 1) != 0)
+		return -EINVAL;
+
+	if (!strcmp(cmdinfo.cmd, "force100M")) {
+		if (cmdinfo.argc != 1)
+			return -EINVAL;
+
+		aeon_ipc_sync_parity(phydev);
+		aeon_set_man_duplex(cmdinfo.args[0], phydev);
+		// switch speed
+		aeon_cu_an_set_top_spd(MDI_CFG_SPD_T100, phydev);
+		// enable AN
+		aeon_cu_an_enable(0, phydev);
+		pr_info("Force 100M successfully!\n");
+	} else
+		printk_force_mode_usage();
+
+	return count;
+}
+
+static ssize_t aeon_parallel_det_read_proc(struct file *file, char __user *buffer,
+					   size_t count, loff_t *pos)
+{
+	printk_parallel_det_usage();
+	return 0;
+}
+
+static ssize_t aeon_parallel_det_write_proc(struct file *file, const char __user *buffer,
+					    size_t count, loff_t *pos)
+{
+	struct phy_device *phydev = file->private_data;
+	char val_string[MAX_BUF] = { 0 };
+	struct parsed_cmd cmdinfo = { 0 };
+
+	if (count >= sizeof(val_string))
+		return -EINVAL;
+
+	if (copy_from_user(val_string, buffer, count))
+		return -EFAULT;
+
+	val_string[count] = '\0';
+
+	if (parse_cmd_args(val_string, &cmdinfo, 1) != 0)
+		return -EINVAL;
+
+	if (!strcmp(cmdinfo.cmd, "paradet")) {
+		if (cmdinfo.argc != 1)
+			return -EINVAL;
+
+		aeon_parallel_det(cmdinfo.args[0], phydev);
+		pr_info("Set parallel detection successfully!\n");
+	} else
+		printk_parallel_det_usage();
+
+	return count;
+}
+
+
+static ssize_t aeon_normal_retrain_read_proc(struct file *file, char __user *buffer,
+					     size_t count, loff_t *pos)
+{
+	printk_normal_retrain_usage();
+
+	return 0;
+}
+
+static ssize_t aeon_normal_retrain_write_proc(struct file *file, const char __user *buffer,
+					      size_t count, loff_t *pos)
+{
+	struct phy_device *phydev = file->private_data;
+	char val_string[MAX_BUF] = { 0 };
+	struct parsed_cmd cmdinfo = { 0 };
+
+	if (count >= sizeof(val_string))
+		return -EINVAL;
+
+	if (copy_from_user(val_string, buffer, count))
+		return -EFAULT;
+
+	val_string[count] = '\0';
+
+	if (parse_cmd_args(val_string, &cmdinfo, 1) != 0)
+		return -EINVAL;
+
+	if (!strcmp(cmdinfo.cmd, "nr")) {
+		if (cmdinfo.argc != 1)
+			return -EINVAL;
+
+		aeon_ipc_sync_parity(phydev);
+		aeon_normal_retrain_cfg(cmdinfo.args[0], phydev);
+		pr_info("Set normal retrain successfully!\n");
+	} else
+		printk_normal_retrain_usage();
+
+	return count;
+}
+
+static ssize_t aeon_sds_txfir_read_proc(struct file *file, char __user *buffer,
+					size_t count, loff_t *pos)
+{
+	printk_sds_txfir_usage();
+
+	return 0;
+}
+
+static ssize_t aeon_sds_txfir_write_proc(struct file *file, const char __user *buffer,
+					 size_t count, loff_t *pos)
+{
+	struct phy_device *phydev = file->private_data;
+	char val_string[MAX_BUF] = { 0 };
+	struct parsed_cmd cmdinfo = { 0 };
+	unsigned short pre, main, post;
+
+	if (count >= sizeof(val_string))
+		return -EINVAL;
+
+	if (copy_from_user(val_string, buffer, count))
+		return -EFAULT;
+
+	val_string[count] = '\0';
+
+	if (parse_cmd_args(val_string, &cmdinfo, 3) != 0)
+		return -EINVAL;
+
+	if (!strcmp(cmdinfo.cmd, "SdsTxFir")) {
+		if (cmdinfo.argc != 3)
+			return -EINVAL;
+		pre = cmdinfo.args[0];
+		main = cmdinfo.args[1];
+		post = cmdinfo.args[2];
+		aeon_ipc_sync_parity(phydev);
+		aeon_ipc_sds_txfir(0, pre, main, post, phydev);
+	} else
+		printk_sds_txfir_usage();
+
+	return count;
+}
+
+static ssize_t aeon_auto_link_read_proc(struct file *file, char __user *buffer,
+					size_t count, loff_t *pos)
+{
+	printk_auto_link_usage();
+
+	return 0;
+}
+
+static ssize_t aeon_auto_link_write_proc(struct file *file, const char __user *buffer,
+					 size_t count, loff_t *pos)
+{
+	struct phy_device *phydev = file->private_data;
+	char val_string[MAX_BUF] = { 0 };
+	struct parsed_cmd cmdinfo = { 0 };
+	unsigned char enable = 0;
+	unsigned char link_type = 0;
+
+	if (count >= sizeof(val_string))
+		return -EINVAL;
+
+	if (copy_from_user(val_string, buffer, count))
+		return -EFAULT;
+
+	val_string[count] = '\0';
+
+	if (parse_cmd_args(val_string, &cmdinfo, 1) != 0)
+		return -EINVAL;
+
+	if (!strcmp(cmdinfo.cmd, "AutoLinkEna")) {
+		if (cmdinfo.argc != 1)
+			return -EINVAL;
+		enable = cmdinfo.args[0];
+		aeon_ipc_sync_parity(phydev);
+		aeon_ipc_auto_link_ena(enable, phydev);
+	} else if (!strcmp(cmdinfo.cmd, "AutoLinkCfg")) {
+		if (cmdinfo.argc != 1)
+			return -EINVAL;
+		link_type = cmdinfo.args[0];
+		aeon_ipc_sync_parity(phydev);
+		aeon_ipc_auto_link_cfg(link_type, phydev);
+	} else
+		printk_auto_link_usage();
+
+	return count;
+}
+
+static ssize_t aeon_force_mdi_mode_read_proc(struct file *file, char __user *buffer,
+					     size_t count, loff_t *pos)
+{
+	printk_force_mdi_mode_usage();
+
+	return 0;
+}
+
+static ssize_t aeon_force_mdi_mode_write_proc(struct file *file, const char __user *buffer,
+					      size_t count, loff_t *pos)
+{
+	struct phy_device *phydev = file->private_data;
+	char val_string[MAX_BUF] = { 0 };
+	struct parsed_cmd cmdinfo = { 0 };
+
+	if (count >= sizeof(val_string))
+		return -EINVAL;
+
+	if (copy_from_user(val_string, buffer, count))
+		return -EFAULT;
+
+	val_string[count] = '\0';
+
+	if (parse_cmd_args(val_string, &cmdinfo, 1) != 0)
+		return -EINVAL;
+
+	if (!strcmp(cmdinfo.cmd, "mdi")) {
+		if (cmdinfo.argc != 1)
+			return -EINVAL;
+
+		aeon_ipc_sync_parity(phydev);
+		if (cmdinfo.args[0] == 1)
+			aeon_set_man_mdi(phydev);
+		else if (cmdinfo.args[0] == 0)
+			aeon_set_man_mdix(phydev);
+		else
+			return -EINVAL;
+
+		pr_info("Force mdi/mdix mode successfully!\n");
+	} else
+		printk_force_mdi_mode_usage();
+
+	return count;
+}
+
+static ssize_t aeon_tx_power_lvl_read_proc(struct file *file, char __user *buffer,
+					   size_t count, loff_t *pos)
+{
+	printk_tx_power_lvl_usage();
+
+	return 0;
+}
+
+static ssize_t aeon_tx_power_lvl_write_proc(struct file *file, const char __user *buffer,
+					    size_t count, loff_t *pos)
+{
+	struct phy_device *phydev = file->private_data;
+	char val_string[MAX_BUF] = { 0 };
+	struct parsed_cmd cmdinfo = { 0 };
+
+	if (count >= sizeof(val_string))
+		return -EINVAL;
+
+	if (copy_from_user(val_string, buffer, count))
+		return -EFAULT;
+
+	val_string[count] = '\0';
+
+	if (parse_cmd_args(val_string, &cmdinfo, 1) != 0)
+		return -EINVAL;
+
+	if (!strcmp(cmdinfo.cmd, "txgain")) {
+		if (cmdinfo.argc != 1)
+			return -EINVAL;
+
+		aeon_ipc_sync_parity(phydev);
+		aeon_ipc_set_tx_power_lvl(cmdinfo.args[0], phydev);
+		pr_info("Set TX power level successfully!\n");
+	} else
+		printk_tx_power_lvl_usage();
+
+	return count;
+}
+
+static ssize_t aeon_synce_master_mode_proc(struct file *file, char __user *buffer,
+					   size_t count, loff_t *pos)
+{
+	printk_synce_master_mode_usage();
+
+	return 0;
+}
+
+static ssize_t aeon_synce_master_mode_write_proc(struct file *file, const char __user *buffer,
+						 size_t count, loff_t *pos)
+{
+	struct phy_device *phydev = file->private_data;
+	char val_string[MAX_BUF] = { 0 };
+	struct parsed_cmd cmdinfo = { 0 };
+
+	if (count >= sizeof(val_string))
+		return -EINVAL;
+
+	if (copy_from_user(val_string, buffer, count))
+		return -EFAULT;
+
+	val_string[count] = '\0';
+
+	if (parse_cmd_args(val_string, &cmdinfo, 2) != 0)
+		return -EINVAL;
+
+	if (!strcmp(cmdinfo.cmd, "synce_master")) {
+		if (cmdinfo.argc != 2)
+			return -EINVAL;
+
+		if ((cmdinfo.args[0] < 0) || (cmdinfo.args[0] > 1)) {
+			pr_info("Set synce enable fail, enable value is from 0 to 1!\n");
+			return -EFAULT;
+		}
+
+		if ((cmdinfo.args[1] < 1) || (cmdinfo.args[1] > 4)) {
+			pr_info("Set user bw fail, enable value is from 1 to 4!\n");
+			return -EFAULT;
+		}
+
+		aeon_ipc_sync_parity(phydev);
+		aeon_synce_mode_cfg(1, phydev);
+		aeon_synce_user_bw(cmdinfo.args[1], phydev);
+		aeon_synce_enable_cfg(cmdinfo.args[0], phydev);
+		pr_info("Set synce master mode successfully!\n");
+	} else
+		printk_synce_master_mode_usage();
+
+	return count;
+}
+
+static ssize_t aeon_synce_slave_mode1_proc(struct file *file, char __user *buffer,
+					   size_t count, loff_t *pos)
+{
+	printk_synce_slave_mode1_usage();
+
+	return 0;
+}
+
+static ssize_t aeon_synce_slave_mode1_write_proc(struct file *file, const char __user *buffer,
+						 size_t count, loff_t *pos)
+{
+	struct phy_device *phydev = file->private_data;
+	char val_string[MAX_BUF] = { 0 };
+	struct parsed_cmd cmdinfo = { 0 };
+
+	if (count >= sizeof(val_string))
+		return -EINVAL;
+
+	if (copy_from_user(val_string, buffer, count))
+		return -EFAULT;
+
+	val_string[count] = '\0';
+
+	if (parse_cmd_args(val_string, &cmdinfo, 2) != 0)
+		return -EINVAL;
+
+	if (!strcmp(cmdinfo.cmd, "synce_slave_mode1")) {
+		if (cmdinfo.argc != 2)
+			return -EINVAL;
+
+		if ((cmdinfo.args[0] < 0) || (cmdinfo.args[0] > 1)) {
+			pr_info("Set synce enable fail, enable value is from 0 to 1!\n");
+			return -EFAULT;
+		}
+
+		if ((cmdinfo.args[1] < 0) || (cmdinfo.args[1] > 4)) {
+			pr_info("Set synce output pin fail, enable value is from 0 to 4!\n");
+			return -EFAULT;
+		}
+
+		aeon_ipc_sync_parity(phydev);
+		aeon_synce_mode_cfg(0, phydev);
+		aeon_synce_user_bw(0, phydev);
+		aeon_synce_slave_output_ctrl_cfg(cmdinfo.args[1], phydev);
+		aeon_synce_enable_cfg(cmdinfo.args[0], phydev);
+		pr_info("Set synce slave mode1 successfully!\n");
+	} else
+		printk_synce_slave_mode1_usage();
+
+	return count;
+}
+
+static ssize_t aeon_synce_slave_mode2_read_proc(struct file *file, char __user *buffer,
+						size_t count, loff_t *pos)
+{
+	printk_synce_slave_mode2_usage();
+
+	return 0;
+}
+
+static ssize_t aeon_synce_slave_mode2_write_proc(struct file *file, const char __user *buffer,
+						 size_t count, loff_t *pos)
+{
+	struct phy_device *phydev = file->private_data;
+	char val_string[MAX_BUF] = { 0 };
+	struct parsed_cmd cmdinfo = { 0 };
+
+	if (count >= sizeof(val_string))
+		return -EINVAL;
+
+	if (copy_from_user(val_string, buffer, count))
+		return -EFAULT;
+
+	val_string[count] = '\0';
+
+	if (parse_cmd_args(val_string, &cmdinfo, 3) != 0)
+		return -EINVAL;
+
+
+	if (!strcmp(cmdinfo.cmd, "synce_slave_mode2")) {
+		if (cmdinfo.argc != 3)
+			return -EINVAL;
+
+		if ((cmdinfo.args[0] < 0) || (cmdinfo.args[0] > 1)) {
+			pr_info("Set synce enable fail, enable value is from 0 to 1!\n");
+			return -EFAULT;
+		}
+
+		if ((cmdinfo.args[1] < 0) || ((cmdinfo.args[1] > 6) && (cmdinfo.args[1] != 10))) {
+			pr_info("Set synce bw fail, enable value is from 0 to 6 and 10!\n");
+			return -EFAULT;
+		}
+
+		if ((cmdinfo.args[2] < 0) || (cmdinfo.args[2] > 1)) {
+			pr_info("Set synce output pin fail, enable value is from 0 to 1!\n");
+			return -EFAULT;
+		}
+
+		aeon_ipc_sync_parity(phydev);
+		aeon_synce_mode_cfg(2, phydev);
+		aeon_synce_user_bw(cmdinfo.args[1], phydev);
+		aeon_synce_slave_output_ctrl_cfg(cmdinfo.args[2], phydev);
+		aeon_synce_enable_cfg(cmdinfo.args[0], phydev);
+		pr_info("Set synce slave mode2 successfully!\n");
+	} else
+		printk_synce_slave_mode2_usage();
+
+	return count;
+}
+
+static const struct file_operations aeon_set_speed_mode_fops = {
+	.owner = THIS_MODULE,
+	.open = simple_open,
+	.read = aeon_speed_mode_read_proc,
+	.write = aeon_speed_mode_write_proc,
+};
+
+static const struct file_operations aeon_set_mdi_cfg_fops = {
+	.owner = THIS_MODULE,
+	.open = simple_open,
+	.read = aeon_mdi_cfg_read_proc,
+	.write = aeon_mdi_cfg_write_proc,
+};
+
+static const struct file_operations aeon_set_sds_pcs_cfg_fops = {
+	.owner = THIS_MODULE,
+	.open = simple_open,
+	.read = aeon_sds_pcs_cfg_read_proc,
+	.write = aeon_sds_pcs_cfg_write_proc,
+};
+
+static const struct file_operations aeon_set_sds_pma_cfg_fops = {
+	.owner = THIS_MODULE,
+	.open = simple_open,
+	.read = aeon_sds_pma_cfg_read_proc,
+	.write = aeon_sds_pma_cfg_write_proc,
+};
+
+static const struct file_operations aeon_fw_version_fops = {
+	.owner = THIS_MODULE,
+	.open = simple_open,
+	.read = aeon_fw_version_read_proc,
+	.write = aeon_fw_version_write_proc,
+};
+
+static const struct file_operations aeon_restart_an_fops = {
+	.owner = THIS_MODULE,
+	.open = simple_open,
+	.read = aeon_restart_an_read_proc,
+	.write = aeon_restart_an_write_proc,
+};
+
+static const struct file_operations aeon_set_led_fops = {
+	.owner = THIS_MODULE,
+	.open = simple_open,
+	.read = aeon_set_led_read_proc,
+	.write = aeon_set_led_write_proc,
+};
+
+static const struct file_operations aeon_temp_monitor_fops = {
+	.owner = THIS_MODULE,
+	.open = simple_open,
+	.read = aeon_temp_monitor_read_proc,
+	.write = aeon_temp_monitor_write_proc,
+};
+
+static const struct file_operations aeon_set_sys_reboot_fops = {
+	.owner = THIS_MODULE,
+	.open = simple_open,
+	.read = aeon_sys_reboot_read_proc,
+	.write = aeon_sys_reboot_write_proc,
+};
+
+static const struct file_operations aeon_auto_eee_cfg_fops = {
+	.owner = THIS_MODULE,
+	.open = simple_open,
+	.read = aeon_auto_eee_cfg_read_proc,
+	.write = aeon_auto_eee_cfg_write_proc,
+};
+
+static const struct file_operations aeon_read_reg_fops = {
+	.owner = THIS_MODULE,
+	.open = simple_open,
+	.read = aeon_read_reg_read_proc,
+	.write = aeon_read_reg_write_proc,
+};
+
+static const struct file_operations aeon_write_reg_fops = {
+	.owner = THIS_MODULE,
+	.open = simple_open,
+	.read = aeon_write_reg_read_proc,
+	.write = aeon_write_reg_write_proc,
+};
+
+static const struct file_operations aeon_get_eth_status_fops = {
+	.owner = THIS_MODULE,
+	.open = simple_open,
+	.read = aeon_eth_status_read_proc,
+	.write = aeon_eth_status_write_proc,
+};
+
+static const struct file_operations aeon_pkt_chk_cfg_fops = {
+	.owner = THIS_MODULE,
+	.open = simple_open,
+	.read = aeon_pkt_chk_cfg_read_proc,
+	.write = aeon_pkt_chk_cfg_write_proc,
+};
+
+static const struct file_operations aeon_mdc_timing_fops = {
+	.owner = THIS_MODULE,
+	.open = simple_open,
+	.read = aeon_mdc_timing_read_proc,
+	.write = aeon_mdc_timing_write_proc,
+};
+
+static const struct file_operations aeon_sds_wait_eth_fops = {
+	.owner = THIS_MODULE,
+	.open = simple_open,
+	.read = aeon_sds_wait_eth_cfg_read_proc,
+	.write = aeon_sds_wait_eth_cfg_write_proc,
+};
+
+static const struct file_operations aeon_phy_enable_fops = {
+	.owner = THIS_MODULE,
+	.open = simple_open,
+	.read = aeon_phy_enable_read_proc,
+	.write = aeon_phy_enable_write_proc,
+};
+#ifdef DUAL_FLASH
+static const struct file_operations aeon_burn_flash_image_fops = {
+	.owner = THIS_MODULE,
+	.open = simple_open,
+	.read = aeon_burn_flash_read_proc,
+	.write = aeon_burn_flash_write_proc,
+};
+static const struct file_operations aeon_erase_flash_fops = {
+	.owner = THIS_MODULE,
+	.open = simple_open,
+	.read = aeon_erase_flash_read_proc,
+	.write = aeon_erase_flash_write_proc,
+};
+#endif
+static const struct file_operations aeon_sds_restart_an_fops = {
+	.owner = THIS_MODULE,
+	.open = simple_open,
+	.read = aeon_sds_restart_an_read_proc,
+	.write = aeon_sds_restart_an_write_proc,
+};
+
+static const struct file_operations aeon_test_mode_fops = {
+	.owner = THIS_MODULE,
+	.open = simple_open,
+	.read = aeon_test_mode_read_proc,
+	.write = aeon_test_mode_write_proc,
+};
+
+static const struct file_operations aeon_tx_fullscale_fops = {
+	.owner = THIS_MODULE,
+	.open = simple_open,
+	.read = aeon_tx_fullscale_read_proc,
+	.write = aeon_tx_fullscale_write_proc,
+};
+
+static const struct file_operations aeon_wol_ctrl = {
+	.owner = THIS_MODULE,
+	.open = simple_open,
+	.read = aeon_wol_ctrl_read_proc,
+	.write = aeon_wol_ctrl_write_proc,
+};
+
+static const struct file_operations aeon_smi_command = {
+	.owner = THIS_MODULE,
+	.open = simple_open,
+	.read = aeon_smi_command_read_proc,
+	.write = aeon_smi_command_write_proc,
+};
+
+static const struct file_operations aeon_setirq_en = {
+	.owner = THIS_MODULE,
+	.open = simple_open,
+	.read = aeon_set_irq_en_read_proc,
+	.write = aeon_set_irq_en_write_proc,
+};
+
+static const struct file_operations aeon_setirq_clr = {
+	.owner = THIS_MODULE,
+	.open = simple_open,
+	.read = aeon_set_irq_clr_read_proc,
+	.write = aeon_set_irq_clr_write_proc,
+};
+
+static const struct file_operations aeon_query_irq = {
+	.owner = THIS_MODULE,
+	.open = simple_open,
+	.read = aeon_query_irq_read_proc,
+	.write = aeon_query_irq_write_proc,
+};
+
+static const struct file_operations aeon_cable_diag = {
+	.owner = THIS_MODULE,
+	.open = simple_open,
+	.read = aeon_cable_diag_read_proc,
+	.write = aeon_cable_diag_write_proc,
+};
+
+static const struct file_operations aeon_eye_diagram_data = {
+	.owner = THIS_MODULE,
+	.open = simple_open,
+	.read = aeon_eye_diagram_read_proc,
+	.write = aeon_eye_diagram_write_proc,
+};
+
+static const struct file_operations aeon_sds2nd_eye_diagram_data = {
+	.owner = THIS_MODULE,
+	.open = simple_open,
+	.read = aeon_sds2nd_eye_diagram_read_proc,
+	.write = aeon_sds2nd_eye_diagram_write_proc,
+};
+
+static const struct file_operations aeon_sds2nd_enable_cfg = {
+	.owner = THIS_MODULE,
+	.open = simple_open,
+	.read = aeon_sds2nd_enable_read_proc,
+	.write = aeon_sds2nd_enable_write_proc,
+};
+
+static const struct file_operations aeon_sds2nd_eq = {
+	.owner = THIS_MODULE,
+	.open = simple_open,
+	.read = aeon_sds2nd_eq_read_proc,
+	.write = aeon_sds2nd_eq_write_proc,
+};
+
+static const struct file_operations aeon_sds2nd_mode = {
+	.owner = THIS_MODULE,
+	.open = simple_open,
+	.read = aeon_sds2nd_mode_read_proc,
+	.write = aeon_sds2nd_mode_write_proc,
+};
+
+static const struct file_operations aeon_force_mode = {
+	.owner = THIS_MODULE,
+	.open = simple_open,
+	.read = aeon_force_mode_read_proc,
+	.write = aeon_force_mode_write_proc,
+};
+
+static const struct file_operations aeon_parallel_detect = {
+	.owner = THIS_MODULE,
+	.open = simple_open,
+	.read = aeon_parallel_det_read_proc,
+	.write = aeon_parallel_det_write_proc,
+};
+
+static const struct file_operations aeon_normal_retrain = {
+	.owner = THIS_MODULE,
+	.open = simple_open,
+	.read = aeon_normal_retrain_read_proc,
+	.write = aeon_normal_retrain_write_proc,
+};
+
+static const struct file_operations aeon_sds_txfir = {
+	.owner = THIS_MODULE,
+	.open = simple_open,
+	.read = aeon_sds_txfir_read_proc,
+	.write = aeon_sds_txfir_write_proc,
+};
+
+static const struct file_operations aeon_auto_link = {
+	.owner = THIS_MODULE,
+	.open = simple_open,
+	.read = aeon_auto_link_read_proc,
+	.write = aeon_auto_link_write_proc,
+};
+
+static const struct file_operations aeon_force_mdi_mode = {
+	.owner = THIS_MODULE,
+	.open = simple_open,
+	.read = aeon_force_mdi_mode_read_proc,
+	.write = aeon_force_mdi_mode_write_proc,
+};
+
+static const struct file_operations aeon_tx_power_lvl = {
+	.owner = THIS_MODULE,
+	.open = simple_open,
+	.read = aeon_tx_power_lvl_read_proc,
+	.write = aeon_tx_power_lvl_write_proc,
+};
+
+static const struct file_operations aeon_synce_master = {
+	.owner = THIS_MODULE,
+	.open = simple_open,
+	.read = aeon_synce_master_mode_proc,
+	.write = aeon_synce_master_mode_write_proc,
+};
+
+static const struct file_operations aeon_synce_slave_mode1 = {
+	.owner = THIS_MODULE,
+	.open = simple_open,
+	.read = aeon_synce_slave_mode1_proc,
+	.write = aeon_synce_slave_mode1_write_proc,
+};
+
+static const struct file_operations aeon_synce_slave_mode2 = {
+	.owner = THIS_MODULE,
+	.open = simple_open,
+	.read = aeon_synce_slave_mode2_read_proc,
+	.write = aeon_synce_slave_mode2_write_proc,
+};
+
+int as21xxx_debugfs_init(struct phy_device *phydev)
+{
+	struct as21xxx_priv *priv = phydev->priv;
+	struct an_mdi_cfg *__priv_data = &priv->mdi_cfg;
+	struct dentry *dir = priv->debugfs_root;
+	int ret = 0;
+
+	dir = debugfs_create_dir(dev_name(&phydev->mdio.dev), NULL);
+	if (!dir) {
+		phydev_err(phydev, "%s:err at %d\n", __func__, __LINE__);
+		ret = -ENOMEM;
+	}
+
+	// init the data structure
+	__priv_data->top_spd = 0xF;
+	__priv_data->eee_spd = 0xFF;
+	__priv_data->fr_spd = 0xF;
+	__priv_data->thp_byp = 0xF;
+	__priv_data->port_type = 0xF;
+	__priv_data->ms_en = 0xF;
+	__priv_data->ms_config = 0xF;
+	__priv_data->nstd_pbo = 0xFF;
+	__priv_data->smt_spd.enable = 0xF;
+	__priv_data->smt_spd.retry_limit = 0xF;
+	__priv_data->trd_ovrd = 0xF;
+	__priv_data->trd_swap = 0xF;
+	__priv_data->cfr = 0xF;
+
+	debugfs_create_file("aeon_set_speed_mode", 0644, dir, phydev,
+			    &aeon_set_speed_mode_fops);
+	debugfs_create_file("aeon_set_mdi_cfg", 0644, dir, phydev,
+			    &aeon_set_mdi_cfg_fops);
+	debugfs_create_file("aeon_set_sds_pcs_cfg", 0644, dir, phydev,
+			    &aeon_set_sds_pcs_cfg_fops);
+	debugfs_create_file("aeon_set_sds_pma_cfg", 0644, dir, phydev,
+			    &aeon_set_sds_pma_cfg_fops);
+	debugfs_create_file("aeon_fw_version", 0644, dir, phydev,
+			    &aeon_fw_version_fops);
+	debugfs_create_file("aeon_restart_an", 0644, dir, phydev,
+			    &aeon_restart_an_fops);
+	debugfs_create_file("aeon_set_led", 0644, dir, phydev,
+			    &aeon_set_led_fops);
+	debugfs_create_file("aeon_temp_monitor", 0644, dir, phydev,
+			    &aeon_temp_monitor_fops);
+	debugfs_create_file("aeon_set_sys_reboot", 0644, dir, phydev,
+			    &aeon_set_sys_reboot_fops);
+	debugfs_create_file("aeon_auto_eee_cfg", 0644, dir, phydev,
+			    &aeon_auto_eee_cfg_fops);
+	debugfs_create_file("aeon_read_reg", 0644, dir, phydev,
+			    &aeon_read_reg_fops);
+	debugfs_create_file("aeon_write_reg", 0644, dir, phydev,
+			    &aeon_write_reg_fops);
+	debugfs_create_file("aeon_get_eth_status", 0644, dir, phydev,
+			    &aeon_get_eth_status_fops);
+	debugfs_create_file("aeon_pkt_chk_cfg", 0644, dir, phydev,
+			    &aeon_pkt_chk_cfg_fops);
+	debugfs_create_file("aeon_mdc_timing", 0644, dir, phydev,
+			    &aeon_mdc_timing_fops);
+	debugfs_create_file("aeon_sds_wait_eth", 0644, dir, phydev,
+			    &aeon_sds_wait_eth_fops);
+	debugfs_create_file("aeon_phy_enable", 0644, dir, phydev,
+			    &aeon_phy_enable_fops);
+#ifdef DUAL_FLASH
+	debugfs_create_file("aeon_burn_flash_image", 0644, dir, phydev,
+			    &aeon_burn_flash_image_fops);
+	debugfs_create_file("aeon_erase_flash", 0644, dir, phydev,
+			    &aeon_erase_flash_fops);
+#endif
+	debugfs_create_file("aeon_sds_restart_an", 0644, dir, phydev,
+			    &aeon_sds_restart_an_fops);
+	debugfs_create_file("aeon_test_mode", 0644, dir, phydev,
+			    &aeon_test_mode_fops);
+	debugfs_create_file("aeon_tx_fullscale", 0644, dir, phydev,
+			    &aeon_tx_fullscale_fops);
+	debugfs_create_file("aeon_wol_ctrl", 0644, dir, phydev,
+			    &aeon_wol_ctrl);
+	debugfs_create_file("aeon_smi_command", 0644, dir, phydev,
+			    &aeon_smi_command);
+	debugfs_create_file("aeon_setirq_en", 0644, dir, phydev,
+			    &aeon_setirq_en);
+	debugfs_create_file("aeon_setirq_clr", 0644, dir, phydev,
+			    &aeon_setirq_clr);
+	debugfs_create_file("aeon_query_irq", 0644, dir, phydev,
+			    &aeon_query_irq);
+	debugfs_create_file("aeon_cable_diag", 0644, dir, phydev,
+			    &aeon_cable_diag);
+	debugfs_create_file("aeon_eye_diagram_data", 0644, dir, phydev,
+			    &aeon_eye_diagram_data);
+	debugfs_create_file("aeon_sds2nd_eye_diagram_data", 0644, dir, phydev,
+			    &aeon_sds2nd_eye_diagram_data);
+	debugfs_create_file("aeon_sds2nd_enable", 0644, dir, phydev,
+			    &aeon_sds2nd_enable_cfg);
+	debugfs_create_file("aeon_sds2nd_eq_cfg", 0644, dir, phydev,
+			    &aeon_sds2nd_eq);
+	debugfs_create_file("aeon_sds2nd_mode_cfg", 0644, dir, phydev,
+			    &aeon_sds2nd_mode);
+	debugfs_create_file("aeon_force_mode", 0644, dir, phydev,
+			    &aeon_force_mode);
+	debugfs_create_file("aeon_parallel_det", 0644, dir, phydev,
+			    &aeon_parallel_detect);
+	debugfs_create_file("aeon_normal_retrain", 0644, dir, phydev,
+			    &aeon_normal_retrain);
+	debugfs_create_file("aeon_sds_txfir", 0644, dir, phydev,
+			    &aeon_sds_txfir);
+	debugfs_create_file("aeon_auto_link", 0644, dir, phydev,
+			    &aeon_auto_link);
+	debugfs_create_file("aeon_force_mdi_mode", 0644, dir, phydev,
+			    &aeon_force_mdi_mode);
+	debugfs_create_file("aeon_tx_power_lvl", 0644, dir, phydev,
+			    &aeon_tx_power_lvl);
+	debugfs_create_file("aeon_synce_master", 0644, dir, phydev,
+			    &aeon_synce_master);
+	debugfs_create_file("aeon_synce_slave_mode1", 0644, dir, phydev,
+			    &aeon_synce_slave_mode1);
+	debugfs_create_file("aeon_synce_slave_mode2", 0644, dir, phydev,
+			    &aeon_synce_slave_mode2);
+
+	priv->debugfs_root = dir;
+
+	return ret;
+}
+
+void as21xxx_debugfs_remove(struct phy_device *phydev)
+{
+	struct as21xxx_priv *priv = phydev->priv;
+
+	debugfs_remove_recursive(priv->debugfs_root);
+	priv->debugfs_root = NULL;
+}
diff --git a/drivers/net/phy/as21xx_bbu_api/as21xx_debugfs.h b/drivers/net/phy/as21xx_bbu_api/as21xx_debugfs.h
new file mode 100644
index 0000000..af66fd1
--- /dev/null
+++ b/drivers/net/phy/as21xx_bbu_api/as21xx_debugfs.h
@@ -0,0 +1,27 @@
+/******************************************************************************
+ *
+ * AEONSEMI CONFIDENTIAL
+ * _____________________
+ *
+ * Aeonsemi Inc., 2023
+ * All Rights Reserved.
+ *
+ * NOTICE:  All information contained herein is, and remains the property of
+ * Aeonsemi Inc. and its subsidiaries, if any. The intellectual and technical
+ * concepts contained herein are proprietary to Aeonsemi Inc. and its
+ * subsidiaries and may be covered by U.S. and Foreign Patents, patents in
+ * process, and are protected by trade secret or copyright law. Dissemination
+ * of this information or reproduction of this material is strictly forbidden
+ * unless prior written permission is obtained from Aeonsemi Inc.
+ *
+ *
+ *****************************************************************************/
+#ifndef _AS21XX_PROC_H_
+#define _AS21XX_PROC_H_
+
+#define CHAN_NUM 4
+
+int as21xxx_debugfs_init(struct phy_device *phydev);
+void as21xxx_debugfs_remove(struct phy_device *phydev);
+
+#endif /**/
diff --git a/drivers/net/phy/as21xxx.c b/drivers/net/phy/as21xxx.c
index 037d799..48d59a7 100644
--- a/drivers/net/phy/as21xxx.c
+++ b/drivers/net/phy/as21xxx.c
@@ -10,6 +10,7 @@
 #include <linux/module.h>
 #include <linux/of.h>
 #include <linux/phy.h>
+#include "as21xxx.h"
 
 #define VEND1_GLB_REG_CPU_RESET_ADDR_LO_BASEADDR 0x3
 #define VEND1_GLB_REG_CPU_RESET_ADDR_HI_BASEADDR 0x4
@@ -21,6 +22,10 @@
 							 BIT(_n))
 
 #define VEND1_FW_START_ADDR		0x100
+#define AN_STATES1_ADDR	0x8005
+#define AN_STATES1_ARB_MASK	0xF000
+#define AN_STATES1_ARB_OFST	12
+#define LINK_GOOD 9
 
 #define VEND1_GLB_REG_MDIO_INDIRECT_ADDRCMD 0x101
 #define VEND1_GLB_REG_MDIO_INDIRECT_LOAD 0x102
@@ -118,6 +123,15 @@
 #define AS21XXX_MDIO_AN_C22		0xffe0
 
 #define PHY_ID_AS21XXX			0x75009410
+
+#define AEON_MEM_DEFAULT_ADDR (0x300100 >> 1)
+#define MEM_WORD_SIZE 4
+#define MAX_WDATA_SIZE 16
+#define PHY_MAX_ADDR 32
+
+static int param1 = 1;
+module_param(param1, int, 0444);
+MODULE_PARM_DESC(param1, "First parameter");
 /* AS21xxx ID Legend
  * AS21x1xxB1
  *     ^ ^^
@@ -182,12 +196,6 @@ struct as21xxx_led_pattern_info {
 	u16 val;
 };
 
-struct as21xxx_priv {
-	bool parity_status;
-	/* Protect concurrent IPC access */
-	struct mutex ipc_lock;
-};
-
 static struct as21xxx_led_pattern_info as21xxx_led_supported_pattern[] = {
 	{
 		.pattern = BIT(TRIGGER_NETDEV_LINK_10),
@@ -294,6 +302,108 @@ static struct as21xxx_led_pattern_info as21xxx_led_supported_pattern[] = {
 	}
 };
 
+static void aeon_mdio_patch(struct phy_device *phydev)
+{
+	struct device *dev = &phydev->mdio.dev;
+	struct mii_bus *bus = phydev->mdio.bus;
+
+	if (!bus) {
+		dev_err(dev, "MDIO bus is NULL\r\n");
+		return;
+	}
+
+	mutex_lock(&bus->mdio_lock);
+	__mdiobus_c45_write(bus, 30, 0x1, 0x1, 0x1);
+	mutex_unlock(&bus->mdio_lock);
+}
+
+int aeon_cl45_read(struct phy_device *phydev, int dev_addr,
+		   unsigned int phy_reg)
+{
+	int ret = 0;
+	struct mii_bus *bus = phydev->mdio.bus;
+	int phy_addr = phydev->mdio.addr;
+
+	if (!bus) {
+		phydev_err(phydev, "MDIO bus is NULL\r\n");
+		return -ENODEV;
+	}
+
+	if (phy_addr >= PHY_MAX_ADDR) {
+		phydev_err(phydev, "Invaild PHY address: %d", phy_addr);
+		return -EINVAL;
+	}
+
+	mutex_lock(&bus->mdio_lock);
+	ret = __mdiobus_c45_read(bus, phy_addr, dev_addr, phy_reg);
+	mutex_unlock(&bus->mdio_lock);
+
+	aeon_mdio_patch(phydev);
+
+	return ret;
+}
+EXPORT_SYMBOL(aeon_cl45_read);
+
+void aeon_cl45_write(struct phy_device *phydev, int dev_addr,
+		     unsigned int phy_reg, unsigned short phy_data)
+{
+	struct mii_bus *bus = phydev->mdio.bus;
+	int phy_addr = phydev->mdio.addr;
+
+	if (!bus) {
+		phydev_err(phydev, "MDIO bus is NULL\r\n");
+		return;
+	}
+
+	if (phy_addr >= PHY_MAX_ADDR) {
+		phydev_err(phydev, "Invaild PHY address: %d", phy_addr);
+		return;
+	}
+
+	mutex_lock(&bus->mdio_lock);
+	__mdiobus_c45_write(bus, phy_addr, dev_addr, phy_reg, phy_data);
+	mutex_unlock(&bus->mdio_lock);
+
+	aeon_mdio_patch(phydev);
+}
+EXPORT_SYMBOL(aeon_cl45_write);
+
+static int aeon_mdio_read(struct phy_device *phydev, int dev_addr,
+			  unsigned short phy_reg)
+{
+	int ret = 0;
+	struct mii_bus *bus = phydev->mdio.bus;
+	int phy_addr = phydev->mdio.addr;
+
+	if (!bus) {
+		phydev_err(phydev, "MDIO bus is NULL\r\n");
+		return -ENODEV;
+	}
+
+	if (phy_addr >= PHY_MAX_ADDR) {
+		phydev_err(phydev, "Invaild PHY address: %d", phy_addr);
+		return -EINVAL;
+	}
+
+	ret = __mdiobus_c45_read(bus, phy_addr, dev_addr, phy_reg);
+	__mdiobus_c45_write(bus, 30, 0x1, 0x1, 0x1);
+
+	return ret;
+}
+
+/* AEONSEMI burst write for load fw */
+static void aeon_cl45_write_burst(struct phy_device *phydev, unsigned int dev_addr,
+				  unsigned int phy_reg, const unsigned char *data,
+				  int size)
+{
+	unsigned short write_data = 0, i = 0;
+
+	for (i = 0; i < size; i += 2) {
+		write_data = (data[i + 1] << 8) | data[i];
+		phy_write_mmd(phydev, dev_addr, phy_reg, write_data);
+	}
+}
+
 static int aeon_firmware_boot(struct phy_device *phydev, const u8 *data,
 			      size_t size)
 {
@@ -349,6 +459,87 @@ static int aeon_firmware_boot(struct phy_device *phydev, const u8 *data,
 			      VEND1_GLB_CPU_CTRL_MASK, AEON_CPU_CTRL_FW_START);
 }
 
+static int aeon_set_default_value(struct phy_device *phydev)
+{
+	static const unsigned char base_data[] = {0x32, 0x30, 0x32, 0x33, 0x30, 0x37, 0x31, 0x34};
+	unsigned char bytebuf[16];
+	unsigned short *wdata;
+	unsigned int mask;
+	int byte_count, wdata_count = 0;
+	int pos = 0, val, ret = 0, remaining;
+	unsigned char padded_bytes[MEM_WORD_SIZE] = {0};
+
+	mask = param1 | 14;
+	memcpy(bytebuf, base_data, sizeof(base_data));
+	bytebuf[8] = mask & 0xff;
+	bytebuf[9] = (mask >> 8) & 0xff;
+	byte_count = 10;
+
+	wdata = kmalloc(MAX_WDATA_SIZE * sizeof(unsigned short), GFP_KERNEL);
+	if (!wdata) {
+		pr_err("Failed to allocate wdata array\n");
+		return -ENOMEM;
+	}
+
+	while (pos + MEM_WORD_SIZE <= byte_count) {
+		if (wdata_count + 2 > MAX_WDATA_SIZE) {
+			pr_err("wdata array overflow\n");
+			ret = -ENOSPC;
+			goto cleanup;
+		}
+
+		wdata[wdata_count++] = le16_to_cpu(*(unsigned short *)&bytebuf[pos]);
+		wdata[wdata_count++] = le16_to_cpu(*(unsigned short *)&bytebuf[pos + 2]);
+
+		pos += MEM_WORD_SIZE;
+	}
+
+	remaining = byte_count - pos;
+	if (remaining > 0) {
+		if (wdata_count + 2 <= MAX_WDATA_SIZE) {
+			// Here we just need padded_bytes once, otherwise we need to read from mem
+			memcpy(padded_bytes, &bytebuf[pos], remaining);
+
+			wdata[wdata_count++] = le16_to_cpu(*(unsigned short *)&padded_bytes[0]);
+			wdata[wdata_count++] = le16_to_cpu(*(unsigned short *)&padded_bytes[2]);
+		}
+	}
+
+	val = aeon_cl45_read(phydev, MDIO_MMD_VEND1, VEND1_GLB_REG_CPU_CTRL); //GLB_REG_CPU_CTRL
+	val |= 0x12;
+	phy_write_mmd(phydev, MDIO_MMD_VEND1, VEND1_GLB_REG_CPU_CTRL, val);
+
+	phy_write_mmd(phydev, MDIO_MMD_VEND1, VEND1_FW_START_ADDR,
+			(u16)(AEON_MEM_DEFAULT_ADDR & 0xFFFF));
+
+	phy_modify_mmd(phydev, MDIO_MMD_VEND1,
+			VEND1_GLB_REG_MDIO_INDIRECT_ADDRCMD,
+			0x3ffc, 0xc000);
+
+	aeon_cl45_write_burst(phydev, MDIO_MMD_VEND1, VEND1_GLB_REG_MDIO_INDIRECT_LOAD,
+			(unsigned char *)wdata, wdata_count*2);
+
+	val = phy_read_mmd(phydev, MDIO_MMD_VEND1,
+			VEND1_GLB_REG_MDIO_INDIRECT_ADDRCMD); //GLB_REG_MDIO_INDIRECT_ADDRCMD
+	val &= 0x3FFF;
+	phy_write_mmd(phydev, MDIO_MMD_VEND1, VEND1_GLB_REG_MDIO_INDIRECT_ADDRCMD, val);
+
+	val = phy_read_mmd(phydev, MDIO_MMD_VEND1, VEND1_GLB_REG_CPU_CTRL); //GLB_REG_CPU_CTRL
+	val &= 0xFFED;
+	phy_write_mmd(phydev, MDIO_MMD_VEND1, VEND1_GLB_REG_CPU_CTRL, val);
+
+cleanup:
+	kfree(wdata);
+	return 0;
+}
+
+static void aeon_set_fast_mdc_timing(struct phy_device *phydev)
+{
+	phy_write_mmd(phydev, MDIO_MMD_VEND1, 0x53, 0xFFFF);
+	phy_write_mmd(phydev, MDIO_MMD_VEND1, 0x54, 0xFFFF);
+	phy_write_mmd(phydev, MDIO_MMD_VEND1, 0x55, 0xFFFF);
+}
+
 static int aeon_firmware_load(struct phy_device *phydev)
 {
 	struct device *dev = &phydev->mdio.dev;
@@ -375,39 +566,13 @@ static int aeon_firmware_load(struct phy_device *phydev)
 	return ret;
 }
 
-static bool aeon_ipc_ready(u16 val, bool parity_status)
-{
-	u16 status;
-
-	if (FIELD_GET(AEON_IPC_STS_PARITY, val) != parity_status)
-		return false;
-
-	status = val & AEON_IPC_STS_STATUS;
-
-	return status != AEON_IPC_STS_STATUS_RCVD &&
-	       status != AEON_IPC_STS_STATUS_PROCESS &&
-	       status != AEON_IPC_STS_STATUS_BUSY;
-}
-
-static int aeon_ipc_wait_cmd(struct phy_device *phydev, bool parity_status)
-{
-	u16 val;
-
-	/* Exit condition logic:
-	 * - Wait for parity bit equal
-	 * - Wait for status success, error OR ready
-	 */
-	return phy_read_mmd_poll_timeout(phydev, MDIO_MMD_VEND1, VEND1_IPC_STS, val,
-					 aeon_ipc_ready(val, parity_status),
-					 AEON_IPC_DELAY, AEON_IPC_TIMEOUT, false);
-}
-
 static int aeon_ipc_send_cmd(struct phy_device *phydev,
 			     struct as21xxx_priv *priv,
 			     u16 cmd, u16 *ret_sts)
 {
 	bool curr_parity;
 	int ret;
+	unsigned int val;
 
 	/* The IPC sync by using a single parity bit.
 	 * Each CMD have alternately this bit set or clear
@@ -433,32 +598,38 @@ static int aeon_ipc_send_cmd(struct phy_device *phydev,
 	if (!ret_sts)
 		return 0;
 
-	ret = aeon_ipc_wait_cmd(phydev, curr_parity);
-	if (ret)
-		return ret;
+	/* Exit condition logic:
+	 * - Wait for parity bit equal
+	 * - Wait for status success, error OR ready
+	 */
+	ret = read_poll_timeout(phy_read_mmd, val,
+				(FIELD_GET(AEON_IPC_STS_PARITY, val) == curr_parity &&
+				(val & AEON_IPC_STS_STATUS) != AEON_IPC_STS_STATUS_RCVD &&
+				(val & AEON_IPC_STS_STATUS) != AEON_IPC_STS_STATUS_PROCESS &&
+				(val & AEON_IPC_STS_STATUS) != AEON_IPC_STS_STATUS_BUSY) ||
+				(val < 0),
+				10000, 2000000, false,
+				phydev, MDIO_MMD_VEND1, VEND1_IPC_STS);
 
-	ret = phy_read_mmd(phydev, MDIO_MMD_VEND1, VEND1_IPC_STS);
-	if (ret < 0)
-		return ret;
+	if (val < 0)
+		ret = val;
+
+	if (ret)
+		phydev_err(phydev, "%s fail to polling status failed: %d\n", __func__, ret);
 
-	*ret_sts = ret;
-	if ((*ret_sts & AEON_IPC_STS_STATUS) != AEON_IPC_STS_STATUS_SUCCESS)
+	*ret_sts = val;
+	if ((val & AEON_IPC_STS_STATUS) != AEON_IPC_STS_STATUS_SUCCESS)
 		return -EINVAL;
 
 	return 0;
 }
 
-/* If data is NULL, return 0 or negative error.
- * If data not NULL, return number of Bytes received from IPC or
- * a negative error.
- */
 static int aeon_ipc_send_msg(struct phy_device *phydev,
 			     u16 opcode, u16 *data, unsigned int data_len,
-			     u16 *ret_data)
+			     u16 *ret_sts)
 {
 	struct as21xxx_priv *priv = phydev->priv;
-	unsigned int ret_size;
-	u16 cmd, ret_sts;
+	u16 cmd;
 	int ret;
 	int i;
 
@@ -468,55 +639,56 @@ static int aeon_ipc_send_msg(struct phy_device *phydev,
 	if (data_len > AEON_IPC_DATA_MAX)
 		return -EINVAL;
 
+	mutex_lock(&priv->ipc_lock);
+
 	for (i = 0; i < data_len / sizeof(u16); i++)
 		phy_write_mmd(phydev, MDIO_MMD_VEND1, VEND1_IPC_DATA(i),
 			      data[i]);
 
 	cmd = FIELD_PREP(AEON_IPC_CMD_SIZE, data_len) |
 	      FIELD_PREP(AEON_IPC_CMD_OPCODE, opcode);
-
-	mutex_lock(&priv->ipc_lock);
-
-	ret = aeon_ipc_send_cmd(phydev, priv, cmd, &ret_sts);
-	if (ret) {
+	ret = aeon_ipc_send_cmd(phydev, priv, cmd, ret_sts);
+	if (ret)
 		phydev_err(phydev, "failed to send ipc msg for %x: %d\n",
 			   opcode, ret);
-		goto out;
-	}
 
-	if (!data)
-		goto out;
+	mutex_unlock(&priv->ipc_lock);
 
-	if ((ret_sts & AEON_IPC_STS_STATUS) == AEON_IPC_STS_STATUS_ERROR) {
-		ret = -EINVAL;
-		goto out;
-	}
+	return ret;
+}
 
-	/* Prevent IPC from stack smashing the kernel.
-	 * We can't trust IPC to return a good value and we always
-	 * preallocate space for 16 Bytes.
-	 */
-	ret_size = FIELD_GET(AEON_IPC_STS_SIZE, ret_sts);
-	if (ret_size > AEON_IPC_DATA_MAX) {
-		ret = -EINVAL;
-		goto out;
-	}
+static int aeon_ipc_rcv_msg(struct phy_device *phydev,
+			    u16 ret_sts, u16 *data)
+{
+	struct as21xxx_priv *priv = phydev->priv;
+	unsigned int size;
+	int ret;
+	int i;
+
+	if ((ret_sts & AEON_IPC_STS_STATUS) == AEON_IPC_STS_STATUS_ERROR)
+		return -EINVAL;
+
+	/* Prevent IPC from stack smashing the kernel */
+	size = FIELD_GET(AEON_IPC_STS_SIZE, ret_sts);
+	if (size > AEON_IPC_DATA_MAX)
+		return -EINVAL;
 
-	/* Read data from IPC data register for ret_size value from IPC */
-	for (i = 0; i < DIV_ROUND_UP(ret_size, sizeof(u16)); i++) {
+	mutex_lock(&priv->ipc_lock);
+
+	for (i = 0; i < DIV_ROUND_UP(size, sizeof(u16)); i++) {
 		ret = phy_read_mmd(phydev, MDIO_MMD_VEND1, VEND1_IPC_DATA(i));
-		if (ret < 0)
+		if (ret < 0) {
+			size = ret;
 			goto out;
+		}
 
-		ret_data[i] = ret;
+		data[i] = ret;
 	}
 
-	ret = ret_size;
-
 out:
 	mutex_unlock(&priv->ipc_lock);
 
-	return ret;
+	return size;
 }
 
 static int aeon_ipc_noop(struct phy_device *phydev,
@@ -570,21 +742,20 @@ static int aeon_ipc_sync_parity(struct phy_device *phydev,
 static int aeon_ipc_get_fw_version(struct phy_device *phydev)
 {
 	u16 ret_data[AEON_IPC_DATA_NUM_REGISTERS], data[1];
-	char fw_version[AEON_IPC_DATA_MAX + 1];
+	u16 ret_sts;
 	int ret;
 
 	data[0] = IPC_INFO_VERSION;
-
 	ret = aeon_ipc_send_msg(phydev, IPC_CMD_INFO, data,
-				sizeof(data), ret_data);
-	if (ret < 0)
+				sizeof(data), &ret_sts);
+	if (ret)
 		return ret;
 
-	/* Make sure FW version is NULL terminated */
-	memcpy(fw_version, ret_data, ret);
-	fw_version[ret] = '\0';
+	ret = aeon_ipc_rcv_msg(phydev, ret_sts, ret_data);
+	if (ret < 0)
+		return ret;
 
-	phydev_info(phydev, "Firmware Version: %s\n", fw_version);
+	phydev_info(phydev, "Firmware Version: %s\n", (char *)ret_data);
 
 	return 0;
 }
@@ -592,12 +763,42 @@ static int aeon_ipc_get_fw_version(struct phy_device *phydev)
 static int aeon_dpc_ra_enable(struct phy_device *phydev)
 {
 	u16 data[2];
+	u16 ret_sts;
 
 	data[0] = IPC_CFG_PARAM_DIRECT;
 	data[1] = IPC_CFG_PARAM_DIRECT_DPC_RA;
 
 	return aeon_ipc_send_msg(phydev, IPC_CMD_CFG_PARAM, data,
-				 sizeof(data), NULL);
+				 sizeof(data), &ret_sts);
+}
+
+static int as21xxx_get_features(struct phy_device *phydev)
+{
+	int ret;
+
+	ret = genphy_c45_pma_read_abilities(phydev);
+	if (ret)
+		return ret;
+
+	/* AS21xxx supports 100M/1G/2.5G/5G/10G speed. */
+	linkmode_clear_bit(ETHTOOL_LINK_MODE_10baseT_Half_BIT,
+			   phydev->supported);
+	linkmode_clear_bit(ETHTOOL_LINK_MODE_10baseT_Full_BIT,
+			   phydev->supported);
+	linkmode_clear_bit(ETHTOOL_LINK_MODE_100baseT_Half_BIT,
+			   phydev->supported);
+	linkmode_set_bit(ETHTOOL_LINK_MODE_100baseT_Full_BIT,
+			 phydev->supported);
+	linkmode_set_bit(ETHTOOL_LINK_MODE_1000baseT_Full_BIT,
+			 phydev->supported);
+	linkmode_set_bit(ETHTOOL_LINK_MODE_2500baseT_Full_BIT,
+			 phydev->supported);
+	linkmode_set_bit(ETHTOOL_LINK_MODE_5000baseT_Full_BIT,
+			 phydev->supported);
+	linkmode_set_bit(ETHTOOL_LINK_MODE_10000baseT_Full_BIT,
+			 phydev->supported);
+
+	return 0;
 }
 
 static int as21xxx_probe(struct phy_device *phydev)
@@ -611,8 +812,14 @@ static int as21xxx_probe(struct phy_device *phydev)
 		return -ENOMEM;
 	phydev->priv = priv;
 
-	ret = devm_mutex_init(&phydev->mdio.dev,
-			      &priv->ipc_lock);
+	if (param1) {
+		aeon_set_fast_mdc_timing(phydev);
+		aeon_set_default_value(phydev);
+	}
+
+	ret = aeon_firmware_load(phydev);
+
+	mutex_init(&priv->ipc_lock);
 	if (ret)
 		return ret;
 
@@ -624,84 +831,178 @@ static int as21xxx_probe(struct phy_device *phydev)
 	if (ret)
 		return ret;
 
+	ret = as21xxx_debugfs_init(phydev);
+	if (ret)
+		return ret;
+
 	/* Enable PTP clk if not already Enabled */
 	ret = phy_set_bits_mmd(phydev, MDIO_MMD_VEND1, VEND1_PTP_CLK,
 			       VEND1_PTP_CLK_EN);
 	if (ret)
 		return ret;
 
-	return aeon_dpc_ra_enable(phydev);
+	return 0;
 }
 
-static int as21xxx_read_link(struct phy_device *phydev, int *bmcr)
+static int aeon_update_link(struct phy_device *phydev)
 {
-	int status;
+	int status = 0, bmcr;
+	bool link_up;
+
+	bmcr = phy_read_mmd(phydev, MDIO_MMD_AN, AS21XXX_MDIO_AN_C22 + MII_BMCR);
+	if (bmcr < 0)
+		return bmcr;
 
-	/* Normal C22 BMCR report inconsistent data, use
-	 * the mapped C22 in C45 to have more consistent link info.
+	/* Autoneg is being started, therefore disregard BMSR value and
+	 * report link as down.
 	 */
-	*bmcr = phy_read_mmd(phydev, MDIO_MMD_AN,
-			     AS21XXX_MDIO_AN_C22 + MII_BMCR);
-	if (*bmcr < 0)
-		return *bmcr;
+	if (bmcr & BMCR_ANRESTART)
+		goto done;
 
-	/* Autoneg is being started, therefore disregard current
-	 * link status and report link as down.
+	/* The link state is latched low so that momentary link
+	 * drops can be detected. Do not double-read the status
+	 * in polling mode to detect such short link drops.
 	 */
-	if (*bmcr & BMCR_ANRESTART) {
-		phydev->link = 0;
-		return 0;
+	if (!phy_polling_mode(phydev)) {
+		status = phy_read_mmd(phydev, MDIO_MMD_AN, AN_STATES1_ADDR);
+		if (status < 0)
+			return status;
+		else if (status & AN_STATES1_ARB_MASK)
+			goto done;
 	}
 
-	status = phy_read_mmd(phydev, MDIO_MMD_AN, MDIO_STAT1);
+	/* Read link and autonegotiation status */
+	status = phy_read_mmd(phydev, MDIO_MMD_AN, AN_STATES1_ADDR);
 	if (status < 0)
 		return status;
+done:
+	link_up = ((status & AN_STATES1_ARB_MASK) >> AN_STATES1_ARB_OFST) == LINK_GOOD;
+	phydev->link = link_up;
+	phydev->autoneg_complete = link_up;
 
-	phydev->link = !!(status & MDIO_STAT1_LSTATUS);
+	/* Consider the case that autoneg was started and "aneg complete"
+	 * bit has been reset, but "link up" bit not yet.
+	 */
+	if (phydev->autoneg == AUTONEG_ENABLE && !phydev->autoneg_complete)
+		phydev->link = 0;
 
 	return 0;
 }
 
-static int as21xxx_read_c22_lpa(struct phy_device *phydev)
+static int aeon_read_lpa(struct phy_device *phydev)
 {
-	int lpagb;
+	int lpa, lpagb;
 
-	/* MII_STAT1000 are only filled in the mapped C22
-	 * in C45, use that to fill lpagb values and check.
-	 */
-	lpagb = phy_read_mmd(phydev, MDIO_MMD_AN,
-			     AS21XXX_MDIO_AN_C22 + MII_STAT1000);
-	if (lpagb < 0)
-		return lpagb;
+	if (phydev->autoneg == AUTONEG_ENABLE) {
+		if (!phydev->autoneg_complete) {
+			mii_stat1000_mod_linkmode_lpa_t(phydev->lp_advertising,
+							0);
+			mii_lpa_mod_linkmode_lpa_t(phydev->lp_advertising, 0);
+			return 0;
+		}
+
+		if (phydev->is_gigabit_capable) {
+			lpagb = phy_read_mmd(phydev, MDIO_MMD_AN,
+					     AS21XXX_MDIO_AN_C22 + MII_STAT1000);
+			if (lpagb < 0)
+				return lpagb;
+
+			if (lpagb & LPA_1000MSFAIL) {
+				int adv = phy_read_mmd(phydev, MDIO_MMD_AN,
+						       AS21XXX_MDIO_AN_C22 + MII_CTRL1000);
+
+				if (adv < 0)
+					return adv;
+
+				if (adv & CTL1000_ENABLE_MASTER)
+					phydev_err(phydev,
+						"Master/Slave resolution failed, maybe conflicting manual settings?\n");
+				else
+					phydev_err(phydev,
+						"Master/Slave resolution failed\n");
+				return -ENOLINK;
+			}
+
+			mii_stat1000_mod_linkmode_lpa_t(phydev->lp_advertising,
+							lpagb);
+		}
 
-	if (lpagb & LPA_1000MSFAIL) {
-		int adv = phy_read_mmd(phydev, MDIO_MMD_AN,
-				       AS21XXX_MDIO_AN_C22 + MII_CTRL1000);
+		lpa = phy_read_mmd(phydev, MDIO_MMD_AN, AS21XXX_MDIO_AN_C22 + MII_LPA);
+		if (lpa < 0)
+			return lpa;
 
-		if (adv < 0)
-			return adv;
+		mii_lpa_mod_linkmode_lpa_t(phydev->lp_advertising, lpa);
 
-		if (adv & CTL1000_ENABLE_MASTER)
-			phydev_err(phydev, "Master/Slave resolution failed, maybe conflicting manual settings?\n");
+		/* Read the link partner's 10G advertisment */
+		lpa = aeon_cl45_read(phydev, MDIO_MMD_AN, MDIO_AN_10GBT_STAT);
+		if (lpa < 0)
+			return lpa;
+
+		mii_10gbt_stat_mod_linkmode_lpa_t(phydev->lp_advertising, lpa);
+	} else {
+		linkmode_zero(phydev->lp_advertising);
+	}
+
+	return 0;
+}
+
+static void aeon_read_speed(struct phy_device *phydev)
+{
+	int bmcr, speed;
+
+	bmcr = phy_read_mmd(phydev, MDIO_MMD_AN, AS21XXX_MDIO_AN_C22 + MII_BMCR);
+	if (bmcr < 0)
+		return;
+
+	speed = phy_read_mmd(phydev, MDIO_MMD_VEND1, VEND1_SPEED_STATUS);
+	if (speed < 0)
+		return;
+
+	speed &= 0xff;
+	if (speed == 0x3) {
+		phydev->speed = SPEED_10000;
+		phydev->duplex = DUPLEX_FULL;
+	} else if (speed == 0x5) {
+		phydev->speed = SPEED_5000;
+		phydev->duplex = DUPLEX_FULL;
+	} else if (speed == 0x9) {
+		phydev->speed = SPEED_2500;
+		phydev->duplex = DUPLEX_FULL;
+	} else if (speed == 0x10) {
+		phydev->speed = SPEED_1000;
+
+		if (bmcr & BMCR_FULLDPLX)
+			phydev->duplex = DUPLEX_FULL;
+		else
+			phydev->duplex = DUPLEX_HALF;
+	} else if (speed == 0x20) {
+		phydev->speed = SPEED_100;
+		if (bmcr & BMCR_FULLDPLX)
+			phydev->duplex = DUPLEX_FULL;
 		else
-			phydev_err(phydev, "Master/Slave resolution failed\n");
-		return -ENOLINK;
+			phydev->duplex = DUPLEX_HALF;
+	} else {
+		phydev->speed = SPEED_10;
+		phydev->duplex = DUPLEX_FULL;
 	}
+}
 
-	mii_stat1000_mod_linkmode_lpa_t(phydev->lp_advertising,
-					lpagb);
+static void aeon_resolve_aneg_linkmode(struct phy_device *phydev)
+{
+	__ETHTOOL_DECLARE_LINK_MODE_MASK(common);
 
-	return 0;
+	linkmode_and(common, phydev->lp_advertising, phydev->advertising);
+	phy_resolve_aneg_pause(phydev);
 }
 
 static int as21xxx_read_status(struct phy_device *phydev)
 {
-	int bmcr, old_link = phydev->link;
-	int ret;
+	int err, old_link = phydev->link;
 
-	ret = as21xxx_read_link(phydev, &bmcr);
-	if (ret)
-		return ret;
+	/* Update the link, but return if there was an error */
+	err = aeon_update_link(phydev);
+	if (err)
+		return err;
 
 	/* why bother the PHY if nothing can have changed */
 	if (phydev->autoneg == AUTONEG_ENABLE && old_link && phydev->link)
@@ -712,57 +1013,15 @@ static int as21xxx_read_status(struct phy_device *phydev)
 	phydev->pause = 0;
 	phydev->asym_pause = 0;
 
-	if (phydev->autoneg == AUTONEG_ENABLE) {
-		ret = genphy_c45_read_lpa(phydev);
-		if (ret)
-			return ret;
-
-		ret = as21xxx_read_c22_lpa(phydev);
-		if (ret)
-			return ret;
-
-		phy_resolve_aneg_linkmode(phydev);
-	} else {
-		int speed;
-
-		linkmode_zero(phydev->lp_advertising);
-
-		speed = phy_read_mmd(phydev, MDIO_MMD_VEND1,
-				     VEND1_SPEED_STATUS);
-		if (speed < 0)
-			return speed;
+	err = aeon_read_lpa(phydev);
+	if (err < 0)
+		return err;
 
-		switch (speed & VEND1_SPEED_STATUS) {
-		case VEND1_SPEED_10000:
-			phydev->speed = SPEED_10000;
-			phydev->duplex = DUPLEX_FULL;
-			break;
-		case VEND1_SPEED_5000:
-			phydev->speed = SPEED_5000;
-			phydev->duplex = DUPLEX_FULL;
-			break;
-		case VEND1_SPEED_2500:
-			phydev->speed = SPEED_2500;
-			phydev->duplex = DUPLEX_FULL;
-			break;
-		case VEND1_SPEED_1000:
-			phydev->speed = SPEED_1000;
-			if (bmcr & BMCR_FULLDPLX)
-				phydev->duplex = DUPLEX_FULL;
-			else
-				phydev->duplex = DUPLEX_HALF;
-			break;
-		case VEND1_SPEED_100:
-			phydev->speed = SPEED_100;
-			phydev->duplex = DUPLEX_FULL;
-			break;
-		case VEND1_SPEED_10:
-			phydev->speed = SPEED_10;
-			phydev->duplex = DUPLEX_FULL;
-			break;
-		default:
-			return -EINVAL;
-		}
+	if (phydev->autoneg == AUTONEG_ENABLE && phydev->autoneg_complete) {
+		aeon_read_speed(phydev);
+		aeon_resolve_aneg_linkmode(phydev);
+	} else if (phydev->autoneg == AUTONEG_DISABLE) {
+		aeon_read_speed(phydev);
 	}
 
 	return 0;
@@ -876,69 +1135,98 @@ static int as21xxx_led_polarity_set(struct phy_device *phydev, int index,
 			      mask, val);
 }
 
-static int as21xxx_match_phy_device(struct phy_device *phydev,
-				    const struct phy_driver *phydrv)
+static int aeon_read_pid(struct phy_device *phydev)
 {
-	struct as21xxx_priv *priv;
-	u16 ret_sts;
-	u32 phy_id;
-	int ret;
+	int pid1 = 0, pid2 = 0, pid = 0;
 
-	/* Skip PHY that are not AS21xxx or already have firmware loaded */
-	if (phydev->c45_ids.device_ids[MDIO_MMD_PCS] != PHY_ID_AS21XXX)
-		return genphy_match_phy_device(phydev, (struct phy_driver *)phydrv);
+	pid1 = aeon_cl45_read(phydev, MDIO_MMD_PMAPMD, 2);
+	if (pid1 < 0)
+		return pid1;
+	pid2 = aeon_cl45_read(phydev, MDIO_MMD_PMAPMD, 3);
+	if (pid2 < 0)
+		return pid2;
+	phydev_dbg(phydev, "%s aeonsemi PHY = %x - %x\n", __func__, pid1, pid2);
 
-	/* Read PHY ID to handle firmware just loaded */
-	ret = phy_read_mmd(phydev, MDIO_MMD_PCS, MII_PHYSID1);
-	if (ret < 0)
-		return ret;
-	phy_id = ret << 16;
+	pid = ((pid1 & 0xffff) << 16) | (pid2 & 0xffff);
+
+	return pid;
+}
+
+static int as21xxx_config_led(struct phy_device *phydev)
+{
+	int ret;
 
-	ret = phy_read_mmd(phydev, MDIO_MMD_PCS, MII_PHYSID2);
+	/* LED0 */
+	ret = as21xxx_led_hw_control_set(phydev, 0,
+					 BIT(TRIGGER_NETDEV_LINK));
 	if (ret < 0)
 		return ret;
-	phy_id |= ret;
 
-	/* With PHY ID not the generic AS21xxx one assume
-	 * the firmware just loaded
-	 */
-	if (phy_id != PHY_ID_AS21XXX)
-		return phy_id == phydrv->phy_id;
+	/* LED1 */
+	return as21xxx_led_hw_control_set(phydev, 1,
+					  BIT(TRIGGER_NETDEV_LINK_10) |
+					  BIT(TRIGGER_NETDEV_LINK_100) |
+					  BIT(TRIGGER_NETDEV_LINK_1000) |
+					  BIT(TRIGGER_NETDEV_LINK_2500) |
+					  BIT(TRIGGER_NETDEV_LINK_5000) |
+					  BIT(TRIGGER_NETDEV_LINK_10000) |
+					  BIT(TRIGGER_NETDEV_TX) |
+					  BIT(TRIGGER_NETDEV_RX));
+}
 
-	/* Allocate temp priv and load the firmware */
-	priv = kzalloc(sizeof(*priv), GFP_KERNEL);
-	if (!priv)
-		return -ENOMEM;
+static int as21xxx_match_phy_device(struct phy_device *phydev,
+				    const struct phy_driver *phydrv)
+{
+	/* AEONSEMI get pid. */
+	phydev->phy_id = aeon_read_pid(phydev);
 
-	mutex_init(&priv->ipc_lock);
+	if (phydev->phy_id != PHY_ID_AS21XXX)
+		return 0;
 
-	ret = aeon_firmware_load(phydev);
-	if (ret)
-		goto out;
+	aeon_cl45_write(phydev, MDIO_MMD_VEND1, VEND1_PTP_CLK, 0x48);
 
-	/* Sync parity... */
-	ret = aeon_ipc_sync_parity(phydev, priv);
-	if (ret)
-		goto out;
+	return 1;
+}
 
-	/* ...and send a third NOOP cmd to wait for firmware finish loading */
-	ret = aeon_ipc_noop(phydev, priv, &ret_sts);
-	if (ret)
-		goto out;
+static void as21xxx_remove(struct phy_device *phydev)
+{
+	as21xxx_debugfs_remove(phydev);
+}
+
+static int aeon_wait_reset_complete(struct phy_device *phydev)
+{
+	int val;
+
+	return read_poll_timeout(aeon_ipc_get_fw_version, val,
+				 val == 0, 10000, 2000000, false, phydev);
+}
+
+static int as21xxx_config_init(struct phy_device *phydev)
+{
+	int ret = aeon_wait_reset_complete(phydev);
+
+	if (ret) {
+		aeon_cl45_write(phydev, MDIO_MMD_VEND1, VEND1_PTP_CLK, 0x48);
+		ret = aeon_firmware_load(phydev);
+		if (ret)
+			return ret;
+
+		ret = aeon_wait_reset_complete(phydev);
+		if (!ret) {
+			/* Enable PTP clk if not already Enabled */
+			ret = phy_set_bits_mmd(phydev, MDIO_MMD_VEND1, VEND1_PTP_CLK,
+					       VEND1_PTP_CLK_EN);
+			if (ret)
+				return ret;
+		} else
+			return -ENODEV;
+	}
+
+	as21xxx_config_led(phydev);
+
+	if (phydev->interface == PHY_INTERFACE_MODE_USXGMII)
+		ret = aeon_dpc_ra_enable(phydev);
 
-out:
-	mutex_destroy(&priv->ipc_lock);
-	kfree(priv);
-
-	/* Return can either be 0 or a negative error code.
-	 * Returning 0 here means THIS is NOT a suitable PHY.
-	 *
-	 * For the specific case of the generic Aeonsemi PHY ID that
-	 * needs the firmware the be loaded first to have a correct PHY ID,
-	 * this is OK as a matching PHY ID will be found right after.
-	 * This relies on the driver probe order where the first PHY driver
-	 * probed is the generic one.
-	 */
 	return ret;
 }
 
@@ -952,13 +1240,26 @@ static struct phy_driver as21xxx_drivers[] = {
 		PHY_ID_MATCH_EXACT(PHY_ID_AS21XXX),
 		.name		= "Aeonsemi AS21xxx",
 		.match_phy_device = as21xxx_match_phy_device,
+		.probe		= as21xxx_probe,
+		.remove		= as21xxx_remove,
+		.get_features	= as21xxx_get_features,
+		.read_status	= as21xxx_read_status,
+		.config_init	= as21xxx_config_init,
+		.read_mmd	= aeon_mdio_read,
+		.led_brightness_set = as21xxx_led_brightness_set,
+		.led_hw_is_supported = as21xxx_led_hw_is_supported,
+		.led_hw_control_set = as21xxx_led_hw_control_set,
+		.led_hw_control_get = as21xxx_led_hw_control_get,
+		.led_polarity_set = as21xxx_led_polarity_set,
 	},
 	{
 		PHY_ID_MATCH_EXACT(PHY_ID_AS21011JB1),
 		.name		= "Aeonsemi AS21011JB1",
 		.probe		= as21xxx_probe,
+		.remove		= as21xxx_remove,
 		.match_phy_device = as21xxx_match_phy_device,
 		.read_status	= as21xxx_read_status,
+		.get_features	= as21xxx_get_features,
 		.led_brightness_set = as21xxx_led_brightness_set,
 		.led_hw_is_supported = as21xxx_led_hw_is_supported,
 		.led_hw_control_set = as21xxx_led_hw_control_set,
@@ -969,8 +1270,10 @@ static struct phy_driver as21xxx_drivers[] = {
 		PHY_ID_MATCH_EXACT(PHY_ID_AS21011PB1),
 		.name		= "Aeonsemi AS21011PB1",
 		.probe		= as21xxx_probe,
+		.remove		= as21xxx_remove,
 		.match_phy_device = as21xxx_match_phy_device,
 		.read_status	= as21xxx_read_status,
+		.get_features	= as21xxx_get_features,
 		.led_brightness_set = as21xxx_led_brightness_set,
 		.led_hw_is_supported = as21xxx_led_hw_is_supported,
 		.led_hw_control_set = as21xxx_led_hw_control_set,
@@ -981,8 +1284,10 @@ static struct phy_driver as21xxx_drivers[] = {
 		PHY_ID_MATCH_EXACT(PHY_ID_AS21010PB1),
 		.name		= "Aeonsemi AS21010PB1",
 		.probe		= as21xxx_probe,
-		.match_phy_device = as21xxx_match_phy_device,
+		.remove		= as21xxx_remove,
+		.get_features	= as21xxx_get_features,
 		.read_status	= as21xxx_read_status,
+		.match_phy_device = as21xxx_match_phy_device,
 		.led_brightness_set = as21xxx_led_brightness_set,
 		.led_hw_is_supported = as21xxx_led_hw_is_supported,
 		.led_hw_control_set = as21xxx_led_hw_control_set,
@@ -993,7 +1298,9 @@ static struct phy_driver as21xxx_drivers[] = {
 		PHY_ID_MATCH_EXACT(PHY_ID_AS21010JB1),
 		.name		= "Aeonsemi AS21010JB1",
 		.probe		= as21xxx_probe,
+		.remove		= as21xxx_remove,
 		.match_phy_device = as21xxx_match_phy_device,
+		.get_features	= as21xxx_get_features,
 		.read_status	= as21xxx_read_status,
 		.led_brightness_set = as21xxx_led_brightness_set,
 		.led_hw_is_supported = as21xxx_led_hw_is_supported,
@@ -1005,7 +1312,9 @@ static struct phy_driver as21xxx_drivers[] = {
 		PHY_ID_MATCH_EXACT(PHY_ID_AS21210PB1),
 		.name		= "Aeonsemi AS21210PB1",
 		.probe		= as21xxx_probe,
+		.remove		= as21xxx_remove,
 		.match_phy_device = as21xxx_match_phy_device,
+		.get_features	= as21xxx_get_features,
 		.read_status	= as21xxx_read_status,
 		.led_brightness_set = as21xxx_led_brightness_set,
 		.led_hw_is_supported = as21xxx_led_hw_is_supported,
@@ -1017,7 +1326,9 @@ static struct phy_driver as21xxx_drivers[] = {
 		PHY_ID_MATCH_EXACT(PHY_ID_AS21510JB1),
 		.name		= "Aeonsemi AS21510JB1",
 		.probe		= as21xxx_probe,
+		.remove		= as21xxx_remove,
 		.match_phy_device = as21xxx_match_phy_device,
+		.get_features	= as21xxx_get_features,
 		.read_status	= as21xxx_read_status,
 		.led_brightness_set = as21xxx_led_brightness_set,
 		.led_hw_is_supported = as21xxx_led_hw_is_supported,
@@ -1029,7 +1340,9 @@ static struct phy_driver as21xxx_drivers[] = {
 		PHY_ID_MATCH_EXACT(PHY_ID_AS21510PB1),
 		.name		= "Aeonsemi AS21510PB1",
 		.probe		= as21xxx_probe,
+		.remove		= as21xxx_remove,
 		.match_phy_device = as21xxx_match_phy_device,
+		.get_features	= as21xxx_get_features,
 		.read_status	= as21xxx_read_status,
 		.led_brightness_set = as21xxx_led_brightness_set,
 		.led_hw_is_supported = as21xxx_led_hw_is_supported,
@@ -1041,7 +1354,9 @@ static struct phy_driver as21xxx_drivers[] = {
 		PHY_ID_MATCH_EXACT(PHY_ID_AS21511JB1),
 		.name		= "Aeonsemi AS21511JB1",
 		.probe		= as21xxx_probe,
+		.remove		= as21xxx_remove,
 		.match_phy_device = as21xxx_match_phy_device,
+		.get_features	= as21xxx_get_features,
 		.read_status	= as21xxx_read_status,
 		.led_brightness_set = as21xxx_led_brightness_set,
 		.led_hw_is_supported = as21xxx_led_hw_is_supported,
@@ -1053,7 +1368,9 @@ static struct phy_driver as21xxx_drivers[] = {
 		PHY_ID_MATCH_EXACT(PHY_ID_AS21210JB1),
 		.name		= "Aeonsemi AS21210JB1",
 		.probe		= as21xxx_probe,
+		.remove		= as21xxx_remove,
 		.match_phy_device = as21xxx_match_phy_device,
+		.get_features	= as21xxx_get_features,
 		.read_status	= as21xxx_read_status,
 		.led_brightness_set = as21xxx_led_brightness_set,
 		.led_hw_is_supported = as21xxx_led_hw_is_supported,
@@ -1065,7 +1382,9 @@ static struct phy_driver as21xxx_drivers[] = {
 		PHY_ID_MATCH_EXACT(PHY_ID_AS21511PB1),
 		.name		= "Aeonsemi AS21511PB1",
 		.probe		= as21xxx_probe,
+		.remove		= as21xxx_remove,
 		.match_phy_device = as21xxx_match_phy_device,
+		.get_features	= as21xxx_get_features,
 		.read_status	= as21xxx_read_status,
 		.led_brightness_set = as21xxx_led_brightness_set,
 		.led_hw_is_supported = as21xxx_led_hw_is_supported,
diff --git a/drivers/net/phy/as21xxx.h b/drivers/net/phy/as21xxx.h
new file mode 100644
index 0000000..135d849
--- /dev/null
+++ b/drivers/net/phy/as21xxx.h
@@ -0,0 +1,65 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Aeonsemi AS21XXxX PHY Driver
+ *
+ */
+
+#include "./as21xx_bbu_api/as21xx_debugfs.h"
+
+// SDS Eye Scan Parameters
+#define EYE_GRPS	31
+#define EYE_COLS_GRP	4
+#define EYE_YRES	254
+#define EYE_NSAMP	256
+#define EYE_XRES	(EYE_GRPS * EYE_COLS_GRP)
+#define EYE_STRIDE	(EYE_COLS_GRP * EYE_YRES)
+#define EYE_TOTAL_BYTES	(EYE_XRES * EYE_YRES)
+#define EYE_PART_0	0
+#define EYE_PART_1	1
+#define EYE_PART_0_GRPS	(EYE_GRPS / 2)
+#define EYE_PART_1_GRPS	(EYE_GRPS - EYE_PART_0_GRPS)
+
+struct downshift_cfg {
+	uint8_t enable;
+	uint8_t retry_limit;
+};
+
+struct an_mdi_cfg {
+	uint8_t top_spd;
+	uint8_t eee_spd;
+	uint8_t fr_spd;
+	uint8_t thp_byp;
+	uint8_t port_type;
+	uint8_t ms_en;
+	uint8_t ms_config;
+	uint8_t nstd_pbo;
+	struct downshift_cfg smt_spd;
+	uint8_t trd_ovrd;
+	uint8_t trd_swap;
+	uint8_t cfr;
+};
+
+typedef struct {
+	unsigned char tm_done : 1;
+	unsigned char tm_alarm : 1;
+	unsigned char wol_sts : 1;
+	unsigned char link_sts : 1;
+	unsigned char reserved2 : 1;
+	unsigned char reserved3 : 1;
+	unsigned char reserved4 : 1;
+	unsigned char reserved5 : 1;
+} irq_stats_t;
+
+struct as21xxx_priv {
+	bool parity_status;
+	/* Protect concurrent IPC access */
+	struct mutex ipc_lock;
+	struct an_mdi_cfg mdi_cfg;
+	struct dentry *debugfs_root;
+	unsigned char raw_eye_data[EYE_TOTAL_BYTES];
+};
+
+int aeon_cl45_read(struct phy_device *phydev, int dev_addr,
+		   unsigned int phy_reg);
+void aeon_cl45_write(struct phy_device *phydev, int dev_addr,
+		     unsigned int phy_reg, unsigned short phy_data);
-- 
2.45.2

