From 6ca5849bee7d577fc97e08d7f575b588c4157630 Mon Sep 17 00:00:00 2001
From: Jianguo Zhang <jianguo.zhang@mediatek.com>
Date: Tue, 14 Oct 2025 16:48:46 +0800
Subject: [PATCH] pcie: mediatek-gen3: Add soft off and soft on API

[Description]
Add soft off and soft on API

[Release-log]
NA

Signed-off-by: Jianguo Zhang <jianguo.zhang@mediatek.com>
---
 drivers/pci/controller/pcie-mediatek-gen3.c | 103 ++++++++++++++++++++
 1 file changed, 103 insertions(+)

diff --git a/drivers/pci/controller/pcie-mediatek-gen3.c b/drivers/pci/controller/pcie-mediatek-gen3.c
index b4d3569..108a2b6 100644
--- a/drivers/pci/controller/pcie-mediatek-gen3.c
+++ b/drivers/pci/controller/pcie-mediatek-gen3.c
@@ -135,6 +135,9 @@
 /* Time in ms needed to complete PCIe reset on EN7581 SoC */
 #define PCIE_EN7581_RESET_TIME_MS	100
 
+int mtk_pcie_soft_off(struct pci_bus *bus);
+int mtk_pcie_soft_on(struct pci_bus *bus);
+
 struct mtk_gen3_pcie;
 
 /**
@@ -212,6 +215,7 @@ struct mtk_pcie_irq {
  * @msi_sets: MSI sets information
  * @msi_group_type: PCIe controller MSI group type
  * @lock: lock protecting IRQ bit map
+ * @soft_off: PCIe soft off state
  * @msi_irq_in_use: bit map for assigned MSI IRQ
  * @soc: pointer to SoC-dependent operations
  */
@@ -240,6 +244,7 @@ struct mtk_gen3_pcie {
 	struct mtk_msi_set msi_sets[PCIE_MSI_SET_NUM];
 	enum mtk_msi_group_type msi_group_type;
 	struct mutex lock;
+	bool soft_off;
 	DECLARE_BITMAP(msi_irq_in_use, PCIE_MSI_IRQS_NUM);
 
 	const struct mtk_gen3_pcie_pdata *soc;
@@ -311,6 +316,11 @@ static void __iomem *mtk_pcie_map_bus(struct pci_bus *bus, unsigned int devfn,
 static int mtk_pcie_config_read(struct pci_bus *bus, unsigned int devfn,
 				int where, int size, u32 *val)
 {
+	struct mtk_gen3_pcie *pcie = bus->sysdata;
+
+	if (pcie->soft_off)
+		return 0;
+
 	mtk_pcie_config_tlp_header(bus, devfn, where, size);
 
 	return pci_generic_config_read32(bus, devfn, where, size, val);
@@ -319,6 +329,11 @@ static int mtk_pcie_config_read(struct pci_bus *bus, unsigned int devfn,
 static int mtk_pcie_config_write(struct pci_bus *bus, unsigned int devfn,
 				 int where, int size, u32 val)
 {
+	struct mtk_gen3_pcie *pcie = bus->sysdata;
+
+	if (pcie->soft_off)
+		return 0;
+
 	mtk_pcie_config_tlp_header(bus, devfn, where, size);
 
 	if (size <= 2)
@@ -1440,6 +1455,94 @@ static int mtk_pcie_turn_off_link(struct mtk_gen3_pcie *pcie)
 				   50 * USEC_PER_MSEC);
 }
 
+int mtk_pcie_soft_off(struct pci_bus *bus)
+{
+	struct pci_host_bridge *host;
+	struct mtk_gen3_pcie *pcie;
+	struct pci_dev *dev;
+	int ret;
+
+	if (!bus) {
+		pr_err("There is no bus, please check the host driver\n");
+		return -ENODEV;
+	}
+
+	pcie = bus->sysdata;
+	if (pcie->soft_off) {
+		dev_err(pcie->dev, "The soft_off is true, can't soft off\n");
+		return -EPERM;
+	}
+
+	host = pci_host_bridge_from_priv(pcie);
+	dev = pci_get_slot(host->bus, 0);
+	if (!dev) {
+		dev_err(pcie->dev, "Failed to get device from bus\n");
+		return -ENODEV;
+	}
+
+	/* Trigger link to L2 state */
+	ret = mtk_pcie_turn_off_link(pcie);
+
+	pci_save_state(dev);
+	pci_dev_put(dev);
+	mtk_pcie_irq_save(pcie);
+	pcie->soft_off = true;
+	mtk_pcie_power_down(pcie);
+
+	dev_info(pcie->dev, "mtk pcie soft off done\n");
+
+	return ret;
+}
+EXPORT_SYMBOL(mtk_pcie_soft_off);
+
+int mtk_pcie_soft_on(struct pci_bus *bus)
+{
+	struct pci_host_bridge *host;
+	struct mtk_gen3_pcie *pcie;
+	struct pci_dev *dev;
+	int ret;
+
+	if (!bus) {
+		pr_err("There is no bus, please check the host driver\n");
+		return -ENODEV;
+	}
+
+	pcie = bus->sysdata;
+	if (!pcie->soft_off) {
+		dev_err(pcie->dev, "The soft_off is false, can't soft on\n");
+		return -EPERM;
+	}
+
+	host = pci_host_bridge_from_priv(pcie);
+	dev = pci_get_slot(host->bus, 0);
+	if (!dev) {
+		dev_err(pcie->dev, "Failed to get device from bus\n");
+		return -ENODEV;
+	}
+
+	ret = mtk_pcie_power_up(pcie);
+	if (ret) {
+		dev_err(pcie->dev, "Failed to power up RC\n");
+		return ret;
+	}
+
+	ret = mtk_pcie_startup_port(pcie);
+	if (ret) {
+		dev_err(pcie->dev, "Failed to detect EP\n");
+		return ret;
+	}
+
+	pcie->soft_off = false;
+	mtk_pcie_irq_restore(pcie);
+	pci_restore_state(dev);
+	pci_dev_put(dev);
+
+	dev_info(pcie->dev, "mtk pcie soft on done\n");
+
+	return ret;
+}
+EXPORT_SYMBOL(mtk_pcie_soft_on);
+
 static int mtk_pcie_suspend_noirq(struct device *dev)
 {
 	struct mtk_gen3_pcie *pcie = dev_get_drvdata(dev);
-- 
2.45.2

