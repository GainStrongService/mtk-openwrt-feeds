--- a/drivers/net/phy/mediatek/mtk-2p5ge.c
+++ b/drivers/net/phy/mediatek/mtk-2p5ge.c
@@ -14,9 +14,16 @@
 
 #define MTK_2P5GPHY_ID_MT7988	(0x00339c11)
 
+#define MTK_PHY_PAGE_EXTENDED_1		0x0001
+#define MTK_PHY_AUX_CTRL_AND_STATUS	0x14
+#define   MTK_PHY_ENABLE_DOWNSHIFT	BIT(4)
+
 #define MT7988_2P5GE_PMB_FW		"mediatek/mt7988/i2p5ge-phy-pmb.bin"
 #define MT7988_2P5GE_PMB_FW_SIZE	(0x20000)
-#define MD32_EN_CFG			(0x18)
+#define MT7988_2P5GE_PMB_FW_BASE	(0x0f100000)
+#define MT7988_2P5GE_PMB_FW_LEN		(0x20000)
+#define MT7988_2P5GE_MD32_EN_CFG_BASE	(0x0f0f0018)
+#define MT7988_2P5GE_MD32_EN_CFG_LEN	(0x20)
 #define   MD32_EN			BIT(0)
 
 #define BASE100T_STATUS_EXTEND		(0x10)
@@ -27,18 +34,16 @@
 #define   PHY_AUX_DPX_MASK		GENMASK(5, 5)
 #define   PHY_AUX_SPEED_MASK		GENMASK(4, 2)
 
-/* Registers on MDIO_MMD_VEND1 */
 #define MTK_PHY_LPI_PCS_DSP_CTRL		(0x121)
 #define   MTK_PHY_LPI_SIG_EN_LO_THRESH100_MASK	GENMASK(12, 8)
 
-#define MTK_PHY_HOST_CMD1		0x800e
-#define MTK_PHY_HOST_CMD2		0x800f
 /* Registers on Token Ring debug nodes */
 /* ch_addr = 0x0, node_addr = 0xf, data_addr = 0x3c */
 #define AUTO_NP_10XEN				BIT(6)
 
 struct mtk_i2p5ge_phy_priv {
 	bool fw_loaded;
+	unsigned long led_state;
 };
 
 enum {
@@ -51,22 +56,21 @@ enum {
 static int mt798x_2p5ge_phy_load_fw(struct phy_device *phydev)
 {
 	struct mtk_i2p5ge_phy_priv *priv = phydev->priv;
-	void __iomem *mcu_csr_base, *pmb_addr;
+	void __iomem *md32_en_cfg_base, *pmb_addr;
 	struct device *dev = &phydev->mdio.dev;
 	const struct firmware *fw;
-	struct device_node *np;
 	int ret, i;
-	u32 reg;
+	u16 reg;
 
-	np = of_find_compatible_node(NULL, NULL, "mediatek,2p5gphy-fw");
-	if (!np)
-		return -ENOENT;
+	if (priv->fw_loaded)
+		return 0;
 
-	pmb_addr = of_iomap(np, 0);
+	pmb_addr = ioremap(MT7988_2P5GE_PMB_FW_BASE, MT7988_2P5GE_PMB_FW_LEN);
 	if (!pmb_addr)
 		return -ENOMEM;
-	mcu_csr_base = of_iomap(np, 1);
-	if (!mcu_csr_base) {
+	md32_en_cfg_base = ioremap(MT7988_2P5GE_MD32_EN_CFG_BASE,
+				   MT7988_2P5GE_MD32_EN_CFG_LEN);
+	if (!md32_en_cfg_base) {
 		ret = -ENOMEM;
 		goto free_pmb;
 	}
@@ -85,7 +89,7 @@ static int mt798x_2p5ge_phy_load_fw(stru
 		goto release_fw;
 	}
 
-	reg = readw(mcu_csr_base + MD32_EN_CFG);
+	reg = readw(md32_en_cfg_base);
 	if (reg & MD32_EN) {
 		phy_set_bits(phydev, MII_BMCR, BMCR_RESET);
 		usleep_range(10000, 11000);
@@ -93,33 +97,32 @@ static int mt798x_2p5ge_phy_load_fw(stru
 	phy_set_bits(phydev, MII_BMCR, BMCR_PDOWN);
 
 	/* Write magic number to safely stall MCU */
-	phy_write_mmd(phydev, MDIO_MMD_VEND1, MTK_PHY_HOST_CMD1, 0x1100);
-	phy_write_mmd(phydev, MDIO_MMD_VEND1, MTK_PHY_HOST_CMD2, 0x00df);
+	phy_write_mmd(phydev, MDIO_MMD_VEND1, 0x800e, 0x1100);
+	phy_write_mmd(phydev, MDIO_MMD_VEND1, 0x800f, 0x00df);
 
 	for (i = 0; i < MT7988_2P5GE_PMB_FW_SIZE - 1; i += 4)
 		writel(*((uint32_t *)(fw->data + i)), pmb_addr + i);
+	dev_info(dev, "Firmware date code: %x/%x/%x, version: %x.%x\n",
+		 be16_to_cpu(*((__be16 *)(fw->data +
+					  MT7988_2P5GE_PMB_FW_SIZE - 8))),
+		 *(fw->data + MT7988_2P5GE_PMB_FW_SIZE - 6),
+		 *(fw->data + MT7988_2P5GE_PMB_FW_SIZE - 5),
+		 *(fw->data + MT7988_2P5GE_PMB_FW_SIZE - 2),
+		 *(fw->data + MT7988_2P5GE_PMB_FW_SIZE - 1));
 
-	if (!priv->fw_loaded)
-		dev_info(dev, "Firmware date code: %x/%x/%x, version: %x.%x\n",
-			 be16_to_cpu(*((__be16 *)(fw->data +
-						  MT7988_2P5GE_PMB_FW_SIZE - 8))),
-			 *(fw->data + MT7988_2P5GE_PMB_FW_SIZE - 6),
-			 *(fw->data + MT7988_2P5GE_PMB_FW_SIZE - 5),
-			 *(fw->data + MT7988_2P5GE_PMB_FW_SIZE - 2),
-			 *(fw->data + MT7988_2P5GE_PMB_FW_SIZE - 1));
-
-	writew(reg & ~MD32_EN, mcu_csr_base + MD32_EN_CFG);
-	writew(reg | MD32_EN, mcu_csr_base + MD32_EN_CFG);
+	writew(reg & ~MD32_EN, md32_en_cfg_base);
+	writew(reg | MD32_EN, md32_en_cfg_base);
 	phy_set_bits(phydev, MII_BMCR, BMCR_RESET);
 	/* We need a delay here to stabilize initialization of MCU */
 	usleep_range(7000, 8000);
+	dev_info(dev, "Firmware loading/trigger ok.\n");
 
 	priv->fw_loaded = true;
 
 release_fw:
 	release_firmware(fw);
 free:
-	iounmap(mcu_csr_base);
+	iounmap(md32_en_cfg_base);
 free_pmb:
 	iounmap(pmb_addr);
 
@@ -149,7 +152,7 @@ static int mt798x_2p5ge_phy_config_init(
 
 	/* Switch pinctrl after setting polarity to avoid bogus blinking */
 	pinctrl = devm_pinctrl_get_select(&phydev->mdio.dev, "i2p5gbe-led");
-	if (IS_ERR(pinctrl) && PTR_ERR(pinctrl) != -ENODEV)
+	if (IS_ERR(pinctrl))
 		dev_err(&phydev->mdio.dev, "Fail to set LED pins!\n");
 
 	phy_modify_mmd(phydev, MDIO_MMD_VEND1, MTK_PHY_LPI_PCS_DSP_CTRL,
@@ -173,6 +176,14 @@ static int mt798x_2p5ge_phy_config_aneg(
 	u32 adv;
 	int ret;
 
+	/* In fact, if we disable autoneg, we can't link up correctly:
+	 * 2.5G/1G: Need AN to exchange master/slave information.
+	 * 100M/10M: Without AN, link starts at half duplex (According to
+	 *           IEEE 802.3-2018), which this phy doesn't support.
+	 */
+	if (phydev->autoneg == AUTONEG_DISABLE)
+		return -EOPNOTSUPP;
+
 	ret = genphy_c45_an_config_aneg(phydev);
 	if (ret < 0)
 		return ret;
@@ -189,7 +200,7 @@ static int mt798x_2p5ge_phy_config_aneg(
 	if (ret > 0)
 		changed = true;
 
-	return __genphy_config_aneg(phydev, changed);
+	return genphy_c45_check_and_restart_aneg(phydev, changed);
 }
 
 static int mt798x_2p5ge_phy_get_features(struct phy_device *phydev)
@@ -283,6 +294,82 @@ static int mt798x_2p5ge_phy_get_rate_mat
 	return RATE_MATCH_PAUSE;
 }
 
+static const unsigned long supported_triggers =
+	BIT(TRIGGER_NETDEV_FULL_DUPLEX) |
+	BIT(TRIGGER_NETDEV_LINK)        |
+	BIT(TRIGGER_NETDEV_LINK_10)     |
+	BIT(TRIGGER_NETDEV_LINK_100)    |
+	BIT(TRIGGER_NETDEV_LINK_1000)   |
+	BIT(TRIGGER_NETDEV_LINK_2500)   |
+	BIT(TRIGGER_NETDEV_RX)          |
+	BIT(TRIGGER_NETDEV_TX);
+
+static int mt798x_2p5ge_phy_led_blink_set(struct phy_device *phydev, u8 index,
+					  unsigned long *delay_on,
+					  unsigned long *delay_off)
+{
+	struct mtk_i2p5ge_phy_priv *priv = phydev->priv;
+	bool blinking = false;
+	int err = 0;
+
+	err = mtk_phy_led_num_dly_cfg(index, delay_on, delay_off, &blinking);
+	if (err < 0)
+		return err;
+
+	err = mtk_phy_hw_led_blink_set(phydev, index, &priv->led_state,
+				       blinking);
+	if (err)
+		return err;
+
+	return mtk_phy_hw_led_on_set(phydev, index, &priv->led_state,
+				     MTK_2P5GPHY_LED_ON_MASK, false);
+}
+
+static int mt798x_2p5ge_phy_led_brightness_set(struct phy_device *phydev,
+					       u8 index,
+					       enum led_brightness value)
+{
+	struct mtk_i2p5ge_phy_priv *priv = phydev->priv;
+	int err;
+
+	err = mtk_phy_hw_led_blink_set(phydev, index, &priv->led_state, false);
+	if (err)
+		return err;
+
+	return mtk_phy_hw_led_on_set(phydev, index, &priv->led_state,
+				     MTK_2P5GPHY_LED_ON_MASK,
+				     (value != LED_OFF));
+}
+
+static int mt798x_2p5ge_phy_led_hw_is_supported(struct phy_device *phydev,
+						u8 index, unsigned long rules)
+{
+	return mtk_phy_led_hw_is_supported(phydev, index, rules,
+					   supported_triggers);
+}
+
+static int mt798x_2p5ge_phy_led_hw_control_get(struct phy_device *phydev,
+					       u8 index, unsigned long *rules)
+{
+	struct mtk_i2p5ge_phy_priv *priv = phydev->priv;
+
+	return mtk_phy_led_hw_ctrl_get(phydev, index, rules, &priv->led_state,
+				       MTK_2P5GPHY_LED_ON_SET,
+				       MTK_2P5GPHY_LED_RX_BLINK_SET,
+				       MTK_2P5GPHY_LED_TX_BLINK_SET);
+};
+
+static int mt798x_2p5ge_phy_led_hw_control_set(struct phy_device *phydev,
+					       u8 index, unsigned long rules)
+{
+	struct mtk_i2p5ge_phy_priv *priv = phydev->priv;
+
+	return mtk_phy_led_hw_ctrl_set(phydev, index, rules, &priv->led_state,
+				       MTK_2P5GPHY_LED_ON_SET,
+				       MTK_2P5GPHY_LED_RX_BLINK_SET,
+				       MTK_2P5GPHY_LED_TX_BLINK_SET);
+};
+
 static int mt798x_2p5ge_phy_probe(struct phy_device *phydev)
 {
 	struct mtk_i2p5ge_phy_priv *priv;
@@ -307,6 +394,8 @@ static int mt798x_2p5ge_phy_probe(struct
 	priv->fw_loaded = false;
 	phydev->priv = priv;
 
+	mtk_phy_leds_state_init(phydev);
+
 	return 0;
 }
 
@@ -324,6 +413,11 @@ static struct phy_driver mtk_2p5gephy_dr
 		.resume = genphy_resume,
 		.read_page = mtk_phy_read_page,
 		.write_page = mtk_phy_write_page,
+		.led_blink_set = mt798x_2p5ge_phy_led_blink_set,
+		.led_brightness_set = mt798x_2p5ge_phy_led_brightness_set,
+		.led_hw_is_supported = mt798x_2p5ge_phy_led_hw_is_supported,
+		.led_hw_control_get = mt798x_2p5ge_phy_led_hw_control_get,
+		.led_hw_control_set = mt798x_2p5ge_phy_led_hw_control_set,
 	},
 };
 
