From 7b43b86f22dc7a0cae398faa50c8f724f7c0d6e4 Mon Sep 17 00:00:00 2001
From: Bo-Cun Chen <bc-bocun.chen@mediatek.com>
Date: Mon, 22 Sep 2025 11:12:10 +0800
Subject: [PATCH] net: ethernet: mtk_eth_soc: add HQoS configuration restore
 flow to SER

Since SER will reset QDMA, it means that the HQoS configurations will
be cleared. The driver needs to save the HQoS configuration before the
SER and then restore the HQoS configuration afterward.

Without this patch, the HQoS is not functioning properly following the
SER.

Signed-off-by: Bo-Cun Chen <bc-bocun.chen@mediatek.com>
---
 drivers/net/ethernet/mediatek/mtk_eth_soc.c | 50 +++++++++++++++++++++
 drivers/net/ethernet/mediatek/mtk_eth_soc.h | 19 ++++++++
 2 files changed, 69 insertions(+)

--- a/drivers/net/ethernet/mediatek/mtk_eth_soc.c
+++ b/drivers/net/ethernet/mediatek/mtk_eth_soc.c
@@ -5314,6 +5314,54 @@ static void mt7988_esw_force_link(struct
 	__raw_writel(val, eth->esw_base + MT753X_PMCR_P(6));
 }
 
+static void mtk_save_qdma_cfg(struct mtk_eth *eth)
+{
+	const struct mtk_reg_map *reg_map = eth->soc->reg_map;
+	struct mtk_qdma_params *params = &eth->qdma_params;
+	int i;
+
+	for (i = 0; i < MTK_QDMA_NUM_QUEUES; i++) {
+		mtk_w32(eth, (i / MTK_QTX_PER_PAGE), reg_map->qdma.page);
+
+		params->qtx_cfg[i] =
+			mtk_r32(eth, reg_map->qdma.qtx_cfg +
+				(i % MTK_QTX_PER_PAGE) * MTK_QTX_OFFSET);
+		params->qtx_sch[i] =
+			mtk_r32(eth, reg_map->qdma.qtx_sch +
+				(i % MTK_QTX_PER_PAGE) * MTK_QTX_OFFSET);
+	}
+	mtk_w32(eth, 0, reg_map->qdma.page);
+
+	params->tx_sch[0] = mtk_r32(eth, reg_map->qdma.tx_sch_rate);
+	if (mtk_is_netsys_v2_or_greater(eth))
+		params->tx_sch[1] =
+			mtk_r32(eth, reg_map->qdma.tx_sch_rate + 0x4);
+}
+
+static void mtk_restore_qdma_cfg(struct mtk_eth *eth)
+{
+	const struct mtk_reg_map *reg_map = eth->soc->reg_map;
+	struct mtk_qdma_params *params = &eth->qdma_params;
+	int i;
+
+	for (i = 0; i < MTK_QDMA_NUM_QUEUES; i++) {
+		mtk_w32(eth, (i / MTK_QTX_PER_PAGE), reg_map->qdma.page);
+
+		mtk_w32(eth, params->qtx_cfg[i],
+			reg_map->qdma.qtx_cfg +
+			(i % MTK_QTX_PER_PAGE) * MTK_QTX_OFFSET);
+		mtk_w32(eth, params->qtx_sch[i],
+			reg_map->qdma.qtx_sch +
+			(i % MTK_QTX_PER_PAGE) * MTK_QTX_OFFSET);
+	}
+	mtk_w32(eth, 0, reg_map->qdma.page);
+
+	mtk_w32(eth, params->tx_sch[0], reg_map->qdma.tx_sch_rate);
+	if (mtk_is_netsys_v2_or_greater(eth))
+		mtk_w32(eth, params->tx_sch[1],
+			reg_map->qdma.tx_sch_rate + 0x4);
+}
+
 static void mtk_prepare_for_reset(struct mtk_eth *eth)
 {
 	struct mtk_mac *mac;
@@ -5366,6 +5414,7 @@ static void mtk_pending_work(struct work
 
 	mtk_hw_dump_all(eth);
 
+	mtk_save_qdma_cfg(eth);
 	mtk_prepare_for_reset(eth);
 	mtk_wed_fe_reset();
 	/* Run again reset preliminary configuration in order to avoid any
@@ -5409,6 +5458,7 @@ static void mtk_pending_work(struct work
 	clear_bit(MTK_RESETTING, &eth->state);
 
 	mtk_wed_fe_reset_complete();
+	mtk_restore_qdma_cfg(eth);
 
 	rtnl_unlock();
 }
--- a/drivers/net/ethernet/mediatek/mtk_eth_soc.h
+++ b/drivers/net/ethernet/mediatek/mtk_eth_soc.h
@@ -336,6 +336,9 @@
 #define MTK_QTX_SCH_MAX_RATE_MAN_V3	GENMASK(9, 3)
 #define MTK_QTX_SCH_MAX_RATE_EXP_V3	GENMASK(2, 0)
 
+/* QDMA Page Configuration Register */
+#define MTK_QTX_PER_PAGE	(16)
+
 /* QDMA TX Scheduler Rate Control Register */
 #define MTK_QDMA_TX_SCH_MAX_WFQ		BIT(15)
 
@@ -1165,6 +1168,21 @@ struct mtk_napi {
 	struct mtk_rx_ring	*rx_ring;
 };
 
+/* struct mtk_qdma_params -	This is the structure holding parameters
+				for the HQoS
+ * @qtx_cfg:			The elements are used to record the
+				reserved buffer for the Tx Queue
+ * @qtx_sch:			The elements are used to record the
+				rate control for the Tx Queue
+ * @tx_sch:			The elements are used to record the
+				rate control for the Tx Scheduler
+ */
+struct mtk_qdma_params {
+	u32	qtx_cfg[MTK_QDMA_NUM_QUEUES];
+	u32	qtx_sch[MTK_QDMA_NUM_QUEUES];
+	u32	tx_sch[2];
+};
+
 enum mkt_eth_capabilities {
 	MTK_RGMII_BIT = 0,
 	MTK_TRGMII_BIT,
@@ -1572,6 +1590,7 @@ struct mtk_eth {
 	struct napi_struct		tx_napi;
 	struct mtk_napi			rx_napi[MTK_RX_NAPI_NUM];
 	struct mtk_rss_params		rss_params;
+	struct mtk_qdma_params		qdma_params;
 	void				*scratch_ring;
 	dma_addr_t			phy_scratch_ring;
 	void				*scratch_head[MTK_FQ_DMA_HEAD];
