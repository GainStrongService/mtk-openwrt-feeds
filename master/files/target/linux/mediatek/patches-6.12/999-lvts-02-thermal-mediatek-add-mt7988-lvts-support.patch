From a057c83da81212944c7efb85b0529c008581be27 Mon Sep 17 00:00:00 2001
From: Mason Chang <mason-cw.chang@mediatek.com>
Date: Thu, 18 Sep 2025 20:04:00 +0800
Subject: [PATCH] thermal: mediatek: add mt7988 lvts support

Without this patch, unexpected LVTS hardware behavior may occur.
---
 drivers/thermal/mediatek/lvts_thermal.c | 124 ++++++++++++++++++++----
 1 file changed, 107 insertions(+), 17 deletions(-)

diff --git a/drivers/thermal/mediatek/lvts_thermal.c b/drivers/thermal/mediatek/lvts_thermal.c
index f4d1e66..eb78871 100644
--- a/drivers/thermal/mediatek/lvts_thermal.c
+++ b/drivers/thermal/mediatek/lvts_thermal.c
@@ -58,11 +58,11 @@
 #define LVTS_PROTTC(__base)		(__base + 0x00CC)
 #define LVTS_CLKEN(__base)		(__base + 0x00E4)
 
-#define LVTS_PERIOD_UNIT			0
-#define LVTS_GROUP_INTERVAL			0
-#define LVTS_FILTER_INTERVAL		0
-#define LVTS_SENSOR_INTERVAL		0
-#define LVTS_HW_FILTER				0x0
+#define LVTS_PERIOD_UNIT			0xc
+#define LVTS_GROUP_INTERVAL			0x1
+#define LVTS_FILTER_INTERVAL			0x1
+#define LVTS_SENSOR_INTERVAL			0x1
+#define LVTS_HW_FILTER				0x5
 #define LVTS_TSSEL_CONF				0x13121110
 #define LVTS_CALSCALE_CONF			0x300
 
@@ -83,6 +83,7 @@
 #define LVTS_SENSOR_MAX				4
 #define LVTS_GOLDEN_TEMP_MAX		62
 #define LVTS_GOLDEN_TEMP_DEFAULT	50
+#define LVTS_GOLDEN_TEMP_MT7988		60
 #define LVTS_COEFF_A_MT8195			-250460
 #define LVTS_COEFF_B_MT8195			250460
 #define LVTS_COEFF_A_MT7988			-204650
@@ -91,8 +92,12 @@
 #define LVTS_MSR_IMMEDIATE_MODE		0
 #define LVTS_MSR_FILTERED_MODE		1
 
-#define LVTS_MSR_READ_TIMEOUT_US	400
+#define LVTS_MSR_READ_TIMEOUT_US	3000
 #define LVTS_MSR_READ_WAIT_US		(LVTS_MSR_READ_TIMEOUT_US / 2)
+#define LVTS_BUS_IDLE_TIMEOUT_US	200
+#define LVTS_BUS_IDLE_WAIT_US		2
+
+#define LVTS_HW_RESET_TEMP		125000
 
 #define LVTS_MINIMUM_THRESHOLD		20000
 
@@ -132,8 +137,10 @@ struct lvts_data {
 	int num_init_cmd;
 	int temp_factor;
 	int temp_offset;
+	int golden_temp;
 	int gt_calib_bit_offset;
 	unsigned int def_calibration;
+	bool irq_enable;
 };
 
 struct lvts_sensor {
@@ -150,6 +157,7 @@ struct lvts_ctrl {
 	struct lvts_sensor sensors[LVTS_SENSOR_MAX];
 	const struct lvts_data *lvts_data;
 	u32 calibration[LVTS_SENSOR_MAX];
+	u32 hw_reset_raw_temp;
 	u8 valid_sensor_mask;
 	int mode;
 	void __iomem *base;
@@ -410,6 +418,9 @@ static int lvts_set_trips(struct thermal_zone_device *tz, int low, int high)
 	}
 	lvts_update_irq_mask(lvts_ctrl);
 
+	if (!lvts_data->irq_enable)
+		return 0;
+
 	if (!should_update_thresh)
 		return 0;
 
@@ -804,8 +815,10 @@ static int lvts_golden_temp_init(struct device *dev, u8 *calib,
 	gt = (((u32 *)calib)[0] >> lvts_data->gt_calib_bit_offset) & 0xff;
 
 	/* A zero value for gt means that device has invalid efuse data */
-	if (gt && gt < LVTS_GOLDEN_TEMP_MAX)
+	if (gt && gt <= LVTS_GOLDEN_TEMP_MAX)
 		golden_temp = gt;
+	else
+		golden_temp = lvts_data->golden_temp;
 
 	golden_temp_offset = golden_temp * 500 + lvts_data->temp_offset;
 
@@ -859,6 +872,14 @@ static int lvts_ctrl_init(struct device *dev, struct lvts_domain *lvts_td,
 		 */
 		lvts_ctrl[i].mode = lvts_data->lvts_ctrl[i].mode;
 
+		/*
+		 * The temperature to raw temperature must be done
+		 * after initializing the calibration.
+		 */
+		lvts_ctrl[i].hw_reset_raw_temp =
+			lvts_temp_to_raw(LVTS_HW_RESET_TEMP,
+					 lvts_data->temp_factor);
+
 		lvts_ctrl[i].low_thresh = INT_MIN;
 		lvts_ctrl[i].high_thresh = INT_MIN;
 	}
@@ -915,12 +936,14 @@ static void lvts_write_config(struct lvts_ctrl *lvts_ctrl, const u32 *cmds, int
 	 */
 	for (i = 0; i < nr_cmds; i++) {
 		writel(cmds[i], LVTS_CONFIG(lvts_ctrl->base));
-		usleep_range(2, 4);
+		usleep_range(5, 15);
 	}
 }
 
 static int lvts_irq_init(struct lvts_ctrl *lvts_ctrl)
 {
+	const struct lvts_data *lvts_data = lvts_ctrl->lvts_data;
+
 	/*
 	 * LVTS_PROTCTL : Thermal Protection Sensor Selection
 	 *
@@ -954,7 +977,12 @@ static int lvts_irq_init(struct lvts_ctrl *lvts_ctrl)
 	 * The LVTS_MONINT register layout is the same as the LVTS_MONINTSTS
 	 * register, except we set the bits to enable the interrupt.
 	 */
-	writel(0, LVTS_MONINT(lvts_ctrl->base));
+	if (lvts_data->irq_enable) {
+		writel(0, LVTS_MONINT(lvts_ctrl->base));
+	} else {
+		writel(BIT(16), LVTS_PROTCTL(lvts_ctrl->base));
+		writel(lvts_ctrl->hw_reset_raw_temp, LVTS_PROTTC(lvts_ctrl->base));
+	}
 
 	return 0;
 }
@@ -1041,6 +1069,38 @@ static int lvts_ctrl_calibrate(struct device *dev, struct lvts_ctrl *lvts_ctrl)
 	return 0;
 }
 
+static int lvts_ctrl_wait_bus_idle(struct device *dev, struct lvts_ctrl *lvts_ctrl)
+{
+	const u32 status_mask = BIT(10) | BIT(7) | BIT(0);
+	u32 status, value;
+	int ret;
+
+	ret = readl_poll_timeout(LVTS_MSRCTL1(lvts_ctrl->base), value,
+				 !(value & status_mask),
+				 LVTS_BUS_IDLE_WAIT_US, LVTS_BUS_IDLE_TIMEOUT_US);
+
+	/*
+	 * Bus status:
+	 *
+	 * 000 : Idle
+	 * 001 : Write transaction
+	 * 010 : Waiting for read after write
+	 * 011 : Disable continue fetching on device
+	 * 100 : Read transaction
+	 * 101 : Set device special register for voltage threshold
+	 * 111 : Set TSMCU number for fetch
+	 */
+	status = ((value & BIT(10)) >> 8) | ((value & BIT(7)) >> 6) |
+		 (value & BIT(0));
+
+	if (status) {
+		dev_err(dev, "Bus not idle, error code 0x%x\n", status);
+		return -EBUSY;
+	}
+
+	return 0;
+}
+
 static int lvts_ctrl_configure(struct device *dev, struct lvts_ctrl *lvts_ctrl)
 {
 	u32 value;
@@ -1061,8 +1121,8 @@ static int lvts_ctrl_configure(struct device *dev, struct lvts_ctrl *lvts_ctrl)
 	/*
 	 * LVTS_CALSCALE : ADC voltage round
 	 */
-	value = 0x300;
 	value = LVTS_CALSCALE_CONF;
+	writel(value, LVTS_CALSCALE(lvts_ctrl->base));
 
 	/*
 	 * LVTS_MSRCTL0 : Sensor filtering strategy
@@ -1290,6 +1350,12 @@ static int lvts_domain_init(struct device *dev, struct lvts_domain *lvts_td,
 			return ret;
 		}
 
+		ret = lvts_ctrl_wait_bus_idle(dev, lvts_ctrl);
+		if (ret) {
+			dev_dbg(dev, "Failed to wait for bus idle");
+			return ret;
+		}
+
 		ret = lvts_ctrl_configure(dev, lvts_ctrl);
 		if (ret) {
 			dev_dbg(dev, "Failed to configure controller");
@@ -1338,9 +1404,11 @@ static int lvts_probe(struct platform_device *pdev)
 	if (IS_ERR(lvts_td->reset))
 		return dev_err_probe(dev, PTR_ERR(lvts_td->reset), "Failed to get reset control\n");
 
-	irq = platform_get_irq(pdev, 0);
-	if (irq < 0)
-		return irq;
+	if (lvts_data->irq_enable) {
+		irq = platform_get_irq(pdev, 0);
+		if (irq < 0)
+			return irq;
+	}
 
 	golden_temp_offset = lvts_data->temp_offset;
 
@@ -1348,14 +1416,17 @@ static int lvts_probe(struct platform_device *pdev)
 	if (ret)
 		return dev_err_probe(dev, ret, "Failed to initialize the lvts domain\n");
 
+
 	/*
 	 * At this point the LVTS is initialized and enabled. We can
 	 * safely enable the interrupt.
 	 */
-	ret = devm_request_threaded_irq(dev, irq, NULL, lvts_irq_handler,
-					IRQF_ONESHOT, dev_name(dev), lvts_td);
-	if (ret)
-		return dev_err_probe(dev, ret, "Failed to request interrupt\n");
+	if (lvts_data->irq_enable) {
+		ret = devm_request_threaded_irq(dev, irq, NULL, lvts_irq_handler,
+						IRQF_ONESHOT, dev_name(dev), lvts_td);
+		if (ret)
+			return dev_err_probe(dev, ret, "Failed to request interrupt\n");
+	}
 
 	platform_set_drvdata(pdev, lvts_td);
 
@@ -1387,6 +1458,7 @@ static const struct lvts_ctrl_data mt7988_lvts_ap_data_ctrl[] = {
 		},
 		VALID_SENSOR_MAP(1, 1, 1, 1),
 		.offset = 0x0,
+		.mode = LVTS_MSR_FILTERED_MODE,
 	},
 	{
 		.lvts_sensor = {
@@ -1401,6 +1473,7 @@ static const struct lvts_ctrl_data mt7988_lvts_ap_data_ctrl[] = {
 		},
 		VALID_SENSOR_MAP(1, 1, 1, 1),
 		.offset = 0x100,
+		.mode = LVTS_MSR_FILTERED_MODE,
 	}
 };
 
@@ -1762,7 +1835,10 @@ static const struct lvts_data mt7988_lvts_ap_data = {
 	.num_init_cmd	= ARRAY_SIZE(mt7988_init_cmds),
 	.temp_factor	= LVTS_COEFF_A_MT7988,
 	.temp_offset	= LVTS_COEFF_B_MT7988,
+	.golden_temp	= LVTS_GOLDEN_TEMP_MT7988,
 	.gt_calib_bit_offset = 24,
+	.def_calibration = 19380,
+	.irq_enable = false,
 };
 
 static const struct lvts_data mt8186_lvts_data = {
@@ -1774,8 +1850,10 @@ static const struct lvts_data mt8186_lvts_data = {
 	.num_init_cmd	= ARRAY_SIZE(default_init_cmds),
 	.temp_factor	= LVTS_COEFF_A_MT7988,
 	.temp_offset	= LVTS_COEFF_B_MT7988,
+	.golden_temp	= LVTS_GOLDEN_TEMP_DEFAULT,
 	.gt_calib_bit_offset = 24,
 	.def_calibration = 19000,
+	.irq_enable = true,
 };
 
 static const struct lvts_data mt8188_lvts_mcu_data = {
@@ -1787,8 +1865,10 @@ static const struct lvts_data mt8188_lvts_mcu_data = {
 	.num_init_cmd	= ARRAY_SIZE(default_init_cmds),
 	.temp_factor	= LVTS_COEFF_A_MT8195,
 	.temp_offset	= LVTS_COEFF_B_MT8195,
+	.golden_temp	= LVTS_GOLDEN_TEMP_DEFAULT,
 	.gt_calib_bit_offset = 20,
 	.def_calibration = 35000,
+	.irq_enable = true,
 };
 
 static const struct lvts_data mt8188_lvts_ap_data = {
@@ -1800,8 +1880,10 @@ static const struct lvts_data mt8188_lvts_ap_data = {
 	.num_init_cmd	= ARRAY_SIZE(default_init_cmds),
 	.temp_factor	= LVTS_COEFF_A_MT8195,
 	.temp_offset	= LVTS_COEFF_B_MT8195,
+	.golden_temp	= LVTS_GOLDEN_TEMP_DEFAULT,
 	.gt_calib_bit_offset = 20,
 	.def_calibration = 35000,
+	.irq_enable = true,
 };
 
 static const struct lvts_data mt8192_lvts_mcu_data = {
@@ -1813,8 +1895,10 @@ static const struct lvts_data mt8192_lvts_mcu_data = {
 	.num_init_cmd	= ARRAY_SIZE(default_init_cmds),
 	.temp_factor	= LVTS_COEFF_A_MT8195,
 	.temp_offset	= LVTS_COEFF_B_MT8195,
+	.golden_temp	= LVTS_GOLDEN_TEMP_DEFAULT,
 	.gt_calib_bit_offset = 24,
 	.def_calibration = 35000,
+	.irq_enable = true,
 };
 
 static const struct lvts_data mt8192_lvts_ap_data = {
@@ -1826,8 +1910,10 @@ static const struct lvts_data mt8192_lvts_ap_data = {
 	.num_init_cmd	= ARRAY_SIZE(default_init_cmds),
 	.temp_factor	= LVTS_COEFF_A_MT8195,
 	.temp_offset	= LVTS_COEFF_B_MT8195,
+	.golden_temp	= LVTS_GOLDEN_TEMP_DEFAULT,
 	.gt_calib_bit_offset = 24,
 	.def_calibration = 35000,
+	.irq_enable = true,
 };
 
 static const struct lvts_data mt8195_lvts_mcu_data = {
@@ -1839,8 +1925,10 @@ static const struct lvts_data mt8195_lvts_mcu_data = {
 	.num_init_cmd	= ARRAY_SIZE(default_init_cmds),
 	.temp_factor	= LVTS_COEFF_A_MT8195,
 	.temp_offset	= LVTS_COEFF_B_MT8195,
+	.golden_temp	= LVTS_GOLDEN_TEMP_DEFAULT,
 	.gt_calib_bit_offset = 24,
 	.def_calibration = 35000,
+	.irq_enable = true,
 };
 
 static const struct lvts_data mt8195_lvts_ap_data = {
@@ -1852,8 +1940,10 @@ static const struct lvts_data mt8195_lvts_ap_data = {
 	.num_init_cmd	= ARRAY_SIZE(default_init_cmds),
 	.temp_factor	= LVTS_COEFF_A_MT8195,
 	.temp_offset	= LVTS_COEFF_B_MT8195,
+	.golden_temp	= LVTS_GOLDEN_TEMP_DEFAULT,
 	.gt_calib_bit_offset = 24,
 	.def_calibration = 35000,
+	.irq_enable = true,
 };
 
 static const struct of_device_id lvts_of_match[] = {
-- 
2.45.2

