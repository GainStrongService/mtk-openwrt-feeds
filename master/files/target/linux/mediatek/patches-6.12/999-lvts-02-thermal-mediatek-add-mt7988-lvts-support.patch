From a057c83da81212944c7efb85b0529c008581be27 Mon Sep 17 00:00:00 2001
From: Mason Chang <mason-cw.chang@mediatek.com>
Date: Thu, 18 Sep 2025 20:04:00 +0800
Subject: [PATCH] thermal: mediatek: add mt7988 lvts support

Without this patch, unexpected LVTS hardware behavior may occur.
---
 drivers/thermal/mediatek/lvts_thermal.c | 124 ++++++++++++++++++++----
 1 file changed, 107 insertions(+), 17 deletions(-)

--- a/drivers/thermal/mediatek/lvts_thermal.c	2025-10-20 17:08:09.363454309 +0800
+++ b/drivers/thermal/mediatek/lvts_thermal.c	2025-10-20 17:09:23.506695416 +0800
@@ -58,11 +58,11 @@
 #define LVTS_PROTTC(__base)		(__base + 0x00CC)
 #define LVTS_CLKEN(__base)		(__base + 0x00E4)
 
-#define LVTS_PERIOD_UNIT			0
-#define LVTS_GROUP_INTERVAL			0
-#define LVTS_FILTER_INTERVAL		0
-#define LVTS_SENSOR_INTERVAL		0
-#define LVTS_HW_FILTER				0x0
+#define LVTS_PERIOD_UNIT			0xc
+#define LVTS_GROUP_INTERVAL			0x1
+#define LVTS_FILTER_INTERVAL			0x1
+#define LVTS_SENSOR_INTERVAL			0x1
+#define LVTS_HW_FILTER				0x5
 #define LVTS_TSSEL_CONF				0x13121110
 #define LVTS_CALSCALE_CONF			0x300
 
@@ -83,6 +83,7 @@
 #define LVTS_SENSOR_MAX				4
 #define LVTS_GOLDEN_TEMP_MAX		62
 #define LVTS_GOLDEN_TEMP_DEFAULT	50
+#define LVTS_GOLDEN_TEMP_MT7988		60
 #define LVTS_COEFF_A_MT8195			-250460
 #define LVTS_COEFF_B_MT8195			250460
 #define LVTS_COEFF_A_MT7988			-204650
@@ -93,8 +94,12 @@
 #define LVTS_MSR_IMMEDIATE_MODE		0
 #define LVTS_MSR_FILTERED_MODE		1
 
-#define LVTS_MSR_READ_TIMEOUT_US	400
+#define LVTS_MSR_READ_TIMEOUT_US	3000
 #define LVTS_MSR_READ_WAIT_US		(LVTS_MSR_READ_TIMEOUT_US / 2)
+#define LVTS_BUS_IDLE_TIMEOUT_US	200
+#define LVTS_BUS_IDLE_WAIT_US		2
+
+#define LVTS_HW_RESET_TEMP		125000
 
 #define LVTS_MINIMUM_THRESHOLD		20000
 
@@ -135,6 +140,7 @@
 	int num_init_cmd;
 	int temp_factor;
 	int temp_offset;
+	int golden_temp;
 	int gt_calib_bit_offset;
 	unsigned int def_calibration;
 };
@@ -153,6 +159,7 @@
 	struct lvts_sensor sensors[LVTS_SENSOR_MAX];
 	const struct lvts_data *lvts_data;
 	u32 calibration[LVTS_SENSOR_MAX];
+	u32 hw_reset_raw_temp;
 	u8 valid_sensor_mask;
 	int mode;
 	void __iomem *base;
@@ -417,6 +424,9 @@
 
 	lvts_update_irq_mask(lvts_ctrl);
 
+	if (!lvts_data->irq_enable)
+		return 0;
+
 	if (!should_update_thresh)
 		return 0;
 
@@ -811,8 +821,10 @@
 	gt = (((u32 *)calib)[0] >> lvts_data->gt_calib_bit_offset) & 0xff;
 
 	/* A zero value for gt means that device has invalid efuse data */
-	if (gt && gt < LVTS_GOLDEN_TEMP_MAX)
+	if (gt && gt <= LVTS_GOLDEN_TEMP_MAX)
 		golden_temp = gt;
+	else
+		golden_temp = lvts_data->golden_temp;
 
 	golden_temp_offset = golden_temp * 500 + lvts_data->temp_offset;
 
@@ -866,6 +878,14 @@
 		 */
 		lvts_ctrl[i].mode = lvts_data->lvts_ctrl[i].mode;
 
+		/*
+		 * The temperature to raw temperature must be done
+		 * after initializing the calibration.
+		 */
+		lvts_ctrl[i].hw_reset_raw_temp =
+			lvts_temp_to_raw(LVTS_HW_RESET_TEMP,
+					 lvts_data->temp_factor);
+
 		lvts_ctrl[i].low_thresh = INT_MIN;
 		lvts_ctrl[i].high_thresh = INT_MIN;
 	}
@@ -922,7 +942,7 @@
 	 */
 	for (i = 0; i < nr_cmds; i++) {
 		writel(cmds[i], LVTS_CONFIG(lvts_ctrl->base));
-		usleep_range(2, 4);
+		usleep_range(5, 15);
 	}
 }
 
@@ -963,8 +983,12 @@
 	 * The LVTS_MONINT register layout is the same as the LVTS_MONINTSTS
 	 * register, except we set the bits to enable the interrupt.
 	 */
-	if (lvts_data->irq_enable)
+	if (lvts_data->irq_enable) {
 		writel(0, LVTS_MONINT(lvts_ctrl->base));
+	} else {
+		writel(BIT(16), LVTS_PROTCTL(lvts_ctrl->base));
+		writel(lvts_ctrl->hw_reset_raw_temp, LVTS_PROTTC(lvts_ctrl->base));
+	}
 
 	return 0;
 }
@@ -1051,6 +1075,38 @@
 	return 0;
 }
 
+static int lvts_ctrl_wait_bus_idle(struct device *dev, struct lvts_ctrl *lvts_ctrl)
+{
+	const u32 status_mask = BIT(10) | BIT(7) | BIT(0);
+	u32 status, value;
+	int ret;
+
+	ret = readl_poll_timeout(LVTS_MSRCTL1(lvts_ctrl->base), value,
+				 !(value & status_mask),
+				 LVTS_BUS_IDLE_WAIT_US, LVTS_BUS_IDLE_TIMEOUT_US);
+
+	/*
+	 * Bus status:
+	 *
+	 * 000 : Idle
+	 * 001 : Write transaction
+	 * 010 : Waiting for read after write
+	 * 011 : Disable continue fetching on device
+	 * 100 : Read transaction
+	 * 101 : Set device special register for voltage threshold
+	 * 111 : Set TSMCU number for fetch
+	 */
+	status = ((value & BIT(10)) >> 8) | ((value & BIT(7)) >> 6) |
+		 (value & BIT(0));
+
+	if (status) {
+		dev_err(dev, "Bus not idle, error code 0x%x\n", status);
+		return -EBUSY;
+	}
+
+	return 0;
+}
+
 static int lvts_ctrl_configure(struct device *dev, struct lvts_ctrl *lvts_ctrl)
 {
 	u32 value;
@@ -1071,8 +1127,8 @@
 	/*
 	 * LVTS_CALSCALE : ADC voltage round
 	 */
-	value = 0x300;
 	value = LVTS_CALSCALE_CONF;
+	writel(value, LVTS_CALSCALE(lvts_ctrl->base));
 
 	/*
 	 * LVTS_MSRCTL0 : Sensor filtering strategy
@@ -1300,6 +1356,12 @@
 			return ret;
 		}
 
+		ret = lvts_ctrl_wait_bus_idle(dev, lvts_ctrl);
+		if (ret) {
+			dev_dbg(dev, "Failed to wait for bus idle");
+			return ret;
+		}
+
 		ret = lvts_ctrl_configure(dev, lvts_ctrl);
 		if (ret) {
 			dev_dbg(dev, "Failed to configure controller");
@@ -1414,6 +1476,7 @@
 		},
 		VALID_SENSOR_MAP(1, 1, 1, 1),
 		.offset = 0x0,
+		.mode = LVTS_MSR_FILTERED_MODE,
 	},
 	{
 		.lvts_sensor = {
@@ -1428,6 +1491,7 @@
 		},
 		VALID_SENSOR_MAP(1, 1, 1, 1),
 		.offset = 0x100,
+		.mode = LVTS_MSR_FILTERED_MODE,
 	}
 };
 
@@ -1810,7 +1874,10 @@
 	.num_init_cmd	= ARRAY_SIZE(mt7988_init_cmds),
 	.temp_factor	= LVTS_COEFF_A_MT7988,
 	.temp_offset	= LVTS_COEFF_B_MT7988,
+	.golden_temp	= LVTS_GOLDEN_TEMP_MT7988,
 	.gt_calib_bit_offset = 24,
+	.def_calibration = 19380,
+	.irq_enable = false,
 };
 
 static const struct lvts_data mt8186_lvts_data = {
@@ -1823,8 +1890,10 @@
 	.num_init_cmd	= ARRAY_SIZE(default_init_cmds),
 	.temp_factor	= LVTS_COEFF_A_MT7988,
 	.temp_offset	= LVTS_COEFF_B_MT7988,
+	.golden_temp	= LVTS_GOLDEN_TEMP_DEFAULT,
 	.gt_calib_bit_offset = 24,
 	.def_calibration = 19000,
+	.irq_enable = true,
 };
 
 static const struct lvts_data mt8188_lvts_mcu_data = {
@@ -1837,8 +1906,10 @@
 	.num_init_cmd	= ARRAY_SIZE(default_init_cmds),
 	.temp_factor	= LVTS_COEFF_A_MT8195,
 	.temp_offset	= LVTS_COEFF_B_MT8195,
+	.golden_temp	= LVTS_GOLDEN_TEMP_DEFAULT,
 	.gt_calib_bit_offset = 20,
 	.def_calibration = 35000,
+	.irq_enable = true,
 };
 
 static const struct lvts_data mt8188_lvts_ap_data = {
@@ -1851,8 +1922,10 @@
 	.num_init_cmd	= ARRAY_SIZE(default_init_cmds),
 	.temp_factor	= LVTS_COEFF_A_MT8195,
 	.temp_offset	= LVTS_COEFF_B_MT8195,
+	.golden_temp	= LVTS_GOLDEN_TEMP_DEFAULT,
 	.gt_calib_bit_offset = 20,
 	.def_calibration = 35000,
+	.irq_enable = true,
 };
 
 static const struct lvts_data mt8192_lvts_mcu_data = {
@@ -1865,8 +1938,10 @@
 	.num_init_cmd	= ARRAY_SIZE(default_init_cmds),
 	.temp_factor	= LVTS_COEFF_A_MT8195,
 	.temp_offset	= LVTS_COEFF_B_MT8195,
+	.golden_temp	= LVTS_GOLDEN_TEMP_DEFAULT,
 	.gt_calib_bit_offset = 24,
 	.def_calibration = 35000,
+	.irq_enable = true,
 };
 
 static const struct lvts_data mt8192_lvts_ap_data = {
@@ -1879,8 +1954,10 @@
 	.num_init_cmd	= ARRAY_SIZE(default_init_cmds),
 	.temp_factor	= LVTS_COEFF_A_MT8195,
 	.temp_offset	= LVTS_COEFF_B_MT8195,
+	.golden_temp	= LVTS_GOLDEN_TEMP_DEFAULT,
 	.gt_calib_bit_offset = 24,
 	.def_calibration = 35000,
+	.irq_enable = true,
 };
 
 static const struct lvts_data mt8195_lvts_mcu_data = {
@@ -1893,8 +1970,10 @@
 	.num_init_cmd	= ARRAY_SIZE(default_init_cmds),
 	.temp_factor	= LVTS_COEFF_A_MT8195,
 	.temp_offset	= LVTS_COEFF_B_MT8195,
+	.golden_temp	= LVTS_GOLDEN_TEMP_DEFAULT,
 	.gt_calib_bit_offset = 24,
 	.def_calibration = 35000,
+	.irq_enable = true,
 };
 
 static const struct lvts_data mt8195_lvts_ap_data = {
@@ -1907,8 +1986,10 @@
 	.num_init_cmd	= ARRAY_SIZE(default_init_cmds),
 	.temp_factor	= LVTS_COEFF_A_MT8195,
 	.temp_offset	= LVTS_COEFF_B_MT8195,
+	.golden_temp	= LVTS_GOLDEN_TEMP_DEFAULT,
 	.gt_calib_bit_offset = 24,
 	.def_calibration = 35000,
+	.irq_enable = true,
 };
 
 static const struct of_device_id lvts_of_match[] = {
