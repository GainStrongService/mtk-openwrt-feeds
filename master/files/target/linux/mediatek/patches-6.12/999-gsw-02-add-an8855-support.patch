From 482cfce379002f2ea7e313047a3ff3c837e8d3b6 Mon Sep 17 00:00:00 2001
From: "neal.yen" <neal.yen@mediatek.com>
Date: Tue, 21 Oct 2025 15:08:33 +0800
Subject: [PATCH] net: phy: airoha: add an8855 gsw driver support


diff --git a/drivers/net/phy/Kconfig b/drivers/net/phy/Kconfig
index 6df7daa..1b0f312 100644
--- a/drivers/net/phy/Kconfig
+++ b/drivers/net/phy/Kconfig
@@ -153,6 +153,8 @@ endif # RTL8366_SMI
 
 source "drivers/net/phy/mtk/mt753x/Kconfig"
 
+source "drivers/net/phy/airoha/an8855/Kconfig"
+
 comment "MII PHY device drivers"
 
 config AS21XXX_PHY
diff --git a/drivers/net/phy/Makefile b/drivers/net/phy/Makefile
index 80af0e8..192cb34 100644
--- a/drivers/net/phy/Makefile
+++ b/drivers/net/phy/Makefile
@@ -123,3 +123,4 @@ obj-$(CONFIG_TERANETICS_PHY)	+= teranetics.o
 obj-$(CONFIG_VITESSE_PHY)	+= vitesse.o
 obj-$(CONFIG_XILINX_GMII2RGMII) += xilinx_gmii2rgmii.o
 obj-$(CONFIG_MT753X_GSW)        += mtk/mt753x/
+obj-$(CONFIG_AN8855_GSW)        += airoha/an8855/
diff --git a/drivers/net/phy/airoha/an8855/Kconfig b/drivers/net/phy/airoha/an8855/Kconfig
new file mode 100644
index 0000000..654aa37
--- /dev/null
+++ b/drivers/net/phy/airoha/an8855/Kconfig
@@ -0,0 +1,8 @@
+
+config AN8855_GSW
+	tristate "Driver for the Airoha AN8855 switch"
+	help
+	  Airoha AN8855 devices and swconfig driver code,
+	  Provide swconfig command for basic switch operation.
+	  AN8855 support 2.5G speed and managed by SMI interface.
+	  To compile this driver as a module, choose M here.
diff --git a/drivers/net/phy/airoha/an8855/Makefile b/drivers/net/phy/airoha/an8855/Makefile
new file mode 100644
index 0000000..5c24bda
--- /dev/null
+++ b/drivers/net/phy/airoha/an8855/Makefile
@@ -0,0 +1,10 @@
+#
+# Makefile for Airoha AN8855 gigabit switch
+#
+
+obj-$(CONFIG_AN8855_GSW)	+= an8855.o
+
+an8855-$(CONFIG_SWCONFIG)	+= an8855_swconfig.o
+
+an8855-y			+= an8855_mdio.o an8855.o \
+					an8855_common.o an8855_vlan.o an8855_nl.o
diff --git a/drivers/net/phy/airoha/an8855/an8855.c b/drivers/net/phy/airoha/an8855/an8855.c
new file mode 100644
index 0000000..c6f5eee
--- /dev/null
+++ b/drivers/net/phy/airoha/an8855/an8855.c
@@ -0,0 +1,1387 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2023 Airoha Inc.
+ * Author: Min Yao <min.yao@airoha.com>
+ */
+
+#include <linux/kernel.h>
+#include <linux/delay.h>
+#include <linux/hrtimer.h>
+#include <linux/of_platform.h>
+#include <linux/mfd/syscon.h>
+#include <linux/regmap.h>
+#include <linux/of_address.h>
+
+#include "an8855.h"
+#include "an8855_regs.h"
+
+/* AN8855 registers */
+#define SCU_BASE					0x10000000
+#define RG_RGMII_TXCK_C				(SCU_BASE + 0x1d0)
+#define RG_GPIO_LED_MODE			(SCU_BASE + 0x0054)
+#define RG_GPIO_LED_SEL(i)	(SCU_BASE + (0x0058 + ((i) * 4)))
+#define RG_INTB_MODE				(SCU_BASE + 0x0080)
+#define RG_GDMP_RAM				(SCU_BASE + 0x10000)
+
+#define RG_GPIO_L_INV			(SCU_BASE + 0x0010)
+#define RG_GPIO_CTRL			(SCU_BASE + 0xa300)
+#define RG_GPIO_DATA			(SCU_BASE + 0xa304)
+#define RG_GPIO_OE			(SCU_BASE + 0xa314)
+
+
+#define HSGMII_AN_CSR_BASE			0x10220000
+#define SGMII_REG_AN0				(HSGMII_AN_CSR_BASE + 0x000)
+#define SGMII_REG_AN_13				(HSGMII_AN_CSR_BASE + 0x034)
+#define SGMII_REG_AN_FORCE_CL37		(HSGMII_AN_CSR_BASE + 0x060)
+
+#define HSGMII_CSR_PCS_BASE			0x10220000
+#define RG_HSGMII_PCS_CTROL_1		(HSGMII_CSR_PCS_BASE + 0xa00)
+#define RG_AN_SGMII_MODE_FORCE		(HSGMII_CSR_PCS_BASE + 0xa24)
+
+#define MULTI_SGMII_CSR_BASE		0x10224000
+#define SGMII_STS_CTRL_0			(MULTI_SGMII_CSR_BASE + 0x018)
+#define MSG_RX_CTRL_0				(MULTI_SGMII_CSR_BASE + 0x100)
+#define MSG_RX_LIK_STS_0			(MULTI_SGMII_CSR_BASE + 0x514)
+#define MSG_RX_LIK_STS_2			(MULTI_SGMII_CSR_BASE + 0x51c)
+#define PHY_RX_FORCE_CTRL_0			(MULTI_SGMII_CSR_BASE + 0x520)
+
+#define XFI_CSR_PCS_BASE			0x10225000
+#define RG_USXGMII_AN_CONTROL_0		(XFI_CSR_PCS_BASE + 0xbf8)
+
+#define MULTI_PHY_RA_CSR_BASE		0x10226000
+#define RG_RATE_ADAPT_CTRL_0		(MULTI_PHY_RA_CSR_BASE + 0x000)
+#define RATE_ADP_P0_CTRL_0			(MULTI_PHY_RA_CSR_BASE + 0x100)
+#define MII_RA_AN_ENABLE			(MULTI_PHY_RA_CSR_BASE + 0x300)
+
+#define QP_DIG_CSR_BASE				0x1022a000
+#define QP_CK_RST_CTRL_4			(QP_DIG_CSR_BASE + 0x310)
+#define QP_DIG_MODE_CTRL_0			(QP_DIG_CSR_BASE + 0x324)
+#define QP_DIG_MODE_CTRL_1			(QP_DIG_CSR_BASE + 0x330)
+
+#define SERDES_WRAPPER_BASE			0x1022c000
+#define USGMII_CTRL_0				(SERDES_WRAPPER_BASE + 0x000)
+
+#define QP_PMA_TOP_BASE				0x1022e000
+#define PON_RXFEDIG_CTRL_0			(QP_PMA_TOP_BASE + 0x100)
+#define PON_RXFEDIG_CTRL_9			(QP_PMA_TOP_BASE + 0x124)
+
+#define SS_LCPLL_PWCTL_SETTING_2	(QP_PMA_TOP_BASE + 0x208)
+#define SS_LCPLL_TDC_FLT_2			(QP_PMA_TOP_BASE + 0x230)
+#define SS_LCPLL_TDC_FLT_5			(QP_PMA_TOP_BASE + 0x23c)
+#define SS_LCPLL_TDC_PCW_1			(QP_PMA_TOP_BASE + 0x248)
+#define INTF_CTRL_8		(QP_PMA_TOP_BASE + 0x320)
+#define INTF_CTRL_9		(QP_PMA_TOP_BASE + 0x324)
+#define INTF_CTRL_10	(QP_PMA_TOP_BASE + 0x328)
+#define INTF_CTRL_11	(QP_PMA_TOP_BASE + 0x32c)
+#define PLL_CTRL_0		(QP_PMA_TOP_BASE + 0x400)
+#define PLL_CTRL_2		(QP_PMA_TOP_BASE + 0x408)
+#define PLL_CTRL_3		(QP_PMA_TOP_BASE + 0x40c)
+#define PLL_CTRL_4		(QP_PMA_TOP_BASE + 0x410)
+#define PLL_CK_CTRL_0	(QP_PMA_TOP_BASE + 0x414)
+#define RX_DLY_0		(QP_PMA_TOP_BASE + 0x614)
+#define RX_CTRL_2		(QP_PMA_TOP_BASE + 0x630)
+#define RX_CTRL_5		(QP_PMA_TOP_BASE + 0x63c)
+#define RX_CTRL_6		(QP_PMA_TOP_BASE + 0x640)
+#define RX_CTRL_7		(QP_PMA_TOP_BASE + 0x644)
+#define RX_CTRL_8		(QP_PMA_TOP_BASE + 0x648)
+#define RX_CTRL_26		(QP_PMA_TOP_BASE + 0x690)
+#define RX_CTRL_42		(QP_PMA_TOP_BASE + 0x6d0)
+
+#define QP_ANA_CSR_BASE				0x1022f000
+#define RG_QP_RX_DAC_EN				(QP_ANA_CSR_BASE + 0x00)
+#define RG_QP_RXAFE_RESERVE			(QP_ANA_CSR_BASE + 0x04)
+#define RG_QP_CDR_LPF_BOT_LIM		(QP_ANA_CSR_BASE + 0x08)
+#define RG_QP_CDR_LPF_MJV_LIM		(QP_ANA_CSR_BASE + 0x0c)
+#define RG_QP_CDR_LPF_SETVALUE		(QP_ANA_CSR_BASE + 0x14)
+#define RG_QP_CDR_PR_CKREF_DIV1		(QP_ANA_CSR_BASE + 0x18)
+#define RG_QP_CDR_PR_KBAND_DIV_PCIE	(QP_ANA_CSR_BASE + 0x1c)
+#define RG_QP_CDR_FORCE_IBANDLPF_R_OFF	(QP_ANA_CSR_BASE + 0x20)
+#define RG_QP_TX_MODE_16B_EN		(QP_ANA_CSR_BASE + 0x28)
+#define RG_QP_PLL_IPLL_DIG_PWR_SEL	(QP_ANA_CSR_BASE + 0x3c)
+#define RG_QP_PLL_SDM_ORD			(QP_ANA_CSR_BASE + 0x40)
+
+#define ETHER_SYS_BASE				0x1028c800
+#define RG_P5MUX_MODE				(ETHER_SYS_BASE + 0x00)
+#define RG_FORCE_CKDIR_SEL			(ETHER_SYS_BASE + 0x04)
+#define RG_SWITCH_MODE				(ETHER_SYS_BASE + 0x08)
+#define RG_FORCE_MAC5_SB			(ETHER_SYS_BASE + 0x2c)
+#define RG_GPHY_AFE_PWD				(ETHER_SYS_BASE + 0x40)
+#define RG_GPHY_SMI_ADDR			(ETHER_SYS_BASE + 0x48)
+#define CSR_RMII					(ETHER_SYS_BASE + 0x70)
+
+/* PHY EEE Register bitmap of define */
+#define PHY_DEV07				0x07
+#define PHY_DEV07_REG_03C		0x3c
+
+/* PHY Extend Register 0x14 bitmap of define */
+#define PHY_EXT_REG_14			0x14
+
+/* Fields of PHY_EXT_REG_14 */
+#define PHY_EN_DOWN_SHFIT		BIT(4)
+
+/* PHY dev address 0x1E */
+#define PHY_DEV1E				0x1e
+
+/* PHY TX PAIR DELAY SELECT Register */
+#define PHY_TX_PAIR_DLY_SEL_GBE		0x013
+/* PHY ADC Register */
+#define PHY_RXADC_CTRL				0x0d8
+#define PHY_RXADC_REV_0				0x0d9
+#define PHY_RXADC_REV_1				0x0da
+
+/* PHY LED Register bitmap of define */
+#define PHY_LED_CTRL_SELECT		0x3e8
+#define PHY_SINGLE_LED_ON_CTRL(i)	(0x3e0 + ((i) * 2))
+#define PHY_SINGLE_LED_BLK_CTRL(i)	(0x3e1 + ((i) * 2))
+#define PHY_SINGLE_LED_ON_DUR(i)	(0x3e9 + ((i) * 2))
+#define PHY_SINGLE_LED_BLK_DUR(i)	(0x3ea + ((i) * 2))
+
+#define PHY_PMA_CTRL	(0x340)
+
+/* PHY dev address 0x1F */
+#define PHY_DEV1F				0x1f
+#define PHY_LED_ON_CTRL(i)		(0x24 + ((i) * 2))
+#define LED_ON_EN				(1 << 15)
+#define LED_ON_POL				(1 << 14)
+#define LED_ON_EVT_MASK			(0x7f)
+/* LED ON Event */
+#define LED_ON_EVT_FORCE		(1 << 6)
+#define LED_ON_EVT_LINK_HD		(1 << 5)
+#define LED_ON_EVT_LINK_FD		(1 << 4)
+#define LED_ON_EVT_LINK_DOWN	(1 << 3)
+#define LED_ON_EVT_LINK_10M		(1 << 2)
+#define LED_ON_EVT_LINK_100M	(1 << 1)
+#define LED_ON_EVT_LINK_1000M	(1 << 0)
+
+#define PHY_LED_BLK_CTRL(i)		(0x25 + ((i) * 2))
+#define LED_BLK_EVT_MASK		(0x3ff)
+/* LED Blinking Event */
+#define LED_BLK_EVT_FORCE			(1 << 9)
+#define LED_BLK_EVT_10M_RX_ACT		(1 << 5)
+#define LED_BLK_EVT_10M_TX_ACT		(1 << 4)
+#define LED_BLK_EVT_100M_RX_ACT		(1 << 3)
+#define LED_BLK_EVT_100M_TX_ACT		(1 << 2)
+#define LED_BLK_EVT_1000M_RX_ACT	(1 << 1)
+#define LED_BLK_EVT_1000M_TX_ACT	(1 << 0)
+
+#define PHY_LED_BCR				(0x21)
+#define LED_BCR_EXT_CTRL		(1 << 15)
+#define LED_BCR_CLK_EN			(1 << 3)
+#define LED_BCR_TIME_TEST		(1 << 2)
+#define LED_BCR_MODE_MASK		(3)
+#define LED_BCR_MODE_DISABLE	(0)
+
+#define PHY_LED_ON_DUR			(0x22)
+#define LED_ON_DUR_MASK			(0xffff)
+
+#define PHY_LED_BLK_DUR			(0x23)
+#define LED_BLK_DUR_MASK		(0xffff)
+
+#define PHY_LED_BLINK_DUR_CTRL	(0x720)
+
+/* Unique fields of PMCR for AN8855 */
+#define FORCE_TX_FC		BIT(4)
+#define FORCE_RX_FC		BIT(5)
+#define FORCE_EEE100		BIT(6)
+#define FORCE_EEE1G		BIT(7)
+#define FORCE_EEE2P5G		BIT(8)
+#define FORCE_DPX		BIT(25)
+#define FORCE_SPD		BITS(28, 30)
+#define FORCE_LNK		BIT(24)
+#define FORCE_MODE		BIT(31)
+
+#define CHIP_ID			0x10005000
+#define CHIP_REV		0x10005004
+
+#define AN8855_EFUSE_DATA0	0x1000a500
+
+const u8 r50ohm_table[] = {
+	127, 127, 127, 127, 127, 127, 127, 127, 127, 127,
+	127, 127, 127, 127, 127, 127, 127, 126, 122, 117,
+	112, 109, 104, 101,  97,  94,  90,  88,  84,  80,
+	78,  74,  72,  68,  66,  64,  61,  58,  56,  53,
+	51,  48,  47,  44,  42,  40,  38,  36,  34,  32,
+	31,  28,  27,  24,  24,  22,  20,  18,  16,  16,
+	14,  12,  11,   9
+};
+
+static u8 shift_check(u8 base)
+{
+	u8 i;
+	u32 sz = sizeof(r50ohm_table)/sizeof(u8);
+
+	for (i = 0; i < sz; ++i)
+		if (r50ohm_table[i] == base)
+			break;
+
+	if (i < 8 || i >= sz)
+		return 25; /* index of 94 */
+
+	return (i - 8);
+}
+
+static u8 get_shift_val(u8 idx)
+{
+	return r50ohm_table[idx];
+}
+
+/* T830 AN8855 Reference Board */
+static const struct an8855_led_cfg led_cfg[] = {
+/*************************************************************************
+ * Enable, LED idx, LED Polarity, LED ON event,  LED Blink event  LED Freq
+ *************************************************************************
+ */
+	/* GPIO0 */
+	{0, PHY_LED_MAX, LED_HIGH, LED_ON_EVENT, LED_BLK_EVENT, LED_FREQ},
+	/* GPIO1 */
+	{1, P0_LED1, LED_HIGH, LED_ON_EVENT, LED_BLK_EVENT, LED_FREQ},
+	/* GPIO2 */
+	{1, P1_LED1, LED_HIGH, LED_ON_EVENT, LED_BLK_EVENT, LED_FREQ},
+	/* GPIO3 */
+	{1, P2_LED1, LED_HIGH, LED_ON_EVENT, LED_BLK_EVENT, LED_FREQ},
+	/* GPIO4 */
+	{1, P3_LED1, LED_LOW,  LED_ON_EVENT, LED_BLK_EVENT, LED_FREQ},
+	/* GPIO5 */
+	{1, P4_LED1, LED_LOW,  LED_ON_EVENT, LED_BLK_EVENT, LED_FREQ},
+	/* GPIO6 */
+	{0, PHY_LED_MAX, LED_LOW,  LED_ON_EVENT, LED_BLK_EVENT, LED_FREQ},
+	/* GPIO7 */
+	{0, PHY_LED_MAX, LED_HIGH, LED_ON_EVENT, LED_BLK_EVENT, LED_FREQ},
+	/* GPIO8 */
+	{0, PHY_LED_MAX, LED_HIGH, LED_ON_EVENT, LED_BLK_EVENT, LED_FREQ},
+	/* GPIO9 */
+	{0, PHY_LED_MAX, LED_HIGH, LED_ON_EVENT, LED_BLK_EVENT, LED_FREQ},
+	/* GPIO10 */
+	{0, PHY_LED_MAX, LED_HIGH, LED_ON_EVENT, LED_BLK_EVENT, LED_FREQ},
+	/* GPIO11 */
+	{0, PHY_LED_MAX, LED_HIGH, LED_ON_EVENT, LED_BLK_EVENT, LED_FREQ},
+	/* GPIO12 */
+	{0, PHY_LED_MAX, LED_LOW,  LED_ON_EVENT, LED_BLK_EVENT, LED_FREQ},
+	/* GPIO13 */
+	{0, PHY_LED_MAX, LED_HIGH, LED_ON_EVENT, LED_BLK_EVENT, LED_FREQ},
+	/* GPIO14 */
+	{0, PHY_LED_MAX, LED_HIGH, LED_ON_EVENT, LED_BLK_EVENT, LED_FREQ},
+	/* GPIO15 */
+	{0, PHY_LED_MAX, LED_HIGH, LED_ON_EVENT, LED_BLK_EVENT, LED_FREQ},
+	/* GPIO16 */
+	{0, PHY_LED_MAX, LED_HIGH, LED_ON_EVENT, LED_BLK_EVENT, LED_FREQ},
+	/* GPIO17 */
+	{0, PHY_LED_MAX, LED_HIGH, LED_ON_EVENT, LED_BLK_EVENT, LED_FREQ},
+	/* GPIO18 */
+	{0, PHY_LED_MAX, LED_HIGH, LED_ON_EVENT, LED_BLK_EVENT, LED_FREQ},
+	/* GPIO19 */
+	{0, PHY_LED_MAX, LED_LOW,  LED_ON_EVENT, LED_BLK_EVENT, LED_FREQ},
+	/* GPIO20 */
+	{0, PHY_LED_MAX, LED_LOW,  LED_ON_EVENT, LED_BLK_EVENT, LED_FREQ},
+};
+
+static int an8855_set_hsgmii_mode(struct gsw_an8855 *gsw)
+{
+	u32 val = 0;
+
+	/* TX FIR - improve TX EYE */
+	val = an8855_reg_read(gsw, INTF_CTRL_10);
+	val &= ~(0x3f << 16);
+	val |= BIT(21);
+	val &= ~(0x1f << 24);
+	val |= (0x4 << 24);
+	val |= BIT(29);
+	an8855_reg_write(gsw, INTF_CTRL_10, val);
+
+	val = an8855_reg_read(gsw, INTF_CTRL_11);
+	val &= ~(0x3f);
+	val |= BIT(6);
+	an8855_reg_write(gsw, INTF_CTRL_11, val);
+
+	/* RX CDR - improve RX Jitter Tolerance */
+	val = an8855_reg_read(gsw, RG_QP_CDR_LPF_BOT_LIM);
+	val &= ~(0x7 << 24);
+	val |= (0x5 << 24);
+	val &= ~(0x7 << 20);
+	val |= (0x5 << 20);
+	an8855_reg_write(gsw, RG_QP_CDR_LPF_BOT_LIM, val);
+
+	/* PLL */
+	val = an8855_reg_read(gsw, QP_DIG_MODE_CTRL_1);
+	val &= ~(0x3 << 2);
+	val |= (0x1 << 2);
+	an8855_reg_write(gsw, QP_DIG_MODE_CTRL_1, val);
+
+	/* PLL - LPF */
+	val = an8855_reg_read(gsw, PLL_CTRL_2);
+	val &= ~(0x3 << 0);
+	val |= (0x1 << 0);
+	val &= ~(0x7 << 2);
+	val |= (0x5 << 2);
+	val &= ~BITS(6, 7);
+	val &= ~(0x7 << 8);
+	val |= (0x3 << 8);
+	val |= BIT(29);
+	val &= ~BITS(12, 13);
+	an8855_reg_write(gsw, PLL_CTRL_2, val);
+
+	/* PLL - ICO */
+	val = an8855_reg_read(gsw, PLL_CTRL_4);
+	val |= BIT(2);
+	an8855_reg_write(gsw, PLL_CTRL_4, val);
+
+	val = an8855_reg_read(gsw, PLL_CTRL_2);
+	val &= ~BIT(14);
+	an8855_reg_write(gsw, PLL_CTRL_2, val);
+
+	/* PLL - CHP */
+	val = an8855_reg_read(gsw, PLL_CTRL_2);
+	val &= ~(0xf << 16);
+	val |= (0x6 << 16);
+	an8855_reg_write(gsw, PLL_CTRL_2, val);
+
+	/* PLL - PFD */
+	val = an8855_reg_read(gsw, PLL_CTRL_2);
+	val &= ~(0x3 << 20);
+	val |= (0x1 << 20);
+	val &= ~(0x3 << 24);
+	val |= (0x1 << 24);
+	val &= ~BIT(26);
+	an8855_reg_write(gsw, PLL_CTRL_2, val);
+
+	/* PLL - POSTDIV */
+	val = an8855_reg_read(gsw, PLL_CTRL_2);
+	val |= BIT(22);
+	val &= ~BIT(27);
+	val &= ~BIT(28);
+	an8855_reg_write(gsw, PLL_CTRL_2, val);
+
+	/* PLL - SDM */
+	val = an8855_reg_read(gsw, PLL_CTRL_4);
+	val &= ~BITS(3, 4);
+	an8855_reg_write(gsw, PLL_CTRL_4, val);
+
+	val = an8855_reg_read(gsw, PLL_CTRL_2);
+	val &= ~BIT(30);
+	an8855_reg_write(gsw, PLL_CTRL_2, val);
+
+	val = an8855_reg_read(gsw, SS_LCPLL_PWCTL_SETTING_2);
+	val &= ~(0x3 << 16);
+	val |= (0x1 << 16);
+	an8855_reg_write(gsw, SS_LCPLL_PWCTL_SETTING_2, val);
+
+	an8855_reg_write(gsw, SS_LCPLL_TDC_FLT_2, 0x7a000000);
+	an8855_reg_write(gsw, SS_LCPLL_TDC_PCW_1, 0x7a000000);
+
+	val = an8855_reg_read(gsw, SS_LCPLL_TDC_FLT_5);
+	val &= ~BIT(24);
+	an8855_reg_write(gsw, SS_LCPLL_TDC_FLT_5, val);
+
+	val = an8855_reg_read(gsw, PLL_CK_CTRL_0);
+	val &= ~BIT(8);
+	an8855_reg_write(gsw, PLL_CK_CTRL_0, val);
+
+	/* PLL - SS */
+	val = an8855_reg_read(gsw, PLL_CTRL_3);
+	val &= ~BITS(0, 15);
+	an8855_reg_write(gsw, PLL_CTRL_3, val);
+
+	val = an8855_reg_read(gsw, PLL_CTRL_4);
+	val &= ~BITS(0, 1);
+	an8855_reg_write(gsw, PLL_CTRL_4, val);
+
+	val = an8855_reg_read(gsw, PLL_CTRL_3);
+	val &= ~BITS(16, 31);
+	an8855_reg_write(gsw, PLL_CTRL_3, val);
+
+	/* PLL - TDC */
+	val = an8855_reg_read(gsw, PLL_CK_CTRL_0);
+	val &= ~BIT(9);
+	an8855_reg_write(gsw, PLL_CK_CTRL_0, val);
+
+	val = an8855_reg_read(gsw, RG_QP_PLL_SDM_ORD);
+	val |= BIT(3);
+	val |= BIT(4);
+	an8855_reg_write(gsw, RG_QP_PLL_SDM_ORD, val);
+
+	val = an8855_reg_read(gsw, RG_QP_RX_DAC_EN);
+	val &= ~(0x3 << 16);
+	val |= (0x2 << 16);
+	an8855_reg_write(gsw, RG_QP_RX_DAC_EN, val);
+
+	/* TCL Disable (only for Co-SIM) */
+	val = an8855_reg_read(gsw, PON_RXFEDIG_CTRL_0);
+	val &= ~BIT(12);
+	an8855_reg_write(gsw, PON_RXFEDIG_CTRL_0, val);
+
+	/* TX Init */
+	val = an8855_reg_read(gsw, RG_QP_TX_MODE_16B_EN);
+	val &= ~BIT(0);
+	val &= ~(0xffff << 16);
+	val |= (0x4 << 16);
+	an8855_reg_write(gsw, RG_QP_TX_MODE_16B_EN, val);
+
+	/* RX Control */
+	val = an8855_reg_read(gsw, RG_QP_RXAFE_RESERVE);
+	val |= BIT(11);
+	an8855_reg_write(gsw, RG_QP_RXAFE_RESERVE, val);
+
+	val = an8855_reg_read(gsw, RG_QP_CDR_LPF_MJV_LIM);
+	val &= ~(0x3 << 4);
+	val |= (0x1 << 4);
+	an8855_reg_write(gsw, RG_QP_CDR_LPF_MJV_LIM, val);
+
+	val = an8855_reg_read(gsw, RG_QP_CDR_LPF_SETVALUE);
+	val &= ~(0xf << 25);
+	val |= (0x1 << 25);
+	val &= ~(0x7 << 29);
+	val |= (0x6 << 29);
+	an8855_reg_write(gsw, RG_QP_CDR_LPF_SETVALUE, val);
+
+	val = an8855_reg_read(gsw, RG_QP_CDR_PR_CKREF_DIV1);
+	val &= ~(0x1f << 8);
+	val |= (0xf << 8);
+	an8855_reg_write(gsw, RG_QP_CDR_PR_CKREF_DIV1, val);
+
+	val = an8855_reg_read(gsw, RG_QP_CDR_PR_KBAND_DIV_PCIE);
+	val &= ~(0x3f << 0);
+	val |= (0x19 << 0);
+	val &= ~BIT(6);
+	an8855_reg_write(gsw, RG_QP_CDR_PR_KBAND_DIV_PCIE, val);
+
+	val = an8855_reg_read(gsw, RG_QP_CDR_FORCE_IBANDLPF_R_OFF);
+	val &= ~(0x7f << 6);
+	val |= (0x21 << 6);
+	val &= ~(0x3 << 16);
+	val |= (0x2 << 16);
+	val &= ~BIT(13);
+	an8855_reg_write(gsw, RG_QP_CDR_FORCE_IBANDLPF_R_OFF, val);
+
+	val = an8855_reg_read(gsw, RG_QP_CDR_PR_KBAND_DIV_PCIE);
+	val &= ~BIT(30);
+	an8855_reg_write(gsw, RG_QP_CDR_PR_KBAND_DIV_PCIE, val);
+
+	val = an8855_reg_read(gsw, RG_QP_CDR_PR_CKREF_DIV1);
+	val &= ~(0x7 << 24);
+	val |= (0x4 << 24);
+	an8855_reg_write(gsw, RG_QP_CDR_PR_CKREF_DIV1, val);
+
+	/* PMA (For HW Mode) */
+	val = an8855_reg_read(gsw, RX_CTRL_26);
+	val |= BIT(23);
+	val &= ~BIT(24);
+	val |= BIT(26);
+	an8855_reg_write(gsw, RX_CTRL_26, val);
+
+	val = an8855_reg_read(gsw, RX_DLY_0);
+	val &= ~(0xff << 0);
+	val |= (0x6f << 0);
+	val |= BITS(8, 13);
+	an8855_reg_write(gsw, RX_DLY_0, val);
+
+	val = an8855_reg_read(gsw, RX_CTRL_42);
+	val &= ~(0x1fff << 0);
+	val |= (0x150 << 0);
+	an8855_reg_write(gsw, RX_CTRL_42, val);
+
+	val = an8855_reg_read(gsw, RX_CTRL_2);
+	val &= ~(0x1fff << 16);
+	val |= (0x150 << 16);
+	an8855_reg_write(gsw, RX_CTRL_2, val);
+
+	val = an8855_reg_read(gsw, PON_RXFEDIG_CTRL_9);
+	val &= ~(0x7 << 0);
+	val |= (0x1 << 0);
+	an8855_reg_write(gsw, PON_RXFEDIG_CTRL_9, val);
+
+	val = an8855_reg_read(gsw, RX_CTRL_8);
+	val &= ~(0xfff << 16);
+	val |= (0x200 << 16);
+	val &= ~(0x7fff << 0);
+	val |= (0xfff << 0);
+	an8855_reg_write(gsw, RX_CTRL_8, val);
+
+	/* Frequency memter */
+	val = an8855_reg_read(gsw, RX_CTRL_5);
+	val &= ~(0xfffff << 10);
+	val |= (0x10 << 10);
+	an8855_reg_write(gsw, RX_CTRL_5, val);
+
+	val = an8855_reg_read(gsw, RX_CTRL_6);
+	val &= ~(0xfffff << 0);
+	val |= (0x64 << 0);
+	an8855_reg_write(gsw, RX_CTRL_6, val);
+
+	val = an8855_reg_read(gsw, RX_CTRL_7);
+	val &= ~(0xfffff << 0);
+	val |= (0x2710 << 0);
+	an8855_reg_write(gsw, RX_CTRL_7, val);
+
+	val = an8855_reg_read(gsw, PLL_CTRL_0);
+	val |= BIT(0);
+	an8855_reg_write(gsw, PLL_CTRL_0, val);
+
+	/* PCS Init */
+	val = an8855_reg_read(gsw, RG_HSGMII_PCS_CTROL_1);
+	val &= ~BIT(30);
+	an8855_reg_write(gsw, RG_HSGMII_PCS_CTROL_1, val);
+
+	/* Rate Adaption */
+	val = an8855_reg_read(gsw, RATE_ADP_P0_CTRL_0);
+	val &= ~BIT(31);
+	an8855_reg_write(gsw, RATE_ADP_P0_CTRL_0, val);
+
+	val = an8855_reg_read(gsw, RG_RATE_ADAPT_CTRL_0);
+	val |= BIT(0);
+	val |= BIT(4);
+	val |= BITS(26, 27);
+	an8855_reg_write(gsw, RG_RATE_ADAPT_CTRL_0, val);
+
+	/* Disable AN */
+	val = an8855_reg_read(gsw, SGMII_REG_AN0);
+	val &= ~BIT(12);
+	an8855_reg_write(gsw, SGMII_REG_AN0, val);
+
+	/* Force Speed */
+	val = an8855_reg_read(gsw, SGMII_STS_CTRL_0);
+	val |= BIT(2);
+	val |= BITS(4, 5);
+	an8855_reg_write(gsw, SGMII_STS_CTRL_0, val);
+
+	/* bypass flow control to MAC */
+	an8855_reg_write(gsw, MSG_RX_LIK_STS_0, 0x01010107);
+	an8855_reg_write(gsw, MSG_RX_LIK_STS_2, 0x00000EEF);
+
+	return 0;
+}
+
+static int an8855_sgmii_setup(struct gsw_an8855 *gsw, int mode)
+{
+	u32 val = 0;
+
+	/* TX FIR - improve TX EYE */
+	val = an8855_reg_read(gsw, INTF_CTRL_10);
+	val &= ~(0x3f << 16);
+	val |= BIT(21);
+	val &= ~(0x1f << 24);
+	val |= BIT(29);
+	an8855_reg_write(gsw, INTF_CTRL_10, val);
+
+	val = an8855_reg_read(gsw, INTF_CTRL_11);
+	val &= ~(0x3f);
+	val |= (0xd << 0);
+	val |= BIT(6);
+	an8855_reg_write(gsw, INTF_CTRL_11, val);
+
+	/* RX CDR - improve RX Jitter Tolerance */
+	val = an8855_reg_read(gsw, RG_QP_CDR_LPF_BOT_LIM);
+	val &= ~(0x7 << 24);
+	val |= (0x6 << 24);
+	val &= ~(0x7 << 20);
+	val |= (0x6 << 20);
+	an8855_reg_write(gsw, RG_QP_CDR_LPF_BOT_LIM, val);
+
+	/* PMA Init */
+	/* PLL */
+	val = an8855_reg_read(gsw, QP_DIG_MODE_CTRL_1);
+	val &= ~BITS(2, 3);
+	an8855_reg_write(gsw, QP_DIG_MODE_CTRL_1, val);
+
+	/* PLL - LPF */
+	val = an8855_reg_read(gsw, PLL_CTRL_2);
+	val &= ~(0x3 << 0);
+	val |= (0x1 << 0);
+	val &= ~(0x7 << 2);
+	val |= (0x5 << 2);
+	val &= ~BITS(6, 7);
+	val &= ~(0x7 << 8);
+	val |= (0x3 << 8);
+	val |= BIT(29);
+	val &= ~BITS(12, 13);
+	an8855_reg_write(gsw, PLL_CTRL_2, val);
+
+	/* PLL - ICO */
+	val = an8855_reg_read(gsw, PLL_CTRL_4);
+	val |= BIT(2);
+	an8855_reg_write(gsw, PLL_CTRL_4, val);
+
+	val = an8855_reg_read(gsw, PLL_CTRL_2);
+	val &= ~BIT(14);
+	an8855_reg_write(gsw, PLL_CTRL_2, val);
+
+	/* PLL - CHP */
+	val = an8855_reg_read(gsw, PLL_CTRL_2);
+	val &= ~(0xf << 16);
+	val |= (0x4 << 16);
+	an8855_reg_write(gsw, PLL_CTRL_2, val);
+
+	/* PLL - PFD */
+	val = an8855_reg_read(gsw, PLL_CTRL_2);
+	val &= ~(0x3 << 20);
+	val |= (0x1 << 20);
+	val &= ~(0x3 << 24);
+	val |= (0x1 << 24);
+	val &= ~BIT(26);
+	an8855_reg_write(gsw, PLL_CTRL_2, val);
+
+	/* PLL - POSTDIV */
+	val = an8855_reg_read(gsw, PLL_CTRL_2);
+	val |= BIT(22);
+	val &= ~BIT(27);
+	val &= ~BIT(28);
+	an8855_reg_write(gsw, PLL_CTRL_2, val);
+
+	/* PLL - SDM */
+	val = an8855_reg_read(gsw, PLL_CTRL_4);
+	val &= ~BITS(3, 4);
+	an8855_reg_write(gsw, PLL_CTRL_4, val);
+
+	val = an8855_reg_read(gsw, PLL_CTRL_2);
+	val &= ~BIT(30);
+	an8855_reg_write(gsw, PLL_CTRL_2, val);
+
+	val = an8855_reg_read(gsw, SS_LCPLL_PWCTL_SETTING_2);
+	val &= ~(0x3 << 16);
+	val |= (0x1 << 16);
+	an8855_reg_write(gsw, SS_LCPLL_PWCTL_SETTING_2, val);
+
+	an8855_reg_write(gsw, SS_LCPLL_TDC_FLT_2, 0x48000000);
+	an8855_reg_write(gsw, SS_LCPLL_TDC_PCW_1, 0x48000000);
+
+	val = an8855_reg_read(gsw, SS_LCPLL_TDC_FLT_5);
+	val &= ~BIT(24);
+	an8855_reg_write(gsw, SS_LCPLL_TDC_FLT_5, val);
+
+	val = an8855_reg_read(gsw, PLL_CK_CTRL_0);
+	val &= ~BIT(8);
+	an8855_reg_write(gsw, PLL_CK_CTRL_0, val);
+
+	/* PLL - SS */
+	val = an8855_reg_read(gsw, PLL_CTRL_3);
+	val &= ~BITS(0, 15);
+	an8855_reg_write(gsw, PLL_CTRL_3, val);
+
+	val = an8855_reg_read(gsw, PLL_CTRL_4);
+	val &= ~BITS(0, 1);
+	an8855_reg_write(gsw, PLL_CTRL_4, val);
+
+	val = an8855_reg_read(gsw, PLL_CTRL_3);
+	val &= ~BITS(16, 31);
+	an8855_reg_write(gsw, PLL_CTRL_3, val);
+
+	/* PLL - TDC */
+	val = an8855_reg_read(gsw, PLL_CK_CTRL_0);
+	val &= ~BIT(9);
+	an8855_reg_write(gsw, PLL_CK_CTRL_0, val);
+
+	val = an8855_reg_read(gsw, RG_QP_PLL_SDM_ORD);
+	val |= BIT(3);
+	val |= BIT(4);
+	an8855_reg_write(gsw, RG_QP_PLL_SDM_ORD, val);
+
+	val = an8855_reg_read(gsw, RG_QP_RX_DAC_EN);
+	val &= ~(0x3 << 16);
+	val |= (0x2 << 16);
+	an8855_reg_write(gsw, RG_QP_RX_DAC_EN, val);
+
+	/* PLL - TCL Disable (only for Co-SIM) */
+	val = an8855_reg_read(gsw, PON_RXFEDIG_CTRL_0);
+	val &= ~BIT(12);
+	an8855_reg_write(gsw, PON_RXFEDIG_CTRL_0, val);
+
+	/* TX Init */
+	val = an8855_reg_read(gsw, RG_QP_TX_MODE_16B_EN);
+	val &= ~BIT(0);
+	val &= ~BITS(16, 31);
+	an8855_reg_write(gsw, RG_QP_TX_MODE_16B_EN, val);
+
+	/* RX Init */
+	val = an8855_reg_read(gsw, RG_QP_RXAFE_RESERVE);
+	val |= BIT(11);
+	an8855_reg_write(gsw, RG_QP_RXAFE_RESERVE, val);
+
+	val = an8855_reg_read(gsw, RG_QP_CDR_LPF_MJV_LIM);
+	val &= ~(0x3 << 4);
+	val |= (0x2 << 4);
+	an8855_reg_write(gsw, RG_QP_CDR_LPF_MJV_LIM, val);
+
+	val = an8855_reg_read(gsw, RG_QP_CDR_LPF_SETVALUE);
+	val &= ~(0xf << 25);
+	val |= (0x1 << 25);
+	val &= ~(0x7 << 29);
+	val |= (0x6 << 29);
+	an8855_reg_write(gsw, RG_QP_CDR_LPF_SETVALUE, val);
+
+	val = an8855_reg_read(gsw, RG_QP_CDR_PR_CKREF_DIV1);
+	val &= ~(0x1f << 8);
+	val |= (0xc << 8);
+	an8855_reg_write(gsw, RG_QP_CDR_PR_CKREF_DIV1, val);
+
+	val = an8855_reg_read(gsw, RG_QP_CDR_PR_KBAND_DIV_PCIE);
+	val &= ~(0x3f << 0);
+	val |= (0x19 << 0);
+	val &= ~BIT(6);
+	an8855_reg_write(gsw, RG_QP_CDR_PR_KBAND_DIV_PCIE, val);
+
+	val = an8855_reg_read(gsw, RG_QP_CDR_FORCE_IBANDLPF_R_OFF);
+	val &= ~(0x7f << 6);
+	val |= (0x21 << 6);
+	val &= ~(0x3 << 16);
+	val |= (0x2 << 16);
+	val &= ~BIT(13);
+	an8855_reg_write(gsw, RG_QP_CDR_FORCE_IBANDLPF_R_OFF, val);
+
+	val = an8855_reg_read(gsw, RG_QP_CDR_PR_KBAND_DIV_PCIE);
+	val &= ~BIT(30);
+	an8855_reg_write(gsw, RG_QP_CDR_PR_KBAND_DIV_PCIE, val);
+
+	val = an8855_reg_read(gsw, RG_QP_CDR_PR_CKREF_DIV1);
+	val &= ~(0x7 << 24);
+	val |= (0x4 << 24);
+	an8855_reg_write(gsw, RG_QP_CDR_PR_CKREF_DIV1, val);
+
+	/* PMA (For HW Mode) */
+	val = an8855_reg_read(gsw, RX_CTRL_26);
+	val |= BIT(23);
+	val &= ~BIT(24);
+		val |= BIT(26);
+
+	an8855_reg_write(gsw, RX_CTRL_26, val);
+
+	val = an8855_reg_read(gsw, RX_DLY_0);
+	val &= ~(0xff << 0);
+	val |= (0x6f << 0);
+	val |= BITS(8, 13);
+	an8855_reg_write(gsw, RX_DLY_0, val);
+
+	val = an8855_reg_read(gsw, RX_CTRL_42);
+	val &= ~(0x1fff << 0);
+	val |= (0x150 << 0);
+	an8855_reg_write(gsw, RX_CTRL_42, val);
+
+	val = an8855_reg_read(gsw, RX_CTRL_2);
+	val &= ~(0x1fff << 16);
+	val |= (0x150 << 16);
+	an8855_reg_write(gsw, RX_CTRL_2, val);
+
+	val = an8855_reg_read(gsw, PON_RXFEDIG_CTRL_9);
+	val &= ~(0x7 << 0);
+	val |= (0x1 << 0);
+	an8855_reg_write(gsw, PON_RXFEDIG_CTRL_9, val);
+
+	val = an8855_reg_read(gsw, RX_CTRL_8);
+	val &= ~(0xfff << 16);
+	val |= (0x200 << 16);
+	val &= ~(0x7fff << 0);
+	val |= (0xfff << 0);
+	an8855_reg_write(gsw, RX_CTRL_8, val);
+
+	/* Frequency memter */
+	val = an8855_reg_read(gsw, RX_CTRL_5);
+	val &= ~(0xfffff << 10);
+	val |= (0x28 << 10);
+	an8855_reg_write(gsw, RX_CTRL_5, val);
+
+	val = an8855_reg_read(gsw, RX_CTRL_6);
+	val &= ~(0xfffff << 0);
+	val |= (0x64 << 0);
+	an8855_reg_write(gsw, RX_CTRL_6, val);
+
+	val = an8855_reg_read(gsw, RX_CTRL_7);
+	val &= ~(0xfffff << 0);
+	val |= (0x2710 << 0);
+	an8855_reg_write(gsw, RX_CTRL_7, val);
+
+	val = an8855_reg_read(gsw, PLL_CTRL_0);
+	val |= BIT(0);
+	an8855_reg_write(gsw, PLL_CTRL_0, val);
+
+	if (mode == SGMII_MODE_FORCE) {
+		/* PCS Init */
+		val = an8855_reg_read(gsw, QP_DIG_MODE_CTRL_0);
+		val &= ~BIT(0);
+		val &= ~BITS(4, 5);
+		an8855_reg_write(gsw, QP_DIG_MODE_CTRL_0, val);
+
+		val = an8855_reg_read(gsw, RG_HSGMII_PCS_CTROL_1);
+		val &= ~BIT(30);
+		an8855_reg_write(gsw, RG_HSGMII_PCS_CTROL_1, val);
+
+		/* Rate Adaption - GMII path config. */
+		val = an8855_reg_read(gsw, RG_AN_SGMII_MODE_FORCE);
+		val |= BIT(0);
+		val &= ~BITS(4, 5);
+		an8855_reg_write(gsw, RG_AN_SGMII_MODE_FORCE, val);
+
+		val = an8855_reg_read(gsw, SGMII_STS_CTRL_0);
+		val |= BIT(2);
+		val &= ~(0x3 << 4);
+		val |= (0x2 << 4);
+		an8855_reg_write(gsw, SGMII_STS_CTRL_0, val);
+
+		val = an8855_reg_read(gsw, SGMII_REG_AN0);
+		val &= ~BIT(12);
+		an8855_reg_write(gsw, SGMII_REG_AN0, val);
+
+		val = an8855_reg_read(gsw, PHY_RX_FORCE_CTRL_0);
+		val |= BIT(4);
+		an8855_reg_write(gsw, PHY_RX_FORCE_CTRL_0, val);
+
+		val = an8855_reg_read(gsw, RATE_ADP_P0_CTRL_0);
+		val &= ~BITS(0, 3);
+		val |= BIT(28);
+		an8855_reg_write(gsw, RATE_ADP_P0_CTRL_0, val);
+
+		val = an8855_reg_read(gsw, RG_RATE_ADAPT_CTRL_0);
+		val |= BIT(0);
+		val |= BIT(4);
+		val |= BITS(26, 27);
+		an8855_reg_write(gsw, RG_RATE_ADAPT_CTRL_0, val);
+	} else {
+		/* PCS Init */
+		val = an8855_reg_read(gsw, RG_HSGMII_PCS_CTROL_1);
+		val &= ~BIT(30);
+		an8855_reg_write(gsw, RG_HSGMII_PCS_CTROL_1, val);
+
+		/* Set AN Ability - Interrupt */
+		val = an8855_reg_read(gsw, SGMII_REG_AN_FORCE_CL37);
+		val |= BIT(0);
+		an8855_reg_write(gsw, SGMII_REG_AN_FORCE_CL37, val);
+
+		val = an8855_reg_read(gsw, SGMII_REG_AN_13);
+		val &= ~(0x3f << 0);
+		val |= (0xb << 0);
+		val |= BIT(8);
+		an8855_reg_write(gsw, SGMII_REG_AN_13, val);
+
+		/* Rate Adaption - GMII path config. */
+		val = an8855_reg_read(gsw, SGMII_REG_AN0);
+		val |= BIT(12);
+		an8855_reg_write(gsw, SGMII_REG_AN0, val);
+
+		val = an8855_reg_read(gsw, MII_RA_AN_ENABLE);
+		val |= BIT(0);
+		an8855_reg_write(gsw, MII_RA_AN_ENABLE, val);
+
+		val = an8855_reg_read(gsw, RATE_ADP_P0_CTRL_0);
+		val |= BIT(28);
+		an8855_reg_write(gsw, RATE_ADP_P0_CTRL_0, val);
+
+		val = an8855_reg_read(gsw, RG_RATE_ADAPT_CTRL_0);
+		val |= BIT(0);
+		val |= BIT(4);
+		val |= BITS(26, 27);
+		an8855_reg_write(gsw, RG_RATE_ADAPT_CTRL_0, val);
+
+		/* Only for Co-SIM */
+
+		/* AN Speed up (Only for Co-SIM) */
+
+		/* Restart AN */
+		val = an8855_reg_read(gsw, SGMII_REG_AN0);
+		val |= BIT(9);
+		an8855_reg_write(gsw, SGMII_REG_AN0, val);
+	}
+
+	/* bypass flow control to MAC */
+	an8855_reg_write(gsw, MSG_RX_LIK_STS_0, 0x01010107);
+	an8855_reg_write(gsw, MSG_RX_LIK_STS_2, 0x00000EEF);
+
+	return 0;
+}
+
+static int an8855_set_port_rmii(struct gsw_an8855 *gsw)
+{
+	an8855_reg_write(gsw, RG_P5MUX_MODE, 0x301);
+	an8855_reg_write(gsw, RG_FORCE_CKDIR_SEL, 0x101);
+	an8855_reg_write(gsw, RG_SWITCH_MODE, 0x101);
+	an8855_reg_write(gsw, RG_FORCE_MAC5_SB, 0x1010101);
+	an8855_reg_write(gsw, CSR_RMII, 0x420102);
+	an8855_reg_write(gsw, RG_RGMII_TXCK_C, 0x1100910);
+	return 0;
+}
+
+static int an8855_set_port_rgmii(struct gsw_an8855 *gsw)
+{
+	an8855_reg_write(gsw, RG_FORCE_MAC5_SB, 0x20101);
+	return 0;
+}
+
+static int an8855_mac_port_setup(struct gsw_an8855 *gsw, u32 port,
+				 struct an8855_port_cfg *port_cfg)
+{
+	u32 pmcr;
+
+	if (port != 5) {
+		dev_info(gsw->dev, "port %d is not a MAC port\n", port);
+		return -EINVAL;
+	}
+
+	if (port_cfg->enabled) {
+		pmcr = an8855_reg_read(gsw, PMCR(5));
+
+		switch (port_cfg->phy_mode) {
+		case PHY_INTERFACE_MODE_RMII:
+			pmcr &= ~FORCE_SPD;
+			pmcr |= FORCE_MODE | (MAC_SPD_100 << 28) | FORCE_DPX
+				| FORCE_LNK | FORCE_TX_FC | FORCE_RX_FC;
+			an8855_set_port_rmii(gsw);
+			break;
+		case PHY_INTERFACE_MODE_RGMII:
+			pmcr &= ~FORCE_SPD;
+			pmcr |= FORCE_MODE | (MAC_SPD_1000 << 28) | FORCE_DPX
+				| FORCE_LNK | FORCE_TX_FC | FORCE_RX_FC;
+			an8855_set_port_rgmii(gsw);
+			break;
+		case PHY_INTERFACE_MODE_SGMII:
+			if (port_cfg->force_link) {
+				pmcr &= ~FORCE_SPD;
+				pmcr |= FORCE_MODE | (MAC_SPD_1000 << 28)
+					 | FORCE_DPX | FORCE_LNK | FORCE_TX_FC
+					 | FORCE_RX_FC;
+				an8855_sgmii_setup(gsw, SGMII_MODE_FORCE);
+			} else
+				an8855_sgmii_setup(gsw, SGMII_MODE_AN);
+			break;
+		case PHY_INTERFACE_MODE_2500BASEX:
+			pmcr &= ~FORCE_SPD;
+			pmcr |= FORCE_MODE | (MAC_SPD_2500 << 28) | FORCE_DPX
+				| FORCE_LNK | FORCE_TX_FC | FORCE_RX_FC;
+			an8855_set_hsgmii_mode(gsw);
+			break;
+		default:
+			dev_info(gsw->dev, "%s is not supported by port %d\n",
+				 phy_modes(port_cfg->phy_mode), port);
+		}
+
+		/* disable eee on cpu port */
+		pmcr &= ~(FORCE_EEE100 | FORCE_EEE1G | FORCE_EEE2P5G);
+
+		if (port_cfg->force_link)
+			an8855_reg_write(gsw, PMCR(port), pmcr);
+	}
+
+	return 0;
+}
+
+static int an8855_sw_detect(struct gsw_an8855 *gsw, struct chip_rev *crev)
+{
+	u32 id, rev;
+
+	id = an8855_reg_read(gsw, CHIP_ID);
+	rev = an8855_reg_read(gsw, CHIP_REV);
+	if (id == AN8855) {
+		if (crev) {
+			crev->rev = rev;
+			crev->name = "AN8855";
+		}
+
+		return 0;
+	}
+
+	return -ENODEV;
+}
+
+static void an8855_phy_setting(struct gsw_an8855 *gsw)
+{
+	int i, j;
+	u8 shift_sel = 0, rsel_tx_a = 0, rsel_tx_b = 0;
+	u8 rsel_tx_c = 0, rsel_tx_d = 0;
+	u16 cl45_data = 0;
+	u32 val;
+
+	/* Release power down */
+	an8855_reg_write(gsw, RG_GPHY_AFE_PWD, 0x0);
+
+	for (i = 0; i < AN8855_NUM_PHYS; i++) {
+		/* Enable HW auto downshift */
+		gsw->mii_write(gsw, i, 0x1f, 0x1);
+		val = gsw->mii_read(gsw, i, PHY_EXT_REG_14);
+		val |= PHY_EN_DOWN_SHFIT;
+		gsw->mii_write(gsw, i, PHY_EXT_REG_14, val);
+		gsw->mii_write(gsw, i, 0x1f, 0x0);
+
+		/* Enable Asymmetric Pause Capability */
+		val = gsw->mii_read(gsw, i, MII_ADVERTISE);
+		val |= ADVERTISE_PAUSE_ASYM;
+		gsw->mii_write(gsw, i, MII_ADVERTISE, val);
+	}
+
+	if (gsw->extSurge) {
+		for (i = 0; i < AN8855_NUM_PHYS; i++) {
+			/* Read data */
+			for (j = 0; j < AN8855_WORD_SIZE; j++) {
+				val = an8855_reg_read(gsw, AN8855_EFUSE_DATA0 +
+					(AN8855_WORD_SIZE * (3 + j + (4 * i))));
+
+				shift_sel = shift_check((val & 0x7f000000) >> 24);
+				switch (j) {
+				case 0:
+					rsel_tx_a = get_shift_val(shift_sel);
+					break;
+				case 1:
+					rsel_tx_b = get_shift_val(shift_sel);
+					break;
+				case 2:
+					rsel_tx_c = get_shift_val(shift_sel);
+					break;
+				case 3:
+					rsel_tx_d = get_shift_val(shift_sel);
+					break;
+				default:
+					continue;
+				}
+			}
+			cl45_data = gsw->mmd_read(gsw, i, PHY_DEV1E, 0x174);
+			cl45_data &= ~(0x7f7f);
+			cl45_data |= (rsel_tx_a << 8);
+			cl45_data |= rsel_tx_b;
+			gsw->mmd_write(gsw, i, PHY_DEV1E, 0x174, cl45_data);
+			cl45_data = gsw->mmd_read(gsw, i, PHY_DEV1E, 0x175);
+			cl45_data &= ~(0x7f7f);
+			cl45_data |= (rsel_tx_c << 8);
+			cl45_data |= rsel_tx_d;
+			gsw->mmd_write(gsw, i, PHY_DEV1E, 0x175, cl45_data);
+		}
+	}
+}
+
+static void an8855_eee_setting(struct gsw_an8855 *gsw, u32 port)
+{
+	/* Disable EEE */
+	gsw->mmd_write(gsw, port, PHY_DEV07, PHY_DEV07_REG_03C, 0);
+}
+
+static int an8855_led_set_usr_def(struct gsw_an8855 *gsw, u8 entity,
+		int polar, u16 on_evt, u16 blk_evt, u8 led_freq)
+{
+	u32 cl45_data = 0;
+
+	if (polar == LED_HIGH)
+		on_evt |= LED_ON_POL;
+	else
+		on_evt &= ~LED_ON_POL;
+
+	/* LED on event */
+	gsw->mmd_write(gsw, (entity / 4), PHY_DEV1E,
+		PHY_SINGLE_LED_ON_CTRL(entity % 4), on_evt | LED_ON_EN);
+
+	/* LED blink event */
+	gsw->mmd_write(gsw, (entity / 4), PHY_DEV1E,
+		PHY_SINGLE_LED_BLK_CTRL(entity % 4), blk_evt);
+
+	/* LED freq */
+	switch (led_freq) {
+	case AIR_LED_BLK_DUR_32M:
+		cl45_data = 0x30e;
+		break;
+	case AIR_LED_BLK_DUR_64M:
+		cl45_data = 0x61a;
+		break;
+	case AIR_LED_BLK_DUR_128M:
+		cl45_data = 0xc35;
+		break;
+	case AIR_LED_BLK_DUR_256M:
+		cl45_data = 0x186a;
+		break;
+	case AIR_LED_BLK_DUR_512M:
+		cl45_data = 0x30d4;
+		break;
+	case AIR_LED_BLK_DUR_1024M:
+		cl45_data = 0x61a8;
+		break;
+	default:
+		break;
+	}
+	gsw->mmd_write(gsw, (entity / 4), PHY_DEV1E,
+		PHY_SINGLE_LED_BLK_DUR(entity % 4), cl45_data);
+
+	gsw->mmd_write(gsw, (entity / 4), PHY_DEV1E,
+		PHY_SINGLE_LED_ON_DUR(entity % 4), (cl45_data >> 1));
+
+	/* Disable DATA & BAD_SSD for port LED blink behavior */
+	cl45_data = gsw->mmd_read(gsw, (entity / 4), PHY_DEV1E,
+		PHY_PMA_CTRL);
+	cl45_data &= ~BIT(0);
+	cl45_data &= ~BIT(15);
+	gsw->mmd_write(gsw, (entity / 4), PHY_DEV1E,
+		PHY_PMA_CTRL, cl45_data);
+
+	return 0;
+}
+
+static int an8855_led_set_mode(struct gsw_an8855 *gsw, u8 mode)
+{
+	u16 cl45_data;
+
+	cl45_data = gsw->mmd_read(gsw, 0, PHY_DEV1F, PHY_LED_BCR);
+	switch (mode) {
+	case AN8855_LED_MODE_DISABLE:
+		cl45_data &= ~LED_BCR_EXT_CTRL;
+		cl45_data &= ~LED_BCR_MODE_MASK;
+		cl45_data |= LED_BCR_MODE_DISABLE;
+		break;
+	case AN8855_LED_MODE_USER_DEFINE:
+		cl45_data |= LED_BCR_EXT_CTRL;
+		cl45_data |= LED_BCR_CLK_EN;
+		break;
+	default:
+		dev_info(gsw->dev, "LED mode%d is not supported!\n", mode);
+		return -EINVAL;
+	}
+	gsw->mmd_write(gsw, 0, PHY_DEV1F, PHY_LED_BCR, cl45_data);
+
+	return 0;
+}
+
+static int an8855_led_set_state(struct gsw_an8855 *gsw, u8 entity, u8 state)
+{
+	u16 cl45_data = 0;
+
+	/* Change to per port contorl */
+	cl45_data = gsw->mmd_read(gsw, (entity / 4), PHY_DEV1E,
+		PHY_LED_CTRL_SELECT);
+
+	if (state == 1)
+		cl45_data |= (1 << (entity % 4));
+	else
+		cl45_data &= ~(1 << (entity % 4));
+	gsw->mmd_write(gsw, (entity / 4), PHY_DEV1E,
+		PHY_LED_CTRL_SELECT, cl45_data);
+
+	/* LED enable setting */
+	cl45_data = gsw->mmd_read(gsw, (entity / 4),
+		PHY_DEV1E, PHY_SINGLE_LED_ON_CTRL(entity % 4));
+
+	if (state == 1)
+		cl45_data |= LED_ON_EN;
+	else
+		cl45_data &= ~LED_ON_EN;
+
+	gsw->mmd_write(gsw, (entity / 4), PHY_DEV1E,
+		PHY_SINGLE_LED_ON_CTRL(entity % 4), cl45_data);
+
+	return 0;
+}
+
+static int an8855_led_init(struct gsw_an8855 *gsw)
+{
+	u32 val, led_count = ARRAY_SIZE(led_cfg);
+	int ret = 0, id;
+	u32 tmp_val = 0;
+	u32 tmp_id = 0;
+
+	ret = an8855_led_set_mode(gsw, AN8855_LED_MODE_USER_DEFINE);
+	if (ret != 0) {
+		dev_info(gsw->dev, "led_set_mode fail(ret:%d)!\n", ret);
+		return ret;
+	}
+
+	for (id = 0; id < led_count; id++) {
+		ret = an8855_led_set_state(gsw,
+			led_cfg[id].phy_led_idx, led_cfg[id].en);
+		if (ret != 0) {
+			dev_info(gsw->dev, "led_set_state fail(ret:%d)!\n", ret);
+			return ret;
+		}
+		if (led_cfg[id].en == 1) {
+			ret = an8855_led_set_usr_def(gsw,
+				led_cfg[id].phy_led_idx,
+				led_cfg[id].pol, led_cfg[id].on_cfg,
+				led_cfg[id].blk_cfg,
+				led_cfg[id].led_freq);
+			if (ret != 0) {
+				dev_info(gsw->dev, "led_set_usr_def fail!\n");
+				return ret;
+			}
+		}
+	}
+
+	/* Setting for System LED & Loop LED */
+	an8855_reg_write(gsw, RG_GPIO_OE, 0x0);
+	an8855_reg_write(gsw, RG_GPIO_CTRL, 0x0);
+	val = 0;
+	an8855_reg_write(gsw, RG_GPIO_L_INV, val);
+
+	val = 0x1001;
+	an8855_reg_write(gsw, RG_GPIO_CTRL, val);
+	val = an8855_reg_read(gsw, RG_GPIO_DATA);
+	val |= BITS(1, 3);
+	val &= ~(BIT(0));
+	val &= ~(BIT(6));
+
+	an8855_reg_write(gsw, RG_GPIO_DATA, val);
+	val = an8855_reg_read(gsw, RG_GPIO_OE);
+	val |= 0x41;
+	an8855_reg_write(gsw, RG_GPIO_OE, val);
+
+	/* Mapping between GPIO & LED */
+	val = 0;
+	for (id = 0; id < led_count; id++) {
+		/* Skip GPIO6, due to GPIO6 does not support PORT LED */
+		if (id == 6)
+			continue;
+
+		if (led_cfg[id].en == 1) {
+			if (id < 7)
+				val |= led_cfg[id].phy_led_idx << ((id % 4) * 8);
+			else
+				val |= led_cfg[id].phy_led_idx << (((id - 1) % 4) * 8);
+		}
+
+		if (id < 7)
+			tmp_id = id;
+		else
+			tmp_id = id - 1;
+
+		if ((tmp_id % 4) == 0x3) {
+			an8855_reg_write(gsw, RG_GPIO_LED_SEL(tmp_id / 4), val);
+			tmp_val = an8855_reg_read(gsw, RG_GPIO_LED_SEL(tmp_id / 4));
+			val = 0;
+		}
+	}
+
+	/* Turn on LAN LED mode */
+	val = 0;
+	for (id = 0; id < led_count; id++) {
+		if (led_cfg[id].en == 1)
+			val |= 0x1 << id;
+	}
+	an8855_reg_write(gsw, RG_GPIO_LED_MODE, val);
+
+	/* Force clear blink pulse for per port LED */
+	gsw->mmd_write(gsw, 0, PHY_DEV1F, PHY_LED_BLINK_DUR_CTRL, 0x1f);
+	usleep_range(1000, 5000);
+	gsw->mmd_write(gsw, 0, PHY_DEV1F, PHY_LED_BLINK_DUR_CTRL, 0);
+
+	return 0;
+}
+
+static int an8855_sw_init(struct gsw_an8855 *gsw)
+{
+	int i, ret = 0;
+	u32 val, led_count = ARRAY_SIZE(led_cfg);
+	int id;
+
+	gsw->phy_base = gsw->smi_addr & AN8855_SMI_ADDR_MASK;
+
+	gsw->mii_read = an8855_mii_read;
+	gsw->mii_write = an8855_mii_write;
+	gsw->mmd_read = an8855_mmd_read;
+	gsw->mmd_write = an8855_mmd_write;
+
+	/* Force MAC link down before reset */
+	an8855_reg_write(gsw, PMCR(5), FORCE_MODE);
+
+	/* Switch soft reset */
+	an8855_reg_write(gsw, SYS_CTRL, SW_SYS_RST);
+	usleep_range(100000, 110000);
+
+	/* Change gphy smi address */
+	if (gsw->new_smi_addr != gsw->smi_addr) {
+		an8855_reg_write(gsw, RG_GPHY_SMI_ADDR, gsw->new_smi_addr);
+		gsw->smi_addr = gsw->new_smi_addr;
+		gsw->phy_base = gsw->new_smi_addr;
+	}
+
+	for (i = 0; i < AN8855_NUM_PHYS; i++) {
+		val = gsw->mii_read(gsw, i, MII_BMCR);
+		val |= BMCR_ISOLATE;
+		gsw->mii_write(gsw, i, MII_BMCR, val);
+	}
+
+	/* AN8855H need to setup before switch init */
+	val = an8855_reg_read(gsw, PKG_SEL);
+	if ((val & 0x7) == PAG_SEL_AN8855H) {
+
+		/* Invert for LED activity change */
+		val = an8855_reg_read(gsw, RG_GPIO_L_INV);
+		for (id = 0; id < led_count; id++) {
+			if ((led_cfg[id].pol == LED_HIGH) &&
+				(led_cfg[id].en == 1))
+				val |= 0x1 << id;
+		}
+		an8855_reg_write(gsw, RG_GPIO_L_INV, (val | 0x1));
+
+		/* MCU NOP CMD */
+		an8855_reg_write(gsw, RG_GDMP_RAM, 0x846);
+		an8855_reg_write(gsw, RG_GDMP_RAM + 4, 0x4a);
+
+		/* Enable MCU */
+		val = an8855_reg_read(gsw, RG_CLK_CPU_ICG);
+		an8855_reg_write(gsw, RG_CLK_CPU_ICG, val | MCU_ENABLE);
+		usleep_range(1000, 5000);
+
+		/* Disable MCU watchdog */
+		val = an8855_reg_read(gsw, RG_TIMER_CTL);
+		an8855_reg_write(gsw, RG_TIMER_CTL, (val & (~WDOG_ENABLE)));
+
+		/* Configure interrupt */
+		an8855_reg_write(gsw, RG_INTB_MODE, (0x1 << gsw->intr_pin));
+
+		/* LED settings for T830 reference board */
+		ret = an8855_led_init(gsw);
+		if (ret < 0) {
+			dev_info(gsw->dev, "an8855_led_init fail. (ret=%d)\n", ret);
+			return ret;
+		}
+	}
+
+	/* Adjust to reduce noise */
+	for (i = 0; i < AN8855_NUM_PHYS; i++) {
+		gsw->mmd_write(gsw, i, PHY_DEV1E,
+			PHY_TX_PAIR_DLY_SEL_GBE, 0x4040);
+
+		gsw->mmd_write(gsw, i, PHY_DEV1E,
+			PHY_RXADC_CTRL, 0x1010);
+
+		gsw->mmd_write(gsw, i, PHY_DEV1E,
+			PHY_RXADC_REV_0, 0x100);
+
+		gsw->mmd_write(gsw, i, PHY_DEV1E,
+			PHY_RXADC_REV_1, 0x100);
+	}
+
+	/* Setup SERDES port 5 */
+	an8855_mac_port_setup(gsw, 5, &gsw->port5_cfg);
+
+	/* Global mac control settings */
+	val = an8855_reg_read(gsw, GMACCR);
+	val |= (15 << MAX_RX_JUMBO_S) | RX_PKT_LEN_MAX_JUMBO;
+	an8855_reg_write(gsw, GMACCR, val);
+
+	val = an8855_reg_read(gsw, CKGCR);
+	val &= ~(CKG_LNKDN_GLB_STOP | CKG_LNKDN_PORT_STOP);
+	an8855_reg_write(gsw, CKGCR, val);
+
+	return 0;
+}
+
+static int an8855_sw_post_init(struct gsw_an8855 *gsw)
+{
+	int i;
+	u32 val;
+
+	for (i = 0; i < AN8855_NUM_PHYS; i++) {
+		val = gsw->mii_read(gsw, i, MII_BMCR);
+		val &= ~BMCR_ISOLATE;
+		gsw->mii_write(gsw, i, MII_BMCR, val);
+	}
+
+	an8855_phy_setting(gsw);
+
+	for (i = 0; i < AN8855_NUM_PHYS; i++)
+		an8855_eee_setting(gsw, i);
+
+	/* PHY restart AN*/
+	for (i = 0; i < AN8855_NUM_PHYS; i++)
+		gsw->mii_write(gsw, i, MII_BMCR, 0x1240);
+
+	return 0;
+}
+
+struct an8855_sw_id an8855_id = {
+	.model = AN8855,
+	.detect = an8855_sw_detect,
+	.init = an8855_sw_init,
+	.post_init = an8855_sw_post_init
+};
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Min Yao <min.yao@airoha.com>");
+MODULE_DESCRIPTION("Driver for Airoha AN8855 Gigabit Switch");
diff --git a/drivers/net/phy/airoha/an8855/an8855.h b/drivers/net/phy/airoha/an8855/an8855.h
new file mode 100644
index 0000000..5f84ee5
--- /dev/null
+++ b/drivers/net/phy/airoha/an8855/an8855.h
@@ -0,0 +1,194 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2023 Airoha Inc.
+ * Author: Min Yao <min.yao@airoha.com>
+ */
+
+#ifndef _AN8855_H_
+#define _AN8855_H_
+
+#include <linux/list.h>
+#include <linux/mutex.h>
+#include <linux/netdevice.h>
+#include <linux/of_mdio.h>
+#include <linux/workqueue.h>
+#include <linux/gpio/consumer.h>
+#include <linux/phy.h>
+
+#ifdef CONFIG_SWCONFIG
+#include <linux/switch.h>
+#endif
+
+#include "an8855_vlan.h"
+
+#define AN8855_DFL_CPU_PORT		5
+#define AN8855_NUM_PHYS			5
+#define AN8855_WORD_SIZE		4
+#define AN8855_DFL_SMI_ADDR		0x1
+#define AN8855_SMI_ADDR_MASK	0x1f
+#define AN8855_DFL_INTR_ID		0xd
+#define AN8855_DFL_EXT_SURGE	0x0
+
+#define LED_ON_EVENT	(LED_ON_EVT_LINK_1000M | \
+			LED_ON_EVT_LINK_100M | LED_ON_EVT_LINK_10M |\
+			LED_ON_EVT_LINK_HD | LED_ON_EVT_LINK_FD)
+
+#define LED_BLK_EVENT	(LED_BLK_EVT_1000M_TX_ACT | \
+			LED_BLK_EVT_1000M_RX_ACT | \
+			LED_BLK_EVT_100M_TX_ACT | \
+			LED_BLK_EVT_100M_RX_ACT | \
+			LED_BLK_EVT_10M_TX_ACT | \
+			LED_BLK_EVT_10M_RX_ACT)
+
+#define LED_FREQ	AIR_LED_BLK_DUR_64M
+
+struct gsw_an8855;
+
+enum an8855_model {
+	AN8855 = 0x8855,
+};
+
+enum sgmii_mode {
+	SGMII_MODE_AN,
+	SGMII_MODE_FORCE,
+};
+
+enum phy_led_idx {
+	P0_LED0,
+	P0_LED1,
+	P0_LED2,
+	P0_LED3,
+	P1_LED0,
+	P1_LED1,
+	P1_LED2,
+	P1_LED3,
+	P2_LED0,
+	P2_LED1,
+	P2_LED2,
+	P2_LED3,
+	P3_LED0,
+	P3_LED1,
+	P3_LED2,
+	P3_LED3,
+	P4_LED0,
+	P4_LED1,
+	P4_LED2,
+	P4_LED3,
+	PHY_LED_MAX
+};
+
+/* TBD */
+enum an8855_led_blk_dur {
+	AIR_LED_BLK_DUR_32M,
+	AIR_LED_BLK_DUR_64M,
+	AIR_LED_BLK_DUR_128M,
+	AIR_LED_BLK_DUR_256M,
+	AIR_LED_BLK_DUR_512M,
+	AIR_LED_BLK_DUR_1024M,
+	AIR_LED_BLK_DUR_LAST
+};
+
+enum an8855_led_polarity {
+	LED_LOW,
+	LED_HIGH,
+};
+enum an8855_led_mode {
+	AN8855_LED_MODE_DISABLE,
+	AN8855_LED_MODE_USER_DEFINE,
+	AN8855_LED_MODE_LAST
+};
+
+struct an8855_led_cfg {
+	u16 en;
+	u8  phy_led_idx;
+	u16 pol;
+	u16 on_cfg;
+	u16 blk_cfg;
+	u8 led_freq;
+};
+
+struct an8855_port_cfg {
+	struct device_node *np;
+	phy_interface_t phy_mode;
+	u32 enabled: 1;
+	u32 force_link: 1;
+	u32 speed: 2;
+	u32 duplex: 1;
+	bool stag_on;
+};
+
+struct gsw_an8855 {
+	u32 id;
+
+	struct device *dev;
+	struct mii_bus *host_bus;
+	u32 smi_addr;
+	u32 new_smi_addr;
+	u32 phy_base;
+	u32 intr_pin;
+	u32 extSurge;
+
+	enum an8855_model model;
+	const char *name;
+
+	struct an8855_port_cfg port5_cfg;
+
+	int phy_link_sts;
+
+	int irq;
+	int reset_pin;
+	struct work_struct irq_worker;
+
+#ifdef CONFIG_SWCONFIG
+	struct switch_dev swdev;
+	u32 cpu_port;
+#endif
+
+	int global_vlan_enable;
+	struct an8855_vlan_entry vlan_entries[AN8855_NUM_VLANS];
+	struct an8855_port_entry port_entries[AN8855_NUM_PORTS];
+
+	int (*mii_read)(struct gsw_an8855 *gsw, int phy, int reg);
+	void (*mii_write)(struct gsw_an8855 *gsw, int phy, int reg, u16 val);
+
+	int (*mmd_read)(struct gsw_an8855 *gsw, int addr, int devad, u16 reg);
+	void (*mmd_write)(struct gsw_an8855 *gsw, int addr, int devad, u16 reg,
+			  u16 val);
+
+	struct list_head list;
+};
+
+struct chip_rev {
+	const char *name;
+	u32 rev;
+};
+
+struct an8855_sw_id {
+	enum an8855_model model;
+	int (*detect)(struct gsw_an8855 *gsw, struct chip_rev *crev);
+	int (*init)(struct gsw_an8855 *gsw);
+	int (*post_init)(struct gsw_an8855 *gsw);
+};
+
+extern struct list_head an8855_devs;
+extern struct an8855_sw_id an8855_id;
+
+struct gsw_an8855 *an8855_get_gsw(u32 id);
+struct gsw_an8855 *an8855_get_first_gsw(void);
+void an8855_put_gsw(void);
+void an8855_lock_gsw(void);
+
+u32 an8855_reg_read(struct gsw_an8855 *gsw, u32 reg);
+void an8855_reg_write(struct gsw_an8855 *gsw, u32 reg, u32 val);
+
+int an8855_mii_read(struct gsw_an8855 *gsw, int phy, int reg);
+void an8855_mii_write(struct gsw_an8855 *gsw, int phy, int reg, u16 val);
+
+int an8855_mmd_read(struct gsw_an8855 *gsw, int addr, int devad, u16 reg);
+void an8855_mmd_write(struct gsw_an8855 *gsw, int addr, int devad, u16 reg,
+			  u16 val);
+
+void an8855_irq_worker(struct work_struct *work);
+void an8855_irq_enable(struct gsw_an8855 *gsw);
+
+#endif /* _AN8855_H_ */
diff --git a/drivers/net/phy/airoha/an8855/an8855_common.c b/drivers/net/phy/airoha/an8855/an8855_common.c
new file mode 100644
index 0000000..c01b5c4
--- /dev/null
+++ b/drivers/net/phy/airoha/an8855/an8855_common.c
@@ -0,0 +1,96 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Copyright (c) 2023 Airoha Inc.
+ * Author: Min Yao <min.yao@airoha.com>
+ */
+
+#include <linux/kernel.h>
+#include <linux/delay.h>
+
+#include "an8855.h"
+#include "an8855_regs.h"
+
+void an8855_irq_enable(struct gsw_an8855 *gsw)
+{
+	u32 val;
+	int i;
+
+	/* Record initial PHY link status */
+	for (i = 0; i < AN8855_NUM_PHYS; i++) {
+		val = gsw->mii_read(gsw, i, MII_BMSR);
+		if (val & BMSR_LSTATUS)
+			gsw->phy_link_sts |= BIT(i);
+	}
+
+	val = BIT(AN8855_NUM_PHYS) - 1;
+	an8855_reg_write(gsw, SYS_INT_EN, val);
+
+	val = an8855_reg_read(gsw, INT_MASK);
+	val |= INT_SYS_BIT;
+	an8855_reg_write(gsw, INT_MASK, val);
+}
+
+static void display_port_link_status(struct gsw_an8855 *gsw, u32 port)
+{
+	u32 pmsr, speed_bits;
+	const char *speed;
+
+	pmsr = an8855_reg_read(gsw, PMSR(port));
+
+	speed_bits = (pmsr & MAC_SPD_STS_M) >> MAC_SPD_STS_S;
+
+	switch (speed_bits) {
+	case MAC_SPD_10:
+		speed = "10Mbps";
+		break;
+	case MAC_SPD_100:
+		speed = "100Mbps";
+		break;
+	case MAC_SPD_1000:
+		speed = "1Gbps";
+		break;
+	case MAC_SPD_2500:
+		speed = "2.5Gbps";
+		break;
+	default:
+		dev_info(gsw->dev, "Invalid speed\n");
+		return;
+	}
+
+	if (pmsr & MAC_LNK_STS) {
+		dev_info(gsw->dev, "Port %d Link is Up - %s/%s\n",
+			 port, speed, (pmsr & MAC_DPX_STS) ? "Full" : "Half");
+	} else {
+		dev_info(gsw->dev, "Port %d Link is Down\n", port);
+	}
+}
+
+void an8855_irq_worker(struct work_struct *work)
+{
+	struct gsw_an8855 *gsw;
+	u32 sts, physts, laststs;
+	int i;
+
+	gsw = container_of(work, struct gsw_an8855, irq_worker);
+
+	sts = an8855_reg_read(gsw, SYS_INT_STS);
+
+	/* Check for changed PHY link status */
+	for (i = 0; i < AN8855_NUM_PHYS; i++) {
+		if (!(sts & PHY_LC_INT(i)))
+			continue;
+
+		laststs = gsw->phy_link_sts & BIT(i);
+		physts = !!(gsw->mii_read(gsw, i, MII_BMSR) & BMSR_LSTATUS);
+		physts <<= i;
+
+		if (physts ^ laststs) {
+			gsw->phy_link_sts ^= BIT(i);
+			display_port_link_status(gsw, i);
+		}
+	}
+
+	an8855_reg_write(gsw, SYS_INT_STS, sts);
+
+	enable_irq(gsw->irq);
+}
diff --git a/drivers/net/phy/airoha/an8855/an8855_mdio.c b/drivers/net/phy/airoha/an8855/an8855_mdio.c
new file mode 100644
index 0000000..65633b0
--- /dev/null
+++ b/drivers/net/phy/airoha/an8855/an8855_mdio.c
@@ -0,0 +1,565 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2023 Airoha Inc.
+ * Author: Min Yao <min.yao@airoha.com>
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <linux/reset.h>
+#include <linux/hrtimer.h>
+#include <linux/mii.h>
+#include <linux/of_mdio.h>
+#include <linux/of_platform.h>
+#include <linux/of_gpio.h>
+#include <linux/of_net.h>
+#include <linux/of_irq.h>
+#include <linux/phy.h>
+#include <linux/version.h>
+#include <linux/seq_file.h>
+#include <linux/proc_fs.h>
+#include <linux/platform_device.h>
+
+#include "an8855.h"
+#include "an8855_swconfig.h"
+#include "an8855_regs.h"
+#include "an8855_nl.h"
+
+/* AN8855 driver version */
+#define ARHT_AN8855_SWCFG_DRIVER_VER	"1.0.6"
+#define ARHT_CHIP_NAME                  "an8855"
+#define ARHT_PROC_DIR                   "air_sw"
+#define ARHT_PROC_NODE_DEVICE           "device"
+
+static u32 an8855_gsw_id;
+struct list_head an8855_devs;
+static DEFINE_MUTEX(an8855_devs_lock);
+struct proc_dir_entry *proc_an8855_gsw_dir;
+
+static struct an8855_sw_id *an8855_sw_ids[] = {
+	&an8855_id,
+};
+
+u32 an8855_reg_read(struct gsw_an8855 *gsw, u32 reg)
+{
+	u32 high, low;
+
+	mutex_lock(&gsw->host_bus->mdio_lock);
+
+	gsw->host_bus->write(gsw->host_bus, gsw->smi_addr, 0x1f, 0x4);
+	gsw->host_bus->write(gsw->host_bus, gsw->smi_addr, 0x10, 0x0);
+
+	gsw->host_bus->write(gsw->host_bus, gsw->smi_addr, 0x15,
+			     ((reg >> 16) & 0xFFFF));
+	gsw->host_bus->write(gsw->host_bus, gsw->smi_addr, 0x16,
+			     (reg & 0xFFFF));
+
+	low = gsw->host_bus->read(gsw->host_bus, gsw->smi_addr, 0x18);
+	high = gsw->host_bus->read(gsw->host_bus, gsw->smi_addr, 0x17);
+
+	gsw->host_bus->write(gsw->host_bus, gsw->smi_addr, 0x1f, 0x0);
+
+	mutex_unlock(&gsw->host_bus->mdio_lock);
+
+	return (high << 16) | (low & 0xffff);
+}
+
+void an8855_reg_write(struct gsw_an8855 *gsw, u32 reg, u32 val)
+{
+	mutex_lock(&gsw->host_bus->mdio_lock);
+
+	gsw->host_bus->write(gsw->host_bus, gsw->smi_addr, 0x1f, 0x4);
+	gsw->host_bus->write(gsw->host_bus, gsw->smi_addr, 0x10, 0x0);
+
+	gsw->host_bus->write(gsw->host_bus, gsw->smi_addr, 0x11,
+			     ((reg >> 16) & 0xFFFF));
+	gsw->host_bus->write(gsw->host_bus, gsw->smi_addr, 0x12,
+			     (reg & 0xFFFF));
+
+	gsw->host_bus->write(gsw->host_bus, gsw->smi_addr, 0x13,
+			     ((val >> 16) & 0xFFFF));
+	gsw->host_bus->write(gsw->host_bus, gsw->smi_addr, 0x14,
+			     (val & 0xFFFF));
+
+	gsw->host_bus->write(gsw->host_bus, gsw->smi_addr, 0x1f, 0x0);
+
+	mutex_unlock(&gsw->host_bus->mdio_lock);
+}
+
+int an8855_mii_read(struct gsw_an8855 *gsw, int phy, int reg)
+{
+	int val;
+
+	if (phy < AN8855_NUM_PHYS)
+		phy = (gsw->phy_base + phy) & AN8855_SMI_ADDR_MASK;
+
+	mutex_lock(&gsw->host_bus->mdio_lock);
+	val = gsw->host_bus->read(gsw->host_bus, phy, reg);
+	mutex_unlock(&gsw->host_bus->mdio_lock);
+
+	return val;
+}
+
+void an8855_mii_write(struct gsw_an8855 *gsw, int phy, int reg, u16 val)
+{
+	if (phy < AN8855_NUM_PHYS)
+		phy = (gsw->phy_base + phy) & AN8855_SMI_ADDR_MASK;
+
+	mutex_lock(&gsw->host_bus->mdio_lock);
+	gsw->host_bus->write(gsw->host_bus, phy, reg, val);
+	mutex_unlock(&gsw->host_bus->mdio_lock);
+}
+
+int an8855_mmd_read(struct gsw_an8855 *gsw, int addr, int devad, u16 reg)
+{
+	int val;
+
+	if (addr < AN8855_NUM_PHYS)
+		addr = (gsw->phy_base + addr) & AN8855_SMI_ADDR_MASK;
+
+	mutex_lock(&gsw->host_bus->mdio_lock);
+
+	gsw->host_bus->write(gsw->host_bus, addr, 0x0d, devad);
+	gsw->host_bus->write(gsw->host_bus, addr, 0x0e, reg);
+	gsw->host_bus->write(gsw->host_bus, addr, 0x0d, devad | (0x4000));
+	val = gsw->host_bus->read(gsw->host_bus, addr, 0xe);
+
+	mutex_unlock(&gsw->host_bus->mdio_lock);
+
+	return val;
+}
+
+void an8855_mmd_write(struct gsw_an8855 *gsw, int addr, int devad, u16 reg,
+		      u16 val)
+{
+	if (addr < AN8855_NUM_PHYS)
+		addr = (gsw->phy_base + addr) & AN8855_SMI_ADDR_MASK;
+
+	mutex_lock(&gsw->host_bus->mdio_lock);
+
+	gsw->host_bus->write(gsw->host_bus, addr, 0x0d, devad);
+	gsw->host_bus->write(gsw->host_bus, addr, 0x0e, reg);
+	gsw->host_bus->write(gsw->host_bus, addr, 0x0d, devad | (0x4000));
+	gsw->host_bus->write(gsw->host_bus, addr, 0x0e, val);
+
+	mutex_unlock(&gsw->host_bus->mdio_lock);
+}
+
+static inline int an8855_get_duplex(const struct device_node *np)
+{
+	return of_property_read_bool(np, "full-duplex");
+}
+
+static void an8855_load_port_cfg(struct gsw_an8855 *gsw)
+{
+	struct device_node *port_np;
+	struct device_node *fixed_link_node;
+	struct an8855_port_cfg *port_cfg;
+	u32 port;
+#if (KERNEL_VERSION(5, 5, 0) <= LINUX_VERSION_CODE)
+	int ret;
+
+#endif
+
+	for_each_child_of_node(gsw->dev->of_node, port_np) {
+		if (!of_device_is_compatible(port_np, "airoha,an8855-port"))
+			continue;
+
+		if (!of_device_is_available(port_np))
+			continue;
+
+		if (of_property_read_u32(port_np, "reg", &port))
+			continue;
+
+		switch (port) {
+		case 5:
+			port_cfg = &gsw->port5_cfg;
+			break;
+		default:
+			continue;
+		}
+
+		if (port_cfg->enabled) {
+			dev_info(gsw->dev, "duplicated node for port%d\n",
+				 port_cfg->phy_mode);
+			continue;
+		}
+
+		port_cfg->np = port_np;
+#if (KERNEL_VERSION(5, 5, 0) <= LINUX_VERSION_CODE)
+		ret = of_get_phy_mode(port_np, &port_cfg->phy_mode);
+		if (ret < 0) {
+#else
+		port_cfg->phy_mode = of_get_phy_mode(port_np);
+		if (port_cfg->phy_mode < 0) {
+#endif
+			dev_info(gsw->dev, "incorrect phy-mode %d\n", port);
+			continue;
+		}
+
+		fixed_link_node = of_get_child_by_name(port_np, "fixed-link");
+		if (fixed_link_node) {
+			u32 speed;
+
+			port_cfg->force_link = 1;
+			port_cfg->duplex = an8855_get_duplex(fixed_link_node);
+
+			if (of_property_read_u32(fixed_link_node, "speed",
+						 &speed)) {
+				speed = 0;
+				continue;
+			}
+
+			of_node_put(fixed_link_node);
+
+			switch (speed) {
+			case 10:
+				port_cfg->speed = MAC_SPD_10;
+				break;
+			case 100:
+				port_cfg->speed = MAC_SPD_100;
+				break;
+			case 1000:
+				port_cfg->speed = MAC_SPD_1000;
+				break;
+			case 2500:
+				port_cfg->speed = MAC_SPD_2500;
+				break;
+
+			default:
+				dev_info(gsw->dev, "incorrect speed %d\n",
+					 speed);
+				continue;
+			}
+		}
+
+		port_cfg->stag_on =
+		    of_property_read_bool(port_cfg->np, "airoha,stag-on");
+		port_cfg->enabled = 1;
+	}
+}
+
+static void an8855_add_gsw(struct gsw_an8855 *gsw)
+{
+	mutex_lock(&an8855_devs_lock);
+	gsw->id = an8855_gsw_id++;
+	INIT_LIST_HEAD(&gsw->list);
+	list_add_tail(&gsw->list, &an8855_devs);
+	mutex_unlock(&an8855_devs_lock);
+}
+
+static void an8855_remove_gsw(struct gsw_an8855 *gsw)
+{
+	mutex_lock(&an8855_devs_lock);
+	list_del(&gsw->list);
+	mutex_unlock(&an8855_devs_lock);
+}
+
+struct gsw_an8855 *an8855_get_gsw(u32 id)
+{
+	struct gsw_an8855 *dev;
+
+	mutex_lock(&an8855_devs_lock);
+
+	list_for_each_entry(dev, &an8855_devs, list) {
+		if (dev->id == id)
+			return dev;
+	}
+
+	mutex_unlock(&an8855_devs_lock);
+
+	return NULL;
+}
+
+struct gsw_an8855 *an8855_get_first_gsw(void)
+{
+	struct gsw_an8855 *dev;
+
+	mutex_lock(&an8855_devs_lock);
+
+	list_for_each_entry(dev, &an8855_devs, list)
+		return dev;
+
+	mutex_unlock(&an8855_devs_lock);
+
+	return NULL;
+}
+
+void an8855_put_gsw(void)
+{
+	mutex_unlock(&an8855_devs_lock);
+}
+
+void an8855_lock_gsw(void)
+{
+	mutex_lock(&an8855_devs_lock);
+}
+
+static int an8855_hw_reset(struct gsw_an8855 *gsw)
+{
+	struct device_node *np = gsw->dev->of_node;
+	int ret;
+
+	gsw->reset_pin = of_get_named_gpio(np, "reset-gpios", 0);
+	if (gsw->reset_pin < 0) {
+		dev_info(gsw->dev, "No reset pin of switch\n");
+		return 0;
+	}
+
+	ret = devm_gpio_request(gsw->dev, gsw->reset_pin, "an8855-reset");
+	if (ret) {
+		dev_info(gsw->dev, "Failed to request gpio %d\n",
+			 gsw->reset_pin);
+		return ret;
+	}
+
+	gpio_direction_output(gsw->reset_pin, 0);
+	gpio_set_value(gsw->reset_pin, 0);
+	usleep_range(100000, 150000);
+	gpio_set_value(gsw->reset_pin, 1);
+	usleep_range(100000, 150000);
+
+	return 0;
+}
+
+static irqreturn_t an8855_irq_handler(int irq, void *dev)
+{
+	struct gsw_an8855 *gsw = dev;
+
+	disable_irq_nosync(gsw->irq);
+
+	schedule_work(&gsw->irq_worker);
+
+	return IRQ_HANDLED;
+}
+
+static int an8855_proc_device_read(struct seq_file *seq, void *v)
+{
+	seq_printf(seq, "%s\n", ARHT_CHIP_NAME);
+
+	return 0;
+}
+
+static int an8855_proc_device_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, an8855_proc_device_read, 0);
+}
+
+#if (KERNEL_VERSION(5, 6, 0) <= LINUX_VERSION_CODE)
+static const struct proc_ops an8855_proc_device_fops = {
+	.proc_open	= an8855_proc_device_open,
+	.proc_read	= seq_read,
+	.proc_lseek	= seq_lseek,
+	.proc_release	= single_release,
+};
+#else
+static const struct file_operations an8855_proc_device_fops = {
+	.owner	= THIS_MODULE,
+	.open	= an8855_proc_device_open,
+	.read	= seq_read,
+	.llseek	= seq_lseek,
+	.release	= single_release,
+};
+#endif
+
+static int an8855_proc_device_init(struct gsw_an8855 *gsw)
+{
+	if (!proc_an8855_gsw_dir)
+		proc_an8855_gsw_dir = proc_mkdir(ARHT_PROC_DIR, 0);
+
+	proc_create(ARHT_PROC_NODE_DEVICE, 0400, proc_an8855_gsw_dir,
+			&an8855_proc_device_fops);
+
+	return 0;
+}
+
+static void an8855_proc_device_exit(void)
+{
+	remove_proc_entry(ARHT_PROC_NODE_DEVICE, 0);
+}
+
+static int an8855_probe(struct platform_device *pdev)
+{
+	struct gsw_an8855 *gsw;
+	struct an8855_sw_id *sw;
+	struct device_node *np = pdev->dev.of_node;
+	struct device_node *mdio;
+	struct mii_bus *mdio_bus;
+	int ret = -EINVAL;
+	struct chip_rev rev;
+	struct an8855_mapping *map;
+	int i;
+
+	mdio = of_parse_phandle(np, "airoha,mdio", 0);
+	if (!mdio)
+		return -EINVAL;
+
+	mdio_bus = of_mdio_find_bus(mdio);
+	if (!mdio_bus)
+		return -EPROBE_DEFER;
+
+	gsw = devm_kzalloc(&pdev->dev, sizeof(struct gsw_an8855), GFP_KERNEL);
+	if (!gsw)
+		return -ENOMEM;
+
+	gsw->host_bus = mdio_bus;
+	gsw->dev = &pdev->dev;
+
+	dev_info(gsw->dev, "AN8855 Driver Version=%s\n",
+			ARHT_AN8855_SWCFG_DRIVER_VER);
+
+	/* Switch hard reset */
+	if (an8855_hw_reset(gsw)) {
+		dev_info(&pdev->dev, "reset switch fail.\n");
+		goto fail;
+	}
+
+	/* Fetch the SMI address first */
+	gsw->smi_addr = AN8855_DFL_SMI_ADDR;
+	if (of_property_read_u32(np, "airoha,smi-addr", &gsw->new_smi_addr))
+		gsw->new_smi_addr = AN8855_DFL_SMI_ADDR;
+
+	/* Assign AN8855 interrupt pin */
+	if (of_property_read_u32(np, "airoha,intr", &gsw->intr_pin))
+		gsw->intr_pin = AN8855_DFL_INTR_ID;
+
+	/* AN8855 surge enhancement */
+	if (of_property_read_u32(np, "airoha,extSurge", &gsw->extSurge))
+		gsw->extSurge = AN8855_DFL_EXT_SURGE;
+
+	/* Get LAN/WAN port mapping */
+	map = an8855_find_mapping(np);
+	if (map) {
+		an8855_apply_mapping(gsw, map);
+		gsw->global_vlan_enable = 1;
+		dev_info(gsw->dev, "LAN/WAN VLAN setting=%s\n", map->name);
+	}
+
+	/* Load MAC port configurations */
+	an8855_load_port_cfg(gsw);
+
+	/* Check for valid switch and then initialize */
+	an8855_gsw_id = 0;
+	for (i = 0; i < ARRAY_SIZE(an8855_sw_ids); i++) {
+		if (!an8855_sw_ids[i]->detect(gsw, &rev)) {
+			sw = an8855_sw_ids[i];
+
+			gsw->name = rev.name;
+			gsw->model = sw->model;
+
+			dev_info(gsw->dev, "Switch is Airoha %s rev %d",
+				 gsw->name, rev.rev);
+
+			/* Initialize the switch */
+			ret = sw->init(gsw);
+			if (ret)
+				goto fail;
+
+			break;
+		}
+	}
+
+	if (i >= ARRAY_SIZE(an8855_sw_ids)) {
+		dev_err(gsw->dev, "No an8855 switch found\n");
+		goto fail;
+	}
+
+	gsw->irq = platform_get_irq(pdev, 0);
+	if (gsw->irq >= 0) {
+		INIT_WORK(&gsw->irq_worker, an8855_irq_worker);
+
+		ret = devm_request_irq(gsw->dev, gsw->irq, an8855_irq_handler,
+				       0, dev_name(gsw->dev), gsw);
+		if (ret) {
+			dev_err(gsw->dev, "Failed to request irq %d\n",
+				gsw->irq);
+			goto fail;
+		}
+	}
+
+	platform_set_drvdata(pdev, gsw);
+
+	an8855_add_gsw(gsw);
+
+	an8855_gsw_nl_init();
+
+	an8855_proc_device_init(gsw);
+
+	an8855_swconfig_init(gsw);
+
+	if (sw->post_init)
+		sw->post_init(gsw);
+
+	if (gsw->irq >= 0)
+		an8855_irq_enable(gsw);
+
+	return 0;
+
+fail:
+	devm_kfree(&pdev->dev, gsw);
+
+	return ret;
+}
+
+static void an8855_remove(struct platform_device *pdev)
+{
+	struct gsw_an8855 *gsw = platform_get_drvdata(pdev);
+
+	if (gsw->irq >= 0)
+		cancel_work_sync(&gsw->irq_worker);
+
+#ifdef CONFIG_SWCONFIG
+	an8855_swconfig_destroy(gsw);
+#endif
+
+	an8855_proc_device_exit();
+
+	an8855_gsw_nl_exit();
+
+	an8855_remove_gsw(gsw);
+
+	platform_set_drvdata(pdev, NULL);
+}
+
+static const struct of_device_id an8855_ids[] = {
+	{.compatible = "airoha,an8855"},
+	{},
+};
+
+MODULE_DEVICE_TABLE(of, an8855_ids);
+
+static struct platform_driver an8855_driver = {
+	.probe = an8855_probe,
+	.remove = an8855_remove,
+	.driver = {
+		   .name = "an8855",
+		   .of_match_table = an8855_ids,
+		   },
+};
+
+static int __init an8855_init(void)
+{
+	int ret;
+
+	INIT_LIST_HEAD(&an8855_devs);
+	ret = platform_driver_register(&an8855_driver);
+
+	return ret;
+}
+
+module_init(an8855_init);
+
+static void __exit an8855_exit(void)
+{
+	platform_driver_unregister(&an8855_driver);
+}
+
+module_exit(an8855_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Min Yao <min.yao@airoha.com>");
+MODULE_VERSION(ARHT_AN8855_SWCFG_DRIVER_VER);
+MODULE_DESCRIPTION("Driver for Airoha AN8855 Gigabit Switch");
diff --git a/drivers/net/phy/airoha/an8855/an8855_nl.c b/drivers/net/phy/airoha/an8855/an8855_nl.c
new file mode 100644
index 0000000..88b808e
--- /dev/null
+++ b/drivers/net/phy/airoha/an8855/an8855_nl.c
@@ -0,0 +1,382 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2023 Airoha Inc.
+ * Author: Min Yao <min.yao@airoha.com>
+ */
+
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <net/genetlink.h>
+
+#include "an8855.h"
+#include "an8855_nl.h"
+
+struct an8855_nl_cmd_item {
+	enum an8855_cmd cmd;
+	bool require_dev;
+	int (*process)(struct genl_info *info, struct gsw_an8855 *gsw);
+	u32 nr_required_attrs;
+	const enum an8855_attr *required_attrs;
+};
+
+static int an8855_nl_response(struct sk_buff *skb, struct genl_info *info);
+
+static const struct nla_policy an8855_nl_cmd_policy[] = {
+	[AN8855_ATTR_TYPE_MESG] = { .type = NLA_STRING },
+	[AN8855_ATTR_TYPE_PHY] = { .type = NLA_S32 },
+	[AN8855_ATTR_TYPE_REG] = { .type = NLA_U32 },
+	[AN8855_ATTR_TYPE_VAL] = { .type = NLA_U32 },
+	[AN8855_ATTR_TYPE_DEV_NAME] = { .type = NLA_S32 },
+	[AN8855_ATTR_TYPE_DEV_ID] = { .type = NLA_S32 },
+	[AN8855_ATTR_TYPE_DEVAD] = { .type = NLA_S32 },
+};
+
+static const struct genl_ops an8855_nl_ops[] = {
+	{
+		.cmd = AN8855_CMD_REQUEST,
+		.doit = an8855_nl_response,
+//		.policy = an8855_nl_cmd_policy,
+		.flags = GENL_ADMIN_PERM,
+	}, {
+		.cmd = AN8855_CMD_READ,
+		.doit = an8855_nl_response,
+//		.policy = an8855_nl_cmd_policy,
+		.flags = GENL_ADMIN_PERM,
+	}, {
+		.cmd = AN8855_CMD_WRITE,
+		.doit = an8855_nl_response,
+//		.policy = an8855_nl_cmd_policy,
+		.flags = GENL_ADMIN_PERM,
+	},
+};
+
+static struct genl_family an8855_nl_family = {
+	.name =		AN8855_GENL_NAME,
+	.version =	AN8855_GENL_VERSION,
+	.maxattr =	AN8855_NR_ATTR_TYPE,
+	.ops =		an8855_nl_ops,
+	.n_ops =	ARRAY_SIZE(an8855_nl_ops),
+	.policy =	an8855_nl_cmd_policy,
+};
+
+static int an8855_nl_list_devs(char *buff, int size)
+{
+	struct gsw_an8855 *gsw;
+	int len, total = 0;
+	char buf[80];
+
+	memset(buff, 0, size);
+
+	an8855_lock_gsw();
+
+	list_for_each_entry(gsw, &an8855_devs, list) {
+		len = snprintf(buf, sizeof(buf),
+				   "id: %d, model: %s, node: %s\n",
+				   gsw->id, gsw->name, gsw->dev->of_node->name);
+		if (len == strlen(buf)) {
+			if (size - total > 0)
+				strncat(buff, buf, size - total);
+			total += len;
+		}
+	}
+
+	an8855_put_gsw();
+
+	return total;
+}
+
+static int an8855_nl_prepare_reply(struct genl_info *info, u8 cmd,
+				   struct sk_buff **skbp)
+{
+	struct sk_buff *msg;
+	void *reply;
+
+	if (!info)
+		return -EINVAL;
+
+	msg = genlmsg_new(NLMSG_GOODSIZE, GFP_KERNEL);
+	if (!msg)
+		return -ENOMEM;
+
+	/* Construct send-back message header */
+	reply = genlmsg_put(msg, info->snd_portid, info->snd_seq,
+				&an8855_nl_family, 0, cmd);
+	if (!reply) {
+		nlmsg_free(msg);
+		return -EINVAL;
+	}
+
+	*skbp = msg;
+	return 0;
+}
+
+static int an8855_nl_send_reply(struct sk_buff *skb, struct genl_info *info)
+{
+	struct genlmsghdr *genlhdr = nlmsg_data(nlmsg_hdr(skb));
+	void *reply = genlmsg_data(genlhdr);
+
+	/* Finalize a generic netlink message (update message header) */
+	genlmsg_end(skb, reply);
+
+	/* reply to a request */
+	return genlmsg_reply(skb, info);
+}
+
+static s32 an8855_nl_get_s32(struct genl_info *info, enum an8855_attr attr,
+				 s32 defval)
+{
+	struct nlattr *na;
+
+	na = info->attrs[attr];
+	if (na)
+		return nla_get_s32(na);
+
+	return defval;
+}
+
+static int an8855_nl_get_u32(struct genl_info *info, enum an8855_attr attr,
+				 u32 *val)
+{
+	struct nlattr *na;
+
+	na = info->attrs[attr];
+	if (na) {
+		*val = nla_get_u32(na);
+		return 0;
+	}
+
+	return -1;
+}
+
+static struct gsw_an8855 *an8855_nl_parse_find_gsw(struct genl_info *info)
+{
+	struct gsw_an8855 *gsw;
+	struct nlattr *na;
+	int gsw_id;
+
+	na = info->attrs[AN8855_ATTR_TYPE_DEV_ID];
+	if (na) {
+		gsw_id = nla_get_s32(na);
+		if (gsw_id >= 0)
+			gsw = an8855_get_gsw(gsw_id);
+		else
+			gsw = an8855_get_first_gsw();
+	} else {
+		gsw = an8855_get_first_gsw();
+	}
+
+	return gsw;
+}
+
+static int an8855_nl_get_swdevs(struct genl_info *info, struct gsw_an8855 *gsw)
+{
+	struct sk_buff *rep_skb = NULL;
+	char dev_info[512];
+	int ret;
+
+	ret = an8855_nl_list_devs(dev_info, sizeof(dev_info) - 1);
+	if (!ret) {
+		pr_info("No switch registered\n");
+		return -EINVAL;
+	}
+
+	ret = an8855_nl_prepare_reply(info, AN8855_CMD_REPLY, &rep_skb);
+	if (ret < 0)
+		goto err;
+
+	ret = nla_put_string(rep_skb, AN8855_ATTR_TYPE_MESG, dev_info);
+	if (ret < 0)
+		goto err;
+
+	return an8855_nl_send_reply(rep_skb, info);
+
+err:
+	if (rep_skb)
+		nlmsg_free(rep_skb);
+
+	return ret;
+}
+
+static int an8855_nl_reply_read(struct genl_info *info, struct gsw_an8855 *gsw)
+{
+	struct sk_buff *rep_skb = NULL;
+	s32 phy, devad;
+	u32 reg = 0;
+	int value = 0;
+	int ret = 0;
+
+	phy = an8855_nl_get_s32(info, AN8855_ATTR_TYPE_PHY, -1);
+	devad = an8855_nl_get_s32(info, AN8855_ATTR_TYPE_DEVAD, -1);
+
+	if (an8855_nl_get_u32(info, AN8855_ATTR_TYPE_REG, &reg))
+		goto err;
+
+	ret = an8855_nl_prepare_reply(info, AN8855_CMD_READ, &rep_skb);
+	if (ret < 0)
+		goto err;
+
+	if (phy >= 0) {
+		if (devad < 0)
+			value = gsw->mii_read(gsw, phy, reg);
+		else
+			value = gsw->mmd_read(gsw, phy, devad, reg);
+	} else {
+		value = an8855_reg_read(gsw, reg);
+	}
+
+	ret = nla_put_u32(rep_skb, AN8855_ATTR_TYPE_REG, reg);
+	if (ret < 0)
+		goto err;
+
+	ret = nla_put_u32(rep_skb, AN8855_ATTR_TYPE_VAL, value);
+	if (ret < 0)
+		goto err;
+
+	return an8855_nl_send_reply(rep_skb, info);
+
+err:
+	if (rep_skb)
+		nlmsg_free(rep_skb);
+
+	return ret;
+}
+
+static int an8855_nl_reply_write(struct genl_info *info, struct gsw_an8855 *gsw)
+{
+	struct sk_buff *rep_skb = NULL;
+	s32 phy, devad;
+	u32 value = 0, reg = 0;
+	int ret = 0;
+
+	phy = an8855_nl_get_s32(info, AN8855_ATTR_TYPE_PHY, -1);
+	devad = an8855_nl_get_s32(info, AN8855_ATTR_TYPE_DEVAD, -1);
+	if (an8855_nl_get_u32(info, AN8855_ATTR_TYPE_REG, &reg))
+		goto err;
+
+	if (an8855_nl_get_u32(info, AN8855_ATTR_TYPE_VAL, &value))
+		goto err;
+
+	ret = an8855_nl_prepare_reply(info, AN8855_CMD_WRITE, &rep_skb);
+	if (ret < 0)
+		goto err;
+
+	if (phy >= 0) {
+		if (devad < 0)
+			gsw->mii_write(gsw, phy, reg, value);
+		else
+			gsw->mmd_write(gsw, phy, devad, reg, value);
+	} else {
+		an8855_reg_write(gsw, reg, value);
+	}
+
+	ret = nla_put_u32(rep_skb, AN8855_ATTR_TYPE_REG, reg);
+	if (ret < 0)
+		goto err;
+
+	ret = nla_put_u32(rep_skb, AN8855_ATTR_TYPE_VAL, value);
+	if (ret < 0)
+		goto err;
+
+	return an8855_nl_send_reply(rep_skb, info);
+
+err:
+	if (rep_skb)
+		nlmsg_free(rep_skb);
+
+	return ret;
+}
+
+static const enum an8855_attr an8855_nl_cmd_read_attrs[] = {
+	AN8855_ATTR_TYPE_REG
+};
+
+static const enum an8855_attr an8855_nl_cmd_write_attrs[] = {
+	AN8855_ATTR_TYPE_REG,
+	AN8855_ATTR_TYPE_VAL
+};
+
+static const struct an8855_nl_cmd_item an8855_nl_cmds[] = {
+	{
+		.cmd = AN8855_CMD_REQUEST,
+		.require_dev = false,
+		.process = an8855_nl_get_swdevs
+	}, {
+		.cmd = AN8855_CMD_READ,
+		.require_dev = true,
+		.process = an8855_nl_reply_read,
+		.required_attrs = an8855_nl_cmd_read_attrs,
+		.nr_required_attrs = ARRAY_SIZE(an8855_nl_cmd_read_attrs),
+	}, {
+		.cmd = AN8855_CMD_WRITE,
+		.require_dev = true,
+		.process = an8855_nl_reply_write,
+		.required_attrs = an8855_nl_cmd_write_attrs,
+		.nr_required_attrs = ARRAY_SIZE(an8855_nl_cmd_write_attrs),
+	}
+};
+
+static int an8855_nl_response(struct sk_buff *skb, struct genl_info *info)
+{
+	struct genlmsghdr *hdr = nlmsg_data(info->nlhdr);
+	const struct an8855_nl_cmd_item *cmditem = NULL;
+	struct gsw_an8855 *gsw = NULL;
+	u32 sat_req_attrs = 0;
+	int i, ret;
+
+	for (i = 0; i < ARRAY_SIZE(an8855_nl_cmds); i++) {
+		if (hdr->cmd == an8855_nl_cmds[i].cmd) {
+			cmditem = &an8855_nl_cmds[i];
+			break;
+		}
+	}
+
+	if (!cmditem) {
+		pr_info("an8855-nl: unknown cmd %u\n", hdr->cmd);
+		return -EINVAL;
+	}
+
+	for (i = 0; i < cmditem->nr_required_attrs; i++) {
+		if (info->attrs[cmditem->required_attrs[i]])
+			sat_req_attrs++;
+	}
+
+	if (sat_req_attrs != cmditem->nr_required_attrs) {
+		pr_info("an8855-nl: missing required attr(s) for cmd %u\n",
+			hdr->cmd);
+		return -EINVAL;
+	}
+
+	if (cmditem->require_dev) {
+		gsw = an8855_nl_parse_find_gsw(info);
+		if (!gsw) {
+			pr_info("an8855-nl: failed to find switch dev\n");
+			return -EINVAL;
+		}
+	}
+
+	an8855_lock_gsw();
+	ret = cmditem->process(info, gsw);
+	an8855_put_gsw();
+
+	return ret;
+}
+
+int an8855_gsw_nl_init(void)
+{
+	int ret;
+
+	ret = genl_register_family(&an8855_nl_family);
+	if (ret) {
+		pr_info("an8855-nl: genl_register_family_with_ops failed\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+void an8855_gsw_nl_exit(void)
+{
+	genl_unregister_family(&an8855_nl_family);
+}
diff --git a/drivers/net/phy/airoha/an8855/an8855_nl.h b/drivers/net/phy/airoha/an8855/an8855_nl.h
new file mode 100644
index 0000000..b00df75
--- /dev/null
+++ b/drivers/net/phy/airoha/an8855/an8855_nl.h
@@ -0,0 +1,43 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (c) 2023 Airoha Inc.
+ * Author: Min Yao <min.yao@airoha.com>
+ */
+
+#ifndef _AN8855_NL_H_
+#define _AN8855_NL_H_
+
+#define AN8855_GENL_NAME		"an8855"
+#define AN8855_GENL_VERSION		0x1
+
+enum an8855_cmd {
+	AN8855_CMD_UNSPEC = 0,
+	AN8855_CMD_REQUEST,
+	AN8855_CMD_REPLY,
+	AN8855_CMD_READ,
+	AN8855_CMD_WRITE,
+
+	__AN8855_CMD_MAX,
+};
+
+enum an8855_attr {
+	AN8855_ATTR_TYPE_UNSPEC = 0,
+	AN8855_ATTR_TYPE_MESG,
+	AN8855_ATTR_TYPE_PHY,
+	AN8855_ATTR_TYPE_DEVAD,
+	AN8855_ATTR_TYPE_REG,
+	AN8855_ATTR_TYPE_VAL,
+	AN8855_ATTR_TYPE_DEV_NAME,
+	AN8855_ATTR_TYPE_DEV_ID,
+
+	__AN8855_ATTR_TYPE_MAX,
+};
+
+#define AN8855_NR_ATTR_TYPE		(__AN8855_ATTR_TYPE_MAX - 1)
+
+#ifdef __KERNEL__
+int an8855_gsw_nl_init(void);
+void an8855_gsw_nl_exit(void);
+#endif /* __KERNEL__ */
+
+#endif /* _AN8855_NL_H_ */
diff --git a/drivers/net/phy/airoha/an8855/an8855_regs.h b/drivers/net/phy/airoha/an8855/an8855_regs.h
new file mode 100644
index 0000000..32790a1
--- /dev/null
+++ b/drivers/net/phy/airoha/an8855/an8855_regs.h
@@ -0,0 +1,197 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2023 Airoha Inc.
+ * Author: Min Yao <min.yao@airoha.com>
+ */
+
+#ifndef _AN8855_REGS_H_
+#define _AN8855_REGS_H_
+
+#include <linux/bitops.h>
+
+#define BITS(m, n)	 (~(BIT(m) - 1) & ((BIT(n) - 1) | BIT(n)))
+
+/* Values of Egress TAG Control */
+#define ETAG_CTRL_UNTAG			0
+#define ETAG_CTRL_TAG			2
+#define ETAG_CTRL_SWAP			1
+#define ETAG_CTRL_STACK			3
+
+#define VTCR					0x10200600
+#define VAWD0					0x10200604
+#define VAWD1					0x10200608
+#define VARD0					0x10200618
+#define VARD1					0x1020061C
+
+/* Fields of VTCR */
+#define VTCR_BUSY				BIT(31)
+#define VTCR_FUNC_S				12
+#define VTCR_FUNC_M				0xf000
+#define VTCR_VID_S				0
+#define VTCR_VID_M				0xfff
+
+/* Values of VTCR_FUNC */
+#define VTCR_READ_VLAN_ENTRY	0
+#define VTCR_WRITE_VLAN_ENTRY	1
+
+/* VLAN entry fields */
+#define IVL_MAC					BIT(5)
+#define EG_CON					BIT(11)
+#define VTAG_EN					BIT(10)
+#define PORT_MEM_S				26
+#define PORT_MEM_M				0xfc000000
+#define VENTRY_VALID			BIT(0)
+#define ETAG_M					0x3fff000
+#define PORT_ETAG_S(p)			(((p) * 2) + 12)
+#define PORT_ETAG_M				0x03
+
+#define PORT_CTRL_BASE			0x10208000
+#define PORT_CTRL_PORT_OFFSET	0x200
+#define PORT_CTRL_REG(p, r)		(PORT_CTRL_BASE + \
+					(p) * PORT_CTRL_PORT_OFFSET +  (r))
+#define PCR(p)					PORT_CTRL_REG(p, 0x04)
+#define PVC(p)					PORT_CTRL_REG(p, 0x10)
+#define PORTMATRIX(p)			PORT_CTRL_REG(p, 0x44)
+#define PVID(p)					PORT_CTRL_REG(p, 0x48)
+
+#define GRP_PORT_VID_M			0xfff
+
+/* Values of PORT_VLAN */
+#define PORT_MATRIX_MODE		0
+#define FALLBACK_MODE			1
+#define CHECK_MODE				2
+#define SECURITY_MODE			3
+
+/* Fields of PVC */
+#define STAG_VPID_S				16
+#define STAG_VPID_M				0xffff0000
+#define VLAN_ATTR_S				6
+#define VLAN_ATTR_M				0xc0
+#define PVC_STAG_REPLACE		BIT(11)
+#define PVC_PORT_STAG			BIT(5)
+
+/* Values of VLAN_ATTR */
+#define VA_USER_PORT			0
+#define VA_STACK_PORT			1
+#define VA_TRANSLATION_PORT		2
+#define VA_TRANSPARENT_PORT		3
+
+#define PORT_MATRIX_M			((1 << AN8855_NUM_PORTS) - 1)
+
+#define PORT_MAC_CTRL_BASE		0x10210000
+#define PORT_MAC_CTRL_PORT_OFFSET	0x200
+#define PORT_MAC_CTRL_REG(p, r)		(PORT_MAC_CTRL_BASE + \
+					(p) * PORT_MAC_CTRL_PORT_OFFSET + (r))
+#define PMCR(p)					PORT_MAC_CTRL_REG(p, 0x00)
+#define PMSR(p)					PORT_MAC_CTRL_REG(p, 0x10)
+
+#define GMACCR					(PORT_MAC_CTRL_BASE + 0x3e00)
+
+#define MAX_RX_JUMBO_S			4
+#define MAX_RX_JUMBO_M			0xf0
+#define MAX_RX_PKT_LEN_S		0
+#define MAX_RX_PKT_LEN_M		0x3
+
+/* Values of MAX_RX_PKT_LEN */
+#define RX_PKT_LEN_1518			0
+#define RX_PKT_LEN_1536			1
+#define RX_PKT_LEN_1522			2
+#define RX_PKT_LEN_MAX_JUMBO	3
+
+/* Fields of PMSR */
+#define EEE1G_STS			BIT(7)
+#define EEE100_STS			BIT(6)
+#define RX_FC_STS			BIT(5)
+#define TX_FC_STS			BIT(4)
+#define MAC_SPD_STS_S		28
+#define MAC_SPD_STS_M		0x70000000
+#define MAC_DPX_STS			BIT(25)
+#define MAC_LNK_STS			BIT(24)
+
+/* Values of MAC_SPD_STS */
+#define MAC_SPD_10			0
+#define MAC_SPD_100			1
+#define MAC_SPD_1000		2
+#define MAC_SPD_2500		3
+
+#define MIB_COUNTER_BASE			0x10214000
+#define MIB_COUNTER_PORT_OFFSET		0x200
+#define MIB_COUNTER_REG(p, r)		(MIB_COUNTER_BASE + \
+					(p) * MIB_COUNTER_PORT_OFFSET + (r))
+#define STATS_TDPC			0x00
+#define STATS_TCRC			0x04
+#define STATS_TUPC			0x08
+#define STATS_TMPC			0x0C
+#define STATS_TBPC			0x10
+#define STATS_TCEC			0x14
+#define STATS_TSCEC			0x18
+#define STATS_TMCEC			0x1C
+#define STATS_TDEC			0x20
+#define STATS_TLCEC			0x24
+#define STATS_TXCEC			0x28
+#define STATS_TPPC			0x2C
+#define STATS_TL64PC		0x30
+#define STATS_TL65PC		0x34
+#define STATS_TL128PC		0x38
+#define STATS_TL256PC		0x3C
+#define STATS_TL512PC		0x40
+#define STATS_TL1024PC		0x44
+#define STATS_TL1519PC		0x48
+#define STATS_TOC			0x4C
+#define STATS_TODPC			0x54
+#define STATS_TOC2			0x58
+
+#define STATS_RDPC			0x80
+#define STATS_RFPC			0x84
+#define STATS_RUPC			0x88
+#define STATS_RMPC			0x8C
+#define STATS_RBPC			0x90
+#define STATS_RAEPC			0x94
+#define STATS_RCEPC			0x98
+#define STATS_RUSPC			0x9C
+#define STATS_RFEPC			0xA0
+#define STATS_ROSPC			0xA4
+#define STATS_RJEPC			0xA8
+#define STATS_RPPC			0xAC
+#define STATS_RL64PC		0xB0
+#define STATS_RL65PC		0xB4
+#define STATS_RL128PC		0xB8
+#define STATS_RL256PC		0xBC
+#define STATS_RL512PC		0xC0
+#define STATS_RL1024PC		0xC4
+#define STATS_RL1519PC		0xC8
+#define STATS_ROC			0xCC
+#define STATS_RDPC_CTRL		0xD4
+#define STATS_RDPC_ING		0xD8
+#define STATS_RDPC_ARL		0xDC
+#define STATS_RDPC_FC		0xE0
+#define STATS_RDPC_WRED		0xE4
+#define STATS_RDPC_MIR		0xE8
+#define STATS_ROC2			0xEC
+#define STATS_RSFSPC		0xF4
+#define STATS_RSFTPC		0xF8
+#define STATS_RXCDPC		0xFC
+
+#define RG_CLK_CPU_ICG		0x10005034
+#define MCU_ENABLE			BIT(3)
+
+#define RG_TIMER_CTL		0x1000a100
+#define WDOG_ENABLE			BIT(25)
+
+#define SYS_CTRL			0x100050C0
+#define SW_SYS_RST			BIT(31)
+
+#define INT_MASK			0x100050F0
+#define INT_SYS_BIT			BIT(15)
+
+#define SYS_INT_EN			0x1021C010
+#define SYS_INT_STS			0x1021C014
+#define PHY_LC_INT(p)		BIT(p)
+
+#define CKGCR				0x10213E1C
+#define CKG_LNKDN_GLB_STOP	0x01
+#define CKG_LNKDN_PORT_STOP	0x02
+
+#define PKG_SEL				0x10000094
+#define PAG_SEL_AN8855H		0x2
+#endif /* _AN8855_REGS_H_ */
diff --git a/drivers/net/phy/airoha/an8855/an8855_swconfig.c b/drivers/net/phy/airoha/an8855/an8855_swconfig.c
new file mode 100644
index 0000000..2dd2ffd
--- /dev/null
+++ b/drivers/net/phy/airoha/an8855/an8855_swconfig.c
@@ -0,0 +1,529 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2023 Airoha Inc.
+ * Author: Min Yao <min.yao@airoha.com>
+ */
+
+#include <linux/if.h>
+#include <linux/list.h>
+#include <linux/if_ether.h>
+#include <linux/skbuff.h>
+#include <linux/netdevice.h>
+#include <linux/netlink.h>
+#include <linux/bitops.h>
+#include <net/genetlink.h>
+#include <linux/delay.h>
+#include <linux/phy.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/lockdep.h>
+#include <linux/workqueue.h>
+#include <linux/of_device.h>
+
+#include "an8855.h"
+#include "an8855_swconfig.h"
+#include "an8855_regs.h"
+
+#define AN8855_PORT_MIB_TXB_ID	19	/* TxByte */
+#define AN8855_PORT_MIB_RXB_ID	40	/* RxByte */
+
+#define MIB_DESC(_s, _o, _n)   \
+	{						\
+		.size = (_s),	\
+		.offset = (_o), \
+		.name = (_n),	\
+	}
+
+struct an8855_mib_desc {
+	unsigned int size;
+	unsigned int offset;
+	const char *name;
+};
+
+static const struct an8855_mib_desc an8855_mibs[] = {
+	MIB_DESC(1, STATS_TDPC, "TxDrop"),
+	MIB_DESC(1, STATS_TCRC, "TxCRC"),
+	MIB_DESC(1, STATS_TUPC, "TxUni"),
+	MIB_DESC(1, STATS_TMPC, "TxMulti"),
+	MIB_DESC(1, STATS_TBPC, "TxBroad"),
+	MIB_DESC(1, STATS_TCEC, "TxCollision"),
+	MIB_DESC(1, STATS_TSCEC, "TxSingleCol"),
+	MIB_DESC(1, STATS_TMCEC, "TxMultiCol"),
+	MIB_DESC(1, STATS_TDEC, "TxDefer"),
+	MIB_DESC(1, STATS_TLCEC, "TxLateCol"),
+	MIB_DESC(1, STATS_TXCEC, "TxExcCol"),
+	MIB_DESC(1, STATS_TPPC, "TxPause"),
+	MIB_DESC(1, STATS_TL64PC, "Tx64Byte"),
+	MIB_DESC(1, STATS_TL65PC, "Tx65Byte"),
+	MIB_DESC(1, STATS_TL128PC, "Tx128Byte"),
+	MIB_DESC(1, STATS_TL256PC, "Tx256Byte"),
+	MIB_DESC(1, STATS_TL512PC, "Tx512Byte"),
+	MIB_DESC(1, STATS_TL1024PC, "Tx1024Byte"),
+	MIB_DESC(1, STATS_TL1519PC, "Tx1519Byte"),
+	MIB_DESC(2, STATS_TOC, "TxByte"),
+	MIB_DESC(1, STATS_TODPC, "TxOverSize"),
+	MIB_DESC(2, STATS_TOC2, "SecondaryTxByte"),
+	MIB_DESC(1, STATS_RDPC, "RxDrop"),
+	MIB_DESC(1, STATS_RFPC, "RxFiltered"),
+	MIB_DESC(1, STATS_RUPC, "RxUni"),
+	MIB_DESC(1, STATS_RMPC, "RxMulti"),
+	MIB_DESC(1, STATS_RBPC, "RxBroad"),
+	MIB_DESC(1, STATS_RAEPC, "RxAlignErr"),
+	MIB_DESC(1, STATS_RCEPC, "RxCRC"),
+	MIB_DESC(1, STATS_RUSPC, "RxUnderSize"),
+	MIB_DESC(1, STATS_RFEPC, "RxFragment"),
+	MIB_DESC(1, STATS_ROSPC, "RxOverSize"),
+	MIB_DESC(1, STATS_RJEPC, "RxJabber"),
+	MIB_DESC(1, STATS_RPPC, "RxPause"),
+	MIB_DESC(1, STATS_RL64PC, "Rx64Byte"),
+	MIB_DESC(1, STATS_RL65PC, "Rx65Byte"),
+	MIB_DESC(1, STATS_RL128PC, "Rx128Byte"),
+	MIB_DESC(1, STATS_RL256PC, "Rx256Byte"),
+	MIB_DESC(1, STATS_RL512PC, "Rx512Byte"),
+	MIB_DESC(1, STATS_RL1024PC, "Rx1024Byte"),
+	MIB_DESC(2, STATS_ROC, "RxByte"),
+	MIB_DESC(1, STATS_RDPC_CTRL, "RxCtrlDrop"),
+	MIB_DESC(1, STATS_RDPC_ING, "RxIngDrop"),
+	MIB_DESC(1, STATS_RDPC_ARL, "RxARLDrop"),
+	MIB_DESC(1, STATS_RDPC_FC, "RxFCDrop"),
+	MIB_DESC(1, STATS_RDPC_WRED, "RxWREDDrop"),
+	MIB_DESC(1, STATS_RDPC_MIR, "RxMIRDrop"),
+	MIB_DESC(2, STATS_ROC2, "SecondaryRxByte"),
+	MIB_DESC(1, STATS_RSFSPC, "RxsFlowSampling"),
+	MIB_DESC(1, STATS_RSFTPC, "RxsFlowTotal"),
+	MIB_DESC(1, STATS_RXCDPC, "RxPortDrop"),
+};
+
+enum {
+	/* Global attributes. */
+	AN8855_ATTR_ENABLE_VLAN,
+};
+
+static int an8855_get_vlan_enable(struct switch_dev *dev,
+				  const struct switch_attr *attr,
+				  struct switch_val *val)
+{
+	struct gsw_an8855 *gsw = container_of(dev, struct gsw_an8855, swdev);
+
+	val->value.i = gsw->global_vlan_enable;
+
+	return 0;
+}
+
+static int an8855_set_vlan_enable(struct switch_dev *dev,
+				  const struct switch_attr *attr,
+				  struct switch_val *val)
+{
+	struct gsw_an8855 *gsw = container_of(dev, struct gsw_an8855, swdev);
+
+	gsw->global_vlan_enable = val->value.i != 0;
+
+	return 0;
+}
+
+static int an8855_get_port_pvid(struct switch_dev *dev, int port, int *val)
+{
+	struct gsw_an8855 *gsw = container_of(dev, struct gsw_an8855, swdev);
+
+	if (port < 0 || port >= AN8855_NUM_PORTS)
+		return -EINVAL;
+
+	*val = an8855_reg_read(gsw, PVID(port));
+	*val &= GRP_PORT_VID_M;
+
+	return 0;
+}
+
+static int an8855_set_port_pvid(struct switch_dev *dev, int port, int pvid)
+{
+	struct gsw_an8855 *gsw = container_of(dev, struct gsw_an8855, swdev);
+
+	if (port < 0 || port >= AN8855_NUM_PORTS)
+		return -EINVAL;
+
+	if (pvid < AN8855_MIN_VID || pvid > AN8855_MAX_VID)
+		return -EINVAL;
+
+	gsw->port_entries[port].pvid = pvid;
+
+	return 0;
+}
+
+static int an8855_get_vlan_ports(struct switch_dev *dev, struct switch_val *val)
+{
+	struct gsw_an8855 *gsw = container_of(dev, struct gsw_an8855, swdev);
+	u32 member;
+	u32 etags;
+	int i;
+
+	val->len = 0;
+
+	if (val->port_vlan >= AN8855_NUM_VLANS)
+		return -EINVAL;
+
+	an8855_vlan_ctrl(gsw, VTCR_READ_VLAN_ENTRY, val->port_vlan);
+
+	member = an8855_reg_read(gsw, VARD0);
+	member &= PORT_MEM_M;
+	member >>= PORT_MEM_S;
+	member |= ((an8855_reg_read(gsw, VARD1) & 0x1) << 6);
+
+	etags = an8855_reg_read(gsw, VARD0) & ETAG_M;
+
+	for (i = 0; i < AN8855_NUM_PORTS; i++) {
+		struct switch_port *p;
+		int etag;
+
+		if (!(member & BIT(i)))
+			continue;
+
+		p = &val->value.ports[val->len++];
+		p->id = i;
+
+		etag = (etags >> PORT_ETAG_S(i)) & PORT_ETAG_M;
+
+		if (etag == ETAG_CTRL_TAG)
+			p->flags |= BIT(SWITCH_PORT_FLAG_TAGGED);
+		else if (etag != ETAG_CTRL_UNTAG)
+			dev_info(gsw->dev,
+				 "vlan egress tag control neither untag nor tag.\n");
+	}
+
+	return 0;
+}
+
+static int an8855_set_vlan_ports(struct switch_dev *dev, struct switch_val *val)
+{
+	struct gsw_an8855 *gsw = container_of(dev, struct gsw_an8855, swdev);
+	u8 member = 0;
+	u8 etags = 0;
+	int i;
+
+	if (val->port_vlan >= AN8855_NUM_VLANS ||
+		val->len > AN8855_NUM_PORTS)
+		return -EINVAL;
+
+	for (i = 0; i < val->len; i++) {
+		struct switch_port *p = &val->value.ports[i];
+
+		if (p->id >= AN8855_NUM_PORTS)
+			return -EINVAL;
+
+		member |= BIT(p->id);
+
+		if (p->flags & BIT(SWITCH_PORT_FLAG_TAGGED))
+			etags |= BIT(p->id);
+	}
+
+	gsw->vlan_entries[val->port_vlan].member = member;
+	gsw->vlan_entries[val->port_vlan].etags = etags;
+
+	return 0;
+}
+
+static int an8855_set_vid(struct switch_dev *dev,
+			  const struct switch_attr *attr,
+			  struct switch_val *val)
+{
+	struct gsw_an8855 *gsw = container_of(dev, struct gsw_an8855, swdev);
+	int vlan;
+	u16 vid;
+
+	vlan = val->port_vlan;
+	vid = (u16)val->value.i;
+
+	if (vlan < 0 || vlan >= AN8855_NUM_VLANS)
+		return -EINVAL;
+
+	if (vid > AN8855_MAX_VID)
+		return -EINVAL;
+
+	gsw->vlan_entries[vlan].vid = vid;
+	return 0;
+}
+
+static int an8855_get_vid(struct switch_dev *dev,
+			  const struct switch_attr *attr,
+			  struct switch_val *val)
+{
+	val->value.i = val->port_vlan;
+	return 0;
+}
+
+static int an8855_get_port_link(struct switch_dev *dev, int port,
+				struct switch_port_link *link)
+{
+	struct gsw_an8855 *gsw = container_of(dev, struct gsw_an8855, swdev);
+	u32 speed, pmsr;
+
+	if (port < 0 || port >= AN8855_NUM_PORTS)
+		return -EINVAL;
+
+	pmsr = an8855_reg_read(gsw, PMSR(port));
+
+	link->link = pmsr & MAC_LNK_STS;
+	link->duplex = pmsr & MAC_DPX_STS;
+	speed = (pmsr & MAC_SPD_STS_M) >> MAC_SPD_STS_S;
+
+	switch (speed) {
+	case MAC_SPD_10:
+		link->speed = SWITCH_PORT_SPEED_10;
+		break;
+	case MAC_SPD_100:
+		link->speed = SWITCH_PORT_SPEED_100;
+		break;
+	case MAC_SPD_1000:
+		link->speed = SWITCH_PORT_SPEED_1000;
+		break;
+	case MAC_SPD_2500:
+		/* TODO: swconfig has no support for 2500 now */
+		link->speed = SWITCH_PORT_SPEED_UNKNOWN;
+		break;
+	}
+
+	return 0;
+}
+
+static int an8855_set_port_link(struct switch_dev *dev, int port,
+				struct switch_port_link *link)
+{
+#ifndef MODULE
+	if (port >= AN8855_NUM_PHYS)
+		return -EINVAL;
+
+	return switch_generic_set_link(dev, port, link);
+#else
+	return -ENOTSUPP;
+#endif
+}
+
+static u64 get_mib_counter(struct gsw_an8855 *gsw, int i, int port)
+{
+	unsigned int offset;
+	u64 lo = 0, hi = 0, hi2 = 0;
+
+	if (i >= 0) {
+		offset = an8855_mibs[i].offset;
+
+		if (an8855_mibs[i].size == 1)
+			return an8855_reg_read(gsw, MIB_COUNTER_REG(port, offset));
+
+		do {
+			hi = an8855_reg_read(gsw, MIB_COUNTER_REG(port, offset + 4));
+			lo = an8855_reg_read(gsw, MIB_COUNTER_REG(port, offset));
+			hi2 = an8855_reg_read(gsw, MIB_COUNTER_REG(port, offset + 4));
+		} while (hi2 != hi);
+	}
+
+	return (hi << 32) | lo;
+}
+
+static int an8855_get_port_mib(struct switch_dev *dev,
+				   const struct switch_attr *attr,
+				   struct switch_val *val)
+{
+	static char buf[4096];
+	struct gsw_an8855 *gsw = container_of(dev, struct gsw_an8855, swdev);
+	int i, len = 0;
+
+	if (val->port_vlan >= AN8855_NUM_PORTS)
+		return -EINVAL;
+
+	len += snprintf(buf + len, sizeof(buf) - len,
+			"Port %d MIB counters\n", val->port_vlan);
+
+	for (i = 0; i < ARRAY_SIZE(an8855_mibs); ++i) {
+		u64 counter;
+
+		len += snprintf(buf + len, sizeof(buf) - len,
+				"%-11s: ", an8855_mibs[i].name);
+		counter = get_mib_counter(gsw, i, val->port_vlan);
+		len += snprintf(buf + len, sizeof(buf) - len, "%llu\n",
+				counter);
+	}
+
+	val->value.s = buf;
+	val->len = len;
+	return 0;
+}
+
+static int an8855_get_port_stats(struct switch_dev *dev, int port,
+				 struct switch_port_stats *stats)
+{
+	struct gsw_an8855 *gsw = container_of(dev, struct gsw_an8855, swdev);
+
+	if (port < 0 || port >= AN8855_NUM_PORTS)
+		return -EINVAL;
+
+	stats->tx_bytes = get_mib_counter(gsw, AN8855_PORT_MIB_TXB_ID, port);
+	stats->rx_bytes = get_mib_counter(gsw, AN8855_PORT_MIB_RXB_ID, port);
+
+	return 0;
+}
+
+static void an8855_port_isolation(struct gsw_an8855 *gsw)
+{
+	int i;
+
+	for (i = 0; i < AN8855_NUM_PORTS; i++)
+		an8855_reg_write(gsw, PORTMATRIX(i),
+				 BIT(gsw->cpu_port));
+
+	an8855_reg_write(gsw, PORTMATRIX(gsw->cpu_port), PORT_MATRIX_M);
+
+	for (i = 0; i < AN8855_NUM_PORTS; i++) {
+		u32 pvc_mode = 0x9100 << STAG_VPID_S;
+
+		if (gsw->port5_cfg.stag_on && i == 5)
+			pvc_mode |= PVC_PORT_STAG | PVC_STAG_REPLACE;
+		else
+			pvc_mode |= (VA_TRANSPARENT_PORT << VLAN_ATTR_S);
+
+		an8855_reg_write(gsw, PVC(i), pvc_mode);
+	}
+}
+
+static int an8855_apply_config(struct switch_dev *dev)
+{
+	struct gsw_an8855 *gsw = container_of(dev, struct gsw_an8855, swdev);
+
+	if (!gsw->global_vlan_enable) {
+		an8855_port_isolation(gsw);
+		return 0;
+	}
+
+	an8855_apply_vlan_config(gsw);
+
+	return 0;
+}
+
+static int an8855_reset_switch(struct switch_dev *dev)
+{
+	struct gsw_an8855 *gsw = container_of(dev, struct gsw_an8855, swdev);
+	int i;
+
+	memset(gsw->port_entries, 0, sizeof(gsw->port_entries));
+	memset(gsw->vlan_entries, 0, sizeof(gsw->vlan_entries));
+
+	/* set default vid of each vlan to the same number of vlan, so the vid
+	 * won't need be set explicitly.
+	 */
+	for (i = 0; i < AN8855_NUM_VLANS; i++)
+		gsw->vlan_entries[i].vid = i;
+
+	return 0;
+}
+
+static int an8855_phy_read16(struct switch_dev *dev, int addr, u8 reg,
+				 u16 *value)
+{
+	struct gsw_an8855 *gsw = container_of(dev, struct gsw_an8855, swdev);
+
+	*value = gsw->mii_read(gsw, addr, reg);
+
+	return 0;
+}
+
+static int an8855_phy_write16(struct switch_dev *dev, int addr, u8 reg,
+				  u16 value)
+{
+	struct gsw_an8855 *gsw = container_of(dev, struct gsw_an8855, swdev);
+
+	gsw->mii_write(gsw, addr, reg, value);
+
+	return 0;
+}
+
+static const struct switch_attr an8855_global[] = {
+	{
+		.type = SWITCH_TYPE_INT,
+		.name = "enable_vlan",
+		.description = "VLAN mode (1:enabled)",
+		.max = 1,
+		.id = AN8855_ATTR_ENABLE_VLAN,
+		.get = an8855_get_vlan_enable,
+		.set = an8855_set_vlan_enable,
+	}
+};
+
+static const struct switch_attr an8855_port[] = {
+	{
+		.type = SWITCH_TYPE_STRING,
+		.name = "mib",
+		.description = "Get MIB counters for port",
+		.get = an8855_get_port_mib,
+		.set = NULL,
+	},
+};
+
+static const struct switch_attr an8855_vlan[] = {
+	{
+		.type = SWITCH_TYPE_INT,
+		.name = "vid",
+		.description = "VLAN ID (0-4094)",
+		.set = an8855_set_vid,
+		.get = an8855_get_vid,
+		.max = 4094,
+	},
+};
+
+static const struct switch_dev_ops an8855_swdev_ops = {
+	.attr_global = {
+		.attr = an8855_global,
+		.n_attr = ARRAY_SIZE(an8855_global),
+	},
+	.attr_port = {
+		.attr = an8855_port,
+		.n_attr = ARRAY_SIZE(an8855_port),
+	},
+	.attr_vlan = {
+		.attr = an8855_vlan,
+		.n_attr = ARRAY_SIZE(an8855_vlan),
+	},
+	.get_vlan_ports = an8855_get_vlan_ports,
+	.set_vlan_ports = an8855_set_vlan_ports,
+	.get_port_pvid = an8855_get_port_pvid,
+	.set_port_pvid = an8855_set_port_pvid,
+	.get_port_link = an8855_get_port_link,
+	.set_port_link = an8855_set_port_link,
+	.get_port_stats = an8855_get_port_stats,
+	.apply_config = an8855_apply_config,
+	.reset_switch = an8855_reset_switch,
+	.phy_read16 = an8855_phy_read16,
+	.phy_write16 = an8855_phy_write16,
+};
+
+int an8855_swconfig_init(struct gsw_an8855 *gsw)
+{
+	struct device_node *np = gsw->dev->of_node;
+	struct switch_dev *swdev;
+	int ret;
+
+	if (of_property_read_u32(np, "airoha,cpuport", &gsw->cpu_port))
+		gsw->cpu_port = AN8855_DFL_CPU_PORT;
+
+	swdev = &gsw->swdev;
+
+	swdev->name = gsw->name;
+	swdev->alias = gsw->name;
+	swdev->cpu_port = gsw->cpu_port;
+	swdev->ports = AN8855_NUM_PORTS;
+	swdev->vlans = AN8855_NUM_VLANS;
+	swdev->ops = &an8855_swdev_ops;
+
+	ret = register_switch(swdev, NULL);
+	if (ret) {
+		dev_notice(gsw->dev, "Failed to register switch %s\n",
+			   swdev->name);
+		return ret;
+	}
+
+	an8855_apply_config(swdev);
+
+	return 0;
+}
+
+void an8855_swconfig_destroy(struct gsw_an8855 *gsw)
+{
+	unregister_switch(&gsw->swdev);
+}
diff --git a/drivers/net/phy/airoha/an8855/an8855_swconfig.h b/drivers/net/phy/airoha/an8855/an8855_swconfig.h
new file mode 100644
index 0000000..4c8f2bf
--- /dev/null
+++ b/drivers/net/phy/airoha/an8855/an8855_swconfig.h
@@ -0,0 +1,29 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (c) 2023 Airoha Inc.
+ * Author: Min Yao <min.yao@airoha.com>
+ */
+
+#ifndef _AN8855_SWCONFIG_H_
+#define _AN8855_SWCONFIG_H_
+
+#ifdef CONFIG_SWCONFIG
+#include <linux/switch.h>
+#include "an8855.h"
+
+int an8855_swconfig_init(struct gsw_an8855 *gsw);
+void an8855_swconfig_destroy(struct gsw_an8855 *gsw);
+#else
+static inline int an8855_swconfig_init(struct gsw_an8855 *gsw)
+{
+	an8855_apply_vlan_config(gsw);
+
+	return 0;
+}
+
+static inline void an8855_swconfig_destroy(struct gsw_an8855 *gsw)
+{
+}
+#endif
+
+#endif /* _AN8855_SWCONFIG_H_ */
diff --git a/drivers/net/phy/airoha/an8855/an8855_vlan.c b/drivers/net/phy/airoha/an8855/an8855_vlan.c
new file mode 100644
index 0000000..1a1d751
--- /dev/null
+++ b/drivers/net/phy/airoha/an8855/an8855_vlan.c
@@ -0,0 +1,200 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2023 Airoha Inc.
+ */
+
+#include "an8855.h"
+#include "an8855_regs.h"
+
+struct an8855_mapping an8855_def_mapping[] = {
+	{
+		.name = "llllw",
+		.pvids = { 1, 1, 1, 1, 2, 1 },
+		.members = { 0, 0x2f, 0x30 },
+		.etags = { 0, 0, 0 },
+		.vids = { 0, 1, 2 },
+	}, {
+		.name = "wllll",
+		.pvids = { 2, 1, 1, 1, 1, 1 },
+		.members = { 0, 0x3e, 0x21 },
+		.etags = { 0, 0, 0 },
+		.vids = { 0, 1, 2 },
+	}, {
+		.name = "lwlll",
+		.pvids = { 1, 2, 1, 1, 1, 1 },
+		.members = { 0, 0x3d, 0x22 },
+		.etags = { 0, 0, 0 },
+		.vids = { 0, 1, 2 },
+	}, {
+		.name = "lllll",
+		.pvids = { 1, 1, 1, 1, 1, 1 },
+		.members = { 0, 0x3f },
+		.etags = { 0, 0 },
+		.vids = { 0, 1 },
+	},
+};
+
+void an8855_vlan_ctrl(struct gsw_an8855 *gsw, u32 cmd, u32 val)
+{
+	int i;
+
+	an8855_reg_write(gsw, VTCR,
+			 VTCR_BUSY | ((cmd << VTCR_FUNC_S) & VTCR_FUNC_M) |
+			 (val & VTCR_VID_M));
+
+	for (i = 0; i < 300; i++) {
+		u32 val = an8855_reg_read(gsw, VTCR);
+
+		if ((val & VTCR_BUSY) == 0)
+			break;
+
+		usleep_range(1000, 1100);
+	}
+
+	if (i == 300)
+		dev_info(gsw->dev, "vtcr timeout\n");
+}
+
+static void an8855_write_vlan_entry(struct gsw_an8855 *gsw, int vlan, u16 vid,
+					u8 ports, u8 etags)
+{
+	int port;
+	u32 val;
+
+	/* vlan port membership */
+	if (ports) {
+		val = IVL_MAC | VTAG_EN | VENTRY_VALID
+			| ((ports << PORT_MEM_S) & PORT_MEM_M);
+		/* egress mode */
+		for (port = 0; port < AN8855_NUM_PORTS; port++) {
+			if (etags & BIT(port))
+				val |= (ETAG_CTRL_TAG << PORT_ETAG_S(port));
+			else
+				val |= (ETAG_CTRL_UNTAG << PORT_ETAG_S(port));
+		}
+		an8855_reg_write(gsw, VAWD0, val);
+	} else {
+		an8855_reg_write(gsw, VAWD0, 0);
+	}
+
+	if (ports & 0x40)
+		an8855_reg_write(gsw, VAWD1, 0x1);
+	else
+		an8855_reg_write(gsw, VAWD1, 0x0);
+
+	/* write to vlan table */
+	an8855_vlan_ctrl(gsw, VTCR_WRITE_VLAN_ENTRY, vid);
+}
+
+void an8855_apply_vlan_config(struct gsw_an8855 *gsw)
+{
+	int i, j;
+	u8 tag_ports;
+	u8 untag_ports;
+	u32 val;
+
+	/* set all ports as security mode */
+	for (i = 0; i < AN8855_NUM_PORTS; i++) {
+		val = an8855_reg_read(gsw, PCR(i));
+		an8855_reg_write(gsw, PCR(i), val | SECURITY_MODE);
+		an8855_reg_write(gsw, PORTMATRIX(i), PORT_MATRIX_M);
+	}
+
+	/* check if a port is used in tag/untag vlan egress mode */
+	tag_ports = 0;
+	untag_ports = 0;
+
+	for (i = 0; i < AN8855_NUM_VLANS; i++) {
+		u8 member = gsw->vlan_entries[i].member;
+		u8 etags = gsw->vlan_entries[i].etags;
+
+		if (!member)
+			continue;
+
+		for (j = 0; j < AN8855_NUM_PORTS; j++) {
+			if (!(member & BIT(j)))
+				continue;
+
+			if (etags & BIT(j))
+				tag_ports |= 1u << j;
+			else
+				untag_ports |= 1u << j;
+		}
+	}
+
+	/* set all untag-only ports as transparent and the rest as user port */
+	for (i = 0; i < AN8855_NUM_PORTS; i++) {
+		u32 pvc_mode = 0x9100 << STAG_VPID_S;
+
+		if (untag_ports & BIT(i) && !(tag_ports & BIT(i)))
+			pvc_mode = (0x9100 << STAG_VPID_S) |
+				(VA_TRANSPARENT_PORT << VLAN_ATTR_S);
+
+		if (gsw->port5_cfg.stag_on && i == 5)
+			pvc_mode = (u32)((0x9100 << STAG_VPID_S) | PVC_PORT_STAG
+						| PVC_STAG_REPLACE);
+
+		an8855_reg_write(gsw, PVC(i), pvc_mode);
+	}
+
+	/* first clear the switch vlan table */
+	for (i = 0; i < AN8855_NUM_VLANS; i++)
+		an8855_write_vlan_entry(gsw, i, i, 0, 0);
+
+	/* now program only vlans with members to avoid
+	 * clobbering remapped entries in later iterations
+	 */
+	for (i = 0; i < AN8855_NUM_VLANS; i++) {
+		u16 vid = gsw->vlan_entries[i].vid;
+		u8 member = gsw->vlan_entries[i].member;
+		u8 etags = gsw->vlan_entries[i].etags;
+
+		if (member)
+			an8855_write_vlan_entry(gsw, i, vid, member, etags);
+	}
+
+	/* Port Default PVID */
+	for (i = 0; i < AN8855_NUM_PORTS; i++) {
+		int vlan = gsw->port_entries[i].pvid;
+		u16 pvid = 0;
+		u32 val;
+
+		if ((vlan >= 0) && (vlan < AN8855_NUM_VLANS)
+			&& (gsw->vlan_entries[vlan].member))
+			pvid = gsw->vlan_entries[vlan].vid;
+
+		val = an8855_reg_read(gsw, PVID(i));
+		val &= ~GRP_PORT_VID_M;
+		val |= pvid;
+		an8855_reg_write(gsw, PVID(i), val);
+	}
+}
+
+struct an8855_mapping *an8855_find_mapping(struct device_node *np)
+{
+	const char *map;
+	int i;
+
+	if (of_property_read_string(np, "airoha,portmap", &map))
+		return NULL;
+
+	for (i = 0; i < ARRAY_SIZE(an8855_def_mapping); i++)
+		if (!strcmp(map, an8855_def_mapping[i].name))
+			return &an8855_def_mapping[i];
+
+	return NULL;
+}
+
+void an8855_apply_mapping(struct gsw_an8855 *gsw, struct an8855_mapping *map)
+{
+	int i = 0;
+
+	for (i = 0; i < AN8855_NUM_PORTS; i++)
+		gsw->port_entries[i].pvid = map->pvids[i];
+
+	for (i = 0; i < AN8855_NUM_VLANS; i++) {
+		gsw->vlan_entries[i].member = map->members[i];
+		gsw->vlan_entries[i].etags = map->etags[i];
+		gsw->vlan_entries[i].vid = map->vids[i];
+	}
+}
diff --git a/drivers/net/phy/airoha/an8855/an8855_vlan.h b/drivers/net/phy/airoha/an8855/an8855_vlan.h
new file mode 100644
index 0000000..d2cd68a
--- /dev/null
+++ b/drivers/net/phy/airoha/an8855/an8855_vlan.h
@@ -0,0 +1,40 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (c) 2023 Airoha Inc.
+ */
+
+#ifndef _AN8855_VLAN_H_
+#define _AN8855_VLAN_H_
+
+#define AN8855_NUM_PORTS	6
+#define AN8855_NUM_VLANS	4095
+#define AN8855_MAX_VID		4095
+#define AN8855_MIN_VID		0
+
+struct gsw_an8855;
+
+struct an8855_port_entry {
+	u16	pvid;
+};
+
+struct an8855_vlan_entry {
+	u16	vid;
+	u8	member;
+	u8	etags;
+};
+
+struct an8855_mapping {
+	char	*name;
+	u16	pvids[AN8855_NUM_PORTS];
+	u8	members[AN8855_NUM_VLANS];
+	u8	etags[AN8855_NUM_VLANS];
+	u16	vids[AN8855_NUM_VLANS];
+};
+
+extern struct an8855_mapping an8855_defaults[];
+
+void an8855_vlan_ctrl(struct gsw_an8855 *gsw, u32 cmd, u32 val);
+void an8855_apply_vlan_config(struct gsw_an8855 *gsw);
+struct an8855_mapping *an8855_find_mapping(struct device_node *np);
+void an8855_apply_mapping(struct gsw_an8855 *gsw, struct an8855_mapping *map);
+#endif /* _AN8855_VLAN_H_ */
-- 
2.45.2

