From eecc1e7982d4f5da63b129e5437d79ced3aeb26f Mon Sep 17 00:00:00 2001
From: Sam Shih <sam.shih@mediatek.com>
Date: Mon, 3 Mar 2025 14:38:41 +0800
Subject: [PATCH] add pwm hw breathing light support for mt7987

---
 drivers/pwm/pwm-mediatek.c | 118 ++++++++++++++++++++++++++++++++++++-
 1 file changed, 116 insertions(+), 2 deletions(-)

--- a/drivers/pwm/pwm-mediatek.c
+++ b/drivers/pwm/pwm-mediatek.c
@@ -31,6 +31,12 @@
 #define PWM45THRES_FIXUP	0x34
 #define PWM_CK_26M_SEL		0x210
 
+#define PWM_BREATHING_
+#define PWM_BREATHING_THRES_MAX	32
+#define PWM_BREATHING_CON	0xb8
+#define PWM_BREATHING_THRES_0	0xbc
+#define PWM_BREATHING_THRES_1	0xd0
+
 #define PWM_CLK_DIV_MAX		7
 
 struct pwm_mediatek_of_data {
@@ -38,6 +44,8 @@ struct pwm_mediatek_of_data {
 	bool pwm45_fixup;
 	bool has_ck_26m_sel;
 	const unsigned int *reg_offset;
+	int hw_breathing_light;
+	int hw_breathing_light_thres_num;
 };
 
 /**
@@ -54,6 +62,7 @@ struct pwm_mediatek_chip {
 	struct clk *clk_main;
 	struct clk **clk_pwms;
 	const struct pwm_mediatek_of_data *soc;
+	bool bw_mode[8];
 };
 
 static const unsigned int mtk_pwm_reg_offset_v1[] = {
@@ -139,34 +148,104 @@ static void pwm_mediatek_disable(struct
 	writel(value, pc->regs);
 }
 
-static int pwm_mediatek_config(struct pwm_chip *chip, struct pwm_device *pwm,
-			       int duty_ns, int period_ns)
+static inline int pwm_bl_set_thres(struct pwm_mediatek_chip *chip, int pwm,
+				    int idx, int value, int scale)
 {
-	struct pwm_mediatek_chip *pc = to_pwm_mediatek_chip(chip);
-	/* The source clock is divided by 2^clkdiv or iff the clksel bit
-	 * is set by (2^clkdiv*1625)
-	 */
-	u32 clkdiv = 0, clksel = 0, cnt_period, cnt_duty,
-	    reg_width = PWMDWIDTH, reg_thres = PWMTHRES;
+	u32 offset;
+	u32 shift;
+	u32 tmp;
 
-	unsigned long clk_rate;
-	u64 resolution;
+	value = value / scale;
+	if ((idx < 0) || (idx >= PWM_BREATHING_THRES_MAX))
+		return -EINVAL;
+	if ((value < 0) || (value > 255))
+		return -EINVAL;
+	if (idx < 4) {
+		offset = PWM_BREATHING_THRES_0;
+		shift = (idx % 4) * 8;
+	} else {
+		offset = PWM_BREATHING_THRES_1 + ((idx / 4) - 1) * 4;
+		shift = (idx % 4) * 8;
+	}
+	tmp = readl(chip->regs + mtk_pwm_reg_offset_v3[pwm] + offset);
+	tmp &= ~(0xff << shift);
+	tmp |= (value << shift);
+	writel(tmp, chip->regs + mtk_pwm_reg_offset_v3[pwm] + offset);
+
+	return 0;
+}
+
+static inline int pwm_config_bl_thres(struct pwm_mediatek_chip *chip, int pwm,
+				      int max_counter, int num_thres)
+{
+	/* use x_scale to make the wavefrom display smoothly */
+	const int x_scale = 1000;
+	int c, x;
 	int ret;
+	int i;
+	/*
+	 *  [Breathing Light Pattern]
+         *  - x         : max_counter / (num_thres / 2)
+         *  - 100% duty : (num_thres / 2) * x
+         *  - 0% duty   : 0 * x
+         *  - per period: T(0)~T(num_thres)
+	 *                (If period = 10^9 (ns), 1T = 10^9 (ns) / num_thres)
+         *
+	 *  | num_thres | T0 T1 T2 T3 T4 T5 T6 T7 T8 T9 10 11 12 13 14 15 ... |
+	 *  |-----------|-----------------------------------------------------|
+         *  | 8         | 4x 3x 2x 1x 0x 1x 2x 3x (repeat) .................. |
+	 *  | 16        | 8x 7x 6x 5x 4x 3x 2x 1x 0x 1x 2x 3x 4x 5x 6x 7x ... |
+	 *  | 24        | 12x ............................................... |
+	 *  | 32 (max)  | 16x ............................................... |
+	 */
+	int pattern[PWM_BREATHING_THRES_MAX];
 
-	ret = pwm_mediatek_clk_enable(chip, pwm);
-	if (ret < 0)
-		return ret;
+	if ((num_thres < 2) || (num_thres % 2))
+		return -EINVAL;
 
-	clk_rate = clk_get_rate(pc->clk_pwms[pwm->hwpwm]);
-	if (!clk_rate) {
-		ret = -EINVAL;
-		goto out;
+	c = num_thres / 2;
+	x = (max_counter * x_scale) / (num_thres / 2);
+
+	/* create breathing ligh pattern according to previous table */
+	/* use (x_scale * max_counter) instead of (x * num_thres) */
+	pattern[0] = max_counter * x_scale;
+	/* caculate each pattern according to (i) */
+	for (i = 1 ; i < c ; i++)
+		pattern[i] = x * (c - i);
+	for (i = c ; i < num_thres ; i++)
+		pattern[i] = x * (i - c);
+	for (i = 0 ; i < num_thres ; i++) {
+		ret = pwm_bl_set_thres(chip, pwm, i, pattern[i], x_scale);
+		if (ret)
+			return ret;
 	}
 
+	/* enable breathing light mode */
+	writel(((num_thres - 1) << 8 | 0x1),
+	       chip->regs + mtk_pwm_reg_offset_v3[pwm] + PWM_BREATHING_CON);
+
+	return 0;
+}
+
+static int pwm_mediatek_clk_resolution_config(struct pwm_chip *chip, struct pwm_device *pwm,
+					      u32 max_cnt_period, int period_ns,
+					      u64 *result_resolution)
+{
+	struct pwm_mediatek_chip *pc = to_pwm_mediatek_chip(chip);
+	u64 resolution;
+	u32 cnt_period;
+	u64 clk_rate;
+	u32 clkdiv = 0;
+	u32 clksel = 0;
+
 	/* Make sure we use the bus clock and not the 26MHz clock */
 	if (pc->soc->has_ck_26m_sel)
 		writel(0, pc->regs + PWM_CK_26M_SEL);
 
+	clk_rate = clk_get_rate(pc->clk_pwms[pwm->hwpwm]);
+	if (!clk_rate)
+		return -EINVAL;
+
 	/* Using resolution in picosecond gets accuracy higher */
 	resolution = (u64)NSEC_PER_SEC * 1000;
 	/* Calculate resolution based on current clock frequency */
@@ -179,7 +258,7 @@ static int pwm_mediatek_config(struct pw
 	if (!cnt_period)
 		return -EINVAL;
 
-	while (cnt_period > 8192) {
+	while (cnt_period > max_cnt_period) {
 		/* Using clkdiv to reduce clock frequency and calculate
 		 * new resolution based on new clock speed
 		 */
@@ -193,20 +272,83 @@ static int pwm_mediatek_config(struct pw
 			clksel = 1;
 			clkdiv = 0;
 			resolution = (u64)NSEC_PER_SEC * 1000 * 1625;
-			do_div(resolution,
-				clk_get_rate(pc->clk_pwms[pwm->hwpwm]));
+			do_div(resolution, clk_rate);
 		}
 		/* Calculate cnt_period based on resolution */
-		cnt_period = DIV_ROUND_CLOSEST_ULL((u64)period_ns * 1000,
-						   resolution);
+		cnt_period = DIV_ROUND_CLOSEST_ULL((u64)period_ns * 1000, resolution);
 	}
 
 	if (clkdiv > PWM_CLK_DIV_MAX) {
 		dev_err(pwmchip_parent(chip), "period of %d ns not supported\n", period_ns);
+		return -EINVAL;
+	}
+
+	if (clksel)
+		pwm_mediatek_writel(pc, pwm->hwpwm, PWMCON, BIT(15) | BIT(3) | clkdiv);
+	else
+		pwm_mediatek_writel(pc, pwm->hwpwm, PWMCON, BIT(15) | clkdiv);
+
+	*result_resolution = resolution;
+
+	return 0;
+}
+
+static int pwm_mediatek_breathing_config(struct pwm_chip *chip, struct pwm_device *pwm,
+					 int duty_ns, int period_ns)
+{
+	struct pwm_mediatek_chip *pc = to_pwm_mediatek_chip(chip);
+	int thres_num = pc->soc->hw_breathing_light_thres_num;
+	u32 max_cnt_period = 255;
+	u32 cnt_period;
+	u64 resolution;
+	int ret;
+
+	period_ns /= thres_num;
+
+	ret = pwm_mediatek_clk_enable(chip, pwm);
+	if (ret < 0)
+		return ret;
+
+	ret = pwm_mediatek_clk_resolution_config(chip, pwm, max_cnt_period, period_ns, &resolution);
+	if (ret)
+		goto out;
+
+	cnt_period = DIV_ROUND_CLOSEST_ULL((u64)period_ns * 1000, resolution);
+	if (!cnt_period) {
 		ret = -EINVAL;
 		goto out;
 	}
 
+	pwm_mediatek_writel(pc, pwm->hwpwm, PWMDWIDTH, cnt_period - 1);
+
+	/* use array of bw_thres instead of normal thres in bw_mode */
+	pwm_config_bl_thres(pc, pwm->hwpwm, cnt_period, thres_num);
+	pwm_mediatek_enable(chip, pwm);
+out:
+	pwm_mediatek_clk_disable(chip, pwm);
+
+	return ret;
+}
+
+static int pwm_mediatek_config(struct pwm_chip *chip, struct pwm_device *pwm,
+			       int duty_ns, int period_ns)
+{
+	struct pwm_mediatek_chip *pc = to_pwm_mediatek_chip(chip);
+	u32 reg_width = PWMDWIDTH, reg_thres = PWMTHRES;
+	u32 max_cnt_period = 8191;
+	u64 resolution;
+	u32 cnt_period;
+	u32 cnt_duty;
+	int ret;
+
+	ret = pwm_mediatek_clk_enable(chip, pwm);
+	if (ret < 0)
+		return ret;
+
+	ret = pwm_mediatek_clk_resolution_config(chip, pwm, max_cnt_period, period_ns, &resolution);
+	if (ret)
+		goto out;
+
 	if (pc->soc->pwm45_fixup && pwm->hwpwm > 2) {
 		/*
 		 * PWM[4,5] has distinct offset for PWMDWIDTH and PWMTHRES
@@ -216,22 +358,21 @@ static int pwm_mediatek_config(struct pw
 		reg_thres = PWM45THRES_FIXUP;
 	}
 
-	/* Calculate cnt_duty based on resolution */
+	cnt_period = DIV_ROUND_CLOSEST_ULL((u64)period_ns * 1000, resolution);
+	if (!cnt_period) {
+		ret = -EINVAL;
+		goto out;
+	}
 	cnt_duty = DIV_ROUND_CLOSEST_ULL((u64)duty_ns * 1000, resolution);
 
-	if (clksel)
-		pwm_mediatek_writel(pc, pwm->hwpwm, PWMCON, BIT(15) | BIT(3) | clkdiv);
-	else
-		pwm_mediatek_writel(pc, pwm->hwpwm, PWMCON, BIT(15) | clkdiv);
 	pwm_mediatek_writel(pc, pwm->hwpwm, reg_width, cnt_period - 1);
-
 	if (cnt_duty) {
+		/* use array of bw_thres instead of normal thres in bw_mode */
 		pwm_mediatek_writel(pc, pwm->hwpwm, reg_thres, cnt_duty - 1);
 		pwm_mediatek_enable(chip, pwm);
 	} else {
 		pwm_mediatek_disable(chip, pwm);
 	}
-
 out:
 	pwm_mediatek_clk_disable(chip, pwm);
 
@@ -241,6 +382,7 @@ out:
 static int pwm_mediatek_apply(struct pwm_chip *chip, struct pwm_device *pwm,
 			      const struct pwm_state *state)
 {
+	struct pwm_mediatek_chip *pc = to_pwm_mediatek_chip(chip);
 	int err;
 
 	if (state->polarity != PWM_POLARITY_NORMAL)
@@ -255,9 +397,15 @@ static int pwm_mediatek_apply(struct pwm
 		return 0;
 	}
 
-	err = pwm_mediatek_config(chip, pwm, state->duty_cycle, state->period);
-	if (err)
-		return err;
+	if (pc->bw_mode[pwm->hwpwm]) {
+		err = pwm_mediatek_breathing_config(chip, pwm, state->duty_cycle, state->period);
+		if (err)
+			return err;
+	} else {
+		err = pwm_mediatek_config(chip, pwm, state->duty_cycle, state->period);
+		if (err)
+			return err;
+	}
 
 	if (!pwm->state.enabled)
 		err = pwm_mediatek_clk_enable(chip, pwm);
@@ -271,6 +419,7 @@ static const struct pwm_ops pwm_mediatek
 
 static int pwm_mediatek_probe(struct platform_device *pdev)
 {
+	struct device_node *np = pdev->dev.of_node;
 	struct pwm_chip *chip;
 	struct pwm_mediatek_chip *pc;
 	const struct pwm_mediatek_of_data *soc;
@@ -307,6 +456,7 @@ static int pwm_mediatek_probe(struct pla
 
 	for (i = 0; i < soc->num_pwms; i++) {
 		char name[8];
+		char bw_name[32];
 
 		snprintf(name, sizeof(name), "pwm%d", i + 1);
 
@@ -314,6 +464,12 @@ static int pwm_mediatek_probe(struct pla
 		if (IS_ERR(pc->clk_pwms[i]))
 			return dev_err_probe(&pdev->dev, PTR_ERR(pc->clk_pwms[i]),
 					     "Failed to get %s clock\n", name);
+
+		if (pc->soc->hw_breathing_light) {
+			snprintf(bw_name, sizeof(bw_name),
+				 "mediatek,pwm%d-breathing-light", i);
+			pc->bw_mode[i] = of_property_read_bool(np, bw_name);
+		}
 	}
 
 	chip->ops = &pwm_mediatek_ops;
@@ -386,6 +542,8 @@ static const struct pwm_mediatek_of_data
 	.pwm45_fixup = false,
 	.has_ck_26m_sel = false,
 	.reg_offset = mtk_pwm_reg_offset_v3,
+	.hw_breathing_light = 1,
+	.hw_breathing_light_thres_num = 32,
 };
 
 static const struct pwm_mediatek_of_data mt7988_pwm_data = {
