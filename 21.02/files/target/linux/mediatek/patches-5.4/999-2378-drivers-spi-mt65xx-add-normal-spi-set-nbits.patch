--- a/drivers/spi/spi-mt65xx.c
+++ b/drivers/spi/spi-mt65xx.c
@@ -453,6 +453,27 @@ static void mtk_spi_setup_packet(struct
 	writel(reg_val, mdata->base + SPI_CFG1_REG);
 }
 
+inline u32 spi_set_nbit(u32 nbit)
+{
+	u32 ret = 0;
+
+	switch (nbit) {
+	case SPI_NBITS_SINGLE:
+		ret = 0x0;
+		break;
+	case SPI_NBITS_DUAL:
+		ret = 0x1;
+		break;
+	case SPI_NBITS_QUAD:
+		ret = 0x2;
+		break;
+	default:
+		pr_info("unknown spi nbit mode, use single mode!");
+		break;
+	}
+	return ret;
+}
+
 static void mtk_spi_enable_transfer(struct spi_master *master)
 {
 	u32 cmd;
@@ -619,10 +640,16 @@ static int mtk_spi_transfer_one(struct s
 
 	/* prepare xfer direction and duplex mode */
 	if (mdata->dev_comp->ipm_design) {
-		if (!xfer->tx_buf || !xfer->rx_buf) {
+		if (xfer->tx_buf && xfer->rx_buf)
+			reg_val &= ~SPI_CFG3_IPM_HALF_DUPLEX_EN;
+		else if (xfer->tx_buf) {
+			reg_val |= SPI_CFG3_IPM_HALF_DUPLEX_EN;
+			reg_val &= ~SPI_CFG3_IPM_HALF_DUPLEX_DIR;
+			reg_val |= spi_set_nbit(xfer->tx_nbits);
+		} else {
 			reg_val |= SPI_CFG3_IPM_HALF_DUPLEX_EN;
-			if (xfer->rx_buf)
-				reg_val |= SPI_CFG3_IPM_HALF_DUPLEX_DIR;
+			reg_val |= SPI_CFG3_IPM_HALF_DUPLEX_DIR;
+			reg_val |= spi_set_nbit(xfer->rx_nbits);
 		}
 		writel(reg_val, mdata->base + SPI_CFG3_IPM_REG);
 	}
